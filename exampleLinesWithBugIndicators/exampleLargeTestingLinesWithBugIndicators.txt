<START_FILE>
<a> </a> 0
<a> package org . atmosphere . grizzly ; </a> 0
<a> import com . sun . grizzly . SSLConfig ; </a> 1
<a> import com . sun . grizzly . comet . CometAsyncFilter ; </a> 1
<a> import com . sun . grizzly . http . embed . GrizzlyWebServer ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 1
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import java . io . IOException ; </a> 1
<a> import java . net . URI ; </a> 1
<a> public final class AtmosphereSpadeServer { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( AtmosphereSpadeServer . class ) ; </a> 1
<a> private final GrizzlyWebServer gws ; </a> 1
<a> private final AtmosphereAdapter aa = new AtmosphereAdapter ( ) ; </a> 1
<a> private boolean defaultToJersey = true ; </a> 1
<a> private AtmosphereSpadeServer ( int port , boolean secure ) { </a> 1
<a> gws = new GrizzlyWebServer ( port , "." , secure ) ; </a> 1
<a> gws . getSelectorThread ( ) . setDisplayConfiguration ( false ) ; </a> 1
<a> gws . addAsyncFilter ( new CometAsyncFilter ( ) ) ; </a> 1
<a> } </a> 1
<a> public static AtmosphereSpadeServer build ( String u ) { </a> 1
<a> return AtmosphereSpadeServer . build ( u , "" ) ; </a> 1
<a> } </a> 1
<a> public static AtmosphereSpadeServer build ( String u , String resourcesPackage ) { </a> 1
<a> return AtmosphereSpadeServer . build ( u , resourcesPackage , null ) ; </a> 1
<a> } </a> 1
<a> public static AtmosphereSpadeServer build ( String u , SSLConfig sslConfig ) { </a> 1
<a> return AtmosphereSpadeServer . build ( u , null , sslConfig ) ; </a> 1
<a> } </a> 1
<a> public static AtmosphereSpadeServer build ( String u , String resourcesPackage , SSLConfig sslConfig ) { </a> 1
<a> if ( u == null ) { </a> 1
<a> throw new IllegalArgumentException ( "The URI must not be null" ) ; </a> 1
<a> } </a> 1
<a> URI uri = URI . create ( u ) ; </a> 1
<a> final String scheme = uri . getScheme ( ) ; </a> 1
<a> if ( ! scheme . startsWith ( "http" ) ) </a> 1
<a> throw new IllegalArgumentException ( "The URI scheme, of the URI " + u + </a> 1
<a> ", must be equal (ignoring case) to 'http'" ) ; </a> 1
<a> final int port = ( uri . getPort ( ) == - 1 ) ? 80 : uri . getPort ( ) ; </a> 1
<a> String path = uri . getPath ( ) ; </a> 1
<a> if ( path == null ) { </a> 1
<a> throw new IllegalArgumentException ( "The URI path, of the URI " + uri + </a> 1
<a> ", must be non-null" ) ; </a> 1
<a> } else if ( path . length ( ) == 0 ) { </a> 1
<a> throw new IllegalArgumentException ( "The URI path, of the URI " + uri + </a> 1
<a> ", must be present" ) ; </a> 1
<a> } else if ( path . charAt ( 0 ) != '/' ) { </a> 1
<a> throw new IllegalArgumentException ( "The URI path, of the URI " + uri + </a> 1
<a> ". must start with a '/'" ) ; </a> 1
<a> } </a> 1
<a> boolean secure = false ; </a> 1
<a> if ( scheme . equalsIgnoreCase ( "https" ) ) { </a> 1
<a> secure = true ; </a> 1
<a> } </a> 1
<a> AtmosphereSpadeServer a = new AtmosphereSpadeServer ( port , secure ) ; </a> 1
<a> if ( path . length ( ) > 1 ) { </a> 1
<a> if ( path . endsWith ( "/" ) ) { </a> 1
<a> path = path . substring ( 0 , path . length ( ) - 1 ) ; </a> 1
<a> } </a> 1
<a> a . aa . setContextPath ( path ) ; </a> 1
<a> } </a> 1
<a> if ( resourcesPackage != null ) { </a> 1
<a> a . aa . setResourcePackage ( resourcesPackage ) ; </a> 1
<a> } </a> 1
<a> if ( sslConfig != null ) { </a> 1
<a> a . setSSLConfig ( sslConfig ) ; </a> 1
<a> } </a> 1
<a> return a ; </a> 1
<a> } </a> 1
<a> private void setSSLConfig ( SSLConfig sslConfig ) { </a> 1
<a> gws . setSSLConfig ( sslConfig ) ; </a> 1
<a> } </a> 1
<a> public AtmosphereSpadeServer addAtmosphereHandler ( String mapping , AtmosphereHandler h ) { </a> 1
<a> defaultToJersey = false ; </a> 1
<a> AtmosphereAdapter a = new AtmosphereAdapter ( ) ; </a> 1
<a> a . setServletInstance ( aa . getServletInstance ( ) ) ; </a> 1
<a> a . addAtmosphereHandler ( mapping , h ) ; </a> 1
<a> a . setServletPath ( mapping ) ; </a> 1
<a> a . setHandleStaticResources ( true ) ; </a> 1
<a> gws . addGrizzlyAdapter ( a , new String [ ] { mapping } ) ; </a> 1
<a> return this ; </a> 1
<a> } </a> 1
<a> public void setResourcePackage ( String resourcePackage ) { </a> 1
<a> aa . setResourcePackage ( resourcePackage ) ; </a> 1
<a> } </a> 1
<a> public AtmosphereSpadeServer start ( ) throws IOException { </a> 1
<a> logger . info ( "AtmosphereSpade Server Started on port: {}" , gws . getSelectorThread ( ) . getPort ( ) ) ; </a> 1
<a> if ( defaultToJersey ) { </a> 1
<a> aa . setHandleStaticResources ( true ) ; </a> 1
<a> gws . addGrizzlyAdapter ( aa , new String [ ] { "*" } ) ; </a> 1
<a> } </a> 1
<a> gws . start ( ) ; </a> 1
<a> return this ; </a> 1
<a> } </a> 1
<a> public AtmosphereSpadeServer stop ( ) throws IOException { </a> 1
<a> gws . stop ( ) ; </a> 1
<a> return this ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . tests . guice ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . annotation . Resume ; </a> 0
<a> import org . atmosphere . annotation . Schedule ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import org . atmosphere . jersey . Broadcastable ; </a> 0
<a> import org . atmosphere . jersey . JerseyBroadcaster ; </a> 0
<a> import org . atmosphere . util . StringFilterAggregator ; </a> 0
<a> import org . atmosphere . util . XSSHtmlFilter ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import java . util . concurrent . ExecutionException ; </a> 0
<a> import java . util . concurrent . Executors ; </a> 0
<a> @ Path ( "/{topic}" ) </a> 0
<a> @ Produces ( "text/plain;charset=ISO-8859-1" ) </a> 0
<a> public class PubSubTest { </a> 0
<a> private </a> 0
<a> @ PathParam ( "topic" ) </a> 0
<a> Broadcaster broadcaster ; </a> 0
<a> private final static int count = 0 ; </a> 0
<a> @ GET </a> 0
<a> @ Path ( "scope" ) </a> 0
<a> @ Suspend ( period = 5000 , outputComments = false , scope = Suspend . SCOPE . REQUEST , resumeOnBroadcast = true ) </a> 0
<a> public Broadcastable suspendScopeRequest ( @ PathParam ( "topic" ) Broadcaster b ) throws ExecutionException , InterruptedException { </a> 0
<a> b . broadcast ( "foo" ) . get ( ) ; </a> 0
<a> return new Broadcastable ( "bar" , b ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Suspend ( period = 5000 , outputComments = false ) </a> 0
<a> public Broadcastable subscribe ( ) { </a> 0
<a> return new Broadcastable ( "resume" , broadcaster ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "withComments" ) </a> 0
<a> @ Suspend ( period = 5000 , outputComments = true ) </a> 0
<a> public Broadcastable subscribeWithComments ( ) { </a> 0
<a> return new Broadcastable ( broadcaster ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "forever" ) </a> 0
<a> @ Suspend ( outputComments = true ) </a> 0
<a> public Broadcastable suspendForever ( ) { </a> 0
<a> return new Broadcastable ( broadcaster ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "foreverWithoutComments" ) </a> 0
<a> @ Suspend ( outputComments = false ) </a> 0
<a> public Broadcastable suspendForeverWithoutComments ( ) { </a> 0
<a> return new Broadcastable ( broadcaster ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "subscribeAndUsingExternalThread" ) </a> 0
<a> @ Suspend ( resumeOnBroadcast = true ) </a> 0
<a> public String subscribeAndResumeUsingExternalThread ( final @ PathParam ( "topic" ) String topic ) { </a> 0
<a> Executors . newSingleThreadExecutor ( ) . submit ( new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 5000 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> BroadcasterFactory . getDefault ( ) . lookup ( JerseyBroadcaster . class , topic ) . broadcast ( "Echo: " + topic ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> return "foo" ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "suspendAndResume" ) </a> 0
<a> @ Suspend ( outputComments = false ) </a> 0
<a> public String suspend ( ) { </a> 0
<a> return "suspend" ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Suspend ( resumeOnBroadcast = true , outputComments = false ) </a> 0
<a> @ Path ( "subscribeAndResume" ) </a> 0
<a> public Broadcastable subscribeAndResume ( ) { </a> 0
<a> return new Broadcastable ( broadcaster ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Resume </a> 0
<a> @ Path ( "suspendAndResume/{uuid}" ) </a> 0
<a> public String resume ( ) throws ExecutionException , InterruptedException { </a> 0
<a> broadcaster . broadcast ( "resume" ) . get ( ) ; </a> 0
<a> return "resumed" ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Broadcast </a> 0
<a> public Broadcastable publish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "publishAndResume" ) </a> 0
<a> @ Broadcast ( resumeOnBroadcast = true ) </a> 0
<a> public Broadcastable publishAndResume ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "filter" ) </a> 0
<a> @ Broadcast ( resumeOnBroadcast = true , value = { XSSHtmlFilter . class } ) </a> 0
<a> public Broadcastable filter ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "aggregate" ) </a> 0
<a> @ Broadcast ( resumeOnBroadcast = true , value = { StringFilterAggregator . class } ) </a> 0
<a> public Broadcastable aggregate ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 5 , resumeOnBroadcast = true , waitFor = 5 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "scheduleAndResume" ) </a> 0
<a> public Broadcastable scheduleAndResume ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 10 , waitFor = 5 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "delaySchedule" ) </a> 0
<a> public Broadcastable delaySchedule ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 5 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "schedule" ) </a> 0
<a> public Broadcastable schedule ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Broadcast ( delay = 0 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "delay" ) </a> 0
<a> public Broadcastable delayPublish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Broadcast ( delay = 5 , resumeOnBroadcast = true ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "delayAndResume" ) </a> 0
<a> public Broadcastable delayPublishAndResume ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "programmaticDelayBroadcast" ) </a> 0
<a> public String manualDelayBroadcast ( @ FormParam ( "message" ) String message ) { </a> 0
<a> broadcaster . delayBroadcast ( message ) ; </a> 0
<a> return message ; </a> 0
<a> } </a> 0
<a> Broadcastable broadcast ( String m ) { </a> 0
<a> return new Broadcastable ( m + "\n" , broadcaster ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client ; </a> 0
<a> import java . io . Serializable ; </a> 1
<a> import java . util . List ; </a> 0
<a> public interface AtmosphereListener { </a> 0
<a> public void onConnected ( int heartbeat , int connectionID ) ; </a> 0
<a> public void onBeforeDisconnected ( ) ; </a> 0
<a> public void onDisconnected ( ) ; </a> 0
<a> public void onError ( Throwable exception , boolean connected ) ; </a> 0
<a> public void onHeartbeat ( ) ; </a> 0
<a> public void onRefresh ( ) ; </a> 0
<a> public void onMessage ( List < ? extends Serializable > messages ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client ; </a> 0
<a> public enum SerialMode { </a> 0
<a> RPC , </a> 0
<a> DE_RPC , </a> 0
<a> PLAIN , </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . core . client . Duration ; </a> 0
<a> import com . google . gwt . core . client . GWT ; </a> 0
<a> import com . google . gwt . http . client . Request ; </a> 0
<a> import com . google . gwt . http . client . RequestBuilder ; </a> 0
<a> import com . google . gwt . http . client . RequestCallback ; </a> 0
<a> import com . google . gwt . http . client . RequestException ; </a> 0
<a> import com . google . gwt . http . client . Response ; </a> 0
<a> import com . google . gwt . user . client . rpc . AsyncCallback ; </a> 0
<a> import com . google . gwt . user . client . rpc . SerializationException ; </a> 0
<a> import com . google . gwt . user . client . rpc . StatusCodeException ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClient ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereGWTSerializer ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereListener ; </a> 0
<a> import org . atmosphere . gwt . client . SerialMode ; </a> 0
<a> import org . atmosphere . gwt . shared . Constants ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . logging . Level ; </a> 0
<a> import java . util . logging . Logger ; </a> 0
<a> public abstract class BaseCometTransport implements CometTransport { </a> 0
<a> protected AtmosphereClient client ; </a> 0
<a> protected AtmosphereListener listener ; </a> 0
<a> protected ServerTransport serverTransport ; </a> 0
<a> protected int connectionId ; </a> 0
<a> protected final Logger logger = Logger . getLogger ( getClass ( ) . getName ( ) ) ; </a> 0
<a> @ Override </a> 0
<a> public void disconnect ( ) { </a> 0
<a> listener . onBeforeDisconnected ( ) ; </a> 0
<a> getServerTransport ( ) . disconnect ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void post ( Serializable message , AsyncCallback < Void > callback ) { </a> 0
<a> getServerTransport ( ) . post ( message , callback ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void post ( List < Serializable > messages , AsyncCallback < Void > callback ) { </a> 0
<a> getServerTransport ( ) . post ( messages , callback ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void broadcast ( Serializable message ) { </a> 0
<a> getServerTransport ( ) . broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void broadcast ( List < Serializable > messages ) { </a> 0
<a> getServerTransport ( ) . broadcast ( messages ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void initiate ( AtmosphereClient client , AtmosphereListener listener ) { </a> 0
<a> this . client = client ; </a> 0
<a> this . listener = listener ; </a> 0
<a> } </a> 0
<a> protected ServerTransport getServerTransport ( ) { </a> 0
<a> if ( serverTransport == null ) { </a> 0
<a> serverTransport = new RPCServerTransport ( ) ; </a> 0
<a> } </a> 0
<a> return serverTransport ; </a> 0
<a> } </a> 0
<a> protected class RPCServerTransport extends ServerTransportProtocol { </a> 0
<a> @ Override </a> 0
<a> void send ( String message , final AsyncCallback < Void > callback ) { </a> 0
<a> RequestBuilder request = new RequestBuilder ( RequestBuilder . POST , serviceUrl ( ) ) ; </a> 0
<a> try { </a> 0
<a> request . sendRequest ( message , new RequestCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onResponseReceived ( Request request , Response response ) { </a> 0
<a> if ( response . getStatusCode ( ) != Response . SC_OK </a> 0
<a> && response . getStatusCode ( ) != 0 ) { </a> 0
<a> logger . log ( Level . SEVERE , "Failed to send server message: [" + response . getStatusText ( ) + "," + response . getStatusCode ( ) + "]" ) ; </a> 0
<a> callback . onFailure ( new StatusCodeException ( response . getStatusCode ( ) , response . getStatusText ( ) ) ) ; </a> 0
<a> } else { </a> 0
<a> callback . onSuccess ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onError ( Request request , Throwable exception ) { </a> 0
<a> callback . onFailure ( exception ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } catch ( RequestException ex ) { </a> 0
<a> callback . onFailure ( ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String serialize ( Serializable message ) throws SerializationException { </a> 0
<a> return client . getSerializer ( ) . serialize ( message ) ; </a> 0
<a> } </a> 0
<a> protected String serviceUrl ( ) { </a> 0
<a> int i = client . getUrl ( ) . indexOf ( '?' ) ; </a> 0
<a> String serviceUrl = ( i > 0 ? client . getUrl ( ) . substring ( 0 , i ) : client . getUrl ( ) ) </a> 0
<a> + "?servertransport=rpcprotocol&connectionID=" + connectionId ; </a> 0
<a> return serviceUrl ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected Serializable parse ( String message ) throws SerializationException { </a> 0
<a> if ( message == null || message . isEmpty ( ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> AtmosphereGWTSerializer serializer = client . getSerializer ( ) ; </a> 0
<a> if ( serializer == null ) { </a> 0
<a> throw new SerializationException ( "Can not deserialize message with no serializer: " + message ) ; </a> 0
<a> } else { </a> 0
<a> return serializer . parse ( message ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public String getUrl ( int connectionCount ) { </a> 0
<a> String url = client . getUrl ( ) ; </a> 0
<a> if ( client . getSerializer ( ) != null && client . getSerializer ( ) . getMode ( ) == SerialMode . DE_RPC ) { </a> 0
<a> url += ( url . contains ( "?" ) ? "&" : "?" ) + Constants . MODULE_BASE_PARAMETER + '=' + GWT . getModuleBaseURL ( ) + '&' + Constants . STRONG_NAME_PARAMETER + '=' + GWT . getPermutationStrongName ( ) ; </a> 0
<a> } </a> 0
<a> String className = getClass ( ) . getName ( ) ; </a> 0
<a> className = className . substring ( className . lastIndexOf ( '.' ) + 1 ) ; </a> 0
<a> String transport = className . substring ( 0 , className . indexOf ( "CometTransport" ) ) ; </a> 0
<a> return url + ( url . contains ( "?" ) ? "&" : "?" ) </a> 0
<a> + "t=" + Integer . toString ( ( int ) ( Duration . currentTimeMillis ( ) % Integer . MAX_VALUE ) , Character . MAX_RADIX ) . toUpperCase ( ) </a> 0
<a> + "&c=" + connectionCount </a> 0
<a> + "&tr=" + transport ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . user . client . rpc . AsyncCallback ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClient ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereListener ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class IECometTransport implements CometTransport { </a> 0
<a> CometTransport transport ; </a> 0
<a> public IECometTransport ( ) { </a> 0
<a> if ( XDomainRequest . isSupported ( ) ) { </a> 0
<a> transport = new IEXDomainRequestCometTransport ( ) ; </a> 0
<a> } else { </a> 0
<a> transport = new IEHTMLFileCometTransport ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void connect ( int connectionCount ) { </a> 0
<a> transport . connect ( connectionCount ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void disconnect ( ) { </a> 0
<a> transport . disconnect ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void initiate ( AtmosphereClient client , AtmosphereListener listener ) { </a> 0
<a> transport . initiate ( client , listener ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void post ( Serializable message , AsyncCallback < Void > callback ) { </a> 0
<a> transport . post ( message , callback ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void post ( List < Serializable > messages , AsyncCallback < Void > callback ) { </a> 0
<a> transport . post ( messages , callback ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void broadcast ( Serializable message ) { </a> 0
<a> transport . broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void broadcast ( List < Serializable > messages ) { </a> 0
<a> transport . broadcast ( messages ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptException ; </a> 0
<a> import com . google . gwt . http . client . RequestException ; </a> 0
<a> import com . google . gwt . http . client . Response ; </a> 0
<a> import com . google . gwt . user . client . Cookies ; </a> 0
<a> import com . google . gwt . user . client . rpc . StatusCodeException ; </a> 0
<a> import org . atmosphere . gwt . client . TimeoutException ; </a> 0
<a> public class IEXDomainRequestCometTransport extends StreamingProtocolTransport { </a> 0
<a> @ Override </a> 0
<a> public void connect ( int connectionCount ) { </a> 0
<a> init ( ) ; </a> 0
<a> try { </a> 0
<a> transportRequest = XDomainRequest . create ( ) ; </a> 0
<a> transportRequest . setListener ( xDomainRequestListener ) ; </a> 0
<a> transportRequest . openGET ( getUrl ( connectionCount ) ) ; </a> 0
<a> transportRequest . send ( ) ; </a> 0
<a> } catch ( JavaScriptException ex ) { </a> 0
<a> if ( transportRequest != null ) { </a> 0
<a> transportRequest . abort ( ) ; </a> 0
<a> transportRequest = null ; </a> 0
<a> } </a> 0
<a> listener . onError ( new RequestException ( ex . getMessage ( ) ) , false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void disconnect ( ) { </a> 0
<a> aborted = true ; </a> 0
<a> expectingDisconnection = true ; </a> 0
<a> super . disconnect ( ) ; </a> 0
<a> if ( transportRequest != null ) { </a> 0
<a> transportRequest . clearListener ( ) ; </a> 0
<a> transportRequest . abort ( ) ; </a> 0
<a> transportRequest = null ; </a> 0
<a> } </a> 0
<a> listener . onDisconnected ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String getUrl ( int connectionCount ) { </a> 0
<a> String url = super . getUrl ( connectionCount ) ; </a> 0
<a> if ( url . toLowerCase ( ) . contains ( ";jsessionid" ) == false ) { </a> 0
<a> String sessionid = Cookies . getCookie ( "JSESSIONID" ) ; </a> 0
<a> if ( sessionid != null ) { </a> 0
<a> String parm = ";jsessionid=" + sessionid ; </a> 0
<a> int p = url . indexOf ( '?' ) ; </a> 0
<a> if ( p > 0 ) { </a> 0
<a> return url . substring ( 0 , p ) + parm + url . substring ( p ) ; </a> 0
<a> } else { </a> 0
<a> return url + parm ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! url . toUpperCase ( ) . contains ( "PHPSESSID" ) ) { </a> 0
<a> String sessionid = Cookies . getCookie ( "PHPSESSID" ) ; </a> 0
<a> if ( sessionid != null ) { </a> 0
<a> int p = url . indexOf ( '?' ) ; </a> 0
<a> String param = "PHPSESSID=" + sessionid ; </a> 0
<a> if ( p > 0 ) { </a> 0
<a> return url . substring ( 0 , p + 1 ) + param + "&" + url . substring ( p + 1 ) ; </a> 0
<a> } else { </a> 0
<a> return url + "?" + param ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return url ; </a> 0
<a> } </a> 0
<a> private XDomainRequest transportRequest ; </a> 0
<a> private XDomainRequestListener xDomainRequestListener = new XDomainRequestListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onError ( XDomainRequest request ) { </a> 0
<a> if ( isCurrent ( request ) ) { </a> 0
<a> expectingDisconnection = true ; </a> 0
<a> listener . onError ( new StatusCodeException ( Response . SC_INTERNAL_SERVER_ERROR , "" ) , true ) ; </a> 0
<a> transportRequest = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onLoad ( XDomainRequest request , String responseText ) { </a> 0
<a> request . clearListener ( ) ; </a> 0
<a> if ( isCurrent ( request ) ) { </a> 0
<a> transportRequest = null ; </a> 0
<a> if ( ! aborted ) { </a> 0
<a> onReceiving ( Response . SC_OK , responseText , false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onProgress ( XDomainRequest request , String responseText ) { </a> 0
<a> if ( ! aborted && isCurrent ( request ) ) { </a> 0
<a> onReceiving ( Response . SC_OK , responseText , true ) ; </a> 0
<a> } else { </a> 0
<a> request . clearListener ( ) ; </a> 0
<a> request . abort ( ) ; </a> 0
<a> if ( isCurrent ( request ) ) { </a> 0
<a> transportRequest = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onTimeout ( XDomainRequest request ) { </a> 0
<a> if ( isCurrent ( request ) ) { </a> 0
<a> if ( ! expectingDisconnection ) { </a> 0
<a> listener . onError ( </a> 0
<a> new TimeoutException ( "Unexpected connection timeout" , request . getTimeout ( ) ) </a> 0
<a> , false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public boolean isCurrent ( XDomainRequest request ) { </a> 0
<a> return request == transportRequest ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> public interface WebSocketListener { </a> 0
<a> void onOpen ( WebSocket socket ) ; </a> 0
<a> void onClose ( WebSocket socket ) ; </a> 0
<a> void onError ( WebSocket socket ) ; </a> 1
<a> void onMessage ( WebSocket socket , String message ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> public interface XDomainRequestListener { </a> 0
<a> public void onError ( XDomainRequest request ) ; </a> 0
<a> public void onLoad ( XDomainRequest request , String responseText ) ; </a> 0
<a> public void onProgress ( XDomainRequest request , String responseText ) ; </a> 0
<a> public void onTimeout ( XDomainRequest request ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . js ; </a> 0
<a> import com . google . gwt . core . client . GWT ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptObject ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClient ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereListener ; </a> 0
<a> import org . timepedia . exporter . client . Export ; </a> 0
<a> import org . timepedia . exporter . client . ExportPackage ; </a> 0
<a> import org . timepedia . exporter . client . Exportable ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> @ ExportPackage ( "atmosphere" ) </a> 0
<a> public class Client implements Exportable { </a> 0
<a> private JsSerializer serializer = GWT . create ( JsSerializer . class ) ; </a> 0
<a> private AtmosphereClient impl ; </a> 0
<a> private OnMessage onMessage ; </a> 0
<a> private OnError onError ; </a> 0
<a> private OnConnected onConnected ; </a> 0
<a> private OnDisconnected onDisconnected ; </a> 0
<a> private OnBeforeDisconnected onBeforeDisconnected ; </a> 0
<a> private OnHeartbeat onHeartbeat ; </a> 0
<a> @ Export </a> 0
<a> public Client ( String url ) { </a> 0
<a> impl = new AtmosphereClient ( url , serializer , listener ) ; </a> 0
<a> } </a> 0
<a> @ Export </a> 0
<a> public void start ( ) { </a> 0
<a> impl . start ( ) ; </a> 0
<a> } </a> 0
<a> @ Export </a> 0
<a> public void stop ( ) { </a> 0
<a> impl . stop ( ) ; </a> 0
<a> } </a> 0
<a> @ Export </a> 0
<a> void post ( JavaScriptObject message ) { </a> 0
<a> impl . post ( encodeJSON ( message ) ) ; </a> 0
<a> } </a> 0
<a> @ Export </a> 0
<a> void broadcast ( JavaScriptObject message ) { </a> 0
<a> impl . broadcast ( encodeJSON ( message ) ) ; </a> 0
<a> } </a> 0
<a> private AtmosphereListener listener = new AtmosphereListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onConnected ( int heartbeat , int connectionID ) { </a> 0
<a> if ( onConnected != null ) { </a> 0
<a> onConnected . execute ( heartbeat , connectionID ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onBeforeDisconnected ( ) { </a> 0
<a> if ( onBeforeDisconnected != null ) { </a> 0
<a> onBeforeDisconnected . execute ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDisconnected ( ) { </a> 0
<a> if ( onDisconnected != null ) { </a> 0
<a> onDisconnected . execute ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onError ( Throwable exception , boolean connected ) { </a> 0
<a> if ( onError != null ) { </a> 0
<a> onError . execute ( exception . getMessage ( ) , connected ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onHeartbeat ( ) { </a> 0
<a> if ( onHeartbeat != null ) { </a> 0
<a> onHeartbeat . execute ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onRefresh ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onMessage ( List < ? extends Serializable > messages ) { </a> 0
<a> if ( onMessage != null ) { </a> 0
<a> for ( Serializable m : messages ) { </a> 0
<a> onMessage . execute ( decodeJSON ( ( String ) m ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> @ Export </a> 0
<a> public void setOnMessage ( OnMessage function ) { </a> 0
<a> onMessage = function ; </a> 0
<a> } </a> 0
<a> @ Export </a> 0
<a> public void setOnError ( OnError function ) { </a> 0
<a> onError = function ; </a> 0
<a> } </a> 0
<a> @ Export </a> 0
<a> public void setOnBeforeDisconnected ( OnBeforeDisconnected onBeforeDisconnected ) { </a> 0
<a> this . onBeforeDisconnected = onBeforeDisconnected ; </a> 0
<a> } </a> 0
<a> @ Export </a> 0
<a> public void setOnConnected ( OnConnected onConnected ) { </a> 0
<a> this . onConnected = onConnected ; </a> 0
<a> } </a> 0
<a> @ Export </a> 0
<a> public void setOnDisconnected ( OnDisconnected onDisconnected ) { </a> 0
<a> this . onDisconnected = onDisconnected ; </a> 0
<a> } </a> 0
<a> @ Export </a> 0
<a> public void setOnHeartbeat ( OnHeartbeat onHeartbeat ) { </a> 0
<a> this . onHeartbeat = onHeartbeat ; </a> 0
<a> } </a> 0
<a> private native String encodeJSON ( JavaScriptObject obj ) ; </a> 0
<a> private native JavaScriptObject decodeJSON ( String json ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server ; </a> 0
<a> import com . google . gwt . user . client . rpc . SerializationException ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicyProvider ; </a> 0
<a> import com . google . gwt . user . server . rpc . impl . ServerSerializationStreamReader ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServletProcessor ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 0
<a> import org . atmosphere . gwt . server . impl . GwtAtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . gwt . server . impl . RPCUtil ; </a> 0
<a> import org . atmosphere . handler . AbstractReflectorAtmosphereHandler ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 1
<a> import javax . servlet . ServletContext ; </a> 1
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . BufferedReader ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 0
<a> import java . util . concurrent . Executor ; </a> 0
<a> import java . util . concurrent . ExecutorService ; </a> 0
<a> import java . util . concurrent . Executors ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public class AtmosphereGwtHandler extends AbstractReflectorAtmosphereHandler </a> 0
<a> implements Executor , AtmosphereServletProcessor { </a> 0
<a> public static final int NO_TIMEOUT = - 1 ; </a> 0
<a> public static final String GWT_BROADCASTER_ID = "GWT_BROADCASTER" ; </a> 0
<a> private static final int DEFAULT_HEARTBEAT = 15 * 1000 ; </a> 0
<a> private ExecutorService executorService ; </a> 0
<a> private int heartbeat = DEFAULT_HEARTBEAT ; </a> 0
<a> protected final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; </a> 0
<a> protected SerializationPolicyProvider cometSerializationPolicyProvider = new SerializationPolicyProvider ( ) { </a> 0
<a> @ Override </a> 0
<a> public SerializationPolicy getSerializationPolicy ( String moduleBaseURL , String serializationPolicyStrongName ) { </a> 0
<a> return RPCUtil . createSimpleSerializationPolicy ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> public int doComet ( GwtAtmosphereResource resource ) throws ServletException , IOException { </a> 0
<a> Broadcaster broadcaster = BroadcasterFactory . getDefault ( ) . lookup ( Broadcaster . class , GWT_BROADCASTER_ID ) ; </a> 0
<a> if ( broadcaster == null ) { </a> 0
<a> try { </a> 0
<a> broadcaster = BroadcasterFactory . getDefault ( ) . get ( DefaultBroadcaster . class , GWT_BROADCASTER_ID ) ; </a> 0
<a> } catch ( IllegalAccessException ex ) { </a> 0
<a> logger . error ( "Failed to get broadcaster" , ex ) ; </a> 0
<a> } catch ( InstantiationException ex ) { </a> 0
<a> logger . error ( "Failed to get broadcaster" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> resource . getAtmosphereResource ( ) . setBroadcaster ( broadcaster ) ; </a> 0
<a> return NO_TIMEOUT ; </a> 0
<a> } </a> 0
<a> public void cometTerminated ( GwtAtmosphereResource cometResponse , boolean serverInitiated ) { </a> 0
<a> resources . remove ( cometResponse . getConnectionID ( ) ) ; </a> 1
<a> } </a> 0
<a> public void doPost ( List < Serializable > messages , GwtAtmosphereResource r ) { </a> 1
<a> if ( messages . size ( ) == 1 ) { </a> 0
<a> r . post ( messages . get ( 0 ) ) ; </a> 1
<a> } else { </a> 0
<a> r . post ( ( List ) messages ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> protected Broadcaster getBroadcaster ( GwtAtmosphereResource resource ) { </a> 0
<a> return resource . getBroadcaster ( ) ; </a> 0
<a> } </a> 0
<a> protected GwtAtmosphereResource lookupResource ( int connectionId ) { </a> 0
<a> GwtAtmosphereResource r = resources . get ( connectionId ) ; </a> 0
<a> if ( r != null ) { </a> 0
<a> return r ; </a> 0
<a> } else { </a> 0
<a> logger . info ( "Failed to find resource for [" + connectionId + "]" ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> private Map < Integer , GwtAtmosphereResource > resources ; </a> 0
<a> private ServletContext context ; </a> 0
<a> @ Override </a> 0
<a> public void init ( ServletConfig servletConfig ) throws ServletException { </a> 0
<a> executorService = Executors . newCachedThreadPool ( ) ; </a> 0
<a> String heartbeat = servletConfig . getInitParameter ( "heartbeat" ) ; </a> 0
<a> context = servletConfig . getServletContext ( ) ; </a> 0
<a> if ( heartbeat != null ) { </a> 0
<a> this . heartbeat = Integer . parseInt ( heartbeat ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void destroy ( ) { </a> 0
<a> if ( executorService != null ) { </a> 0
<a> executorService . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public int getHeartbeat ( ) { </a> 0
<a> return heartbeat ; </a> 0
<a> } </a> 0
<a> public void setHeartbeat ( int heartbeat ) { </a> 0
<a> this . heartbeat = heartbeat ; </a> 0
<a> } </a> 0
<a> public ServletContext getServletContext ( ) { </a> 0
<a> return context ; </a> 0
<a> } </a> 0
<a> protected void reapResources ( ) { </a> 0
<a> for ( GwtAtmosphereResource resource : resources . values ( ) ) { </a> 0
<a> if ( ! resource . isAlive ( ) ) { </a> 0
<a> resources . remove ( resource . getConnectionID ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > resource ) throws IOException { </a> 0
<a> HttpServletRequest request = resource . getRequest ( ) ; </a> 0
<a> String servertransport = request . getParameter ( "servertransport" ) ; </a> 0
<a> if ( "rpcprotocol" . equals ( servertransport ) ) { </a> 0
<a> Integer connectionID = Integer . parseInt ( request . getParameter ( "connectionID" ) ) ; </a> 0
<a> doServerMessage ( request . getReader ( ) , connectionID ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> int requestHeartbeat = heartbeat ; </a> 0
<a> String requestedHeartbeat = request . getParameter ( "heartbeat" ) ; </a> 0
<a> if ( requestedHeartbeat != null ) { </a> 0
<a> try { </a> 0
<a> requestHeartbeat = Integer . parseInt ( requestedHeartbeat ) ; </a> 0
<a> if ( requestHeartbeat <= 0 ) { </a> 0
<a> throw new IOException ( "invalid heartbeat parameter" ) ; </a> 0
<a> } </a> 0
<a> requestHeartbeat = computeHeartbeat ( requestHeartbeat ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> throw new IOException ( "invalid heartbeat parameter" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> GwtAtmosphereResourceImpl resourceWrapper = new GwtAtmosphereResourceImpl ( resource , this , requestHeartbeat ) ; </a> 1
<a> doCometImpl ( resourceWrapper ) ; </a> 1
<a> } catch ( IOException e ) { </a> 1
<a> logger . error ( "Unable to initiated comet" + e . getMessage ( ) , e ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> protected void doServerMessage ( BufferedReader data , int connectionID ) { </a> 1
<a> List < Serializable > postMessages = new ArrayList < Serializable > ( ) ; </a> 0
<a> GwtAtmosphereResource resource = lookupResource ( connectionID ) ; </a> 0
<a> if ( resource == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> while ( true ) { </a> 0
<a> String event = data . readLine ( ) ; </a> 0
<a> if ( event == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> String messageData = data . readLine ( ) ; </a> 1
<a> if ( messageData == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> data . readLine ( ) ; </a> 1
<a> if ( logger . isTraceEnabled ( ) ) { </a> 0
<a> logger . trace ( "[" + connectionID + "] Server message received: " + event + ";" + messageData . charAt ( 0 ) ) ; </a> 1
<a> } </a> 0
<a> if ( event . equals ( "o" ) ) { </a> 1
<a> if ( messageData . charAt ( 0 ) == 'p' ) { </a> 1
<a> Serializable message = deserialize ( messageData . substring ( 1 ) ) ; </a> 1
<a> if ( message != null ) { </a> 1
<a> postMessages . add ( message ) ; </a> 0
<a> } </a> 1
<a> } else if ( messageData . charAt ( 0 ) == 'b' ) { </a> 1
<a> Serializable message = deserialize ( messageData . substring ( 1 ) ) ; </a> 1
<a> broadcast ( message , resource ) ; </a> 0
<a> } </a> 0
<a> } else if ( event . equals ( "s" ) ) { </a> 1
<a> if ( messageData . charAt ( 0 ) == 'p' ) { </a> 1
<a> String message = messageData . substring ( 1 ) ; </a> 1
<a> postMessages . add ( message ) ; </a> 1
<a> } else if ( messageData . charAt ( 0 ) == 'b' ) { </a> 1
<a> Serializable message = messageData . substring ( 1 ) ; </a> 1
<a> broadcast ( message , resource ) ; </a> 1
<a> } </a> 1
<a> } else if ( event . equals ( "c" ) ) { </a> 0
<a> if ( messageData . equals ( "d" ) ) { </a> 1
<a> disconnect ( resource ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( IOException ex ) { </a> 0
<a> logger . error ( "[" + connectionID + "] Failed to read" , ex ) ; </a> 0
<a> } </a> 0
<a> if ( postMessages . size ( ) > 0 ) { </a> 0
<a> post ( postMessages , resource ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> protected Serializable deserialize ( String data ) { </a> 0
<a> try { </a> 0
<a> ServerSerializationStreamReader reader = new ServerSerializationStreamReader ( getClass ( ) . getClassLoader ( ) , cometSerializationPolicyProvider ) ; </a> 0
<a> reader . prepareToRead ( data ) ; </a> 0
<a> return ( Serializable ) reader . readObject ( ) ; </a> 0
<a> } catch ( SerializationException ex ) { </a> 0
<a> logger . error ( "Failed to deserialize message" , ex ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> final public void post ( List < Serializable > messages , GwtAtmosphereResource resource ) { </a> 1
<a> if ( messages == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( resource != null ) { </a> 1
<a> doPost ( messages , resource ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> public void broadcast ( Serializable message , GwtAtmosphereResource resource ) { </a> 0
<a> if ( message == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> resource . getBroadcaster ( ) . broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> public void broadcast ( List < Serializable > messages , GwtAtmosphereResource resource ) { </a> 0
<a> if ( messages == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> resource . getBroadcaster ( ) . broadcast ( messages ) ; </a> 0
<a> } </a> 0
<a> public void disconnect ( GwtAtmosphereResource resource ) { </a> 0
<a> if ( resource != null ) { </a> 0
<a> logger . debug ( "Resuming connection[" + resource . getConnectionID ( ) + "] after client disconnect message" ) ; </a> 0
<a> resource . getAtmosphereResource ( ) . resume ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void execute ( Runnable command ) { </a> 0
<a> executorService . execute ( command ) ; </a> 0
<a> } </a> 0
<a> protected int computeHeartbeat ( int requestedHeartbeat ) { </a> 0
<a> return requestedHeartbeat < heartbeat ? heartbeat : requestedHeartbeat ; </a> 0
<a> } </a> 0
<a> private void doCometImpl ( GwtAtmosphereResourceImpl resource ) throws IOException { </a> 0
<a> try { </a> 0
<a> resource . getWriterImpl ( ) . initiate ( ) ; </a> 0
<a> if ( resources == null ) { </a> 0
<a> resources = new ConcurrentHashMap < Integer , GwtAtmosphereResource > ( 5 ) ; </a> 0
<a> resource . getBroadcaster ( ) . getBroadcasterConfig ( ) . getScheduledExecutorService ( ) . scheduleWithFixedDelay ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> reapResources ( ) ; </a> 0
<a> } </a> 0
<a> } , 30 , 10 , TimeUnit . SECONDS ) ; </a> 0
<a> } </a> 0
<a> resources . put ( resource . getConnectionID ( ) , resource ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . error ( "Error initiating GwtComet" , e ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> int timeout ; </a> 0
<a> try { </a> 0
<a> timeout = doComet ( resource ) ; </a> 0
<a> if ( timeout == - 1 ) { </a> 1
<a> logger . info ( "You have set an infinite timeout for your comet connection this is not recommended" ) ; </a> 0
<a> } </a> 0
<a> } catch ( ServletException e ) { </a> 0
<a> logger . error ( "Error calling doComet()" , e ) ; </a> 0
<a> return ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . error ( "Error calling doComet()" , e ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> resource . suspend ( timeout ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . impl ; </a> 0
<a> import com . google . gwt . rpc . server . ClientOracle ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class IFrameResponseWriter extends ManagedStreamResponseWriter { </a> 0
<a> public IFrameResponseWriter ( GwtAtmosphereResourceImpl resource , SerializationPolicy serializationPolicy , ClientOracle clientOracle ) { </a> 0
<a> super ( resource , serializationPolicy , clientOracle ) ; </a> 0
<a> } </a> 0
<a> private static final int PADDING_REQUIRED = 256 ; </a> 0
<a> private static final String HEAD = "<html><body onload='parent.d()'><script>" ; </a> 0
<a> private static final String MID = "parent.c(" ; </a> 0
<a> private static final String TAIL = ");var m=parent.m;var h=parent.h;</script>" ; </a> 0
<a> private static final String PADDING_STRING ; </a> 0
<a> static { </a> 0
<a> int capacity = PADDING_REQUIRED - HEAD . length ( ) - MID . length ( ) - TAIL . length ( ) ; </a> 0
<a> char [ ] padding = new char [ capacity ] ; </a> 0
<a> for ( int i = 0 ; i < capacity ; i ++ ) { </a> 0
<a> padding [ i ] = ' ' ; </a> 0
<a> } </a> 0
<a> PADDING_STRING = new String ( padding ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void initiate ( ) throws IOException { </a> 0
<a> getResponse ( ) . setContentType ( "text/html" ) ; </a> 0
<a> String origin = getRequest ( ) . getHeader ( "Origin" ) ; </a> 0
<a> if ( origin != null ) { </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( "Origin: " + origin ) ; </a> 0
<a> } </a> 0
<a> getResponse ( ) . setHeader ( "Access-Control-Allow-Origin" , origin ) ; </a> 0
<a> } </a> 0
<a> super . initiate ( ) ; </a> 0
<a> writer . append ( HEAD ) ; </a> 0
<a> String domain = getRequest ( ) . getParameter ( "d" ) ; </a> 0
<a> if ( domain != null ) { </a> 0
<a> writer . append ( "document.domain='" ) ; </a> 0
<a> writer . append ( domain ) ; </a> 0
<a> writer . append ( "';" ) ; </a> 0
<a> } </a> 0
<a> writer . append ( MID ) ; </a> 0
<a> writer . append ( Integer . toString ( resource . getHeartBeatInterval ( ) ) ) ; </a> 0
<a> writer . append ( ',' ) . append ( String . valueOf ( connectionID ) ) ; </a> 0
<a> writer . append ( TAIL ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int getPaddingRequired ( ) { </a> 0
<a> return PADDING_REQUIRED ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected CharSequence getPadding ( int padding ) { </a> 0
<a> if ( padding > PADDING_STRING . length ( ) ) { </a> 0
<a> StringBuilder result = new StringBuilder ( padding ) ; </a> 0
<a> for ( int i = 0 ; i < padding ; i ++ ) { </a> 0
<a> result . append ( ' ' ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } else { </a> 0
<a> return PADDING_STRING . substring ( 0 , padding ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doSendError ( int statusCode , String message ) throws IOException { </a> 0
<a> getResponse ( ) . setContentType ( "text/html" ) ; </a> 0
<a> writer . append ( "<html><script>parent.e(" ) . append ( Integer . toString ( statusCode ) ) ; </a> 0
<a> if ( message != null ) { </a> 0
<a> writer . append ( ",'" ) . append ( escapeString ( message ) ) . append ( '\'' ) ; </a> 0
<a> } </a> 0
<a> writer . append ( ")</script></html>" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doWrite ( List < ? extends Serializable > messages ) throws IOException { </a> 0
<a> writer . append ( "<script>m(" ) ; </a> 0
<a> boolean first = true ; </a> 0
<a> for ( Serializable message : messages ) { </a> 0
<a> CharSequence string ; </a> 0
<a> if ( message instanceof CharSequence ) { </a> 0
<a> string = "]" + escapeString ( ( CharSequence ) message ) ; </a> 0
<a> } else { </a> 0
<a> string = escapeObject ( serialize ( message ) ) ; </a> 0
<a> } </a> 0
<a> if ( first ) { </a> 0
<a> first = false ; </a> 0
<a> } else { </a> 0
<a> writer . append ( ',' ) ; </a> 0
<a> } </a> 0
<a> writer . append ( '\'' ) . append ( string ) . append ( '\'' ) ; </a> 0
<a> } </a> 0
<a> writer . append ( ")</script>" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doHeartbeat ( ) throws IOException { </a> 0
<a> writer . append ( "<script>h();</script>" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doTerminate ( ) throws IOException { </a> 0
<a> writer . append ( "<script>parent.t();</script>" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doRefresh ( ) throws IOException { </a> 0
<a> writer . append ( "<script>parent.r();</script>" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isOverRefreshLength ( int written ) { </a> 0
<a> if ( length != null ) { </a> 0
<a> return written > length ; </a> 0
<a> } else { </a> 0
<a> return written > 4 * 1024 * 1024 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static CharSequence escapeString ( CharSequence string ) { </a> 1
<a> int length = ( string != null ) ? string . length ( ) : 0 ; </a> 1
<a> int i = 0 ; </a> 0
<a> loop : </a> 0
<a> while ( i < length ) { </a> 1
<a> char ch = string . charAt ( i ) ; </a> 0
<a> switch ( ch ) { </a> 0
<a> case '\'' : </a> 0
<a> case '\\' : </a> 0
<a> case '/' : </a> 0
<a> case '\b' : </a> 0
<a> case '\f' : </a> 0
<a> case '\n' : </a> 0
<a> case '\r' : </a> 0
<a> break loop ; </a> 0
<a> } </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> if ( i == length ) </a> 1
<a> return string ; </a> 0
<a> StringBuilder str = new StringBuilder ( string . length ( ) * 2 ) ; </a> 0
<a> str . append ( string , 0 , i ) ; </a> 0
<a> while ( i < length ) { </a> 1
<a> char ch = string . charAt ( i ) ; </a> 0
<a> switch ( ch ) { </a> 0
<a> case '\'' : </a> 0
<a> str . append ( "\\\'" ) ; </a> 0
<a> break ; </a> 0
<a> case '\\' : </a> 0
<a> str . append ( "\\\\" ) ; </a> 0
<a> break ; </a> 0
<a> case '/' : </a> 0
<a> str . append ( "\\/" ) ; </a> 0
<a> break ; </a> 0
<a> case '\b' : </a> 0
<a> str . append ( "\\b" ) ; </a> 0
<a> break ; </a> 0
<a> case '\f' : </a> 0
<a> str . append ( "\\f" ) ; </a> 0
<a> break ; </a> 0
<a> case '\n' : </a> 0
<a> str . append ( "\\n" ) ; </a> 0
<a> break ; </a> 0
<a> case '\r' : </a> 0
<a> str . append ( "\\r" ) ; </a> 0
<a> break ; </a> 0
<a> case '\t' : </a> 0
<a> str . append ( "\\t" ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> str . append ( ch ) ; </a> 0
<a> } </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> return str ; </a> 0
<a> } </a> 0
<a> private static CharSequence escapeObject ( CharSequence string ) { </a> 1
<a> int length = ( string != null ) ? string . length ( ) : 0 ; </a> 1
<a> int i = 0 ; </a> 0
<a> loop : </a> 0
<a> while ( i < length ) { </a> 1
<a> char ch = string . charAt ( i ) ; </a> 0
<a> switch ( ch ) { </a> 0
<a> case '\'' : </a> 0
<a> case '\\' : </a> 0
<a> case '/' : </a> 0
<a> break loop ; </a> 0
<a> } </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> if ( i == length ) </a> 1
<a> return string ; </a> 0
<a> StringBuilder str = new StringBuilder ( string . length ( ) * 2 ) ; </a> 0
<a> str . append ( string , 0 , i ) ; </a> 0
<a> while ( i < length ) { </a> 1
<a> char ch = string . charAt ( i ) ; </a> 0
<a> switch ( ch ) { </a> 0
<a> case '\'' : </a> 0
<a> str . append ( "\\\'" ) ; </a> 0
<a> break ; </a> 0
<a> case '\\' : </a> 0
<a> str . append ( "\\\\" ) ; </a> 0
<a> break ; </a> 0
<a> case '/' : </a> 0
<a> str . append ( "\\/" ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> str . append ( ch ) ; </a> 0
<a> } </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> return str ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( ElementType . TYPE ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> public @ interface ExportClosure { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> public interface ExportOverlay < T > extends Exportable { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptObject ; </a> 0
<a> public class ExporterHostedModeUtil { </a> 0
<a> public static native JavaScriptObject deboxHostedMode ( </a> 0
<a> JavaScriptObject typeCast , JavaScriptObject val ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> import com . google . gwt . core . client . GWT ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptObject ; </a> 0
<a> import com . google . gwt . core . client . JsArray ; </a> 0
<a> public class ExporterUtil { </a> 0
<a> private interface ExportAll extends Exportable { </a> 0
<a> } </a> 0
<a> private static ExporterBaseImpl impl = GWT . create ( ExporterBaseImpl . class ) ; </a> 0
<a> public static void addTypeMap ( Exportable type , </a> 0
<a> JavaScriptObject exportedConstructor ) { </a> 0
<a> impl . addTypeMap ( type . getClass ( ) , exportedConstructor ) ; </a> 0
<a> } </a> 0
<a> public static void addTypeMap ( Class type , </a> 0
<a> JavaScriptObject exportedConstructor ) { </a> 0
<a> impl . addTypeMap ( type , exportedConstructor ) ; </a> 0
<a> } </a> 0
<a> public static void declarePackage ( String packageName , </a> 0
<a> String enclosingClasses ) { </a> 0
<a> impl . declarePackage ( packageName , enclosingClasses ) ; </a> 0
<a> } </a> 0
<a> public static void exportAll ( ) { </a> 0
<a> GWT . create ( ExportAll . class ) ; </a> 0
<a> } </a> 0
<a> public static JavaScriptObject getDispatch ( Class clazz , String meth , </a> 0
<a> JsArray arguments , boolean isStatic ) { </a> 0
<a> return impl . getDispatch ( clazz , meth , arguments , isStatic ) ; </a> 0
<a> } </a> 0
<a> public static native byte getStructuralFieldbyte ( JavaScriptObject jso , </a> 0
<a> String field ) ; </a> 0
<a> public static native char getStructuralFieldchar ( JavaScriptObject jso , </a> 0
<a> String field ) ; </a> 0
<a> public static native double getStructuralFielddouble ( JavaScriptObject jso , </a> 0
<a> String field ) ; </a> 0
<a> public static native float getStructuralFieldfloat ( JavaScriptObject jso , </a> 0
<a> String field ) ; </a> 0
<a> public static native int getStructuralFieldint ( JavaScriptObject jso , </a> 0
<a> String field ) ; </a> 0
<a> public static long getStructuralFieldlong ( JavaScriptObject jso , </a> 0
<a> String field ) { </a> 0
<a> return ( long ) getStructuralFielddouble ( jso , field ) ; </a> 0
<a> } </a> 0
<a> public static native < T > T getStructuralFieldObject ( JavaScriptObject jso , </a> 0
<a> String field ) ; </a> 0
<a> public static native short getStructuralFieldshort ( JavaScriptObject jso , </a> 0
<a> String field ) ; </a> 0
<a> public static void registerDispatchMap ( Class clazz , JavaScriptObject dispMap , </a> 0
<a> boolean isStatic ) { </a> 0
<a> impl . registerDispatchMap ( clazz , dispMap , isStatic ) ; </a> 0
<a> } </a> 0
<a> public static native void setStructuralField ( JavaScriptObject jso , </a> 0
<a> String field , Object val ) ; </a> 0
<a> public static void setWrapper ( Object instance , JavaScriptObject wrapper ) { </a> 0
<a> impl . setWrapper ( instance , wrapper ) ; </a> 0
<a> } </a> 0
<a> public static JavaScriptObject typeConstructor ( Exportable type ) { </a> 0
<a> return impl . typeConstructor ( type ) ; </a> 0
<a> } </a> 0
<a> public static JavaScriptObject typeConstructor ( String type ) { </a> 0
<a> return impl . typeConstructor ( type ) ; </a> 0
<a> } </a> 0
<a> public static JavaScriptObject wrap ( Exportable type ) { </a> 0
<a> return impl . wrap ( type ) ; </a> 0
<a> } </a> 0
<a> public static JavaScriptObject wrap ( Exportable [ ] type ) { </a> 0
<a> return impl . wrap ( type ) ; </a> 0
<a> } </a> 0
<a> public static JavaScriptObject wrap ( double [ ] type ) { </a> 0
<a> return impl . wrap ( type ) ; </a> 0
<a> } </a> 0
<a> public static JavaScriptObject wrap ( float [ ] type ) { </a> 0
<a> return impl . wrap ( type ) ; </a> 0
<a> } </a> 0
<a> public static JavaScriptObject wrap ( int [ ] type ) { </a> 0
<a> return impl . wrap ( type ) ; </a> 0
<a> } </a> 0
<a> public static JavaScriptObject wrap ( char [ ] type ) { </a> 0
<a> return impl . wrap ( type ) ; </a> 0
<a> } </a> 0
<a> public static JavaScriptObject wrap ( byte [ ] type ) { </a> 0
<a> return impl . wrap ( type ) ; </a> 0
<a> } </a> 0
<a> public static JavaScriptObject wrap ( long [ ] type ) { </a> 0
<a> return impl . wrap ( type ) ; </a> 0
<a> } </a> 0
<a> public static JavaScriptObject wrap ( short [ ] type ) { </a> 0
<a> return impl . wrap ( type ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( { ElementType . METHOD , ElementType . FIELD , ElementType . CONSTRUCTOR } ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> public @ interface NoExport { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . HashSet ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Set ; </a> 0
<a> public class DispatchTable { </a> 0
<a> private boolean isOverloaded ; </a> 0
<a> private JExportableMethod method ; </a> 0
<a> public boolean addSignature ( JExportableMethod method , </a> 0
<a> JExportableParameter [ ] exportableParameters ) { </a> 0
<a> Set < Signature > sigs = sigMap . get ( exportableParameters . length ) ; </a> 0
<a> if ( sigs == null ) { </a> 0
<a> sigs = new HashSet < Signature > ( ) ; </a> 0
<a> sigMap . put ( exportableParameters . length , sigs ) ; </a> 0
<a> } </a> 0
<a> isOverloaded = sigMap . size ( ) > 1 || isOverloaded ; </a> 0
<a> Signature sig = new Signature ( method , exportableParameters ) ; </a> 0
<a> if ( sigs . contains ( sig ) ) { </a> 0
<a> return false ; </a> 0
<a> } else { </a> 0
<a> sigs . add ( sig ) ; </a> 0
<a> } </a> 0
<a> isOverloaded = sigs . size ( ) > 1 || isOverloaded ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public int maxArity ( ) { </a> 0
<a> return Collections . max ( sigMap . keySet ( ) ) . intValue ( ) ; </a> 0
<a> } </a> 0
<a> public boolean isOverloaded ( ) { </a> 0
<a> return isOverloaded ; </a> 0
<a> } </a> 0
<a> public static String toJSON ( HashMap < String , DispatchTable > dispatchMap ) { </a> 0
<a> StringBuilder sb = new StringBuilder ( ) ; </a> 0
<a> sb . append ( "{" ) ; </a> 0
<a> for ( Map . Entry < String , DispatchTable > e : dispatchMap . entrySet ( ) ) { </a> 0
<a> if ( ! e . getValue ( ) . isOverloaded ( ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> sb . append ( "\"" + e . getKey ( ) + "\":" + e . getValue ( ) . toJSON ( ) + "," ) ; </a> 0
<a> } </a> 0
<a> sb . append ( "}" ) ; </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> public static class Signature { </a> 0
<a> private JExportableMethod method ; </a> 0
<a> private JExportableParameter [ ] exportableParameters ; </a> 0
<a> public Signature ( JExportableMethod method , </a> 0
<a> JExportableParameter [ ] exportableParameters ) { </a> 0
<a> this . method = method ; </a> 0
<a> this . exportableParameters = exportableParameters ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object o ) { </a> 0
<a> if ( this == o ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( o == null || getClass ( ) != o . getClass ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> Signature signature = ( Signature ) o ; </a> 0
<a> if ( ! Arrays </a> 0
<a> . equals ( exportableParameters , signature . exportableParameters ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return exportableParameters != null ? Arrays </a> 0
<a> . hashCode ( exportableParameters ) : 0 ; </a> 0
<a> } </a> 0
<a> public String toJSON ( ) { </a> 0
<a> StringBuilder sb = new StringBuilder ( ) ; </a> 0
<a> sb . append ( "[" ) ; </a> 0
<a> String functionRef = "@" + method . getJSNIReference ( ) ; </a> 0
<a> if ( method . isStatic ( ) ) { </a> 0
<a> sb . append ( functionRef ) ; </a> 0
<a> } else { </a> 0
<a> sb . append ( "function() { return this." + functionRef + ".apply(this, arguments); }" ) ; </a> 0
<a> } </a> 0
<a> sb . append ( "," ) ; </a> 0
<a> sb . append ( method . getExportableReturnType ( ) . getWrapperFunc ( ) + "," ) ; </a> 0
<a> for ( JExportableParameter param : exportableParameters ) { </a> 0
<a> String jsType = param . getJsTypeOf ( ) ; </a> 0
<a> if ( jsType . equals ( "number" ) || jsType . equals ( "object" ) || </a> 0
<a> jsType . equals ( "string" ) || jsType . equals ( "boolean" ) ) { </a> 0
<a> jsType = "\"" + jsType + "\"" ; </a> 0
<a> } </a> 0
<a> sb . append ( jsType + "," ) ; </a> 0
<a> } </a> 0
<a> sb . append ( "]" ) ; </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public String toJSON ( ) { </a> 0
<a> StringBuilder json = new StringBuilder ( ) ; </a> 0
<a> json . append ( "{" ) ; </a> 0
<a> for ( Integer arity : sigMap . keySet ( ) ) { </a> 0
<a> json . append ( "" + arity + ":" + toJSON ( sigMap . get ( arity ) ) + "," ) ; </a> 0
<a> } </a> 0
<a> json . append ( "}" ) ; </a> 0
<a> return json . toString ( ) ; </a> 0
<a> } </a> 0
<a> static boolean isAnyOverridden ( HashMap < String , DispatchTable > dispatchMap ) { </a> 0
<a> for ( Map . Entry < String , DispatchTable > e : dispatchMap . entrySet ( ) ) { </a> 0
<a> if ( e . getValue ( ) . isOverloaded ( ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private String toJSON ( Set < Signature > signatures ) { </a> 0
<a> StringBuilder sb = new StringBuilder ( ) ; </a> 0
<a> sb . append ( "[" ) ; </a> 0
<a> for ( Signature s : signatures ) { </a> 0
<a> sb . append ( s . toJSON ( ) + "," ) ; </a> 0
<a> } </a> 0
<a> sb . append ( "]" ) ; </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> private Map < Integer , Set < Signature > > sigMap </a> 0
<a> = new HashMap < Integer , Set < Signature > > ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . plugin . jms ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . util . AbstractBroadcasterProxy ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . jms . Connection ; </a> 0
<a> import javax . jms . ConnectionFactory ; </a> 0
<a> import javax . jms . JMSException ; </a> 0
<a> import javax . jms . Message ; </a> 0
<a> import javax . jms . MessageConsumer ; </a> 0
<a> import javax . jms . MessageListener ; </a> 0
<a> import javax . jms . MessageProducer ; </a> 0
<a> import javax . jms . Session ; </a> 0
<a> import javax . jms . TextMessage ; </a> 0
<a> import javax . jms . Topic ; </a> 0
<a> import javax . naming . Context ; </a> 0
<a> import javax . naming . InitialContext ; </a> 0
<a> public class JMSBroadcaster extends AbstractBroadcasterProxy { </a> 0
<a> private static final String JMS_TOPIC = JMSBroadcaster . class . getName ( ) + ".topic" ; </a> 0
<a> private static final String JNDI_NAMESPACE = JMSBroadcaster . class . getName ( ) + ".JNDINamespace" ; </a> 0
<a> private static final String JNDI_FACTORY_NAME = JMSBroadcaster . class . getName ( ) + ".JNDIConnectionFactoryName" ; </a> 0
<a> private static final String JNDI_TOPIC = JMSBroadcaster . class . getName ( ) + ".JNDITopic" ; </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( JMSBroadcaster . class ) ; </a> 0
<a> private Connection connection ; </a> 0
<a> private Session session ; </a> 1
<a> private Topic topic ; </a> 0
<a> private MessageConsumer consumer ; </a> 0
<a> private MessageProducer publisher ; </a> 0
<a> private String topicId = "atmosphere" ; </a> 0
<a> private String factoryName = "atmosphereFactory" ; </a> 0
<a> private String namespace = "jms/" ; </a> 0
<a> public JMSBroadcaster ( ) { </a> 0
<a> super ( JMSBroadcaster . class . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> public JMSBroadcaster ( String id ) { </a> 0
<a> super ( id ) ; </a> 0
<a> } </a> 0
<a> public synchronized void configure ( AtmosphereServlet . AtmosphereConfig config ) { </a> 0
<a> try { </a> 0
<a> if ( config != null ) { </a> 0
<a> if ( config . getInitParameter ( JMS_TOPIC ) != null ) { </a> 0
<a> topicId = config . getInitParameter ( JMS_TOPIC ) ; </a> 0
<a> } </a> 0
<a> if ( config . getInitParameter ( JNDI_NAMESPACE ) != null ) { </a> 0
<a> namespace = config . getInitParameter ( JNDI_NAMESPACE ) ; </a> 0
<a> } </a> 0
<a> if ( config . getInitParameter ( JNDI_FACTORY_NAME ) != null ) { </a> 0
<a> factoryName = config . getInitParameter ( JNDI_FACTORY_NAME ) ; </a> 0
<a> } </a> 0
<a> if ( config . getInitParameter ( JNDI_TOPIC ) != null ) { </a> 0
<a> topicId = config . getInitParameter ( JNDI_TOPIC ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> logger . info ( "Looking up Connection Factory {}" , namespace + factoryName ) ; </a> 0
<a> Context ctx = new InitialContext ( ) ; </a> 0
<a> ConnectionFactory connectionFactory = ( ConnectionFactory ) ctx . lookup ( namespace + factoryName ) ; </a> 0
<a> logger . info ( "Looking up topic: {}" , topicId ) ; </a> 0
<a> topic = ( Topic ) ctx . lookup ( namespace + topicId ) ; </a> 0
<a> connection = connectionFactory . createConnection ( ) ; </a> 0
<a> session = connection . createSession ( false , Session . AUTO_ACKNOWLEDGE ) ; </a> 1
<a> publisher = session . createProducer ( topic ) ; </a> 1
<a> connection . start ( ) ; </a> 0
<a> logger . info ( "JMS created for topic {}" , topicId ) ; </a> 0
<a> this . notify ( ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> String msg = "Unable to configure JMSBroadcaster" ; </a> 0
<a> logger . error ( msg , e ) ; </a> 0
<a> throw new RuntimeException ( msg , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void incomingBroadcast ( ) { </a> 0
<a> synchronized ( this ) { </a> 0
<a> while ( session == null ) { </a> 1
<a> try { </a> 0
<a> this . wait ( 1000 ) ; </a> 0
<a> } catch ( InterruptedException e ) { } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> restartConsumer ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setID ( String id ) { </a> 0
<a> super . setID ( id ) ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( session != null ) </a> 1
<a> restartConsumer ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void restartConsumer ( ) { </a> 0
<a> try { </a> 0
<a> String id = getID ( ) ; </a> 0
<a> if ( id . startsWith ( "/*" ) ) { </a> 0
<a> id = "atmosphere" ; </a> 0
<a> } </a> 0
<a> if ( consumer != null ) { </a> 0
<a> consumer . close ( ) ; </a> 0
<a> consumer = null ; </a> 0
<a> } </a> 0
<a> logger . info ( "Create JMS consumer: {}" , id ) ; </a> 0
<a> String selector = String . format ( "BroadcasterId = '%s'" , id ) ; </a> 0
<a> consumer = session . createConsumer ( topic , selector ) ; </a> 1
<a> consumer . setMessageListener ( new MessageListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onMessage ( Message msg ) { </a> 0
<a> try { </a> 0
<a> TextMessage textMessage = ( TextMessage ) msg ; </a> 0
<a> String message = textMessage . getText ( ) ; </a> 0
<a> if ( message != null && bc != null ) { </a> 0
<a> broadcastReceivedMessage ( message ) ; </a> 0
<a> } </a> 0
<a> } catch ( JMSException ex ) { </a> 0
<a> logger . warn ( "Failed to broadcast message" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> logger . info ( "Consumer created for topic {}, with filter {}" , </a> 0
<a> topicId , selector ) ; </a> 0
<a> } catch ( Throwable ex ) { </a> 0
<a> String msg = "Unable to initialize JMSBroadcaster" ; </a> 0
<a> logger . error ( msg , ex ) ; </a> 0
<a> throw new IllegalStateException ( msg , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void outgoingBroadcast ( Object message ) { </a> 0
<a> try { </a> 0
<a> String id = getID ( ) ; </a> 0
<a> if ( id . startsWith ( "/*" ) ) { </a> 0
<a> id = "atmosphere" ; </a> 0
<a> } </a> 0
<a> if ( session == null ) { </a> 1
<a> throw new IllegalStateException ( "JMS Session is null" ) ; </a> 0
<a> } </a> 0
<a> TextMessage textMessage = session . createTextMessage ( message </a> 1
<a> . toString ( ) ) ; </a> 0
<a> textMessage . setStringProperty ( "BroadcasterId" , id ) ; </a> 0
<a> publisher . send ( textMessage ) ; </a> 0
<a> } catch ( JMSException ex ) { </a> 0
<a> logger . warn ( "Failed to send message over JMS" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized void releaseExternalResources ( ) { </a> 0
<a> try { </a> 0
<a> connection . close ( ) ; </a> 0
<a> session . close ( ) ; </a> 1
<a> consumer . close ( ) ; </a> 0
<a> publisher . close ( ) ; </a> 0
<a> } catch ( Throwable ex ) { </a> 0
<a> logger . warn ( "releaseExternalResources" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . annotation ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import java . lang . annotation . Documented ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( { ElementType . TYPE , ElementType . METHOD } ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> @ Documented </a> 0
<a> public @ interface Cluster { </a> 0
<a> String name ( ) default "Atmosphere" ; </a> 0
<a> Class < ? extends org . atmosphere . cpr . ClusterBroadcastFilter > [ ] value ( ) </a> 0
<a> default { org . atmosphere . cpr . ClusterBroadcastFilter . class } ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . annotation ; </a> 0
<a> import java . lang . annotation . Documented ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( { ElementType . METHOD } ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> @ Documented </a> 0
<a> public @ interface Publish { </a> 0
<a> String value ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . jboss . servlet . http ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> public interface HttpEvent { </a> 0
<a> public enum EventType { BEGIN , READ , END , ERROR , TIMEOUT , EOF } </a> 0
<a> public HttpServletRequest getHttpServletRequest ( ) ; </a> 0
<a> public HttpServletResponse getHttpServletResponse ( ) ; </a> 0
<a> public EventType getType ( ) ; </a> 0
<a> public void close ( ) throws IOException ; </a> 0
<a> public void setTimeout ( int timeout ) </a> 0
<a> throws IOException , ServletException , UnsupportedOperationException ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . apache . catalina ; </a> 0
<a> import javax . servlet . Servlet ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> public interface CometProcessor extends Servlet { </a> 0
<a> public void event ( CometEvent event ) </a> 0
<a> throws IOException , ServletException ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package weblogic . servlet . http ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 1
<a> import javax . servlet . http . HttpServletResponse ; </a> 1
<a> public class RequestResponseKey { </a> 1
<a> public HttpServletRequest getRequest ( ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-weblogic from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public HttpServletResponse getResponse ( ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-weblogic from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public void setTimeout ( int i ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-weblogic from your classpath" ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cache ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . X_CACHE_DATE ; </a> 0
<a> public class HeaderBroadcasterCache extends BroadcasterCacheBase { </a> 1
<a> public void cache ( final AtmosphereResource < HttpServletRequest , HttpServletResponse > r , CachedMessage cm ) { </a> 0
<a> long time = cm . next ( ) == null ? cm . currentTime ( ) : cm . next ( ) . currentTime ( ) ; </a> 1
<a> r . getResponse ( ) . addHeader ( X_CACHE_DATE , String . valueOf ( time ) ) ; </a> 1
<a> } </a> 1
<a> public CachedMessage retrieveLastMessage ( final AtmosphereResource < HttpServletRequest , HttpServletResponse > r ) { </a> 0
<a> HttpServletRequest request = r . getRequest ( ) ; </a> 0
<a> return retrieveUsingHeader ( request . getHeader ( X_CACHE_DATE ) ) ; </a> 1
<a> } </a> 0
<a> public CachedMessage retrieveUsingHeader ( final String dateString ) { </a> 1
<a> if ( dateString == null ) return null ; </a> 1
<a> long currentTime = Long . valueOf ( dateString ) ; </a> 1
<a> CachedMessage prev = null ; </a> 1
<a> for ( CachedMessage cm : queue ) { </a> 1
<a> if ( cm . currentTime ( ) > currentTime ) { </a> 1
<a> return prev ; </a> 1
<a> } </a> 0
<a> prev = cm ; </a> 1
<a> } </a> 1
<a> return prev ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . client ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> public class FormParamFilter implements BroadcastFilter { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( FormParamFilter . class ) ; </a> 0
<a> @ Override </a> 0
<a> public BroadcastAction filter ( Object originalMessage , Object message ) { </a> 0
<a> if ( ( message instanceof String ) && ( ( String ) message ) . contains ( "=" ) ) { </a> 0
<a> try { </a> 0
<a> message = message . toString ( ) . split ( "=" ) [ 1 ] ; </a> 0
<a> } catch ( ArrayIndexOutOfBoundsException ex ) { </a> 0
<a> logger . warn ( "failed to split form param: " + message , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return new BroadcastAction ( BroadcastAction . ACTION . CONTINUE , message ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . client ; </a> 0
<a> import org . atmosphere . cpr . PerRequestBroadcastFilter ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . X_ATMOSPHERE_TRACKMESSAGESIZE ; </a> 0
<a> public class TrackMessageSizeFilter implements PerRequestBroadcastFilter { </a> 0
<a> @ Override </a> 0
<a> public BroadcastAction filter ( HttpServletRequest request , HttpServletResponse response , Object message ) { </a> 1
<a> if ( "true" . equalsIgnoreCase ( request . getHeader ( X_ATMOSPHERE_TRACKMESSAGESIZE ) ) </a> 1
<a> && message != null && String . class . isAssignableFrom ( message . getClass ( ) ) ) { </a> 0
<a> String msg = message . toString ( ) ; </a> 1
<a> msg = msg . length ( ) + "|" + msg ; </a> 1
<a> return new BroadcastAction ( BroadcastAction . ACTION . CONTINUE , msg ) ; </a> 1
<a> } </a> 0
<a> return new BroadcastAction ( BroadcastAction . ACTION . CONTINUE , message ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public BroadcastAction filter ( Object originalMessage , Object message ) { </a> 1
<a> return new BroadcastAction ( message ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import org . apache . catalina . CometEvent ; </a> 1
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AsynchronousProcessor ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . CometSupport ; </a> 1
<a> import org . jboss . servlet . http . HttpEvent ; </a> 1
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 0
<a> import java . util . concurrent . CountDownLatch ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public class BlockingIOCometSupport extends AsynchronousProcessor { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( BlockingIOCometSupport . class ) ; </a> 0
<a> protected static final String LATCH = "org.atmosphere.container.BlockingIOCometSupport.latch" ; </a> 0
<a> protected final ConcurrentHashMap < Integer , CountDownLatch > latchs </a> 0
<a> = new ConcurrentHashMap < Integer , CountDownLatch > ( ) ; </a> 0
<a> public BlockingIOCometSupport ( AtmosphereConfig config ) { </a> 0
<a> super ( config ) ; </a> 0
<a> } </a> 0
<a> public Action service ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> Action action = null ; </a> 0
<a> try { </a> 0
<a> action = suspended ( req , res ) ; </a> 0
<a> if ( action . type == Action . TYPE . SUSPEND ) { </a> 0
<a> logger . debug ( "Suspending response: {}" , res ) ; </a> 1
<a> suspend ( action , req , res ) ; </a> 0
<a> } else if ( action . type == Action . TYPE . RESUME ) { </a> 0
<a> logger . debug ( "Resuming response: {}" , res ) ; </a> 1
<a> int latchId = ( req . getAttribute ( LATCH ) == null ? 0 : ( Integer ) req . getAttribute ( LATCH ) ) ; </a> 0
<a> if ( req . getSession ( false ) != null && req . getSession ( false ) . getAttribute ( LATCH ) != null ) { </a> 0
<a> latchId = ( Integer ) req . getSession ( false ) . getAttribute ( LATCH ) ; </a> 0
<a> } </a> 0
<a> CountDownLatch latch = latchs . get ( latchId ) ; </a> 0
<a> if ( latch == null && req . getAttribute ( AtmosphereResourceImpl . PRE_SUSPEND ) == null ) { </a> 0
<a> logger . debug ( "response wasn't suspended: {}" , res ) ; </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> Action nextAction = resumed ( req , res ) ; </a> 0
<a> if ( nextAction . type == Action . TYPE . SUSPEND ) { </a> 0
<a> logger . debug ( "Suspending after resuming response: {}" , res ) ; </a> 1
<a> suspend ( action , req , res ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> CometEvent event = ( CometEvent ) req . getAttribute ( TomcatCometSupport . COMET_EVENT ) ; </a> 1
<a> if ( event != null ) { </a> 0
<a> event . close ( ) ; </a> 1
<a> } </a> 0
<a> HttpEvent he = ( HttpEvent ) req . getAttribute ( JBossWebCometSupport . HTTP_EVENT ) ; </a> 1
<a> if ( he != null ) { </a> 1
<a> he . close ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> protected void suspend ( Action action , HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> int hash = latch . hashCode ( ) ; </a> 0
<a> req . setAttribute ( LATCH , hash ) ; </a> 0
<a> latchs . put ( hash , latch ) ; </a> 0
<a> if ( supportSession ( ) ) { </a> 0
<a> req . getSession ( ) . setAttribute ( String . valueOf ( req . hashCode ( ) ) , hash ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> if ( action . timeout != - 1 ) { </a> 0
<a> latch . await ( action . timeout , TimeUnit . MILLISECONDS ) ; </a> 0
<a> } else { </a> 0
<a> latch . await ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( InterruptedException ex ) { </a> 0
<a> logger . debug ( "" , ex ) ; </a> 0
<a> } finally { </a> 0
<a> latchs . remove ( hash ) ; </a> 0
<a> timedout ( req , res ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Action cancelled ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> int latchId = - 1 ; </a> 0
<a> if ( req . getAttribute ( LATCH ) != null ) { </a> 0
<a> latchId = ( Integer ) req . getAttribute ( LATCH ) ; </a> 0
<a> } </a> 0
<a> CountDownLatch latch = latchs . remove ( latchId ) ; </a> 0
<a> Action a = super . cancelled ( req , res ) ; </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> return a ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void action ( AtmosphereResourceImpl actionEvent ) { </a> 0
<a> try { </a> 0
<a> super . action ( actionEvent ) ; </a> 0
<a> if ( actionEvent . action ( ) . type == Action . TYPE . RESUME && actionEvent . isInScope ( ) ) { </a> 0
<a> int latchId = - 1 ; </a> 0
<a> HttpServletRequest req = actionEvent . getRequest ( ) ; </a> 0
<a> if ( req . getAttribute ( LATCH ) != null ) { </a> 0
<a> latchId = ( Integer ) req . getAttribute ( LATCH ) ; </a> 0
<a> } </a> 0
<a> if ( latchId == - 1 && supportSession ( ) ) { </a> 0
<a> if ( req . getSession ( ) . getAttribute ( LATCH ) != null ) { </a> 0
<a> latchId = ( Integer ) req . getSession ( ) . getAttribute ( LATCH ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> String s = config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) ; </a> 0
<a> if ( latchId != - 1 && ( s == null || s . equalsIgnoreCase ( "false" ) ) ) { </a> 0
<a> CountDownLatch latch = latchs . remove ( latchId ) ; </a> 0
<a> if ( latch == null ) { </a> 0
<a> logger . error ( "Unable to resume the suspended connection with latchId: {}" , latchId ) ; </a> 0
<a> } else { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } else if ( req . getAttribute ( AtmosphereResourceImpl . PRE_SUSPEND ) == null ) { </a> 0
<a> logger . error ( "Unable to resume the suspended connection" ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } catch ( Exception ex ) { </a> 1
<a> logger . error ( "" , ex ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import org . atmosphere . cpr . AsynchronousProcessor ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . atmosphere . cpr . CometSupport ; </a> 0
<a> import org . atmosphere . websocket . JettyWebSocketHandler ; </a> 0
<a> import org . atmosphere . websocket . WebSocket ; </a> 0
<a> import org . atmosphere . websocket . container . JettyWebSocket ; </a> 0
<a> import org . eclipse . jetty . websocket . WebSocketFactory ; </a> 1
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import javax . servlet . ServletException ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> public class JettyCometSupportWithWebSocket extends Jetty7CometSupport { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( JettyCometSupportWithWebSocket . class ) ; </a> 1
<a> private final WebSocketFactory webSocketFactory ; </a> 1
<a> public JettyCometSupportWithWebSocket ( final AtmosphereConfig config ) { </a> 1
<a> super ( config ) ; </a> 1
<a> String [ ] jettyVersion = config . getServletContext ( ) . getServerInfo ( ) . substring ( 6 ) . split ( "\\." ) ; </a> 1
<a> if ( Integer . valueOf ( jettyVersion [ 0 ] ) > 7 || Integer . valueOf ( jettyVersion [ 0 ] ) == 7 && Integer . valueOf ( jettyVersion [ 1 ] ) > 4 ) { </a> 1
<a> webSocketFactory = JettyWebSocketUtil . getFactory ( config ) ; </a> 0
<a> } else { </a> 1
<a> webSocketFactory = null ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public Action service ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 1
<a> Action action = JettyWebSocketUtil . doService ( this , req , res , webSocketFactory ) ; </a> 1
<a> return action == null ? super . service ( req , res ) : action ; </a> 1
<a> } </a> 1
<a> public String getContainerName ( ) { </a> 1
<a> return config . getServletConfig ( ) . getServletContext ( ) . getServerInfo ( ) + " with WebSocket enabled." ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean supportWebSocket ( ) { </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AsynchronousProcessor ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . AsyncContext ; </a> 0
<a> import javax . servlet . AsyncEvent ; </a> 0
<a> import javax . servlet . AsyncListener ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> public class Servlet30CometSupport extends AsynchronousProcessor { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( Servlet30CometSupport . class ) ; </a> 0
<a> public Servlet30CometSupport ( AtmosphereConfig config ) { </a> 0
<a> super ( config ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String getContainerName ( ) { </a> 0
<a> return super . getContainerName ( ) + " using javax.servlet/3.0" ; </a> 0
<a> } </a> 0
<a> public Action service ( HttpServletRequest request , HttpServletResponse response ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> Action action = suspended ( request , response ) ; </a> 0
<a> if ( action . type == Action . TYPE . SUSPEND ) { </a> 0
<a> logger . debug ( "Suspending response: {}" , response ) ; </a> 1
<a> suspend ( action , request , response ) ; </a> 0
<a> } else if ( action . type == Action . TYPE . RESUME ) { </a> 0
<a> logger . debug ( "Resuming response: {}" , response ) ; </a> 1
<a> if ( supportSession ( ) ) { </a> 1
<a> AsyncContext asyncContext = </a> 1
<a> ( AsyncContext ) request . getSession ( ) . getAttribute ( "org.atmosphere.container.asyncContext" ) ; </a> 1
<a> if ( asyncContext != null ) { </a> 1
<a> asyncContext . complete ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> Action nextAction = resumed ( request , response ) ; </a> 0
<a> if ( nextAction . type == Action . TYPE . SUSPEND ) { </a> 0
<a> logger . debug ( "Suspending after resuming response: {}" , response ) ; </a> 1
<a> suspend ( action , request , response ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> private void suspend ( Action action , HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> if ( ! req . isAsyncStarted ( ) ) { </a> 0
<a> AsyncContext asyncContext = req . startAsync ( ) ; </a> 1
<a> asyncContext . addListener ( new CometListener ( ) ) ; </a> 1
<a> if ( action . timeout != - 1 ) { </a> 0
<a> asyncContext . setTimeout ( action . timeout ) ; </a> 0
<a> } else { </a> 0
<a> asyncContext . setTimeout ( Integer . MAX_VALUE ) ; </a> 0
<a> } </a> 0
<a> req . setAttribute ( "org.atmosphere.container.asyncContext" , asyncContext ) ; </a> 1
<a> if ( supportSession ( ) ) { </a> 1
<a> req . getSession ( ) . setAttribute ( "org.atmosphere.container.asyncContext" , asyncContext ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void action ( AtmosphereResourceImpl actionEvent ) { </a> 0
<a> if ( actionEvent . action ( ) . type == Action . TYPE . RESUME && actionEvent . isInScope ( ) ) { </a> 0
<a> AsyncContext asyncContext = </a> 0
<a> ( AsyncContext ) actionEvent . getRequest ( ) . getAttribute ( "org.atmosphere.container.asyncContext" ) ; </a> 1
<a> if ( asyncContext == null && supportSession ( ) ) { </a> 1
<a> asyncContext = ( AsyncContext ) actionEvent . getRequest ( ) . getSession ( ) </a> 1
<a> . getAttribute ( "org.atmosphere.container.asyncContext" ) ; </a> 1
<a> } </a> 1
<a> if ( asyncContext != null && ( config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) == null </a> 0
<a> || config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) . equalsIgnoreCase ( "false" ) ) ) { </a> 0
<a> asyncContext . complete ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 1
<a> if ( ! actionEvent . isInScope ( ) ) { </a> 1
<a> logger . debug ( "Already resumed or cancelled: event: {}" , actionEvent ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> private class CometListener implements AsyncListener { </a> 1
<a> public void onComplete ( AsyncEvent event ) throws IOException { </a> 0
<a> logger . debug ( "Resumed (completed): event: {}" , event . getAsyncContext ( ) . getRequest ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onTimeout ( AsyncEvent event ) throws IOException { </a> 0
<a> logger . debug ( "onTimeout(): event: {}" , event . getAsyncContext ( ) . getRequest ( ) ) ; </a> 1
<a> try { </a> 0
<a> timedout ( ( HttpServletRequest ) event . getAsyncContext ( ) . getRequest ( ) , </a> 0
<a> ( HttpServletResponse ) event . getAsyncContext ( ) . getResponse ( ) ) ; </a> 0
<a> } catch ( ServletException ex ) { </a> 0
<a> logger . debug ( "onTimeout(): failed timing out comet response: " + event . getAsyncContext ( ) . getResponse ( ) , ex ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> public void onError ( AsyncEvent event ) { </a> 0
<a> logger . debug ( "onError(): event: {}" , event . getAsyncContext ( ) . getResponse ( ) ) ; </a> 1
<a> try { </a> 0
<a> cancelled ( ( HttpServletRequest ) event . getAsyncContext ( ) . getRequest ( ) , </a> 0
<a> ( HttpServletResponse ) event . getAsyncContext ( ) . getResponse ( ) ) ; </a> 0
<a> } catch ( Throwable ex ) { </a> 0
<a> logger . debug ( "failed cancelling comet response: " + event . getAsyncContext ( ) . getResponse ( ) , ex ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> public void onStartAsync ( AsyncEvent event ) { </a> 0
<a> logger . debug ( "onStartAsync(): event: {}" , event . getAsyncContext ( ) . getResponse ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import org . apache . catalina . CometEvent ; </a> 0
<a> import org . apache . catalina . CometEvent . EventType ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AsynchronousProcessor ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . MAX_INACTIVE ; </a> 0
<a> public class TomcatCometSupport extends AsynchronousProcessor { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( TomcatCometSupport . class ) ; </a> 0
<a> public static final String COMET_EVENT = "CometEvent" ; </a> 0
<a> private static final IllegalStateException unableToDetectComet </a> 0
<a> = new IllegalStateException ( unableToDetectComet ( ) ) ; </a> 0
<a> private final ConcurrentLinkedQueue < CometEvent > resumed </a> 0
<a> = new ConcurrentLinkedQueue < CometEvent > ( ) ; </a> 0
<a> public TomcatCometSupport ( AtmosphereConfig config ) { </a> 0
<a> super ( config ) ; </a> 0
<a> } </a> 0
<a> public Action service ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> CometEvent event = ( CometEvent ) req . getAttribute ( COMET_EVENT ) ; </a> 0
<a> if ( event == null ) { </a> 0
<a> throw unableToDetectComet ; </a> 0
<a> } </a> 0
<a> Action action = null ; </a> 0
<a> if ( event . getEventType ( ) == EventType . BEGIN ) { </a> 0
<a> action = suspended ( req , res ) ; </a> 0
<a> if ( action . type == Action . TYPE . SUSPEND ) { </a> 0
<a> logger . debug ( "Suspending response: {}" , res ) ; </a> 1
<a> try { </a> 0
<a> if ( action . timeout != - 1 ) { </a> 0
<a> event . setTimeout ( ( int ) action . timeout ) ; </a> 0
<a> } else { </a> 0
<a> event . setTimeout ( Integer . MAX_VALUE ) ; </a> 0
<a> } </a> 0
<a> } catch ( UnsupportedOperationException ex ) { </a> 0
<a> } </a> 0
<a> } else if ( action . type == Action . TYPE . RESUME ) { </a> 0
<a> logger . debug ( "Resuming response: {}" , res ) ; </a> 1
<a> event . close ( ) ; </a> 1
<a> } else { </a> 0
<a> event . close ( ) ; </a> 1
<a> } </a> 0
<a> } else if ( event . getEventType ( ) == EventType . READ ) { </a> 0
<a> } else if ( event . getEventSubType ( ) == CometEvent . EventSubType . CLIENT_DISCONNECT ) { </a> 0
<a> logger . debug ( "Client closed connection: response: {}" , res ) ; </a> 1
<a> if ( ! resumed . remove ( event ) ) { </a> 0
<a> logger . debug ( "Client closed connection: response: {}" , res ) ; </a> 0
<a> action = cancelled ( req , res ) ; </a> 0
<a> } else { </a> 1
<a> logger . debug ( "Cancelling response: {}" , res ) ; </a> 1
<a> } </a> 0
<a> event . close ( ) ; </a> 1
<a> } else if ( event . getEventSubType ( ) == CometEvent . EventSubType . TIMEOUT ) { </a> 1
<a> logger . debug ( "Timing out response: {}" , res ) ; </a> 1
<a> action = timedout ( req , res ) ; </a> 0
<a> event . close ( ) ; </a> 1
<a> } else if ( event . getEventType ( ) == EventType . ERROR ) { </a> 0
<a> event . close ( ) ; </a> 1
<a> } else if ( event . getEventType ( ) == EventType . END ) { </a> 0
<a> if ( ! resumed . remove ( event ) ) { </a> 0
<a> logger . debug ( "Client closed connection: response: {}" , res ) ; </a> 1
<a> action = cancelled ( req , res ) ; </a> 1
<a> } else { </a> 0
<a> logger . debug ( "Cancelling response: {}" , res ) ; </a> 1
<a> } </a> 0
<a> event . close ( ) ; </a> 1
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void action ( AtmosphereResourceImpl resource ) { </a> 1
<a> super . action ( resource ) ; </a> 1
<a> if ( resource . action ( ) . type == Action . TYPE . RESUME && resource . isInScope ( ) ) { </a> 0
<a> try { </a> 1
<a> CometEvent event = ( CometEvent ) resource . getRequest ( ) . getAttribute ( COMET_EVENT ) ; </a> 1
<a> if ( event == null ) return ; </a> 1
<a> resumed . offer ( event ) ; </a> 0
<a> if ( config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) == null </a> 0
<a> || config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) . equalsIgnoreCase ( "false" ) ) { </a> 0
<a> event . close ( ) ; </a> 1
<a> } </a> 0
<a> } catch ( IOException ex ) { </a> 1
<a> logger . debug ( "action failed" , ex ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Action cancelled ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> Action action = super . cancelled ( req , res ) ; </a> 0
<a> if ( req . getAttribute ( MAX_INACTIVE ) != null && Long . class . cast ( req . getAttribute ( MAX_INACTIVE ) ) == - 1 ) { </a> 0
<a> CometEvent event = ( CometEvent ) req . getAttribute ( COMET_EVENT ) ; </a> 0
<a> if ( event == null ) return action ; </a> 0
<a> resumed . offer ( event ) ; </a> 0
<a> event . close ( ) ; </a> 0
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> private static String unableToDetectComet ( ) { </a> 0
<a> StringBuilder sb = new StringBuilder ( ) ; </a> 0
<a> sb . append ( "Tomcat failed to detect this is a Comet application because context.xml " ) ; </a> 0
<a> sb . append ( "is missing or the Http11NioProtocol Connector is not enabled." ) ; </a> 0
<a> sb . append ( "\nIf that's not the case, you can also remove META-INF/context.xml and WEB-INF/lib/atmosphere-compat-tomcat.jar" ) ; </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public interface AtmosphereResource < E , F > extends Trackable { </a> 0
<a> public void resume ( ) ; </a> 1
<a> public void suspend ( ) ; </a> 1
<a> public void suspend ( long timeout ) ; </a> 1
<a> public void suspend ( long timeout , TimeUnit timeunit ) ; </a> 1
<a> public void suspend ( long timeout , boolean flushComment ) ; </a> 1
<a> public void suspend ( long timeout , TimeUnit timeunit , boolean flushComment ) ; </a> 1
<a> public E getRequest ( ) ; </a> 0
<a> public F getResponse ( ) ; </a> 0
<a> public AtmosphereConfig getAtmosphereConfig ( ) ; </a> 1
<a> public Broadcaster getBroadcaster ( ) ; </a> 1
<a> public void setBroadcaster ( Broadcaster broadcaster ) ; </a> 1
<a> public void setSerializer ( Serializer s ) ; </a> 1
<a> public void write ( OutputStream os , Object o ) throws IOException ; </a> 1
<a> public Serializer getSerializer ( ) ; </a> 1
<a> public AtmosphereResourceEvent getAtmosphereResourceEvent ( ) ; </a> 1
<a> public AtmosphereHandler getAtmosphereHandler ( ) ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> public interface BroadcastFilterLifecycle extends BroadcastFilter { </a> 0
<a> void init ( ) ; </a> 0
<a> void destroy ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import java . util . List ; </a> 0
<a> public interface BroadcasterCache < V , W > { </a> 0
<a> public final static String BROADCASTER_CACHE_TRACKER = BroadcasterCache . class . getName ( ) ; </a> 1
<a> void start ( ) ; </a> 0
<a> void stop ( ) ; </a> 0
<a> void addToCache ( AtmosphereResource < V , W > r , Object e ) ; </a> 0
<a> List < Object > retrieveFromCache ( AtmosphereResource < V , W > r ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter . BroadcastAction ; </a> 0
<a> import org . atmosphere . di . InjectorProvider ; </a> 1
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . util . ArrayList ; </a> 1
<a> import java . util . List ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import java . util . concurrent . ExecutorService ; </a> 0
<a> import java . util . concurrent . Executors ; </a> 0
<a> import java . util . concurrent . ScheduledExecutorService ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 1
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 1
<a> public class BroadcasterConfig { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( BroadcasterConfig . class ) ; </a> 0
<a> protected final ConcurrentLinkedQueue < BroadcastFilter > filters = </a> 0
<a> new ConcurrentLinkedQueue < BroadcastFilter > ( ) ; </a> 0
<a> protected final ConcurrentLinkedQueue < PerRequestBroadcastFilter > perRequestFilters = </a> 0
<a> new ConcurrentLinkedQueue < PerRequestBroadcastFilter > ( ) ; </a> 0
<a> private ExecutorService executorService ; </a> 0
<a> private ExecutorService asyncWriteService ; </a> 0
<a> private ExecutorService defaultExecutorService ; </a> 1
<a> private ExecutorService defaultAsyncWriteService ; </a> 1
<a> private ScheduledExecutorService scheduler ; </a> 0
<a> private final Object [ ] lock = new Object [ 0 ] ; </a> 1
<a> private BroadcasterCache broadcasterCache ; </a> 1
<a> private AtmosphereServlet . AtmosphereConfig config ; </a> 0
<a> private boolean isExecutorShared = false ; </a> 0
<a> private boolean isAsyncExecutorShared = false ; </a> 0
<a> public BroadcasterConfig ( String [ ] list , AtmosphereServlet . AtmosphereConfig config ) { </a> 0
<a> this . config = config ; </a> 0
<a> configExecutors ( ) ; </a> 1
<a> configureBroadcasterFilter ( list ) ; </a> 1
<a> configureBroadcasterCache ( ) ; </a> 1
<a> } </a> 0
<a> private void configureBroadcasterCache ( ) { </a> 0
<a> try { </a> 0
<a> if ( AtmosphereServlet . broadcasterCacheClassName != null ) { </a> 0
<a> BroadcasterCache cache = ( BroadcasterCache ) Thread . currentThread ( ) . getContextClassLoader ( ) </a> 1
<a> . loadClass ( AtmosphereServlet . broadcasterCacheClassName ) . newInstance ( ) ; </a> 0
<a> InjectorProvider . getInjector ( ) . inject ( cache ) ; </a> 1
<a> setBroadcasterCache ( cache ) ; </a> 1
<a> } </a> 0
<a> } catch ( InstantiationException e ) { </a> 1
<a> throw new RuntimeException ( e ) ; </a> 1
<a> } catch ( IllegalAccessException e ) { </a> 1
<a> throw new RuntimeException ( e ) ; </a> 1
<a> } catch ( ClassNotFoundException e ) { </a> 1
<a> throw new RuntimeException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public BroadcasterConfig ( ExecutorService executorService , ExecutorService asyncWriteService , </a> 1
<a> ScheduledExecutorService scheduler , AtmosphereServlet . AtmosphereConfig config ) { </a> 1
<a> this . executorService = executorService ; </a> 1
<a> this . scheduler = scheduler ; </a> 1
<a> this . asyncWriteService = asyncWriteService ; </a> 1
<a> this . config = config ; </a> 1
<a> } </a> 1
<a> protected void configExecutors ( ) { </a> 0
<a> executorService = Executors . newSingleThreadExecutor ( new ThreadFactory ( ) { </a> 0
<a> private final AtomicInteger count = new AtomicInteger ( ) ; </a> 1
<a> @ Override </a> 1
<a> public Thread newThread ( final Runnable runnable ) { </a> 1
<a> Thread t = new Thread ( runnable , "Atmosphere-BroadcasterConfig-" + count . getAndIncrement ( ) ) ; </a> 1
<a> t . setDaemon ( true ) ; </a> 1
<a> return t ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> defaultExecutorService = executorService ; </a> 1
<a> asyncWriteService = Executors . newCachedThreadPool ( new ThreadFactory ( ) { </a> 1
<a> private final AtomicInteger count = new AtomicInteger ( ) ; </a> 1
<a> @ Override </a> 0
<a> public Thread newThread ( final Runnable runnable ) { </a> 0
<a> Thread t = new Thread ( runnable , "Atmosphere-AsyncWrite-" + count . getAndIncrement ( ) ) ; </a> 1
<a> t . setDaemon ( true ) ; </a> 1
<a> return t ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> defaultAsyncWriteService = asyncWriteService ; </a> 1
<a> } </a> 1
<a> public BroadcasterConfig setExecutorService ( ExecutorService executorService ) { </a> 0
<a> return setExecutorService ( executorService , false ) ; </a> 0
<a> } </a> 0
<a> public BroadcasterConfig setExecutorService ( ExecutorService executorService , boolean isExecutorShared ) { </a> 0
<a> if ( ! this . isExecutorShared && this . executorService != null ) { </a> 0
<a> this . executorService . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> this . executorService = executorService ; </a> 0
<a> this . isExecutorShared = isExecutorShared ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ExecutorService getExecutorService ( ) { </a> 0
<a> return executorService ; </a> 0
<a> } </a> 0
<a> public BroadcasterConfig setAsyncWriteService ( ExecutorService asyncWriteService ) { </a> 0
<a> return setAsyncWriteService ( asyncWriteService , false ) ; </a> 0
<a> } </a> 0
<a> public BroadcasterConfig setAsyncWriteService ( ExecutorService asyncWriteService , boolean isAsyncExecutorShared ) { </a> 0
<a> if ( ! this . isAsyncExecutorShared && this . asyncWriteService != null ) { </a> 0
<a> this . asyncWriteService . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> this . asyncWriteService = asyncWriteService ; </a> 0
<a> this . isAsyncExecutorShared = isAsyncExecutorShared ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ExecutorService getAsyncWriteService ( ) { </a> 0
<a> return asyncWriteService ; </a> 0
<a> } </a> 0
<a> public boolean addFilter ( BroadcastFilter e ) { </a> 0
<a> if ( filters . contains ( e ) || checkDuplicateFilter ( e ) ) return false ; </a> 1
<a> if ( e instanceof BroadcastFilterLifecycle ) { </a> 0
<a> ( ( BroadcastFilterLifecycle ) e ) . init ( ) ; </a> 0
<a> } </a> 0
<a> if ( e instanceof PerRequestBroadcastFilter ) { </a> 0
<a> perRequestFilters . add ( ( PerRequestBroadcastFilter ) e ) ; </a> 0
<a> } </a> 0
<a> return filters . offer ( e ) ; </a> 0
<a> } </a> 0
<a> private boolean checkDuplicateFilter ( BroadcastFilter e ) { </a> 1
<a> for ( BroadcastFilter f : filters ) { </a> 0
<a> if ( f . getClass ( ) . isAssignableFrom ( e . getClass ( ) ) ) { </a> 0
<a> return true ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 1
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> if ( broadcasterCache != null ) { </a> 1
<a> broadcasterCache . stop ( ) ; </a> 0
<a> } </a> 0
<a> if ( ! isExecutorShared && executorService != null ) { </a> 0
<a> executorService . shutdownNow ( ) ; </a> 0
<a> } </a> 0
<a> if ( ! isAsyncExecutorShared && asyncWriteService != null ) { </a> 0
<a> asyncWriteService . shutdownNow ( ) ; </a> 0
<a> } </a> 0
<a> if ( ! isExecutorShared && defaultExecutorService != null ) { </a> 0
<a> defaultExecutorService . shutdownNow ( ) ; </a> 1
<a> } </a> 1
<a> if ( ! isAsyncExecutorShared && defaultAsyncWriteService != null ) { </a> 0
<a> defaultAsyncWriteService . shutdownNow ( ) ; </a> 1
<a> } </a> 1
<a> if ( scheduler != null ) { </a> 0
<a> scheduler . shutdownNow ( ) ; </a> 0
<a> } </a> 0
<a> for ( BroadcastFilter f : filters ) { </a> 1
<a> if ( f instanceof BroadcastFilterLifecycle ) { </a> 1
<a> ( ( BroadcastFilterLifecycle ) f ) . destroy ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> removeAllFilters ( ) ; </a> 1
<a> } </a> 0
<a> public boolean removeFilter ( BroadcastFilter filter ) { </a> 0
<a> if ( filter instanceof BroadcastFilterLifecycle ) { </a> 0
<a> ( ( BroadcastFilterLifecycle ) filter ) . destroy ( ) ; </a> 0
<a> } </a> 0
<a> if ( filter instanceof PerRequestBroadcastFilter ) { </a> 0
<a> perRequestFilters . remove ( filter ) ; </a> 0
<a> } </a> 0
<a> return filters . remove ( filter ) ; </a> 0
<a> } </a> 0
<a> public void removeAllFilters ( ) { </a> 0
<a> for ( BroadcastFilter filter : filters ) { </a> 0
<a> removeFilter ( filter ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public boolean hasFilters ( ) { </a> 0
<a> return ! filters . isEmpty ( ) ; </a> 0
<a> } </a> 0
<a> public boolean hasPerRequestFilters ( ) { </a> 0
<a> if ( filters . isEmpty ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } else { </a> 0
<a> for ( BroadcastFilter b : filters ) { </a> 0
<a> if ( PerRequestBroadcastFilter . class . isAssignableFrom ( b . getClass ( ) ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> protected BroadcastAction filter ( Object object ) { </a> 0
<a> BroadcastAction transformed = new BroadcastAction ( object ) ; </a> 0
<a> for ( BroadcastFilter mf : filters ) { </a> 0
<a> synchronized ( mf ) { </a> 0
<a> transformed = mf . filter ( object , transformed . message ( ) ) ; </a> 1
<a> if ( transformed == null || transformed . action ( ) == BroadcastAction . ACTION . ABORT ) { </a> 1
<a> return transformed ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return transformed ; </a> 1
<a> } </a> 0
<a> protected BroadcastAction filter ( HttpServletRequest request , HttpServletResponse response , Object object ) { </a> 1
<a> BroadcastAction transformed = new BroadcastAction ( object ) ; </a> 1
<a> for ( PerRequestBroadcastFilter mf : perRequestFilters ) { </a> 0
<a> synchronized ( mf ) { </a> 0
<a> transformed = mf . filter ( request , response , transformed . message ( ) ) ; </a> 1
<a> if ( transformed == null || transformed . action ( ) == BroadcastAction . ACTION . ABORT ) { </a> 1
<a> return transformed ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return transformed ; </a> 1
<a> } </a> 0
<a> public ExecutorService getDefaultExecutorService ( ) { </a> 1
<a> return defaultExecutorService ; </a> 1
<a> } </a> 1
<a> public BroadcasterConfig setScheduledExecutorService ( ScheduledExecutorService scheduler ) { </a> 0
<a> if ( this . scheduler != null ) { </a> 0
<a> this . scheduler . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> this . scheduler = scheduler ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ScheduledExecutorService getScheduledExecutorService ( ) { </a> 0
<a> synchronized ( lock ) { </a> 1
<a> if ( scheduler == null ) { </a> 1
<a> scheduler = Executors . newSingleThreadScheduledExecutor ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return scheduler ; </a> 0
<a> } </a> 0
<a> public BroadcasterConfig setBroadcasterCache ( BroadcasterCache broadcasterCache ) { </a> 0
<a> this . broadcasterCache = broadcasterCache ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public BroadcasterCache getBroadcasterCache ( ) { </a> 1
<a> if ( broadcasterCache == null ) { </a> 1
<a> broadcasterCache = new DefaultBroadcasterCache ( ) ; </a> 1
<a> } </a> 1
<a> return broadcasterCache ; </a> 0
<a> } </a> 0
<a> public static class DefaultBroadcasterCache implements BroadcasterCache { </a> 1
<a> private final List < Object > list = new ArrayList < Object > ( ) ; </a> 1
<a> public void start ( ) { </a> 1
<a> } </a> 1
<a> public void stop ( ) { </a> 1
<a> } </a> 1
<a> public void addToCache ( AtmosphereResource r , Object e ) { </a> 1
<a> } </a> 1
<a> public List < Object > retrieveFromCache ( AtmosphereResource r ) { </a> 1
<a> return list ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> void configureBroadcasterFilter ( String [ ] list ) { </a> 0
<a> for ( String broadcastFilter : list ) { </a> 0
<a> BroadcastFilter bf = null ; </a> 0
<a> try { </a> 0
<a> bf = BroadcastFilter . class </a> 1
<a> . cast ( Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( broadcastFilter ) . newInstance ( ) ) ; </a> 1
<a> } catch ( InstantiationException e ) { </a> 1
<a> logger . warn ( "Error trying to instantiate BroadcastFilter: " + broadcastFilter , e ) ; </a> 0
<a> } catch ( IllegalAccessException e ) { </a> 1
<a> logger . warn ( "Error trying to instantiate BroadcastFilter: " + broadcastFilter , e ) ; </a> 0
<a> } catch ( ClassNotFoundException e ) { </a> 1
<a> try { </a> 1
<a> bf = BroadcastFilter . class </a> 1
<a> . cast ( BroadcastFilter . class . getClassLoader ( ) . loadClass ( broadcastFilter ) . newInstance ( ) ) ; </a> 1
<a> } catch ( InstantiationException e1 ) { </a> 1
<a> } catch ( IllegalAccessException e1 ) { </a> 1
<a> } catch ( ClassNotFoundException e1 ) { </a> 1
<a> logger . warn ( "Error trying to instantiate BroadcastFilter: " + broadcastFilter , e ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> if ( bf != null ) { </a> 0
<a> InjectorProvider . getInjector ( ) . inject ( bf ) ; </a> 1
<a> addFilter ( bf ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> public AtmosphereServlet . AtmosphereConfig getAtmosphereConfig ( ) { </a> 0
<a> return config ; </a> 0
<a> } </a> 0
<a> public void setAtmosphereConfig ( AtmosphereServlet . AtmosphereConfig config ) { </a> 0
<a> this . config = config ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> public interface BroadcasterLifeCyclePolicyListener { </a> 0
<a> void onEmpty ( ) ; </a> 0
<a> void onIdle ( ) ; </a> 0
<a> void onDestroy ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> public interface ClusterBroadcastFilter extends BroadcastFilterLifecycle { </a> 0
<a> void setUri ( String name ) ; </a> 0
<a> void setBroadcaster ( Broadcaster bc ) ; </a> 0
<a> Broadcaster getBroadcaster ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 1
<a> import org . atmosphere . container . BlockingIOCometSupport ; </a> 1
<a> import org . atmosphere . container . GlassFishWebSocketSupport ; </a> 1
<a> import org . atmosphere . container . GlassFishv2CometSupport ; </a> 1
<a> import org . atmosphere . container . GrizzlyCometSupport ; </a> 1
<a> import org . atmosphere . container . JBossWebCometSupport ; </a> 1
<a> import org . atmosphere . container . Jetty7CometSupport ; </a> 1
<a> import org . atmosphere . container . JettyCometSupport ; </a> 0
<a> import org . atmosphere . container . JettyCometSupportWithWebSocket ; </a> 1
<a> import org . atmosphere . container . Servlet30CometSupport ; </a> 1
<a> import org . atmosphere . container . Servlet30CometSupportWithWebSocket ; </a> 1
<a> import org . atmosphere . container . Tomcat7CometSupport ; </a> 1
<a> import org . atmosphere . container . TomcatCometSupport ; </a> 1
<a> import org . atmosphere . container . WebLogicCometSupport ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import java . util . LinkedList ; </a> 1
<a> import java . util . List ; </a> 1
<a> public class DefaultCometSupportResolver implements CometSupportResolver { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( DefaultCometSupportResolver . class ) ; </a> 1
<a> public final static String SERVLET_30 = "javax.servlet.AsyncListener" ; </a> 1
<a> public final static String GLASSFISH_V2 = "com.sun.enterprise.web.PEWebContainer" ; </a> 1
<a> public final static String TOMCAT_7 = "org.apache.catalina.comet.CometFilterChain" ; </a> 1
<a> public final static String TOMCAT = "org.apache.coyote.http11.Http11NioProcessor" ; </a> 1
<a> public final static String JBOSS_5 = "org.jboss." ; </a> 1
<a> public final static String JETTY = "org.mortbay.util.ajax.Continuation" ; </a> 1
<a> public final static String JETTY_7 = "org.eclipse.jetty.servlet.ServletContextHandler" ; </a> 1
<a> public final static String JETTY_8 = "org.eclipse.jetty.continuation.Servlet3Continuation" ; </a> 1
<a> public final static String GRIZZLY = "com.sun.grizzly.http.servlet.ServletAdapter" ; </a> 1
<a> public final static String WEBLOGIC = "weblogic.servlet.http.FutureResponseModel" ; </a> 1
<a> public final static String JBOSSWEB = "org.apache.catalina.connector.HttpEventImpl" ; </a> 1
<a> public final static String GRIZZLY_WEBSOCKET = "com.sun.grizzly.websockets.WebSocketEngine" ; </a> 1
<a> private final AtmosphereConfig config ; </a> 1
<a> public DefaultCometSupportResolver ( final AtmosphereConfig config ) { </a> 1
<a> this . config = config ; </a> 1
<a> } </a> 1
<a> protected boolean testClassExists ( final String testClass ) { </a> 1
<a> try { </a> 1
<a> return testClass != null && testClass . length ( ) > 0 && </a> 1
<a> Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( testClass ) != null ; </a> 1
<a> } catch ( ClassNotFoundException ex ) { </a> 1
<a> return false ; </a> 1
<a> } catch ( NoClassDefFoundError ex ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public List < Class < ? extends CometSupport > > detectContainersPresent ( ) { </a> 1
<a> return new LinkedList < Class < ? extends CometSupport > > ( ) { </a> 1
<a> { </a> 1
<a> if ( testClassExists ( GLASSFISH_V2 ) ) </a> 1
<a> add ( GlassFishv2CometSupport . class ) ; </a> 1
<a> if ( testClassExists ( JETTY ) ) </a> 1
<a> add ( JettyCometSupport . class ) ; </a> 1
<a> if ( testClassExists ( JETTY_7 ) ) </a> 1
<a> add ( Jetty7CometSupport . class ) ; </a> 1
<a> if ( testClassExists ( JETTY_8 ) ) </a> 1
<a> add ( Jetty7CometSupport . class ) ; </a> 1
<a> if ( testClassExists ( JBOSSWEB ) ) </a> 1
<a> add ( JBossWebCometSupport . class ) ; </a> 1
<a> if ( testClassExists ( TOMCAT_7 ) ) </a> 1
<a> add ( Tomcat7CometSupport . class ) ; </a> 1
<a> if ( testClassExists ( TOMCAT ) || testClassExists ( JBOSS_5 ) ) </a> 1
<a> add ( TomcatCometSupport . class ) ; </a> 1
<a> if ( testClassExists ( GRIZZLY ) ) </a> 1
<a> add ( GrizzlyCometSupport . class ) ; </a> 1
<a> if ( testClassExists ( WEBLOGIC ) ) </a> 1
<a> add ( WebLogicCometSupport . class ) ; </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> } </a> 1
<a> public List < Class < ? extends CometSupport > > detectWebSocketPresent ( ) { </a> 1
<a> List l = new LinkedList < Class < ? extends CometSupport > > ( ) { </a> 1
<a> { </a> 1
<a> if ( testClassExists ( TOMCAT ) ) { </a> 1
<a> logger . info ( "Tomcat doesn't support WebSocket. Ignoring web.xml config init-param" ) ; </a> 1
<a> } else { </a> 1
<a> if ( testClassExists ( JETTY_8 ) ) </a> 1
<a> add ( JettyCometSupportWithWebSocket . class ) ; </a> 1
<a> if ( testClassExists ( GRIZZLY_WEBSOCKET ) ) </a> 1
<a> add ( GlassFishWebSocketSupport . class ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> if ( l . isEmpty ( ) ) { </a> 1
<a> return detectContainersPresent ( ) ; </a> 0
<a> } </a> 0
<a> return l ; </a> 1
<a> } </a> 1
<a> public CometSupport defaultCometSupport ( final boolean preferBlocking ) { </a> 1
<a> if ( ! preferBlocking && testClassExists ( SERVLET_30 ) ) { </a> 1
<a> if ( detectWebSocketPresent ( ) . size ( ) > 0 ) { </a> 1
<a> return new Servlet30CometSupportWithWebSocket ( config ) ; </a> 1
<a> } </a> 1
<a> return new Servlet30CometSupport ( config ) ; </a> 1
<a> } else { </a> 1
<a> return new BlockingIOCometSupport ( config ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public CometSupport newCometSupport ( final Class < ? extends CometSupport > targetClass ) { </a> 1
<a> try { </a> 1
<a> return targetClass . getDeclaredConstructor ( new Class [ ] { AtmosphereConfig . class } ) </a> 1
<a> . newInstance ( config ) ; </a> 1
<a> } catch ( final Exception e ) { </a> 1
<a> logger . error ( "failed to create comet support class: {}, error: {}" , targetClass , e . getMessage ( ) ) ; </a> 1
<a> throw new IllegalArgumentException ( </a> 1
<a> "Comet support class " + targetClass . getCanonicalName ( ) + " has bad signature." , e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public CometSupport newCometSupport ( final String targetClassFQN ) { </a> 1
<a> try { </a> 1
<a> ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; </a> 1
<a> return ( CometSupport ) cl . loadClass ( targetClassFQN ) </a> 1
<a> . getDeclaredConstructor ( new Class [ ] { AtmosphereConfig . class } ) . newInstance ( config ) ; </a> 1
<a> } catch ( final Exception e ) { </a> 1
<a> logger . error ( "failed to create comet support class: {}, error: {}" , targetClassFQN , e . getMessage ( ) ) ; </a> 1
<a> throw new IllegalArgumentException ( "Comet support class " + targetClassFQN + " has bad signature." , e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public CometSupport resolve ( final boolean useNativeIfPossible , final boolean defaultToBlocking ) { </a> 1
<a> final CometSupport servletAsyncSupport = defaultCometSupport ( defaultToBlocking ) ; </a> 1
<a> final CometSupport nativeSupport ; </a> 1
<a> if ( ! defaultToBlocking && ( useNativeIfPossible || </a> 1
<a> servletAsyncSupport . getClass ( ) . getName ( ) . equals ( BlockingIOCometSupport . class . getName ( ) ) ) ) { </a> 1
<a> nativeSupport = resolveNativeCometSupport ( detectContainersPresent ( ) ) ; </a> 1
<a> return nativeSupport == null ? servletAsyncSupport : nativeSupport ; </a> 1
<a> } </a> 1
<a> return servletAsyncSupport ; </a> 1
<a> } </a> 1
<a> public CometSupport resolve ( boolean useNativeIfPossible , boolean defaultToBlocking , boolean useWebsocketIfPossible ) { </a> 1
<a> CometSupport cs ; </a> 1
<a> if ( ! useWebsocketIfPossible ) { </a> 1
<a> cs = resolve ( useNativeIfPossible , defaultToBlocking ) ; </a> 1
<a> } else { </a> 1
<a> cs = resolveWebSocket ( detectWebSocketPresent ( ) ) ; </a> 0
<a> } </a> 1
<a> if ( cs == null ) { </a> 1
<a> return new BlockingIOCometSupport ( config ) ; </a> 1
<a> } else { </a> 1
<a> return cs ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public CometSupport resolveWebSocket ( final java . util . List < Class < ? extends CometSupport > > available ) { </a> 1
<a> if ( available == null || available . isEmpty ( ) ) return null ; </a> 1
<a> else return newCometSupport ( available . get ( 0 ) ) ; </a> 1
<a> } </a> 1
<a> protected CometSupport resolveNativeCometSupport ( final java . util . List < Class < ? extends CometSupport > > available ) { </a> 1
<a> if ( available == null || available . isEmpty ( ) ) return null ; </a> 1
<a> else if ( available . size ( ) == 1 ) return newCometSupport ( available . get ( 0 ) ) ; </a> 1
<a> else return resolveMultipleNativeSupportConflict ( available ) ; </a> 1
<a> } </a> 1
<a> protected CometSupport resolveMultipleNativeSupportConflict ( final List < Class < ? extends CometSupport > > available ) { </a> 1
<a> final StringBuilder b = new StringBuilder ( "Found multiple containers, please specify which one to use: " ) ; </a> 1
<a> for ( Class < ? extends CometSupport > cs : available ) { </a> 1
<a> b . append ( ( cs != null ) ? cs . getCanonicalName ( ) : "null" ) . append ( ", " ) ; </a> 1
<a> } </a> 1
<a> b . append ( " until you do, Atmosphere will use:" + available . get ( 0 ) ) ; </a> 1
<a> logger . warn ( "{}" , b . toString ( ) ) ; </a> 1
<a> return newCometSupport ( available . get ( 0 ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . UUID ; </a> 1
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import static org . atmosphere . cpr . FrameworkConfig . ATMOSPHERE_RESOURCE ; </a> 0
<a> public class Meteor { </a> 0
<a> private final static ConcurrentHashMap < AtmosphereResource , Meteor > cache = </a> 1
<a> new ConcurrentHashMap < AtmosphereResource , Meteor > ( ) ; </a> 1
<a> private final AtmosphereResource < HttpServletRequest , HttpServletResponse > r ; </a> 0
<a> private Object o ; </a> 1
<a> private Meteor ( AtmosphereResource < HttpServletRequest , HttpServletResponse > r , </a> 0
<a> List < BroadcastFilter > l , Serializer s ) { </a> 0
<a> this . r = r ; </a> 0
<a> this . r . setSerializer ( s ) ; </a> 0
<a> if ( l != null ) { </a> 0
<a> for ( BroadcastFilter f : l ) { </a> 0
<a> this . r . getBroadcaster ( ) . getBroadcasterConfig ( ) . addFilter ( f ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> cache . put ( this . r , this ) ; </a> 1
<a> } </a> 0
<a> public static Meteor lookup ( HttpServletRequest r ) { </a> 0
<a> return cache . get ( r . getAttribute ( ATMOSPHERE_RESOURCE ) ) ; </a> 1
<a> } </a> 0
<a> public final static Meteor build ( HttpServletRequest r ) { </a> 0
<a> return build ( r , null ) ; </a> 0
<a> } </a> 0
<a> public final static Meteor build ( HttpServletRequest r , Serializer s ) { </a> 0
<a> return build ( r , null , s ) ; </a> 0
<a> } </a> 0
<a> public final static Meteor build ( HttpServletRequest req , List < BroadcastFilter > l , Serializer s ) { </a> 0
<a> return build ( req , Broadcaster . SCOPE . APPLICATION , l , s ) ; </a> 0
<a> } </a> 0
<a> public final static Meteor build ( HttpServletRequest req , Broadcaster . SCOPE scope , </a> 0
<a> List < BroadcastFilter > l , Serializer s ) { </a> 0
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > r = </a> 0
<a> ( AtmosphereResource < HttpServletRequest , HttpServletResponse > ) </a> 0
<a> req . getAttribute ( ATMOSPHERE_RESOURCE ) ; </a> 0
<a> if ( r == null ) throw new IllegalStateException ( "MeteorServlet not defined in web.xml" ) ; </a> 0
<a> Broadcaster b = null ; </a> 1
<a> if ( scope == Broadcaster . SCOPE . REQUEST ) { </a> 1
<a> try { </a> 1
<a> b = BroadcasterFactory . getDefault ( ) . get ( DefaultBroadcaster . class , DefaultBroadcaster . class . getSimpleName ( ) + UUID . randomUUID ( ) ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> throw new RuntimeException ( t ) ; </a> 1
<a> } </a> 1
<a> b . setScope ( scope ) ; </a> 1
<a> r . setBroadcaster ( b ) ; </a> 1
<a> } </a> 1
<a> Meteor m = new Meteor ( r , l , s ) ; </a> 1
<a> return m ; </a> 0
<a> } </a> 0
<a> public Meteor suspend ( long l ) { </a> 0
<a> r . suspend ( l ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Meteor suspend ( long timeout , TimeUnit timeunit ) { </a> 0
<a> r . suspend ( timeout , timeunit ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Meteor suspend ( long l , boolean outputComments ) { </a> 0
<a> r . suspend ( l , outputComments ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Meteor suspend ( long timeout , TimeUnit timeunit , boolean outputComments ) { </a> 0
<a> r . suspend ( timeout , timeunit , outputComments ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Meteor resume ( ) { </a> 0
<a> r . resume ( ) ; </a> 0
<a> cache . remove ( r ) ; </a> 1
<a> return this ; </a> 0
<a> } </a> 0
<a> public Meteor broadcast ( Object o ) { </a> 0
<a> r . getBroadcaster ( ) . broadcast ( o ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Meteor schedule ( Object o , long period ) { </a> 0
<a> r . getBroadcaster ( ) . scheduleFixedBroadcast ( o , period , TimeUnit . SECONDS ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Meteor delayBroadadcast ( Object o , long period ) { </a> 0
<a> r . getBroadcaster ( ) . delayBroadcast ( o , period , TimeUnit . SECONDS ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Broadcaster getBroadcaster ( ) { </a> 0
<a> return r . getBroadcaster ( ) ; </a> 0
<a> } </a> 0
<a> public void setBroadcaster ( Broadcaster b ) { </a> 0
<a> r . setBroadcaster ( b ) ; </a> 0
<a> } </a> 0
<a> public Object attachement ( ) { </a> 0
<a> return o ; </a> 0
<a> } </a> 0
<a> public void attach ( Object o ) { </a> 0
<a> this . o = o ; </a> 0
<a> } </a> 0
<a> public void addListener ( AtmosphereResourceEventListener e ) { </a> 0
<a> if ( r instanceof AtmosphereEventLifecycle ) { </a> 1
<a> ( ( AtmosphereEventLifecycle ) r ) . addEventListener ( e ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> public void removeListener ( AtmosphereResourceEventListener e ) { </a> 0
<a> if ( r instanceof AtmosphereEventLifecycle ) { </a> 1
<a> ( ( AtmosphereEventLifecycle ) r ) . removeEventListener ( e ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> static void destroy ( ) { </a> 1
<a> cache . clear ( ) ; </a> 1
<a> } </a> 0
<a> public AtmosphereResource < HttpServletRequest , HttpServletResponse > getAtmosphereResource ( ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> public interface Serializer { </a> 0
<a> void write ( OutputStream os , Object o ) throws IOException ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . di ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 1
<a> import java . lang . ref . WeakReference ; </a> 1
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 1
<a> public final class ServletContextHolder { </a> 1
<a> private static AtomicReference < WeakReference < ServletContextProvider > > PROVIDER = new AtomicReference < WeakReference < ServletContextProvider > > ( ) ; </a> 1
<a> private ServletContextHolder ( ) { </a> 1
<a> } </a> 1
<a> public static void register ( ServletContextProvider provider ) { </a> 1
<a> PROVIDER . set ( new WeakReference < ServletContextProvider > ( provider ) ) ; </a> 1
<a> } </a> 1
<a> public static ServletContext getServletContext ( ) { </a> 1
<a> WeakReference < ServletContextProvider > ref = PROVIDER . get ( ) ; </a> 1
<a> if ( ref != null ) { </a> 1
<a> ServletContextProvider provider = ref . get ( ) ; </a> 1
<a> if ( provider != null ) { </a> 1
<a> return provider . getServletContext ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> throw new IllegalStateException ( "No " + ServletContextProvider . class . getSimpleName ( ) + " found." ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . handler ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . List ; </a> 0
<a> public abstract class AbstractReflectorAtmosphereHandler </a> 0
<a> implements AtmosphereHandler < HttpServletRequest , HttpServletResponse > { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( AbstractReflectorAtmosphereHandler . class ) ; </a> 0
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) </a> 0
<a> throws IOException { </a> 0
<a> Object message = event . getMessage ( ) ; </a> 0
<a> if ( message == null || event . isCancelled ( ) ) return ; </a> 1
<a> if ( event . getResource ( ) . getSerializer ( ) != null ) { </a> 0
<a> try { </a> 0
<a> event . getResource ( ) . getSerializer ( ) . write ( event . getResource ( ) . getResponse ( ) . getOutputStream ( ) , message ) ; </a> 0
<a> } catch ( Throwable ex ) { </a> 0
<a> logger . warn ( "Serializer exception: message: " + message , ex ) ; </a> 1
<a> throw new IOException ( ex ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> boolean isUsingStream = false ; </a> 0
<a> try { </a> 0
<a> event . getResource ( ) . getResponse ( ) . getWriter ( ) ; </a> 0
<a> } catch ( IllegalStateException e ) { </a> 0
<a> isUsingStream = true ; </a> 0
<a> } </a> 0
<a> if ( message instanceof List ) { </a> 0
<a> for ( String s : ( List < String > ) message ) { </a> 1
<a> if ( isUsingStream ) { </a> 0
<a> event . getResource ( ) . getResponse ( ) . getOutputStream ( ) . write ( s . getBytes ( ) ) ; </a> 1
<a> event . getResource ( ) . getResponse ( ) . getOutputStream ( ) . flush ( ) ; </a> 0
<a> } else { </a> 0
<a> event . getResource ( ) . getResponse ( ) . getWriter ( ) . write ( s ) ; </a> 0
<a> event . getResource ( ) . getResponse ( ) . getWriter ( ) . flush ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } else { </a> 0
<a> if ( isUsingStream ) { </a> 0
<a> event . getResource ( ) . getResponse ( ) . getOutputStream ( ) . write ( message . toString ( ) . getBytes ( ) ) ; </a> 1
<a> event . getResource ( ) . getResponse ( ) . getOutputStream ( ) . flush ( ) ; </a> 0
<a> } else { </a> 0
<a> event . getResource ( ) . getResponse ( ) . getWriter ( ) . write ( message . toString ( ) ) ; </a> 0
<a> event . getResource ( ) . getResponse ( ) . getWriter ( ) . flush ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Boolean resumeOnBroadcast = false ; </a> 0
<a> Object o = event . getResource ( ) . getRequest ( ) . getAttribute ( ApplicationConfig . RESUME_ON_BROADCAST ) ; </a> 0
<a> if ( o != null && Boolean . class . isAssignableFrom ( o . getClass ( ) ) ) { </a> 0
<a> resumeOnBroadcast = Boolean . class . cast ( o ) ; </a> 0
<a> } </a> 0
<a> if ( resumeOnBroadcast != null && resumeOnBroadcast ) { </a> 0
<a> event . getResource ( ) . resume ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . util ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . CometSupport ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import org . w3c . dom . Document ; </a> 0
<a> import org . w3c . dom . Element ; </a> 0
<a> import org . w3c . dom . NamedNodeMap ; </a> 0
<a> import org . w3c . dom . Node ; </a> 0
<a> import org . w3c . dom . NodeList ; </a> 0
<a> import org . xml . sax . SAXException ; </a> 0
<a> import javax . xml . parsers . DocumentBuilderFactory ; </a> 0
<a> import javax . xml . parsers . ParserConfigurationException ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class AtmosphereConfigReader { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( AtmosphereConfigReader . class ) ; </a> 0
<a> private final Map < String , String > tuples = new HashMap < String , String > ( ) ; </a> 0
<a> private final Map < String , ArrayList < Property > > atmosphereHandlerProperties = new HashMap < String , ArrayList < Property > > ( ) ; </a> 0
<a> private final Map < String , String > broadcasters = new HashMap < String , String > ( ) ; </a> 0
<a> private final Map < String , String > broadcasterCache = new HashMap < String , String > ( ) ; </a> 0
<a> private String cometSupportClass = null ; </a> 0
<a> private String supportSession = "" ; </a> 0
<a> private String [ ] broadcastFilterClasses ; </a> 0
<a> public AtmosphereConfigReader ( InputStream stream ) { </a> 0
<a> DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; </a> 0
<a> try { </a> 0
<a> parse ( factory . newDocumentBuilder ( ) . parse ( stream ) ) ; </a> 0
<a> } catch ( SAXException e ) { </a> 0
<a> logger . error ( e . getMessage ( ) , e ) ; </a> 0
<a> throw new RuntimeException ( e ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . error ( e . getMessage ( ) , e ) ; </a> 0
<a> throw new RuntimeException ( e ) ; </a> 0
<a> } catch ( ParserConfigurationException e ) { </a> 0
<a> logger . error ( e . getMessage ( ) , e ) ; </a> 0
<a> throw new RuntimeException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void parse ( Document document ) { </a> 0
<a> Element element = document . getDocumentElement ( ) ; </a> 0
<a> NodeList atmosphereHandlers = element . getElementsByTagName ( "atmosphere-handler" ) ; </a> 0
<a> for ( int i = 0 ; i < atmosphereHandlers . getLength ( ) ; i ++ ) { </a> 0
<a> Node atmosphereHandler = atmosphereHandlers . item ( i ) ; </a> 0
<a> NamedNodeMap attrs = atmosphereHandler . getAttributes ( ) ; </a> 0
<a> NodeList properties = atmosphereHandler . getChildNodes ( ) ; </a> 0
<a> ArrayList < Property > list = new ArrayList < Property > ( ) ; </a> 0
<a> for ( int j = 0 ; j < properties . getLength ( ) ; j ++ ) { </a> 0
<a> Node property = properties . item ( j ) ; </a> 0
<a> NamedNodeMap values = property . getAttributes ( ) ; </a> 0
<a> if ( values != null ) { </a> 0
<a> list . add ( new Property ( values . getNamedItem ( "name" ) . getNodeValue ( ) , </a> 0
<a> values . getNamedItem ( "value" ) . getNodeValue ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( attrs != null ) { </a> 0
<a> atmosphereHandlerProperties . put ( attrs . getNamedItem ( "context-root" ) . getNodeValue ( ) , list ) ; </a> 0
<a> addAtmosphereHandler ( attrs . getNamedItem ( "context-root" ) . getNodeValue ( ) , </a> 0
<a> attrs . getNamedItem ( "class-name" ) . getNodeValue ( ) ) ; </a> 0
<a> if ( attrs . getNamedItem ( "broadcaster" ) != null ) { </a> 0
<a> String broadcasterClass = attrs . getNamedItem ( "broadcaster" ) . getNodeValue ( ) ; </a> 0
<a> if ( broadcasterClass != null ) { </a> 0
<a> broadcasters . put ( attrs . getNamedItem ( "context-root" ) . getNodeValue ( ) , broadcasterClass ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( attrs . getNamedItem ( "broadcastFilterClasses" ) != null ) { </a> 0
<a> broadcastFilterClasses = attrs . getNamedItem ( "broadcastFilter" ) . getNodeValue ( ) . split ( "," ) ; </a> 0
<a> } </a> 0
<a> if ( attrs . getNamedItem ( "broadcasterCache" ) != null ) { </a> 0
<a> String bc = attrs . getNamedItem ( "broadcasterCache" ) . getNodeValue ( ) ; </a> 0
<a> if ( bc != null ) { </a> 0
<a> broadcasterCache . put ( attrs . getNamedItem ( "context-root" ) . getNodeValue ( ) , bc ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( attrs . getNamedItem ( "comet-support" ) != null ) { </a> 0
<a> cometSupportClass = attrs . getNamedItem ( "comet-support" ) . getNodeValue ( ) ; </a> 0
<a> } </a> 0
<a> if ( attrs . getNamedItem ( "support-session" ) != null ) { </a> 0
<a> supportSession = attrs . getNamedItem ( "support-session" ) . getNodeValue ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public String supportSession ( ) { </a> 0
<a> return supportSession ; </a> 0
<a> } </a> 0
<a> void addAtmosphereHandler ( String contextPath , String className ) { </a> 0
<a> if ( tuples . containsKey ( contextPath ) ) { </a> 0
<a> throw new RuntimeException ( "duplicate context root in configuration :" + contextPath ) ; </a> 0
<a> } </a> 0
<a> tuples . put ( contextPath , className ) ; </a> 0
<a> } </a> 0
<a> public Map < String , String > getAtmosphereHandlers ( ) { </a> 0
<a> return tuples ; </a> 0
<a> } </a> 0
<a> public String getBroadcasterClass ( String contextRoot ) { </a> 0
<a> return broadcasters . get ( contextRoot ) ; </a> 0
<a> } </a> 0
<a> public String getBroadcasterCache ( String contextRoot ) { </a> 0
<a> return broadcasterCache . get ( contextRoot ) ; </a> 0
<a> } </a> 0
<a> public class Property { </a> 0
<a> public String name = "" ; </a> 0
<a> public String value = "" ; </a> 0
<a> public Property ( String name , String value ) { </a> 0
<a> this . name = name ; </a> 0
<a> this . value = value ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public ArrayList < Property > getProperty ( String contextRoot ) { </a> 0
<a> return atmosphereHandlerProperties . get ( contextRoot ) ; </a> 0
<a> } </a> 0
<a> public String getCometSupportClass ( ) { </a> 0
<a> return cometSupportClass ; </a> 0
<a> } </a> 0
<a> public String [ ] getBroadcastFilterClasses ( ) { </a> 0
<a> return broadcastFilterClasses ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . util ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFuture ; </a> 0
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpSession ; </a> 0
<a> import java . util . HashSet ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . concurrent . Future ; </a> 0
<a> public class ExcludeSessionBroadcaster </a> 1
<a> extends DefaultBroadcaster { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( ExcludeSessionBroadcaster . class ) ; </a> 0
<a> public ExcludeSessionBroadcaster ( ) { </a> 0
<a> setID ( ExcludeSessionBroadcaster . class . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> public ExcludeSessionBroadcaster ( String id ) { </a> 0
<a> super ( id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > Future < T > broadcast ( T msg , AtmosphereResource < ? , ? > r ) { </a> 0
<a> if ( destroyed . get ( ) ) { </a> 0
<a> throw new IllegalStateException ( "This Broadcaster has been destroyed and cannot be used" ) ; </a> 0
<a> } </a> 0
<a> Set < AtmosphereResource < ? , ? > > sub = new HashSet < AtmosphereResource < ? , ? > > ( ) ; </a> 0
<a> sub . addAll ( resources ) ; </a> 0
<a> sub . remove ( r ) ; </a> 0
<a> start ( ) ; </a> 0
<a> Object newMsg = filter ( msg ) ; </a> 0
<a> if ( newMsg == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> messages . offer ( new Entry ( newMsg , sub , f , msg ) ) ; </a> 1
<a> return f ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > Future < T > broadcast ( T msg , Set < AtmosphereResource < ? , ? > > subset ) { </a> 0
<a> if ( destroyed . get ( ) ) { </a> 0
<a> throw new IllegalStateException ( "This Broadcaster has been destroyed and cannot be used" ) ; </a> 1
<a> } </a> 0
<a> subset . retainAll ( resources ) ; </a> 0
<a> start ( ) ; </a> 0
<a> Object newMsg = filter ( msg ) ; </a> 0
<a> if ( newMsg == null ) { </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> messages . offer ( new Entry ( newMsg , subset , f , msg ) ) ; </a> 1
<a> return f ; </a> 0
<a> } </a> 0
<a> public < T > Future < T > broadcast ( T msg , List < HttpSession > sessions ) { </a> 1
<a> if ( destroyed . get ( ) ) { </a> 0
<a> throw new IllegalStateException ( "This Broadcaster has been destroyed and cannot be used" ) ; </a> 1
<a> } </a> 0
<a> Set < AtmosphereResource < ? , ? > > subset = new HashSet < AtmosphereResource < ? , ? > > ( ) ; </a> 0
<a> subset . addAll ( resources ) ; </a> 0
<a> for ( AtmosphereResource < ? , ? > r : resources ) { </a> 0
<a> if ( ! r . getAtmosphereResourceEvent ( ) . isCancelled ( ) && </a> 0
<a> sessions . contains ( ( ( HttpServletRequest ) r . getRequest ( ) ) . getSession ( ) ) ) { </a> 0
<a> subset . remove ( r ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> start ( ) ; </a> 0
<a> Object newMsg = filter ( msg ) ; </a> 0
<a> if ( newMsg == null ) { </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> messages . offer ( new Entry ( newMsg , subset , f , msg ) ) ; </a> 1
<a> return f ; </a> 0
<a> } </a> 0
<a> public < T > Future < T > broadcast ( T msg , HttpSession s ) { </a> 1
<a> if ( destroyed . get ( ) ) { </a> 0
<a> throw new IllegalStateException ( "This Broadcaster has been destroyed and cannot be used" ) ; </a> 1
<a> } </a> 0
<a> Set < AtmosphereResource < ? , ? > > subset = new HashSet < AtmosphereResource < ? , ? > > ( ) ; </a> 0
<a> subset . addAll ( resources ) ; </a> 0
<a> for ( AtmosphereResource < ? , ? > r : resources ) { </a> 0
<a> if ( ! r . getAtmosphereResourceEvent ( ) . isCancelled ( ) && </a> 0
<a> s . equals ( ( ( HttpServletRequest ) r . getRequest ( ) ) . getSession ( ) ) ) { </a> 0
<a> subset . remove ( r ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> start ( ) ; </a> 0
<a> Object newMsg = filter ( msg ) ; </a> 0
<a> if ( newMsg == null ) { </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> messages . offer ( new Entry ( newMsg , subset , f , msg ) ) ; </a> 1
<a> return f ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . util ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import java . io . File ; </a> 0
<a> import java . io . FilenameFilter ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . lang . reflect . Method ; </a> 0
<a> import java . net . InetAddress ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> import java . net . URL ; </a> 0
<a> import java . net . UnknownHostException ; </a> 0
<a> import java . util . Hashtable ; </a> 0
<a> import java . util . StringTokenizer ; </a> 0
<a> import java . util . Vector ; </a> 0
<a> public final class IntrospectionUtils { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( IntrospectionUtils . class ) ; </a> 0
<a> public static void execute ( Object proxy , String method ) throws Exception { </a> 0
<a> Method executeM = null ; </a> 0
<a> Class < ? > c = proxy . getClass ( ) ; </a> 0
<a> Class < ? > params [ ] = new Class [ 0 ] ; </a> 0
<a> executeM = findMethod ( c , method , params ) ; </a> 0
<a> if ( executeM == null ) { </a> 0
<a> throw new RuntimeException ( "No execute in " + proxy . getClass ( ) ) ; </a> 0
<a> } </a> 0
<a> executeM . invoke ( proxy , ( Object [ ] ) null ) ; </a> 0
<a> } </a> 0
<a> public static void setAttribute ( Object proxy , String name , Object value ) </a> 0
<a> throws Exception { </a> 0
<a> if ( proxy instanceof AttributeHolder ) { </a> 0
<a> ( ( AttributeHolder ) proxy ) . setAttribute ( name , value ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> Method executeM = null ; </a> 0
<a> Class < ? > c = proxy . getClass ( ) ; </a> 0
<a> Class < ? > params [ ] = new Class [ 2 ] ; </a> 0
<a> params [ 0 ] = String . class ; </a> 0
<a> params [ 1 ] = Object . class ; </a> 0
<a> executeM = findMethod ( c , "setAttribute" , params ) ; </a> 0
<a> if ( executeM == null ) { </a> 0
<a> logger . debug ( "No setAttribute in {}" , proxy . getClass ( ) ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> logger . debug ( "Setting {}={} in proxy: {}" , new Object [ ] { name , value , proxy } ) ; </a> 0
<a> executeM . invoke ( proxy , new Object [ ] { name , value } ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> public static Object getAttribute ( Object proxy , String name ) throws Exception { </a> 0
<a> Class < ? > c = proxy . getClass ( ) ; </a> 0
<a> Class < ? > params [ ] = new Class [ 1 ] ; </a> 0
<a> params [ 0 ] = String . class ; </a> 0
<a> Method executeM = findMethod ( c , "getAttribute" , params ) ; </a> 0
<a> if ( executeM == null ) { </a> 0
<a> logger . debug ( "No getAttribute in {}" , proxy . getClass ( ) ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return executeM . invoke ( proxy , new Object [ ] { name } ) ; </a> 0
<a> } </a> 0
<a> public static ClassLoader getURLClassLoader ( URL urls [ ] , ClassLoader parent ) { </a> 0
<a> try { </a> 0
<a> Class < ? > urlCL = Class . forName ( "java.net.URLClassLoader" ) ; </a> 0
<a> Class < ? > paramT [ ] = new Class [ 2 ] ; </a> 0
<a> paramT [ 0 ] = urls . getClass ( ) ; </a> 0
<a> paramT [ 1 ] = ClassLoader . class ; </a> 0
<a> Method m = findMethod ( urlCL , "newInstance" , paramT ) ; </a> 0
<a> if ( m == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> ClassLoader cl = ( ClassLoader ) m . invoke ( urlCL , new Object [ ] { urls , parent } ) ; </a> 0
<a> return cl ; </a> 0
<a> } catch ( ClassNotFoundException ex ) { </a> 0
<a> return null ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> logger . error ( "failed getting URLClassLoader" , ex ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> final public static boolean setProperty ( Object o , String name , String value ) { </a> 0
<a> String setter = "set" + capitalize ( name ) ; </a> 0
<a> return invokeProperty ( o , setter , name , value ) ; </a> 0
<a> } </a> 0
<a> final public static boolean addProperty ( Object o , String name , String value ) { </a> 0
<a> String setter = "add" + capitalize ( name ) ; </a> 0
<a> return invokeProperty ( o , setter , name , value ) ; </a> 0
<a> } </a> 0
<a> final static public boolean invokeProperty ( Object object , String setter , String name , String value ) { </a> 0
<a> try { </a> 0
<a> Method methods [ ] = findMethods ( object . getClass ( ) ) ; </a> 0
<a> Method setPropertyMethodVoid = null ; </a> 0
<a> Method setPropertyMethodBool = null ; </a> 0
<a> for ( int i = 0 ; i < methods . length ; i ++ ) { </a> 0
<a> Class < ? > paramT [ ] = methods [ i ] . getParameterTypes ( ) ; </a> 0
<a> if ( setter . equals ( methods [ i ] . getName ( ) ) && paramT . length == 1 </a> 0
<a> && "java.lang.String" . equals ( paramT [ 0 ] . getName ( ) ) ) { </a> 0
<a> methods [ i ] . invoke ( object , new Object [ ] { value } ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < methods . length ; i ++ ) { </a> 0
<a> boolean ok = true ; </a> 0
<a> if ( setter . equals ( methods [ i ] . getName ( ) ) </a> 0
<a> && methods [ i ] . getParameterTypes ( ) . length == 1 ) { </a> 0
<a> Class < ? > paramType = methods [ i ] . getParameterTypes ( ) [ 0 ] ; </a> 0
<a> Object params [ ] = new Object [ 1 ] ; </a> 0
<a> if ( "java.lang.Integer" . equals ( paramType . getName ( ) ) </a> 0
<a> || "int" . equals ( paramType . getName ( ) ) ) { </a> 0
<a> try { </a> 0
<a> params [ 0 ] = new Integer ( value ) ; </a> 0
<a> } catch ( NumberFormatException ex ) { </a> 0
<a> ok = false ; </a> 0
<a> } </a> 0
<a> } else if ( "java.lang.Long" . equals ( paramType . getName ( ) ) </a> 0
<a> || "long" . equals ( paramType . getName ( ) ) ) { </a> 0
<a> try { </a> 0
<a> params [ 0 ] = new Long ( value ) ; </a> 0
<a> } catch ( NumberFormatException ex ) { </a> 0
<a> ok = false ; </a> 0
<a> } </a> 0
<a> } else if ( "java.lang.Boolean" . equals ( paramType . getName ( ) ) </a> 0
<a> || "boolean" . equals ( paramType . getName ( ) ) ) { </a> 0
<a> params [ 0 ] = new Boolean ( value ) ; </a> 0
<a> } else if ( "java.net.InetAddress" . equals ( paramType </a> 0
<a> . getName ( ) ) ) { </a> 0
<a> try { </a> 0
<a> params [ 0 ] = InetAddress . getByName ( value ) ; </a> 0
<a> } catch ( UnknownHostException exc ) { </a> 0
<a> debug ( "Unable to resolve host name:" + value ) ; </a> 0
<a> ok = false ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> debug ( "Unknown type " + paramType . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( ok ) { </a> 0
<a> methods [ i ] . invoke ( object , params ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( "setProperty" . equals ( methods [ i ] . getName ( ) ) ) { </a> 0
<a> if ( methods [ i ] . getReturnType ( ) == Boolean . TYPE ) { </a> 0
<a> setPropertyMethodBool = methods [ i ] ; </a> 0
<a> } else { </a> 0
<a> setPropertyMethodVoid = methods [ i ] ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( setPropertyMethodBool != null || setPropertyMethodVoid != null ) { </a> 0
<a> Object params [ ] = new Object [ 2 ] ; </a> 0
<a> params [ 0 ] = name ; </a> 0
<a> params [ 1 ] = value ; </a> 0
<a> if ( setPropertyMethodBool != null ) { </a> 0
<a> try { </a> 0
<a> return ( Boolean ) setPropertyMethodBool . invoke ( object , params ) ; </a> 0
<a> } catch ( IllegalArgumentException biae ) { </a> 0
<a> if ( setPropertyMethodVoid != null ) { </a> 0
<a> setPropertyMethodVoid . invoke ( object , params ) ; </a> 0
<a> return true ; </a> 0
<a> } else { </a> 0
<a> throw biae ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> setPropertyMethodVoid . invoke ( object , params ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( IllegalArgumentException e ) { </a> 0
<a> logger . info ( "failed, object: " + object + ", setter: " + setter + ", value: " + value , e ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> if ( dbg > 0 ) { </a> 0
<a> debug ( e . getClass ( ) . getSimpleName ( ) + " for " + object . getClass ( ) + " " + setter + "=" + value + ")" ) ; </a> 0
<a> } </a> 0
<a> if ( dbg > 1 ) { </a> 0
<a> logger . debug ( "" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> public static Object getProperty ( Object object , String name ) { </a> 0
<a> String getter = "get" + capitalize ( name ) ; </a> 0
<a> String isGetter = "is" + capitalize ( name ) ; </a> 0
<a> try { </a> 0
<a> Method methods [ ] = findMethods ( object . getClass ( ) ) ; </a> 0
<a> Method getPropertyMethod = null ; </a> 0
<a> for ( int i = 0 ; i < methods . length ; i ++ ) { </a> 0
<a> Class < ? > paramT [ ] = methods [ i ] . getParameterTypes ( ) ; </a> 0
<a> if ( getter . equals ( methods [ i ] . getName ( ) ) && paramT . length == 0 ) { </a> 0
<a> return methods [ i ] . invoke ( object , ( Object [ ] ) null ) ; </a> 0
<a> } </a> 0
<a> if ( isGetter . equals ( methods [ i ] . getName ( ) ) && paramT . length == 0 ) { </a> 0
<a> return methods [ i ] . invoke ( object , ( Object [ ] ) null ) ; </a> 0
<a> } </a> 0
<a> if ( "getProperty" . equals ( methods [ i ] . getName ( ) ) ) { </a> 0
<a> getPropertyMethod = methods [ i ] ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( getPropertyMethod != null ) { </a> 0
<a> Object params [ ] = new Object [ 1 ] ; </a> 0
<a> params [ 0 ] = name ; </a> 0
<a> return getPropertyMethod . invoke ( object , params ) ; </a> 0
<a> } </a> 0
<a> } catch ( IllegalArgumentException e ) { </a> 0
<a> logger . info ( "failed, object: " + object + ", name: " + name , e ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> if ( dbg > 0 ) { </a> 0
<a> debug ( e . getClass ( ) . getSimpleName ( ) + " for " + object . getClass ( ) + " " + name + ")" ) ; </a> 0
<a> } </a> 0
<a> if ( dbg > 1 ) { </a> 0
<a> logger . debug ( "" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public static void setProperty ( Object object , String name ) { </a> 0
<a> String setter = "set" + capitalize ( name ) ; </a> 0
<a> try { </a> 0
<a> Method methods [ ] = findMethods ( object . getClass ( ) ) ; </a> 0
<a> Method setPropertyMethod = null ; </a> 0
<a> for ( int i = 0 ; i < methods . length ; i ++ ) { </a> 0
<a> Class < ? > paramT [ ] = methods [ i ] . getParameterTypes ( ) ; </a> 0
<a> if ( setter . equals ( methods [ i ] . getName ( ) ) && paramT . length == 0 ) { </a> 0
<a> methods [ i ] . invoke ( object , new Object [ ] { } ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> if ( dbg > 0 ) { </a> 0
<a> debug ( "Exception for " + object . getClass ( ) + " " + name ) ; </a> 0
<a> } </a> 0
<a> if ( dbg > 1 ) { </a> 0
<a> logger . debug ( "" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static String replaceProperties ( String value , </a> 0
<a> Hashtable < String , String > staticProp , PropertySource dynamicProp [ ] ) { </a> 0
<a> if ( value . indexOf ( "$" ) < 0 ) { </a> 0
<a> return value ; </a> 0
<a> } </a> 0
<a> StringBuilder sb = new StringBuilder ( ) ; </a> 0
<a> int prev = 0 ; </a> 0
<a> int pos ; </a> 0
<a> while ( ( pos = value . indexOf ( "$" , prev ) ) >= 0 ) { </a> 0
<a> if ( pos > 0 ) { </a> 0
<a> sb . append ( value . substring ( prev , pos ) ) ; </a> 0
<a> } </a> 0
<a> if ( pos == ( value . length ( ) - 1 ) ) { </a> 0
<a> sb . append ( '$' ) ; </a> 0
<a> prev = pos + 1 ; </a> 0
<a> } else if ( value . charAt ( pos + 1 ) != '{' ) { </a> 0
<a> sb . append ( '$' ) ; </a> 0
<a> prev = pos + 1 ; </a> 0
<a> } else { </a> 0
<a> int endName = value . indexOf ( '}' , pos ) ; </a> 0
<a> if ( endName < 0 ) { </a> 0
<a> sb . append ( value . substring ( pos ) ) ; </a> 0
<a> prev = value . length ( ) ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> String n = value . substring ( pos + 2 , endName ) ; </a> 0
<a> String v = null ; </a> 0
<a> if ( staticProp != null ) { </a> 0
<a> v = staticProp . get ( n ) ; </a> 0
<a> } </a> 0
<a> if ( v == null && dynamicProp != null ) { </a> 0
<a> for ( int i = 0 ; i < dynamicProp . length ; i ++ ) { </a> 0
<a> v = dynamicProp [ i ] . getProperty ( n ) ; </a> 0
<a> if ( v != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( v == null ) </a> 0
<a> v = "${" + n + "}" ; </a> 0
<a> sb . append ( v ) ; </a> 0
<a> prev = endName + 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( prev < value . length ( ) ) </a> 0
<a> sb . append ( value . substring ( prev ) ) ; </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> public static String capitalize ( String name ) { </a> 0
<a> if ( name == null || name . length ( ) == 0 ) { </a> 0
<a> return name ; </a> 0
<a> } </a> 0
<a> char chars [ ] = name . toCharArray ( ) ; </a> 0
<a> chars [ 0 ] = Character . toUpperCase ( chars [ 0 ] ) ; </a> 0
<a> return new String ( chars ) ; </a> 0
<a> } </a> 0
<a> public static String unCapitalize ( String name ) { </a> 0
<a> if ( name == null || name . length ( ) == 0 ) { </a> 0
<a> return name ; </a> 0
<a> } </a> 0
<a> char chars [ ] = name . toCharArray ( ) ; </a> 0
<a> chars [ 0 ] = Character . toLowerCase ( chars [ 0 ] ) ; </a> 0
<a> return new String ( chars ) ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> public static void addToClassPath ( Vector < URL > cpV , String dir ) { </a> 0
<a> try { </a> 0
<a> String cpComp [ ] = getFilesByExt ( dir , ".jar" ) ; </a> 0
<a> if ( cpComp != null ) { </a> 0
<a> int jarCount = cpComp . length ; </a> 0
<a> for ( int i = 0 ; i < jarCount ; i ++ ) { </a> 0
<a> URL url = getURL ( dir , cpComp [ i ] ) ; </a> 0
<a> if ( url != null ) </a> 0
<a> cpV . addElement ( url ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> logger . debug ( "failed to add urls to classpath" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> public static void addToolsJar ( Vector < URL > v ) { </a> 0
<a> try { </a> 0
<a> File f = new File ( System . getProperty ( "java.home" ) </a> 0
<a> + "/../lib/tools.jar" ) ; </a> 0
<a> if ( ! f . exists ( ) ) { </a> 0
<a> f = new File ( System . getProperty ( "java.home" ) + "/lib/tools.jar" ) ; </a> 0
<a> if ( f . exists ( ) ) { </a> 0
<a> logger . debug ( "Detected strange java.home value {}, it should point to jre" , </a> 0
<a> System . getProperty ( "java.home" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> URL url = new URL ( "file" , "" , f . getAbsolutePath ( ) ) ; </a> 0
<a> v . addElement ( url ) ; </a> 0
<a> } catch ( MalformedURLException ex ) { </a> 0
<a> logger . debug ( "failed to add tools jar url to vector" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static String [ ] getFilesByExt ( String ld , String ext ) { </a> 0
<a> File dir = new File ( ld ) ; </a> 0
<a> String [ ] names = null ; </a> 0
<a> final String lext = ext ; </a> 0
<a> if ( dir . isDirectory ( ) ) { </a> 0
<a> names = dir . list ( new FilenameFilter ( ) { </a> 0
<a> public boolean accept ( File d , String name ) { </a> 0
<a> if ( name . endsWith ( lext ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> return names ; </a> 0
<a> } </a> 0
<a> public static URL getURL ( String base , String file ) { </a> 0
<a> try { </a> 0
<a> File baseF = new File ( base ) ; </a> 0
<a> File f = new File ( baseF , file ) ; </a> 0
<a> String path = f . getCanonicalPath ( ) ; </a> 0
<a> if ( f . isDirectory ( ) ) { </a> 0
<a> path += "/" ; </a> 0
<a> } </a> 0
<a> if ( ! f . exists ( ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return new URL ( "file" , "" , path ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> logger . debug ( "failed to get url, base: " + base + ", file: " + file , ex ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> public static void addJarsFromClassPath ( Vector < URL > jars , String cp ) </a> 0
<a> throws IOException , MalformedURLException { </a> 0
<a> String sep = System . getProperty ( "path.separator" ) ; </a> 0
<a> String token ; </a> 0
<a> StringTokenizer st ; </a> 0
<a> if ( cp != null ) { </a> 0
<a> st = new StringTokenizer ( cp , sep ) ; </a> 0
<a> while ( st . hasMoreTokens ( ) ) { </a> 0
<a> File f = new File ( st . nextToken ( ) ) ; </a> 0
<a> String path = f . getCanonicalPath ( ) ; </a> 0
<a> if ( f . isDirectory ( ) ) { </a> 0
<a> path += "/" ; </a> 0
<a> } </a> 0
<a> URL url = new URL ( "file" , "" , path ) ; </a> 0
<a> if ( ! jars . contains ( url ) ) { </a> 0
<a> jars . addElement ( url ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static URL [ ] getClassPath ( Vector < URL > v ) { </a> 0
<a> URL [ ] urls = new URL [ v . size ( ) ] ; </a> 0
<a> for ( int i = 0 ; i < v . size ( ) ; i ++ ) { </a> 0
<a> urls [ i ] = v . elementAt ( i ) ; </a> 0
<a> } </a> 0
<a> return urls ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> public static URL [ ] getClassPath ( String dir , String cpath , </a> 0
<a> String cpathProp , boolean addTools ) throws IOException , </a> 0
<a> MalformedURLException { </a> 0
<a> Vector < URL > jarsV = new Vector < URL > ( ) ; </a> 0
<a> if ( dir != null ) { </a> 0
<a> URL url = getURL ( dir , "classes" ) ; </a> 0
<a> if ( url != null ) </a> 0
<a> jarsV . addElement ( url ) ; </a> 0
<a> addToClassPath ( jarsV , dir ) ; </a> 0
<a> } </a> 0
<a> if ( cpath != null ) </a> 0
<a> addJarsFromClassPath ( jarsV , cpath ) ; </a> 0
<a> if ( cpathProp != null ) { </a> 0
<a> String cpath1 = System . getProperty ( cpathProp ) ; </a> 0
<a> addJarsFromClassPath ( jarsV , cpath1 ) ; </a> 0
<a> } </a> 0
<a> if ( addTools ) </a> 0
<a> addToolsJar ( jarsV ) ; </a> 0
<a> return getClassPath ( jarsV ) ; </a> 0
<a> } </a> 0
<a> public static boolean processArgs ( Object proxy , String args [ ] ) </a> 0
<a> throws Exception { </a> 0
<a> String args0 [ ] = null ; </a> 0
<a> if ( null != findMethod ( proxy . getClass ( ) , "getOptions1" , new Class [ ] { } ) ) { </a> 0
<a> args0 = ( String [ ] ) callMethod0 ( proxy , "getOptions1" ) ; </a> 0
<a> } </a> 0
<a> if ( args0 == null ) { </a> 0
<a> args0 = findBooleanSetters ( proxy . getClass ( ) ) ; </a> 0
<a> } </a> 0
<a> Hashtable < String , String > h = null ; </a> 0
<a> if ( null != findMethod ( proxy . getClass ( ) , "getOptionAliases" , </a> 0
<a> new Class [ ] { } ) ) { </a> 0
<a> h = ( Hashtable < String , String > ) callMethod0 ( proxy , "getOptionAliases" ) ; </a> 0
<a> } </a> 0
<a> return processArgs ( proxy , args , args0 , null , h ) ; </a> 0
<a> } </a> 0
<a> public static boolean processArgs ( Object proxy , String args [ ] , </a> 0
<a> String args0 [ ] , String args1 [ ] , </a> 0
<a> Hashtable < String , String > aliases ) throws Exception { </a> 0
<a> for ( int i = 0 ; i < args . length ; i ++ ) { </a> 0
<a> String arg = args [ i ] ; </a> 0
<a> if ( arg . startsWith ( "-" ) ) </a> 0
<a> arg = arg . substring ( 1 ) ; </a> 0
<a> if ( aliases != null && aliases . get ( arg ) != null ) </a> 0
<a> arg = aliases . get ( arg ) ; </a> 0
<a> if ( args0 != null ) { </a> 0
<a> boolean set = false ; </a> 0
<a> for ( int j = 0 ; j < args0 . length ; j ++ ) { </a> 0
<a> if ( args0 [ j ] . equalsIgnoreCase ( arg ) ) { </a> 0
<a> setProperty ( proxy , args0 [ j ] , "true" ) ; </a> 0
<a> set = true ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( set ) </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> if ( args1 != null ) { </a> 0
<a> for ( int j = 0 ; j < args1 . length ; j ++ ) { </a> 0
<a> if ( args1 [ j ] . equalsIgnoreCase ( arg ) ) { </a> 0
<a> i ++ ; </a> 0
<a> if ( i >= args . length ) </a> 0
<a> return false ; </a> 0
<a> setProperty ( proxy , arg , args [ i ] ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> i ++ ; </a> 0
<a> if ( i >= args . length ) </a> 0
<a> return false ; </a> 0
<a> setProperty ( proxy , arg , args [ i ] ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public static void clear ( ) { </a> 0
<a> objectMethods . clear ( ) ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> public static String [ ] findVoidSetters ( Class < ? > c ) { </a> 0
<a> Method m [ ] = findMethods ( c ) ; </a> 0
<a> if ( m == null ) </a> 0
<a> return null ; </a> 0
<a> Vector < String > v = new Vector < String > ( ) ; </a> 0
<a> for ( int i = 0 ; i < m . length ; i ++ ) { </a> 0
<a> if ( m [ i ] . getName ( ) . startsWith ( "set" ) </a> 0
<a> && m [ i ] . getParameterTypes ( ) . length == 0 ) { </a> 0
<a> String arg = m [ i ] . getName ( ) . substring ( 3 ) ; </a> 0
<a> v . addElement ( unCapitalize ( arg ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> String s [ ] = new String [ v . size ( ) ] ; </a> 0
<a> for ( int i = 0 ; i < s . length ; i ++ ) { </a> 0
<a> s [ i ] = ( String ) v . elementAt ( i ) ; </a> 0
<a> } </a> 0
<a> return s ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> public static String [ ] findBooleanSetters ( Class < ? > c ) { </a> 0
<a> Method m [ ] = findMethods ( c ) ; </a> 0
<a> if ( m == null ) </a> 0
<a> return null ; </a> 0
<a> Vector < String > v = new Vector < String > ( ) ; </a> 0
<a> for ( int i = 0 ; i < m . length ; i ++ ) { </a> 0
<a> if ( m [ i ] . getName ( ) . startsWith ( "set" ) </a> 0
<a> && m [ i ] . getParameterTypes ( ) . length == 1 </a> 0
<a> && "boolean" . equalsIgnoreCase ( m [ i ] . getParameterTypes ( ) [ 0 ] </a> 0
<a> . getName ( ) ) ) { </a> 0
<a> String arg = m [ i ] . getName ( ) . substring ( 3 ) ; </a> 0
<a> v . addElement ( unCapitalize ( arg ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> String s [ ] = new String [ v . size ( ) ] ; </a> 0
<a> for ( int i = 0 ; i < s . length ; i ++ ) { </a> 0
<a> s [ i ] = v . elementAt ( i ) ; </a> 0
<a> } </a> 0
<a> return s ; </a> 0
<a> } </a> 0
<a> static Hashtable < Class < ? > , Method [ ] > objectMethods = </a> 0
<a> new Hashtable < Class < ? > , Method [ ] > ( ) ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> public static Method [ ] findMethods ( Class < ? > c ) { </a> 0
<a> Method methods [ ] = ( Method [ ] ) objectMethods . get ( c ) ; </a> 0
<a> if ( methods != null ) </a> 0
<a> return methods ; </a> 0
<a> methods = c . getMethods ( ) ; </a> 0
<a> objectMethods . put ( c , methods ) ; </a> 0
<a> return methods ; </a> 0
<a> } </a> 0
<a> public static Method findMethod ( Class < ? > c , String name , </a> 0
<a> Class < ? > params [ ] ) { </a> 0
<a> Method methods [ ] = findMethods ( c ) ; </a> 0
<a> if ( methods == null ) </a> 0
<a> return null ; </a> 0
<a> for ( int i = 0 ; i < methods . length ; i ++ ) { </a> 0
<a> if ( methods [ i ] . getName ( ) . equals ( name ) ) { </a> 0
<a> Class < ? > methodParams [ ] = methods [ i ] . getParameterTypes ( ) ; </a> 0
<a> if ( methodParams == null ) </a> 0
<a> if ( params == null || params . length == 0 ) </a> 0
<a> return methods [ i ] ; </a> 0
<a> if ( params == null ) </a> 0
<a> if ( methodParams == null || methodParams . length == 0 ) </a> 0
<a> return methods [ i ] ; </a> 0
<a> if ( params . length != methodParams . length ) </a> 0
<a> continue ; </a> 0
<a> boolean found = true ; </a> 0
<a> for ( int j = 0 ; j < params . length ; j ++ ) { </a> 0
<a> if ( params [ j ] != methodParams [ j ] ) { </a> 0
<a> found = false ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( found ) </a> 0
<a> return methods [ i ] ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public static boolean hasHook ( Object obj , String methodN ) { </a> 0
<a> try { </a> 0
<a> Method myMethods [ ] = findMethods ( obj . getClass ( ) ) ; </a> 0
<a> for ( int i = 0 ; i < myMethods . length ; i ++ ) { </a> 0
<a> if ( methodN . equals ( myMethods [ i ] . getName ( ) ) ) { </a> 0
<a> Class < ? > declaring = myMethods [ i ] . getDeclaringClass ( ) ; </a> 0
<a> Class < ? > parentOfDeclaring = declaring . getSuperclass ( ) ; </a> 0
<a> if ( ! "java.lang.Object" . equals ( parentOfDeclaring . getName ( ) ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> logger . debug ( "hasHook() failed" , ex ) ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> public static void callMain ( Class < ? > c , String args [ ] ) throws Exception { </a> 0
<a> Class < ? > p [ ] = new Class [ 1 ] ; </a> 0
<a> p [ 0 ] = args . getClass ( ) ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> Method m = c . getMethod ( "main" , p ) ; </a> 0
<a> m . invoke ( c , new Object [ ] { args } ) ; </a> 0
<a> } </a> 0
<a> public static Object callMethod1 ( Object target , String methodN , </a> 0
<a> Object param1 , String typeParam1 , ClassLoader cl ) throws Exception { </a> 0
<a> if ( target == null || param1 == null ) { </a> 0
<a> debug ( "Assert: Illegal params " + target + " " + param1 ) ; </a> 0
<a> } </a> 0
<a> if ( dbg > 0 ) </a> 0
<a> debug ( "callMethod1 " + target . getClass ( ) . getName ( ) + " " + param1 . getClass ( ) . getName ( ) + " " + </a> 0
<a> typeParam1 ) ; </a> 0
<a> Class < ? > params [ ] = new Class [ 1 ] ; </a> 0
<a> if ( typeParam1 == null ) { </a> 0
<a> params [ 0 ] = param1 . getClass ( ) ; </a> 0
<a> } else { </a> 0
<a> params [ 0 ] = cl . loadClass ( typeParam1 ) ; </a> 0
<a> } </a> 0
<a> Method m = findMethod ( target . getClass ( ) , methodN , params ) ; </a> 0
<a> if ( m == null ) { </a> 0
<a> throw new NoSuchMethodException ( target . getClass ( ) . getName ( ) + " " + methodN ) ; </a> 0
<a> } </a> 0
<a> return m . invoke ( target , new Object [ ] { param1 } ) ; </a> 0
<a> } </a> 0
<a> public static Object callMethod0 ( Object target , String methodN ) </a> 0
<a> throws Exception { </a> 0
<a> if ( target == null ) { </a> 0
<a> debug ( "Assert: Illegal params " + target ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( dbg > 0 ) { </a> 0
<a> debug ( "callMethod0 " + target . getClass ( ) . getName ( ) + "." + methodN ) ; </a> 0
<a> } </a> 0
<a> Class params [ ] = new Class [ 0 ] ; </a> 0
<a> Method m = findMethod ( target . getClass ( ) , methodN , params ) ; </a> 0
<a> if ( m == null ) { </a> 0
<a> throw new NoSuchMethodException ( target . getClass ( ) . getName ( ) + " " + methodN ) ; </a> 0
<a> } </a> 0
<a> return m . invoke ( target , emptyArray ) ; </a> 0
<a> } </a> 0
<a> static Object [ ] emptyArray = new Object [ ] { } ; </a> 0
<a> public static Object callMethodN ( Object target , String methodN , </a> 0
<a> Object params [ ] , Class < ? > typeParams [ ] ) throws Exception { </a> 0
<a> Method m = null ; </a> 0
<a> m = findMethod ( target . getClass ( ) , methodN , typeParams ) ; </a> 0
<a> if ( m == null ) { </a> 0
<a> debug ( "Can't find method " + methodN + " in " + target + " CLASS " + target . getClass ( ) ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> Object o = m . invoke ( target , params ) ; </a> 0
<a> if ( dbg > 0 ) { </a> 0
<a> StringBuffer sb = new StringBuffer ( ) ; </a> 0
<a> sb . append ( "" + target . getClass ( ) . getName ( ) + "." + methodN + "( " ) ; </a> 0
<a> for ( int i = 0 ; i < params . length ; i ++ ) { </a> 0
<a> if ( i > 0 ) </a> 0
<a> sb . append ( ", " ) ; </a> 0
<a> sb . append ( params [ i ] ) ; </a> 0
<a> } </a> 0
<a> sb . append ( ")" ) ; </a> 0
<a> debug ( sb . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> return o ; </a> 0
<a> } </a> 0
<a> public static Object convert ( String object , Class < ? > paramType ) { </a> 0
<a> Object result = null ; </a> 0
<a> if ( "java.lang.String" . equals ( paramType . getName ( ) ) ) { </a> 0
<a> result = object ; </a> 0
<a> } else if ( "java.lang.Integer" . equals ( paramType . getName ( ) ) </a> 0
<a> || "int" . equals ( paramType . getName ( ) ) ) { </a> 0
<a> try { </a> 0
<a> result = new Integer ( object ) ; </a> 0
<a> } catch ( NumberFormatException ex ) { </a> 0
<a> } </a> 0
<a> } else if ( "java.lang.Boolean" . equals ( paramType . getName ( ) ) </a> 0
<a> || "boolean" . equals ( paramType . getName ( ) ) ) { </a> 0
<a> result = new Boolean ( object ) ; </a> 0
<a> } else if ( "java.net.InetAddress" . equals ( paramType </a> 0
<a> . getName ( ) ) ) { </a> 0
<a> try { </a> 0
<a> result = InetAddress . getByName ( object ) ; </a> 0
<a> } catch ( UnknownHostException exc ) { </a> 0
<a> debug ( "Unable to resolve host name:" + object ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> debug ( "Unknown type " + paramType . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( result == null ) { </a> 0
<a> throw new IllegalArgumentException ( "Can't convert argument: " + object ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> public static interface PropertySource { </a> 0
<a> public String getProperty ( String key ) ; </a> 0
<a> } </a> 0
<a> public static interface AttributeHolder { </a> 0
<a> public void setAttribute ( String key , Object o ) ; </a> 0
<a> } </a> 0
<a> static final int dbg = 0 ; </a> 0
<a> static void debug ( String s ) { </a> 0
<a> logger . debug ( "IntrospectionUtils: {}" , s ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . util ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter ; </a> 0
<a> public class XSSHtmlFilter implements BroadcastFilter { </a> 0
<a> public BroadcastAction filter ( Object originalMessage , Object o ) { </a> 1
<a> if ( o instanceof String ) { </a> 0
<a> String message = ( String ) o ; </a> 0
<a> StringBuffer buffer = new StringBuffer ( message . length ( ) ) ; </a> 0
<a> for ( int i = 0 ; i < message . length ( ) ; i ++ ) { </a> 0
<a> char c = message . charAt ( i ) ; </a> 0
<a> switch ( c ) { </a> 0
<a> case '\b' : </a> 0
<a> buffer . append ( "\\b" ) ; </a> 0
<a> break ; </a> 0
<a> case '\f' : </a> 0
<a> buffer . append ( "\\f" ) ; </a> 0
<a> break ; </a> 0
<a> case '\n' : </a> 0
<a> buffer . append ( "<br />" ) ; </a> 0
<a> break ; </a> 0
<a> case '\r' : </a> 0
<a> break ; </a> 0
<a> case '\t' : </a> 0
<a> buffer . append ( "\\t" ) ; </a> 0
<a> break ; </a> 0
<a> case '\'' : </a> 0
<a> buffer . append ( "\\'" ) ; </a> 0
<a> break ; </a> 0
<a> case '\"' : </a> 0
<a> buffer . append ( "\\\"" ) ; </a> 0
<a> break ; </a> 0
<a> case '\\' : </a> 0
<a> buffer . append ( "\\\\" ) ; </a> 0
<a> break ; </a> 0
<a> case '<' : </a> 0
<a> buffer . append ( "&lt;" ) ; </a> 0
<a> break ; </a> 0
<a> case '>' : </a> 0
<a> buffer . append ( "&gt;" ) ; </a> 0
<a> break ; </a> 0
<a> case '&' : </a> 0
<a> buffer . append ( "&amp;" ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> buffer . append ( c ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return new BroadcastAction ( buffer . toString ( ) ) ; </a> 0
<a> } else { </a> 0
<a> return new BroadcastAction ( o ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . atmosphere . tests ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . testng . annotations . Test ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 1
<a> import static org . mockito . Mockito . mock ; </a> 1
<a> import static org . testng . Assert . assertFalse ; </a> 1
<a> import static org . testng . Assert . assertTrue ; </a> 1
<a> public class AtmosphereServletTest { </a> 1
<a> @ Test </a> 1
<a> public void destroy ( ) throws Exception { </a> 1
<a> Broadcaster broadcaster = mock ( Broadcaster . class ) ; </a> 1
<a> AtmosphereServlet servlet = new AtmosphereServlet ( ) ; </a> 1
<a> Handler handler = new Handler ( ) ; </a> 1
<a> Handler handler2 = new Handler ( ) ; </a> 1
<a> assertFalse ( handler . isDestroyed ( ) ) ; </a> 1
<a> assertFalse ( handler2 . isDestroyed ( ) ) ; </a> 1
<a> servlet . addAtmosphereHandler ( "/test" , handler , broadcaster ) ; </a> 0
<a> servlet . addAtmosphereHandler ( "/test2" , handler2 , broadcaster ) ; </a> 0
<a> servlet . destroy ( ) ; </a> 1
<a> assertTrue ( handler . isDestroyed ( ) ) ; </a> 1
<a> assertTrue ( handler2 . isDestroyed ( ) ) ; </a> 1
<a> } </a> 1
<a> private static class Handler implements AtmosphereHandler < HttpServletRequest , HttpServletResponse > { </a> 0
<a> private final AtomicBoolean destroyed = new AtomicBoolean ( false ) ; </a> 1
<a> @ Override </a> 1
<a> public void destroy ( ) { </a> 1
<a> destroyed . set ( true ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > resource ) throws IOException { </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> } </a> 1
<a> public boolean isDestroyed ( ) { </a> 1
<a> return destroyed . get ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . tests ; </a> 0
<a> import org . atmosphere . container . BlockingIOCometSupport ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 1
<a> import org . mortbay . jetty . Connector ; </a> 1
<a> import org . mortbay . jetty . Server ; </a> 1
<a> import org . mortbay . jetty . bio . SocketConnector ; </a> 1
<a> import org . mortbay . jetty . servlet . Context ; </a> 1
<a> import org . mortbay . jetty . servlet . ServletHolder ; </a> 1
<a> import org . testng . annotations . AfterMethod ; </a> 1
<a> import org . testng . annotations . BeforeMethod ; </a> 1
<a> public class BlockingIOCometSupportTest extends BaseTest { </a> 1
<a> protected Server server ; </a> 1
<a> protected Context root ; </a> 1
<a> @ BeforeMethod ( alwaysRun = true ) </a> 1
<a> public void startServer ( ) throws Exception { </a> 1
<a> int port = TestHelper . getEnvVariable ( "ATMOSPHERE_HTTP_PORT" , findFreePort ( ) ) ; </a> 1
<a> urlTarget = "http://127.0.0.1:" + port + "/invoke" ; </a> 1
<a> server = new Server ( ) ; </a> 1
<a> root = new Context ( server , "/" , Context . SESSIONS ) ; </a> 1
<a> atmoServlet = new AtmosphereServlet ( ) ; </a> 1
<a> configureCometSupport ( ) ; </a> 1
<a> setConnector ( port ) ; </a> 1
<a> root . addServlet ( new ServletHolder ( atmoServlet ) , ROOT ) ; </a> 1
<a> server . start ( ) ; </a> 0
<a> } </a> 0
<a> public void setConnector ( int port ) throws Exception { </a> 1
<a> Connector listener = new SocketConnector ( ) ; </a> 1
<a> listener . setHost ( "127.0.0.1" ) ; </a> 1
<a> listener . setPort ( port ) ; </a> 1
<a> server . addConnector ( listener ) ; </a> 1
<a> } </a> 1
<a> public void configureCometSupport ( ) { </a> 1
<a> atmoServlet . setCometSupport ( new BlockingIOCometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 1
<a> @ AfterMethod ( alwaysRun = true ) </a> 1
<a> public void unsetAtmosphereHandler ( ) throws Exception { </a> 1
<a> atmoServlet . destroy ( ) ; </a> 1
<a> server . stop ( ) ; </a> 1
<a> server = null ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . tests ; </a> 0
<a> import org . atmosphere . container . JettyCometSupport ; </a> 1
<a> import org . mortbay . jetty . Connector ; </a> 1
<a> import org . mortbay . jetty . nio . SelectChannelConnector ; </a> 1
<a> public class Jetty6CometSupportTest extends BlockingIOCometSupportTest { </a> 1
<a> public void setConnector ( int port ) throws Exception { </a> 1
<a> Connector listener = new SelectChannelConnector ( ) ; </a> 1
<a> listener . setHost ( "127.0.0.1" ) ; </a> 1
<a> listener . setPort ( port ) ; </a> 1
<a> server . addConnector ( listener ) ; </a> 1
<a> } </a> 0
<a> public void configureCometSupport ( ) { </a> 1
<a> atmoServlet . setCometSupport ( new JettyCometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . atmosphere . tests ; </a> 0
<a> import com . ning . http . client . AsyncCompletionHandler ; </a> 1
<a> import com . ning . http . client . AsyncHttpClient ; </a> 1
<a> import com . ning . http . client . Response ; </a> 1
<a> import org . atmosphere . container . JettyCometSupport ; </a> 1
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 1
<a> import org . atmosphere . cpr . Broadcaster ; </a> 1
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 1
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 1
<a> import org . atmosphere . cpr . Meteor ; </a> 1
<a> import org . atmosphere . cpr . MeteorServlet ; </a> 1
<a> import org . mortbay . jetty . Server ; </a> 1
<a> import org . mortbay . jetty . servlet . Context ; </a> 1
<a> import org . mortbay . jetty . servlet . ServletHolder ; </a> 1
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import org . testng . annotations . AfterMethod ; </a> 1
<a> import org . testng . annotations . BeforeMethod ; </a> 1
<a> import org . testng . annotations . Test ; </a> 1
<a> import javax . servlet . http . HttpServlet ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 1
<a> import javax . servlet . http . HttpServletResponse ; </a> 1
<a> import java . io . IOException ; </a> 1
<a> import java . net . ServerSocket ; </a> 1
<a> import java . util . concurrent . CountDownLatch ; </a> 1
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 1
<a> import static org . testng . Assert . assertEquals ; </a> 1
<a> import static org . testng . Assert . assertFalse ; </a> 1
<a> import static org . testng . Assert . assertNotNull ; </a> 1
<a> import static org . testng . Assert . assertTrue ; </a> 1
<a> import static org . testng . Assert . fail ; </a> 1
<a> public class MeteorTest { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( MeteorTest . class ) ; </a> 1
<a> protected MeteorServlet atmoServlet ; </a> 1
<a> protected final static String ROOT = "/*" ; </a> 1
<a> protected String urlTarget ; </a> 1
<a> protected Server server ; </a> 1
<a> protected Context root ; </a> 1
<a> private static CountDownLatch servletLatch ; </a> 1
<a> public static class TestHelper { </a> 1
<a> public static int getEnvVariable ( final String varName , int defaultValue ) { </a> 1
<a> if ( null == varName ) { </a> 1
<a> return defaultValue ; </a> 1
<a> } </a> 1
<a> String varValue = System . getenv ( varName ) ; </a> 1
<a> if ( null != varValue ) { </a> 1
<a> try { </a> 1
<a> return Integer . parseInt ( varValue ) ; </a> 1
<a> } catch ( NumberFormatException e ) { </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return defaultValue ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> protected int findFreePort ( ) throws IOException { </a> 1
<a> ServerSocket socket = null ; </a> 1
<a> try { </a> 1
<a> socket = new ServerSocket ( 0 ) ; </a> 1
<a> return socket . getLocalPort ( ) ; </a> 1
<a> } finally { </a> 1
<a> if ( socket != null ) { </a> 1
<a> socket . close ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public static class Meteor1 extends HttpServlet { </a> 1
<a> @ Override </a> 1
<a> public void doGet ( HttpServletRequest req , HttpServletResponse res ) throws IOException { </a> 1
<a> final Meteor m = Meteor . build ( req ) ; </a> 1
<a> req . getSession ( ) . setAttribute ( "meteor" , m ) ; </a> 1
<a> m . suspend ( 5000 , false ) ; </a> 0
<a> m . broadcast ( "resume" ) ; </a> 0
<a> m . addListener ( new AtmosphereResourceEventListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onSuspend ( final AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> event . getResource ( ) . getRequest ( ) . setAttribute ( ApplicationConfig . RESUME_ON_BROADCAST , "true" ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> } </a> 1
<a> } ) ; </a> 0
<a> if ( servletLatch != null ) { </a> 1
<a> servletLatch . countDown ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ BeforeMethod ( alwaysRun = true ) </a> 0
<a> public void startServer ( ) throws Exception { </a> 0
<a> int port = org . atmosphere . tests . BaseTest . TestHelper . getEnvVariable ( "ATMOSPHERE_HTTP_PORT" , findFreePort ( ) ) ; </a> 0
<a> urlTarget = "http://127.0.0.1:" + port + "/invoke" ; </a> 1
<a> server = new Server ( port ) ; </a> 1
<a> root = new Context ( server , "/" , Context . SESSIONS ) ; </a> 1
<a> atmoServlet = new MeteorServlet ( ) ; </a> 1
<a> atmoServlet . addInitParameter ( "org.atmosphere.servlet" , Meteor1 . class . getName ( ) ) ; </a> 0
<a> configureCometSupport ( ) ; </a> 1
<a> root . addServlet ( new ServletHolder ( atmoServlet ) , ROOT ) ; </a> 1
<a> server . start ( ) ; </a> 1
<a> } </a> 1
<a> public void configureCometSupport ( ) { </a> 1
<a> atmoServlet . setCometSupport ( new JettyCometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 1
<a> @ AfterMethod ( alwaysRun = true ) </a> 1
<a> public void unsetAtmosphereHandler ( ) throws Exception { </a> 1
<a> atmoServlet . destroy ( ) ; </a> 0
<a> server . stop ( ) ; </a> 1
<a> server = null ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 1
<a> public void testSuspendTimeout ( ) { </a> 0
<a> logger . info ( "running test: testSuspendTimeout" ) ; </a> 1
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 1
<a> try { </a> 1
<a> long currentTime = System . currentTimeMillis ( ) ; </a> 1
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 1
<a> long time = System . currentTimeMillis ( ) - currentTime ; </a> 1
<a> if ( time > 5000 && time < 15000 ) { </a> 1
<a> assertTrue ( true ) ; </a> 1
<a> } else { </a> 1
<a> assertFalse ( false ) ; </a> 1
<a> } </a> 1
<a> assertNotNull ( r ) ; </a> 1
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 1
<a> String resume = r . getResponseBody ( ) ; </a> 1
<a> assertEquals ( resume , "resume" ) ; </a> 1
<a> } catch ( Exception e ) { </a> 1
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testResumeOnBroadcast ( ) { </a> 0
<a> logger . info ( "running test: testResumeOnBroadcast" ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 1
<a> servletLatch = new CountDownLatch ( 1 ) ; </a> 1
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 1
<a> try { </a> 1
<a> long currentTime = System . currentTimeMillis ( ) ; </a> 1
<a> final AtomicReference < Response > r = new AtomicReference ( ) ; </a> 1
<a> c . prepareGet ( urlTarget ) . execute ( new AsyncCompletionHandler < Response > ( ) { </a> 1
<a> @ Override </a> 1
<a> public Response onCompleted ( Response response ) throws Exception { </a> 1
<a> r . set ( response ) ; </a> 1
<a> latch . countDown ( ) ; </a> 1
<a> return response ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> servletLatch . await ( ) ; </a> 1
<a> Broadcaster b = BroadcasterFactory . getDefault ( ) . lookup ( DefaultBroadcaster . class , "/*" ) ; </a> 1
<a> assertNotNull ( b ) ; </a> 1
<a> b . broadcast ( "resume" ) . get ( ) ; </a> 1
<a> try { </a> 1
<a> latch . await ( ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> long time = System . currentTimeMillis ( ) - currentTime ; </a> 1
<a> if ( time < 5000 ) { </a> 1
<a> assertTrue ( true ) ; </a> 1
<a> } else { </a> 1
<a> assertFalse ( false ) ; </a> 1
<a> } </a> 1
<a> assertNotNull ( r . get ( ) ) ; </a> 1
<a> assertEquals ( r . get ( ) . getStatusCode ( ) , 200 ) ; </a> 1
<a> String resume = r . get ( ) . getResponseBody ( ) ; </a> 1
<a> assertEquals ( resume , "resumeresume" ) ; </a> 1
<a> } catch ( Exception e ) { </a> 1
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey ; </a> 0
<a> import com . sun . jersey . api . core . ResourceConfig ; </a> 0
<a> import com . sun . jersey . api . core . ResourceConfigurator ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> public class AtmosphereResourceConfigurator implements ResourceConfigurator { </a> 0
<a> @ Override </a> 0
<a> public void configure ( ResourceConfig config ) { </a> 0
<a> Collections . addAll ( config . getClasses ( ) , </a> 0
<a> AtmosphereProviders . BroadcasterProvider . class , </a> 0
<a> AtmosphereProviders . TrackableResourceProvider . class , </a> 1
<a> BroadcasterFactoryInjector . PerRequest . class , </a> 0
<a> BroadcasterFactoryInjector . Singleton . class , </a> 0
<a> BroadcasterInjector . PerRequest . class , </a> 0
<a> BroadcasterInjector . Singleton . class , </a> 0
<a> AtmosphereResourceInjector . PerRequest . class , </a> 0
<a> AtmosphereResourceInjector . Singleton . class ) ; </a> 0
<a> config . getResourceFilterFactories ( ) . add ( AtmosphereFilter . class ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey ; </a> 0
<a> import com . sun . jersey . core . spi . component . ComponentContext ; </a> 0
<a> import com . sun . jersey . core . spi . component . ComponentScope ; </a> 0
<a> import com . sun . jersey . spi . inject . Injectable ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import java . lang . reflect . InvocationHandler ; </a> 0
<a> import java . lang . reflect . Method ; </a> 0
<a> import java . lang . reflect . ParameterizedType ; </a> 0
<a> import java . lang . reflect . Proxy ; </a> 0
<a> import java . lang . reflect . Type ; </a> 0
<a> abstract class AtmosphereResourceInjector extends BaseInjectableProvider { </a> 0
<a> boolean isValidType ( Type c ) { </a> 0
<a> if ( c == AtmosphereResource . class ) return true ; </a> 0
<a> if ( c instanceof ParameterizedType ) { </a> 0
<a> ParameterizedType pt = ( ParameterizedType ) c ; </a> 0
<a> if ( pt . getRawType ( ) != AtmosphereResource . class ) return false ; </a> 0
<a> if ( pt . getActualTypeArguments ( ) . length != 2 ) return false ; </a> 0
<a> if ( pt . getActualTypeArguments ( ) [ 0 ] != HttpServletRequest . class ) return false ; </a> 0
<a> if ( pt . getActualTypeArguments ( ) [ 1 ] != HttpServletResponse . class ) return false ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> public static final class PerRequest extends AtmosphereResourceInjector { </a> 0
<a> @ Override </a> 0
<a> public ComponentScope getScope ( ) { </a> 0
<a> return ComponentScope . PerRequest ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Injectable < AtmosphereResource > getInjectable ( ComponentContext ic , Context a , Type c ) { </a> 0
<a> if ( ! isValidType ( c ) ) </a> 0
<a> return null ; </a> 0
<a> return new Injectable < AtmosphereResource > ( ) { </a> 0
<a> @ Override </a> 0
<a> public AtmosphereResource getValue ( ) { </a> 0
<a> return getAtmosphereResource ( AtmosphereResource . class , false ) ; </a> 1
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final class Singleton extends AtmosphereResourceInjector { </a> 0
<a> @ Override </a> 0
<a> public ComponentScope getScope ( ) { </a> 0
<a> return ComponentScope . Singleton ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Injectable < AtmosphereResource > getInjectable ( ComponentContext ic , Context a , Type c ) { </a> 0
<a> if ( ! isValidType ( c ) ) </a> 0
<a> return null ; </a> 0
<a> return new Injectable < AtmosphereResource > ( ) { </a> 0
<a> @ Override </a> 0
<a> public AtmosphereResource getValue ( ) { </a> 0
<a> return ( AtmosphereResource ) Proxy . newProxyInstance ( this . getClass ( ) . getClassLoader ( ) , </a> 1
<a> new Class [ ] { AtmosphereResource . class } , new InvocationHandler ( ) { </a> 1
<a> @ Override </a> 0
<a> public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { </a> 0
<a> return method . invoke ( getAtmosphereResource ( AtmosphereResource . class , false ) , args ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey ; </a> 0
<a> import com . sun . jersey . spi . inject . InjectableProvider ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . FrameworkConfig ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import java . lang . reflect . Type ; </a> 0
<a> abstract class BaseInjectableProvider implements InjectableProvider < Context , Type > { </a> 0
<a> @ Context </a> 0
<a> HttpServletRequest req ; </a> 0
<a> protected AtmosphereResource getAtmosphereResource ( Class injectType , boolean session ) { </a> 0
<a> AtmosphereResource r = null ; </a> 0
<a> try { </a> 0
<a> if ( session ) { </a> 0
<a> if ( ( Boolean ) req . getAttribute ( FrameworkConfig . SUPPORT_SESSION ) ) { </a> 0
<a> r = ( AtmosphereResource ) req . getSession ( ) . </a> 0
<a> getAttribute ( AtmosphereFilter . SUSPENDED_RESOURCE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( r == null ) { </a> 0
<a> r = ( AtmosphereResource ) </a> 0
<a> req . getAttribute ( FrameworkConfig . ATMOSPHERE_RESOURCE ) ; </a> 0
<a> } </a> 0
<a> return r ; </a> 0
<a> } catch ( IllegalStateException ex ) { </a> 0
<a> throw new IllegalStateException ( "An instance of the class " + injectType . getName ( ) + " could not be injected because there is no HTTP request in scope" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey ; </a> 0
<a> import com . sun . jersey . core . spi . component . ComponentContext ; </a> 0
<a> import com . sun . jersey . core . spi . component . ComponentScope ; </a> 0
<a> import com . sun . jersey . spi . inject . Injectable ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import java . lang . reflect . Type ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> abstract class BroadcasterFactoryInjector extends BaseInjectableProvider { </a> 0
<a> boolean isValidType ( Type t ) { </a> 0
<a> return ( t instanceof Class ) && BroadcasterFactory . class . isAssignableFrom ( ( Class ) t ) ; </a> 0
<a> } </a> 0
<a> public static final class PerRequest extends BroadcasterFactoryInjector { </a> 0
<a> @ Override </a> 0
<a> public ComponentScope getScope ( ) { </a> 0
<a> return ComponentScope . PerRequest ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Injectable < BroadcasterFactory > getInjectable ( ComponentContext ic , Context a , Type c ) { </a> 0
<a> if ( ! isValidType ( c ) ) </a> 0
<a> return null ; </a> 0
<a> return new Injectable < BroadcasterFactory > ( ) { </a> 0
<a> @ Override </a> 0
<a> public BroadcasterFactory getValue ( ) { </a> 0
<a> return getAtmosphereResource ( AtmosphereResource . class , true ) . getAtmosphereConfig ( ) . getBroadcasterFactory ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final class Singleton extends BroadcasterFactoryInjector { </a> 0
<a> @ Override </a> 0
<a> public ComponentScope getScope ( ) { </a> 0
<a> return ComponentScope . Singleton ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Injectable < BroadcasterFactory > getInjectable ( ComponentContext ic , Context a , Type c ) { </a> 0
<a> if ( ! isValidType ( c ) ) </a> 0
<a> return null ; </a> 0
<a> return new Injectable < BroadcasterFactory > ( ) { </a> 0
<a> @ Override </a> 0
<a> public BroadcasterFactory getValue ( ) { </a> 0
<a> return new BroadcasterFactoryProxy ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> class BroadcasterFactoryProxy extends BroadcasterFactory { </a> 1
<a> BroadcasterFactory _get ( ) { </a> 0
<a> return getAtmosphereResource ( AtmosphereResource . class , true ) . getAtmosphereConfig ( ) . getBroadcasterFactory ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Broadcaster get ( ) throws IllegalAccessException , InstantiationException { </a> 0
<a> return _get ( ) . get ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Broadcaster get ( Class < ? extends Broadcaster > c , Object id ) throws IllegalAccessException , InstantiationException { </a> 0
<a> return _get ( ) . get ( c , id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void destroy ( ) { </a> 0
<a> _get ( ) . destroy ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean add ( Broadcaster b , Object id ) { </a> 0
<a> return _get ( ) . add ( b , id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean remove ( Broadcaster b , Object id ) { </a> 0
<a> return _get ( ) . remove ( b , id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Broadcaster lookup ( Class < ? extends Broadcaster > c , Object id ) { </a> 0
<a> return _get ( ) . lookup ( c , id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Broadcaster lookup ( Class < ? extends Broadcaster > c , Object id , boolean createIfNull ) { </a> 0
<a> return _get ( ) . lookup ( c , id , createIfNull ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void removeAllAtmosphereResource ( AtmosphereResource < ? , ? > r ) { </a> 0
<a> _get ( ) . removeAllAtmosphereResource ( r ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Collection < Broadcaster > lookupAll ( ) { </a> 0
<a> return _get ( ) . lookupAll ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey ; </a> 0
<a> import org . atmosphere . cpr . Trackable ; </a> 1
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import java . util . concurrent . CountDownLatch ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 1
<a> public class TrackableResource < T extends Trackable > { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( TrackableResource . class ) ; </a> 1
<a> private final Class < T > type ; </a> 1
<a> private T resource ; </a> 1
<a> private String trackingID = null ; </a> 1
<a> private final Object entity ; </a> 1
<a> private final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 1
<a> public TrackableResource ( Class < T > type , Object entity ) { </a> 1
<a> this . type = type ; </a> 1
<a> this . entity = entity ; </a> 1
<a> } </a> 1
<a> public TrackableResource ( Class < T > type , String trackingID , Object entity ) { </a> 1
<a> this . type = type ; </a> 1
<a> this . trackingID = trackingID ; </a> 1
<a> this . entity = entity ; </a> 1
<a> } </a> 1
<a> protected void setResource ( Trackable resource ) { </a> 1
<a> if ( ! type . isAssignableFrom ( resource . getClass ( ) ) ) { </a> 1
<a> throw new IllegalStateException ( String . format ( "Unassignable %s to %s" , type . toString ( ) , resource . getClass ( ) . toString ( ) ) ) ; </a> 1
<a> } </a> 1
<a> latch . countDown ( ) ; </a> 1
<a> this . resource = type . cast ( resource ) ; </a> 1
<a> } </a> 1
<a> protected void setTrackingID ( String trackingID ) { </a> 1
<a> this . trackingID = trackingID ; </a> 1
<a> } </a> 1
<a> public T resource ( ) { </a> 1
<a> try { </a> 1
<a> latch . await ( 5 , TimeUnit . SECONDS ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> logger . trace ( "" , e ) ; </a> 1
<a> } </a> 1
<a> return resource ; </a> 1
<a> } </a> 1
<a> public Class < T > type ( ) { </a> 1
<a> return type ; </a> 1
<a> } </a> 1
<a> public String trackingID ( ) { </a> 1
<a> return trackingID ; </a> 1
<a> } </a> 1
<a> public Object entity ( ) { </a> 1
<a> return entity ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import org . atmosphere . container . BlockingIOCometSupport ; </a> 0
<a> import org . mortbay . jetty . Server ; </a> 0
<a> import org . mortbay . jetty . servlet . Context ; </a> 0
<a> import org . mortbay . jetty . servlet . ServletHolder ; </a> 0
<a> import org . testng . annotations . AfterMethod ; </a> 1
<a> public class BlockingIOJerseyTest extends BasePubSubTest { </a> 0
<a> protected Server server ; </a> 0
<a> protected Context root ; </a> 0
<a> protected final static String ROOT = "/*" ; </a> 0
<a> @ Override </a> 0
<a> public void configureCometSupport ( ) { </a> 0
<a> atmoServlet . setCometSupport ( new BlockingIOCometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public void startServer ( ) throws Exception { </a> 0
<a> server = new Server ( port ) ; </a> 0
<a> root = new Context ( server , "/" , Context . SESSIONS ) ; </a> 0
<a> root . addServlet ( new ServletHolder ( atmoServlet ) , ROOT ) ; </a> 0
<a> server . start ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public void stopServer ( ) throws Exception { </a> 0
<a> server . stop ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> @ AfterMethod ( alwaysRun = true ) </a> 1
<a> public void unsetAtmosphereHandler ( ) throws Exception { </a> 1
<a> atmoServlet . destroy ( ) ; </a> 0
<a> server . stop ( ) ; </a> 0
<a> server = null ; </a> 0
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import org . atmosphere . container . Jetty7CometSupport ; </a> 0
<a> import org . eclipse . jetty . server . Server ; </a> 0
<a> import org . eclipse . jetty . servlet . ServletContextHandler ; </a> 0
<a> import org . eclipse . jetty . servlet . ServletHolder ; </a> 0
<a> public class Jetty7JerseyTest extends BasePubSubTest { </a> 0
<a> protected Server server ; </a> 0
<a> @ Override </a> 0
<a> public void startServer ( ) throws Exception { </a> 0
<a> server = new Server ( port ) ; </a> 0
<a> ServletContextHandler context = new ServletContextHandler ( ServletContextHandler . SESSIONS ) ; </a> 0
<a> context . setContextPath ( "/" ) ; </a> 0
<a> server . setHandler ( context ) ; </a> 0
<a> context . addServlet ( new ServletHolder ( atmoServlet ) , "/*" ) ; </a> 0
<a> server . start ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void configureCometSupport ( ) { </a> 0
<a> atmoServlet . setCometSupport ( new Jetty7CometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void stopServer ( ) throws Exception { </a> 0
<a> server . stop ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import com . sun . jersey . spi . resource . Singleton ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import static org . testng . Assert . assertNotNull ; </a> 0
<a> @ Path ( "/singleton" ) </a> 0
<a> @ Produces ( "text/plain;charset=ISO-8859-1" ) </a> 0
<a> @ Singleton </a> 0
<a> public class SingletonResource { </a> 0
<a> @ Context </a> 0
<a> Broadcaster b ; </a> 0
<a> @ Context </a> 0
<a> BroadcasterFactory bf ; </a> 0
<a> @ Context </a> 0
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > ar ; </a> 0
<a> @ GET </a> 0
<a> @ Suspend ( period = 5000 , outputComments = false ) </a> 0
<a> public String subscribe ( ) { </a> 0
<a> assertNotNull ( b . toString ( ) ) ; </a> 0
<a> assertNotNull ( bf . toString ( ) ) ; </a> 0
<a> assertNotNull ( ar . toString ( ) ) ; </a> 0
<a> return "singleton" ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Broadcast </a> 0
<a> public String publish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return message ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . guice ; </a> 0
<a> import com . google . inject . servlet . ServletModule ; </a> 0
<a> public class GuiceChatModule extends ServletModule { </a> 0
<a> @ Override </a> 0
<a> protected void configureServlets ( ) { </a> 0
<a> bind ( org . atmosphere . commons . jersey . ResourceChat . class ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . atmosphere . commons . util ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public class EventsLogger implements AtmosphereResourceEventListener { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( EventsLogger . class ) ; </a> 0
<a> public EventsLogger ( ) { </a> 0
<a> } </a> 0
<a> public void onSuspend ( final AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onSuspend(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> public void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onResume(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> public void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onDisconnect(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> public void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onBroadcast(): {}" , event ) ; </a> 1
<a> } </a> 0
<a> public void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . warn ( "onThrowable(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . di . guice ; </a> 0
<a> import com . google . inject . Guice ; </a> 0
<a> import com . google . inject . Injector ; </a> 0
<a> import com . google . inject . servlet . GuiceServletContextListener ; </a> 0
<a> import com . google . inject . servlet . ServletModule ; </a> 0
<a> import com . sun . jersey . guice . spi . container . servlet . GuiceContainer ; </a> 1
<a> import org . atmosphere . guice . GuiceManagedAtmosphereServlet ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> public final class GuiceContextListener extends GuiceServletContextListener { </a> 0
<a> @ Override </a> 0
<a> protected Injector getInjector ( ) { </a> 0
<a> return Guice . createInjector ( new ServletModule ( ) { </a> 0
<a> @ Override </a> 0
<a> protected void configureServlets ( ) { </a> 0
<a> bind ( MessageResource . class ) ; </a> 0
<a> serve ( "/async/*" ) . with ( GuiceManagedAtmosphereServlet . class , new HashMap < String , String > ( ) { </a> 0
<a> { </a> 0
<a> put ( "org.atmosphere.useWebSocket" , "true" ) ; </a> 0
<a> put ( "org.atmosphere.useNative" , "true" ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> serve ( "/rest/*" ) . with ( GuiceContainer . class ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . di . guice ; </a> 0
<a> import com . google . inject . Inject ; </a> 0
<a> import com . google . inject . Singleton ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 1
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 1
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 1
<a> import org . atmosphere . jersey . Broadcastable ; </a> 0
<a> import org . codehaus . jettison . json . JSONException ; </a> 0
<a> import org . codehaus . jettison . json . JSONObject ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> @ Path ( "/topic" ) </a> 0
<a> @ Singleton </a> 0
<a> @ Produces ( "application/json" ) </a> 0
<a> public class MessageResource { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( MessageResource . class ) ; </a> 0
<a> @ Inject </a> 0
<a> Service service ; </a> 0
<a> @ GET </a> 0
<a> @ Path ( "{name}" ) </a> 0
<a> @ Suspend ( outputComments = true , resumeOnBroadcast = false , listeners = EventsLogger . class ) </a> 0
<a> public Broadcastable listen ( @ PathParam ( "name" ) String topic ) throws JSONException { </a> 0
<a> Broadcaster broadcaster = BroadcasterFactory . getDefault ( ) . lookup ( DefaultBroadcaster . class , topic , true ) ; </a> 1
<a> logger . info ( "thread: {} LISTENING to '{}'" , Thread . currentThread ( ) . getName ( ) , broadcaster . getID ( ) ) ; </a> 0
<a> if ( service == null ) { </a> 0
<a> throw new AssertionError ( ) ; </a> 0
<a> } </a> 0
<a> return new Broadcastable ( new JSONObject ( ) . put ( "from" , "system" ) . put ( "msg" , "Connected !" ) , broadcaster ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "{name}" ) </a> 0
<a> @ Broadcast </a> 0
<a> public Broadcastable publish ( @ PathParam ( "name" ) String topic , @ FormParam ( "from" ) String from , </a> 0
<a> @ FormParam ( "msg" ) String message ) throws JSONException { </a> 0
<a> Broadcaster broadcaster = BroadcasterFactory . getDefault ( ) . lookup ( DefaultBroadcaster . class , topic , true ) ; </a> 1
<a> logger . info ( "thread: {} PUBLISH to '{}' from {}: {}" , </a> 0
<a> new Object [ ] { Thread . currentThread ( ) . getName ( ) , broadcaster . getID ( ) , from , message } ) ; </a> 0
<a> if ( service == null ) { </a> 0
<a> throw new AssertionError ( ) ; </a> 0
<a> } </a> 0
<a> return new Broadcastable ( new JSONObject ( ) . put ( "from" , from ) . put ( "msg" , message ) , "" , broadcaster ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . server ; </a> 0
<a> import org . atmosphere . gwt . poll . AtmospherePollService ; </a> 0
<a> import org . atmosphere . samples . client . Event ; </a> 0
<a> import org . atmosphere . samples . client . Poll ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . Timer ; </a> 0
<a> import java . util . TimerTask ; </a> 0
<a> public class PollService extends AtmospherePollService </a> 0
<a> implements Poll { </a> 0
<a> @ Override </a> 0
<a> public Event pollDelayed ( final int milli ) { </a> 0
<a> final SuspendInfo info = suspend ( ) ; </a> 0
<a> Timer t = new Timer ( ) ; </a> 0
<a> t . schedule ( new TimerTask ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> try { </a> 0
<a> info . writeAndResume ( new Event ( milli , "Polling: Delayed event" ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . error ( "Failed to write and resume" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , milli ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> private Logger logger = LoggerFactory . getLogger ( PollService . class . getName ( ) ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public class EventsLogger implements AtmosphereResourceEventListener { </a> 0
<a> public EventsLogger ( ) { </a> 0
<a> } </a> 0
<a> public void onSuspend ( final AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> System . out . println ( "onSuspend: " + event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) </a> 0
<a> + event . getResource ( ) . getRequest ( ) . getRemotePort ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> System . out . println ( "onResume: " + event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> System . out . println ( "onDisconnect: " + event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) </a> 0
<a> + event . getResource ( ) . getRequest ( ) . getRemotePort ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> System . out . println ( "onBroadcast: " + event . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> event . throwable ( ) . printStackTrace ( System . err ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import javax . xml . bind . annotation . XmlRootElement ; </a> 0
<a> @ XmlRootElement </a> 0
<a> public class JAXBBean { </a> 0
<a> public String value ; </a> 0
<a> public JAXBBean ( ) { </a> 0
<a> super ( ) ; </a> 0
<a> } </a> 0
<a> public JAXBBean ( String str ) { </a> 0
<a> super ( ) ; </a> 0
<a> value = str ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . twitter ; </a> 0
<a> import com . sun . jersey . spi . resource . Singleton ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . jersey . Broadcastable ; </a> 0
<a> import org . atmosphere . samples . twitter . UsersState . UserStateData ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . ws . rs . Consumes ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import javax . ws . rs . QueryParam ; </a> 0
<a> import javax . ws . rs . WebApplicationException ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import javax . ws . rs . core . MediaType ; </a> 0
<a> @ Path ( "/twitter" ) </a> 0
<a> @ Singleton </a> 0
<a> public class TwitterResource { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( TwitterResource . class ) ; </a> 0
<a> private int counter ; </a> 0
<a> private static final String BEGIN_SCRIPT_TAG = "<script type='text/javascript'>\n" ; </a> 0
<a> private static final String END_SCRIPT_TAG = "</script>\n" ; </a> 0
<a> private static final long serialVersionUID = - 2919167206889576860L ; </a> 0
<a> private String startingMessage = "<html><head><title>Twitter</title></head><body bgcolor=\"#FFFFFF\">" ; </a> 0
<a> private UsersState us = new UsersState ( ) ; </a> 0
<a> public TwitterResource ( ) { </a> 0
<a> } </a> 0
<a> @ Suspend ( scope = Suspend . SCOPE . REQUEST ) </a> 0
<a> @ GET </a> 0
<a> @ Produces ( "text/html;charset=ISO-8859-1" ) </a> 0
<a> public String onStart ( @ QueryParam ( "callback" ) String callback ) { </a> 0
<a> String message = "{ message : 'Welcome'}" ; </a> 0
<a> if ( callback == null ) { </a> 0
<a> callback = "alert" ; </a> 0
<a> } </a> 0
<a> StringBuilder sb = new StringBuilder ( ) ; </a> 0
<a> sb . append ( startingMessage ) ; </a> 0
<a> sb . append ( "<script id='comet_" + counter ++ </a> 0
<a> + "'>" + "window.parent." + callback + "(" + message + ");</script>\n" ) ; </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> @ Path ( "login" ) </a> 0
<a> @ Broadcast </a> 0
<a> @ POST </a> 0
<a> @ Consumes ( MediaType . APPLICATION_FORM_URLENCODED ) </a> 0
<a> @ Produces ( "text/plain;charset=ISO-8859-1" ) </a> 0
<a> public Broadcastable onLogin ( @ Context TwitterBroadcaster bc , </a> 0
<a> @ FormParam ( "name" ) String name ) { </a> 0
<a> UserStateData usd = us . create ( name , ( TwitterBroadcaster ) bc ) ; </a> 0
<a> if ( usd == null ) </a> 0
<a> throw new WebApplicationException ( 400 ) ; </a> 0
<a> if ( name == null ) { </a> 0
<a> logger . error ( "Name cannot be null" ) ; </a> 0
<a> throw new WebApplicationException ( 400 ) ; </a> 0
<a> } </a> 0
<a> bc . setID ( name ) ; </a> 0
<a> String m = BEGIN_SCRIPT_TAG + toJsonp ( "Welcome back" , name ) + END_SCRIPT_TAG ; </a> 0
<a> Broadcastable b = new Broadcastable ( m , bc ) ; </a> 0
<a> return b ; </a> 0
<a> } </a> 0
<a> @ Path ( "follows" ) </a> 0
<a> @ POST </a> 0
<a> @ Consumes ( MediaType . APPLICATION_FORM_URLENCODED ) </a> 0
<a> @ Produces ( "text/html;charset=ISO-8859-1" ) </a> 0
<a> @ Broadcast </a> 0
<a> public Broadcastable onFollow ( @ Context TwitterBroadcaster userBc , </a> 0
<a> @ FormParam ( "name" ) String name , </a> 0
<a> @ FormParam ( "followee" ) String followee ) { </a> 0
<a> if ( followee == null ) { </a> 0
<a> logger . error ( "Message cannot be null" ) ; </a> 0
<a> throw new WebApplicationException ( 400 ) ; </a> 0
<a> } </a> 0
<a> if ( name == null ) { </a> 0
<a> logger . error ( "Name cannot be null" ) ; </a> 0
<a> throw new WebApplicationException ( 400 ) ; </a> 0
<a> } </a> 0
<a> UserStateData followeeData = us . get ( followee ) ; </a> 0
<a> TwitterBroadcaster outsiderBroadcaster = followeeData . bc ; </a> 0
<a> if ( outsiderBroadcaster == null ) { </a> 0
<a> String m = ( BEGIN_SCRIPT_TAG + toJsonp ( "Invalid Twitter user " , followee ) + END_SCRIPT_TAG ) ; </a> 0
<a> Broadcastable b = new Broadcastable ( m , userBc ) ; </a> 0
<a> return b ; </a> 0
<a> } </a> 0
<a> outsiderBroadcaster . broadcast ( BEGIN_SCRIPT_TAG </a> 0
<a> + toJsonp ( name , " is now following " + followee ) </a> 0
<a> + END_SCRIPT_TAG ) ; </a> 0
<a> outsiderBroadcaster . addAtmosphereResource ( userBc . getUserAtmosphereEvent ( ) . getResource ( ) ) ; </a> 0
<a> String m = ( BEGIN_SCRIPT_TAG </a> 0
<a> + toJsonp ( "You are now following " , followee ) </a> 0
<a> + END_SCRIPT_TAG ) ; </a> 0
<a> Broadcastable b = new Broadcastable ( m , userBc ) ; </a> 0
<a> return b ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Consumes ( MediaType . APPLICATION_FORM_URLENCODED ) </a> 0
<a> @ Produces ( "text/html;charset=ISO-8859-1" ) </a> 0
<a> @ Broadcast </a> 0
<a> public Broadcastable onPush ( @ Context TwitterBroadcaster bc , </a> 0
<a> @ FormParam ( "message" ) String message , </a> 0
<a> @ FormParam ( "callback" ) String callback ) { </a> 0
<a> if ( message == null ) { </a> 0
<a> logger . error ( "Message cannot be null" ) ; </a> 0
<a> throw new WebApplicationException ( 400 ) ; </a> 0
<a> } </a> 0
<a> if ( callback == null ) { </a> 0
<a> callback = "alert" ; </a> 0
<a> } </a> 0
<a> String m = "<script id='comet_" + counter ++ + "'>" + "window.parent." </a> 0
<a> + callback + "(" + message + ");</script>" ; </a> 0
<a> Broadcastable b = new Broadcastable ( m , bc ) ; </a> 0
<a> return b ; </a> 0
<a> } </a> 0
<a> private String escape ( String orig ) { </a> 0
<a> StringBuilder buffer = new StringBuilder ( orig . length ( ) ) ; </a> 0
<a> for ( int i = 0 ; i < orig . length ( ) ; i ++ ) { </a> 0
<a> char c = orig . charAt ( i ) ; </a> 0
<a> switch ( c ) { </a> 0
<a> case '\b' : </a> 0
<a> buffer . append ( "\\b" ) ; </a> 0
<a> break ; </a> 0
<a> case '\f' : </a> 0
<a> buffer . append ( "\\f" ) ; </a> 0
<a> break ; </a> 0
<a> case '\n' : </a> 0
<a> buffer . append ( "<br />" ) ; </a> 0
<a> break ; </a> 0
<a> case '\r' : </a> 0
<a> break ; </a> 0
<a> case '\t' : </a> 0
<a> buffer . append ( "\\t" ) ; </a> 0
<a> break ; </a> 0
<a> case '\'' : </a> 0
<a> buffer . append ( "\\'" ) ; </a> 0
<a> break ; </a> 0
<a> case '\"' : </a> 0
<a> buffer . append ( "\\\"" ) ; </a> 0
<a> break ; </a> 0
<a> case '\\' : </a> 0
<a> buffer . append ( "\\\\" ) ; </a> 0
<a> break ; </a> 0
<a> case '<' : </a> 0
<a> buffer . append ( "&lt;" ) ; </a> 0
<a> break ; </a> 0
<a> case '>' : </a> 0
<a> buffer . append ( "&gt;" ) ; </a> 0
<a> break ; </a> 0
<a> case '&' : </a> 0
<a> buffer . append ( "&amp;" ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> buffer . append ( c ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return buffer . toString ( ) ; </a> 0
<a> } </a> 0
<a> private String toJsonp ( String name , String message ) { </a> 0
<a> return "window.parent.app.update({ name: \"" + escape ( name ) + "\", message: \"" + escape ( message ) + "\" });\n" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . tictactoe ; </a> 0
<a> public class TTTGame { </a> 0
<a> final public static int X = 10 ; </a> 0
<a> final public static int O = 1 ; </a> 0
<a> int [ ] board = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; </a> 0
<a> int turnNum = 0 ; </a> 0
<a> int [ ] [ ] wins = { { 0 , 1 , 2 } , { 3 , 4 , 5 , } , { 6 , 7 , 8 } , { 0 , 3 , 6 } , </a> 0
<a> { 1 , 4 , 7 } , { 2 , 5 , 8 } , { 0 , 4 , 8 } , { 2 , 4 , 6 } } ; </a> 0
<a> int winner = - 1 ; </a> 0
<a> public boolean turn ( int cell ) { </a> 0
<a> if ( cell < 0 || cell > 8 ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( winner != - 1 ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( board [ cell ] != 0 ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> turnNum ++ ; </a> 0
<a> if ( turnNum % 2 == 1 ) { </a> 0
<a> board [ cell ] = X ; </a> 0
<a> } else { </a> 0
<a> board [ cell ] = O ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> private int whoseTurn ( ) { </a> 0
<a> if ( turnNum == 0 || turnNum % 2 == 0 ) { </a> 0
<a> return X ; </a> 0
<a> } else { </a> 0
<a> return O ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean done ( ) { </a> 0
<a> return ( turnNum > 8 ) ; </a> 0
<a> } </a> 0
<a> public int win ( ) { </a> 0
<a> if ( winner != - 1 ) { </a> 0
<a> return winner ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < 8 ; i ++ ) { </a> 0
<a> int winSum = board [ wins [ i ] [ 0 ] ] + board [ wins [ i ] [ 1 ] ] + board [ wins [ i ] [ 2 ] ] ; </a> 0
<a> if ( winSum == 3 ) { </a> 0
<a> winner = 2 ; </a> 0
<a> } else if ( winSum == 30 ) { </a> 0
<a> winner = 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( winner == - 1 && turnNum > 8 ) { </a> 0
<a> winner = 0 ; </a> 0
<a> } </a> 0
<a> return winner ; </a> 0
<a> } </a> 0
<a> private int [ ] getBoard ( ) { </a> 0
<a> return board ; </a> 0
<a> } </a> 0
<a> public String getJSON ( ) { </a> 0
<a> String response = "{" + </a> 0
<a> "\"win\": \"" + win ( ) + "\", \"board\": [" ; </a> 0
<a> for ( int i = 0 ; i < 9 ; i ++ ) { </a> 0
<a> response = response + "\"" + board [ i ] + "\"" ; </a> 0
<a> if ( i < 8 ) { </a> 0
<a> response = response + "," ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> response = response + "]," + "\"turn\": " + whoseTurn ( ) + " }" ; </a> 0
<a> return response ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . twitter ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public class EventsLogger implements AtmosphereResourceEventListener { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( EventsLogger . class ) ; </a> 0
<a> public EventsLogger ( ) { </a> 0
<a> } </a> 0
<a> public void onSuspend ( final AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onSuspend(): {}:{}" , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onResume(): {}:{}" , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onDisconnect(): {}:{}" , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onBroadcast(): {}" , event . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . warn ( "onThrowable(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . twitter ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import org . atmosphere . handler . AbstractReflectorAtmosphereHandler ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . Servlet ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . servlet . http . HttpSession ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> public class TwitterAtmosphereHandler extends AbstractReflectorAtmosphereHandler { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( TwitterAtmosphereHandler . class ) ; </a> 0
<a> private int counter ; </a> 0
<a> private static final String BEGIN_SCRIPT_TAG = "<script type='text/javascript'>\n" ; </a> 0
<a> private static final String END_SCRIPT_TAG = "</script>\n" ; </a> 0
<a> private static final long serialVersionUID = - 2919167206889576860L ; </a> 0
<a> private String startingMessage = "<html><head><title>Twitter</title></head><body bgcolor=\"#FFFFFF\">" ; </a> 0
<a> private String endingMessage = "Twitter closed<br/>\n</body></html>" ; </a> 0
<a> public TwitterAtmosphereHandler ( ) { </a> 0
<a> } </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > atmoResource ) throws IOException { </a> 0
<a> HttpServletRequest request = atmoResource . getRequest ( ) ; </a> 0
<a> HttpServletResponse response = atmoResource . getResponse ( ) ; </a> 0
<a> String action = request . getParameter ( "action" ) ; </a> 0
<a> String sessionId = request . getSession ( ) . getId ( ) ; </a> 0
<a> HttpSession session = request . getSession ( ) ; </a> 0
<a> Broadcaster myBroadcasterFollower = ( Broadcaster ) session . getAttribute ( sessionId ) ; </a> 0
<a> if ( action != null ) { </a> 0
<a> if ( "login" . equals ( action ) ) { </a> 0
<a> response . setContentType ( "text/plain" ) ; </a> 0
<a> response . setCharacterEncoding ( "UTF-8" ) ; </a> 0
<a> String name = request . getParameter ( "name" ) ; </a> 0
<a> if ( name == null ) { </a> 0
<a> logger . error ( "Name cannot be null" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> session . setAttribute ( "name" , name ) ; </a> 0
<a> myBroadcasterFollower . broadcast ( BEGIN_SCRIPT_TAG </a> 0
<a> + toJsonp ( "Welcome back" , name ) </a> 0
<a> + END_SCRIPT_TAG ) ; </a> 0
<a> atmoResource . getAtmosphereConfig ( ) . getServletContext ( ) . setAttribute ( name , myBroadcasterFollower ) ; </a> 0
<a> } else if ( "post" . equals ( action ) ) { </a> 0
<a> String message = request . getParameter ( "message" ) ; </a> 0
<a> String callback = request . getParameter ( "callback" ) ; </a> 0
<a> if ( message == null ) { </a> 0
<a> logger . error ( "Message cannot be null" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( callback == null ) { </a> 0
<a> callback = "alert" ; </a> 0
<a> } </a> 0
<a> if ( myBroadcasterFollower != null ) { </a> 0
<a> myBroadcasterFollower . broadcast ( "<script id='comet_" + counter ++ + "'>" </a> 0
<a> + "window.parent." + callback + "(" + message + ");</script>" ) ; </a> 0
<a> } else { </a> 0
<a> throw new RuntimeException ( "Broadcaster was null" ) ; </a> 0
<a> } </a> 0
<a> response . getWriter ( ) . println ( "ok" ) ; </a> 0
<a> } else if ( "start" . equals ( action ) ) { </a> 0
<a> String message = "{ message : 'Welcome'}" ; </a> 0
<a> response . setContentType ( "text/html;charset=ISO-8859-1" ) ; </a> 0
<a> String callback = request . getParameter ( "callback" ) ; </a> 0
<a> if ( callback == null ) { </a> 0
<a> callback = "alert" ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> atmoResource . setBroadcaster ( BroadcasterFactory . getDefault ( ) . get ( ) ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> throw new IOException ( t ) ; </a> 0
<a> } </a> 0
<a> myBroadcasterFollower = atmoResource . getBroadcaster ( ) ; </a> 0
<a> atmoResource . suspend ( ) ; </a> 0
<a> session . setAttribute ( "atmoResource" , atmoResource ) ; </a> 0
<a> session . setAttribute ( sessionId , myBroadcasterFollower ) ; </a> 0
<a> response . getWriter ( ) . println ( "<script id='comet_" + counter ++ + "'>" </a> 0
<a> + "window.parent." + callback + "(" + message + ");</script>" ) ; </a> 0
<a> response . getWriter ( ) . println ( startingMessage ) ; </a> 0
<a> response . getWriter ( ) . flush ( ) ; </a> 0
<a> } else if ( "following" . equals ( action ) ) { </a> 0
<a> response . setContentType ( "text/html" ) ; </a> 0
<a> String follow = request . getParameter ( "message" ) ; </a> 0
<a> String name = ( String ) session . getAttribute ( "name" ) ; </a> 0
<a> if ( follow == null ) { </a> 0
<a> logger . error ( "Message cannot be null" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( name == null ) { </a> 0
<a> logger . error ( "Name cannot be null" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> Broadcaster outsiderBroadcaster </a> 0
<a> = ( Broadcaster ) atmoResource . getAtmosphereConfig ( ) . getServletContext ( ) . getAttribute ( follow ) ; </a> 0
<a> AtmosphereResource r = ( AtmosphereResource ) session . getAttribute ( "atmoResource" ) ; </a> 0
<a> if ( outsiderBroadcaster == null ) { </a> 0
<a> myBroadcasterFollower . broadcast ( BEGIN_SCRIPT_TAG </a> 0
<a> + toJsonp ( "Invalid Twitter user " , follow ) </a> 0
<a> + END_SCRIPT_TAG , r ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> outsiderBroadcaster . addAtmosphereResource ( r ) ; </a> 0
<a> myBroadcasterFollower . broadcast ( BEGIN_SCRIPT_TAG </a> 0
<a> + toJsonp ( "You are now following " , follow ) </a> 0
<a> + END_SCRIPT_TAG , r ) ; </a> 0
<a> outsiderBroadcaster . broadcast ( BEGIN_SCRIPT_TAG </a> 0
<a> + toJsonp ( name , " is now following " + follow ) </a> 0
<a> + END_SCRIPT_TAG ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> } </a> 0
<a> private String escape ( String orig ) { </a> 0
<a> StringBuilder buffer = new StringBuilder ( orig . length ( ) ) ; </a> 0
<a> for ( int i = 0 ; i < orig . length ( ) ; i ++ ) { </a> 0
<a> char c = orig . charAt ( i ) ; </a> 0
<a> switch ( c ) { </a> 0
<a> case '\b' : </a> 0
<a> buffer . append ( "\\b" ) ; </a> 0
<a> break ; </a> 0
<a> case '\f' : </a> 0
<a> buffer . append ( "\\f" ) ; </a> 0
<a> break ; </a> 0
<a> case '\n' : </a> 0
<a> buffer . append ( "<br />" ) ; </a> 0
<a> break ; </a> 0
<a> case '\r' : </a> 0
<a> break ; </a> 0
<a> case '\t' : </a> 0
<a> buffer . append ( "\\t" ) ; </a> 0
<a> break ; </a> 0
<a> case '\'' : </a> 0
<a> buffer . append ( "\\'" ) ; </a> 0
<a> break ; </a> 0
<a> case '\"' : </a> 0
<a> buffer . append ( "\\\"" ) ; </a> 0
<a> break ; </a> 0
<a> case '\\' : </a> 0
<a> buffer . append ( "\\\\" ) ; </a> 0
<a> break ; </a> 0
<a> case '<' : </a> 0
<a> buffer . append ( "&lt;" ) ; </a> 0
<a> break ; </a> 0
<a> case '>' : </a> 0
<a> buffer . append ( "&gt;" ) ; </a> 0
<a> break ; </a> 0
<a> case '&' : </a> 0
<a> buffer . append ( "&amp;" ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> buffer . append ( c ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return buffer . toString ( ) ; </a> 0
<a> } </a> 0
<a> private String toJsonp ( String name , String message ) { </a> 0
<a> return "window.parent.app.update({ name: \"" </a> 0
<a> + escape ( name ) + "\", message: \"" + escape ( message ) + "\" });\n" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . wicket ; </a> 0
<a> import org . apache . wicket . protocol . http . WebApplication ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import java . util . Date ; </a> 0
<a> public class WicketPushApplication extends WebApplication { </a> 0
<a> public Class < HomePage > getHomePage ( ) { </a> 0
<a> return HomePage . class ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> public class FacebookAuthorizationException extends FacebookException { </a> 0
<a> static final long serialVersionUID = 1 ; </a> 0
<a> public FacebookAuthorizationException ( ) { </a> 0
<a> super ( ) ; </a> 0
<a> } </a> 0
<a> public FacebookAuthorizationException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public FacebookAuthorizationException ( String message , Throwable throwable ) { </a> 0
<a> super ( message , throwable ) ; </a> 0
<a> } </a> 0
<a> public FacebookAuthorizationException ( Throwable throwable ) { </a> 0
<a> super ( throwable ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> public class FacebookServiceException extends FacebookException { </a> 0
<a> private final FacebookRequestError error ; </a> 0
<a> private static final long serialVersionUID = 1 ; </a> 0
<a> public FacebookServiceException ( FacebookRequestError error , String errorMessage ) { </a> 0
<a> super ( errorMessage ) ; </a> 0
<a> this . error = error ; </a> 0
<a> } </a> 0
<a> public final FacebookRequestError getRequestError ( ) { </a> 0
<a> return error ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final String toString ( ) { </a> 0
<a> return new StringBuilder ( ) </a> 0
<a> . append ( "{FacebookServiceException: " ) </a> 0
<a> . append ( "httpResponseCode: " ) </a> 0
<a> . append ( error . getRequestStatusCode ( ) ) </a> 0
<a> . append ( ", facebookErrorCode: " ) </a> 0
<a> . append ( error . getErrorCode ( ) ) </a> 0
<a> . append ( ", facebookErrorType: " ) </a> 0
<a> . append ( error . getErrorType ( ) ) </a> 0
<a> . append ( ", message: " ) </a> 0
<a> . append ( error . getErrorMessage ( ) ) </a> 0
<a> . append ( "}" ) </a> 0
<a> . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> public enum SessionDefaultAudience { </a> 0
<a> NONE ( null ) , </a> 0
<a> ONLY_ME ( NativeProtocol . AUDIENCE_ME ) , </a> 0
<a> FRIENDS ( NativeProtocol . AUDIENCE_FRIENDS ) , </a> 0
<a> EVERYONE ( NativeProtocol . AUDIENCE_EVERYONE ) ; </a> 0
<a> private final String nativeProtocolAudience ; </a> 0
<a> private SessionDefaultAudience ( String protocol ) { </a> 0
<a> nativeProtocolAudience = protocol ; </a> 0
<a> } </a> 0
<a> String getNativeProtocolAudience ( ) { </a> 0
<a> return nativeProtocolAudience ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import com . facebook . model . GraphObjectList ; </a> 0
<a> import com . facebook . internal . Logger ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import com . facebook . internal . Validate ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . util . * ; </a> 0
<a> public class TestSession extends Session { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> private enum Mode { </a> 0
<a> PRIVATE , SHARED </a> 0
<a> } </a> 0
<a> private static final String LOG_TAG = Logger . LOG_TAG_BASE + "TestSession" ; </a> 0
<a> private static Map < String , TestAccount > appTestAccounts ; </a> 0
<a> private static String testApplicationSecret ; </a> 0
<a> private static String testApplicationId ; </a> 0
<a> private final String sessionUniqueUserTag ; </a> 0
<a> private final List < String > requestedPermissions ; </a> 0
<a> private final Mode mode ; </a> 0
<a> private String testAccountId ; </a> 0
<a> private boolean wasAskedToExtendAccessToken ; </a> 0
<a> TestSession ( Activity activity , List < String > permissions , TokenCachingStrategy tokenCachingStrategy , </a> 0
<a> String sessionUniqueUserTag , Mode mode ) { </a> 0
<a> super ( activity , TestSession . testApplicationId , tokenCachingStrategy ) ; </a> 0
<a> Validate . notNull ( permissions , "permissions" ) ; </a> 0
<a> Validate . notNullOrEmpty ( testApplicationId , "testApplicationId" ) ; </a> 0
<a> Validate . notNullOrEmpty ( testApplicationSecret , "testApplicationSecret" ) ; </a> 0
<a> this . sessionUniqueUserTag = sessionUniqueUserTag ; </a> 0
<a> this . mode = mode ; </a> 0
<a> this . requestedPermissions = permissions ; </a> 0
<a> } </a> 0
<a> public static TestSession createSessionWithPrivateUser ( Activity activity , List < String > permissions ) { </a> 0
<a> return createTestSession ( activity , permissions , Mode . PRIVATE , null ) ; </a> 0
<a> } </a> 0
<a> public static TestSession createSessionWithSharedUser ( Activity activity , List < String > permissions ) { </a> 0
<a> return createSessionWithSharedUser ( activity , permissions , null ) ; </a> 0
<a> } </a> 0
<a> public static TestSession createSessionWithSharedUser ( Activity activity , List < String > permissions , </a> 0
<a> String sessionUniqueUserTag ) { </a> 0
<a> return createTestSession ( activity , permissions , Mode . SHARED , sessionUniqueUserTag ) ; </a> 0
<a> } </a> 0
<a> public static synchronized String getTestApplicationId ( ) { </a> 0
<a> return testApplicationId ; </a> 0
<a> } </a> 0
<a> public static synchronized void setTestApplicationId ( String applicationId ) { </a> 0
<a> if ( testApplicationId != null && ! testApplicationId . equals ( applicationId ) ) { </a> 0
<a> throw new FacebookException ( "Can't have more than one test application ID" ) ; </a> 0
<a> } </a> 0
<a> testApplicationId = applicationId ; </a> 0
<a> } </a> 0
<a> public static synchronized String getTestApplicationSecret ( ) { </a> 0
<a> return testApplicationSecret ; </a> 0
<a> } </a> 0
<a> public static synchronized void setTestApplicationSecret ( String applicationSecret ) { </a> 0
<a> if ( testApplicationSecret != null && ! testApplicationSecret . equals ( applicationSecret ) ) { </a> 0
<a> throw new FacebookException ( "Can't have more than one test application secret" ) ; </a> 0
<a> } </a> 0
<a> testApplicationSecret = applicationSecret ; </a> 0
<a> } </a> 0
<a> public final String getTestUserId ( ) { </a> 0
<a> return testAccountId ; </a> 0
<a> } </a> 0
<a> private static synchronized TestSession createTestSession ( Activity activity , List < String > permissions , Mode mode , </a> 0
<a> String sessionUniqueUserTag ) { </a> 0
<a> if ( Utility . isNullOrEmpty ( testApplicationId ) || Utility . isNullOrEmpty ( testApplicationSecret ) ) { </a> 0
<a> throw new FacebookException ( "Must provide app ID and secret" ) ; </a> 0
<a> } </a> 0
<a> if ( Utility . isNullOrEmpty ( permissions ) ) { </a> 0
<a> permissions = Arrays . asList ( "email" , "publish_actions" ) ; </a> 0
<a> } </a> 0
<a> return new TestSession ( activity , permissions , new TestTokenCachingStrategy ( ) , sessionUniqueUserTag , </a> 0
<a> mode ) ; </a> 0
<a> } </a> 0
<a> private static synchronized void retrieveTestAccountsForAppIfNeeded ( ) { </a> 0
<a> if ( appTestAccounts != null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> appTestAccounts = new HashMap < String , TestAccount > ( ) ; </a> 0
<a> String testAccountQuery = String . format ( "SELECT id,access_token FROM test_account WHERE app_id = %s" , </a> 0
<a> testApplicationId ) ; </a> 0
<a> String userQuery = "SELECT uid,name FROM user WHERE uid IN (SELECT id FROM #test_accounts)" ; </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> JSONObject multiquery ; </a> 0
<a> try { </a> 0
<a> multiquery = new JSONObject ( ) ; </a> 0
<a> multiquery . put ( "test_accounts" , testAccountQuery ) ; </a> 0
<a> multiquery . put ( "users" , userQuery ) ; </a> 0
<a> } catch ( JSONException exception ) { </a> 0
<a> throw new FacebookException ( exception ) ; </a> 0
<a> } </a> 0
<a> parameters . putString ( "q" , multiquery . toString ( ) ) ; </a> 0
<a> parameters . putString ( "access_token" , getAppAccessToken ( ) ) ; </a> 0
<a> Request request = new Request ( null , "fql" , parameters , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> if ( response . getError ( ) != null ) { </a> 0
<a> throw response . getError ( ) . getException ( ) ; </a> 0
<a> } </a> 0
<a> FqlResponse fqlResponse = response . getGraphObjectAs ( FqlResponse . class ) ; </a> 0
<a> GraphObjectList < FqlResult > fqlResults = fqlResponse . getData ( ) ; </a> 0
<a> if ( fqlResults == null || fqlResults . size ( ) != 2 ) { </a> 0
<a> throw new FacebookException ( "Unexpected number of results from FQL query" ) ; </a> 0
<a> } </a> 0
<a> Collection < TestAccount > testAccounts = fqlResults . get ( 0 ) . getFqlResultSet ( ) . castToListOf ( TestAccount . class ) ; </a> 0
<a> Collection < UserAccount > userAccounts = fqlResults . get ( 1 ) . getFqlResultSet ( ) . castToListOf ( UserAccount . class ) ; </a> 0
<a> populateTestAccounts ( testAccounts , userAccounts ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> private static synchronized void populateTestAccounts ( Collection < TestAccount > testAccounts , </a> 0
<a> Collection < UserAccount > userAccounts ) { </a> 0
<a> for ( TestAccount testAccount : testAccounts ) { </a> 0
<a> storeTestAccount ( testAccount ) ; </a> 0
<a> } </a> 0
<a> for ( UserAccount userAccount : userAccounts ) { </a> 0
<a> TestAccount testAccount = appTestAccounts . get ( userAccount . getUid ( ) ) ; </a> 0
<a> if ( testAccount != null ) { </a> 0
<a> testAccount . setName ( userAccount . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static synchronized void storeTestAccount ( TestAccount testAccount ) { </a> 0
<a> appTestAccounts . put ( testAccount . getId ( ) , testAccount ) ; </a> 0
<a> } </a> 0
<a> private static synchronized TestAccount findTestAccountMatchingIdentifier ( String identifier ) { </a> 0
<a> retrieveTestAccountsForAppIfNeeded ( ) ; </a> 0
<a> for ( TestAccount testAccount : appTestAccounts . values ( ) ) { </a> 0
<a> if ( testAccount . getName ( ) . contains ( identifier ) ) { </a> 0
<a> return testAccount ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final String toString ( ) { </a> 0
<a> String superString = super . toString ( ) ; </a> 0
<a> return new StringBuilder ( ) . append ( "{TestSession" ) . append ( " testUserId:" ) . append ( testAccountId ) </a> 0
<a> . append ( " " ) . append ( superString ) . append ( "}" ) . toString ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void authorize ( AuthorizationRequest request ) { </a> 0
<a> if ( mode == Mode . PRIVATE ) { </a> 0
<a> createTestAccountAndFinishAuth ( ) ; </a> 0
<a> } else { </a> 0
<a> findOrCreateSharedTestAccount ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void postStateChange ( final SessionState oldState , final SessionState newState , final Exception error ) { </a> 0
<a> String id = testAccountId ; </a> 0
<a> super . postStateChange ( oldState , newState , error ) ; </a> 0
<a> if ( newState . isClosed ( ) && id != null && mode == Mode . PRIVATE ) { </a> 0
<a> deleteTestAccount ( id , getAppAccessToken ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean getWasAskedToExtendAccessToken ( ) { </a> 0
<a> return wasAskedToExtendAccessToken ; </a> 0
<a> } </a> 0
<a> void forceExtendAccessToken ( boolean forceExtendAccessToken ) { </a> 0
<a> AccessToken currentToken = getTokenInfo ( ) ; </a> 0
<a> setTokenInfo ( </a> 0
<a> new AccessToken ( currentToken . getToken ( ) , new Date ( ) , currentToken . getPermissions ( ) , </a> 0
<a> AccessTokenSource . TEST_USER , new Date ( 0 ) ) ) ; </a> 0
<a> setLastAttemptedTokenExtendDate ( new Date ( 0 ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> boolean shouldExtendAccessToken ( ) { </a> 0
<a> boolean result = super . shouldExtendAccessToken ( ) ; </a> 0
<a> wasAskedToExtendAccessToken = false ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void extendAccessToken ( ) { </a> 0
<a> wasAskedToExtendAccessToken = true ; </a> 0
<a> super . extendAccessToken ( ) ; </a> 0
<a> } </a> 0
<a> void fakeTokenRefreshAttempt ( ) { </a> 0
<a> setCurrentTokenRefreshRequest ( new TokenRefreshRequest ( ) ) ; </a> 0
<a> } </a> 0
<a> static final String getAppAccessToken ( ) { </a> 0
<a> return testApplicationId + "|" + testApplicationSecret ; </a> 0
<a> } </a> 0
<a> private void findOrCreateSharedTestAccount ( ) { </a> 0
<a> TestAccount testAccount = findTestAccountMatchingIdentifier ( getSharedTestAccountIdentifier ( ) ) ; </a> 0
<a> if ( testAccount != null ) { </a> 0
<a> finishAuthWithTestAccount ( testAccount ) ; </a> 0
<a> } else { </a> 0
<a> createTestAccountAndFinishAuth ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void finishAuthWithTestAccount ( TestAccount testAccount ) { </a> 0
<a> testAccountId = testAccount . getId ( ) ; </a> 0
<a> AccessToken accessToken = AccessToken . createFromString ( testAccount . getAccessToken ( ) , requestedPermissions , </a> 0
<a> AccessTokenSource . TEST_USER ) ; </a> 0
<a> finishAuthOrReauth ( accessToken , null ) ; </a> 0
<a> } </a> 0
<a> private TestAccount createTestAccountAndFinishAuth ( ) { </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> parameters . putString ( "installed" , "true" ) ; </a> 0
<a> parameters . putString ( "permissions" , getPermissionsString ( ) ) ; </a> 0
<a> parameters . putString ( "access_token" , getAppAccessToken ( ) ) ; </a> 0
<a> if ( mode == Mode . SHARED ) { </a> 0
<a> parameters . putString ( "name" , String . format ( "Shared %s Testuser" , getSharedTestAccountIdentifier ( ) ) ) ; </a> 0
<a> } </a> 0
<a> String graphPath = String . format ( "%s/accounts/test-users" , testApplicationId ) ; </a> 0
<a> Request createUserRequest = new Request ( null , graphPath , parameters , HttpMethod . POST ) ; </a> 0
<a> Response response = createUserRequest . executeAndWait ( ) ; </a> 0
<a> FacebookRequestError error = response . getError ( ) ; </a> 0
<a> TestAccount testAccount = response . getGraphObjectAs ( TestAccount . class ) ; </a> 0
<a> if ( error != null ) { </a> 0
<a> finishAuthOrReauth ( null , error . getException ( ) ) ; </a> 0
<a> return null ; </a> 0
<a> } else { </a> 0
<a> assert testAccount != null ; </a> 0
<a> if ( mode == Mode . SHARED ) { </a> 0
<a> testAccount . setName ( parameters . getString ( "name" ) ) ; </a> 0
<a> storeTestAccount ( testAccount ) ; </a> 0
<a> } </a> 0
<a> finishAuthWithTestAccount ( testAccount ) ; </a> 0
<a> return testAccount ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void deleteTestAccount ( String testAccountId , String appAccessToken ) { </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> parameters . putString ( "access_token" , appAccessToken ) ; </a> 0
<a> Request request = new Request ( null , testAccountId , parameters , HttpMethod . DELETE ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> FacebookRequestError error = response . getError ( ) ; </a> 0
<a> GraphObject graphObject = response . getGraphObject ( ) ; </a> 0
<a> if ( error != null ) { </a> 0
<a> Log . w ( LOG_TAG , String . format ( "Could not delete test account %s: %s" , testAccountId , error . getException ( ) . toString ( ) ) ) ; </a> 0
<a> } else if ( graphObject . getProperty ( Response . NON_JSON_RESPONSE_PROPERTY ) == ( Boolean ) false ) { </a> 0
<a> Log . w ( LOG_TAG , String . format ( "Could not delete test account %s: unknown reason" , testAccountId ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private String getPermissionsString ( ) { </a> 0
<a> return TextUtils . join ( "," , requestedPermissions ) ; </a> 0
<a> } </a> 0
<a> private String getSharedTestAccountIdentifier ( ) { </a> 0
<a> long permissionsHash = getPermissionsString ( ) . hashCode ( ) & 0xffffffffL ; </a> 0
<a> long sessionTagHash = ( sessionUniqueUserTag != null ) ? sessionUniqueUserTag . hashCode ( ) & 0xffffffffL : 0 ; </a> 0
<a> long combinedHash = permissionsHash ^ sessionTagHash ; </a> 0
<a> return validNameStringFromInteger ( combinedHash ) ; </a> 0
<a> } </a> 0
<a> private String validNameStringFromInteger ( long i ) { </a> 0
<a> String s = Long . toString ( i ) ; </a> 0
<a> StringBuilder result = new StringBuilder ( "Perm" ) ; </a> 0
<a> char lastChar = 0 ; </a> 0
<a> for ( char c : s . toCharArray ( ) ) { </a> 0
<a> if ( c == lastChar ) { </a> 0
<a> c += 10 ; </a> 0
<a> } </a> 0
<a> result . append ( ( char ) ( c + 'a' - '0' ) ) ; </a> 0
<a> lastChar = c ; </a> 0
<a> } </a> 0
<a> return result . toString ( ) ; </a> 0
<a> } </a> 0
<a> private interface TestAccount extends GraphObject { </a> 0
<a> String getId ( ) ; </a> 0
<a> String getAccessToken ( ) ; </a> 0
<a> String getName ( ) ; </a> 0
<a> void setName ( String name ) ; </a> 0
<a> } </a> 0
<a> private interface UserAccount extends GraphObject { </a> 0
<a> String getUid ( ) ; </a> 0
<a> String getName ( ) ; </a> 0
<a> void setName ( String name ) ; </a> 0
<a> } </a> 0
<a> private interface FqlResult extends GraphObject { </a> 0
<a> GraphObjectList < GraphObject > getFqlResultSet ( ) ; </a> 0
<a> } </a> 0
<a> private interface FqlResponse extends GraphObject { </a> 0
<a> GraphObjectList < FqlResult > getData ( ) ; </a> 0
<a> } </a> 0
<a> private static final class TestTokenCachingStrategy extends TokenCachingStrategy { </a> 0
<a> private Bundle bundle ; </a> 0
<a> @ Override </a> 0
<a> public Bundle load ( ) { </a> 0
<a> return bundle ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void save ( Bundle value ) { </a> 0
<a> bundle = value ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clear ( ) { </a> 0
<a> bundle = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import java . io . FileNotFoundException ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> @ Deprecated </a> 0
<a> public class AsyncFacebookRunner { </a> 0
<a> Facebook fb ; </a> 0
<a> public AsyncFacebookRunner ( Facebook fb ) { </a> 0
<a> this . fb = fb ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void logout ( final Context context , </a> 0
<a> final RequestListener listener , </a> 0
<a> final Object state ) { </a> 0
<a> new Thread ( ) { </a> 0
<a> @ Override public void run ( ) { </a> 0
<a> try { </a> 0
<a> String response = fb . logoutImpl ( context ) ; </a> 0
<a> if ( response . length ( ) == 0 || response . equals ( "false" ) ) { </a> 0
<a> listener . onFacebookError ( new FacebookError ( </a> 0
<a> "auth.expireSession failed" ) , state ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> listener . onComplete ( response , state ) ; </a> 0
<a> } catch ( FileNotFoundException e ) { </a> 0
<a> listener . onFileNotFoundException ( e , state ) ; </a> 0
<a> } catch ( MalformedURLException e ) { </a> 0
<a> listener . onMalformedURLException ( e , state ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> listener . onIOException ( e , state ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } . start ( ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void logout ( final Context context , final RequestListener listener ) { </a> 0
<a> logout ( context , listener , null ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void request ( Bundle parameters , </a> 0
<a> RequestListener listener , </a> 0
<a> final Object state ) { </a> 0
<a> request ( null , parameters , "GET" , listener , state ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void request ( Bundle parameters , RequestListener listener ) { </a> 0
<a> request ( null , parameters , "GET" , listener , null ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void request ( String graphPath , </a> 0
<a> RequestListener listener , </a> 0
<a> final Object state ) { </a> 0
<a> request ( graphPath , new Bundle ( ) , "GET" , listener , state ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void request ( String graphPath , RequestListener listener ) { </a> 0
<a> request ( graphPath , new Bundle ( ) , "GET" , listener , null ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void request ( String graphPath , </a> 0
<a> Bundle parameters , </a> 0
<a> RequestListener listener , </a> 0
<a> final Object state ) { </a> 0
<a> request ( graphPath , parameters , "GET" , listener , state ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void request ( String graphPath , </a> 0
<a> Bundle parameters , </a> 0
<a> RequestListener listener ) { </a> 0
<a> request ( graphPath , parameters , "GET" , listener , null ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void request ( final String graphPath , </a> 0
<a> final Bundle parameters , </a> 0
<a> final String httpMethod , </a> 0
<a> final RequestListener listener , </a> 0
<a> final Object state ) { </a> 0
<a> new Thread ( ) { </a> 0
<a> @ Override public void run ( ) { </a> 0
<a> try { </a> 0
<a> String resp = fb . requestImpl ( graphPath , parameters , httpMethod ) ; </a> 0
<a> listener . onComplete ( resp , state ) ; </a> 0
<a> } catch ( FileNotFoundException e ) { </a> 0
<a> listener . onFileNotFoundException ( e , state ) ; </a> 0
<a> } catch ( MalformedURLException e ) { </a> 0
<a> listener . onMalformedURLException ( e , state ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> listener . onIOException ( e , state ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } . start ( ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static interface RequestListener { </a> 0
<a> public void onComplete ( String response , Object state ) ; </a> 0
<a> public void onIOException ( IOException e , Object state ) ; </a> 0
<a> public void onFileNotFoundException ( FileNotFoundException e , </a> 0
<a> Object state ) ; </a> 0
<a> public void onMalformedURLException ( MalformedURLException e , </a> 0
<a> Object state ) ; </a> 0
<a> public void onFacebookError ( FacebookError e , Object state ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . internal ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import com . facebook . LoggingBehavior ; </a> 0
<a> import com . facebook . Settings ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class Logger { </a> 0
<a> public static final String LOG_TAG_BASE = "FacebookSDK." ; </a> 0
<a> private static final HashMap < String , String > stringsToReplace = new HashMap < String , String > ( ) ; </a> 0
<a> private final LoggingBehavior behavior ; </a> 0
<a> private final String tag ; </a> 0
<a> private StringBuilder contents ; </a> 0
<a> private int priority = Log . DEBUG ; </a> 0
<a> public synchronized static void registerStringToReplace ( String original , String replace ) { </a> 0
<a> stringsToReplace . put ( original , replace ) ; </a> 0
<a> } </a> 0
<a> public synchronized static void registerAccessToken ( String accessToken ) { </a> 0
<a> if ( Settings . isLoggingBehaviorEnabled ( LoggingBehavior . INCLUDE_ACCESS_TOKENS ) == false ) { </a> 0
<a> registerStringToReplace ( accessToken , "ACCESS_TOKEN_REMOVED" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void log ( LoggingBehavior behavior , String tag , String string ) { </a> 0
<a> log ( behavior , Log . DEBUG , tag , string ) ; </a> 0
<a> } </a> 0
<a> public static void log ( LoggingBehavior behavior , String tag , String format , Object ... args ) { </a> 0
<a> if ( Settings . isLoggingBehaviorEnabled ( behavior ) ) { </a> 0
<a> String string = String . format ( format , args ) ; </a> 0
<a> log ( behavior , Log . DEBUG , tag , string ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void log ( LoggingBehavior behavior , int priority , String tag , String string ) { </a> 0
<a> if ( Settings . isLoggingBehaviorEnabled ( behavior ) ) { </a> 0
<a> string = replaceStrings ( string ) ; </a> 0
<a> if ( tag . startsWith ( LOG_TAG_BASE ) == false ) { </a> 0
<a> tag = LOG_TAG_BASE + tag ; </a> 0
<a> } </a> 0
<a> Log . println ( priority , tag , string ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private synchronized static String replaceStrings ( String string ) { </a> 0
<a> for ( Map . Entry < String , String > entry : stringsToReplace . entrySet ( ) ) { </a> 0
<a> string = string . replace ( entry . getKey ( ) , entry . getValue ( ) ) ; </a> 0
<a> } </a> 0
<a> return string ; </a> 0
<a> } </a> 0
<a> public Logger ( LoggingBehavior behavior , String tag ) { </a> 0
<a> Validate . notNullOrEmpty ( tag , "tag" ) ; </a> 0
<a> this . behavior = behavior ; </a> 0
<a> this . tag = LOG_TAG_BASE + tag ; </a> 0
<a> this . contents = new StringBuilder ( ) ; </a> 0
<a> } </a> 0
<a> public int getPriority ( ) { </a> 0
<a> return priority ; </a> 0
<a> } </a> 0
<a> public void setPriority ( int value ) { </a> 0
<a> Validate . oneOf ( value , "value" , Log . ASSERT , Log . DEBUG , Log . ERROR , Log . INFO , Log . VERBOSE , Log . WARN ) ; </a> 0
<a> priority = value ; </a> 0
<a> } </a> 0
<a> public String getContents ( ) { </a> 0
<a> return replaceStrings ( contents . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> public void log ( ) { </a> 0
<a> logString ( contents . toString ( ) ) ; </a> 0
<a> contents = new StringBuilder ( ) ; </a> 0
<a> } </a> 0
<a> public void logString ( String string ) { </a> 0
<a> log ( behavior , priority , tag , string ) ; </a> 0
<a> } </a> 0
<a> public void append ( StringBuilder stringBuilder ) { </a> 0
<a> if ( shouldLog ( ) ) { </a> 0
<a> contents . append ( stringBuilder ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void append ( String string ) { </a> 0
<a> if ( shouldLog ( ) ) { </a> 0
<a> contents . append ( string ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void append ( String format , Object ... args ) { </a> 0
<a> if ( shouldLog ( ) ) { </a> 0
<a> contents . append ( String . format ( format , args ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void appendKeyValue ( String key , Object value ) { </a> 0
<a> append ( " %s:\t%s\n" , key , value ) ; </a> 0
<a> } </a> 0
<a> private boolean shouldLog ( ) { </a> 0
<a> return Settings . isLoggingBehaviorEnabled ( behavior ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . internal ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . pm . ApplicationInfo ; </a> 0
<a> import android . content . pm . PackageManager ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Parcelable ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import android . webkit . CookieManager ; </a> 0
<a> import android . webkit . CookieSyncManager ; </a> 0
<a> import com . facebook . FacebookException ; </a> 1
<a> import com . facebook . Session ; </a> 1
<a> import com . facebook . android . BuildConfig ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import org . json . JSONTokener ; </a> 0
<a> import java . io . * ; </a> 0
<a> import java . net . HttpURLConnection ; </a> 0
<a> import java . net . URLConnection ; </a> 0
<a> import java . security . MessageDigest ; </a> 0
<a> import java . security . NoSuchAlgorithmException ; </a> 0
<a> import java . util . * ; </a> 0
<a> public final class Utility { </a> 0
<a> static final String LOG_TAG = "FacebookSDK" ; </a> 0
<a> private static final String HASH_ALGORITHM_MD5 = "MD5" ; </a> 0
<a> private static final String URL_SCHEME = "https" ; </a> 0
<a> public static final int DEFAULT_STREAM_BUFFER_SIZE = 8192 ; </a> 0
<a> public static < T > boolean isSubset ( Collection < T > subset , Collection < T > superset ) { </a> 0
<a> if ( ( superset == null ) || ( superset . size ( ) == 0 ) ) { </a> 0
<a> return ( ( subset == null ) || ( subset . size ( ) == 0 ) ) ; </a> 0
<a> } </a> 0
<a> HashSet < T > hash = new HashSet < T > ( superset ) ; </a> 0
<a> for ( T t : subset ) { </a> 0
<a> if ( ! hash . contains ( t ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public static < T > boolean isNullOrEmpty ( Collection < T > c ) { </a> 0
<a> return ( c == null ) || ( c . size ( ) == 0 ) ; </a> 0
<a> } </a> 0
<a> public static boolean isNullOrEmpty ( String s ) { </a> 0
<a> return ( s == null ) || ( s . length ( ) == 0 ) ; </a> 0
<a> } </a> 0
<a> public static < T > Collection < T > unmodifiableCollection ( T ... ts ) { </a> 0
<a> return Collections . unmodifiableCollection ( Arrays . asList ( ts ) ) ; </a> 0
<a> } </a> 0
<a> public static < T > ArrayList < T > arrayList ( T ... ts ) { </a> 0
<a> ArrayList < T > arrayList = new ArrayList < T > ( ts . length ) ; </a> 0
<a> for ( T t : ts ) { </a> 0
<a> arrayList . add ( t ) ; </a> 0
<a> } </a> 0
<a> return arrayList ; </a> 0
<a> } </a> 0
<a> static String md5hash ( String key ) { </a> 0
<a> MessageDigest hash = null ; </a> 0
<a> try { </a> 0
<a> hash = MessageDigest . getInstance ( HASH_ALGORITHM_MD5 ) ; </a> 1
<a> } catch ( NoSuchAlgorithmException e ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> hash . update ( key . getBytes ( ) ) ; </a> 0
<a> byte [ ] digest = hash . digest ( ) ; </a> 0
<a> StringBuilder builder = new StringBuilder ( ) ; </a> 0
<a> for ( int b : digest ) { </a> 0
<a> builder . append ( Integer . toHexString ( ( b > > 4 ) & 0xf ) ) ; </a> 0
<a> builder . append ( Integer . toHexString ( ( b > > 0 ) & 0xf ) ) ; </a> 0
<a> } </a> 0
<a> return builder . toString ( ) ; </a> 0
<a> } </a> 0
<a> public static Uri buildUri ( String authority , String path , Bundle parameters ) { </a> 0
<a> Uri . Builder builder = new Uri . Builder ( ) ; </a> 0
<a> builder . scheme ( URL_SCHEME ) ; </a> 0
<a> builder . authority ( authority ) ; </a> 0
<a> builder . path ( path ) ; </a> 0
<a> for ( String key : parameters . keySet ( ) ) { </a> 0
<a> Object parameter = parameters . get ( key ) ; </a> 0
<a> if ( parameter instanceof String ) { </a> 0
<a> builder . appendQueryParameter ( key , ( String ) parameter ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return builder . build ( ) ; </a> 0
<a> } </a> 0
<a> public static void putObjectInBundle ( Bundle bundle , String key , Object value ) { </a> 0
<a> if ( value instanceof String ) { </a> 0
<a> bundle . putString ( key , ( String ) value ) ; </a> 0
<a> } else if ( value instanceof Parcelable ) { </a> 0
<a> bundle . putParcelable ( key , ( Parcelable ) value ) ; </a> 0
<a> } else if ( value instanceof byte [ ] ) { </a> 0
<a> bundle . putByteArray ( key , ( byte [ ] ) value ) ; </a> 0
<a> } else { </a> 0
<a> throw new FacebookException ( "attempted to add unsupported type to Bundle" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void closeQuietly ( Closeable closeable ) { </a> 0
<a> try { </a> 0
<a> if ( closeable != null ) { </a> 0
<a> closeable . close ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( IOException ioe ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void disconnectQuietly ( URLConnection connection ) { </a> 0
<a> if ( connection instanceof HttpURLConnection ) { </a> 0
<a> ( ( HttpURLConnection ) connection ) . disconnect ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static String getMetadataApplicationId ( Context context ) { </a> 0
<a> try { </a> 0
<a> ApplicationInfo ai = context . getPackageManager ( ) . getApplicationInfo ( </a> 0
<a> context . getPackageName ( ) , PackageManager . GET_META_DATA ) ; </a> 0
<a> if ( ai . metaData != null ) { </a> 0
<a> return ai . metaData . getString ( Session . APPLICATION_ID_PROPERTY ) ; </a> 0
<a> } </a> 0
<a> } catch ( PackageManager . NameNotFoundException e ) { </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> static Map < String , Object > convertJSONObjectToHashMap ( JSONObject jsonObject ) { </a> 0
<a> HashMap < String , Object > map = new HashMap < String , Object > ( ) ; </a> 0
<a> JSONArray keys = jsonObject . names ( ) ; </a> 0
<a> for ( int i = 0 ; i < keys . length ( ) ; ++ i ) { </a> 0
<a> String key ; </a> 0
<a> try { </a> 0
<a> key = keys . getString ( i ) ; </a> 0
<a> Object value = jsonObject . get ( key ) ; </a> 0
<a> if ( value instanceof JSONObject ) { </a> 0
<a> value = convertJSONObjectToHashMap ( ( JSONObject ) value ) ; </a> 0
<a> } </a> 0
<a> map . put ( key , value ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return map ; </a> 0
<a> } </a> 0
<a> public static Object getStringPropertyAsJSON ( JSONObject jsonObject , String key , String nonJSONPropertyKey ) </a> 0
<a> throws JSONException { </a> 0
<a> Object value = jsonObject . opt ( key ) ; </a> 0
<a> if ( value != null && value instanceof String ) { </a> 0
<a> JSONTokener tokener = new JSONTokener ( ( String ) value ) ; </a> 0
<a> value = tokener . nextValue ( ) ; </a> 0
<a> } </a> 0
<a> if ( value != null && ! ( value instanceof JSONObject || value instanceof JSONArray ) ) { </a> 0
<a> if ( nonJSONPropertyKey != null ) { </a> 0
<a> jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . putOpt ( nonJSONPropertyKey , value ) ; </a> 0
<a> return jsonObject ; </a> 0
<a> } else { </a> 0
<a> throw new FacebookException ( "Got an unexpected non-JSON object." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return value ; </a> 0
<a> } </a> 0
<a> public static String readStreamToString ( InputStream inputStream ) throws IOException { </a> 0
<a> BufferedInputStream bufferedInputStream = null ; </a> 0
<a> InputStreamReader reader = null ; </a> 0
<a> try { </a> 0
<a> bufferedInputStream = new BufferedInputStream ( inputStream ) ; </a> 0
<a> reader = new InputStreamReader ( bufferedInputStream ) ; </a> 0
<a> StringBuilder stringBuilder = new StringBuilder ( ) ; </a> 0
<a> final int bufferSize = 1024 * 2 ; </a> 0
<a> char [ ] buffer = new char [ bufferSize ] ; </a> 0
<a> int n = 0 ; </a> 0
<a> while ( ( n = reader . read ( buffer ) ) != - 1 ) { </a> 0
<a> stringBuilder . append ( buffer , 0 , n ) ; </a> 0
<a> } </a> 0
<a> return stringBuilder . toString ( ) ; </a> 0
<a> } finally { </a> 0
<a> closeQuietly ( bufferedInputStream ) ; </a> 0
<a> closeQuietly ( reader ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static boolean stringsEqualOrEmpty ( String a , String b ) { </a> 0
<a> boolean aEmpty = TextUtils . isEmpty ( a ) ; </a> 0
<a> boolean bEmpty = TextUtils . isEmpty ( b ) ; </a> 0
<a> if ( aEmpty && bEmpty ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( ! aEmpty && ! bEmpty ) { </a> 0
<a> return a . equals ( b ) ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private static void clearCookiesForDomain ( Context context , String domain ) { </a> 0
<a> CookieSyncManager syncManager = CookieSyncManager . createInstance ( context ) ; </a> 0
<a> syncManager . sync ( ) ; </a> 0
<a> CookieManager cookieManager = CookieManager . getInstance ( ) ; </a> 0
<a> String cookies = cookieManager . getCookie ( domain ) ; </a> 0
<a> if ( cookies == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> String [ ] splitCookies = cookies . split ( ";" ) ; </a> 0
<a> for ( String cookie : splitCookies ) { </a> 0
<a> String [ ] cookieParts = cookie . split ( "=" ) ; </a> 0
<a> if ( cookieParts . length > 0 ) { </a> 0
<a> String newCookie = cookieParts [ 0 ] . trim ( ) + "=;expires=Sat, 1 Jan 2000 00:00:01 UTC;" ; </a> 0
<a> cookieManager . setCookie ( domain , newCookie ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> cookieManager . removeExpiredCookie ( ) ; </a> 0
<a> } </a> 0
<a> public static void clearFacebookCookies ( Context context ) { </a> 0
<a> clearCookiesForDomain ( context , "facebook.com" ) ; </a> 0
<a> clearCookiesForDomain ( context , ".facebook.com" ) ; </a> 0
<a> clearCookiesForDomain ( context , "https://facebook.com" ) ; </a> 0
<a> clearCookiesForDomain ( context , "https://.facebook.com" ) ; </a> 0
<a> } </a> 0
<a> public static void logd ( String tag , String msg ) { </a> 0
<a> if ( BuildConfig . DEBUG ) { </a> 1
<a> Log . d ( tag , msg ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . internal ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . graphics . BitmapFactory ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import com . facebook . FacebookException ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . InputStreamReader ; </a> 0
<a> import java . net . HttpURLConnection ; </a> 0
<a> import java . net . URL ; </a> 0
<a> import java . util . * ; </a> 0
<a> class ImageDownloader { </a> 0
<a> private static final int DOWNLOAD_QUEUE_MAX_CONCURRENT = WorkQueue . DEFAULT_MAX_CONCURRENT ; </a> 0
<a> private static final int CACHE_READ_QUEUE_MAX_CONCURRENT = 2 ; </a> 0
<a> private static final Handler handler = new Handler ( ) ; </a> 0
<a> private static WorkQueue downloadQueue = new WorkQueue ( DOWNLOAD_QUEUE_MAX_CONCURRENT ) ; </a> 0
<a> private static WorkQueue cacheReadQueue = new WorkQueue ( CACHE_READ_QUEUE_MAX_CONCURRENT ) ; </a> 0
<a> private static final Map < RequestKey , DownloaderContext > pendingRequests = new HashMap < RequestKey , DownloaderContext > ( ) ; </a> 0
<a> static void downloadAsync ( ImageRequest request ) { </a> 0
<a> if ( request == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> RequestKey key = new RequestKey ( request . getImageUrl ( ) , request . getCallerTag ( ) ) ; </a> 0
<a> synchronized ( pendingRequests ) { </a> 0
<a> DownloaderContext downloaderContext = pendingRequests . get ( key ) ; </a> 0
<a> if ( downloaderContext != null ) { </a> 0
<a> downloaderContext . request = request ; </a> 0
<a> downloaderContext . isCancelled = false ; </a> 0
<a> downloaderContext . workItem . moveToFront ( ) ; </a> 0
<a> } else { </a> 0
<a> enqueueCacheRead ( request , key , request . isCachedRedirectAllowed ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static boolean cancelRequest ( ImageRequest request ) { </a> 0
<a> boolean cancelled = false ; </a> 0
<a> RequestKey key = new RequestKey ( request . getImageUrl ( ) , request . getCallerTag ( ) ) ; </a> 0
<a> synchronized ( pendingRequests ) { </a> 0
<a> DownloaderContext downloaderContext = pendingRequests . get ( key ) ; </a> 0
<a> if ( downloaderContext != null ) { </a> 0
<a> cancelled = true ; </a> 0
<a> if ( downloaderContext . workItem . cancel ( ) ) { </a> 0
<a> pendingRequests . remove ( key ) ; </a> 0
<a> } else { </a> 0
<a> downloaderContext . isCancelled = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return cancelled ; </a> 0
<a> } </a> 0
<a> static void prioritizeRequest ( ImageRequest request ) { </a> 0
<a> RequestKey key = new RequestKey ( request . getImageUrl ( ) , request . getCallerTag ( ) ) ; </a> 0
<a> synchronized ( pendingRequests ) { </a> 0
<a> DownloaderContext downloaderContext = pendingRequests . get ( key ) ; </a> 0
<a> if ( downloaderContext != null ) { </a> 0
<a> downloaderContext . workItem . moveToFront ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void enqueueCacheRead ( ImageRequest request , RequestKey key , boolean allowCachedRedirects ) { </a> 0
<a> enqueueRequest ( </a> 0
<a> request , </a> 0
<a> key , </a> 0
<a> cacheReadQueue , </a> 0
<a> new CacheReadWorkItem ( request . getContext ( ) , key , allowCachedRedirects ) ) ; </a> 0
<a> } </a> 0
<a> private static void enqueueDownload ( ImageRequest request , RequestKey key ) { </a> 0
<a> enqueueRequest ( </a> 0
<a> request , </a> 0
<a> key , </a> 0
<a> downloadQueue , </a> 0
<a> new DownloadImageWorkItem ( request . getContext ( ) , key ) ) ; </a> 0
<a> } </a> 0
<a> private static void enqueueRequest ( </a> 0
<a> ImageRequest request , </a> 0
<a> RequestKey key , </a> 0
<a> WorkQueue workQueue , </a> 0
<a> Runnable workItem ) { </a> 0
<a> synchronized ( pendingRequests ) { </a> 0
<a> DownloaderContext downloaderContext = new DownloaderContext ( ) ; </a> 0
<a> downloaderContext . request = request ; </a> 0
<a> pendingRequests . put ( key , downloaderContext ) ; </a> 0
<a> downloaderContext . workItem = workQueue . addActiveWorkItem ( workItem ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void issueResponse ( </a> 0
<a> RequestKey key , </a> 0
<a> final Exception error , </a> 0
<a> final Bitmap bitmap , </a> 0
<a> final boolean isCachedRedirect ) { </a> 0
<a> DownloaderContext completedRequestContext = removePendingRequest ( key ) ; </a> 0
<a> if ( completedRequestContext != null && ! completedRequestContext . isCancelled ) { </a> 0
<a> final ImageRequest request = completedRequestContext . request ; </a> 0
<a> final ImageRequest . Callback callback = request . getCallback ( ) ; </a> 0
<a> if ( callback != null ) { </a> 0
<a> handler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> ImageResponse response = new ImageResponse ( </a> 0
<a> request , </a> 0
<a> error , </a> 0
<a> isCachedRedirect , </a> 0
<a> bitmap ) ; </a> 0
<a> callback . onCompleted ( response ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void readFromCache ( RequestKey key , Context context , boolean allowCachedRedirects ) { </a> 0
<a> InputStream cachedStream = null ; </a> 0
<a> boolean isCachedRedirect = false ; </a> 0
<a> if ( allowCachedRedirects ) { </a> 0
<a> URL redirectUrl = UrlRedirectCache . getRedirectedUrl ( context , key . url ) ; </a> 0
<a> if ( redirectUrl != null ) { </a> 0
<a> cachedStream = ImageResponseCache . getCachedImageStream ( redirectUrl , context ) ; </a> 0
<a> isCachedRedirect = cachedStream != null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! isCachedRedirect ) { </a> 0
<a> cachedStream = ImageResponseCache . getCachedImageStream ( key . url , context ) ; </a> 0
<a> } </a> 0
<a> if ( cachedStream != null ) { </a> 0
<a> Bitmap bitmap = BitmapFactory . decodeStream ( cachedStream ) ; </a> 0
<a> Utility . closeQuietly ( cachedStream ) ; </a> 0
<a> issueResponse ( key , null , bitmap , isCachedRedirect ) ; </a> 0
<a> } else { </a> 0
<a> DownloaderContext downloaderContext = removePendingRequest ( key ) ; </a> 0
<a> if ( downloaderContext != null && ! downloaderContext . isCancelled ) { </a> 0
<a> enqueueDownload ( downloaderContext . request , key ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void download ( RequestKey key , Context context ) { </a> 0
<a> HttpURLConnection connection = null ; </a> 0
<a> InputStream stream = null ; </a> 0
<a> Exception error = null ; </a> 0
<a> Bitmap bitmap = null ; </a> 0
<a> boolean issueResponse = true ; </a> 0
<a> try { </a> 0
<a> connection = ( HttpURLConnection ) key . url . openConnection ( ) ; </a> 0
<a> connection . setInstanceFollowRedirects ( false ) ; </a> 0
<a> switch ( connection . getResponseCode ( ) ) { </a> 0
<a> case HttpURLConnection . HTTP_MOVED_PERM : </a> 0
<a> case HttpURLConnection . HTTP_MOVED_TEMP : </a> 0
<a> issueResponse = false ; </a> 0
<a> String redirectLocation = connection . getHeaderField ( "location" ) ; </a> 0
<a> if ( ! Utility . isNullOrEmpty ( redirectLocation ) ) { </a> 0
<a> URL redirectUrl = new URL ( redirectLocation ) ; </a> 0
<a> UrlRedirectCache . cacheUrlRedirect ( context , key . url , redirectUrl ) ; </a> 0
<a> DownloaderContext downloaderContext = removePendingRequest ( key ) ; </a> 0
<a> if ( downloaderContext != null && ! downloaderContext . isCancelled ) { </a> 0
<a> enqueueCacheRead ( </a> 0
<a> downloaderContext . request , </a> 0
<a> new RequestKey ( redirectUrl , key . tag ) , </a> 0
<a> false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> case HttpURLConnection . HTTP_OK : </a> 0
<a> stream = ImageResponseCache . interceptAndCacheImageStream ( context , connection ) ; </a> 0
<a> bitmap = BitmapFactory . decodeStream ( stream ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> stream = connection . getErrorStream ( ) ; </a> 0
<a> InputStreamReader reader = new InputStreamReader ( stream ) ; </a> 0
<a> char [ ] buffer = new char [ 128 ] ; </a> 0
<a> int bufferLength ; </a> 0
<a> StringBuilder errorMessageBuilder = new StringBuilder ( ) ; </a> 1
<a> while ( ( bufferLength = reader . read ( buffer , 0 , buffer . length ) ) > 0 ) { </a> 0
<a> errorMessageBuilder . append ( buffer , 0 , bufferLength ) ; </a> 0
<a> } </a> 0
<a> Utility . closeQuietly ( reader ) ; </a> 0
<a> error = new FacebookException ( errorMessageBuilder . toString ( ) ) ; </a> 1
<a> break ; </a> 0
<a> } </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> error = e ; </a> 0
<a> } finally { </a> 0
<a> Utility . closeQuietly ( stream ) ; </a> 0
<a> Utility . disconnectQuietly ( connection ) ; </a> 0
<a> } </a> 0
<a> if ( issueResponse ) { </a> 0
<a> issueResponse ( key , error , bitmap , false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static DownloaderContext removePendingRequest ( RequestKey key ) { </a> 0
<a> synchronized ( pendingRequests ) { </a> 0
<a> return pendingRequests . remove ( key ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class RequestKey { </a> 0
<a> private static final int HASH_SEED = 29 ; </a> 0
<a> private static final int HASH_MULTIPLIER = 37 ; </a> 0
<a> URL url ; </a> 0
<a> Object tag ; </a> 0
<a> RequestKey ( URL url , Object tag ) { </a> 0
<a> this . url = url ; </a> 0
<a> this . tag = tag ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> int result = HASH_SEED ; </a> 0
<a> result = ( result * HASH_MULTIPLIER ) + url . hashCode ( ) ; </a> 0
<a> result = ( result * HASH_MULTIPLIER ) + tag . hashCode ( ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object o ) { </a> 0
<a> boolean isEqual = false ; </a> 0
<a> if ( o != null && o instanceof RequestKey ) { </a> 0
<a> RequestKey compareTo = ( RequestKey ) o ; </a> 0
<a> isEqual = compareTo . url == url && compareTo . tag == tag ; </a> 0
<a> } </a> 0
<a> return isEqual ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class DownloaderContext { </a> 0
<a> WorkQueue . WorkItem workItem ; </a> 0
<a> ImageRequest request ; </a> 0
<a> boolean isCancelled ; </a> 0
<a> } </a> 0
<a> private static class CacheReadWorkItem implements Runnable { </a> 0
<a> private Context context ; </a> 0
<a> private RequestKey key ; </a> 0
<a> private boolean allowCachedRedirects ; </a> 0
<a> CacheReadWorkItem ( Context context , RequestKey key , boolean allowCachedRedirects ) { </a> 0
<a> this . context = context ; </a> 0
<a> this . key = key ; </a> 0
<a> this . allowCachedRedirects = allowCachedRedirects ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> readFromCache ( key , context , allowCachedRedirects ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class DownloadImageWorkItem implements Runnable { </a> 0
<a> private Context context ; </a> 0
<a> private RequestKey key ; </a> 0
<a> DownloadImageWorkItem ( Context context , RequestKey key ) { </a> 0
<a> this . context = context ; </a> 0
<a> this . key = key ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> download ( key , context ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import com . facebook . internal . Validate ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> import java . net . URL ; </a> 0
<a> class ImageRequest { </a> 0
<a> interface Callback { </a> 0
<a> void onCompleted ( ImageResponse response ) ; </a> 0
<a> } </a> 0
<a> static final int UNSPECIFIED_DIMENSION = 0 ; </a> 0
<a> private static final String PROFILEPIC_URL_FORMAT = </a> 0
<a> "https://graph.facebook.com/%s/picture" ; </a> 0
<a> private static final String HEIGHT_PARAM = "height" ; </a> 0
<a> private static final String WIDTH_PARAM = "width" ; </a> 0
<a> private static final String MIGRATION_PARAM = "migration_overrides" ; </a> 0
<a> private static final String MIGRATION_VALUE = "{october_2012:true}" ; </a> 0
<a> private Context context ; </a> 0
<a> private URL imageUrl ; </a> 0
<a> private Callback callback ; </a> 0
<a> private boolean allowCachedRedirects ; </a> 0
<a> private Object callerTag ; </a> 0
<a> static URL getProfilePictureUrl ( </a> 0
<a> String userId , </a> 0
<a> int width , </a> 0
<a> int height ) </a> 0
<a> throws MalformedURLException { </a> 0
<a> Validate . notNullOrEmpty ( userId , "userId" ) ; </a> 0
<a> width = Math . max ( width , UNSPECIFIED_DIMENSION ) ; </a> 0
<a> height = Math . max ( height , UNSPECIFIED_DIMENSION ) ; </a> 0
<a> if ( width == UNSPECIFIED_DIMENSION && height == UNSPECIFIED_DIMENSION ) { </a> 0
<a> throw new IllegalArgumentException ( "Either width or height must be greater than 0" ) ; </a> 0
<a> } </a> 0
<a> Uri . Builder builder = new Uri . Builder ( ) . encodedPath ( String . format ( PROFILEPIC_URL_FORMAT , userId ) ) ; </a> 0
<a> if ( height != UNSPECIFIED_DIMENSION ) { </a> 0
<a> builder . appendQueryParameter ( HEIGHT_PARAM , String . valueOf ( height ) ) ; </a> 0
<a> } </a> 0
<a> if ( width != UNSPECIFIED_DIMENSION ) { </a> 0
<a> builder . appendQueryParameter ( WIDTH_PARAM , String . valueOf ( width ) ) ; </a> 0
<a> } </a> 0
<a> builder . appendQueryParameter ( MIGRATION_PARAM , MIGRATION_VALUE ) ; </a> 0
<a> return new URL ( builder . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> private ImageRequest ( Builder builder ) { </a> 0
<a> this . context = builder . context ; </a> 0
<a> this . imageUrl = builder . imageUrl ; </a> 0
<a> this . callback = builder . callback ; </a> 0
<a> this . allowCachedRedirects = builder . allowCachedRedirects ; </a> 0
<a> this . callerTag = builder . callerTag == null ? new Object ( ) : builder . callerTag ; </a> 0
<a> } </a> 0
<a> Context getContext ( ) { </a> 0
<a> return context ; </a> 0
<a> } </a> 0
<a> URL getImageUrl ( ) { </a> 0
<a> return imageUrl ; </a> 0
<a> } </a> 0
<a> Callback getCallback ( ) { </a> 0
<a> return callback ; </a> 0
<a> } </a> 0
<a> boolean isCachedRedirectAllowed ( ) { </a> 0
<a> return allowCachedRedirects ; </a> 0
<a> } </a> 0
<a> Object getCallerTag ( ) { </a> 0
<a> return callerTag ; </a> 0
<a> } </a> 0
<a> static class Builder { </a> 0
<a> private Context context ; </a> 0
<a> private URL imageUrl ; </a> 0
<a> private Callback callback ; </a> 0
<a> private boolean allowCachedRedirects ; </a> 0
<a> private Object callerTag ; </a> 0
<a> Builder ( Context context , URL imageUrl ) { </a> 0
<a> Validate . notNull ( imageUrl , "imageUrl" ) ; </a> 0
<a> this . context = context ; </a> 0
<a> this . imageUrl = imageUrl ; </a> 0
<a> } </a> 0
<a> Builder setCallback ( Callback callback ) { </a> 0
<a> this . callback = callback ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> Builder setCallerTag ( Object callerTag ) { </a> 0
<a> this . callerTag = callerTag ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> Builder setAllowCachedRedirects ( boolean allowCachedRedirects ) { </a> 0
<a> this . allowCachedRedirects = allowCachedRedirects ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> ImageRequest build ( ) { </a> 0
<a> return new ImageRequest ( this ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> public class FacebookActivityTests extends FacebookActivityTestCase < FacebookActivityTests . FacebookTestActivity > { </a> 0
<a> public FacebookActivityTests ( ) { </a> 0
<a> super ( FacebookActivityTests . FacebookTestActivity . class ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void setUp ( ) throws Exception { </a> 0
<a> super . setUp ( ) ; </a> 0
<a> Session activeSession = Session . getActiveSession ( ) ; </a> 0
<a> if ( activeSession != null ) { </a> 0
<a> activeSession . closeAndClearTokenInformation ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testLaunchingWithEmptyIntent ( ) { </a> 0
<a> Intent intent = new Intent ( Intent . ACTION_MAIN ) ; </a> 0
<a> setActivityIntent ( intent ) ; </a> 0
<a> FacebookTestActivity activity = getActivity ( ) ; </a> 0
<a> assertNull ( Session . getActiveSession ( ) ) ; </a> 0
<a> assertFalse ( activity . hasNativeLinkIntentForTesting ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testLaunchingWithValidNativeLinkingIntent ( ) { </a> 0
<a> final String token = "A token less unique than most" ; </a> 0
<a> Intent intent = new Intent ( Intent . ACTION_MAIN ) ; </a> 0
<a> intent . putExtras ( getNativeLinkingExtras ( token ) ) ; </a> 0
<a> setActivityIntent ( intent ) ; </a> 0
<a> assertNull ( Session . getActiveSession ( ) ) ; </a> 0
<a> FacebookTestActivity activity = getActivity ( ) ; </a> 0
<a> Session activeSession = Session . getActiveSession ( ) ; </a> 0
<a> assertNull ( activeSession ) ; </a> 0
<a> assertTrue ( activity . hasNativeLinkIntentForTesting ( ) ) ; </a> 0
<a> } </a> 0
<a> public static class FacebookTestActivity extends Activity { </a> 0
<a> public boolean hasNativeLinkIntentForTesting ( ) { </a> 0
<a> return AccessToken . createFromNativeLinkingIntent ( getIntent ( ) ) != null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> public class FacebookTestCase extends FacebookActivityTestCase < FacebookTestCase . FacebookTestActivity > { </a> 0
<a> public FacebookTestCase ( ) { </a> 0
<a> super ( FacebookTestCase . FacebookTestActivity . class ) ; </a> 0
<a> Settings . addLoggingBehavior ( LoggingBehavior . REQUESTS ) ; </a> 0
<a> Settings . addLoggingBehavior ( LoggingBehavior . INCLUDE_RAW_RESPONSES ) ; </a> 0
<a> } </a> 0
<a> public static class FacebookTestActivity extends Activity { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . content . BroadcastReceiver ; </a> 1
<a> import android . content . Context ; </a> 0
<a> import android . content . Intent ; </a> 1
<a> import android . os . Bundle ; </a> 0
<a> import android . os . ConditionVariable ; </a> 1
<a> import android . os . Looper ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import com . facebook . model . GraphMultiResult ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import com . facebook . model . GraphObjectList ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import java . util . * ; </a> 0
<a> import java . util . concurrent . BlockingQueue ; </a> 0
<a> import java . util . concurrent . LinkedBlockingQueue ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public class SessionTestsBase extends FacebookTestCase { </a> 0
<a> public static final int DEFAULT_TIMEOUT_MILLISECONDS = 10 * 1000 ; </a> 0
<a> static final int SIMULATED_WORKING_MILLISECONDS = 20 ; </a> 0
<a> public static final int STRAY_CALLBACK_WAIT_MILLISECONDS = 50 ; </a> 0
<a> public ScriptedSession createScriptedSessionOnBlockerThread ( TokenCachingStrategy cachingStrategy ) { </a> 0
<a> return createScriptedSessionOnBlockerThread ( Utility . getMetadataApplicationId ( getActivity ( ) ) , cachingStrategy ) ; </a> 0
<a> } </a> 0
<a> ScriptedSession createScriptedSessionOnBlockerThread ( final String applicationId , </a> 0
<a> final TokenCachingStrategy cachingStrategy ) { </a> 0
<a> class MutableState { </a> 0
<a> ScriptedSession session ; </a> 0
<a> } </a> 0
<a> ; </a> 0
<a> final MutableState mutable = new MutableState ( ) ; </a> 0
<a> runOnBlockerThread ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> mutable . session = new ScriptedSession ( getActivity ( ) , applicationId , cachingStrategy ) ; </a> 0
<a> } </a> 0
<a> } , true ) ; </a> 0
<a> return mutable . session ; </a> 0
<a> } </a> 0
<a> public static void stall ( int stallMsec ) { </a> 0
<a> try { </a> 0
<a> Thread . sleep ( stallMsec ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( "InterruptedException while stalling" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class ScriptedSession extends Session { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> private final LinkedList < AuthorizeResult > pendingAuthorizations = new LinkedList < AuthorizeResult > ( ) ; </a> 0
<a> private AuthorizationRequest lastRequest ; </a> 0
<a> private AuthorizeResult currentAuthorization = null ; </a> 0
<a> public ScriptedSession ( Context currentContext , String applicationId , TokenCachingStrategy tokenCachingStrategy ) { </a> 0
<a> super ( currentContext , applicationId , tokenCachingStrategy ) ; </a> 0
<a> } </a> 0
<a> public void addAuthorizeResult ( String token , List < String > permissions , AccessTokenSource source ) { </a> 0
<a> addAuthorizeResult ( AccessToken . createFromString ( token , permissions , source ) ) ; </a> 0
<a> } </a> 0
<a> public void addAuthorizeResult ( AccessToken token ) { </a> 0
<a> pendingAuthorizations . add ( new AuthorizeResult ( token ) ) ; </a> 0
<a> } </a> 0
<a> public void addAuthorizeResult ( AccessToken token , List < String > permissions ) { </a> 0
<a> pendingAuthorizations . add ( new AuthorizeResult ( token , permissions ) ) ; </a> 0
<a> } </a> 0
<a> public void addAuthorizeResult ( AccessToken token , String ... permissions ) { </a> 0
<a> pendingAuthorizations . add ( new AuthorizeResult ( token , Arrays . asList ( permissions ) ) ) ; </a> 0
<a> } </a> 0
<a> public void addAuthorizeResult ( Exception exception ) { </a> 0
<a> pendingAuthorizations . add ( new AuthorizeResult ( exception ) ) ; </a> 0
<a> } </a> 0
<a> public void addPendingAuthorizeResult ( ) { </a> 0
<a> pendingAuthorizations . add ( new AuthorizeResult ( ) ) ; </a> 0
<a> } </a> 0
<a> public AuthorizationRequest getLastRequest ( ) { </a> 0
<a> return lastRequest ; </a> 0
<a> } </a> 0
<a> public SessionDefaultAudience getLastRequestAudience ( ) { </a> 0
<a> return lastRequest . getDefaultAudience ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void authorize ( final AuthorizationRequest request ) { </a> 0
<a> lastRequest = request ; </a> 0
<a> getActivity ( ) . runOnUiThread ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> stall ( SIMULATED_WORKING_MILLISECONDS ) ; </a> 0
<a> currentAuthorization = pendingAuthorizations . poll ( ) ; </a> 0
<a> if ( currentAuthorization == null ) { </a> 0
<a> fail ( "Missing call to addScriptedAuthorization" ) ; </a> 0
<a> } </a> 0
<a> if ( ! currentAuthorization . leaveAsPending ) { </a> 0
<a> finishAuthOrReauth ( currentAuthorization . token , currentAuthorization . exception ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private class AuthorizeResult { </a> 0
<a> final AccessToken token ; </a> 0
<a> final Exception exception ; </a> 0
<a> final List < String > resultingPermissions ; </a> 0
<a> final boolean leaveAsPending ; </a> 0
<a> private AuthorizeResult ( AccessToken token , Exception exception , List < String > permissions ) { </a> 0
<a> this . token = token ; </a> 0
<a> this . exception = exception ; </a> 0
<a> this . resultingPermissions = permissions ; </a> 0
<a> this . leaveAsPending = false ; </a> 0
<a> } </a> 0
<a> private AuthorizeResult ( ) { </a> 0
<a> this . token = null ; </a> 0
<a> this . exception = null ; </a> 0
<a> this . resultingPermissions = null ; </a> 0
<a> this . leaveAsPending = true ; </a> 0
<a> } </a> 0
<a> AuthorizeResult ( AccessToken token , List < String > permissions ) { </a> 0
<a> this ( token , null , permissions ) ; </a> 0
<a> } </a> 0
<a> AuthorizeResult ( AccessToken token ) { </a> 0
<a> this ( token , null , null ) ; </a> 0
<a> } </a> 0
<a> AuthorizeResult ( Exception exception ) { </a> 0
<a> this ( null , exception , null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static class SessionStatusCallbackRecorder implements Session . StatusCallback { </a> 0
<a> private final BlockingQueue < Call > calls = new LinkedBlockingQueue < Call > ( ) ; </a> 0
<a> volatile boolean isClosed = false ; </a> 0
<a> public void waitForCall ( Session session , SessionState state , Exception exception ) { </a> 0
<a> Call call = null ; </a> 0
<a> try { </a> 0
<a> call = calls . poll ( DEFAULT_TIMEOUT_MILLISECONDS , TimeUnit . MILLISECONDS ) ; </a> 0
<a> if ( call == null ) { </a> 0
<a> fail ( "Did not get a status callback within timeout." ) ; </a> 0
<a> } </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( "InterruptedException while waiting for status callback: " + e ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( session , call . session ) ; </a> 0
<a> assertEquals ( state , call . state ) ; </a> 0
<a> if ( exception != null && call . exception != null ) { </a> 0
<a> assertEquals ( exception . getClass ( ) , call . exception . getClass ( ) ) ; </a> 0
<a> } else { </a> 0
<a> assertTrue ( exception == call . exception ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void close ( ) { </a> 0
<a> isClosed = true ; </a> 0
<a> assertEquals ( 0 , calls . size ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> Call call = new Call ( session , state , exception ) ; </a> 0
<a> if ( ! calls . offer ( call ) ) { </a> 0
<a> fail ( "Test Error: Blocking queue ran out of capacity" ) ; </a> 0
<a> } </a> 0
<a> if ( isClosed ) { </a> 0
<a> fail ( "Reauthorize callback called after closed" ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( "Callback should run on main UI thread" , Thread . currentThread ( ) , </a> 0
<a> Looper . getMainLooper ( ) . getThread ( ) ) ; </a> 0
<a> } </a> 0
<a> private static class Call { </a> 0
<a> final Session session ; </a> 0
<a> final SessionState state ; </a> 0
<a> final Exception exception ; </a> 0
<a> Call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> this . session = session ; </a> 0
<a> this . state = state ; </a> 0
<a> this . exception = exception ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static class MockTokenCachingStrategy extends TokenCachingStrategy { </a> 0
<a> private final String token ; </a> 0
<a> private final long expires_in ; </a> 0
<a> private Bundle saved ; </a> 0
<a> MockTokenCachingStrategy ( ) { </a> 0
<a> this ( "FakeToken" , DEFAULT_TIMEOUT_MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> public MockTokenCachingStrategy ( String token , long expires_in ) { </a> 0
<a> this . token = token ; </a> 0
<a> this . expires_in = expires_in ; </a> 0
<a> this . saved = null ; </a> 0
<a> } </a> 0
<a> public Bundle getSavedState ( ) { </a> 0
<a> return saved ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Bundle load ( ) { </a> 0
<a> Bundle bundle = null ; </a> 0
<a> if ( token != null ) { </a> 0
<a> bundle = new Bundle ( ) ; </a> 0
<a> TokenCachingStrategy . putToken ( bundle , token ) ; </a> 0
<a> TokenCachingStrategy . putExpirationMilliseconds ( bundle , System . currentTimeMillis ( ) + expires_in ) ; </a> 0
<a> } </a> 0
<a> return bundle ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void save ( Bundle bundle ) { </a> 0
<a> this . saved = bundle ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clear ( ) { </a> 0
<a> this . saved = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static class WaitForBroadcastReceiver extends BroadcastReceiver { </a> 0
<a> static int idGenerator = 0 ; </a> 0
<a> final int id = idGenerator ++ ; </a> 0
<a> ConditionVariable condition = new ConditionVariable ( true ) ; </a> 0
<a> int expectCount ; </a> 0
<a> int actualCount ; </a> 0
<a> public void incrementExpectCount ( ) { </a> 0
<a> incrementExpectCount ( 1 ) ; </a> 0
<a> } </a> 0
<a> public void incrementExpectCount ( int n ) { </a> 0
<a> expectCount += n ; </a> 0
<a> if ( actualCount < expectCount ) { </a> 0
<a> condition . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void waitForExpectedCalls ( ) { </a> 0
<a> if ( ! condition . block ( DEFAULT_TIMEOUT_MILLISECONDS ) ) { </a> 0
<a> assertTrue ( false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void incrementExpectCounts ( WaitForBroadcastReceiver ... receivers ) { </a> 0
<a> for ( WaitForBroadcastReceiver receiver : receivers ) { </a> 0
<a> receiver . incrementExpectCount ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void waitForExpectedCalls ( WaitForBroadcastReceiver ... receivers ) { </a> 0
<a> for ( WaitForBroadcastReceiver receiver : receivers ) { </a> 0
<a> receiver . waitForExpectedCalls ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onReceive ( Context context , Intent intent ) { </a> 0
<a> if ( ++ actualCount == expectCount ) { </a> 0
<a> condition . open ( ) ; </a> 0
<a> } </a> 0
<a> assertTrue ( actualCount <= expectCount ) ; </a> 0
<a> assertEquals ( "BroadcastReceiver should receive on main UI thread" , </a> 0
<a> Thread . currentThread ( ) , Looper . getMainLooper ( ) . getThread ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . location . Location ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . support . v4 . app . LoaderManager ; </a> 0
<a> import android . support . v4 . content . Loader ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . model . GraphPlace ; </a> 0
<a> public class GraphObjectPagingLoaderTests extends FragmentTestCase < GraphObjectPagingLoaderTests . TestActivity > { </a> 0
<a> public GraphObjectPagingLoaderTests ( ) { </a> 0
<a> super ( TestActivity . class ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testLoaderLoadsAndFollowsNextLinks ( ) throws Exception { </a> 0
<a> CountingCallback callback = new CountingCallback ( ) ; </a> 0
<a> final GraphObjectPagingLoader < GraphPlace > loader = ( GraphObjectPagingLoader < GraphPlace > ) </a> 0
<a> getActivity ( ) . getSupportLoaderManager ( ) . initLoader ( 0 , null , callback ) ; </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Location location = new Location ( "" ) ; </a> 0
<a> location . setLatitude ( 47.6204 ) ; </a> 0
<a> location . setLongitude ( - 122.3491 ) ; </a> 0
<a> final Request request = Request . newPlacesSearchRequest ( session , location , 1000 , 5 , null , null ) ; </a> 0
<a> runOnBlockerThread ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> loader . startLoading ( request , false ) ; </a> 0
<a> } </a> 0
<a> } , false ) ; </a> 0
<a> getTestBlocker ( ) . waitForSignals ( 1 ) ; </a> 0
<a> assertEquals ( 1 , callback . onLoadFinishedCount ) ; </a> 0
<a> assertEquals ( 0 , callback . onErrorCount ) ; </a> 0
<a> assertEquals ( 0 , callback . onLoadResetCount ) ; </a> 0
<a> assertNotNull ( callback . results ) ; </a> 0
<a> assertTrue ( callback . results . getCount ( ) > 0 ) ; </a> 0
<a> runOnBlockerThread ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> loader . followNextLink ( ) ; </a> 0
<a> } </a> 0
<a> } , false ) ; </a> 0
<a> getTestBlocker ( ) . waitForSignals ( 1 ) ; </a> 0
<a> assertEquals ( 2 , callback . onLoadFinishedCount ) ; </a> 0
<a> assertEquals ( 0 , callback . onErrorCount ) ; </a> 0
<a> assertEquals ( 0 , callback . onLoadResetCount ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testLoaderFinishesImmediatelyOnNoResults ( ) throws Exception { </a> 0
<a> CountingCallback callback = new CountingCallback ( ) ; </a> 0
<a> final GraphObjectPagingLoader < GraphPlace > loader = ( GraphObjectPagingLoader < GraphPlace > ) </a> 0
<a> getActivity ( ) . getSupportLoaderManager ( ) . initLoader ( 0 , null , callback ) ; </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Location location = new Location ( "" ) ; </a> 0
<a> location . setLatitude ( - 1.0 ) ; </a> 0
<a> location . setLongitude ( - 1.0 ) ; </a> 0
<a> final Request request = Request . newPlacesSearchRequest ( session , location , 10 , 5 , null , null ) ; </a> 0
<a> runOnBlockerThread ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> loader . startLoading ( request , false ) ; </a> 0
<a> } </a> 0
<a> } , false ) ; </a> 0
<a> getTestBlocker ( ) . waitForSignals ( 1 ) ; </a> 0
<a> assertEquals ( 1 , callback . onLoadFinishedCount ) ; </a> 0
<a> assertEquals ( 0 , callback . onErrorCount ) ; </a> 0
<a> assertEquals ( 0 , callback . onLoadResetCount ) ; </a> 0
<a> assertNotNull ( callback . results ) ; </a> 0
<a> assertEquals ( 0 , callback . results . getCount ( ) ) ; </a> 0
<a> } </a> 0
<a> private class CountingCallback implements </a> 0
<a> GraphObjectPagingLoader . OnErrorListener , LoaderManager . LoaderCallbacks < SimpleGraphObjectCursor < GraphPlace > > { </a> 0
<a> public int onLoadFinishedCount ; </a> 0
<a> public int onLoadResetCount ; </a> 0
<a> public int onErrorCount ; </a> 0
<a> public SimpleGraphObjectCursor < GraphPlace > results ; </a> 0
<a> private TestBlocker testBlocker = getTestBlocker ( ) ; </a> 0
<a> @ Override </a> 0
<a> public void onError ( FacebookException error , GraphObjectPagingLoader < ? > loader ) { </a> 0
<a> ++ onErrorCount ; </a> 0
<a> testBlocker . signal ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Loader < SimpleGraphObjectCursor < GraphPlace > > onCreateLoader ( int id , Bundle args ) { </a> 0
<a> GraphObjectPagingLoader < GraphPlace > loader = new GraphObjectPagingLoader < GraphPlace > ( getActivity ( ) , </a> 0
<a> GraphPlace . class ) ; </a> 0
<a> loader . setOnErrorListener ( this ) ; </a> 0
<a> return loader ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onLoadFinished ( Loader < SimpleGraphObjectCursor < GraphPlace > > loader , </a> 0
<a> SimpleGraphObjectCursor < GraphPlace > data ) { </a> 0
<a> results = data ; </a> 0
<a> ++ onLoadFinishedCount ; </a> 0
<a> testBlocker . signal ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onLoaderReset ( Loader < SimpleGraphObjectCursor < GraphPlace > > loader ) { </a> 0
<a> ++ onLoadResetCount ; </a> 0
<a> testBlocker . signal ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static class DummyFragment extends Fragment { </a> 0
<a> } </a> 0
<a> public static class TestActivity extends FragmentTestCase . TestFragmentActivity < DummyFragment > { </a> 0
<a> public TestActivity ( ) { </a> 0
<a> super ( DummyFragment . class ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean getAutoCreateUI ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . friendpicker ; </a> 0
<a> import android . app . Application ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import java . util . Collection ; </a> 1
<a> public class FriendPickerApplication extends Application { </a> 0
<a> private Collection < GraphUser > selectedUsers ; </a> 1
<a> public Collection < GraphUser > getSelectedUsers ( ) { </a> 1
<a> return selectedUsers ; </a> 0
<a> } </a> 0
<a> public void setSelectedUsers ( Collection < GraphUser > selectedUsers ) { </a> 1
<a> this . selectedUsers = selectedUsers ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import com . facebook . android . AsyncFacebookRunner . RequestListener ; </a> 0
<a> import java . io . FileNotFoundException ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public abstract class BaseRequestListener implements RequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onFacebookError ( FacebookError e , final Object state ) { </a> 0
<a> Log . e ( "Facebook" , e . getMessage ( ) ) ; </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onFileNotFoundException ( FileNotFoundException e , final Object state ) { </a> 0
<a> Log . e ( "Facebook" , e . getMessage ( ) ) ; </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onIOException ( IOException e , final Object state ) { </a> 0
<a> Log . e ( "Facebook" , e . getMessage ( ) ) ; </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onMalformedURLException ( MalformedURLException e , final Object state ) { </a> 0
<a> Log . e ( "Facebook" , e . getMessage ( ) ) ; </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Dialog ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . text . SpannableString ; </a> 0
<a> import android . text . style . UnderlineSpan ; </a> 0
<a> import android . view . LayoutInflater ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . view . ViewGroup . LayoutParams ; </a> 0
<a> import android . widget . * ; </a> 0
<a> import android . widget . AdapterView . OnItemClickListener ; </a> 0
<a> import android . widget . CompoundButton . OnCheckedChangeListener ; </a> 0
<a> import android . widget . TabHost . TabSpec ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . Comparator ; </a> 0
<a> import java . util . Vector ; </a> 0
<a> public class FieldsConnectionsDialog extends Dialog { </a> 0
<a> private final static int TAB_HEIGHT = 50 ; </a> 0
<a> private Button mGetFieldsButton ; </a> 0
<a> private ListView fieldsList , connectionsList ; </a> 0
<a> private BaseAdapter fieldsAdapter , connectionsAdapter ; </a> 0
<a> private GraphExplorer explorerActivity ; </a> 0
<a> protected Vector < String > fieldsVector ; </a> 0
<a> private ArrayList < JSONObject > fieldsArray ; </a> 0
<a> private ArrayList < String > connectionsArray ; </a> 0
<a> public FieldsConnectionsDialog ( GraphExplorer explorerActivity , JSONObject metadata ) { </a> 0
<a> super ( explorerActivity ) ; </a> 0
<a> this . explorerActivity = explorerActivity ; </a> 0
<a> try { </a> 0
<a> sortFields ( metadata . getJSONArray ( "fields" ) ) ; </a> 0
<a> sortConnections ( metadata . getJSONObject ( "connections" ) . names ( ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> Toast . makeText ( explorerActivity . getBaseContext ( ) , </a> 0
<a> "Fields/Connections could not be fetched." , Toast . LENGTH_SHORT ) . show ( ) ; </a> 0
<a> } </a> 0
<a> setTitle ( explorerActivity . getString ( R . string . fields_and_connections ) ) ; </a> 0
<a> fieldsVector = new Vector < String > ( ) ; </a> 0
<a> } </a> 0
<a> public void sortFields ( JSONArray jsonFieldsArray ) { </a> 0
<a> this . fieldsArray = new ArrayList < JSONObject > ( jsonFieldsArray . length ( ) ) ; </a> 0
<a> for ( int i = 0 ; i < jsonFieldsArray . length ( ) ; i ++ ) { </a> 0
<a> try { </a> 0
<a> this . fieldsArray . add ( jsonFieldsArray . getJSONObject ( i ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Collections . sort ( this . fieldsArray , new Comparator < JSONObject > ( ) { </a> 0
<a> @ Override </a> 0
<a> public int compare ( JSONObject object1 , JSONObject object2 ) { </a> 0
<a> try { </a> 0
<a> return object1 . getString ( "name" ) . compareToIgnoreCase ( object2 . getString ( "name" ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> public void sortConnections ( JSONArray jsonConnectionsArray ) { </a> 0
<a> this . connectionsArray = new ArrayList < String > ( jsonConnectionsArray . length ( ) ) ; </a> 0
<a> for ( int i = 0 ; i < jsonConnectionsArray . length ( ) ; i ++ ) { </a> 0
<a> try { </a> 0
<a> this . connectionsArray . add ( jsonConnectionsArray . get ( i ) . toString ( ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Collections . sort ( this . connectionsArray ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . fields_connections_list ) ; </a> 0
<a> LayoutParams params = getWindow ( ) . getAttributes ( ) ; </a> 0
<a> params . width = LayoutParams . FILL_PARENT ; </a> 0
<a> params . height = LayoutParams . FILL_PARENT ; </a> 0
<a> getWindow ( ) . setAttributes ( ( android . view . WindowManager . LayoutParams ) params ) ; </a> 0
<a> fieldsList = ( ListView ) findViewById ( R . id . fields_list ) ; </a> 0
<a> connectionsList = ( ListView ) findViewById ( R . id . connections_list ) ; </a> 0
<a> fieldsAdapter = new FieldsListAdapter ( ) ; </a> 0
<a> if ( this . fieldsArray == null ) { </a> 0
<a> fieldsList . setAdapter ( new ArrayAdapter < String > ( explorerActivity , </a> 0
<a> android . R . layout . simple_list_item_1 , new String [ ] { "No fields available" } ) ) ; </a> 0
<a> } else { </a> 0
<a> fieldsList . setAdapter ( fieldsAdapter ) ; </a> 0
<a> } </a> 0
<a> connectionsAdapter = new ConnectionsListAdapter ( ) ; </a> 0
<a> if ( this . connectionsArray == null ) { </a> 0
<a> connectionsList . setAdapter ( new ArrayAdapter < String > ( explorerActivity , </a> 0
<a> android . R . layout . simple_list_item_1 , </a> 0
<a> new String [ ] { "No connections available" } ) ) ; </a> 0
<a> } else { </a> 0
<a> connectionsList . setAdapter ( connectionsAdapter ) ; </a> 0
<a> } </a> 0
<a> TabHost tabHost = ( TabHost ) findViewById ( R . id . tabHost ) ; </a> 0
<a> tabHost . setup ( ) ; </a> 0
<a> TabSpec spec1 = tabHost . newTabSpec ( "Tab 1" ) ; </a> 0
<a> spec1 . setIndicator ( explorerActivity . getString ( R . string . fields ) ) ; </a> 0
<a> spec1 . setContent ( R . id . fields_layout ) ; </a> 0
<a> TabSpec spec2 = tabHost . newTabSpec ( "Tab 2" ) ; </a> 0
<a> spec2 . setIndicator ( explorerActivity . getString ( R . string . connections ) ) ; </a> 0
<a> spec2 . setContent ( R . id . connections_list ) ; </a> 0
<a> tabHost . addTab ( spec1 ) ; </a> 0
<a> tabHost . addTab ( spec2 ) ; </a> 0
<a> tabHost . setCurrentTab ( 0 ) ; </a> 0
<a> tabHost . getTabWidget ( ) . getChildAt ( 0 ) . getLayoutParams ( ) . height = TAB_HEIGHT ; </a> 0
<a> tabHost . getTabWidget ( ) . getChildAt ( 1 ) . getLayoutParams ( ) . height = TAB_HEIGHT ; </a> 0
<a> mGetFieldsButton = ( Button ) findViewById ( R . id . get_fields_button ) ; </a> 0
<a> mGetFieldsButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> FieldsConnectionsDialog . this . dismiss ( ) ; </a> 0
<a> if ( ! fieldsVector . isEmpty ( ) ) { </a> 0
<a> explorerActivity . getFields ( fieldsVector ) ; </a> 0
<a> } else { </a> 0
<a> Toast . makeText ( explorerActivity . getBaseContext ( ) , "No Fields selected." , </a> 0
<a> Toast . LENGTH_SHORT ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> connectionsList . setOnItemClickListener ( new OnItemClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onItemClick ( AdapterView < ? > arg0 , View v , int position , long arg3 ) { </a> 0
<a> FieldsConnectionsDialog . this . dismiss ( ) ; </a> 0
<a> explorerActivity . getConnection ( connectionsArray . get ( position ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> public class FieldsListAdapter extends BaseAdapter { </a> 0
<a> private LayoutInflater mInflater ; </a> 0
<a> boolean [ ] isChecked ; </a> 0
<a> public FieldsListAdapter ( ) { </a> 0
<a> mInflater = LayoutInflater . from ( explorerActivity . getBaseContext ( ) ) ; </a> 0
<a> isChecked = new boolean [ fieldsArray . size ( ) ] ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getCount ( ) { </a> 0
<a> return fieldsArray . size ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object getItem ( int position ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getItemId ( int position ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View getView ( final int position , View convertView , ViewGroup parent ) { </a> 0
<a> View hView = convertView ; </a> 0
<a> ViewHolder holder ; </a> 0
<a> JSONObject fieldObject = null ; </a> 0
<a> fieldObject = fieldsArray . get ( position ) ; </a> 0
<a> if ( hView == null ) { </a> 0
<a> hView = mInflater . inflate ( R . layout . fields_item , null ) ; </a> 0
<a> holder = new ViewHolder ( ) ; </a> 0
<a> holder . checkbox = ( CheckBox ) hView . findViewById ( R . id . fields_checkbox ) ; </a> 0
<a> holder . fieldsInfo = ( TextView ) hView . findViewById ( R . id . fields_info ) ; </a> 0
<a> hView . setTag ( holder ) ; </a> 0
<a> } else { </a> 0
<a> holder = ( ViewHolder ) hView . getTag ( ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> holder . checkbox . setText ( fieldObject . getString ( "name" ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> holder . checkbox . setText ( "" ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> holder . fieldsInfo . setText ( fieldObject . getString ( "description" ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> holder . fieldsInfo . setText ( "" ) ; </a> 0
<a> } </a> 0
<a> holder . checkbox . setId ( position ) ; </a> 0
<a> holder . checkbox . setChecked ( isChecked [ position ] ) ; </a> 0
<a> holder . checkbox . setOnCheckedChangeListener ( new OnCheckedChangeListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCheckedChanged ( CompoundButton button , boolean checked ) { </a> 0
<a> isChecked [ button . getId ( ) ] = checked ; </a> 0
<a> String field = button . getText ( ) . toString ( ) ; </a> 0
<a> if ( checked ) { </a> 0
<a> fieldsVector . add ( field ) ; </a> 0
<a> } else if ( fieldsVector . contains ( field ) ) { </a> 0
<a> fieldsVector . remove ( field ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> return hView ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> class ViewHolder { </a> 0
<a> CheckBox checkbox ; </a> 0
<a> TextView fieldsInfo ; </a> 0
<a> } </a> 0
<a> public class ConnectionsListAdapter extends BaseAdapter { </a> 0
<a> private LayoutInflater mInflater ; </a> 0
<a> public ConnectionsListAdapter ( ) { </a> 0
<a> mInflater = LayoutInflater . from ( explorerActivity . getBaseContext ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getCount ( ) { </a> 0
<a> return connectionsArray . size ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object getItem ( int position ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getItemId ( int position ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View getView ( int position , View convertView , ViewGroup parent ) { </a> 0
<a> View hView = convertView ; </a> 0
<a> TextView connection ; </a> 0
<a> if ( hView == null ) { </a> 0
<a> hView = mInflater . inflate ( R . layout . connection_item , null ) ; </a> 0
<a> connection = ( TextView ) hView . findViewById ( R . id . connection_name ) ; </a> 0
<a> hView . setTag ( connection ) ; </a> 0
<a> } else { </a> 0
<a> connection = ( TextView ) hView . getTag ( ) ; </a> 0
<a> } </a> 0
<a> SpannableString name ; </a> 0
<a> name = new SpannableString ( connectionsArray . get ( position ) ) ; </a> 0
<a> name . setSpan ( new UnderlineSpan ( ) , 0 , name . length ( ) , 0 ) ; </a> 0
<a> connection . setText ( name ) ; </a> 0
<a> return hView ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . SharedPreferences ; </a> 0
<a> import android . content . SharedPreferences . Editor ; </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public class SessionStore { </a> 0
<a> private static final String TOKEN = "access_token" ; </a> 0
<a> private static final String EXPIRES = "expires_in" ; </a> 0
<a> private static final String LAST_UPDATE = "last_update" ; </a> 0
<a> private static final String KEY = "facebook-session" ; </a> 0
<a> public static boolean save ( Facebook session , Context context ) { </a> 0
<a> Editor editor = context . getSharedPreferences ( KEY , Context . MODE_PRIVATE ) . edit ( ) ; </a> 0
<a> editor . putString ( TOKEN , session . getAccessToken ( ) ) ; </a> 0
<a> editor . putLong ( EXPIRES , session . getAccessExpires ( ) ) ; </a> 0
<a> editor . putLong ( LAST_UPDATE , session . getLastAccessUpdate ( ) ) ; </a> 0
<a> return editor . commit ( ) ; </a> 0
<a> } </a> 0
<a> public static boolean restore ( Facebook session , Context context ) { </a> 0
<a> SharedPreferences savedSession = context . getSharedPreferences ( KEY , Context . MODE_PRIVATE ) ; </a> 0
<a> session . setTokenFromCache ( </a> 0
<a> savedSession . getString ( TOKEN , null ) , </a> 0
<a> savedSession . getLong ( EXPIRES , 0 ) , </a> 0
<a> savedSession . getLong ( LAST_UPDATE , 0 ) ) ; </a> 0
<a> return session . isSessionValid ( ) ; </a> 0
<a> } </a> 0
<a> public static void clear ( Context context ) { </a> 0
<a> Editor editor = context . getSharedPreferences ( KEY , Context . MODE_PRIVATE ) . edit ( ) ; </a> 0
<a> editor . clear ( ) ; </a> 0
<a> editor . commit ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import java . util . Timer ; </a> 0
<a> import java . util . TimerTask ; </a> 0
<a> public class SplashActivity extends Activity { </a> 0
<a> private long splashDelay = 1500 ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . splash ) ; </a> 0
<a> TimerTask task = new TimerTask ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> finish ( ) ; </a> 0
<a> Intent hackbookIntent = new Intent ( ) . setClass ( SplashActivity . this , Hackbook . class ) ; </a> 0
<a> startActivity ( hackbookIntent ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> Timer timer = new Timer ( ) ; </a> 0
<a> timer . schedule ( task , splashDelay ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . scrumptious ; </a> 0
<a> import android . app . AlertDialog ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . DialogInterface ; </a> 0
<a> import android . location . Criteria ; </a> 0
<a> import android . location . Location ; </a> 0
<a> import android . location . LocationListener ; </a> 0
<a> import android . location . LocationManager ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . os . Build ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Looper ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> import android . support . v4 . app . FragmentManager ; </a> 0
<a> import com . facebook . FacebookException ; </a> 0
<a> import com . facebook . widget . FriendPickerFragment ; </a> 0
<a> import com . facebook . widget . PickerFragment ; </a> 0
<a> import com . facebook . widget . PlacePickerFragment ; </a> 0
<a> public class PickerActivity extends FragmentActivity { </a> 0
<a> public static final Uri FRIEND_PICKER = Uri . parse ( "picker://friend" ) ; </a> 0
<a> public static final Uri PLACE_PICKER = Uri . parse ( "picker://place" ) ; </a> 0
<a> private static final int SEARCH_RADIUS_METERS = 1000 ; </a> 0
<a> private static final int SEARCH_RESULT_LIMIT = 50 ; </a> 0
<a> private static final String SEARCH_TEXT = "Restaurant" ; </a> 0
<a> private static final int LOCATION_CHANGE_THRESHOLD = 50 ; </a> 0
<a> private static final Location SAN_FRANCISCO_LOCATION = new Location ( "" ) { { </a> 0
<a> setLatitude ( 37.7750 ) ; </a> 0
<a> setLongitude ( - 122.4183 ) ; </a> 0
<a> } } ; </a> 0
<a> private FriendPickerFragment friendPickerFragment ; </a> 0
<a> private PlacePickerFragment placePickerFragment ; </a> 0
<a> private LocationListener locationListener ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . pickers ) ; </a> 0
<a> Bundle args = getIntent ( ) . getExtras ( ) ; </a> 0
<a> FragmentManager manager = getSupportFragmentManager ( ) ; </a> 0
<a> Fragment fragmentToShow = null ; </a> 0
<a> Uri intentUri = getIntent ( ) . getData ( ) ; </a> 0
<a> if ( FRIEND_PICKER . equals ( intentUri ) ) { </a> 0
<a> if ( savedInstanceState == null ) { </a> 0
<a> friendPickerFragment = new FriendPickerFragment ( args ) ; </a> 0
<a> } else { </a> 0
<a> friendPickerFragment = ( FriendPickerFragment ) manager . findFragmentById ( R . id . picker_fragment ) ; ; </a> 0
<a> } </a> 0
<a> friendPickerFragment . setOnErrorListener ( new PickerFragment . OnErrorListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onError ( PickerFragment < ? > fragment , FacebookException error ) { </a> 0
<a> PickerActivity . this . onError ( error ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> friendPickerFragment . setOnDoneButtonClickedListener ( new PickerFragment . OnDoneButtonClickedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onDoneButtonClicked ( PickerFragment < ? > fragment ) { </a> 0
<a> finishActivity ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> fragmentToShow = friendPickerFragment ; </a> 0
<a> } else if ( PLACE_PICKER . equals ( intentUri ) ) { </a> 0
<a> if ( savedInstanceState == null ) { </a> 0
<a> placePickerFragment = new PlacePickerFragment ( args ) ; </a> 0
<a> } else { </a> 0
<a> placePickerFragment = ( PlacePickerFragment ) manager . findFragmentById ( R . id . picker_fragment ) ; </a> 0
<a> } </a> 0
<a> placePickerFragment . setOnSelectionChangedListener ( new PickerFragment . OnSelectionChangedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onSelectionChanged ( PickerFragment < ? > fragment ) { </a> 0
<a> finishActivity ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> placePickerFragment . setOnErrorListener ( new PickerFragment . OnErrorListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onError ( PickerFragment < ? > fragment , FacebookException error ) { </a> 0
<a> PickerActivity . this . onError ( error ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> placePickerFragment . setOnDoneButtonClickedListener ( new PickerFragment . OnDoneButtonClickedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onDoneButtonClicked ( PickerFragment < ? > fragment ) { </a> 0
<a> finishActivity ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> fragmentToShow = placePickerFragment ; </a> 0
<a> } else { </a> 0
<a> setResult ( RESULT_CANCELED ) ; </a> 0
<a> finish ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> manager . beginTransaction ( ) . replace ( R . id . picker_fragment , fragmentToShow ) . commit ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onStart ( ) { </a> 0
<a> super . onStart ( ) ; </a> 0
<a> if ( FRIEND_PICKER . equals ( getIntent ( ) . getData ( ) ) ) { </a> 0
<a> try { </a> 0
<a> friendPickerFragment . loadData ( false ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> onError ( ex ) ; </a> 0
<a> } </a> 0
<a> } else if ( PLACE_PICKER . equals ( getIntent ( ) . getData ( ) ) ) { </a> 0
<a> try { </a> 0
<a> Location location = null ; </a> 0
<a> Criteria criteria = new Criteria ( ) ; </a> 0
<a> LocationManager locationManager = ( LocationManager ) getSystemService ( Context . LOCATION_SERVICE ) ; </a> 0
<a> String bestProvider = locationManager . getBestProvider ( criteria , false ) ; </a> 0
<a> if ( bestProvider != null ) { </a> 0
<a> location = locationManager . getLastKnownLocation ( bestProvider ) ; </a> 0
<a> if ( locationManager . isProviderEnabled ( bestProvider ) && locationListener == null ) { </a> 0
<a> locationListener = new LocationListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onLocationChanged ( Location location ) { </a> 0
<a> float distance = location . distanceTo ( placePickerFragment . getLocation ( ) ) ; </a> 0
<a> if ( distance >= LOCATION_CHANGE_THRESHOLD ) { </a> 0
<a> placePickerFragment . setLocation ( location ) ; </a> 0
<a> placePickerFragment . loadData ( true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onStatusChanged ( String s , int i , Bundle bundle ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onProviderEnabled ( String s ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onProviderDisabled ( String s ) { </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> locationManager . requestLocationUpdates ( bestProvider , 1 , LOCATION_CHANGE_THRESHOLD , </a> 0
<a> locationListener , Looper . getMainLooper ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( location == null ) { </a> 0
<a> String model = Build . MODEL ; </a> 0
<a> if ( model . equals ( "sdk" ) || model . equals ( "google_sdk" ) || model . contains ( "x86" ) ) { </a> 0
<a> location = SAN_FRANCISCO_LOCATION ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( location != null ) { </a> 0
<a> placePickerFragment . setLocation ( location ) ; </a> 0
<a> placePickerFragment . setRadiusInMeters ( SEARCH_RADIUS_METERS ) ; </a> 0
<a> placePickerFragment . setSearchText ( SEARCH_TEXT ) ; </a> 0
<a> placePickerFragment . setResultsLimit ( SEARCH_RESULT_LIMIT ) ; </a> 0
<a> placePickerFragment . loadData ( false ) ; </a> 0
<a> } else { </a> 0
<a> onError ( getResources ( ) . getString ( R . string . no_location_error ) , true ) ; </a> 0
<a> } </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> onError ( ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onStop ( ) { </a> 0
<a> super . onStop ( ) ; </a> 0
<a> if ( locationListener != null ) { </a> 0
<a> LocationManager locationManager = ( LocationManager ) getSystemService ( Context . LOCATION_SERVICE ) ; </a> 0
<a> locationManager . removeUpdates ( locationListener ) ; </a> 0
<a> locationListener = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onError ( Exception error ) { </a> 0
<a> onError ( error . getLocalizedMessage ( ) , false ) ; </a> 1
<a> } </a> 0
<a> private void onError ( String error , final boolean finishActivity ) { </a> 0
<a> AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; </a> 0
<a> builder . setTitle ( R . string . error_dialog_title ) . </a> 0
<a> setMessage ( error ) . </a> 0
<a> setPositiveButton ( R . string . error_dialog_button_text , new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialogInterface , int i ) { </a> 0
<a> if ( finishActivity ) { </a> 0
<a> finishActivity ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> builder . show ( ) ; </a> 0
<a> } </a> 0
<a> private void finishActivity ( ) { </a> 0
<a> ScrumptiousApplication app = ( ScrumptiousApplication ) getApplication ( ) ; </a> 0
<a> if ( FRIEND_PICKER . equals ( getIntent ( ) . getData ( ) ) ) { </a> 0
<a> if ( friendPickerFragment != null ) { </a> 0
<a> app . setSelectedUsers ( friendPickerFragment . getSelection ( ) ) ; </a> 0
<a> } </a> 0
<a> } else if ( PLACE_PICKER . equals ( getIntent ( ) . getData ( ) ) ) { </a> 0
<a> if ( placePickerFragment != null ) { </a> 0
<a> app . setSelectedPlace ( placePickerFragment . getSelection ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> setResult ( RESULT_OK , null ) ; </a> 0
<a> finish ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . scrumptious ; </a> 0
<a> import android . app . Application ; </a> 0
<a> import com . facebook . model . GraphPlace ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class ScrumptiousApplication extends Application { </a> 0
<a> private List < GraphUser > selectedUsers ; </a> 0
<a> private GraphPlace selectedPlace ; </a> 0
<a> public List < GraphUser > getSelectedUsers ( ) { </a> 0
<a> return selectedUsers ; </a> 0
<a> } </a> 0
<a> public void setSelectedUsers ( List < GraphUser > users ) { </a> 0
<a> selectedUsers = users ; </a> 0
<a> } </a> 0
<a> public GraphPlace getSelectedPlace ( ) { </a> 0
<a> return selectedPlace ; </a> 0
<a> } </a> 0
<a> public void setSelectedPlace ( GraphPlace place ) { </a> 0
<a> this . selectedPlace = place ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . switchuser ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> public class Slot { </a> 0
<a> private static final String CACHE_NAME_FORMAT = "TokenCache%d" ; </a> 0
<a> private static final String CACHE_USER_ID_KEY = "SwitchUserSampleUserId" ; </a> 0
<a> private static final String CACHE_USER_NAME_KEY = "SwitchUserSampleUserName" ; </a> 0
<a> private String tokenCacheName ; </a> 0
<a> private String userName ; </a> 0
<a> private String userId ; </a> 0
<a> private SharedPreferencesTokenCachingStrategy tokenCache ; </a> 0
<a> private SessionLoginBehavior loginBehavior ; </a> 0
<a> public Slot ( Context context , int slotNumber , SessionLoginBehavior loginBehavior ) { </a> 0
<a> this . loginBehavior = loginBehavior ; </a> 0
<a> this . tokenCacheName = String . format ( CACHE_NAME_FORMAT , slotNumber ) ; </a> 0
<a> this . tokenCache = new SharedPreferencesTokenCachingStrategy ( </a> 0
<a> context , </a> 0
<a> tokenCacheName ) ; </a> 0
<a> restore ( ) ; </a> 0
<a> } </a> 0
<a> public String getTokenCacheName ( ) { </a> 0
<a> return tokenCacheName ; </a> 0
<a> } </a> 0
<a> public String getUserName ( ) { </a> 0
<a> return userName ; </a> 0
<a> } </a> 0
<a> public String getUserId ( ) { </a> 0
<a> return userId ; </a> 0
<a> } </a> 0
<a> public SessionLoginBehavior getLoginBehavior ( ) { </a> 0
<a> return loginBehavior ; </a> 0
<a> } </a> 0
<a> public SharedPreferencesTokenCachingStrategy getTokenCache ( ) { </a> 0
<a> return tokenCache ; </a> 0
<a> } </a> 0
<a> public void update ( GraphUser user ) { </a> 0
<a> if ( user == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> userId = user . getId ( ) ; </a> 0
<a> userName = user . getName ( ) ; </a> 0
<a> Bundle userInfo = tokenCache . load ( ) ; </a> 0
<a> userInfo . putString ( CACHE_USER_ID_KEY , userId ) ; </a> 0
<a> userInfo . putString ( CACHE_USER_NAME_KEY , userName ) ; </a> 0
<a> tokenCache . save ( userInfo ) ; </a> 0
<a> } </a> 0
<a> public void clear ( ) { </a> 0
<a> tokenCache . clear ( ) ; </a> 0
<a> restore ( ) ; </a> 0
<a> } </a> 0
<a> private void restore ( ) { </a> 0
<a> Bundle userInfo = tokenCache . load ( ) ; </a> 0
<a> userId = userInfo . getString ( CACHE_USER_ID_KEY ) ; </a> 0
<a> userName = userInfo . getString ( CACHE_USER_NAME_KEY ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> import java . io . InputStream ; </a> 1
<a> import java . io . OutputStream ; </a> 1
<a> import java . nio . ByteBuffer ; </a> 1
<a> import java . nio . ByteOrder ; </a> 1
<a> import java . nio . channels . ClosedChannelException ; </a> 1
<a> import java . nio . channels . GatheringByteChannel ; </a> 1
<a> import java . nio . channels . ScatteringByteChannel ; </a> 1
<a> public class HeapByteBuf extends AbstractByteBuf { </a> 1
<a> private final Unsafe unsafe = new HeapUnsafe ( ) ; </a> 1
<a> private byte [ ] array ; </a> 1
<a> private ByteBuffer nioBuf ; </a> 1
<a> public HeapByteBuf ( int initialCapacity , int maxCapacity ) { </a> 1
<a> this ( new byte [ initialCapacity ] , 0 , 0 , maxCapacity ) ; </a> 1
<a> } </a> 1
<a> public HeapByteBuf ( byte [ ] initialArray , int maxCapacity ) { </a> 1
<a> this ( initialArray , 0 , initialArray . length , maxCapacity ) ; </a> 1
<a> } </a> 1
<a> private HeapByteBuf ( byte [ ] initialArray , int readerIndex , int writerIndex , int maxCapacity ) { </a> 1
<a> super ( ByteOrder . BIG_ENDIAN , maxCapacity ) ; </a> 1
<a> if ( initialArray == null ) { </a> 1
<a> throw new NullPointerException ( "initialArray" ) ; </a> 1
<a> } </a> 0
<a> if ( initialArray . length > maxCapacity ) { </a> 1
<a> throw new IllegalArgumentException ( String . format ( </a> 1
<a> "initialCapacity(%d) > maxCapacity(%d)" , initialArray . length , maxCapacity ) ) ; </a> 1
<a> } </a> 1
<a> setArray ( initialArray ) ; </a> 1
<a> setIndex ( readerIndex , writerIndex ) ; </a> 1
<a> } </a> 1
<a> private void setArray ( byte [ ] initialArray ) { </a> 1
<a> array = initialArray ; </a> 1
<a> nioBuf = ByteBuffer . wrap ( initialArray ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isDirect ( ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int capacity ( ) { </a> 1
<a> return array . length ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void capacity ( int newCapacity ) { </a> 0
<a> if ( newCapacity < 0 || newCapacity > maxCapacity ( ) ) { </a> 1
<a> throw new IllegalArgumentException ( "newCapacity: " + newCapacity ) ; </a> 1
<a> } </a> 1
<a> int oldCapacity = array . length ; </a> 1
<a> if ( newCapacity > oldCapacity ) { </a> 1
<a> byte [ ] newArray = new byte [ newCapacity ] ; </a> 1
<a> System . arraycopy ( array , readerIndex ( ) , newArray , readerIndex ( ) , readableBytes ( ) ) ; </a> 1
<a> setArray ( newArray ) ; </a> 1
<a> } else if ( newCapacity < oldCapacity ) { </a> 1
<a> byte [ ] newArray = new byte [ newCapacity ] ; </a> 1
<a> int readerIndex = readerIndex ( ) ; </a> 1
<a> if ( readerIndex < newCapacity ) { </a> 1
<a> int writerIndex = writerIndex ( ) ; </a> 1
<a> if ( writerIndex > newCapacity ) { </a> 1
<a> writerIndex ( writerIndex = newCapacity ) ; </a> 1
<a> } </a> 1
<a> System . arraycopy ( array , readerIndex , newArray , readerIndex , writerIndex - readerIndex ) ; </a> 1
<a> } else { </a> 1
<a> setIndex ( newCapacity , newCapacity ) ; </a> 1
<a> } </a> 1
<a> setArray ( newArray ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean hasArray ( ) { </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public byte [ ] array ( ) { </a> 1
<a> return array ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int arrayOffset ( ) { </a> 1
<a> return 0 ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public byte getByte ( int index ) { </a> 1
<a> return array [ index ] ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void getBytes ( int index , ByteBuf dst , int dstIndex , int length ) { </a> 0
<a> if ( dst instanceof HeapByteBuf ) { </a> 1
<a> getBytes ( index , ( ( HeapByteBuf ) dst ) . array , dstIndex , length ) ; </a> 1
<a> } else { </a> 1
<a> dst . setBytes ( dstIndex , array , index , length ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void getBytes ( int index , byte [ ] dst , int dstIndex , int length ) { </a> 0
<a> System . arraycopy ( array , index , dst , dstIndex , length ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void getBytes ( int index , ByteBuffer dst ) { </a> 0
<a> dst . put ( array , index , Math . min ( capacity ( ) - index , dst . remaining ( ) ) ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void getBytes ( int index , OutputStream out , int length ) </a> 0
<a> throws IOException { </a> 1
<a> out . write ( array , index , length ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getBytes ( int index , GatheringByteChannel out , int length ) </a> 1
<a> throws IOException { </a> 1
<a> return out . write ( ( ByteBuffer ) nioBuf . clear ( ) . position ( index ) . limit ( index + length ) ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setByte ( int index , int value ) { </a> 0
<a> array [ index ] = ( byte ) value ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setBytes ( int index , ByteBuf src , int srcIndex , int length ) { </a> 0
<a> if ( src instanceof HeapByteBuf ) { </a> 1
<a> setBytes ( index , ( ( HeapByteBuf ) src ) . array , srcIndex , length ) ; </a> 1
<a> } else { </a> 1
<a> src . getBytes ( srcIndex , array , index , length ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setBytes ( int index , byte [ ] src , int srcIndex , int length ) { </a> 0
<a> System . arraycopy ( src , srcIndex , array , index , length ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setBytes ( int index , ByteBuffer src ) { </a> 0
<a> src . get ( array , index , src . remaining ( ) ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int setBytes ( int index , InputStream in , int length ) throws IOException { </a> 1
<a> return in . read ( array , index , length ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int setBytes ( int index , ScatteringByteChannel in , int length ) throws IOException { </a> 1
<a> try { </a> 1
<a> return in . read ( ( ByteBuffer ) nioBuf . clear ( ) . position ( index ) . limit ( index + length ) ) ; </a> 1
<a> } catch ( ClosedChannelException e ) { </a> 1
<a> return - 1 ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean hasNioBuffer ( ) { </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer nioBuffer ( int index , int length ) { </a> 1
<a> return ByteBuffer . wrap ( array , index , length ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean hasNioBuffers ( ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( int offset , int length ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public short getShort ( int index ) { </a> 0
<a> return ( short ) ( array [ index ] < < 8 | array [ index + 1 ] & 0xFF ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getUnsignedMedium ( int index ) { </a> 0
<a> return ( array [ index ] & 0xff ) < < 16 | </a> 0
<a> ( array [ index + 1 ] & 0xff ) < < 8 | </a> 0
<a> ( array [ index + 2 ] & 0xff ) < < 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getInt ( int index ) { </a> 0
<a> return ( array [ index ] & 0xff ) < < 24 | </a> 0
<a> ( array [ index + 1 ] & 0xff ) < < 16 | </a> 0
<a> ( array [ index + 2 ] & 0xff ) < < 8 | </a> 0
<a> ( array [ index + 3 ] & 0xff ) < < 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getLong ( int index ) { </a> 0
<a> return ( ( long ) array [ index ] & 0xff ) < < 56 | </a> 0
<a> ( ( long ) array [ index + 1 ] & 0xff ) < < 48 | </a> 0
<a> ( ( long ) array [ index + 2 ] & 0xff ) < < 40 | </a> 0
<a> ( ( long ) array [ index + 3 ] & 0xff ) < < 32 | </a> 0
<a> ( ( long ) array [ index + 4 ] & 0xff ) < < 24 | </a> 0
<a> ( ( long ) array [ index + 5 ] & 0xff ) < < 16 | </a> 0
<a> ( ( long ) array [ index + 6 ] & 0xff ) < < 8 | </a> 0
<a> ( ( long ) array [ index + 7 ] & 0xff ) < < 0 ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setShort ( int index , int value ) { </a> 0
<a> array [ index ] = ( byte ) ( value > > > 8 ) ; </a> 1
<a> array [ index + 1 ] = ( byte ) ( value > > > 0 ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setMedium ( int index , int value ) { </a> 0
<a> array [ index ] = ( byte ) ( value > > > 16 ) ; </a> 1
<a> array [ index + 1 ] = ( byte ) ( value > > > 8 ) ; </a> 1
<a> array [ index + 2 ] = ( byte ) ( value > > > 0 ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setInt ( int index , int value ) { </a> 0
<a> array [ index ] = ( byte ) ( value > > > 24 ) ; </a> 0
<a> array [ index + 1 ] = ( byte ) ( value > > > 16 ) ; </a> 0
<a> array [ index + 2 ] = ( byte ) ( value > > > 8 ) ; </a> 0
<a> array [ index + 3 ] = ( byte ) ( value > > > 0 ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setLong ( int index , long value ) { </a> 0
<a> array [ index ] = ( byte ) ( value > > > 56 ) ; </a> 0
<a> array [ index + 1 ] = ( byte ) ( value > > > 48 ) ; </a> 0
<a> array [ index + 2 ] = ( byte ) ( value > > > 40 ) ; </a> 0
<a> array [ index + 3 ] = ( byte ) ( value > > > 32 ) ; </a> 0
<a> array [ index + 4 ] = ( byte ) ( value > > > 24 ) ; </a> 0
<a> array [ index + 5 ] = ( byte ) ( value > > > 16 ) ; </a> 0
<a> array [ index + 6 ] = ( byte ) ( value > > > 8 ) ; </a> 0
<a> array [ index + 7 ] = ( byte ) ( value > > > 0 ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf copy ( int index , int length ) { </a> 0
<a> if ( index < 0 || length < 0 || index + length > array . length ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to copy - Need " </a> 0
<a> + ( index + length ) + ", maximum is " + array . length ) ; </a> 0
<a> } </a> 0
<a> byte [ ] copiedArray = new byte [ length ] ; </a> 0
<a> System . arraycopy ( array , index , copiedArray , 0 , length ) ; </a> 0
<a> return new HeapByteBuf ( copiedArray , maxCapacity ( ) ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public Unsafe unsafe ( ) { </a> 1
<a> return unsafe ; </a> 1
<a> } </a> 1
<a> private class HeapUnsafe implements Unsafe { </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer nioBuffer ( ) { </a> 1
<a> return nioBuf ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf newBuffer ( int initialCapacity ) { </a> 1
<a> return new HeapByteBuf ( initialCapacity , Math . max ( initialCapacity , maxCapacity ( ) ) ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void discardSomeReadBytes ( ) { </a> 1
<a> final int readerIndex = readerIndex ( ) ; </a> 1
<a> if ( readerIndex == writerIndex ( ) ) { </a> 1
<a> discardReadBytes ( ) ; </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> if ( readerIndex > 0 && readerIndex >= capacity ( ) > > > 1 ) { </a> 1
<a> discardReadBytes ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void acquire ( ) { </a> 1
<a> if ( refCnt <= 0 ) { </a> 1
<a> throw new IllegalStateException ( ) ; </a> 1
<a> } </a> 1
<a> refCnt ++ ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void release ( ) { </a> 1
<a> if ( refCnt <= 0 ) { </a> 1
<a> throw new IllegalStateException ( ) ; </a> 1
<a> } </a> 1
<a> refCnt -- ; </a> 1
<a> if ( refCnt == 0 ) { </a> 1
<a> array = null ; </a> 1
<a> nioBuf = null ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . ReadOnlyBufferException ; </a> 0
<a> import java . nio . channels . GatheringByteChannel ; </a> 0
<a> import java . nio . channels . ScatteringByteChannel ; </a> 0
<a> public class ReadOnlyByteBuf extends AbstractByteBuf implements WrappedByteBuf { </a> 0
<a> private final ByteBuf buffer ; </a> 1
<a> public ReadOnlyByteBuf ( ByteBuf buffer ) { </a> 1
<a> super ( buffer . order ( ) , buffer . maxCapacity ( ) ) ; </a> 1
<a> this . buffer = buffer ; </a> 1
<a> setIndex ( buffer . readerIndex ( ) , buffer . writerIndex ( ) ) ; </a> 1
<a> } </a> 0
<a> private ReadOnlyByteBuf ( ReadOnlyByteBuf buffer ) { </a> 1
<a> super ( buffer . buffer . order ( ) , buffer . maxCapacity ( ) ) ; </a> 1
<a> this . buffer = buffer . buffer ; </a> 1
<a> setIndex ( buffer . readerIndex ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf unwrap ( ) { </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDirect ( ) { </a> 0
<a> return buffer . isDirect ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasArray ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte [ ] array ( ) { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int arrayOffset ( ) { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void discardReadBytes ( ) { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setByte ( int index , int value ) { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuf src , int srcIndex , int length ) { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , byte [ ] src , int srcIndex , int length ) { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuffer src ) { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setShort ( int index , int value ) { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setMedium ( int index , int value ) { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setInt ( int index , int value ) { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setLong ( int index , long value ) { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , InputStream in , int length ) </a> 0
<a> throws IOException { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , ScatteringByteChannel in , int length ) </a> 0
<a> throws IOException { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getBytes ( int index , GatheringByteChannel out , int length ) </a> 0
<a> throws IOException { </a> 0
<a> return buffer . getBytes ( index , out , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , OutputStream out , int length ) </a> 0
<a> throws IOException { </a> 0
<a> buffer . getBytes ( index , out , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , byte [ ] dst , int dstIndex , int length ) { </a> 0
<a> buffer . getBytes ( index , dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuf dst , int dstIndex , int length ) { </a> 0
<a> buffer . getBytes ( index , dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuffer dst ) { </a> 0
<a> buffer . getBytes ( index , dst ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf duplicate ( ) { </a> 0
<a> return new ReadOnlyByteBuf ( this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf copy ( int index , int length ) { </a> 0
<a> return buffer . copy ( index , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf slice ( int index , int length ) { </a> 0
<a> return new ReadOnlyByteBuf ( buffer . slice ( index , length ) ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte getByte ( int index ) { </a> 0
<a> return buffer . getByte ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short getShort ( int index ) { </a> 0
<a> return buffer . getShort ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getUnsignedMedium ( int index ) { </a> 0
<a> return buffer . getUnsignedMedium ( index ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getInt ( int index ) { </a> 1
<a> return buffer . getInt ( index ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public long getLong ( int index ) { </a> 1
<a> return buffer . getLong ( index ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean hasNioBuffer ( ) { </a> 1
<a> return buffer . hasNioBuffer ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuffer nioBuffer ( int index , int length ) { </a> 0
<a> return buffer . nioBuffer ( index , length ) . asReadOnlyBuffer ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNioBuffers ( ) { </a> 1
<a> return buffer . hasNioBuffers ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( int offset , int length ) { </a> 1
<a> return buffer . nioBuffers ( offset , length ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public int capacity ( ) { </a> 0
<a> return buffer . capacity ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void capacity ( int newCapacity ) { </a> 0
<a> throw new ReadOnlyBufferException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Unsafe unsafe ( ) { </a> 1
<a> return buffer . unsafe ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import static io . netty . buffer . Unpooled . * ; </a> 1
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . io . ByteArrayInputStream ; </a> 0
<a> import java . io . ByteArrayOutputStream ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> import java . util . HashSet ; </a> 0
<a> import java . util . Random ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import org . junit . After ; </a> 1
<a> import org . junit . Assume ; </a> 1
<a> import org . junit . Before ; </a> 1
<a> import org . junit . Test ; </a> 1
<a> public abstract class AbstractChannelBufferTest { </a> 0
<a> private static final int CAPACITY = 4096 ; </a> 0
<a> private static final int BLOCK_SIZE = 128 ; </a> 0
<a> private long seed ; </a> 0
<a> private Random random ; </a> 0
<a> private ByteBuf buffer ; </a> 0
<a> protected abstract ByteBuf newBuffer ( int capacity ) ; </a> 0
<a> protected abstract ByteBuf [ ] components ( ) ; </a> 0
<a> protected boolean discardReadBytesDoesNotMoveWritableBytes ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Before </a> 0
<a> public void init ( ) { </a> 0
<a> buffer = newBuffer ( CAPACITY ) ; </a> 0
<a> seed = System . currentTimeMillis ( ) ; </a> 0
<a> random = new Random ( seed ) ; </a> 0
<a> } </a> 0
<a> @ After </a> 0
<a> public void dispose ( ) { </a> 0
<a> buffer = null ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void initialState ( ) { </a> 0
<a> assertEquals ( CAPACITY , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void readerIndexBoundaryCheck1 ( ) { </a> 0
<a> try { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> } catch ( IndexOutOfBoundsException e ) { </a> 0
<a> fail ( ) ; </a> 0
<a> } </a> 0
<a> buffer . readerIndex ( - 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void readerIndexBoundaryCheck2 ( ) { </a> 0
<a> try { </a> 0
<a> buffer . writerIndex ( buffer . capacity ( ) ) ; </a> 0
<a> } catch ( IndexOutOfBoundsException e ) { </a> 0
<a> fail ( ) ; </a> 0
<a> } </a> 0
<a> buffer . readerIndex ( buffer . capacity ( ) + 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void readerIndexBoundaryCheck3 ( ) { </a> 0
<a> try { </a> 0
<a> buffer . writerIndex ( CAPACITY / 2 ) ; </a> 0
<a> } catch ( IndexOutOfBoundsException e ) { </a> 0
<a> fail ( ) ; </a> 0
<a> } </a> 0
<a> buffer . readerIndex ( CAPACITY * 3 / 2 ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void readerIndexBoundaryCheck4 ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> buffer . readerIndex ( 0 ) ; </a> 0
<a> buffer . writerIndex ( buffer . capacity ( ) ) ; </a> 0
<a> buffer . readerIndex ( buffer . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void writerIndexBoundaryCheck1 ( ) { </a> 0
<a> buffer . writerIndex ( - 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void writerIndexBoundaryCheck2 ( ) { </a> 0
<a> try { </a> 0
<a> buffer . writerIndex ( CAPACITY ) ; </a> 0
<a> buffer . readerIndex ( CAPACITY ) ; </a> 0
<a> } catch ( IndexOutOfBoundsException e ) { </a> 0
<a> fail ( ) ; </a> 0
<a> } </a> 0
<a> buffer . writerIndex ( buffer . capacity ( ) + 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void writerIndexBoundaryCheck3 ( ) { </a> 0
<a> try { </a> 0
<a> buffer . writerIndex ( CAPACITY ) ; </a> 0
<a> buffer . readerIndex ( CAPACITY / 2 ) ; </a> 0
<a> } catch ( IndexOutOfBoundsException e ) { </a> 0
<a> fail ( ) ; </a> 0
<a> } </a> 0
<a> buffer . writerIndex ( CAPACITY / 4 ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void writerIndexBoundaryCheck4 ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> buffer . readerIndex ( 0 ) ; </a> 0
<a> buffer . writerIndex ( CAPACITY ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getBooleanBoundaryCheck1 ( ) { </a> 0
<a> buffer . getBoolean ( - 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getBooleanBoundaryCheck2 ( ) { </a> 0
<a> buffer . getBoolean ( buffer . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getByteBoundaryCheck1 ( ) { </a> 0
<a> buffer . getByte ( - 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getByteBoundaryCheck2 ( ) { </a> 0
<a> buffer . getByte ( buffer . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getShortBoundaryCheck1 ( ) { </a> 0
<a> buffer . getShort ( - 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getShortBoundaryCheck2 ( ) { </a> 0
<a> buffer . getShort ( buffer . capacity ( ) - 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getMediumBoundaryCheck1 ( ) { </a> 0
<a> buffer . getMedium ( - 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getMediumBoundaryCheck2 ( ) { </a> 0
<a> buffer . getMedium ( buffer . capacity ( ) - 2 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getIntBoundaryCheck1 ( ) { </a> 0
<a> buffer . getInt ( - 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getIntBoundaryCheck2 ( ) { </a> 0
<a> buffer . getInt ( buffer . capacity ( ) - 3 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getLongBoundaryCheck1 ( ) { </a> 0
<a> buffer . getLong ( - 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getLongBoundaryCheck2 ( ) { </a> 0
<a> buffer . getLong ( buffer . capacity ( ) - 7 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getByteArrayBoundaryCheck1 ( ) { </a> 0
<a> buffer . getBytes ( - 1 , new byte [ 0 ] ) ; </a> 1
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getByteArrayBoundaryCheck2 ( ) { </a> 0
<a> buffer . getBytes ( - 1 , new byte [ 0 ] , 0 , 0 ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void getByteArrayBoundaryCheck3 ( ) { </a> 0
<a> byte [ ] dst = new byte [ 4 ] ; </a> 0
<a> buffer . setInt ( 0 , 0x01020304 ) ; </a> 0
<a> try { </a> 0
<a> buffer . getBytes ( 0 , dst , - 1 , 4 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( IndexOutOfBoundsException e ) { </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , dst [ 0 ] ) ; </a> 0
<a> assertEquals ( 0 , dst [ 1 ] ) ; </a> 0
<a> assertEquals ( 0 , dst [ 2 ] ) ; </a> 0
<a> assertEquals ( 0 , dst [ 3 ] ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void getByteArrayBoundaryCheck4 ( ) { </a> 0
<a> byte [ ] dst = new byte [ 4 ] ; </a> 0
<a> buffer . setInt ( 0 , 0x01020304 ) ; </a> 0
<a> try { </a> 0
<a> buffer . getBytes ( 0 , dst , 1 , 4 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( IndexOutOfBoundsException e ) { </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , dst [ 0 ] ) ; </a> 0
<a> assertEquals ( 0 , dst [ 1 ] ) ; </a> 0
<a> assertEquals ( 0 , dst [ 2 ] ) ; </a> 0
<a> assertEquals ( 0 , dst [ 3 ] ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getByteBufferBoundaryCheck ( ) { </a> 0
<a> buffer . getBytes ( - 1 , ByteBuffer . allocate ( 0 ) ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void copyBoundaryCheck1 ( ) { </a> 0
<a> buffer . copy ( - 1 , 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void copyBoundaryCheck2 ( ) { </a> 0
<a> buffer . copy ( 0 , buffer . capacity ( ) + 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void copyBoundaryCheck3 ( ) { </a> 0
<a> buffer . copy ( buffer . capacity ( ) + 1 , 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void copyBoundaryCheck4 ( ) { </a> 0
<a> buffer . copy ( buffer . capacity ( ) , 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void setIndexBoundaryCheck1 ( ) { </a> 0
<a> buffer . setIndex ( - 1 , CAPACITY ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void setIndexBoundaryCheck2 ( ) { </a> 0
<a> buffer . setIndex ( CAPACITY / 2 , CAPACITY / 4 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void setIndexBoundaryCheck3 ( ) { </a> 0
<a> buffer . setIndex ( 0 , CAPACITY + 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void getByteBufferState ( ) { </a> 0
<a> ByteBuffer dst = ByteBuffer . allocate ( 4 ) ; </a> 0
<a> dst . position ( 1 ) ; </a> 0
<a> dst . limit ( 3 ) ; </a> 0
<a> buffer . setByte ( 0 , ( byte ) 1 ) ; </a> 0
<a> buffer . setByte ( 1 , ( byte ) 2 ) ; </a> 0
<a> buffer . setByte ( 2 , ( byte ) 3 ) ; </a> 0
<a> buffer . setByte ( 3 , ( byte ) 4 ) ; </a> 0
<a> buffer . getBytes ( 1 , dst ) ; </a> 0
<a> assertEquals ( 3 , dst . position ( ) ) ; </a> 0
<a> assertEquals ( 3 , dst . limit ( ) ) ; </a> 0
<a> dst . clear ( ) ; </a> 0
<a> assertEquals ( 0 , dst . get ( 0 ) ) ; </a> 0
<a> assertEquals ( 2 , dst . get ( 1 ) ) ; </a> 0
<a> assertEquals ( 3 , dst . get ( 2 ) ) ; </a> 0
<a> assertEquals ( 0 , dst . get ( 3 ) ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IndexOutOfBoundsException . class ) </a> 0
<a> public void getDirectByteBufferBoundaryCheck ( ) { </a> 0
<a> buffer . getBytes ( - 1 , ByteBuffer . allocateDirect ( 0 ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void getDirectByteBufferState ( ) { </a> 0
<a> ByteBuffer dst = ByteBuffer . allocateDirect ( 4 ) ; </a> 0
<a> dst . position ( 1 ) ; </a> 0
<a> dst . limit ( 3 ) ; </a> 0
<a> buffer . setByte ( 0 , ( byte ) 1 ) ; </a> 0
<a> buffer . setByte ( 1 , ( byte ) 2 ) ; </a> 0
<a> buffer . setByte ( 2 , ( byte ) 3 ) ; </a> 0
<a> buffer . setByte ( 3 , ( byte ) 4 ) ; </a> 0
<a> buffer . getBytes ( 1 , dst ) ; </a> 0
<a> assertEquals ( 3 , dst . position ( ) ) ; </a> 0
<a> assertEquals ( 3 , dst . limit ( ) ) ; </a> 0
<a> dst . clear ( ) ; </a> 0
<a> assertEquals ( 0 , dst . get ( 0 ) ) ; </a> 0
<a> assertEquals ( 2 , dst . get ( 1 ) ) ; </a> 0
<a> assertEquals ( 3 , dst . get ( 2 ) ) ; </a> 0
<a> assertEquals ( 0 , dst . get ( 3 ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomByteAccess ( ) { </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> byte value = ( byte ) random . nextInt ( ) ; </a> 0
<a> buffer . setByte ( i , value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> byte value = ( byte ) random . nextInt ( ) ; </a> 0
<a> assertEquals ( value , buffer . getByte ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomUnsignedByteAccess ( ) { </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> byte value = ( byte ) random . nextInt ( ) ; </a> 0
<a> buffer . setByte ( i , value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> int value = random . nextInt ( ) & 0xFF ; </a> 0
<a> assertEquals ( value , buffer . getUnsignedByte ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomShortAccess ( ) { </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 1 ; i += 2 ) { </a> 0
<a> short value = ( short ) random . nextInt ( ) ; </a> 0
<a> buffer . setShort ( i , value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 1 ; i += 2 ) { </a> 0
<a> short value = ( short ) random . nextInt ( ) ; </a> 0
<a> assertEquals ( value , buffer . getShort ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomUnsignedShortAccess ( ) { </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 1 ; i += 2 ) { </a> 0
<a> short value = ( short ) random . nextInt ( ) ; </a> 0
<a> buffer . setShort ( i , value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 1 ; i += 2 ) { </a> 0
<a> int value = random . nextInt ( ) & 0xFFFF ; </a> 0
<a> assertEquals ( value , buffer . getUnsignedShort ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomMediumAccess ( ) { </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 2 ; i += 3 ) { </a> 0
<a> int value = random . nextInt ( ) ; </a> 0
<a> buffer . setMedium ( i , value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 2 ; i += 3 ) { </a> 0
<a> int value = random . nextInt ( ) < < 8 > > 8 ; </a> 0
<a> assertEquals ( value , buffer . getMedium ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomUnsignedMediumAccess ( ) { </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 2 ; i += 3 ) { </a> 0
<a> int value = random . nextInt ( ) ; </a> 0
<a> buffer . setMedium ( i , value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 2 ; i += 3 ) { </a> 0
<a> int value = random . nextInt ( ) & 0x00FFFFFF ; </a> 0
<a> assertEquals ( value , buffer . getUnsignedMedium ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomIntAccess ( ) { </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 3 ; i += 4 ) { </a> 0
<a> int value = random . nextInt ( ) ; </a> 0
<a> buffer . setInt ( i , value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 3 ; i += 4 ) { </a> 0
<a> int value = random . nextInt ( ) ; </a> 0
<a> assertEquals ( value , buffer . getInt ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomUnsignedIntAccess ( ) { </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 3 ; i += 4 ) { </a> 0
<a> int value = random . nextInt ( ) ; </a> 0
<a> buffer . setInt ( i , value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 3 ; i += 4 ) { </a> 0
<a> long value = random . nextInt ( ) & 0xFFFFFFFFL ; </a> 0
<a> assertEquals ( value , buffer . getUnsignedInt ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomLongAccess ( ) { </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 7 ; i += 8 ) { </a> 0
<a> long value = random . nextLong ( ) ; </a> 0
<a> buffer . setLong ( i , value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - 7 ; i += 8 ) { </a> 0
<a> long value = random . nextLong ( ) ; </a> 0
<a> assertEquals ( value , buffer . getLong ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSetZero ( ) { </a> 0
<a> buffer . clear ( ) ; </a> 0
<a> while ( buffer . writable ( ) ) { </a> 0
<a> buffer . writeByte ( ( byte ) 0xFF ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; ) { </a> 0
<a> int length = Math . min ( buffer . capacity ( ) - i , random . nextInt ( 32 ) ) ; </a> 0
<a> buffer . setZero ( i , length ) ; </a> 0
<a> i += length ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> assertEquals ( 0 , buffer . getByte ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialByteAccess ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> byte value = ( byte ) random . nextInt ( ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . writable ( ) ) ; </a> 0
<a> buffer . writeByte ( value ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> byte value = ( byte ) random . nextInt ( ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( value , buffer . readByte ( ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialUnsignedByteAccess ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> byte value = ( byte ) random . nextInt ( ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . writable ( ) ) ; </a> 0
<a> buffer . writeByte ( value ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> int value = random . nextInt ( ) & 0xFF ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( value , buffer . readUnsignedByte ( ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialShortAccess ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i += 2 ) { </a> 0
<a> short value = ( short ) random . nextInt ( ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . writable ( ) ) ; </a> 0
<a> buffer . writeShort ( value ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i += 2 ) { </a> 0
<a> short value = ( short ) random . nextInt ( ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( value , buffer . readShort ( ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialUnsignedShortAccess ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i += 2 ) { </a> 0
<a> short value = ( short ) random . nextInt ( ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . writable ( ) ) ; </a> 0
<a> buffer . writeShort ( value ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i += 2 ) { </a> 0
<a> int value = random . nextInt ( ) & 0xFFFF ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( value , buffer . readUnsignedShort ( ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialMediumAccess ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) / 3 * 3 ; i += 3 ) { </a> 0
<a> int value = random . nextInt ( ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . writable ( ) ) ; </a> 0
<a> buffer . writeMedium ( value ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) / 3 * 3 , buffer . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) % 3 , buffer . writableBytes ( ) ) ; </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) / 3 * 3 ; i += 3 ) { </a> 0
<a> int value = random . nextInt ( ) < < 8 > > 8 ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( value , buffer . readMedium ( ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( buffer . capacity ( ) / 3 * 3 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) / 3 * 3 , buffer . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( 0 , buffer . readableBytes ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) % 3 , buffer . writableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialUnsignedMediumAccess ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) / 3 * 3 ; i += 3 ) { </a> 0
<a> int value = random . nextInt ( ) & 0x00FFFFFF ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . writable ( ) ) ; </a> 0
<a> buffer . writeMedium ( value ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) / 3 * 3 , buffer . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) % 3 , buffer . writableBytes ( ) ) ; </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) / 3 * 3 ; i += 3 ) { </a> 0
<a> int value = random . nextInt ( ) & 0x00FFFFFF ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( value , buffer . readUnsignedMedium ( ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( buffer . capacity ( ) / 3 * 3 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) / 3 * 3 , buffer . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( 0 , buffer . readableBytes ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) % 3 , buffer . writableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialIntAccess ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i += 4 ) { </a> 0
<a> int value = random . nextInt ( ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . writable ( ) ) ; </a> 0
<a> buffer . writeInt ( value ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i += 4 ) { </a> 0
<a> int value = random . nextInt ( ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( value , buffer . readInt ( ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialUnsignedIntAccess ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i += 4 ) { </a> 0
<a> int value = random . nextInt ( ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . writable ( ) ) ; </a> 0
<a> buffer . writeInt ( value ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i += 4 ) { </a> 0
<a> long value = random . nextInt ( ) & 0xFFFFFFFFL ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( value , buffer . readUnsignedInt ( ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialLongAccess ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i += 8 ) { </a> 0
<a> long value = random . nextLong ( ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . writable ( ) ) ; </a> 0
<a> buffer . writeLong ( value ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i += 8 ) { </a> 0
<a> long value = random . nextLong ( ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertTrue ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( value , buffer . readLong ( ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testByteArrayTransfer ( ) { </a> 0
<a> byte [ ] value = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( value ) ; </a> 0
<a> buffer . setBytes ( i , value , random . nextInt ( BLOCK_SIZE ) , BLOCK_SIZE ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValue = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValue ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> buffer . getBytes ( i , value , valueOffset , BLOCK_SIZE ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue [ j ] , value [ j ] ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomByteArrayTransfer1 ( ) { </a> 0
<a> byte [ ] value = new byte [ BLOCK_SIZE ] ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( value ) ; </a> 0
<a> buffer . setBytes ( i , value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValueContent = new byte [ BLOCK_SIZE ] ; </a> 0
<a> ByteBuf expectedValue = wrappedBuffer ( expectedValueContent ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValueContent ) ; </a> 0
<a> buffer . getBytes ( i , value ) ; </a> 0
<a> for ( int j = 0 ; j < BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . getByte ( j ) , value [ j ] ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomByteArrayTransfer2 ( ) { </a> 0
<a> byte [ ] value = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( value ) ; </a> 0
<a> buffer . setBytes ( i , value , random . nextInt ( BLOCK_SIZE ) , BLOCK_SIZE ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf expectedValue = wrappedBuffer ( expectedValueContent ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValueContent ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> buffer . getBytes ( i , value , valueOffset , BLOCK_SIZE ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . getByte ( j ) , value [ j ] ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomHeapBufferTransfer1 ( ) { </a> 0
<a> byte [ ] valueContent = new byte [ BLOCK_SIZE ] ; </a> 0
<a> ByteBuf value = wrappedBuffer ( valueContent ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( valueContent ) ; </a> 0
<a> value . setIndex ( 0 , BLOCK_SIZE ) ; </a> 0
<a> buffer . setBytes ( i , value ) ; </a> 0
<a> assertEquals ( BLOCK_SIZE , value . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( BLOCK_SIZE , value . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValueContent = new byte [ BLOCK_SIZE ] ; </a> 0
<a> ByteBuf expectedValue = wrappedBuffer ( expectedValueContent ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValueContent ) ; </a> 0
<a> value . clear ( ) ; </a> 0
<a> buffer . getBytes ( i , value ) ; </a> 0
<a> assertEquals ( 0 , value . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( BLOCK_SIZE , value . writerIndex ( ) ) ; </a> 0
<a> for ( int j = 0 ; j < BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . getByte ( j ) , value . getByte ( j ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomHeapBufferTransfer2 ( ) { </a> 0
<a> byte [ ] valueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf value = wrappedBuffer ( valueContent ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( valueContent ) ; </a> 0
<a> buffer . setBytes ( i , value , random . nextInt ( BLOCK_SIZE ) , BLOCK_SIZE ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf expectedValue = wrappedBuffer ( expectedValueContent ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValueContent ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> buffer . getBytes ( i , value , valueOffset , BLOCK_SIZE ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . getByte ( j ) , value . getByte ( j ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomDirectBufferTransfer ( ) { </a> 0
<a> byte [ ] tmp = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf value = directBuffer ( BLOCK_SIZE * 2 ) ; </a> 1
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( tmp ) ; </a> 0
<a> value . setBytes ( 0 , tmp , 0 , value . capacity ( ) ) ; </a> 0
<a> buffer . setBytes ( i , value , random . nextInt ( BLOCK_SIZE ) , BLOCK_SIZE ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> ByteBuf expectedValue = directBuffer ( BLOCK_SIZE * 2 ) ; </a> 1
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( tmp ) ; </a> 0
<a> expectedValue . setBytes ( 0 , tmp , 0 , expectedValue . capacity ( ) ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> buffer . getBytes ( i , value , valueOffset , BLOCK_SIZE ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . getByte ( j ) , value . getByte ( j ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRandomByteBufferTransfer ( ) { </a> 0
<a> ByteBuffer value = ByteBuffer . allocate ( BLOCK_SIZE * 2 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( value . array ( ) ) ; </a> 0
<a> value . clear ( ) . position ( random . nextInt ( BLOCK_SIZE ) ) ; </a> 0
<a> value . limit ( value . position ( ) + BLOCK_SIZE ) ; </a> 0
<a> buffer . setBytes ( i , value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> ByteBuffer expectedValue = ByteBuffer . allocate ( BLOCK_SIZE * 2 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValue . array ( ) ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> value . clear ( ) . position ( valueOffset ) . limit ( valueOffset + BLOCK_SIZE ) ; </a> 0
<a> buffer . getBytes ( i , value ) ; </a> 0
<a> assertEquals ( valueOffset + BLOCK_SIZE , value . position ( ) ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . get ( j ) , value . get ( j ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialByteArrayTransfer1 ( ) { </a> 0
<a> byte [ ] value = new byte [ BLOCK_SIZE ] ; </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( value ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . writeBytes ( value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValue = new byte [ BLOCK_SIZE ] ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValue ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . readBytes ( value ) ; </a> 0
<a> for ( int j = 0 ; j < BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue [ j ] , value [ j ] ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialByteArrayTransfer2 ( ) { </a> 0
<a> byte [ ] value = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( value ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> int readerIndex = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> buffer . writeBytes ( value , readerIndex , BLOCK_SIZE ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValue = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValue ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . readBytes ( value , valueOffset , BLOCK_SIZE ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue [ j ] , value [ j ] ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialHeapBufferTransfer1 ( ) { </a> 0
<a> byte [ ] valueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf value = wrappedBuffer ( valueContent ) ; </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( valueContent ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . writeBytes ( value , random . nextInt ( BLOCK_SIZE ) , BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( 0 , value . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( valueContent . length , value . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf expectedValue = wrappedBuffer ( expectedValueContent ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValueContent ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . readBytes ( value , valueOffset , BLOCK_SIZE ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . getByte ( j ) , value . getByte ( j ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , value . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( valueContent . length , value . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialHeapBufferTransfer2 ( ) { </a> 0
<a> byte [ ] valueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf value = wrappedBuffer ( valueContent ) ; </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( valueContent ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> int readerIndex = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> value . readerIndex ( readerIndex ) ; </a> 0
<a> value . writerIndex ( readerIndex + BLOCK_SIZE ) ; </a> 0
<a> buffer . writeBytes ( value ) ; </a> 0
<a> assertEquals ( readerIndex + BLOCK_SIZE , value . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( value . writerIndex ( ) , value . readerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf expectedValue = wrappedBuffer ( expectedValueContent ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValueContent ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY , buffer . writerIndex ( ) ) ; </a> 0
<a> value . readerIndex ( valueOffset ) ; </a> 0
<a> value . writerIndex ( valueOffset ) ; </a> 0
<a> buffer . readBytes ( value , BLOCK_SIZE ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . getByte ( j ) , value . getByte ( j ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( valueOffset , value . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( valueOffset + BLOCK_SIZE , value . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialDirectBufferTransfer1 ( ) { </a> 0
<a> byte [ ] valueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf value = directBuffer ( BLOCK_SIZE * 2 ) ; </a> 1
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( valueContent ) ; </a> 0
<a> value . setBytes ( 0 , valueContent ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . writeBytes ( value , random . nextInt ( BLOCK_SIZE ) , BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( 0 , value . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( 0 , value . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf expectedValue = wrappedBuffer ( expectedValueContent ) ; </a> 1
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValueContent ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> value . setBytes ( 0 , valueContent ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . readBytes ( value , valueOffset , BLOCK_SIZE ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . getByte ( j ) , value . getByte ( j ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , value . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( 0 , value . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialDirectBufferTransfer2 ( ) { </a> 0
<a> byte [ ] valueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf value = directBuffer ( BLOCK_SIZE * 2 ) ; </a> 1
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( valueContent ) ; </a> 0
<a> value . setBytes ( 0 , valueContent ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> int readerIndex = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> value . readerIndex ( 0 ) ; </a> 0
<a> value . writerIndex ( readerIndex + BLOCK_SIZE ) ; </a> 0
<a> value . readerIndex ( readerIndex ) ; </a> 0
<a> buffer . writeBytes ( value ) ; </a> 0
<a> assertEquals ( readerIndex + BLOCK_SIZE , value . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( value . writerIndex ( ) , value . readerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf expectedValue = wrappedBuffer ( expectedValueContent ) ; </a> 1
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValueContent ) ; </a> 0
<a> value . setBytes ( 0 , valueContent ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY , buffer . writerIndex ( ) ) ; </a> 0
<a> value . readerIndex ( valueOffset ) ; </a> 0
<a> value . writerIndex ( valueOffset ) ; </a> 0
<a> buffer . readBytes ( value , BLOCK_SIZE ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . getByte ( j ) , value . getByte ( j ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( valueOffset , value . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( valueOffset + BLOCK_SIZE , value . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialByteBufferBackedHeapBufferTransfer1 ( ) { </a> 0
<a> byte [ ] valueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf value = wrappedBuffer ( ByteBuffer . allocate ( BLOCK_SIZE * 2 ) ) ; </a> 0
<a> value . writerIndex ( 0 ) ; </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( valueContent ) ; </a> 0
<a> value . setBytes ( 0 , valueContent ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . writeBytes ( value , random . nextInt ( BLOCK_SIZE ) , BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( 0 , value . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( 0 , value . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf expectedValue = wrappedBuffer ( expectedValueContent ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValueContent ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> value . setBytes ( 0 , valueContent ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . readBytes ( value , valueOffset , BLOCK_SIZE ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . getByte ( j ) , value . getByte ( j ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , value . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( 0 , value . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialByteBufferBackedHeapBufferTransfer2 ( ) { </a> 0
<a> byte [ ] valueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf value = wrappedBuffer ( ByteBuffer . allocate ( BLOCK_SIZE * 2 ) ) ; </a> 0
<a> value . writerIndex ( 0 ) ; </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( valueContent ) ; </a> 0
<a> value . setBytes ( 0 , valueContent ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> int readerIndex = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> value . readerIndex ( 0 ) ; </a> 0
<a> value . writerIndex ( readerIndex + BLOCK_SIZE ) ; </a> 0
<a> value . readerIndex ( readerIndex ) ; </a> 0
<a> buffer . writeBytes ( value ) ; </a> 0
<a> assertEquals ( readerIndex + BLOCK_SIZE , value . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( value . writerIndex ( ) , value . readerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValueContent = new byte [ BLOCK_SIZE * 2 ] ; </a> 0
<a> ByteBuf expectedValue = wrappedBuffer ( expectedValueContent ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValueContent ) ; </a> 0
<a> value . setBytes ( 0 , valueContent ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY , buffer . writerIndex ( ) ) ; </a> 0
<a> value . readerIndex ( valueOffset ) ; </a> 0
<a> value . writerIndex ( valueOffset ) ; </a> 0
<a> buffer . readBytes ( value , BLOCK_SIZE ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . getByte ( j ) , value . getByte ( j ) ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( valueOffset , value . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( valueOffset + BLOCK_SIZE , value . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialByteBufferTransfer ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> ByteBuffer value = ByteBuffer . allocate ( BLOCK_SIZE * 2 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( value . array ( ) ) ; </a> 0
<a> value . clear ( ) . position ( random . nextInt ( BLOCK_SIZE ) ) ; </a> 0
<a> value . limit ( value . position ( ) + BLOCK_SIZE ) ; </a> 0
<a> buffer . writeBytes ( value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> ByteBuffer expectedValue = ByteBuffer . allocate ( BLOCK_SIZE * 2 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValue . array ( ) ) ; </a> 0
<a> int valueOffset = random . nextInt ( BLOCK_SIZE ) ; </a> 0
<a> value . clear ( ) . position ( valueOffset ) . limit ( valueOffset + BLOCK_SIZE ) ; </a> 0
<a> buffer . readBytes ( value ) ; </a> 0
<a> assertEquals ( valueOffset + BLOCK_SIZE , value . position ( ) ) ; </a> 0
<a> for ( int j = valueOffset ; j < valueOffset + BLOCK_SIZE ; j ++ ) { </a> 0
<a> assertEquals ( expectedValue . get ( j ) , value . get ( j ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialCopiedBufferTransfer1 ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> byte [ ] value = new byte [ BLOCK_SIZE ] ; </a> 0
<a> random . nextBytes ( value ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . writeBytes ( value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValue = new byte [ BLOCK_SIZE ] ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValue ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY , buffer . writerIndex ( ) ) ; </a> 0
<a> ByteBuf actualValue = buffer . readBytes ( BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( wrappedBuffer ( expectedValue ) , actualValue ) ; </a> 0
<a> actualValue . setByte ( 0 , ( byte ) ( actualValue . getByte ( 0 ) + 1 ) ) ; </a> 0
<a> assertFalse ( buffer . getByte ( i ) == actualValue . getByte ( 0 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSequentialSlice1 ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> byte [ ] value = new byte [ BLOCK_SIZE ] ; </a> 0
<a> random . nextBytes ( value ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . writeBytes ( value ) ; </a> 0
<a> } </a> 0
<a> random . setSeed ( seed ) ; </a> 0
<a> byte [ ] expectedValue = new byte [ BLOCK_SIZE ] ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> random . nextBytes ( expectedValue ) ; </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY , buffer . writerIndex ( ) ) ; </a> 0
<a> ByteBuf actualValue = buffer . readSlice ( BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( wrappedBuffer ( expectedValue ) , actualValue ) ; </a> 0
<a> actualValue . setByte ( 0 , ( byte ) ( actualValue . getByte ( 0 ) + 1 ) ) ; </a> 0
<a> assertEquals ( buffer . getByte ( i ) , actualValue . getByte ( 0 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWriteZero ( ) { </a> 0
<a> try { </a> 0
<a> buffer . writeZero ( - 1 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( IllegalArgumentException e ) { </a> 0
<a> } </a> 0
<a> buffer . clear ( ) ; </a> 0
<a> while ( buffer . writable ( ) ) { </a> 0
<a> buffer . writeByte ( ( byte ) 0xFF ) ; </a> 0
<a> } </a> 0
<a> buffer . clear ( ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; ) { </a> 0
<a> int length = Math . min ( buffer . capacity ( ) - i , random . nextInt ( 32 ) ) ; </a> 0
<a> buffer . writeZero ( length ) ; </a> 0
<a> i += length ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> assertEquals ( 0 , buffer . getByte ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDiscardReadBytes ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i += 4 ) { </a> 0
<a> buffer . writeInt ( i ) ; </a> 0
<a> } </a> 0
<a> ByteBuf copy = copiedBuffer ( buffer ) ; </a> 1
<a> buffer . readerIndex ( CAPACITY / 4 ) ; </a> 0
<a> buffer . markReaderIndex ( ) ; </a> 0
<a> buffer . writerIndex ( CAPACITY / 3 ) ; </a> 0
<a> buffer . markWriterIndex ( ) ; </a> 0
<a> buffer . readerIndex ( 0 ) ; </a> 0
<a> buffer . writerIndex ( CAPACITY / 2 ) ; </a> 0
<a> buffer . discardReadBytes ( ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY / 2 , buffer . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( copy . slice ( 0 , CAPACITY / 2 ) , buffer . slice ( 0 , CAPACITY / 2 ) ) ; </a> 0
<a> buffer . resetReaderIndex ( ) ; </a> 0
<a> assertEquals ( CAPACITY / 4 , buffer . readerIndex ( ) ) ; </a> 0
<a> buffer . resetWriterIndex ( ) ; </a> 0
<a> assertEquals ( CAPACITY / 3 , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . readerIndex ( 1 ) ; </a> 0
<a> buffer . writerIndex ( CAPACITY / 2 ) ; </a> 0
<a> buffer . discardReadBytes ( ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY / 2 - 1 , buffer . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( copy . slice ( 1 , CAPACITY / 2 - 1 ) , buffer . slice ( 0 , CAPACITY / 2 - 1 ) ) ; </a> 0
<a> if ( discardReadBytesDoesNotMoveWritableBytes ( ) ) { </a> 0
<a> assertFalse ( copy . slice ( CAPACITY / 2 , CAPACITY / 2 ) . equals ( buffer . slice ( CAPACITY / 2 - 1 , CAPACITY / 2 ) ) ) ; </a> 0
<a> } else { </a> 0
<a> assertEquals ( copy . slice ( CAPACITY / 2 , CAPACITY / 2 ) , buffer . slice ( CAPACITY / 2 - 1 , CAPACITY / 2 ) ) ; </a> 0
<a> } </a> 0
<a> buffer . resetReaderIndex ( ) ; </a> 0
<a> assertEquals ( CAPACITY / 4 - 1 , buffer . readerIndex ( ) ) ; </a> 0
<a> buffer . resetWriterIndex ( ) ; </a> 0
<a> assertEquals ( CAPACITY / 3 - 1 , buffer . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDiscardReadBytes2 ( ) { </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> buffer . writeByte ( ( byte ) i ) ; </a> 0
<a> } </a> 0
<a> ByteBuf copy = copiedBuffer ( buffer ) ; </a> 1
<a> buffer . setIndex ( CAPACITY / 2 - 1 , CAPACITY - 1 ) ; </a> 0
<a> buffer . discardReadBytes ( ) ; </a> 0
<a> assertEquals ( 0 , buffer . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( CAPACITY / 2 , buffer . writerIndex ( ) ) ; </a> 0
<a> for ( int i = 0 ; i < CAPACITY / 2 ; i ++ ) { </a> 0
<a> assertEquals ( copy . slice ( CAPACITY / 2 - 1 + i , CAPACITY / 2 - i ) , buffer . slice ( i , CAPACITY / 2 - i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testStreamTransfer1 ( ) throws Exception { </a> 0
<a> byte [ ] expected = new byte [ buffer . capacity ( ) ] ; </a> 0
<a> random . nextBytes ( expected ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> ByteArrayInputStream in = new ByteArrayInputStream ( expected , i , BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( BLOCK_SIZE , buffer . setBytes ( i , in , BLOCK_SIZE ) ) ; </a> 0
<a> assertEquals ( - 1 , buffer . setBytes ( i , in , 0 ) ) ; </a> 0
<a> } </a> 0
<a> ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> buffer . getBytes ( i , out , BLOCK_SIZE ) ; </a> 0
<a> } </a> 0
<a> assertTrue ( Arrays . equals ( expected , out . toByteArray ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testStreamTransfer2 ( ) throws Exception { </a> 0
<a> byte [ ] expected = new byte [ buffer . capacity ( ) ] ; </a> 0
<a> random . nextBytes ( expected ) ; </a> 0
<a> buffer . clear ( ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> ByteArrayInputStream in = new ByteArrayInputStream ( expected , i , BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( i , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . writeBytes ( in , BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( i + BLOCK_SIZE , buffer . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> assertEquals ( i , buffer . readerIndex ( ) ) ; </a> 0
<a> buffer . readBytes ( out , BLOCK_SIZE ) ; </a> 0
<a> assertEquals ( i + BLOCK_SIZE , buffer . readerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> assertTrue ( Arrays . equals ( expected , out . toByteArray ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testCopy ( ) { </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> byte value = ( byte ) random . nextInt ( ) ; </a> 0
<a> buffer . setByte ( i , value ) ; </a> 0
<a> } </a> 0
<a> final int readerIndex = CAPACITY / 3 ; </a> 0
<a> final int writerIndex = CAPACITY * 2 / 3 ; </a> 0
<a> buffer . setIndex ( readerIndex , writerIndex ) ; </a> 0
<a> ByteBuf copy = buffer . copy ( ) ; </a> 1
<a> assertEquals ( 0 , copy . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . readableBytes ( ) , copy . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . readableBytes ( ) , copy . capacity ( ) ) ; </a> 0
<a> assertSame ( buffer . order ( ) , copy . order ( ) ) ; </a> 0
<a> for ( int i = 0 ; i < copy . capacity ( ) ; i ++ ) { </a> 0
<a> assertEquals ( buffer . getByte ( i + readerIndex ) , copy . getByte ( i ) ) ; </a> 0
<a> } </a> 0
<a> buffer . setByte ( readerIndex , ( byte ) ( buffer . getByte ( readerIndex ) + 1 ) ) ; </a> 0
<a> assertTrue ( buffer . getByte ( readerIndex ) != copy . getByte ( 0 ) ) ; </a> 0
<a> copy . setByte ( 1 , ( byte ) ( copy . getByte ( 1 ) + 1 ) ) ; </a> 0
<a> assertTrue ( buffer . getByte ( readerIndex + 1 ) != copy . getByte ( 1 ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDuplicate ( ) { </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) ; i ++ ) { </a> 0
<a> byte value = ( byte ) random . nextInt ( ) ; </a> 0
<a> buffer . setByte ( i , value ) ; </a> 0
<a> } </a> 0
<a> final int readerIndex = CAPACITY / 3 ; </a> 0
<a> final int writerIndex = CAPACITY * 2 / 3 ; </a> 0
<a> buffer . setIndex ( readerIndex , writerIndex ) ; </a> 0
<a> ByteBuf duplicate = buffer . duplicate ( ) ; </a> 0
<a> assertEquals ( buffer . readerIndex ( ) , duplicate . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . writerIndex ( ) , duplicate . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , duplicate . capacity ( ) ) ; </a> 0
<a> assertSame ( buffer . order ( ) , duplicate . order ( ) ) ; </a> 0
<a> for ( int i = 0 ; i < duplicate . capacity ( ) ; i ++ ) { </a> 0
<a> assertEquals ( buffer . getByte ( i ) , duplicate . getByte ( i ) ) ; </a> 0
<a> } </a> 0
<a> buffer . setByte ( readerIndex , ( byte ) ( buffer . getByte ( readerIndex ) + 1 ) ) ; </a> 0
<a> assertTrue ( buffer . getByte ( readerIndex ) == duplicate . getByte ( readerIndex ) ) ; </a> 1
<a> duplicate . setByte ( 1 , ( byte ) ( duplicate . getByte ( 1 ) + 1 ) ) ; </a> 0
<a> assertTrue ( buffer . getByte ( 1 ) == duplicate . getByte ( 1 ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSliceEndianness ( ) throws Exception { </a> 0
<a> assertEquals ( buffer . order ( ) , buffer . slice ( 0 , buffer . capacity ( ) ) . order ( ) ) ; </a> 0
<a> assertEquals ( buffer . order ( ) , buffer . slice ( 0 , buffer . capacity ( ) - 1 ) . order ( ) ) ; </a> 0
<a> assertEquals ( buffer . order ( ) , buffer . slice ( 1 , buffer . capacity ( ) - 1 ) . order ( ) ) ; </a> 0
<a> assertEquals ( buffer . order ( ) , buffer . slice ( 1 , buffer . capacity ( ) - 2 ) . order ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSliceIndex ( ) throws Exception { </a> 0
<a> assertEquals ( 0 , buffer . slice ( 0 , buffer . capacity ( ) ) . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( 0 , buffer . slice ( 0 , buffer . capacity ( ) - 1 ) . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( 0 , buffer . slice ( 1 , buffer . capacity ( ) - 1 ) . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( 0 , buffer . slice ( 1 , buffer . capacity ( ) - 2 ) . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) , buffer . slice ( 0 , buffer . capacity ( ) ) . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) - 1 , buffer . slice ( 0 , buffer . capacity ( ) - 1 ) . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) - 1 , buffer . slice ( 1 , buffer . capacity ( ) - 1 ) . writerIndex ( ) ) ; </a> 0
<a> assertEquals ( buffer . capacity ( ) - 2 , buffer . slice ( 1 , buffer . capacity ( ) - 2 ) . writerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testEquals ( ) { </a> 0
<a> assertFalse ( buffer . equals ( null ) ) ; </a> 0
<a> assertFalse ( buffer . equals ( new Object ( ) ) ) ; </a> 0
<a> byte [ ] value = new byte [ 32 ] ; </a> 0
<a> buffer . setIndex ( 0 , value . length ) ; </a> 0
<a> random . nextBytes ( value ) ; </a> 0
<a> buffer . setBytes ( 0 , value ) ; </a> 0
<a> assertEquals ( buffer , wrappedBuffer ( value ) ) ; </a> 0
<a> assertEquals ( buffer , wrappedBuffer ( value ) . order ( LITTLE_ENDIAN ) ) ; </a> 0
<a> value [ 0 ] ++ ; </a> 0
<a> assertFalse ( buffer . equals ( wrappedBuffer ( value ) ) ) ; </a> 0
<a> assertFalse ( buffer . equals ( wrappedBuffer ( value ) . order ( LITTLE_ENDIAN ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testCompareTo ( ) { </a> 0
<a> try { </a> 0
<a> buffer . compareTo ( null ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( NullPointerException e ) { </a> 0
<a> } </a> 0
<a> byte [ ] value = new byte [ 32 ] ; </a> 0
<a> random . nextBytes ( value ) ; </a> 0
<a> if ( value [ 0 ] == 0 ) { </a> 0
<a> value [ 0 ] ++ ; </a> 0
<a> } else if ( value [ 0 ] == - 1 ) { </a> 0
<a> value [ 0 ] -- ; </a> 0
<a> } </a> 0
<a> buffer . setIndex ( 0 , value . length ) ; </a> 0
<a> buffer . setBytes ( 0 , value ) ; </a> 0
<a> assertEquals ( 0 , buffer . compareTo ( wrappedBuffer ( value ) ) ) ; </a> 0
<a> assertEquals ( 0 , buffer . compareTo ( wrappedBuffer ( value ) . order ( LITTLE_ENDIAN ) ) ) ; </a> 0
<a> value [ 0 ] ++ ; </a> 0
<a> assertTrue ( buffer . compareTo ( wrappedBuffer ( value ) ) < 0 ) ; </a> 0
<a> assertTrue ( buffer . compareTo ( wrappedBuffer ( value ) . order ( LITTLE_ENDIAN ) ) < 0 ) ; </a> 0
<a> value [ 0 ] -= 2 ; </a> 0
<a> assertTrue ( buffer . compareTo ( wrappedBuffer ( value ) ) > 0 ) ; </a> 0
<a> assertTrue ( buffer . compareTo ( wrappedBuffer ( value ) . order ( LITTLE_ENDIAN ) ) > 0 ) ; </a> 0
<a> value [ 0 ] ++ ; </a> 0
<a> assertTrue ( buffer . compareTo ( wrappedBuffer ( value , 0 , 31 ) ) > 0 ) ; </a> 0
<a> assertTrue ( buffer . compareTo ( wrappedBuffer ( value , 0 , 31 ) . order ( LITTLE_ENDIAN ) ) > 0 ) ; </a> 0
<a> assertTrue ( buffer . slice ( 0 , 31 ) . compareTo ( wrappedBuffer ( value ) ) < 0 ) ; </a> 0
<a> assertTrue ( buffer . slice ( 0 , 31 ) . compareTo ( wrappedBuffer ( value ) . order ( LITTLE_ENDIAN ) ) < 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testToString ( ) { </a> 0
<a> buffer . clear ( ) ; </a> 0
<a> buffer . writeBytes ( copiedBuffer ( "Hello, World!" , CharsetUtil . ISO_8859_1 ) ) ; </a> 1
<a> assertEquals ( "Hello, World!" , buffer . toString ( CharsetUtil . ISO_8859_1 ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIndexOf ( ) { </a> 0
<a> buffer . clear ( ) ; </a> 0
<a> buffer . writeByte ( ( byte ) 1 ) ; </a> 0
<a> buffer . writeByte ( ( byte ) 2 ) ; </a> 0
<a> buffer . writeByte ( ( byte ) 3 ) ; </a> 0
<a> buffer . writeByte ( ( byte ) 2 ) ; </a> 0
<a> buffer . writeByte ( ( byte ) 1 ) ; </a> 0
<a> assertEquals ( - 1 , buffer . indexOf ( 1 , 4 , ( byte ) 1 ) ) ; </a> 0
<a> assertEquals ( - 1 , buffer . indexOf ( 4 , 1 , ( byte ) 1 ) ) ; </a> 0
<a> assertEquals ( 1 , buffer . indexOf ( 1 , 4 , ( byte ) 2 ) ) ; </a> 0
<a> assertEquals ( 3 , buffer . indexOf ( 4 , 1 , ( byte ) 2 ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testNioBuffer1 ( ) { </a> 0
<a> Assume . assumeTrue ( buffer . hasNioBuffer ( ) ) ; </a> 1
<a> byte [ ] value = new byte [ buffer . capacity ( ) ] ; </a> 0
<a> random . nextBytes ( value ) ; </a> 0
<a> buffer . clear ( ) ; </a> 0
<a> buffer . writeBytes ( value ) ; </a> 0
<a> assertEquals ( ByteBuffer . wrap ( value ) , buffer . nioBuffer ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testToByteBuffer2 ( ) { </a> 0
<a> Assume . assumeTrue ( buffer . hasNioBuffer ( ) ) ; </a> 1
<a> byte [ ] value = new byte [ buffer . capacity ( ) ] ; </a> 0
<a> random . nextBytes ( value ) ; </a> 0
<a> buffer . clear ( ) ; </a> 0
<a> buffer . writeBytes ( value ) ; </a> 0
<a> for ( int i = 0 ; i < buffer . capacity ( ) - BLOCK_SIZE + 1 ; i += BLOCK_SIZE ) { </a> 0
<a> assertEquals ( ByteBuffer . wrap ( value , i , BLOCK_SIZE ) , buffer . nioBuffer ( i , BLOCK_SIZE ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testToByteBuffer3 ( ) { </a> 0
<a> Assume . assumeTrue ( buffer . hasNioBuffer ( ) ) ; </a> 1
<a> assertEquals ( buffer . order ( ) , buffer . nioBuffer ( ) . order ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSkipBytes1 ( ) { </a> 0
<a> buffer . setIndex ( CAPACITY / 4 , CAPACITY / 2 ) ; </a> 0
<a> buffer . skipBytes ( CAPACITY / 4 ) ; </a> 0
<a> assertEquals ( CAPACITY / 4 * 2 , buffer . readerIndex ( ) ) ; </a> 0
<a> try { </a> 0
<a> buffer . skipBytes ( CAPACITY / 4 + 1 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( IndexOutOfBoundsException e ) { </a> 0
<a> } </a> 0
<a> assertEquals ( CAPACITY / 4 * 2 , buffer . readerIndex ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testHashCode ( ) { </a> 0
<a> ByteBuf elemA = buffer ( 15 ) ; </a> 1
<a> ByteBuf elemB = directBuffer ( 15 ) ; </a> 1
<a> elemA . writeBytes ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 , 1 , 2 , 3 , 4 , 5 } ) ; </a> 0
<a> elemB . writeBytes ( new byte [ ] { 6 , 7 , 8 , 9 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 9 } ) ; </a> 0
<a> Set < ByteBuf > set = new HashSet < ByteBuf > ( ) ; </a> 0
<a> set . add ( elemA ) ; </a> 0
<a> set . add ( elemB ) ; </a> 0
<a> assertEquals ( 2 , set . size ( ) ) ; </a> 0
<a> assertTrue ( set . contains ( elemA . copy ( ) ) ) ; </a> 1
<a> assertTrue ( set . contains ( elemB . copy ( ) ) ) ; </a> 1
<a> buffer . clear ( ) ; </a> 0
<a> buffer . writeBytes ( elemA . duplicate ( ) ) ; </a> 0
<a> assertTrue ( set . remove ( buffer ) ) ; </a> 0
<a> assertFalse ( set . contains ( elemA ) ) ; </a> 0
<a> assertEquals ( 1 , set . size ( ) ) ; </a> 0
<a> buffer . clear ( ) ; </a> 0
<a> buffer . writeBytes ( elemB . duplicate ( ) ) ; </a> 0
<a> assertTrue ( set . remove ( buffer ) ) ; </a> 0
<a> assertFalse ( set . contains ( elemB ) ) ; </a> 0
<a> assertEquals ( 0 , set . size ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDiscardAllReadBytes ( ) { </a> 0
<a> buffer . writerIndex ( buffer . capacity ( ) ) ; </a> 0
<a> buffer . readerIndex ( buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . discardReadBytes ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> public class BigEndianCompositeChannelBufferTest extends AbstractCompositeChannelBufferTest { </a> 0
<a> public BigEndianCompositeChannelBufferTest ( ) { </a> 0
<a> super ( Unpooled . BIG_ENDIAN ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class ChannelBufferIndexFinderTest { </a> 0
<a> @ Test </a> 0
<a> public void testForward ( ) { </a> 0
<a> ByteBuf buf = Unpooled . copiedBuffer ( </a> 0
<a> "abc\r\n\ndef\r\rghi\n\njkl\0\0mno \t\tx" , </a> 0
<a> CharsetUtil . ISO_8859_1 ) ; </a> 0
<a> assertEquals ( 3 , buf . indexOf ( Integer . MIN_VALUE , buf . capacity ( ) , ByteBufIndexFinder . CRLF ) ) ; </a> 0
<a> assertEquals ( 6 , buf . indexOf ( 3 , buf . capacity ( ) , ByteBufIndexFinder . NOT_CRLF ) ) ; </a> 0
<a> assertEquals ( 9 , buf . indexOf ( 6 , buf . capacity ( ) , ByteBufIndexFinder . CR ) ) ; </a> 0
<a> assertEquals ( 11 , buf . indexOf ( 9 , buf . capacity ( ) , ByteBufIndexFinder . NOT_CR ) ) ; </a> 0
<a> assertEquals ( 14 , buf . indexOf ( 11 , buf . capacity ( ) , ByteBufIndexFinder . LF ) ) ; </a> 0
<a> assertEquals ( 16 , buf . indexOf ( 14 , buf . capacity ( ) , ByteBufIndexFinder . NOT_LF ) ) ; </a> 0
<a> assertEquals ( 19 , buf . indexOf ( 16 , buf . capacity ( ) , ByteBufIndexFinder . NUL ) ) ; </a> 0
<a> assertEquals ( 21 , buf . indexOf ( 19 , buf . capacity ( ) , ByteBufIndexFinder . NOT_NUL ) ) ; </a> 0
<a> assertEquals ( 24 , buf . indexOf ( 21 , buf . capacity ( ) , ByteBufIndexFinder . LINEAR_WHITESPACE ) ) ; </a> 0
<a> assertEquals ( 28 , buf . indexOf ( 24 , buf . capacity ( ) , ByteBufIndexFinder . NOT_LINEAR_WHITESPACE ) ) ; </a> 0
<a> assertEquals ( - 1 , buf . indexOf ( 28 , buf . capacity ( ) , ByteBufIndexFinder . LINEAR_WHITESPACE ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testBackward ( ) { </a> 0
<a> ByteBuf buf = Unpooled . copiedBuffer ( </a> 0
<a> "abc\r\n\ndef\r\rghi\n\njkl\0\0mno \t\tx" , </a> 0
<a> CharsetUtil . ISO_8859_1 ) ; </a> 0
<a> assertEquals ( 27 , buf . indexOf ( Integer . MAX_VALUE , 0 , ByteBufIndexFinder . LINEAR_WHITESPACE ) ) ; </a> 0
<a> assertEquals ( 23 , buf . indexOf ( 28 , 0 , ByteBufIndexFinder . NOT_LINEAR_WHITESPACE ) ) ; </a> 0
<a> assertEquals ( 20 , buf . indexOf ( 24 , 0 , ByteBufIndexFinder . NUL ) ) ; </a> 0
<a> assertEquals ( 18 , buf . indexOf ( 21 , 0 , ByteBufIndexFinder . NOT_NUL ) ) ; </a> 0
<a> assertEquals ( 15 , buf . indexOf ( 19 , 0 , ByteBufIndexFinder . LF ) ) ; </a> 0
<a> assertEquals ( 13 , buf . indexOf ( 16 , 0 , ByteBufIndexFinder . NOT_LF ) ) ; </a> 0
<a> assertEquals ( 10 , buf . indexOf ( 14 , 0 , ByteBufIndexFinder . CR ) ) ; </a> 0
<a> assertEquals ( 8 , buf . indexOf ( 11 , 0 , ByteBufIndexFinder . NOT_CR ) ) ; </a> 0
<a> assertEquals ( 5 , buf . indexOf ( 9 , 0 , ByteBufIndexFinder . CRLF ) ) ; </a> 0
<a> assertEquals ( 2 , buf . indexOf ( 6 , 0 , ByteBufIndexFinder . NOT_CRLF ) ) ; </a> 0
<a> assertEquals ( - 1 , buf . indexOf ( 3 , 0 , ByteBufIndexFinder . CRLF ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class DuplicateChannelBufferTest extends AbstractChannelBufferTest { </a> 0
<a> private ByteBuf buffer ; </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf newBuffer ( int length ) { </a> 0
<a> buffer = new DuplicatedByteBuf ( Unpooled . buffer ( length ) ) ; </a> 1
<a> assertEquals ( 0 , buffer . writerIndex ( ) ) ; </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf [ ] components ( ) { </a> 0
<a> return new ByteBuf [ ] { buffer } ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = NullPointerException . class ) </a> 0
<a> public void shouldNotAllowNullInConstructor ( ) { </a> 0
<a> new DuplicatedByteBuf ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> public class LittleEndianCompositeChannelBufferTest extends AbstractCompositeChannelBufferTest { </a> 0
<a> public LittleEndianCompositeChannelBufferTest ( ) { </a> 0
<a> super ( Unpooled . LITTLE_ENDIAN ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import java . nio . ByteOrder ; </a> 0
<a> public class LittleEndianDirectChannelBufferTest extends AbstractChannelBufferTest { </a> 0
<a> private ByteBuf buffer ; </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf newBuffer ( int length ) { </a> 0
<a> buffer = Unpooled . directBuffer ( length ) . order ( ByteOrder . LITTLE_ENDIAN ) ; </a> 1
<a> assertSame ( ByteOrder . LITTLE_ENDIAN , buffer . order ( ) ) ; </a> 0
<a> assertEquals ( 0 , buffer . writerIndex ( ) ) ; </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf [ ] components ( ) { </a> 0
<a> return new ByteBuf [ ] { buffer } ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import java . util . Set ; </a> 1
<a> public interface Cookie extends Comparable < Cookie > { </a> 1
<a> String getName ( ) ; </a> 1
<a> String getValue ( ) ; </a> 1
<a> void setValue ( String value ) ; </a> 1
<a> String getDomain ( ) ; </a> 1
<a> void setDomain ( String domain ) ; </a> 1
<a> String getPath ( ) ; </a> 1
<a> void setPath ( String path ) ; </a> 1
<a> String getComment ( ) ; </a> 1
<a> void setComment ( String comment ) ; </a> 1
<a> long getMaxAge ( ) ; </a> 1
<a> void setMaxAge ( long maxAge ) ; </a> 1
<a> int getVersion ( ) ; </a> 1
<a> void setVersion ( int version ) ; </a> 1
<a> boolean isSecure ( ) ; </a> 1
<a> void setSecure ( boolean secure ) ; </a> 1
<a> boolean isHttpOnly ( ) ; </a> 1
<a> void setHttpOnly ( boolean httpOnly ) ; </a> 1
<a> String getCommentUrl ( ) ; </a> 1
<a> void setCommentUrl ( String commentUrl ) ; </a> 1
<a> boolean isDiscard ( ) ; </a> 1
<a> void setDiscard ( boolean discard ) ; </a> 1
<a> Set < Integer > getPorts ( ) ; </a> 1
<a> void setPorts ( int ... ports ) ; </a> 1
<a> void setPorts ( Iterable < Integer > ports ) ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> public class DefaultHttpChunk implements HttpChunk { </a> 0
<a> private ByteBuf content ; </a> 1
<a> private boolean last ; </a> 0
<a> public DefaultHttpChunk ( ByteBuf content ) { </a> 0
<a> setContent ( content ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf getContent ( ) { </a> 1
<a> return content ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setContent ( ByteBuf content ) { </a> 1
<a> if ( content == null ) { </a> 1
<a> throw new NullPointerException ( "content" ) ; </a> 1
<a> } </a> 1
<a> last = ! content . readable ( ) ; </a> 0
<a> this . content = content ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isLast ( ) { </a> 0
<a> return last ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . util . internal . StringUtil ; </a> 0
<a> import java . util . List ; </a> 1
<a> import java . util . Map ; </a> 1
<a> import java . util . Set ; </a> 1
<a> public class DefaultHttpMessage implements HttpMessage { </a> 0
<a> private final HttpHeaders headers = new HttpHeaders ( ) ; </a> 0
<a> private HttpVersion version ; </a> 0
<a> private ByteBuf content = Unpooled . EMPTY_BUFFER ; </a> 1
<a> private HttpTransferEncoding te = HttpTransferEncoding . SINGLE ; </a> 0
<a> protected DefaultHttpMessage ( final HttpVersion version ) { </a> 0
<a> setProtocolVersion ( version ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void addHeader ( final String name , final Object value ) { </a> 0
<a> headers . addHeader ( name , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setHeader ( final String name , final Object value ) { </a> 0
<a> headers . setHeader ( name , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setHeader ( final String name , final Iterable < ? > values ) { </a> 0
<a> headers . setHeader ( name , values ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void removeHeader ( final String name ) { </a> 0
<a> headers . removeHeader ( name ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public HttpTransferEncoding getTransferEncoding ( ) { </a> 0
<a> return te ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setTransferEncoding ( HttpTransferEncoding te ) { </a> 0
<a> if ( te == null ) { </a> 0
<a> throw new NullPointerException ( "te (transferEncoding)" ) ; </a> 0
<a> } </a> 0
<a> this . te = te ; </a> 0
<a> switch ( te ) { </a> 0
<a> case SINGLE : </a> 0
<a> HttpCodecUtil . removeTransferEncodingChunked ( this ) ; </a> 0
<a> break ; </a> 0
<a> case STREAMED : </a> 0
<a> HttpCodecUtil . removeTransferEncodingChunked ( this ) ; </a> 0
<a> setContent ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> break ; </a> 0
<a> case CHUNKED : </a> 0
<a> if ( ! HttpCodecUtil . isTransferEncodingChunked ( this ) ) { </a> 0
<a> addHeader ( HttpHeaders . Names . TRANSFER_ENCODING , HttpHeaders . Values . CHUNKED ) ; </a> 0
<a> } </a> 0
<a> removeHeader ( HttpHeaders . Names . CONTENT_LENGTH ) ; </a> 0
<a> setContent ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clearHeaders ( ) { </a> 0
<a> headers . clearHeaders ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setContent ( ByteBuf content ) { </a> 1
<a> if ( content == null ) { </a> 1
<a> content = Unpooled . EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> if ( ! getTransferEncoding ( ) . isSingle ( ) && content . readable ( ) ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "non-empty content disallowed if this.transferEncoding != SINGLE" ) ; </a> 0
<a> } </a> 0
<a> this . content = content ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public String getHeader ( final String name ) { </a> 0
<a> return headers . getHeader ( name ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public List < String > getHeaders ( final String name ) { </a> 0
<a> return headers . getHeaders ( name ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public List < Map . Entry < String , String > > getHeaders ( ) { </a> 0
<a> return headers . getHeaders ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean containsHeader ( final String name ) { </a> 0
<a> return headers . containsHeader ( name ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Set < String > getHeaderNames ( ) { </a> 0
<a> return headers . getHeaderNames ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public HttpVersion getProtocolVersion ( ) { </a> 0
<a> return version ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setProtocolVersion ( HttpVersion version ) { </a> 1
<a> if ( version == null ) { </a> 0
<a> throw new NullPointerException ( "version" ) ; </a> 0
<a> } </a> 0
<a> this . version = version ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf getContent ( ) { </a> 0
<a> if ( getTransferEncoding ( ) == HttpTransferEncoding . SINGLE ) { </a> 0
<a> return content ; </a> 0
<a> } else { </a> 0
<a> return Unpooled . EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 0
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> buf . append ( "(version: " ) ; </a> 1
<a> buf . append ( getProtocolVersion ( ) . getText ( ) ) ; </a> 1
<a> buf . append ( ", keepAlive: " ) ; </a> 1
<a> buf . append ( HttpHeaders . isKeepAlive ( this ) ) ; </a> 1
<a> buf . append ( ", transferEncoding: " ) ; </a> 0
<a> buf . append ( getTransferEncoding ( ) ) ; </a> 0
<a> buf . append ( ')' ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 0
<a> appendHeaders ( buf ) ; </a> 0
<a> buf . setLength ( buf . length ( ) - StringUtil . NEWLINE . length ( ) ) ; </a> 0
<a> return buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> void appendHeaders ( StringBuilder buf ) { </a> 0
<a> for ( Map . Entry < String , String > e : getHeaders ( ) ) { </a> 0
<a> buf . append ( e . getKey ( ) ) ; </a> 0
<a> buf . append ( ": " ) ; </a> 0
<a> buf . append ( e . getValue ( ) ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . util . internal . StringUtil ; </a> 0
<a> public class DefaultHttpRequest extends DefaultHttpMessage implements HttpRequest { </a> 0
<a> private HttpMethod method ; </a> 1
<a> private String uri ; </a> 1
<a> public DefaultHttpRequest ( HttpVersion httpVersion , HttpMethod method , String uri ) { </a> 0
<a> super ( httpVersion ) ; </a> 1
<a> setMethod ( method ) ; </a> 1
<a> setUri ( uri ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> public HttpMethod getMethod ( ) { </a> 0
<a> return method ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void setMethod ( HttpMethod method ) { </a> 1
<a> if ( method == null ) { </a> 1
<a> throw new NullPointerException ( "method" ) ; </a> 1
<a> } </a> 1
<a> this . method = method ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getUri ( ) { </a> 0
<a> return uri ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setUri ( String uri ) { </a> 1
<a> if ( uri == null ) { </a> 0
<a> throw new NullPointerException ( "uri" ) ; </a> 0
<a> } </a> 0
<a> this . uri = uri ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String toString ( ) { </a> 1
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> buf . append ( "(transferEncoding: " ) ; </a> 0
<a> buf . append ( getTransferEncoding ( ) ) ; </a> 0
<a> buf . append ( ')' ) ; </a> 1
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( getMethod ( ) . toString ( ) ) ; </a> 1
<a> buf . append ( ' ' ) ; </a> 1
<a> buf . append ( getUri ( ) ) ; </a> 1
<a> buf . append ( ' ' ) ; </a> 1
<a> buf . append ( getProtocolVersion ( ) . getText ( ) ) ; </a> 1
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> appendHeaders ( buf ) ; </a> 1
<a> buf . setLength ( buf . length ( ) - StringUtil . NEWLINE . length ( ) ) ; </a> 1
<a> return buf . toString ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import java . util . List ; </a> 1
<a> import java . util . Map ; </a> 1
<a> import java . util . Set ; </a> 1
<a> public interface HttpChunkTrailer extends HttpChunk { </a> 0
<a> @ Override </a> 0
<a> boolean isLast ( ) ; </a> 0
<a> String getHeader ( String name ) ; </a> 1
<a> List < String > getHeaders ( String name ) ; </a> 1
<a> List < Map . Entry < String , String > > getHeaders ( ) ; </a> 1
<a> boolean containsHeader ( String name ) ; </a> 1
<a> Set < String > getHeaderNames ( ) ; </a> 1
<a> void addHeader ( String name , Object value ) ; </a> 1
<a> void setHeader ( String name , Object value ) ; </a> 1
<a> void setHeader ( String name , Iterable < ? > values ) ; </a> 1
<a> void removeHeader ( String name ) ; </a> 1
<a> void clearHeaders ( ) ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import java . util . List ; </a> 0
<a> final class HttpCodecUtil { </a> 0
<a> static void validateHeaderName ( String headerName ) { </a> 0
<a> if ( headerName == null ) { </a> 0
<a> throw new NullPointerException ( "Header names cannot be null" ) ; </a> 0
<a> } </a> 0
<a> for ( int index = 0 ; index < headerName . length ( ) ; index ++ ) { </a> 0
<a> char character = headerName . charAt ( index ) ; </a> 0
<a> if ( character > 127 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Header name cannot contain non-ASCII characters: " + headerName ) ; </a> 0
<a> } </a> 0
<a> switch ( character ) { </a> 0
<a> case '\t' : case '\n' : case 0x0b : case '\f' : case '\r' : </a> 0
<a> case ' ' : case ',' : case ':' : case ';' : case '=' : </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Header name cannot contain the following prohibited characters: " + </a> 0
<a> "=,;: \\t\\r\\n\\v\\f: " + headerName ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static void validateHeaderValue ( String headerValue ) { </a> 0
<a> if ( headerValue == null ) { </a> 0
<a> throw new NullPointerException ( "Header values cannot be null" ) ; </a> 0
<a> } </a> 0
<a> int state = 0 ; </a> 0
<a> for ( int index = 0 ; index < headerValue . length ( ) ; index ++ ) { </a> 0
<a> char character = headerValue . charAt ( index ) ; </a> 0
<a> switch ( character ) { </a> 0
<a> case 0x0b : </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Header value contains a prohibited character '\\v': " + headerValue ) ; </a> 0
<a> case '\f' : </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Header value contains a prohibited character '\\f': " + headerValue ) ; </a> 0
<a> } </a> 0
<a> switch ( state ) { </a> 0
<a> case 0 : </a> 0
<a> switch ( character ) { </a> 0
<a> case '\r' : </a> 0
<a> state = 1 ; </a> 0
<a> break ; </a> 0
<a> case '\n' : </a> 0
<a> state = 2 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> case 1 : </a> 0
<a> switch ( character ) { </a> 0
<a> case '\n' : </a> 0
<a> state = 2 ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Only '\\n' is allowed after '\\r': " + headerValue ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> case 2 : </a> 0
<a> switch ( character ) { </a> 0
<a> case '\t' : case ' ' : </a> 0
<a> state = 0 ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Only ' ' and '\\t' are allowed after '\\n': " + headerValue ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( state != 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Header value must not end with '\\r' or '\\n':" + headerValue ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static boolean isTransferEncodingChunked ( HttpMessage message ) { </a> 0
<a> List < String > transferEncodingHeaders = message . getHeaders ( HttpHeaders . Names . TRANSFER_ENCODING ) ; </a> 0
<a> if ( transferEncodingHeaders . isEmpty ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> for ( String value : transferEncodingHeaders ) { </a> 0
<a> if ( value . equalsIgnoreCase ( HttpHeaders . Values . CHUNKED ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> static void removeTransferEncodingChunked ( HttpMessage m ) { </a> 0
<a> List < String > values = m . getHeaders ( HttpHeaders . Names . TRANSFER_ENCODING ) ; </a> 0
<a> values . remove ( HttpHeaders . Values . CHUNKED ) ; </a> 0
<a> if ( values . isEmpty ( ) ) { </a> 0
<a> m . removeHeader ( HttpHeaders . Names . TRANSFER_ENCODING ) ; </a> 0
<a> } else { </a> 0
<a> m . setHeader ( HttpHeaders . Names . TRANSFER_ENCODING , values ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static boolean isContentLengthSet ( HttpMessage m ) { </a> 0
<a> List < String > contentLength = m . getHeaders ( HttpHeaders . Names . CONTENT_LENGTH ) ; </a> 0
<a> return ! contentLength . isEmpty ( ) ; </a> 0
<a> } </a> 0
<a> private HttpCodecUtil ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import io . netty . handler . codec . compression . ZlibCodecFactory ; </a> 0
<a> import io . netty . handler . codec . compression . ZlibWrapper ; </a> 0
<a> public class HttpContentDecompressor extends HttpContentDecoder { </a> 0
<a> @ Override </a> 0
<a> protected EmbeddedByteChannel newContentDecoder ( String contentEncoding ) throws Exception { </a> 1
<a> if ( "gzip" . equalsIgnoreCase ( contentEncoding ) || "x-gzip" . equalsIgnoreCase ( contentEncoding ) ) { </a> 0
<a> return new EmbeddedByteChannel ( ZlibCodecFactory . newZlibDecoder ( ZlibWrapper . GZIP ) ) ; </a> 0
<a> } else if ( "deflate" . equalsIgnoreCase ( contentEncoding ) || "x-deflate" . equalsIgnoreCase ( contentEncoding ) ) { </a> 0
<a> return new EmbeddedByteChannel ( ZlibCodecFactory . newZlibDecoder ( ZlibWrapper . ZLIB_OR_NONE ) ) ; </a> 0
<a> } </a> 1
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import io . netty . handler . codec . MessageToMessageCodec ; </a> 0
<a> import java . util . ArrayDeque ; </a> 0
<a> import java . util . Queue ; </a> 0
<a> public abstract class HttpContentEncoder extends MessageToMessageCodec < HttpMessage , HttpMessage , Object , Object > { </a> 0
<a> private final Queue < String > acceptEncodingQueue = new ArrayDeque < String > ( ) ; </a> 0
<a> private EmbeddedByteChannel encoder ; </a> 1
<a> protected HttpContentEncoder ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDecodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof HttpMessage ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public HttpMessage decode ( ChannelHandlerContext ctx , HttpMessage msg ) </a> 0
<a> throws Exception { </a> 0
<a> String acceptedEncoding = msg . getHeader ( HttpHeaders . Names . ACCEPT_ENCODING ) ; </a> 1
<a> if ( acceptedEncoding == null ) { </a> 0
<a> acceptedEncoding = HttpHeaders . Values . IDENTITY ; </a> 0
<a> } </a> 0
<a> boolean offered = acceptEncodingQueue . offer ( acceptedEncoding ) ; </a> 0
<a> assert offered ; </a> 0
<a> return msg ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof HttpMessage || msg instanceof HttpChunk ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object encode ( ChannelHandlerContext ctx , Object msg ) </a> 0
<a> throws Exception { </a> 1
<a> if ( msg instanceof HttpResponse && ( ( HttpResponse ) msg ) . getStatus ( ) . getCode ( ) == 100 ) { </a> 0
<a> return msg ; </a> 1
<a> } else if ( msg instanceof HttpMessage ) { </a> 0
<a> HttpMessage m = ( HttpMessage ) msg ; </a> 0
<a> cleanup ( ) ; </a> 1
<a> String acceptEncoding = acceptEncodingQueue . poll ( ) ; </a> 1
<a> if ( acceptEncoding == null ) { </a> 1
<a> throw new IllegalStateException ( "cannot send more responses than requests" ) ; </a> 1
<a> } </a> 1
<a> boolean hasContent = m . getTransferEncoding ( ) . isMultiple ( ) || m . getContent ( ) . readable ( ) ; </a> 0
<a> if ( ! hasContent ) { </a> 0
<a> return m ; </a> 0
<a> } </a> 0
<a> Result result = beginEncode ( m , acceptEncoding ) ; </a> 0
<a> if ( result == null ) { </a> 0
<a> return m ; </a> 0
<a> } </a> 0
<a> encoder = result . getContentEncoder ( ) ; </a> 0
<a> m . setHeader ( </a> 0
<a> HttpHeaders . Names . CONTENT_ENCODING , </a> 1
<a> result . getTargetContentEncoding ( ) ) ; </a> 0
<a> if ( m . getTransferEncoding ( ) . isSingle ( ) ) { </a> 0
<a> ByteBuf content = m . getContent ( ) ; </a> 0
<a> ByteBuf newContent = Unpooled . buffer ( ) ; </a> 0
<a> encode ( content , newContent ) ; </a> 0
<a> finishEncode ( newContent ) ; </a> 0
<a> m . setContent ( newContent ) ; </a> 0
<a> if ( m . containsHeader ( HttpHeaders . Names . CONTENT_LENGTH ) ) { </a> 0
<a> m . setHeader ( </a> 0
<a> HttpHeaders . Names . CONTENT_LENGTH , </a> 1
<a> Integer . toString ( newContent . readableBytes ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } else if ( msg instanceof HttpChunk ) { </a> 0
<a> HttpChunk c = ( HttpChunk ) msg ; </a> 0
<a> ByteBuf content = c . getContent ( ) ; </a> 0
<a> if ( encoder != null ) { </a> 1
<a> if ( ! c . isLast ( ) ) { </a> 0
<a> ByteBuf newContent = Unpooled . buffer ( ) ; </a> 0
<a> encode ( content , newContent ) ; </a> 0
<a> if ( content . readable ( ) ) { </a> 0
<a> c . setContent ( newContent ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> ByteBuf lastProduct = Unpooled . buffer ( ) ; </a> 0
<a> finishEncode ( lastProduct ) ; </a> 0
<a> if ( lastProduct . readable ( ) ) { </a> 0
<a> return new Object [ ] { new DefaultHttpChunk ( lastProduct ) , c } ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<a> return msg ; </a> 0
<a> } </a> 0
<a> protected abstract Result beginEncode ( HttpMessage msg , String acceptEncoding ) throws Exception ; </a> 0
<a> @ Override </a> 0
<a> public void afterRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> cleanup ( ) ; </a> 0
<a> super . afterRemove ( ctx ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> cleanup ( ) ; </a> 0
<a> super . channelInactive ( ctx ) ; </a> 0
<a> } </a> 0
<a> private void cleanup ( ) { </a> 0
<a> if ( encoder != null ) { </a> 0
<a> finishEncode ( Unpooled . buffer ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private void encode ( ByteBuf in , ByteBuf out ) { </a> 0
<a> encoder . writeOutbound ( in ) ; </a> 0
<a> fetchEncoderOutput ( out ) ; </a> 0
<a> } </a> 0
<a> private void finishEncode ( ByteBuf out ) { </a> 0
<a> if ( encoder . finish ( ) ) { </a> 0
<a> fetchEncoderOutput ( out ) ; </a> 0
<a> } </a> 0
<a> encoder = null ; </a> 0
<a> } </a> 0
<a> private void fetchEncoderOutput ( ByteBuf out ) { </a> 0
<a> for ( ; ; ) { </a> 0
<a> ByteBuf buf = encoder . readOutbound ( ) ; </a> 1
<a> if ( buf == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> out . writeBytes ( buf ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final class Result { </a> 0
<a> private final String targetContentEncoding ; </a> 0
<a> private final EmbeddedByteChannel contentEncoder ; </a> 1
<a> public Result ( String targetContentEncoding , EmbeddedByteChannel contentEncoder ) { </a> 1
<a> if ( targetContentEncoding == null ) { </a> 0
<a> throw new NullPointerException ( "targetContentEncoding" ) ; </a> 0
<a> } </a> 0
<a> if ( contentEncoder == null ) { </a> 0
<a> throw new NullPointerException ( "contentEncoder" ) ; </a> 0
<a> } </a> 0
<a> this . targetContentEncoding = targetContentEncoding ; </a> 0
<a> this . contentEncoder = contentEncoder ; </a> 0
<a> } </a> 0
<a> public String getTargetContentEncoding ( ) { </a> 0
<a> return targetContentEncoding ; </a> 0
<a> } </a> 0
<a> public EmbeddedByteChannel getContentEncoder ( ) { </a> 0
<a> return contentEncoder ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import java . text . ParseException ; </a> 0
<a> import java . util . Calendar ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . LinkedList ; </a> 1
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . TreeSet ; </a> 1
<a> public class HttpHeaders { </a> 1
<a> public static final class Names { </a> 0
<a> public static final String ACCEPT = "Accept" ; </a> 0
<a> public static final String ACCEPT_CHARSET = "Accept-Charset" ; </a> 0
<a> public static final String ACCEPT_ENCODING = "Accept-Encoding" ; </a> 0
<a> public static final String ACCEPT_LANGUAGE = "Accept-Language" ; </a> 0
<a> public static final String ACCEPT_RANGES = "Accept-Ranges" ; </a> 0
<a> public static final String ACCEPT_PATCH = "Accept-Patch" ; </a> 0
<a> public static final String AGE = "Age" ; </a> 0
<a> public static final String ALLOW = "Allow" ; </a> 0
<a> public static final String AUTHORIZATION = "Authorization" ; </a> 0
<a> public static final String CACHE_CONTROL = "Cache-Control" ; </a> 0
<a> public static final String CONNECTION = "Connection" ; </a> 0
<a> public static final String CONTENT_BASE = "Content-Base" ; </a> 0
<a> public static final String CONTENT_ENCODING = "Content-Encoding" ; </a> 0
<a> public static final String CONTENT_LANGUAGE = "Content-Language" ; </a> 0
<a> public static final String CONTENT_LENGTH = "Content-Length" ; </a> 0
<a> public static final String CONTENT_LOCATION = "Content-Location" ; </a> 0
<a> public static final String CONTENT_TRANSFER_ENCODING = "Content-Transfer-Encoding" ; </a> 0
<a> public static final String CONTENT_MD5 = "Content-MD5" ; </a> 0
<a> public static final String CONTENT_RANGE = "Content-Range" ; </a> 0
<a> public static final String CONTENT_TYPE = "Content-Type" ; </a> 0
<a> public static final String COOKIE = "Cookie" ; </a> 0
<a> public static final String DATE = "Date" ; </a> 0
<a> public static final String ETAG = "ETag" ; </a> 0
<a> public static final String EXPECT = "Expect" ; </a> 0
<a> public static final String EXPIRES = "Expires" ; </a> 0
<a> public static final String FROM = "From" ; </a> 0
<a> public static final String HOST = "Host" ; </a> 0
<a> public static final String IF_MATCH = "If-Match" ; </a> 0
<a> public static final String IF_MODIFIED_SINCE = "If-Modified-Since" ; </a> 0
<a> public static final String IF_NONE_MATCH = "If-None-Match" ; </a> 0
<a> public static final String IF_RANGE = "If-Range" ; </a> 0
<a> public static final String IF_UNMODIFIED_SINCE = "If-Unmodified-Since" ; </a> 0
<a> public static final String LAST_MODIFIED = "Last-Modified" ; </a> 0
<a> public static final String LOCATION = "Location" ; </a> 0
<a> public static final String MAX_FORWARDS = "Max-Forwards" ; </a> 0
<a> public static final String ORIGIN = "Origin" ; </a> 0
<a> public static final String PRAGMA = "Pragma" ; </a> 0
<a> public static final String PROXY_AUTHENTICATE = "Proxy-Authenticate" ; </a> 0
<a> public static final String PROXY_AUTHORIZATION = "Proxy-Authorization" ; </a> 0
<a> public static final String RANGE = "Range" ; </a> 0
<a> public static final String REFERER = "Referer" ; </a> 0
<a> public static final String RETRY_AFTER = "Retry-After" ; </a> 0
<a> public static final String SEC_WEBSOCKET_KEY1 = "Sec-WebSocket-Key1" ; </a> 0
<a> public static final String SEC_WEBSOCKET_KEY2 = "Sec-WebSocket-Key2" ; </a> 0
<a> public static final String SEC_WEBSOCKET_LOCATION = "Sec-WebSocket-Location" ; </a> 0
<a> public static final String SEC_WEBSOCKET_ORIGIN = "Sec-WebSocket-Origin" ; </a> 0
<a> public static final String SEC_WEBSOCKET_PROTOCOL = "Sec-WebSocket-Protocol" ; </a> 0
<a> public static final String SEC_WEBSOCKET_VERSION = "Sec-WebSocket-Version" ; </a> 0
<a> public static final String SEC_WEBSOCKET_KEY = "Sec-WebSocket-Key" ; </a> 0
<a> public static final String SEC_WEBSOCKET_ACCEPT = "Sec-WebSocket-Accept" ; </a> 0
<a> public static final String SERVER = "Server" ; </a> 0
<a> public static final String SET_COOKIE = "Set-Cookie" ; </a> 0
<a> public static final String SET_COOKIE2 = "Set-Cookie2" ; </a> 0
<a> public static final String TE = "TE" ; </a> 0
<a> public static final String TRAILER = "Trailer" ; </a> 0
<a> public static final String TRANSFER_ENCODING = "Transfer-Encoding" ; </a> 0
<a> public static final String UPGRADE = "Upgrade" ; </a> 0
<a> public static final String USER_AGENT = "User-Agent" ; </a> 0
<a> public static final String VARY = "Vary" ; </a> 0
<a> public static final String VIA = "Via" ; </a> 0
<a> public static final String WARNING = "Warning" ; </a> 0
<a> public static final String WEBSOCKET_LOCATION = "WebSocket-Location" ; </a> 0
<a> public static final String WEBSOCKET_ORIGIN = "WebSocket-Origin" ; </a> 0
<a> public static final String WEBSOCKET_PROTOCOL = "WebSocket-Protocol" ; </a> 0
<a> public static final String WWW_AUTHENTICATE = "WWW-Authenticate" ; </a> 0
<a> private Names ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final class Values { </a> 0
<a> public static final String APPLICATION_X_WWW_FORM_URLENCODED = </a> 0
<a> "application/x-www-form-urlencoded" ; </a> 0
<a> public static final String BASE64 = "base64" ; </a> 0
<a> public static final String BINARY = "binary" ; </a> 0
<a> public static final String BOUNDARY = "boundary" ; </a> 0
<a> public static final String BYTES = "bytes" ; </a> 0
<a> public static final String CHARSET = "charset" ; </a> 0
<a> public static final String CHUNKED = "chunked" ; </a> 0
<a> public static final String CLOSE = "close" ; </a> 0
<a> public static final String COMPRESS = "compress" ; </a> 0
<a> public static final String CONTINUE = "100-continue" ; </a> 0
<a> public static final String DEFLATE = "deflate" ; </a> 0
<a> public static final String GZIP = "gzip" ; </a> 0
<a> public static final String IDENTITY = "identity" ; </a> 0
<a> public static final String KEEP_ALIVE = "keep-alive" ; </a> 0
<a> public static final String MAX_AGE = "max-age" ; </a> 0
<a> public static final String MAX_STALE = "max-stale" ; </a> 0
<a> public static final String MIN_FRESH = "min-fresh" ; </a> 0
<a> public static final String MULTIPART_FORM_DATA = "multipart/form-data" ; </a> 0
<a> public static final String MUST_REVALIDATE = "must-revalidate" ; </a> 0
<a> public static final String NO_CACHE = "no-cache" ; </a> 0
<a> public static final String NO_STORE = "no-store" ; </a> 0
<a> public static final String NO_TRANSFORM = "no-transform" ; </a> 0
<a> public static final String NONE = "none" ; </a> 0
<a> public static final String ONLY_IF_CACHED = "only-if-cached" ; </a> 0
<a> public static final String PRIVATE = "private" ; </a> 0
<a> public static final String PROXY_REVALIDATE = "proxy-revalidate" ; </a> 0
<a> public static final String PUBLIC = "public" ; </a> 0
<a> public static final String QUOTED_PRINTABLE = "quoted-printable" ; </a> 0
<a> public static final String S_MAXAGE = "s-maxage" ; </a> 0
<a> public static final String TRAILERS = "trailers" ; </a> 0
<a> public static final String UPGRADE = "Upgrade" ; </a> 0
<a> public static final String WEBSOCKET = "WebSocket" ; </a> 0
<a> private Values ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static boolean isKeepAlive ( HttpMessage message ) { </a> 0
<a> String connection = message . getHeader ( Names . CONNECTION ) ; </a> 1
<a> if ( Values . CLOSE . equalsIgnoreCase ( connection ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( message . getProtocolVersion ( ) . isKeepAliveDefault ( ) ) { </a> 1
<a> return ! Values . CLOSE . equalsIgnoreCase ( connection ) ; </a> 0
<a> } else { </a> 0
<a> return Values . KEEP_ALIVE . equalsIgnoreCase ( connection ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void setKeepAlive ( HttpMessage message , boolean keepAlive ) { </a> 0
<a> if ( message . getProtocolVersion ( ) . isKeepAliveDefault ( ) ) { </a> 1
<a> if ( keepAlive ) { </a> 0
<a> message . removeHeader ( Names . CONNECTION ) ; </a> 1
<a> } else { </a> 0
<a> message . setHeader ( Names . CONNECTION , Values . CLOSE ) ; </a> 1
<a> } </a> 0
<a> } else { </a> 0
<a> if ( keepAlive ) { </a> 0
<a> message . setHeader ( Names . CONNECTION , Values . KEEP_ALIVE ) ; </a> 1
<a> } else { </a> 0
<a> message . removeHeader ( Names . CONNECTION ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static String getHeader ( HttpMessage message , String name ) { </a> 0
<a> return message . getHeader ( name ) ; </a> 1
<a> } </a> 0
<a> public static String getHeader ( HttpMessage message , String name , String defaultValue ) { </a> 0
<a> String value = message . getHeader ( name ) ; </a> 1
<a> if ( value == null ) { </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> return value ; </a> 0
<a> } </a> 0
<a> public static void setHeader ( HttpMessage message , String name , Object value ) { </a> 0
<a> message . setHeader ( name , value ) ; </a> 1
<a> } </a> 0
<a> public static void setHeader ( HttpMessage message , String name , Iterable < ? > values ) { </a> 0
<a> message . setHeader ( name , values ) ; </a> 1
<a> } </a> 0
<a> public static void addHeader ( HttpMessage message , String name , Object value ) { </a> 0
<a> message . addHeader ( name , value ) ; </a> 1
<a> } </a> 0
<a> public static void removeHeader ( HttpMessage message , String name ) { </a> 0
<a> message . removeHeader ( name ) ; </a> 1
<a> } </a> 0
<a> public static void clearHeaders ( HttpMessage message ) { </a> 0
<a> message . clearHeaders ( ) ; </a> 1
<a> } </a> 0
<a> public static int getIntHeader ( HttpMessage message , String name ) { </a> 0
<a> String value = getHeader ( message , name ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NumberFormatException ( "header not found: " + name ) ; </a> 0
<a> } </a> 0
<a> return Integer . parseInt ( value ) ; </a> 0
<a> } </a> 0
<a> public static int getIntHeader ( HttpMessage message , String name , int defaultValue ) { </a> 0
<a> String value = getHeader ( message , name ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> return Integer . parseInt ( value ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void setIntHeader ( HttpMessage message , String name , int value ) { </a> 0
<a> message . setHeader ( name , value ) ; </a> 1
<a> } </a> 0
<a> public static void setIntHeader ( HttpMessage message , String name , Iterable < Integer > values ) { </a> 0
<a> message . setHeader ( name , values ) ; </a> 1
<a> } </a> 0
<a> public static void addIntHeader ( HttpMessage message , String name , int value ) { </a> 0
<a> message . addHeader ( name , value ) ; </a> 1
<a> } </a> 0
<a> public static Date getDateHeader ( HttpMessage message , String name ) throws ParseException { </a> 0
<a> String value = getHeader ( message , name ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new ParseException ( "header not found: " + name , 0 ) ; </a> 0
<a> } </a> 0
<a> return new HttpHeaderDateFormat ( ) . parse ( value ) ; </a> 0
<a> } </a> 0
<a> public static Date getDateHeader ( HttpMessage message , String name , Date defaultValue ) { </a> 0
<a> final String value = getHeader ( message , name ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> return new HttpHeaderDateFormat ( ) . parse ( value ) ; </a> 0
<a> } catch ( ParseException e ) { </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void setDateHeader ( HttpMessage message , String name , Date value ) { </a> 0
<a> if ( value != null ) { </a> 0
<a> message . setHeader ( name , new HttpHeaderDateFormat ( ) . format ( value ) ) ; </a> 1
<a> } else { </a> 0
<a> message . setHeader ( name , null ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> public static void setDateHeader ( HttpMessage message , String name , Iterable < Date > values ) { </a> 0
<a> message . setHeader ( name , values ) ; </a> 1
<a> } </a> 0
<a> public static void addDateHeader ( HttpMessage message , String name , Date value ) { </a> 0
<a> message . addHeader ( name , value ) ; </a> 1
<a> } </a> 0
<a> public static long getContentLength ( HttpMessage message ) { </a> 0
<a> String value = getHeader ( message , Names . CONTENT_LENGTH ) ; </a> 0
<a> if ( value != null ) { </a> 0
<a> return Long . parseLong ( value ) ; </a> 0
<a> } </a> 0
<a> long webSocketContentLength = getWebSocketContentLength ( message ) ; </a> 0
<a> if ( webSocketContentLength >= 0 ) { </a> 0
<a> return webSocketContentLength ; </a> 0
<a> } </a> 0
<a> throw new NumberFormatException ( "header not found: " + Names . CONTENT_LENGTH ) ; </a> 0
<a> } </a> 0
<a> public static long getContentLength ( HttpMessage message , long defaultValue ) { </a> 0
<a> String contentLength = message . getHeader ( Names . CONTENT_LENGTH ) ; </a> 1
<a> if ( contentLength != null ) { </a> 0
<a> try { </a> 0
<a> return Long . parseLong ( contentLength ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> long webSocketContentLength = getWebSocketContentLength ( message ) ; </a> 0
<a> if ( webSocketContentLength >= 0 ) { </a> 0
<a> return webSocketContentLength ; </a> 0
<a> } </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> private static int getWebSocketContentLength ( HttpMessage message ) { </a> 0
<a> if ( message instanceof HttpRequest ) { </a> 0
<a> HttpRequest req = ( HttpRequest ) message ; </a> 0
<a> if ( HttpMethod . GET . equals ( req . getMethod ( ) ) && </a> 1
<a> req . containsHeader ( Names . SEC_WEBSOCKET_KEY1 ) && </a> 1
<a> req . containsHeader ( Names . SEC_WEBSOCKET_KEY2 ) ) { </a> 1
<a> return 8 ; </a> 0
<a> } </a> 0
<a> } else if ( message instanceof HttpResponse ) { </a> 0
<a> HttpResponse res = ( HttpResponse ) message ; </a> 0
<a> if ( res . getStatus ( ) . getCode ( ) == 101 && </a> 1
<a> res . containsHeader ( Names . SEC_WEBSOCKET_ORIGIN ) && </a> 1
<a> res . containsHeader ( Names . SEC_WEBSOCKET_LOCATION ) ) { </a> 1
<a> return 16 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> public static void setContentLength ( HttpMessage message , long length ) { </a> 0
<a> message . setHeader ( Names . CONTENT_LENGTH , length ) ; </a> 1
<a> } </a> 0
<a> public static String getHost ( HttpMessage message ) { </a> 0
<a> return message . getHeader ( Names . HOST ) ; </a> 1
<a> } </a> 0
<a> public static String getHost ( HttpMessage message , String defaultValue ) { </a> 0
<a> return getHeader ( message , Names . HOST , defaultValue ) ; </a> 0
<a> } </a> 0
<a> public static void setHost ( HttpMessage message , String value ) { </a> 0
<a> message . setHeader ( Names . HOST , value ) ; </a> 1
<a> } </a> 0
<a> public static Date getDate ( HttpMessage message ) throws ParseException { </a> 0
<a> return getDateHeader ( message , Names . DATE ) ; </a> 0
<a> } </a> 0
<a> public static Date getDate ( HttpMessage message , Date defaultValue ) { </a> 0
<a> return getDateHeader ( message , Names . DATE , defaultValue ) ; </a> 0
<a> } </a> 0
<a> public static void setDate ( HttpMessage message , Date value ) { </a> 0
<a> if ( value != null ) { </a> 0
<a> message . setHeader ( Names . DATE , new HttpHeaderDateFormat ( ) . format ( value ) ) ; </a> 1
<a> } else { </a> 0
<a> message . setHeader ( Names . DATE , null ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> public static boolean is100ContinueExpected ( HttpMessage message ) { </a> 0
<a> if ( ! ( message instanceof HttpRequest ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( message . getProtocolVersion ( ) . compareTo ( HttpVersion . HTTP_1_1 ) < 0 ) { </a> 1
<a> return false ; </a> 0
<a> } </a> 0
<a> String value = message . getHeader ( Names . EXPECT ) ; </a> 1
<a> if ( value == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( Values . CONTINUE . equalsIgnoreCase ( value ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> for ( String v : message . getHeaders ( Names . EXPECT ) ) { </a> 1
<a> if ( Values . CONTINUE . equalsIgnoreCase ( v ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> public static void set100ContinueExpected ( HttpMessage message ) { </a> 0
<a> set100ContinueExpected ( message , true ) ; </a> 0
<a> } </a> 0
<a> public static void set100ContinueExpected ( HttpMessage message , boolean set ) { </a> 0
<a> if ( set ) { </a> 0
<a> message . setHeader ( Names . EXPECT , Values . CONTINUE ) ; </a> 1
<a> } else { </a> 0
<a> message . removeHeader ( Names . EXPECT ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private static final int BUCKET_SIZE = 17 ; </a> 1
<a> private static int hash ( String name ) { </a> 1
<a> int h = 0 ; </a> 1
<a> for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { </a> 1
<a> char c = name . charAt ( i ) ; </a> 1
<a> if ( c >= 'A' && c <= 'Z' ) { </a> 1
<a> c += 32 ; </a> 1
<a> } </a> 1
<a> h = 31 * h + c ; </a> 1
<a> } </a> 1
<a> if ( h > 0 ) { </a> 1
<a> return h ; </a> 1
<a> } else if ( h == Integer . MIN_VALUE ) { </a> 1
<a> return Integer . MAX_VALUE ; </a> 1
<a> } else { </a> 1
<a> return - h ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private static boolean eq ( String name1 , String name2 ) { </a> 1
<a> int nameLen = name1 . length ( ) ; </a> 1
<a> if ( nameLen != name2 . length ( ) ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> for ( int i = nameLen - 1 ; i >= 0 ; i -- ) { </a> 1
<a> char c1 = name1 . charAt ( i ) ; </a> 1
<a> char c2 = name2 . charAt ( i ) ; </a> 1
<a> if ( c1 != c2 ) { </a> 1
<a> if ( c1 >= 'A' && c1 <= 'Z' ) { </a> 1
<a> c1 += 32 ; </a> 1
<a> } </a> 1
<a> if ( c2 >= 'A' && c2 <= 'Z' ) { </a> 1
<a> c2 += 32 ; </a> 1
<a> } </a> 1
<a> if ( c1 != c2 ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> private static int index ( int hash ) { </a> 1
<a> return hash % BUCKET_SIZE ; </a> 1
<a> } </a> 1
<a> private final Entry [ ] entries = new Entry [ BUCKET_SIZE ] ; </a> 1
<a> private final Entry head = new Entry ( - 1 , null , null ) ; </a> 1
<a> HttpHeaders ( ) { </a> 1
<a> head . before = head . after = head ; </a> 1
<a> } </a> 1
<a> void validateHeaderName ( String name ) { </a> 0
<a> HttpCodecUtil . validateHeaderName ( name ) ; </a> 0
<a> } </a> 1
<a> void addHeader ( final String name , final Object value ) { </a> 1
<a> validateHeaderName ( name ) ; </a> 0
<a> String strVal = toString ( value ) ; </a> 1
<a> HttpCodecUtil . validateHeaderValue ( strVal ) ; </a> 0
<a> int h = hash ( name ) ; </a> 1
<a> int i = index ( h ) ; </a> 1
<a> addHeader0 ( h , i , name , strVal ) ; </a> 1
<a> } </a> 1
<a> private void addHeader0 ( int h , int i , final String name , final String value ) { </a> 1
<a> Entry e = entries [ i ] ; </a> 1
<a> Entry newEntry ; </a> 1
<a> entries [ i ] = newEntry = new Entry ( h , name , value ) ; </a> 1
<a> newEntry . next = e ; </a> 1
<a> newEntry . addBefore ( head ) ; </a> 1
<a> } </a> 0
<a> void removeHeader ( final String name ) { </a> 1
<a> if ( name == null ) { </a> 1
<a> throw new NullPointerException ( "name" ) ; </a> 1
<a> } </a> 0
<a> int h = hash ( name ) ; </a> 1
<a> int i = index ( h ) ; </a> 1
<a> removeHeader0 ( h , i , name ) ; </a> 1
<a> } </a> 0
<a> private void removeHeader0 ( int h , int i , String name ) { </a> 1
<a> Entry e = entries [ i ] ; </a> 1
<a> if ( e == null ) { </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> for ( ; ; ) { </a> 1
<a> if ( e . hash == h && eq ( name , e . key ) ) { </a> 1
<a> e . remove ( ) ; </a> 1
<a> Entry next = e . next ; </a> 1
<a> if ( next != null ) { </a> 1
<a> entries [ i ] = next ; </a> 1
<a> e = next ; </a> 1
<a> } else { </a> 1
<a> entries [ i ] = null ; </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> for ( ; ; ) { </a> 1
<a> Entry next = e . next ; </a> 1
<a> if ( next == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> if ( next . hash == h && eq ( name , next . key ) ) { </a> 1
<a> e . next = next . next ; </a> 1
<a> next . remove ( ) ; </a> 1
<a> } else { </a> 1
<a> e = next ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void setHeader ( final String name , final Object value ) { </a> 1
<a> validateHeaderName ( name ) ; </a> 0
<a> String strVal = toString ( value ) ; </a> 1
<a> HttpCodecUtil . validateHeaderValue ( strVal ) ; </a> 0
<a> int h = hash ( name ) ; </a> 1
<a> int i = index ( h ) ; </a> 1
<a> removeHeader0 ( h , i , name ) ; </a> 1
<a> addHeader0 ( h , i , name , strVal ) ; </a> 1
<a> } </a> 1
<a> void setHeader ( final String name , final Iterable < ? > values ) { </a> 1
<a> if ( values == null ) { </a> 0
<a> throw new NullPointerException ( "values" ) ; </a> 0
<a> } </a> 0
<a> validateHeaderName ( name ) ; </a> 0
<a> int h = hash ( name ) ; </a> 1
<a> int i = index ( h ) ; </a> 1
<a> removeHeader0 ( h , i , name ) ; </a> 1
<a> for ( Object v : values ) { </a> 1
<a> if ( v == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> String strVal = toString ( v ) ; </a> 1
<a> HttpCodecUtil . validateHeaderValue ( strVal ) ; </a> 0
<a> addHeader0 ( h , i , name , strVal ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> void clearHeaders ( ) { </a> 1
<a> for ( int i = 0 ; i < entries . length ; i ++ ) { </a> 1
<a> entries [ i ] = null ; </a> 1
<a> } </a> 1
<a> head . before = head . after = head ; </a> 1
<a> } </a> 1
<a> String getHeader ( final String name ) { </a> 1
<a> if ( name == null ) { </a> 1
<a> throw new NullPointerException ( "name" ) ; </a> 1
<a> } </a> 1
<a> int h = hash ( name ) ; </a> 1
<a> int i = index ( h ) ; </a> 1
<a> Entry e = entries [ i ] ; </a> 1
<a> while ( e != null ) { </a> 1
<a> if ( e . hash == h && eq ( name , e . key ) ) { </a> 1
<a> return e . value ; </a> 1
<a> } </a> 1
<a> e = e . next ; </a> 1
<a> } </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> List < String > getHeaders ( final String name ) { </a> 1
<a> if ( name == null ) { </a> 1
<a> throw new NullPointerException ( "name" ) ; </a> 1
<a> } </a> 1
<a> LinkedList < String > values = new LinkedList < String > ( ) ; </a> 1
<a> int h = hash ( name ) ; </a> 1
<a> int i = index ( h ) ; </a> 1
<a> Entry e = entries [ i ] ; </a> 1
<a> while ( e != null ) { </a> 1
<a> if ( e . hash == h && eq ( name , e . key ) ) { </a> 1
<a> values . addFirst ( e . value ) ; </a> 1
<a> } </a> 1
<a> e = e . next ; </a> 1
<a> } </a> 1
<a> return values ; </a> 1
<a> } </a> 1
<a> List < Map . Entry < String , String > > getHeaders ( ) { </a> 1
<a> List < Map . Entry < String , String > > all = </a> 1
<a> new LinkedList < Map . Entry < String , String > > ( ) ; </a> 1
<a> Entry e = head . after ; </a> 1
<a> while ( e != head ) { </a> 1
<a> all . add ( e ) ; </a> 1
<a> e = e . after ; </a> 1
<a> } </a> 1
<a> return all ; </a> 1
<a> } </a> 1
<a> boolean containsHeader ( String name ) { </a> 1
<a> return getHeader ( name ) != null ; </a> 1
<a> } </a> 1
<a> Set < String > getHeaderNames ( ) { </a> 1
<a> Set < String > names = new TreeSet < String > ( String . CASE_INSENSITIVE_ORDER ) ; </a> 0
<a> Entry e = head . after ; </a> 1
<a> while ( e != head ) { </a> 1
<a> names . add ( e . key ) ; </a> 1
<a> e = e . after ; </a> 1
<a> } </a> 1
<a> return names ; </a> 1
<a> } </a> 1
<a> private static String toString ( Object value ) { </a> 1
<a> if ( value == null ) { </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> if ( value instanceof String ) { </a> 1
<a> return ( String ) value ; </a> 1
<a> } </a> 1
<a> if ( value instanceof Number ) { </a> 1
<a> return value . toString ( ) ; </a> 1
<a> } </a> 1
<a> if ( value instanceof Date ) { </a> 1
<a> return new HttpHeaderDateFormat ( ) . format ( ( Date ) value ) ; </a> 1
<a> } </a> 1
<a> if ( value instanceof Calendar ) { </a> 1
<a> return new HttpHeaderDateFormat ( ) . format ( ( ( Calendar ) value ) . getTime ( ) ) ; </a> 1
<a> } </a> 1
<a> return value . toString ( ) ; </a> 1
<a> } </a> 1
<a> private static final class Entry implements Map . Entry < String , String > { </a> 1
<a> final int hash ; </a> 1
<a> final String key ; </a> 1
<a> String value ; </a> 1
<a> Entry next ; </a> 1
<a> Entry before , after ; </a> 1
<a> Entry ( int hash , String key , String value ) { </a> 1
<a> this . hash = hash ; </a> 1
<a> this . key = key ; </a> 1
<a> this . value = value ; </a> 1
<a> } </a> 1
<a> void remove ( ) { </a> 1
<a> before . after = after ; </a> 1
<a> after . before = before ; </a> 1
<a> } </a> 1
<a> void addBefore ( Entry e ) { </a> 1
<a> after = e ; </a> 1
<a> before = e . before ; </a> 1
<a> before . after = this ; </a> 1
<a> after . before = this ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getKey ( ) { </a> 1
<a> return key ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getValue ( ) { </a> 1
<a> return value ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String setValue ( String value ) { </a> 1
<a> if ( value == null ) { </a> 1
<a> throw new NullPointerException ( "value" ) ; </a> 1
<a> } </a> 1
<a> HttpCodecUtil . validateHeaderValue ( value ) ; </a> 0
<a> String oldValue = this . value ; </a> 1
<a> this . value = value ; </a> 1
<a> return oldValue ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String toString ( ) { </a> 1
<a> return key + "=" + value ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> public class HttpResponseStatus implements Comparable < HttpResponseStatus > { </a> 0
<a> public static final HttpResponseStatus CONTINUE = new HttpResponseStatus ( 100 , "Continue" ) ; </a> 0
<a> public static final HttpResponseStatus SWITCHING_PROTOCOLS = new HttpResponseStatus ( 101 , "Switching Protocols" ) ; </a> 0
<a> public static final HttpResponseStatus PROCESSING = new HttpResponseStatus ( 102 , "Processing" ) ; </a> 0
<a> public static final HttpResponseStatus OK = new HttpResponseStatus ( 200 , "OK" ) ; </a> 0
<a> public static final HttpResponseStatus CREATED = new HttpResponseStatus ( 201 , "Created" ) ; </a> 0
<a> public static final HttpResponseStatus ACCEPTED = new HttpResponseStatus ( 202 , "Accepted" ) ; </a> 0
<a> public static final HttpResponseStatus NON_AUTHORITATIVE_INFORMATION = </a> 0
<a> new HttpResponseStatus ( 203 , "Non-Authoritative Information" ) ; </a> 0
<a> public static final HttpResponseStatus NO_CONTENT = new HttpResponseStatus ( 204 , "No Content" ) ; </a> 0
<a> public static final HttpResponseStatus RESET_CONTENT = new HttpResponseStatus ( 205 , "Reset Content" ) ; </a> 0
<a> public static final HttpResponseStatus PARTIAL_CONTENT = new HttpResponseStatus ( 206 , "Partial Content" ) ; </a> 0
<a> public static final HttpResponseStatus MULTI_STATUS = new HttpResponseStatus ( 207 , "Multi-Status" ) ; </a> 0
<a> public static final HttpResponseStatus MULTIPLE_CHOICES = new HttpResponseStatus ( 300 , "Multiple Choices" ) ; </a> 0
<a> public static final HttpResponseStatus MOVED_PERMANENTLY = new HttpResponseStatus ( 301 , "Moved Permanently" ) ; </a> 0
<a> public static final HttpResponseStatus FOUND = new HttpResponseStatus ( 302 , "Found" ) ; </a> 0
<a> public static final HttpResponseStatus SEE_OTHER = new HttpResponseStatus ( 303 , "See Other" ) ; </a> 0
<a> public static final HttpResponseStatus NOT_MODIFIED = new HttpResponseStatus ( 304 , "Not Modified" ) ; </a> 0
<a> public static final HttpResponseStatus USE_PROXY = new HttpResponseStatus ( 305 , "Use Proxy" ) ; </a> 0
<a> public static final HttpResponseStatus TEMPORARY_REDIRECT = new HttpResponseStatus ( 307 , "Temporary Redirect" ) ; </a> 0
<a> public static final HttpResponseStatus BAD_REQUEST = new HttpResponseStatus ( 400 , "Bad Request" ) ; </a> 0
<a> public static final HttpResponseStatus UNAUTHORIZED = new HttpResponseStatus ( 401 , "Unauthorized" ) ; </a> 0
<a> public static final HttpResponseStatus PAYMENT_REQUIRED = new HttpResponseStatus ( 402 , "Payment Required" ) ; </a> 0
<a> public static final HttpResponseStatus FORBIDDEN = new HttpResponseStatus ( 403 , "Forbidden" ) ; </a> 0
<a> public static final HttpResponseStatus NOT_FOUND = new HttpResponseStatus ( 404 , "Not Found" ) ; </a> 0
<a> public static final HttpResponseStatus METHOD_NOT_ALLOWED = new HttpResponseStatus ( 405 , "Method Not Allowed" ) ; </a> 0
<a> public static final HttpResponseStatus NOT_ACCEPTABLE = new HttpResponseStatus ( 406 , "Not Acceptable" ) ; </a> 0
<a> public static final HttpResponseStatus PROXY_AUTHENTICATION_REQUIRED = </a> 0
<a> new HttpResponseStatus ( 407 , "Proxy Authentication Required" ) ; </a> 0
<a> public static final HttpResponseStatus REQUEST_TIMEOUT = new HttpResponseStatus ( 408 , "Request Timeout" ) ; </a> 0
<a> public static final HttpResponseStatus CONFLICT = new HttpResponseStatus ( 409 , "Conflict" ) ; </a> 0
<a> public static final HttpResponseStatus GONE = new HttpResponseStatus ( 410 , "Gone" ) ; </a> 0
<a> public static final HttpResponseStatus LENGTH_REQUIRED = new HttpResponseStatus ( 411 , "Length Required" ) ; </a> 0
<a> public static final HttpResponseStatus PRECONDITION_FAILED = new HttpResponseStatus ( 412 , "Precondition Failed" ) ; </a> 0
<a> public static final HttpResponseStatus REQUEST_ENTITY_TOO_LARGE = </a> 0
<a> new HttpResponseStatus ( 413 , "Request Entity Too Large" ) ; </a> 0
<a> public static final HttpResponseStatus REQUEST_URI_TOO_LONG = new HttpResponseStatus ( 414 , "Request-URI Too Long" ) ; </a> 0
<a> public static final HttpResponseStatus UNSUPPORTED_MEDIA_TYPE = </a> 0
<a> new HttpResponseStatus ( 415 , "Unsupported Media Type" ) ; </a> 0
<a> public static final HttpResponseStatus REQUESTED_RANGE_NOT_SATISFIABLE = </a> 0
<a> new HttpResponseStatus ( 416 , "Requested Range Not Satisfiable" ) ; </a> 0
<a> public static final HttpResponseStatus EXPECTATION_FAILED = new HttpResponseStatus ( 417 , "Expectation Failed" ) ; </a> 0
<a> public static final HttpResponseStatus UNPROCESSABLE_ENTITY = new HttpResponseStatus ( 422 , "Unprocessable Entity" ) ; </a> 0
<a> public static final HttpResponseStatus LOCKED = new HttpResponseStatus ( 423 , "Locked" ) ; </a> 0
<a> public static final HttpResponseStatus FAILED_DEPENDENCY = new HttpResponseStatus ( 424 , "Failed Dependency" ) ; </a> 0
<a> public static final HttpResponseStatus UNORDERED_COLLECTION = new HttpResponseStatus ( 425 , "Unordered Collection" ) ; </a> 0
<a> public static final HttpResponseStatus UPGRADE_REQUIRED = new HttpResponseStatus ( 426 , "Upgrade Required" ) ; </a> 0
<a> public static final HttpResponseStatus INTERNAL_SERVER_ERROR = </a> 0
<a> new HttpResponseStatus ( 500 , "Internal Server Error" ) ; </a> 0
<a> public static final HttpResponseStatus NOT_IMPLEMENTED = new HttpResponseStatus ( 501 , "Not Implemented" ) ; </a> 0
<a> public static final HttpResponseStatus BAD_GATEWAY = new HttpResponseStatus ( 502 , "Bad Gateway" ) ; </a> 0
<a> public static final HttpResponseStatus SERVICE_UNAVAILABLE = new HttpResponseStatus ( 503 , "Service Unavailable" ) ; </a> 0
<a> public static final HttpResponseStatus GATEWAY_TIMEOUT = new HttpResponseStatus ( 504 , "Gateway Timeout" ) ; </a> 0
<a> public static final HttpResponseStatus HTTP_VERSION_NOT_SUPPORTED = </a> 0
<a> new HttpResponseStatus ( 505 , "HTTP Version Not Supported" ) ; </a> 0
<a> public static final HttpResponseStatus VARIANT_ALSO_NEGOTIATES = </a> 0
<a> new HttpResponseStatus ( 506 , "Variant Also Negotiates" ) ; </a> 0
<a> public static final HttpResponseStatus INSUFFICIENT_STORAGE = new HttpResponseStatus ( 507 , "Insufficient Storage" ) ; </a> 0
<a> public static final HttpResponseStatus NOT_EXTENDED = new HttpResponseStatus ( 510 , "Not Extended" ) ; </a> 0
<a> public static HttpResponseStatus valueOf ( int code ) { </a> 0
<a> switch ( code ) { </a> 0
<a> case 100 : </a> 0
<a> return CONTINUE ; </a> 0
<a> case 101 : </a> 0
<a> return SWITCHING_PROTOCOLS ; </a> 0
<a> case 102 : </a> 0
<a> return PROCESSING ; </a> 0
<a> case 200 : </a> 0
<a> return OK ; </a> 0
<a> case 201 : </a> 0
<a> return CREATED ; </a> 0
<a> case 202 : </a> 0
<a> return ACCEPTED ; </a> 0
<a> case 203 : </a> 0
<a> return NON_AUTHORITATIVE_INFORMATION ; </a> 0
<a> case 204 : </a> 0
<a> return NO_CONTENT ; </a> 0
<a> case 205 : </a> 0
<a> return RESET_CONTENT ; </a> 0
<a> case 206 : </a> 0
<a> return PARTIAL_CONTENT ; </a> 0
<a> case 207 : </a> 0
<a> return MULTI_STATUS ; </a> 0
<a> case 300 : </a> 0
<a> return MULTIPLE_CHOICES ; </a> 0
<a> case 301 : </a> 0
<a> return MOVED_PERMANENTLY ; </a> 0
<a> case 302 : </a> 0
<a> return FOUND ; </a> 0
<a> case 303 : </a> 0
<a> return SEE_OTHER ; </a> 0
<a> case 304 : </a> 0
<a> return NOT_MODIFIED ; </a> 0
<a> case 305 : </a> 0
<a> return USE_PROXY ; </a> 0
<a> case 307 : </a> 0
<a> return TEMPORARY_REDIRECT ; </a> 0
<a> case 400 : </a> 0
<a> return BAD_REQUEST ; </a> 0
<a> case 401 : </a> 0
<a> return UNAUTHORIZED ; </a> 0
<a> case 402 : </a> 0
<a> return PAYMENT_REQUIRED ; </a> 0
<a> case 403 : </a> 0
<a> return FORBIDDEN ; </a> 0
<a> case 404 : </a> 0
<a> return NOT_FOUND ; </a> 0
<a> case 405 : </a> 0
<a> return METHOD_NOT_ALLOWED ; </a> 0
<a> case 406 : </a> 0
<a> return NOT_ACCEPTABLE ; </a> 0
<a> case 407 : </a> 0
<a> return PROXY_AUTHENTICATION_REQUIRED ; </a> 0
<a> case 408 : </a> 0
<a> return REQUEST_TIMEOUT ; </a> 0
<a> case 409 : </a> 0
<a> return CONFLICT ; </a> 0
<a> case 410 : </a> 0
<a> return GONE ; </a> 0
<a> case 411 : </a> 0
<a> return LENGTH_REQUIRED ; </a> 0
<a> case 412 : </a> 0
<a> return PRECONDITION_FAILED ; </a> 0
<a> case 413 : </a> 0
<a> return REQUEST_ENTITY_TOO_LARGE ; </a> 0
<a> case 414 : </a> 0
<a> return REQUEST_URI_TOO_LONG ; </a> 0
<a> case 415 : </a> 0
<a> return UNSUPPORTED_MEDIA_TYPE ; </a> 0
<a> case 416 : </a> 0
<a> return REQUESTED_RANGE_NOT_SATISFIABLE ; </a> 0
<a> case 417 : </a> 0
<a> return EXPECTATION_FAILED ; </a> 0
<a> case 422 : </a> 0
<a> return UNPROCESSABLE_ENTITY ; </a> 0
<a> case 423 : </a> 0
<a> return LOCKED ; </a> 0
<a> case 424 : </a> 0
<a> return FAILED_DEPENDENCY ; </a> 0
<a> case 425 : </a> 0
<a> return UNORDERED_COLLECTION ; </a> 0
<a> case 426 : </a> 0
<a> return UPGRADE_REQUIRED ; </a> 0
<a> case 500 : </a> 0
<a> return INTERNAL_SERVER_ERROR ; </a> 0
<a> case 501 : </a> 0
<a> return NOT_IMPLEMENTED ; </a> 0
<a> case 502 : </a> 0
<a> return BAD_GATEWAY ; </a> 0
<a> case 503 : </a> 0
<a> return SERVICE_UNAVAILABLE ; </a> 0
<a> case 504 : </a> 0
<a> return GATEWAY_TIMEOUT ; </a> 0
<a> case 505 : </a> 0
<a> return HTTP_VERSION_NOT_SUPPORTED ; </a> 0
<a> case 506 : </a> 0
<a> return VARIANT_ALSO_NEGOTIATES ; </a> 0
<a> case 507 : </a> 0
<a> return INSUFFICIENT_STORAGE ; </a> 0
<a> case 510 : </a> 0
<a> return NOT_EXTENDED ; </a> 0
<a> } </a> 0
<a> final String reasonPhrase ; </a> 1
<a> if ( code < 100 ) { </a> 1
<a> reasonPhrase = "Unknown Status" ; </a> 1
<a> } else if ( code < 200 ) { </a> 1
<a> reasonPhrase = "Informational" ; </a> 1
<a> } else if ( code < 300 ) { </a> 1
<a> reasonPhrase = "Successful" ; </a> 1
<a> } else if ( code < 400 ) { </a> 1
<a> reasonPhrase = "Redirection" ; </a> 1
<a> } else if ( code < 500 ) { </a> 1
<a> reasonPhrase = "Client Error" ; </a> 1
<a> } else if ( code < 600 ) { </a> 1
<a> reasonPhrase = "Server Error" ; </a> 1
<a> } else { </a> 1
<a> reasonPhrase = "Unknown Status" ; </a> 1
<a> } </a> 1
<a> return new HttpResponseStatus ( code , reasonPhrase + " (" + code + ')' ) ; </a> 1
<a> } </a> 0
<a> private final int code ; </a> 0
<a> private final String reasonPhrase ; </a> 1
<a> public HttpResponseStatus ( int code , String reasonPhrase ) { </a> 0
<a> if ( code < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "code: " + code + " (expected: 0+)" ) ; </a> 0
<a> } </a> 0
<a> if ( reasonPhrase == null ) { </a> 0
<a> throw new NullPointerException ( "reasonPhrase" ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < reasonPhrase . length ( ) ; i ++ ) { </a> 0
<a> char c = reasonPhrase . charAt ( i ) ; </a> 0
<a> switch ( c ) { </a> 0
<a> case '\n' : case '\r' : </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "reasonPhrase contains one of the following prohibited characters: " + </a> 0
<a> "\\r\\n: " + reasonPhrase ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> this . code = code ; </a> 0
<a> this . reasonPhrase = reasonPhrase ; </a> 1
<a> } </a> 0
<a> public int getCode ( ) { </a> 1
<a> return code ; </a> 0
<a> } </a> 0
<a> public String getReasonPhrase ( ) { </a> 1
<a> return reasonPhrase ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return getCode ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object o ) { </a> 0
<a> if ( ! ( o instanceof HttpResponseStatus ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return getCode ( ) == ( ( HttpResponseStatus ) o ) . getCode ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( HttpResponseStatus o ) { </a> 0
<a> return getCode ( ) - o . getCode ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( reasonPhrase . length ( ) + 5 ) ; </a> 1
<a> buf . append ( code ) ; </a> 1
<a> buf . append ( ' ' ) ; </a> 1
<a> buf . append ( reasonPhrase ) ; </a> 1
<a> return buf . toString ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . channel . CombinedChannelHandler ; </a> 0
<a> public class HttpServerCodec extends CombinedChannelHandler { </a> 0
<a> public HttpServerCodec ( ) { </a> 0
<a> this ( 4096 , 8192 , 8192 ) ; </a> 0
<a> } </a> 0
<a> public HttpServerCodec ( </a> 0
<a> int maxInitialLineLength , int maxHeaderSize , int maxChunkSize ) { </a> 0
<a> super ( </a> 0
<a> new HttpRequestDecoder ( maxInitialLineLength , maxHeaderSize , maxChunkSize ) , </a> 0
<a> new HttpResponseEncoder ( ) ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class CloseWebSocketFrame extends WebSocketFrame { </a> 0
<a> public CloseWebSocketFrame ( ) { </a> 0
<a> setBinaryData ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> } </a> 0
<a> public CloseWebSocketFrame ( int statusCode , String reasonText ) { </a> 0
<a> this ( true , 0 , statusCode , reasonText ) ; </a> 0
<a> } </a> 0
<a> public CloseWebSocketFrame ( boolean finalFragment , int rsv ) { </a> 0
<a> this ( finalFragment , rsv , null ) ; </a> 1
<a> } </a> 0
<a> public CloseWebSocketFrame ( boolean finalFragment , int rsv , int statusCode , String reasonText ) { </a> 0
<a> setFinalFragment ( finalFragment ) ; </a> 0
<a> setRsv ( rsv ) ; </a> 0
<a> byte [ ] reasonBytes = new byte [ 0 ] ; </a> 1
<a> if ( reasonText != null ) { </a> 0
<a> reasonBytes = reasonText . getBytes ( CharsetUtil . UTF_8 ) ; </a> 0
<a> } </a> 0
<a> ByteBuf binaryData = Unpooled . buffer ( 2 + reasonBytes . length ) ; </a> 0
<a> binaryData . writeShort ( statusCode ) ; </a> 0
<a> if ( reasonBytes . length > 0 ) { </a> 0
<a> binaryData . writeBytes ( reasonBytes ) ; </a> 0
<a> } </a> 0
<a> binaryData . readerIndex ( 0 ) ; </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> } </a> 0
<a> public CloseWebSocketFrame ( boolean finalFragment , int rsv , ByteBuf binaryData ) { </a> 0
<a> setFinalFragment ( finalFragment ) ; </a> 0
<a> setRsv ( rsv ) ; </a> 0
<a> if ( binaryData == null ) { </a> 0
<a> setBinaryData ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> } else { </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public int getStatusCode ( ) { </a> 0
<a> ByteBuf binaryData = getBinaryData ( ) ; </a> 0
<a> if ( binaryData == null || binaryData . capacity ( ) == 0 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> binaryData . readerIndex ( 0 ) ; </a> 0
<a> int statusCode = binaryData . readShort ( ) ; </a> 0
<a> binaryData . readerIndex ( 0 ) ; </a> 0
<a> return statusCode ; </a> 0
<a> } </a> 0
<a> public String getReasonText ( ) { </a> 0
<a> ByteBuf binaryData = getBinaryData ( ) ; </a> 0
<a> if ( binaryData == null || binaryData . capacity ( ) <= 2 ) { </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> binaryData . readerIndex ( 2 ) ; </a> 0
<a> String reasonText = binaryData . toString ( CharsetUtil . UTF_8 ) ; </a> 0
<a> binaryData . readerIndex ( 0 ) ; </a> 0
<a> return reasonText ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getClass ( ) . getSimpleName ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class TextWebSocketFrame extends WebSocketFrame { </a> 0
<a> public TextWebSocketFrame ( ) { </a> 0
<a> setBinaryData ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> } </a> 0
<a> public TextWebSocketFrame ( String text ) { </a> 0
<a> if ( text == null || text . isEmpty ( ) ) { </a> 0
<a> setBinaryData ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> } else { </a> 0
<a> setBinaryData ( Unpooled . copiedBuffer ( text , CharsetUtil . UTF_8 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public TextWebSocketFrame ( ByteBuf binaryData ) { </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> } </a> 0
<a> public TextWebSocketFrame ( boolean finalFragment , int rsv , String text ) { </a> 0
<a> setFinalFragment ( finalFragment ) ; </a> 0
<a> setRsv ( rsv ) ; </a> 0
<a> if ( text == null || text . isEmpty ( ) ) { </a> 0
<a> setBinaryData ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> } else { </a> 0
<a> setBinaryData ( Unpooled . copiedBuffer ( text , CharsetUtil . UTF_8 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public TextWebSocketFrame ( boolean finalFragment , int rsv , ByteBuf binaryData ) { </a> 0
<a> setFinalFragment ( finalFragment ) ; </a> 0
<a> setRsv ( rsv ) ; </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> } </a> 0
<a> public String getText ( ) { </a> 0
<a> if ( getBinaryData ( ) == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return getBinaryData ( ) . toString ( CharsetUtil . UTF_8 ) ; </a> 0
<a> } </a> 0
<a> public void setText ( String text ) { </a> 0
<a> if ( text == null ) { </a> 0
<a> throw new NullPointerException ( "text" ) ; </a> 0
<a> } </a> 0
<a> setBinaryData ( Unpooled . copiedBuffer ( text , CharsetUtil . UTF_8 ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getClass ( ) . getSimpleName ( ) + "(text: " + getText ( ) + ')' ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . ReplayingDecoder ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> public class WebSocket00FrameDecoder extends ReplayingDecoder < WebSocketFrame , Void > { </a> 0
<a> static final int DEFAULT_MAX_FRAME_SIZE = 16384 ; </a> 0
<a> private final long maxFrameSize ; </a> 0
<a> private boolean receivedClosingHandshake ; </a> 0
<a> public WebSocket00FrameDecoder ( ) { </a> 0
<a> this ( DEFAULT_MAX_FRAME_SIZE ) ; </a> 0
<a> } </a> 0
<a> public WebSocket00FrameDecoder ( int maxFrameSize ) { </a> 0
<a> this . maxFrameSize = maxFrameSize ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public WebSocketFrame decode ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 0
<a> if ( receivedClosingHandshake ) { </a> 0
<a> in . skipBytes ( actualReadableBytes ( ) ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> byte type = in . readByte ( ) ; </a> 0
<a> if ( ( type & 0x80 ) == 0x80 ) { </a> 0
<a> return decodeBinaryFrame ( type , in ) ; </a> 0
<a> } else { </a> 0
<a> return decodeTextFrame ( in ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private WebSocketFrame decodeBinaryFrame ( byte type , ByteBuf buffer ) throws TooLongFrameException { </a> 0
<a> long frameSize = 0 ; </a> 0
<a> int lengthFieldSize = 0 ; </a> 0
<a> byte b ; </a> 0
<a> do { </a> 0
<a> b = buffer . readByte ( ) ; </a> 0
<a> frameSize <<= 7 ; </a> 0
<a> frameSize |= b & 0x7f ; </a> 0
<a> if ( frameSize > maxFrameSize ) { </a> 0
<a> throw new TooLongFrameException ( ) ; </a> 0
<a> } </a> 0
<a> lengthFieldSize ++ ; </a> 0
<a> if ( lengthFieldSize > 8 ) { </a> 0
<a> throw new TooLongFrameException ( ) ; </a> 0
<a> } </a> 0
<a> } while ( ( b & 0x80 ) == 0x80 ) ; </a> 0
<a> if ( type == ( byte ) 0xFF && frameSize == 0 ) { </a> 0
<a> receivedClosingHandshake = true ; </a> 0
<a> return new CloseWebSocketFrame ( ) ; </a> 0
<a> } </a> 0
<a> return new BinaryWebSocketFrame ( buffer . readBytes ( ( int ) frameSize ) ) ; </a> 0
<a> } </a> 0
<a> private WebSocketFrame decodeTextFrame ( ByteBuf buffer ) throws TooLongFrameException { </a> 0
<a> int ridx = buffer . readerIndex ( ) ; </a> 0
<a> int rbytes = actualReadableBytes ( ) ; </a> 0
<a> int delimPos = buffer . indexOf ( ridx , ridx + rbytes , ( byte ) 0xFF ) ; </a> 0
<a> if ( delimPos == - 1 ) { </a> 0
<a> if ( rbytes > maxFrameSize ) { </a> 0
<a> throw new TooLongFrameException ( ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int frameSize = delimPos - ridx ; </a> 0
<a> if ( frameSize > maxFrameSize ) { </a> 0
<a> throw new TooLongFrameException ( ) ; </a> 0
<a> } </a> 0
<a> ByteBuf binaryData = buffer . readBytes ( frameSize ) ; </a> 0
<a> buffer . skipBytes ( 1 ) ; </a> 0
<a> int ffDelimPos = binaryData . indexOf ( binaryData . readerIndex ( ) , binaryData . writerIndex ( ) , ( byte ) 0xFF ) ; </a> 0
<a> if ( ffDelimPos >= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "a text frame should not contain 0xFF." ) ; </a> 0
<a> } </a> 0
<a> return new TextWebSocketFrame ( binaryData ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . CorruptedFrameException ; </a> 0
<a> import io . netty . handler . codec . ReplayingDecoder ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> public class WebSocket08FrameDecoder extends ReplayingDecoder < WebSocketFrame , WebSocket08FrameDecoder . State > { </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocket08FrameDecoder . class ) ; </a> 0
<a> private static final byte OPCODE_CONT = 0x0 ; </a> 0
<a> private static final byte OPCODE_TEXT = 0x1 ; </a> 0
<a> private static final byte OPCODE_BINARY = 0x2 ; </a> 0
<a> private static final byte OPCODE_CLOSE = 0x8 ; </a> 0
<a> private static final byte OPCODE_PING = 0x9 ; </a> 0
<a> private static final byte OPCODE_PONG = 0xA ; </a> 0
<a> private UTF8Output fragmentedFramesText ; </a> 0
<a> private int fragmentedFramesCount ; </a> 0
<a> private final long maxFramePayloadLength ; </a> 0
<a> private boolean frameFinalFlag ; </a> 0
<a> private int frameRsv ; </a> 0
<a> private int frameOpcode ; </a> 0
<a> private long framePayloadLength ; </a> 0
<a> private ByteBuf framePayload ; </a> 0
<a> private int framePayloadBytesRead ; </a> 0
<a> private ByteBuf maskingKey ; </a> 1
<a> private final boolean allowExtensions ; </a> 0
<a> private final boolean maskedPayload ; </a> 0
<a> private boolean receivedClosingHandshake ; </a> 0
<a> public enum State { </a> 0
<a> FRAME_START , MASKING_KEY , PAYLOAD , CORRUPT </a> 0
<a> } </a> 0
<a> public WebSocket08FrameDecoder ( boolean maskedPayload , boolean allowExtensions , int maxFramePayloadLength ) { </a> 0
<a> super ( State . FRAME_START ) ; </a> 0
<a> this . maskedPayload = maskedPayload ; </a> 0
<a> this . allowExtensions = allowExtensions ; </a> 0
<a> this . maxFramePayloadLength = maxFramePayloadLength ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public WebSocketFrame decode ( </a> 0
<a> ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 0
<a> if ( receivedClosingHandshake ) { </a> 0
<a> in . skipBytes ( actualReadableBytes ( ) ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> switch ( state ( ) ) { </a> 0
<a> case FRAME_START : </a> 0
<a> framePayloadBytesRead = 0 ; </a> 0
<a> framePayloadLength = - 1 ; </a> 0
<a> framePayload = null ; </a> 0
<a> byte b = in . readByte ( ) ; </a> 0
<a> frameFinalFlag = ( b & 0x80 ) != 0 ; </a> 0
<a> frameRsv = ( b & 0x70 ) > > 4 ; </a> 0
<a> frameOpcode = b & 0x0F ; </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( "Decoding WebSocket Frame opCode=" + frameOpcode ) ; </a> 0
<a> } </a> 0
<a> b = in . readByte ( ) ; </a> 0
<a> boolean frameMasked = ( b & 0x80 ) != 0 ; </a> 0
<a> int framePayloadLen1 = b & 0x7F ; </a> 0
<a> if ( frameRsv != 0 && ! allowExtensions ) { </a> 0
<a> protocolViolation ( ctx , "RSV != 0 and no extension negotiated, RSV:" + frameRsv ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> if ( maskedPayload && ! frameMasked ) { </a> 0
<a> protocolViolation ( ctx , "unmasked client to server frame" ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> if ( frameOpcode > 7 ) { </a> 0
<a> if ( ! frameFinalFlag ) { </a> 0
<a> protocolViolation ( ctx , "fragmented control frame" ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> if ( framePayloadLen1 > 125 ) { </a> 0
<a> protocolViolation ( ctx , "control frame with payload length > 125 octets" ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> if ( ! ( frameOpcode == OPCODE_CLOSE || frameOpcode == OPCODE_PING || frameOpcode == OPCODE_PONG ) ) { </a> 1
<a> protocolViolation ( ctx , "control frame using reserved opcode " + frameOpcode ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> if ( frameOpcode == 8 && framePayloadLen1 == 1 ) { </a> 0
<a> protocolViolation ( ctx , "received close control frame with payload len 1" ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> } else { </a> 0
<a> if ( ! ( frameOpcode == OPCODE_CONT || frameOpcode == OPCODE_TEXT || frameOpcode == OPCODE_BINARY ) ) { </a> 1
<a> protocolViolation ( ctx , "data frame using reserved opcode " + frameOpcode ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> if ( fragmentedFramesCount == 0 && frameOpcode == OPCODE_CONT ) { </a> 0
<a> protocolViolation ( ctx , "received continuation data frame outside fragmented message" ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> if ( fragmentedFramesCount != 0 && frameOpcode != OPCODE_CONT && frameOpcode != OPCODE_PING ) { </a> 0
<a> protocolViolation ( ctx , "received non-continuation data frame while inside fragmented message" ) ; </a> 1
<a> return null ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> if ( framePayloadLen1 == 126 ) { </a> 0
<a> framePayloadLength = in . readUnsignedShort ( ) ; </a> 0
<a> if ( framePayloadLength < 126 ) { </a> 0
<a> protocolViolation ( ctx , "invalid data frame length (not using minimal length encoding)" ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } else if ( framePayloadLen1 == 127 ) { </a> 0
<a> framePayloadLength = in . readLong ( ) ; </a> 0
<a> if ( framePayloadLength < 65536 ) { </a> 0
<a> protocolViolation ( ctx , "invalid data frame length (not using minimal length encoding)" ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> framePayloadLength = framePayloadLen1 ; </a> 0
<a> } </a> 0
<a> if ( framePayloadLength > maxFramePayloadLength ) { </a> 0
<a> protocolViolation ( ctx , "Max frame length of " + maxFramePayloadLength + " has been exceeded." ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( "Decoding WebSocket Frame length=" + framePayloadLength ) ; </a> 0
<a> } </a> 0
<a> checkpoint ( State . MASKING_KEY ) ; </a> 0
<a> case MASKING_KEY : </a> 0
<a> if ( maskedPayload ) { </a> 0
<a> maskingKey = in . readBytes ( 4 ) ; </a> 1
<a> } </a> 0
<a> checkpoint ( State . PAYLOAD ) ; </a> 0
<a> case PAYLOAD : </a> 0
<a> int rbytes = actualReadableBytes ( ) ; </a> 0
<a> ByteBuf payloadBuffer = null ; </a> 1
<a> long willHaveReadByteCount = framePayloadBytesRead + rbytes ; </a> 0
<a> if ( willHaveReadByteCount == framePayloadLength ) { </a> 0
<a> payloadBuffer = in . readBytes ( rbytes ) ; </a> 0
<a> } else if ( willHaveReadByteCount < framePayloadLength ) { </a> 0
<a> payloadBuffer = in . readBytes ( rbytes ) ; </a> 0
<a> if ( framePayload == null ) { </a> 0
<a> framePayload = Unpooled . buffer ( toFrameLength ( framePayloadLength ) ) ; </a> 0
<a> } </a> 0
<a> framePayload . writeBytes ( payloadBuffer ) ; </a> 0
<a> framePayloadBytesRead += rbytes ; </a> 0
<a> return null ; </a> 1
<a> } else if ( willHaveReadByteCount > framePayloadLength ) { </a> 0
<a> payloadBuffer = in . readBytes ( toFrameLength ( framePayloadLength - framePayloadBytesRead ) ) ; </a> 0
<a> } </a> 0
<a> checkpoint ( State . FRAME_START ) ; </a> 0
<a> if ( framePayload == null ) { </a> 0
<a> framePayload = payloadBuffer ; </a> 0
<a> } else { </a> 0
<a> framePayload . writeBytes ( payloadBuffer ) ; </a> 0
<a> } </a> 0
<a> if ( maskedPayload ) { </a> 0
<a> unmask ( framePayload ) ; </a> 0
<a> } </a> 0
<a> if ( frameOpcode == OPCODE_PING ) { </a> 0
<a> return new PingWebSocketFrame ( frameFinalFlag , frameRsv , framePayload ) ; </a> 1
<a> } else if ( frameOpcode == OPCODE_PONG ) { </a> 0
<a> return new PongWebSocketFrame ( frameFinalFlag , frameRsv , framePayload ) ; </a> 1
<a> } else if ( frameOpcode == OPCODE_CLOSE ) { </a> 0
<a> checkCloseFrameBody ( ctx , framePayload ) ; </a> 0
<a> receivedClosingHandshake = true ; </a> 0
<a> return new CloseWebSocketFrame ( frameFinalFlag , frameRsv , framePayload ) ; </a> 1
<a> } </a> 0
<a> String aggregatedText = null ; </a> 0
<a> if ( frameFinalFlag ) { </a> 0
<a> if ( frameOpcode != OPCODE_PING ) { </a> 0
<a> fragmentedFramesCount = 0 ; </a> 0
<a> if ( frameOpcode == OPCODE_TEXT || fragmentedFramesText != null ) { </a> 0
<a> checkUTF8String ( ctx , framePayload . array ( ) ) ; </a> 0
<a> aggregatedText = fragmentedFramesText . toString ( ) ; </a> 0
<a> fragmentedFramesText = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( fragmentedFramesCount == 0 ) { </a> 0
<a> fragmentedFramesText = null ; </a> 0
<a> if ( frameOpcode == OPCODE_TEXT ) { </a> 0
<a> checkUTF8String ( ctx , framePayload . array ( ) ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( fragmentedFramesText != null ) { </a> 0
<a> checkUTF8String ( ctx , framePayload . array ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> fragmentedFramesCount ++ ; </a> 0
<a> } </a> 0
<a> if ( frameOpcode == OPCODE_TEXT ) { </a> 0
<a> return new TextWebSocketFrame ( frameFinalFlag , frameRsv , framePayload ) ; </a> 1
<a> } else if ( frameOpcode == OPCODE_BINARY ) { </a> 0
<a> return new BinaryWebSocketFrame ( frameFinalFlag , frameRsv , framePayload ) ; </a> 1
<a> } else if ( frameOpcode == OPCODE_CONT ) { </a> 0
<a> return new ContinuationWebSocketFrame ( frameFinalFlag , frameRsv , framePayload , aggregatedText ) ; </a> 1
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( "Cannot decode web socket frame with opcode: " + frameOpcode ) ; </a> 0
<a> } </a> 0
<a> case CORRUPT : </a> 0
<a> in . readByte ( ) ; </a> 0
<a> return null ; </a> 1
<a> default : </a> 0
<a> throw new Error ( "Shouldn't reach here." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void unmask ( ByteBuf frame ) { </a> 0
<a> byte [ ] bytes = frame . array ( ) ; </a> 0
<a> for ( int i = 0 ; i < bytes . length ; i ++ ) { </a> 0
<a> frame . setByte ( i , frame . getByte ( i ) ^ maskingKey . getByte ( i % 4 ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private void protocolViolation ( ChannelHandlerContext ctx , String reason ) throws CorruptedFrameException { </a> 0
<a> checkpoint ( State . CORRUPT ) ; </a> 0
<a> if ( ctx . channel ( ) . isActive ( ) ) { </a> 0
<a> ctx . flush ( ) . addListener ( ChannelFutureListener . CLOSE ) ; </a> 1
<a> } </a> 0
<a> throw new CorruptedFrameException ( reason ) ; </a> 0
<a> } </a> 0
<a> private static int toFrameLength ( long l ) throws TooLongFrameException { </a> 0
<a> if ( l > Integer . MAX_VALUE ) { </a> 0
<a> throw new TooLongFrameException ( "Length:" + l ) ; </a> 0
<a> } else { </a> 0
<a> return ( int ) l ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void checkUTF8String ( ChannelHandlerContext ctx , byte [ ] bytes ) throws CorruptedFrameException { </a> 0
<a> try { </a> 0
<a> if ( fragmentedFramesText == null ) { </a> 0
<a> fragmentedFramesText = new UTF8Output ( bytes ) ; </a> 0
<a> } else { </a> 0
<a> fragmentedFramesText . write ( bytes ) ; </a> 0
<a> } </a> 0
<a> } catch ( UTF8Exception ex ) { </a> 0
<a> protocolViolation ( ctx , "invalid UTF-8 bytes" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void checkCloseFrameBody ( </a> 0
<a> ChannelHandlerContext ctx , ByteBuf buffer ) throws CorruptedFrameException { </a> 0
<a> if ( buffer == null || buffer . capacity ( ) == 0 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( buffer . capacity ( ) == 1 ) { </a> 0
<a> protocolViolation ( ctx , "Invalid close frame body" ) ; </a> 0
<a> } </a> 0
<a> int idx = buffer . readerIndex ( ) ; </a> 0
<a> buffer . readerIndex ( 0 ) ; </a> 0
<a> int statusCode = buffer . readShort ( ) ; </a> 0
<a> if ( statusCode >= 0 && statusCode <= 999 || statusCode >= 1004 && statusCode <= 1006 </a> 0
<a> || statusCode >= 1012 && statusCode <= 2999 ) { </a> 0
<a> protocolViolation ( ctx , "Invalid close frame status code: " + statusCode ) ; </a> 1
<a> } </a> 0
<a> if ( buffer . readableBytes ( ) > 0 ) { </a> 0
<a> byte [ ] b = new byte [ buffer . readableBytes ( ) ] ; </a> 0
<a> buffer . readBytes ( b ) ; </a> 0
<a> try { </a> 0
<a> new UTF8Output ( b ) ; </a> 0
<a> } catch ( UTF8Exception ex ) { </a> 0
<a> protocolViolation ( ctx , "Invalid close frame reason text. Invalid UTF-8 bytes" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> buffer . readerIndex ( idx ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> public abstract class WebSocketFrame { </a> 0
<a> private boolean finalFragment = true ; </a> 0
<a> private int rsv ; </a> 0
<a> private ByteBuf binaryData ; </a> 0
<a> public ByteBuf getBinaryData ( ) { </a> 0
<a> return binaryData ; </a> 0
<a> } </a> 0
<a> public void setBinaryData ( ByteBuf binaryData ) { </a> 0
<a> this . binaryData = binaryData ; </a> 0
<a> } </a> 0
<a> public boolean isFinalFragment ( ) { </a> 0
<a> return finalFragment ; </a> 0
<a> } </a> 0
<a> public void setFinalFragment ( boolean finalFragment ) { </a> 0
<a> this . finalFragment = finalFragment ; </a> 0
<a> } </a> 0
<a> public int getRsv ( ) { </a> 0
<a> return rsv ; </a> 0
<a> } </a> 0
<a> public void setRsv ( int rsv ) { </a> 0
<a> this . rsv = rsv ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . rtsp ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseStatus ; </a> 0
<a> public final class RtspResponseStatuses { </a> 0
<a> public static final HttpResponseStatus CONTINUE = HttpResponseStatus . CONTINUE ; </a> 0
<a> public static final HttpResponseStatus OK = HttpResponseStatus . OK ; </a> 0
<a> public static final HttpResponseStatus CREATED = HttpResponseStatus . CREATED ; </a> 0
<a> public static final HttpResponseStatus LOW_STORAGE_SPACE = new HttpResponseStatus ( </a> 0
<a> 250 , "Low on Storage Space" ) ; </a> 0
<a> public static final HttpResponseStatus MULTIPLE_CHOICES = HttpResponseStatus . MULTIPLE_CHOICES ; </a> 0
<a> public static final HttpResponseStatus MOVED_PERMANENTLY = HttpResponseStatus . MOVED_PERMANENTLY ; </a> 0
<a> public static final HttpResponseStatus MOVED_TEMPORARILY = new HttpResponseStatus ( </a> 0
<a> 302 , "Moved Temporarily" ) ; </a> 0
<a> public static final HttpResponseStatus NOT_MODIFIED = HttpResponseStatus . NOT_MODIFIED ; </a> 0
<a> public static final HttpResponseStatus USE_PROXY = HttpResponseStatus . USE_PROXY ; </a> 0
<a> public static final HttpResponseStatus BAD_REQUEST = HttpResponseStatus . BAD_REQUEST ; </a> 0
<a> public static final HttpResponseStatus UNAUTHORIZED = HttpResponseStatus . UNAUTHORIZED ; </a> 0
<a> public static final HttpResponseStatus PAYMENT_REQUIRED = HttpResponseStatus . PAYMENT_REQUIRED ; </a> 0
<a> public static final HttpResponseStatus FORBIDDEN = HttpResponseStatus . FORBIDDEN ; </a> 0
<a> public static final HttpResponseStatus NOT_FOUND = HttpResponseStatus . NOT_FOUND ; </a> 0
<a> public static final HttpResponseStatus METHOD_NOT_ALLOWED = HttpResponseStatus . METHOD_NOT_ALLOWED ; </a> 0
<a> public static final HttpResponseStatus NOT_ACCEPTABLE = HttpResponseStatus . NOT_ACCEPTABLE ; </a> 0
<a> public static final HttpResponseStatus PROXY_AUTHENTICATION_REQUIRED = </a> 0
<a> HttpResponseStatus . PROXY_AUTHENTICATION_REQUIRED ; </a> 0
<a> public static final HttpResponseStatus REQUEST_TIMEOUT = HttpResponseStatus . REQUEST_TIMEOUT ; </a> 0
<a> public static final HttpResponseStatus GONE = HttpResponseStatus . GONE ; </a> 0
<a> public static final HttpResponseStatus LENGTH_REQUIRED = HttpResponseStatus . LENGTH_REQUIRED ; </a> 0
<a> public static final HttpResponseStatus PRECONDITION_FAILED = HttpResponseStatus . PRECONDITION_FAILED ; </a> 0
<a> public static final HttpResponseStatus REQUEST_ENTITY_TOO_LARGE = HttpResponseStatus . REQUEST_ENTITY_TOO_LARGE ; </a> 0
<a> public static final HttpResponseStatus REQUEST_URI_TOO_LONG = HttpResponseStatus . REQUEST_URI_TOO_LONG ; </a> 0
<a> public static final HttpResponseStatus UNSUPPORTED_MEDIA_TYPE = HttpResponseStatus . UNSUPPORTED_MEDIA_TYPE ; </a> 0
<a> public static final HttpResponseStatus PARAMETER_NOT_UNDERSTOOD = new HttpResponseStatus ( </a> 0
<a> 451 , "Parameter Not Understood" ) ; </a> 0
<a> public static final HttpResponseStatus CONFERENCE_NOT_FOUND = new HttpResponseStatus ( </a> 0
<a> 452 , "Conference Not Found" ) ; </a> 0
<a> public static final HttpResponseStatus NOT_ENOUGH_BANDWIDTH = new HttpResponseStatus ( </a> 0
<a> 453 , "Not Enough Bandwidth" ) ; </a> 0
<a> public static final HttpResponseStatus SESSION_NOT_FOUND = new HttpResponseStatus ( </a> 0
<a> 454 , "Session Not Found" ) ; </a> 0
<a> public static final HttpResponseStatus METHOD_NOT_VALID = new HttpResponseStatus ( </a> 0
<a> 455 , "Method Not Valid in This State" ) ; </a> 0
<a> public static final HttpResponseStatus HEADER_FIELD_NOT_VALID = new HttpResponseStatus ( </a> 0
<a> 456 , "Header Field Not Valid for Resource" ) ; </a> 0
<a> public static final HttpResponseStatus INVALID_RANGE = new HttpResponseStatus ( </a> 0
<a> 457 , "Invalid Range" ) ; </a> 0
<a> public static final HttpResponseStatus PARAMETER_IS_READONLY = new HttpResponseStatus ( </a> 0
<a> 458 , "Parameter Is Read-Only" ) ; </a> 0
<a> public static final HttpResponseStatus AGGREGATE_OPERATION_NOT_ALLOWED = new HttpResponseStatus ( </a> 0
<a> 459 , "Aggregate operation not allowed" ) ; </a> 0
<a> public static final HttpResponseStatus ONLY_AGGREGATE_OPERATION_ALLOWED = new HttpResponseStatus ( </a> 0
<a> 460 , "Only Aggregate operation allowed" ) ; </a> 0
<a> public static final HttpResponseStatus UNSUPPORTED_TRANSPORT = new HttpResponseStatus ( </a> 0
<a> 461 , "Unsupported transport" ) ; </a> 0
<a> public static final HttpResponseStatus DESTINATION_UNREACHABLE = new HttpResponseStatus ( </a> 0
<a> 462 , "Destination unreachable" ) ; </a> 0
<a> public static final HttpResponseStatus KEY_MANAGEMENT_FAILURE = new HttpResponseStatus ( </a> 0
<a> 463 , "Key management failure" ) ; </a> 0
<a> public static final HttpResponseStatus INTERNAL_SERVER_ERROR = HttpResponseStatus . INTERNAL_SERVER_ERROR ; </a> 0
<a> public static final HttpResponseStatus NOT_IMPLEMENTED = HttpResponseStatus . NOT_IMPLEMENTED ; </a> 0
<a> public static final HttpResponseStatus BAD_GATEWAY = HttpResponseStatus . BAD_GATEWAY ; </a> 0
<a> public static final HttpResponseStatus SERVICE_UNAVAILABLE = HttpResponseStatus . SERVICE_UNAVAILABLE ; </a> 0
<a> public static final HttpResponseStatus GATEWAY_TIMEOUT = HttpResponseStatus . GATEWAY_TIMEOUT ; </a> 0
<a> public static final HttpResponseStatus RTSP_VERSION_NOT_SUPPORTED = new HttpResponseStatus ( </a> 0
<a> 505 , "RTSP Version not supported" ) ; </a> 0
<a> public static final HttpResponseStatus OPTION_NOT_SUPPORTED = new HttpResponseStatus ( </a> 0
<a> 551 , "Option not supported" ) ; </a> 0
<a> public static HttpResponseStatus valueOf ( int code ) { </a> 0
<a> switch ( code ) { </a> 0
<a> case 250 : return LOW_STORAGE_SPACE ; </a> 0
<a> case 302 : return MOVED_TEMPORARILY ; </a> 0
<a> case 451 : return PARAMETER_NOT_UNDERSTOOD ; </a> 0
<a> case 452 : return CONFERENCE_NOT_FOUND ; </a> 0
<a> case 453 : return NOT_ENOUGH_BANDWIDTH ; </a> 0
<a> case 454 : return SESSION_NOT_FOUND ; </a> 0
<a> case 455 : return METHOD_NOT_VALID ; </a> 0
<a> case 456 : return HEADER_FIELD_NOT_VALID ; </a> 0
<a> case 457 : return INVALID_RANGE ; </a> 0
<a> case 458 : return PARAMETER_IS_READONLY ; </a> 0
<a> case 459 : return AGGREGATE_OPERATION_NOT_ALLOWED ; </a> 0
<a> case 460 : return ONLY_AGGREGATE_OPERATION_ALLOWED ; </a> 0
<a> case 461 : return UNSUPPORTED_TRANSPORT ; </a> 0
<a> case 462 : return DESTINATION_UNREACHABLE ; </a> 0
<a> case 463 : return KEY_MANAGEMENT_FAILURE ; </a> 0
<a> case 505 : return RTSP_VERSION_NOT_SUPPORTED ; </a> 0
<a> case 551 : return OPTION_NOT_SUPPORTED ; </a> 0
<a> default : return HttpResponseStatus . valueOf ( code ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private RtspResponseStatuses ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . util . internal . StringUtil ; </a> 0
<a> public class DefaultSpdyDataFrame implements SpdyDataFrame { </a> 0
<a> private int streamId ; </a> 0
<a> private boolean last ; </a> 0
<a> private ByteBuf data = Unpooled . EMPTY_BUFFER ; </a> 0
<a> public DefaultSpdyDataFrame ( int streamId ) { </a> 0
<a> setStreamId ( streamId ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getStreamId ( ) { </a> 0
<a> return streamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setStreamId ( int streamId ) { </a> 0
<a> if ( streamId <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Stream-ID must be positive: " + streamId ) ; </a> 0
<a> } </a> 0
<a> this . streamId = streamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isLast ( ) { </a> 0
<a> return last ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setLast ( boolean last ) { </a> 0
<a> this . last = last ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf getData ( ) { </a> 0
<a> return data ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setData ( ByteBuf data ) { </a> 0
<a> if ( data == null ) { </a> 0
<a> data = Unpooled . EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> if ( data . readableBytes ( ) > SpdyCodecUtil . SPDY_MAX_LENGTH ) { </a> 0
<a> throw new IllegalArgumentException ( "data payload cannot exceed " </a> 0
<a> + SpdyCodecUtil . SPDY_MAX_LENGTH + " bytes" ) ; </a> 0
<a> } </a> 0
<a> this . data = data ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> buf . append ( "(last: " ) ; </a> 1
<a> buf . append ( isLast ( ) ) ; </a> 1
<a> buf . append ( ')' ) ; </a> 1
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Stream-ID = " ) ; </a> 1
<a> buf . append ( streamId ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Size = " ) ; </a> 1
<a> buf . append ( data . readableBytes ( ) ) ; </a> 0
<a> return buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . util . internal . StringUtil ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Set ; </a> 0
<a> public class DefaultSpdyHeaderBlock implements SpdyHeaderBlock { </a> 0
<a> private boolean invalid ; </a> 0
<a> private final SpdyHeaders headers = new SpdyHeaders ( ) ; </a> 0
<a> protected DefaultSpdyHeaderBlock ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isInvalid ( ) { </a> 0
<a> return invalid ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setInvalid ( ) { </a> 0
<a> invalid = true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void addHeader ( final String name , final Object value ) { </a> 0
<a> headers . addHeader ( name , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setHeader ( final String name , final Object value ) { </a> 0
<a> headers . setHeader ( name , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setHeader ( final String name , final Iterable < ? > values ) { </a> 0
<a> headers . setHeader ( name , values ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void removeHeader ( final String name ) { </a> 0
<a> headers . removeHeader ( name ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clearHeaders ( ) { </a> 0
<a> headers . clearHeaders ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String getHeader ( final String name ) { </a> 0
<a> return headers . getHeader ( name ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public List < String > getHeaders ( final String name ) { </a> 0
<a> return headers . getHeaders ( name ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public List < Map . Entry < String , String > > getHeaders ( ) { </a> 0
<a> return headers . getHeaders ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean containsHeader ( final String name ) { </a> 0
<a> return headers . containsHeader ( name ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Set < String > getHeaderNames ( ) { </a> 0
<a> return headers . getHeaderNames ( ) ; </a> 0
<a> } </a> 0
<a> protected void appendHeaders ( StringBuilder buf ) { </a> 0
<a> for ( Map . Entry < String , String > e : getHeaders ( ) ) { </a> 0
<a> buf . append ( " " ) ; </a> 0
<a> buf . append ( e . getKey ( ) ) ; </a> 0
<a> buf . append ( ": " ) ; </a> 0
<a> buf . append ( e . getValue ( ) ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . util . internal . StringUtil ; </a> 0
<a> public class DefaultSpdyWindowUpdateFrame implements SpdyWindowUpdateFrame { </a> 0
<a> private int streamId ; </a> 0
<a> private int deltaWindowSize ; </a> 0
<a> public DefaultSpdyWindowUpdateFrame ( int streamId , int deltaWindowSize ) { </a> 0
<a> setStreamId ( streamId ) ; </a> 0
<a> setDeltaWindowSize ( deltaWindowSize ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getStreamId ( ) { </a> 0
<a> return streamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setStreamId ( int streamId ) { </a> 0
<a> if ( streamId <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Stream-ID must be positive: " + streamId ) ; </a> 0
<a> } </a> 0
<a> this . streamId = streamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getDeltaWindowSize ( ) { </a> 0
<a> return deltaWindowSize ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setDeltaWindowSize ( int deltaWindowSize ) { </a> 0
<a> if ( deltaWindowSize <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Delta-Window-Size must be positive: " + </a> 0
<a> deltaWindowSize ) ; </a> 0
<a> } </a> 0
<a> this . deltaWindowSize = deltaWindowSize ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Stream-ID = " ) ; </a> 1
<a> buf . append ( streamId ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Delta-Window-Size = " ) ; </a> 1
<a> buf . append ( deltaWindowSize ) ; </a> 0
<a> return buf . toString ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 1
<a> final class SpdyCodecUtil { </a> 0
<a> static final int SPDY_HEADER_TYPE_OFFSET = 2 ; </a> 0
<a> static final int SPDY_HEADER_FLAGS_OFFSET = 4 ; </a> 0
<a> static final int SPDY_HEADER_LENGTH_OFFSET = 5 ; </a> 0
<a> static final int SPDY_HEADER_SIZE = 8 ; </a> 0
<a> static final int SPDY_MAX_LENGTH = 0xFFFFFF ; </a> 0
<a> static final byte SPDY_DATA_FLAG_FIN = 0x01 ; </a> 0
<a> static final int SPDY_SYN_STREAM_FRAME = 1 ; </a> 0
<a> static final int SPDY_SYN_REPLY_FRAME = 2 ; </a> 0
<a> static final int SPDY_RST_STREAM_FRAME = 3 ; </a> 0
<a> static final int SPDY_SETTINGS_FRAME = 4 ; </a> 0
<a> static final int SPDY_NOOP_FRAME = 5 ; </a> 0
<a> static final int SPDY_PING_FRAME = 6 ; </a> 0
<a> static final int SPDY_GOAWAY_FRAME = 7 ; </a> 0
<a> static final int SPDY_HEADERS_FRAME = 8 ; </a> 0
<a> static final int SPDY_WINDOW_UPDATE_FRAME = 9 ; </a> 0
<a> static final int SPDY_CREDENTIAL_FRAME = 10 ; </a> 0
<a> static final byte SPDY_FLAG_FIN = 0x01 ; </a> 0
<a> static final byte SPDY_FLAG_UNIDIRECTIONAL = 0x02 ; </a> 0
<a> static final byte SPDY_SETTINGS_CLEAR = 0x01 ; </a> 0
<a> static final byte SPDY_SETTINGS_PERSIST_VALUE = 0x01 ; </a> 0
<a> static final byte SPDY_SETTINGS_PERSISTED = 0x02 ; </a> 0
<a> static final int SPDY_SETTINGS_MAX_ID = 0xFFFFFF ; </a> 0
<a> static final int SPDY_MAX_NV_LENGTH = 0xFFFF ; </a> 0
<a> static final byte [ ] SPDY_DICT = { </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x07 , 0x6f , 0x70 , 0x74 , 0x69 , </a> 0
<a> 0x6f , 0x6e , 0x73 , 0x00 , 0x00 , 0x00 , 0x04 , 0x68 , </a> 0
<a> 0x65 , 0x61 , 0x64 , 0x00 , 0x00 , 0x00 , 0x04 , 0x70 , </a> 0
<a> 0x6f , 0x73 , 0x74 , 0x00 , 0x00 , 0x00 , 0x03 , 0x70 , </a> 0
<a> 0x75 , 0x74 , 0x00 , 0x00 , 0x00 , 0x06 , 0x64 , 0x65 , </a> 0
<a> 0x6c , 0x65 , 0x74 , 0x65 , 0x00 , 0x00 , 0x00 , 0x05 , </a> 0
<a> 0x74 , 0x72 , 0x61 , 0x63 , 0x65 , 0x00 , 0x00 , 0x00 , </a> 0
<a> 0x06 , 0x61 , 0x63 , 0x63 , 0x65 , 0x70 , 0x74 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x0e , 0x61 , 0x63 , 0x63 , 0x65 , 0x70 , </a> 0
<a> 0x74 , 0x2d , 0x63 , 0x68 , 0x61 , 0x72 , 0x73 , 0x65 , </a> 0
<a> 0x74 , 0x00 , 0x00 , 0x00 , 0x0f , 0x61 , 0x63 , 0x63 , </a> 0
<a> 0x65 , 0x70 , 0x74 , 0x2d , 0x65 , 0x6e , 0x63 , 0x6f , </a> 0
<a> 0x64 , 0x69 , 0x6e , 0x67 , 0x00 , 0x00 , 0x00 , 0x0f , </a> 0
<a> 0x61 , 0x63 , 0x63 , 0x65 , 0x70 , 0x74 , 0x2d , 0x6c , </a> 0
<a> 0x61 , 0x6e , 0x67 , 0x75 , 0x61 , 0x67 , 0x65 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x0d , 0x61 , 0x63 , 0x63 , 0x65 , 0x70 , </a> 0
<a> 0x74 , 0x2d , 0x72 , 0x61 , 0x6e , 0x67 , 0x65 , 0x73 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x03 , 0x61 , 0x67 , 0x65 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x05 , 0x61 , 0x6c , 0x6c , 0x6f , 0x77 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x0d , 0x61 , 0x75 , 0x74 , 0x68 , </a> 0
<a> 0x6f , 0x72 , 0x69 , 0x7a , 0x61 , 0x74 , 0x69 , 0x6f , </a> 0
<a> 0x6e , 0x00 , 0x00 , 0x00 , 0x0d , 0x63 , 0x61 , 0x63 , </a> 0
<a> 0x68 , 0x65 , 0x2d , 0x63 , 0x6f , 0x6e , 0x74 , 0x72 , </a> 0
<a> 0x6f , 0x6c , 0x00 , 0x00 , 0x00 , 0x0a , 0x63 , 0x6f , </a> 0
<a> 0x6e , 0x6e , 0x65 , 0x63 , 0x74 , 0x69 , 0x6f , 0x6e , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x0c , 0x63 , 0x6f , 0x6e , 0x74 , </a> 0
<a> 0x65 , 0x6e , 0x74 , 0x2d , 0x62 , 0x61 , 0x73 , 0x65 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x10 , 0x63 , 0x6f , 0x6e , 0x74 , </a> 0
<a> 0x65 , 0x6e , 0x74 , 0x2d , 0x65 , 0x6e , 0x63 , 0x6f , </a> 0
<a> 0x64 , 0x69 , 0x6e , 0x67 , 0x00 , 0x00 , 0x00 , 0x10 , </a> 0
<a> 0x63 , 0x6f , 0x6e , 0x74 , 0x65 , 0x6e , 0x74 , 0x2d , </a> 0
<a> 0x6c , 0x61 , 0x6e , 0x67 , 0x75 , 0x61 , 0x67 , 0x65 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x0e , 0x63 , 0x6f , 0x6e , 0x74 , </a> 0
<a> 0x65 , 0x6e , 0x74 , 0x2d , 0x6c , 0x65 , 0x6e , 0x67 , </a> 0
<a> 0x74 , 0x68 , 0x00 , 0x00 , 0x00 , 0x10 , 0x63 , 0x6f , </a> 0
<a> 0x6e , 0x74 , 0x65 , 0x6e , 0x74 , 0x2d , 0x6c , 0x6f , </a> 0
<a> 0x63 , 0x61 , 0x74 , 0x69 , 0x6f , 0x6e , 0x00 , 0x00 , </a> 0
<a> 0x00 , 0x0b , 0x63 , 0x6f , 0x6e , 0x74 , 0x65 , 0x6e , </a> 0
<a> 0x74 , 0x2d , 0x6d , 0x64 , 0x35 , 0x00 , 0x00 , 0x00 , </a> 0
<a> 0x0d , 0x63 , 0x6f , 0x6e , 0x74 , 0x65 , 0x6e , 0x74 , </a> 0
<a> 0x2d , 0x72 , 0x61 , 0x6e , 0x67 , 0x65 , 0x00 , 0x00 , </a> 0
<a> 0x00 , 0x0c , 0x63 , 0x6f , 0x6e , 0x74 , 0x65 , 0x6e , </a> 0
<a> 0x74 , 0x2d , 0x74 , 0x79 , 0x70 , 0x65 , 0x00 , 0x00 , </a> 0
<a> 0x00 , 0x04 , 0x64 , 0x61 , 0x74 , 0x65 , 0x00 , 0x00 , </a> 0
<a> 0x00 , 0x04 , 0x65 , 0x74 , 0x61 , 0x67 , 0x00 , 0x00 , </a> 0
<a> 0x00 , 0x06 , 0x65 , 0x78 , 0x70 , 0x65 , 0x63 , 0x74 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x07 , 0x65 , 0x78 , 0x70 , 0x69 , </a> 0
<a> 0x72 , 0x65 , 0x73 , 0x00 , 0x00 , 0x00 , 0x04 , 0x66 , </a> 0
<a> 0x72 , 0x6f , 0x6d , 0x00 , 0x00 , 0x00 , 0x04 , 0x68 , </a> 0
<a> 0x6f , 0x73 , 0x74 , 0x00 , 0x00 , 0x00 , 0x08 , 0x69 , </a> 0
<a> 0x66 , 0x2d , 0x6d , 0x61 , 0x74 , 0x63 , 0x68 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x11 , 0x69 , 0x66 , 0x2d , 0x6d , 0x6f , </a> 0
<a> 0x64 , 0x69 , 0x66 , 0x69 , 0x65 , 0x64 , 0x2d , 0x73 , </a> 0
<a> 0x69 , 0x6e , 0x63 , 0x65 , 0x00 , 0x00 , 0x00 , 0x0d , </a> 0
<a> 0x69 , 0x66 , 0x2d , 0x6e , 0x6f , 0x6e , 0x65 , 0x2d , </a> 0
<a> 0x6d , 0x61 , 0x74 , 0x63 , 0x68 , 0x00 , 0x00 , 0x00 , </a> 0
<a> 0x08 , 0x69 , 0x66 , 0x2d , 0x72 , 0x61 , 0x6e , 0x67 , </a> 0
<a> 0x65 , 0x00 , 0x00 , 0x00 , 0x13 , 0x69 , 0x66 , 0x2d , </a> 0
<a> 0x75 , 0x6e , 0x6d , 0x6f , 0x64 , 0x69 , 0x66 , 0x69 , </a> 0
<a> 0x65 , 0x64 , 0x2d , 0x73 , 0x69 , 0x6e , 0x63 , 0x65 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x0d , 0x6c , 0x61 , 0x73 , 0x74 , </a> 0
<a> 0x2d , 0x6d , 0x6f , 0x64 , 0x69 , 0x66 , 0x69 , 0x65 , </a> 0
<a> 0x64 , 0x00 , 0x00 , 0x00 , 0x08 , 0x6c , 0x6f , 0x63 , </a> 0
<a> 0x61 , 0x74 , 0x69 , 0x6f , 0x6e , 0x00 , 0x00 , 0x00 , </a> 0
<a> 0x0c , 0x6d , 0x61 , 0x78 , 0x2d , 0x66 , 0x6f , 0x72 , </a> 0
<a> 0x77 , 0x61 , 0x72 , 0x64 , 0x73 , 0x00 , 0x00 , 0x00 , </a> 0
<a> 0x06 , 0x70 , 0x72 , 0x61 , 0x67 , 0x6d , 0x61 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x12 , 0x70 , 0x72 , 0x6f , 0x78 , 0x79 , </a> 0
<a> 0x2d , 0x61 , 0x75 , 0x74 , 0x68 , 0x65 , 0x6e , 0x74 , </a> 0
<a> 0x69 , 0x63 , 0x61 , 0x74 , 0x65 , 0x00 , 0x00 , 0x00 , </a> 0
<a> 0x13 , 0x70 , 0x72 , 0x6f , 0x78 , 0x79 , 0x2d , 0x61 , </a> 0
<a> 0x75 , 0x74 , 0x68 , 0x6f , 0x72 , 0x69 , 0x7a , 0x61 , </a> 0
<a> 0x74 , 0x69 , 0x6f , 0x6e , 0x00 , 0x00 , 0x00 , 0x05 , </a> 0
<a> 0x72 , 0x61 , 0x6e , 0x67 , 0x65 , 0x00 , 0x00 , 0x00 , </a> 0
<a> 0x07 , 0x72 , 0x65 , 0x66 , 0x65 , 0x72 , 0x65 , 0x72 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x0b , 0x72 , 0x65 , 0x74 , 0x72 , </a> 0
<a> 0x79 , 0x2d , 0x61 , 0x66 , 0x74 , 0x65 , 0x72 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x06 , 0x73 , 0x65 , 0x72 , 0x76 , 0x65 , </a> 0
<a> 0x72 , 0x00 , 0x00 , 0x00 , 0x02 , 0x74 , 0x65 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x07 , 0x74 , 0x72 , 0x61 , 0x69 , 0x6c , </a> 0
<a> 0x65 , 0x72 , 0x00 , 0x00 , 0x00 , 0x11 , 0x74 , 0x72 , </a> 0
<a> 0x61 , 0x6e , 0x73 , 0x66 , 0x65 , 0x72 , 0x2d , 0x65 , </a> 0
<a> 0x6e , 0x63 , 0x6f , 0x64 , 0x69 , 0x6e , 0x67 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x07 , 0x75 , 0x70 , 0x67 , 0x72 , 0x61 , </a> 0
<a> 0x64 , 0x65 , 0x00 , 0x00 , 0x00 , 0x0a , 0x75 , 0x73 , </a> 0
<a> 0x65 , 0x72 , 0x2d , 0x61 , 0x67 , 0x65 , 0x6e , 0x74 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x04 , 0x76 , 0x61 , 0x72 , 0x79 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x03 , 0x76 , 0x69 , 0x61 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x07 , 0x77 , 0x61 , 0x72 , 0x6e , 0x69 , </a> 0
<a> 0x6e , 0x67 , 0x00 , 0x00 , 0x00 , 0x10 , 0x77 , 0x77 , </a> 0
<a> 0x77 , 0x2d , 0x61 , 0x75 , 0x74 , 0x68 , 0x65 , 0x6e , </a> 0
<a> 0x74 , 0x69 , 0x63 , 0x61 , 0x74 , 0x65 , 0x00 , 0x00 , </a> 0
<a> 0x00 , 0x06 , 0x6d , 0x65 , 0x74 , 0x68 , 0x6f , 0x64 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x03 , 0x67 , 0x65 , 0x74 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x06 , 0x73 , 0x74 , 0x61 , 0x74 , 0x75 , </a> 0
<a> 0x73 , 0x00 , 0x00 , 0x00 , 0x06 , 0x32 , 0x30 , 0x30 , </a> 0
<a> 0x20 , 0x4f , 0x4b , 0x00 , 0x00 , 0x00 , 0x07 , 0x76 , </a> 0
<a> 0x65 , 0x72 , 0x73 , 0x69 , 0x6f , 0x6e , 0x00 , 0x00 , </a> 0
<a> 0x00 , 0x08 , 0x48 , 0x54 , 0x54 , 0x50 , 0x2f , 0x31 , </a> 0
<a> 0x2e , 0x31 , 0x00 , 0x00 , 0x00 , 0x03 , 0x75 , 0x72 , </a> 0
<a> 0x6c , 0x00 , 0x00 , 0x00 , 0x06 , 0x70 , 0x75 , 0x62 , </a> 0
<a> 0x6c , 0x69 , 0x63 , 0x00 , 0x00 , 0x00 , 0x0a , 0x73 , </a> 0
<a> 0x65 , 0x74 , 0x2d , 0x63 , 0x6f , 0x6f , 0x6b , 0x69 , </a> 0
<a> 0x65 , 0x00 , 0x00 , 0x00 , 0x0a , 0x6b , 0x65 , 0x65 , </a> 0
<a> 0x70 , 0x2d , 0x61 , 0x6c , 0x69 , 0x76 , 0x65 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x06 , 0x6f , 0x72 , 0x69 , 0x67 , 0x69 , </a> 0
<a> 0x6e , 0x31 , 0x30 , 0x30 , 0x31 , 0x30 , 0x31 , 0x32 , </a> 0
<a> 0x30 , 0x31 , 0x32 , 0x30 , 0x32 , 0x32 , 0x30 , 0x35 , </a> 0
<a> 0x32 , 0x30 , 0x36 , 0x33 , 0x30 , 0x30 , 0x33 , 0x30 , </a> 0
<a> 0x32 , 0x33 , 0x30 , 0x33 , 0x33 , 0x30 , 0x34 , 0x33 , </a> 0
<a> 0x30 , 0x35 , 0x33 , 0x30 , 0x36 , 0x33 , 0x30 , 0x37 , </a> 0
<a> 0x34 , 0x30 , 0x32 , 0x34 , 0x30 , 0x35 , 0x34 , 0x30 , </a> 0
<a> 0x36 , 0x34 , 0x30 , 0x37 , 0x34 , 0x30 , 0x38 , 0x34 , </a> 0
<a> 0x30 , 0x39 , 0x34 , 0x31 , 0x30 , 0x34 , 0x31 , 0x31 , </a> 0
<a> 0x34 , 0x31 , 0x32 , 0x34 , 0x31 , 0x33 , 0x34 , 0x31 , </a> 0
<a> 0x34 , 0x34 , 0x31 , 0x35 , 0x34 , 0x31 , 0x36 , 0x34 , </a> 0
<a> 0x31 , 0x37 , 0x35 , 0x30 , 0x32 , 0x35 , 0x30 , 0x34 , </a> 0
<a> 0x35 , 0x30 , 0x35 , 0x32 , 0x30 , 0x33 , 0x20 , 0x4e , </a> 0
<a> 0x6f , 0x6e , 0x2d , 0x41 , 0x75 , 0x74 , 0x68 , 0x6f , </a> 0
<a> 0x72 , 0x69 , 0x74 , 0x61 , 0x74 , 0x69 , 0x76 , 0x65 , </a> 0
<a> 0x20 , 0x49 , 0x6e , 0x66 , 0x6f , 0x72 , 0x6d , 0x61 , </a> 0
<a> 0x74 , 0x69 , 0x6f , 0x6e , 0x32 , 0x30 , 0x34 , 0x20 , </a> 0
<a> 0x4e , 0x6f , 0x20 , 0x43 , 0x6f , 0x6e , 0x74 , 0x65 , </a> 0
<a> 0x6e , 0x74 , 0x33 , 0x30 , 0x31 , 0x20 , 0x4d , 0x6f , </a> 0
<a> 0x76 , 0x65 , 0x64 , 0x20 , 0x50 , 0x65 , 0x72 , 0x6d , </a> 0
<a> 0x61 , 0x6e , 0x65 , 0x6e , 0x74 , 0x6c , 0x79 , 0x34 , </a> 0
<a> 0x30 , 0x30 , 0x20 , 0x42 , 0x61 , 0x64 , 0x20 , 0x52 , </a> 0
<a> 0x65 , 0x71 , 0x75 , 0x65 , 0x73 , 0x74 , 0x34 , 0x30 , </a> 0
<a> 0x31 , 0x20 , 0x55 , 0x6e , 0x61 , 0x75 , 0x74 , 0x68 , </a> 0
<a> 0x6f , 0x72 , 0x69 , 0x7a , 0x65 , 0x64 , 0x34 , 0x30 , </a> 0
<a> 0x33 , 0x20 , 0x46 , 0x6f , 0x72 , 0x62 , 0x69 , 0x64 , </a> 0
<a> 0x64 , 0x65 , 0x6e , 0x34 , 0x30 , 0x34 , 0x20 , 0x4e , </a> 0
<a> 0x6f , 0x74 , 0x20 , 0x46 , 0x6f , 0x75 , 0x6e , 0x64 , </a> 0
<a> 0x35 , 0x30 , 0x30 , 0x20 , 0x49 , 0x6e , 0x74 , 0x65 , </a> 0
<a> 0x72 , 0x6e , 0x61 , 0x6c , 0x20 , 0x53 , 0x65 , 0x72 , </a> 0
<a> 0x76 , 0x65 , 0x72 , 0x20 , 0x45 , 0x72 , 0x72 , 0x6f , </a> 0
<a> 0x72 , 0x35 , 0x30 , 0x31 , 0x20 , 0x4e , 0x6f , 0x74 , </a> 0
<a> 0x20 , 0x49 , 0x6d , 0x70 , 0x6c , 0x65 , 0x6d , 0x65 , </a> 0
<a> 0x6e , 0x74 , 0x65 , 0x64 , 0x35 , 0x30 , 0x33 , 0x20 , </a> 0
<a> 0x53 , 0x65 , 0x72 , 0x76 , 0x69 , 0x63 , 0x65 , 0x20 , </a> 0
<a> 0x55 , 0x6e , 0x61 , 0x76 , 0x61 , 0x69 , 0x6c , 0x61 , </a> 0
<a> 0x62 , 0x6c , 0x65 , 0x4a , 0x61 , 0x6e , 0x20 , 0x46 , </a> 0
<a> 0x65 , 0x62 , 0x20 , 0x4d , 0x61 , 0x72 , 0x20 , 0x41 , </a> 0
<a> 0x70 , 0x72 , 0x20 , 0x4d , 0x61 , 0x79 , 0x20 , 0x4a , </a> 0
<a> 0x75 , 0x6e , 0x20 , 0x4a , 0x75 , 0x6c , 0x20 , 0x41 , </a> 0
<a> 0x75 , 0x67 , 0x20 , 0x53 , 0x65 , 0x70 , 0x74 , 0x20 , </a> 0
<a> 0x4f , 0x63 , 0x74 , 0x20 , 0x4e , 0x6f , 0x76 , 0x20 , </a> 0
<a> 0x44 , 0x65 , 0x63 , 0x20 , 0x30 , 0x30 , 0x3a , 0x30 , </a> 0
<a> 0x30 , 0x3a , 0x30 , 0x30 , 0x20 , 0x4d , 0x6f , 0x6e , </a> 0
<a> 0x2c , 0x20 , 0x54 , 0x75 , 0x65 , 0x2c , 0x20 , 0x57 , </a> 0
<a> 0x65 , 0x64 , 0x2c , 0x20 , 0x54 , 0x68 , 0x75 , 0x2c , </a> 0
<a> 0x20 , 0x46 , 0x72 , 0x69 , 0x2c , 0x20 , 0x53 , 0x61 , </a> 0
<a> 0x74 , 0x2c , 0x20 , 0x53 , 0x75 , 0x6e , 0x2c , 0x20 , </a> 0
<a> 0x47 , 0x4d , 0x54 , 0x63 , 0x68 , 0x75 , 0x6e , 0x6b , </a> 0
<a> 0x65 , 0x64 , 0x2c , 0x74 , 0x65 , 0x78 , 0x74 , 0x2f , </a> 0
<a> 0x68 , 0x74 , 0x6d , 0x6c , 0x2c , 0x69 , 0x6d , 0x61 , </a> 0
<a> 0x67 , 0x65 , 0x2f , 0x70 , 0x6e , 0x67 , 0x2c , 0x69 , </a> 0
<a> 0x6d , 0x61 , 0x67 , 0x65 , 0x2f , 0x6a , 0x70 , 0x67 , </a> 0
<a> 0x2c , 0x69 , 0x6d , 0x61 , 0x67 , 0x65 , 0x2f , 0x67 , </a> 0
<a> 0x69 , 0x66 , 0x2c , 0x61 , 0x70 , 0x70 , 0x6c , 0x69 , </a> 0
<a> 0x63 , 0x61 , 0x74 , 0x69 , 0x6f , 0x6e , 0x2f , 0x78 , </a> 0
<a> 0x6d , 0x6c , 0x2c , 0x61 , 0x70 , 0x70 , 0x6c , 0x69 , </a> 0
<a> 0x63 , 0x61 , 0x74 , 0x69 , 0x6f , 0x6e , 0x2f , 0x78 , </a> 0
<a> 0x68 , 0x74 , 0x6d , 0x6c , 0x2b , 0x78 , 0x6d , 0x6c , </a> 0
<a> 0x2c , 0x74 , 0x65 , 0x78 , 0x74 , 0x2f , 0x70 , 0x6c , </a> 0
<a> 0x61 , 0x69 , 0x6e , 0x2c , 0x74 , 0x65 , 0x78 , 0x74 , </a> 0
<a> 0x2f , 0x6a , 0x61 , 0x76 , 0x61 , 0x73 , 0x63 , 0x72 , </a> 0
<a> 0x69 , 0x70 , 0x74 , 0x2c , 0x70 , 0x75 , 0x62 , 0x6c , </a> 0
<a> 0x69 , 0x63 , 0x70 , 0x72 , 0x69 , 0x76 , 0x61 , 0x74 , </a> 0
<a> 0x65 , 0x6d , 0x61 , 0x78 , 0x2d , 0x61 , 0x67 , 0x65 , </a> 0
<a> 0x3d , 0x67 , 0x7a , 0x69 , 0x70 , 0x2c , 0x64 , 0x65 , </a> 0
<a> 0x66 , 0x6c , 0x61 , 0x74 , 0x65 , 0x2c , 0x73 , 0x64 , </a> 0
<a> 0x63 , 0x68 , 0x63 , 0x68 , 0x61 , 0x72 , 0x73 , 0x65 , </a> 0
<a> 0x74 , 0x3d , 0x75 , 0x74 , 0x66 , 0x2d , 0x38 , 0x63 , </a> 0
<a> 0x68 , 0x61 , 0x72 , 0x73 , 0x65 , 0x74 , 0x3d , 0x69 , </a> 0
<a> 0x73 , 0x6f , 0x2d , 0x38 , 0x38 , 0x35 , 0x39 , 0x2d , </a> 0
<a> 0x31 , 0x2c , 0x75 , 0x74 , 0x66 , 0x2d , 0x2c , 0x2a , </a> 0
<a> 0x2c , 0x65 , 0x6e , 0x71 , 0x3d , 0x30 , 0x2e </a> 0
<a> } ; </a> 0
<a> private static final String SPDY2_DICT_S = </a> 0
<a> "optionsgetheadpostputdeletetraceacceptaccept-charsetaccept-encodingaccept-" + </a> 0
<a> "languageauthorizationexpectfromhostif-modified-sinceif-matchif-none-matchi" + </a> 0
<a> "f-rangeif-unmodifiedsincemax-forwardsproxy-authorizationrangerefererteuser" + </a> 0
<a> "-agent10010120020120220320420520630030130230330430530630740040140240340440" + </a> 0
<a> "5406407408409410411412413414415416417500501502503504505accept-rangesageeta" + </a> 0
<a> "glocationproxy-authenticatepublicretry-afterservervarywarningwww-authentic" + </a> 0
<a> "ateallowcontent-basecontent-encodingcache-controlconnectiondatetrailertran" + </a> 0
<a> "sfer-encodingupgradeviawarningcontent-languagecontent-lengthcontent-locati" + </a> 0
<a> "oncontent-md5content-rangecontent-typeetagexpireslast-modifiedset-cookieMo" + </a> 0
<a> "ndayTuesdayWednesdayThursdayFridaySaturdaySundayJanFebMarAprMayJunJulAugSe" + </a> 0
<a> "pOctNovDecchunkedtext/htmlimage/pngimage/jpgimage/gifapplication/xmlapplic" + </a> 0
<a> "ation/xhtmltext/plainpublicmax-agecharset=iso-8859-1utf-8gzipdeflateHTTP/1" + </a> 0
<a> ".1statusversionurl " ; </a> 0
<a> static final byte [ ] SPDY2_DICT ; </a> 0
<a> static { </a> 0
<a> byte [ ] SPDY2_DICT_ ; </a> 0
<a> try { </a> 0
<a> SPDY2_DICT_ = SPDY2_DICT_S . getBytes ( CharsetUtil . US_ASCII ) ; </a> 0
<a> SPDY2_DICT_ [ SPDY2_DICT_ . length - 1 ] = ( byte ) 0 ; </a> 1
<a> } catch ( Exception e ) { </a> 0
<a> SPDY2_DICT_ = new byte [ 1 ] ; </a> 0
<a> } </a> 0
<a> SPDY2_DICT = SPDY2_DICT_ ; </a> 0
<a> } </a> 0
<a> private SpdyCodecUtil ( ) { </a> 0
<a> } </a> 0
<a> static int getUnsignedShort ( ByteBuf buf , int offset ) { </a> 0
<a> return ( buf . getByte ( offset ) & 0xFF ) < < 8 | </a> 0
<a> buf . getByte ( offset + 1 ) & 0xFF ; </a> 0
<a> } </a> 0
<a> static int getUnsignedMedium ( ByteBuf buf , int offset ) { </a> 0
<a> return ( buf . getByte ( offset ) & 0xFF ) < < 16 | </a> 0
<a> ( buf . getByte ( offset + 1 ) & 0xFF ) < < 8 | </a> 0
<a> buf . getByte ( offset + 2 ) & 0xFF ; </a> 0
<a> } </a> 0
<a> static int getUnsignedInt ( ByteBuf buf , int offset ) { </a> 0
<a> return ( buf . getByte ( offset ) & 0x7F ) < < 24 | </a> 0
<a> ( buf . getByte ( offset + 1 ) & 0xFF ) < < 16 | </a> 0
<a> ( buf . getByte ( offset + 2 ) & 0xFF ) < < 8 | </a> 0
<a> buf . getByte ( offset + 3 ) & 0xFF ; </a> 0
<a> } </a> 0
<a> static int getSignedInt ( ByteBuf buf , int offset ) { </a> 0
<a> return ( buf . getByte ( offset ) & 0xFF ) < < 24 | </a> 0
<a> ( buf . getByte ( offset + 1 ) & 0xFF ) < < 16 | </a> 0
<a> ( buf . getByte ( offset + 2 ) & 0xFF ) < < 8 | </a> 0
<a> buf . getByte ( offset + 3 ) & 0xFF ; </a> 0
<a> } </a> 0
<a> static boolean isServerId ( int ID ) { </a> 1
<a> return ID % 2 == 0 ; </a> 1
<a> } </a> 0
<a> static void validateHeaderName ( String name ) { </a> 0
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> if ( name . length ( ) == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "name cannot be length zero" ) ; </a> 0
<a> } </a> 0
<a> if ( name . length ( ) > SPDY_MAX_NV_LENGTH ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "name exceeds allowable length: " + name ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < name . length ( ) ; i ++ ) { </a> 0
<a> char c = name . charAt ( i ) ; </a> 0
<a> if ( c == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "name contains null character: " + name ) ; </a> 0
<a> } </a> 0
<a> if ( c > 127 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "name contains non-ascii character: " + name ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static void validateHeaderValue ( String value ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( "value" ) ; </a> 0
<a> } </a> 0
<a> if ( value . length ( ) == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "value cannot be length zero" ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < value . length ( ) ; i ++ ) { </a> 0
<a> char c = value . charAt ( i ) ; </a> 0
<a> if ( c == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "value contains null character: " + value ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public interface SpdyControlFrame { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import static io . netty . handler . codec . spdy . SpdyCodecUtil . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . MessageToByteEncoder ; </a> 0
<a> import io . netty . handler . codec . UnsupportedMessageTypeException ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . util . Set ; </a> 0
<a> public class SpdyFrameEncoder extends MessageToByteEncoder < Object > { </a> 0
<a> private final int version ; </a> 0
<a> private volatile boolean finished ; </a> 0
<a> private final SpdyHeaderBlockCompressor headerBlockCompressor ; </a> 0
<a> public SpdyFrameEncoder ( int version ) { </a> 0
<a> this ( version , 6 , 15 , 8 ) ; </a> 0
<a> } </a> 0
<a> public SpdyFrameEncoder ( int version , int compressionLevel , int windowBits , int memLevel ) { </a> 0
<a> if ( version < SpdyConstants . SPDY_MIN_VERSION || version > SpdyConstants . SPDY_MAX_VERSION ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "unknown version: " + version ) ; </a> 0
<a> } </a> 0
<a> this . version = version ; </a> 0
<a> headerBlockCompressor = SpdyHeaderBlockCompressor . newInstance ( </a> 0
<a> version , compressionLevel , windowBits , memLevel ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> ctx . channel ( ) . closeFuture ( ) . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 0
<a> synchronized ( headerBlockCompressor ) { </a> 0
<a> if ( finished ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> finished = true ; </a> 0
<a> headerBlockCompressor . end ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof SpdyDataFrame || msg instanceof SpdyControlFrame ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( ChannelHandlerContext ctx , Object msg , ByteBuf out ) throws Exception { </a> 0
<a> if ( msg instanceof SpdyDataFrame ) { </a> 0
<a> SpdyDataFrame spdyDataFrame = ( SpdyDataFrame ) msg ; </a> 0
<a> ByteBuf data = spdyDataFrame . getData ( ) ; </a> 0
<a> byte flags = spdyDataFrame . isLast ( ) ? SPDY_DATA_FLAG_FIN : 0 ; </a> 0
<a> out . ensureWritableBytes ( SPDY_HEADER_SIZE + data . readableBytes ( ) ) ; </a> 0
<a> out . writeInt ( spdyDataFrame . getStreamId ( ) & 0x7FFFFFFF ) ; </a> 0
<a> out . writeByte ( flags ) ; </a> 0
<a> out . writeMedium ( data . readableBytes ( ) ) ; </a> 0
<a> out . writeBytes ( data , data . readerIndex ( ) , data . readableBytes ( ) ) ; </a> 0
<a> } else if ( msg instanceof SpdySynStreamFrame ) { </a> 0
<a> SpdySynStreamFrame spdySynStreamFrame = ( SpdySynStreamFrame ) msg ; </a> 0
<a> ByteBuf data = compressHeaderBlock ( </a> 0
<a> encodeHeaderBlock ( version , spdySynStreamFrame ) ) ; </a> 0
<a> byte flags = spdySynStreamFrame . isLast ( ) ? SPDY_FLAG_FIN : 0 ; </a> 0
<a> if ( spdySynStreamFrame . isUnidirectional ( ) ) { </a> 0
<a> flags |= SPDY_FLAG_UNIDIRECTIONAL ; </a> 0
<a> } </a> 0
<a> int headerBlockLength = data . readableBytes ( ) ; </a> 0
<a> int length ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> length = headerBlockLength == 0 ? 12 : 10 + headerBlockLength ; </a> 0
<a> } else { </a> 0
<a> length = 10 + headerBlockLength ; </a> 0
<a> } </a> 0
<a> out . ensureWritableBytes ( SPDY_HEADER_SIZE + length ) ; </a> 0
<a> out . writeShort ( version | 0x8000 ) ; </a> 0
<a> out . writeShort ( SPDY_SYN_STREAM_FRAME ) ; </a> 0
<a> out . writeByte ( flags ) ; </a> 0
<a> out . writeMedium ( length ) ; </a> 0
<a> out . writeInt ( spdySynStreamFrame . getStreamId ( ) ) ; </a> 0
<a> out . writeInt ( spdySynStreamFrame . getAssociatedToStreamId ( ) ) ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> byte priority = spdySynStreamFrame . getPriority ( ) ; </a> 0
<a> if ( priority > 3 ) { </a> 0
<a> priority = 3 ; </a> 0
<a> } </a> 0
<a> out . writeShort ( ( priority & 0xFF ) < < 14 ) ; </a> 0
<a> } else { </a> 0
<a> out . writeShort ( ( spdySynStreamFrame . getPriority ( ) & 0xFF ) < < 13 ) ; </a> 0
<a> } </a> 0
<a> if ( version < 3 && data . readableBytes ( ) == 0 ) { </a> 0
<a> out . writeShort ( 0 ) ; </a> 0
<a> } </a> 0
<a> out . writeBytes ( data , data . readerIndex ( ) , headerBlockLength ) ; </a> 0
<a> } else if ( msg instanceof SpdySynReplyFrame ) { </a> 0
<a> SpdySynReplyFrame spdySynReplyFrame = ( SpdySynReplyFrame ) msg ; </a> 0
<a> ByteBuf data = compressHeaderBlock ( </a> 0
<a> encodeHeaderBlock ( version , spdySynReplyFrame ) ) ; </a> 0
<a> byte flags = spdySynReplyFrame . isLast ( ) ? SPDY_FLAG_FIN : 0 ; </a> 0
<a> int headerBlockLength = data . readableBytes ( ) ; </a> 0
<a> int length ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> length = headerBlockLength == 0 ? 8 : 6 + headerBlockLength ; </a> 0
<a> } else { </a> 0
<a> length = 4 + headerBlockLength ; </a> 0
<a> } </a> 0
<a> out . ensureWritableBytes ( SPDY_HEADER_SIZE + length ) ; </a> 0
<a> out . writeShort ( version | 0x8000 ) ; </a> 0
<a> out . writeShort ( SPDY_SYN_REPLY_FRAME ) ; </a> 0
<a> out . writeByte ( flags ) ; </a> 0
<a> out . writeMedium ( length ) ; </a> 0
<a> out . writeInt ( spdySynReplyFrame . getStreamId ( ) ) ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> if ( headerBlockLength == 0 ) { </a> 0
<a> out . writeInt ( 0 ) ; </a> 0
<a> } else { </a> 0
<a> out . writeShort ( 0 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> out . writeBytes ( data , data . readerIndex ( ) , headerBlockLength ) ; </a> 0
<a> } else if ( msg instanceof SpdyRstStreamFrame ) { </a> 0
<a> SpdyRstStreamFrame spdyRstStreamFrame = ( SpdyRstStreamFrame ) msg ; </a> 0
<a> out . ensureWritableBytes ( SPDY_HEADER_SIZE + 8 ) ; </a> 0
<a> out . writeShort ( version | 0x8000 ) ; </a> 0
<a> out . writeShort ( SPDY_RST_STREAM_FRAME ) ; </a> 0
<a> out . writeInt ( 8 ) ; </a> 0
<a> out . writeInt ( spdyRstStreamFrame . getStreamId ( ) ) ; </a> 0
<a> out . writeInt ( spdyRstStreamFrame . getStatus ( ) . getCode ( ) ) ; </a> 0
<a> } else if ( msg instanceof SpdySettingsFrame ) { </a> 0
<a> SpdySettingsFrame spdySettingsFrame = ( SpdySettingsFrame ) msg ; </a> 0
<a> byte flags = spdySettingsFrame . clearPreviouslyPersistedSettings ( ) ? </a> 0
<a> SPDY_SETTINGS_CLEAR : 0 ; </a> 0
<a> Set < Integer > IDs = spdySettingsFrame . getIds ( ) ; </a> 0
<a> int numEntries = IDs . size ( ) ; </a> 0
<a> int length = 4 + numEntries * 8 ; </a> 0
<a> out . ensureWritableBytes ( SPDY_HEADER_SIZE + length ) ; </a> 0
<a> out . writeShort ( version | 0x8000 ) ; </a> 0
<a> out . writeShort ( SPDY_SETTINGS_FRAME ) ; </a> 0
<a> out . writeByte ( flags ) ; </a> 0
<a> out . writeMedium ( length ) ; </a> 0
<a> out . writeInt ( numEntries ) ; </a> 0
<a> for ( Integer ID : IDs ) { </a> 0
<a> int id = ID . intValue ( ) ; </a> 0
<a> byte ID_flags = ( byte ) 0 ; </a> 1
<a> if ( spdySettingsFrame . isPersistValue ( id ) ) { </a> 0
<a> ID_flags |= SPDY_SETTINGS_PERSIST_VALUE ; </a> 0
<a> } </a> 0
<a> if ( spdySettingsFrame . isPersisted ( id ) ) { </a> 0
<a> ID_flags |= SPDY_SETTINGS_PERSISTED ; </a> 0
<a> } </a> 0
<a> if ( version < 3 ) { </a> 0
<a> out . writeByte ( id > > 0 & 0xFF ) ; </a> 0
<a> out . writeByte ( id > > 8 & 0xFF ) ; </a> 0
<a> out . writeByte ( id > > 16 & 0xFF ) ; </a> 0
<a> out . writeByte ( ID_flags ) ; </a> 0
<a> } else { </a> 0
<a> out . writeByte ( ID_flags ) ; </a> 0
<a> out . writeMedium ( id ) ; </a> 0
<a> } </a> 0
<a> out . writeInt ( spdySettingsFrame . getValue ( id ) ) ; </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdyNoOpFrame ) { </a> 0
<a> out . ensureWritableBytes ( SPDY_HEADER_SIZE ) ; </a> 0
<a> out . writeShort ( version | 0x8000 ) ; </a> 0
<a> out . writeShort ( SPDY_NOOP_FRAME ) ; </a> 0
<a> out . writeInt ( 0 ) ; </a> 0
<a> } else if ( msg instanceof SpdyPingFrame ) { </a> 0
<a> SpdyPingFrame spdyPingFrame = ( SpdyPingFrame ) msg ; </a> 0
<a> out . ensureWritableBytes ( SPDY_HEADER_SIZE + 4 ) ; </a> 0
<a> out . writeShort ( version | 0x8000 ) ; </a> 0
<a> out . writeShort ( SPDY_PING_FRAME ) ; </a> 0
<a> out . writeInt ( 4 ) ; </a> 0
<a> out . writeInt ( spdyPingFrame . getId ( ) ) ; </a> 0
<a> } else if ( msg instanceof SpdyGoAwayFrame ) { </a> 0
<a> SpdyGoAwayFrame spdyGoAwayFrame = ( SpdyGoAwayFrame ) msg ; </a> 0
<a> int length = version < 3 ? 4 : 8 ; </a> 0
<a> out . ensureWritableBytes ( SPDY_HEADER_SIZE + length ) ; </a> 0
<a> out . writeShort ( version | 0x8000 ) ; </a> 0
<a> out . writeShort ( SPDY_GOAWAY_FRAME ) ; </a> 0
<a> out . writeInt ( length ) ; </a> 0
<a> out . writeInt ( spdyGoAwayFrame . getLastGoodStreamId ( ) ) ; </a> 0
<a> if ( version >= 3 ) { </a> 0
<a> out . writeInt ( spdyGoAwayFrame . getStatus ( ) . getCode ( ) ) ; </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdyHeadersFrame ) { </a> 0
<a> SpdyHeadersFrame spdyHeadersFrame = ( SpdyHeadersFrame ) msg ; </a> 0
<a> ByteBuf data = compressHeaderBlock ( </a> 0
<a> encodeHeaderBlock ( version , spdyHeadersFrame ) ) ; </a> 0
<a> byte flags = spdyHeadersFrame . isLast ( ) ? SPDY_FLAG_FIN : 0 ; </a> 0
<a> int headerBlockLength = data . readableBytes ( ) ; </a> 0
<a> int length ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> length = headerBlockLength == 0 ? 4 : 6 + headerBlockLength ; </a> 0
<a> } else { </a> 0
<a> length = 4 + headerBlockLength ; </a> 0
<a> } </a> 0
<a> out . ensureWritableBytes ( SPDY_HEADER_SIZE + length ) ; </a> 0
<a> out . writeShort ( version | 0x8000 ) ; </a> 0
<a> out . writeShort ( SPDY_HEADERS_FRAME ) ; </a> 0
<a> out . writeByte ( flags ) ; </a> 0
<a> out . writeMedium ( length ) ; </a> 0
<a> out . writeInt ( spdyHeadersFrame . getStreamId ( ) ) ; </a> 0
<a> if ( version < 3 && headerBlockLength != 0 ) { </a> 0
<a> out . writeShort ( 0 ) ; </a> 0
<a> } </a> 0
<a> out . writeBytes ( data , data . readerIndex ( ) , headerBlockLength ) ; </a> 0
<a> } else if ( msg instanceof SpdyWindowUpdateFrame ) { </a> 0
<a> SpdyWindowUpdateFrame spdyWindowUpdateFrame = ( SpdyWindowUpdateFrame ) msg ; </a> 0
<a> out . ensureWritableBytes ( SPDY_HEADER_SIZE + 8 ) ; </a> 0
<a> out . writeShort ( version | 0x8000 ) ; </a> 0
<a> out . writeShort ( SPDY_WINDOW_UPDATE_FRAME ) ; </a> 0
<a> out . writeInt ( 8 ) ; </a> 0
<a> out . writeInt ( spdyWindowUpdateFrame . getStreamId ( ) ) ; </a> 0
<a> out . writeInt ( spdyWindowUpdateFrame . getDeltaWindowSize ( ) ) ; </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedMessageTypeException ( msg ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void writeLengthField ( int version , ByteBuf buffer , int length ) { </a> 0
<a> if ( version < 3 ) { </a> 0
<a> buffer . writeShort ( length ) ; </a> 0
<a> } else { </a> 0
<a> buffer . writeInt ( length ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void setLengthField ( int version , ByteBuf buffer , int writerIndex , int length ) { </a> 0
<a> if ( version < 3 ) { </a> 0
<a> buffer . setShort ( writerIndex , length ) ; </a> 0
<a> } else { </a> 0
<a> buffer . setInt ( writerIndex , length ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static ByteBuf encodeHeaderBlock ( int version , SpdyHeaderBlock headerFrame ) </a> 0
<a> throws Exception { </a> 0
<a> Set < String > names = headerFrame . getHeaderNames ( ) ; </a> 0
<a> int numHeaders = names . size ( ) ; </a> 0
<a> if ( numHeaders == 0 ) { </a> 0
<a> return Unpooled . EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> if ( numHeaders > SPDY_MAX_NV_LENGTH ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "header block contains too many headers" ) ; </a> 0
<a> } </a> 0
<a> ByteBuf headerBlock = Unpooled . buffer ( ) ; </a> 0
<a> writeLengthField ( version , headerBlock , numHeaders ) ; </a> 0
<a> for ( String name : names ) { </a> 0
<a> byte [ ] nameBytes = name . getBytes ( CharsetUtil . UTF_8 ) ; </a> 0
<a> writeLengthField ( version , headerBlock , nameBytes . length ) ; </a> 0
<a> headerBlock . writeBytes ( nameBytes ) ; </a> 0
<a> int savedIndex = headerBlock . writerIndex ( ) ; </a> 0
<a> int valueLength = 0 ; </a> 0
<a> writeLengthField ( version , headerBlock , valueLength ) ; </a> 0
<a> for ( String value : headerFrame . getHeaders ( name ) ) { </a> 0
<a> byte [ ] valueBytes = value . getBytes ( CharsetUtil . UTF_8 ) ; </a> 0
<a> headerBlock . writeBytes ( valueBytes ) ; </a> 0
<a> headerBlock . writeByte ( 0 ) ; </a> 0
<a> valueLength += valueBytes . length + 1 ; </a> 0
<a> } </a> 0
<a> valueLength -- ; </a> 0
<a> if ( valueLength > SPDY_MAX_NV_LENGTH ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "header exceeds allowable length: " + name ) ; </a> 0
<a> } </a> 0
<a> setLengthField ( version , headerBlock , savedIndex , valueLength ) ; </a> 0
<a> headerBlock . writerIndex ( headerBlock . writerIndex ( ) - 1 ) ; </a> 0
<a> } </a> 0
<a> return headerBlock ; </a> 0
<a> } </a> 0
<a> private synchronized ByteBuf compressHeaderBlock ( </a> 0
<a> ByteBuf uncompressed ) throws Exception { </a> 0
<a> if ( uncompressed . readableBytes ( ) == 0 ) { </a> 0
<a> return Unpooled . EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> ByteBuf compressed = Unpooled . buffer ( ) ; </a> 0
<a> synchronized ( headerBlockCompressor ) { </a> 0
<a> if ( ! finished ) { </a> 0
<a> headerBlockCompressor . setInput ( uncompressed ) ; </a> 0
<a> headerBlockCompressor . encode ( compressed ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return compressed ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public interface SpdyGoAwayFrame extends SpdyControlFrame { </a> 0
<a> int getLastGoodStreamId ( ) ; </a> 1
<a> void setLastGoodStreamId ( int lastGoodStreamId ) ; </a> 0
<a> SpdySessionStatus getStatus ( ) ; </a> 1
<a> void setStatus ( SpdySessionStatus status ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import java . util . Comparator ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Queue ; </a> 0
<a> import java . util . Set ; </a> 1
<a> import java . util . TreeSet ; </a> 1
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> final class SpdySession { </a> 0
<a> private final Map < Integer , StreamState > activeStreams = </a> 1
<a> new ConcurrentHashMap < Integer , StreamState > ( ) ; </a> 1
<a> SpdySession ( ) { </a> 0
<a> } </a> 0
<a> int numActiveStreams ( ) { </a> 0
<a> return activeStreams . size ( ) ; </a> 0
<a> } </a> 0
<a> boolean noActiveStreams ( ) { </a> 0
<a> return activeStreams . isEmpty ( ) ; </a> 0
<a> } </a> 0
<a> boolean isActiveStream ( int streamID ) { </a> 0
<a> return activeStreams . containsKey ( new Integer ( streamID ) ) ; </a> 1
<a> } </a> 0
<a> Set < Integer > getActiveStreams ( ) { </a> 1
<a> TreeSet < Integer > StreamIDs = new TreeSet < Integer > ( new PriorityComparator ( ) ) ; </a> 0
<a> StreamIDs . addAll ( activeStreams . keySet ( ) ) ; </a> 0
<a> return StreamIDs ; </a> 0
<a> } </a> 0
<a> void acceptStream ( </a> 0
<a> int streamID , byte priority , boolean remoteSideClosed , boolean localSideClosed , </a> 0
<a> int sendWindowSize , int receiveWindowSize ) { </a> 0
<a> if ( ! remoteSideClosed || ! localSideClosed ) { </a> 0
<a> activeStreams . put ( </a> 0
<a> new Integer ( streamID ) , </a> 1
<a> new StreamState ( priority , remoteSideClosed , localSideClosed , sendWindowSize , receiveWindowSize ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean removeStream ( int streamID ) { </a> 0
<a> Integer StreamID = new Integer ( streamID ) ; </a> 1
<a> StreamState state = activeStreams . get ( StreamID ) ; </a> 0
<a> activeStreams . remove ( StreamID ) ; </a> 0
<a> if ( state != null ) { </a> 0
<a> return state . clearPendingWrites ( ) ; </a> 0
<a> } else { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean isRemoteSideClosed ( int streamID ) { </a> 0
<a> StreamState state = activeStreams . get ( new Integer ( streamID ) ) ; </a> 1
<a> return state == null || state . isRemoteSideClosed ( ) ; </a> 0
<a> } </a> 0
<a> void closeRemoteSide ( int streamID ) { </a> 0
<a> Integer StreamID = new Integer ( streamID ) ; </a> 1
<a> StreamState state = activeStreams . get ( StreamID ) ; </a> 0
<a> if ( state != null ) { </a> 0
<a> state . closeRemoteSide ( ) ; </a> 0
<a> if ( state . isLocalSideClosed ( ) ) { </a> 0
<a> activeStreams . remove ( StreamID ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean isLocalSideClosed ( int streamID ) { </a> 0
<a> StreamState state = activeStreams . get ( new Integer ( streamID ) ) ; </a> 1
<a> return state == null || state . isLocalSideClosed ( ) ; </a> 0
<a> } </a> 0
<a> void closeLocalSide ( int streamID ) { </a> 0
<a> Integer StreamID = new Integer ( streamID ) ; </a> 1
<a> StreamState state = activeStreams . get ( StreamID ) ; </a> 0
<a> if ( state != null ) { </a> 0
<a> state . closeLocalSide ( ) ; </a> 0
<a> if ( state . isRemoteSideClosed ( ) ) { </a> 0
<a> activeStreams . remove ( StreamID ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean hasReceivedReply ( int streamID ) { </a> 0
<a> StreamState state = activeStreams . get ( new Integer ( streamID ) ) ; </a> 1
<a> return state != null && state . hasReceivedReply ( ) ; </a> 0
<a> } </a> 0
<a> void receivedReply ( int streamID ) { </a> 0
<a> StreamState state = activeStreams . get ( new Integer ( streamID ) ) ; </a> 1
<a> if ( state != null ) { </a> 0
<a> state . receivedReply ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int getSendWindowSize ( int streamID ) { </a> 0
<a> StreamState state = activeStreams . get ( new Integer ( streamID ) ) ; </a> 1
<a> return state != null ? state . getSendWindowSize ( ) : - 1 ; </a> 0
<a> } </a> 0
<a> int updateSendWindowSize ( int streamID , int deltaWindowSize ) { </a> 0
<a> StreamState state = activeStreams . get ( new Integer ( streamID ) ) ; </a> 1
<a> return state != null ? state . updateSendWindowSize ( deltaWindowSize ) : - 1 ; </a> 0
<a> } </a> 0
<a> int updateReceiveWindowSize ( int streamID , int deltaWindowSize ) { </a> 0
<a> StreamState state = activeStreams . get ( new Integer ( streamID ) ) ; </a> 1
<a> if ( deltaWindowSize > 0 ) { </a> 0
<a> state . setReceiveWindowSizeLowerBound ( 0 ) ; </a> 0
<a> } </a> 0
<a> return state != null ? state . updateReceiveWindowSize ( deltaWindowSize ) : - 1 ; </a> 1
<a> } </a> 0
<a> int getReceiveWindowSizeLowerBound ( int streamID ) { </a> 0
<a> StreamState state = activeStreams . get ( new Integer ( streamID ) ) ; </a> 1
<a> return state != null ? state . getReceiveWindowSizeLowerBound ( ) : 0 ; </a> 0
<a> } </a> 0
<a> void updateAllReceiveWindowSizes ( int deltaWindowSize ) { </a> 0
<a> for ( StreamState state : activeStreams . values ( ) ) { </a> 0
<a> state . updateReceiveWindowSize ( deltaWindowSize ) ; </a> 0
<a> if ( deltaWindowSize < 0 ) { </a> 0
<a> state . setReceiveWindowSizeLowerBound ( deltaWindowSize ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean putPendingWrite ( int streamID , Object msg ) { </a> 0
<a> StreamState state = activeStreams . get ( Integer . valueOf ( streamID ) ) ; </a> 0
<a> return state != null && state . putPendingWrite ( msg ) ; </a> 0
<a> } </a> 0
<a> Object getPendingWrite ( int streamID ) { </a> 0
<a> StreamState state = activeStreams . get ( Integer . valueOf ( streamID ) ) ; </a> 0
<a> return state != null ? state . getPendingWrite ( ) : null ; </a> 0
<a> } </a> 0
<a> Object removePendingWrite ( int streamID ) { </a> 0
<a> StreamState state = activeStreams . get ( Integer . valueOf ( streamID ) ) ; </a> 0
<a> return state != null ? state . removePendingWrite ( ) : null ; </a> 0
<a> } </a> 0
<a> private static final class StreamState { </a> 0
<a> private final byte priority ; </a> 0
<a> private volatile boolean remoteSideClosed ; </a> 0
<a> private volatile boolean localSideClosed ; </a> 0
<a> private boolean receivedReply ; </a> 0
<a> private final AtomicInteger sendWindowSize ; </a> 0
<a> private final AtomicInteger receiveWindowSize ; </a> 0
<a> private volatile int receiveWindowSizeLowerBound ; </a> 0
<a> private final Queue < Object > pendingWriteQueue = new ConcurrentLinkedQueue < Object > ( ) ; </a> 0
<a> StreamState ( </a> 0
<a> byte priority , boolean remoteSideClosed , boolean localSideClosed , </a> 0
<a> int sendWindowSize , int receiveWindowSize ) { </a> 0
<a> this . priority = priority ; </a> 0
<a> this . remoteSideClosed = remoteSideClosed ; </a> 0
<a> this . localSideClosed = localSideClosed ; </a> 0
<a> this . sendWindowSize = new AtomicInteger ( sendWindowSize ) ; </a> 0
<a> this . receiveWindowSize = new AtomicInteger ( receiveWindowSize ) ; </a> 0
<a> } </a> 0
<a> byte getPriority ( ) { </a> 0
<a> return priority ; </a> 0
<a> } </a> 0
<a> boolean isRemoteSideClosed ( ) { </a> 0
<a> return remoteSideClosed ; </a> 0
<a> } </a> 0
<a> void closeRemoteSide ( ) { </a> 0
<a> remoteSideClosed = true ; </a> 0
<a> } </a> 0
<a> boolean isLocalSideClosed ( ) { </a> 0
<a> return localSideClosed ; </a> 0
<a> } </a> 0
<a> void closeLocalSide ( ) { </a> 0
<a> localSideClosed = true ; </a> 0
<a> } </a> 0
<a> boolean hasReceivedReply ( ) { </a> 0
<a> return receivedReply ; </a> 0
<a> } </a> 0
<a> void receivedReply ( ) { </a> 0
<a> receivedReply = true ; </a> 0
<a> } </a> 0
<a> int getSendWindowSize ( ) { </a> 0
<a> return sendWindowSize . get ( ) ; </a> 0
<a> } </a> 0
<a> int updateSendWindowSize ( int deltaWindowSize ) { </a> 0
<a> return sendWindowSize . addAndGet ( deltaWindowSize ) ; </a> 0
<a> } </a> 0
<a> int updateReceiveWindowSize ( int deltaWindowSize ) { </a> 0
<a> return receiveWindowSize . addAndGet ( deltaWindowSize ) ; </a> 0
<a> } </a> 0
<a> int getReceiveWindowSizeLowerBound ( ) { </a> 0
<a> return receiveWindowSizeLowerBound ; </a> 0
<a> } </a> 0
<a> void setReceiveWindowSizeLowerBound ( int receiveWindowSizeLowerBound ) { </a> 0
<a> this . receiveWindowSizeLowerBound = receiveWindowSizeLowerBound ; </a> 0
<a> } </a> 0
<a> boolean putPendingWrite ( Object msg ) { </a> 0
<a> return pendingWriteQueue . offer ( msg ) ; </a> 0
<a> } </a> 0
<a> Object getPendingWrite ( ) { </a> 0
<a> return pendingWriteQueue . peek ( ) ; </a> 0
<a> } </a> 0
<a> Object removePendingWrite ( ) { </a> 0
<a> return pendingWriteQueue . poll ( ) ; </a> 0
<a> } </a> 0
<a> boolean clearPendingWrites ( ) { </a> 0
<a> if ( pendingWriteQueue . isEmpty ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> pendingWriteQueue . clear ( ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final class PriorityComparator implements Comparator < Integer > { </a> 1
<a> @ Override </a> 0
<a> public int compare ( Integer id1 , Integer id2 ) { </a> 0
<a> StreamState state1 = activeStreams . get ( id1 ) ; </a> 0
<a> StreamState state2 = activeStreams . get ( id2 ) ; </a> 0
<a> return state1 . getPriority ( ) - state2 . getPriority ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import java . util . Set ; </a> 0
<a> public interface SpdySettingsFrame extends SpdyControlFrame { </a> 0
<a> int SETTINGS_UPLOAD_BANDWIDTH = 1 ; </a> 0
<a> int SETTINGS_DOWNLOAD_BANDWIDTH = 2 ; </a> 0
<a> int SETTINGS_ROUND_TRIP_TIME = 3 ; </a> 0
<a> int SETTINGS_MAX_CONCURRENT_STREAMS = 4 ; </a> 0
<a> int SETTINGS_CURRENT_CWND = 5 ; </a> 0
<a> int SETTINGS_DOWNLOAD_RETRANS_RATE = 6 ; </a> 0
<a> int SETTINGS_INITIAL_WINDOW_SIZE = 7 ; </a> 0
<a> int SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE = 8 ; </a> 0
<a> Set < Integer > getIds ( ) ; </a> 1
<a> boolean isSet ( int id ) ; </a> 0
<a> int getValue ( int id ) ; </a> 0
<a> void setValue ( int id , int value ) ; </a> 0
<a> void setValue ( int id , int value , boolean persistVal , boolean persisted ) ; </a> 0
<a> void removeValue ( int id ) ; </a> 0
<a> boolean isPersistValue ( int id ) ; </a> 0
<a> void setPersistValue ( int id , boolean persistValue ) ; </a> 0
<a> boolean isPersisted ( int id ) ; </a> 0
<a> void setPersisted ( int id , boolean persisted ) ; </a> 0
<a> boolean clearPreviouslyPersistedSettings ( ) ; </a> 0
<a> void setClearPreviouslyPersistedSettings ( boolean clear ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public interface SpdySynStreamFrame extends SpdyHeaderBlock , SpdyControlFrame { </a> 0
<a> int getStreamId ( ) ; </a> 0
<a> void setStreamId ( int streamId ) ; </a> 0
<a> int getAssociatedToStreamId ( ) ; </a> 1
<a> void setAssociatedToStreamId ( int associatedToStreamId ) ; </a> 0
<a> byte getPriority ( ) ; </a> 1
<a> void setPriority ( byte priority ) ; </a> 0
<a> boolean isLast ( ) ; </a> 0
<a> void setLast ( boolean last ) ; </a> 0
<a> boolean isUnidirectional ( ) ; </a> 0
<a> void setUnidirectional ( boolean unidirectional ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import java . util . Calendar ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . TimeZone ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class CookieDecoderTest { </a> 0
<a> @ Test </a> 0
<a> public void testDecodingSingleCookieV0 ( ) { </a> 0
<a> String cookieString = "myCookie=myValue;expires=XXX;path=/apathsomewhere;domain=.adomainsomewhere;secure;" ; </a> 0
<a> cookieString = cookieString . replace ( "XXX" , new HttpHeaderDateFormat ( ) . format ( new Date ( System . currentTimeMillis ( ) + 50000 ) ) ) ; </a> 1
<a> Set < Cookie > cookies = CookieDecoder . decode ( cookieString ) ; </a> 0
<a> assertEquals ( 1 , cookies . size ( ) ) ; </a> 0
<a> Cookie cookie = cookies . iterator ( ) . next ( ) ; </a> 0
<a> assertNotNull ( cookie ) ; </a> 0
<a> assertEquals ( "myValue" , cookie . getValue ( ) ) ; </a> 1
<a> assertNull ( cookie . getComment ( ) ) ; </a> 1
<a> assertNull ( cookie . getCommentUrl ( ) ) ; </a> 1
<a> assertEquals ( ".adomainsomewhere" , cookie . getDomain ( ) ) ; </a> 1
<a> assertFalse ( cookie . isDiscard ( ) ) ; </a> 0
<a> boolean fail = true ; </a> 0
<a> for ( int i = 40 ; i <= 60 ; i ++ ) { </a> 0
<a> if ( cookie . getMaxAge ( ) == i ) { </a> 1
<a> fail = false ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( fail ) { </a> 0
<a> fail ( "expected: 50, actual: " + cookie . getMaxAge ( ) ) ; </a> 1
<a> } </a> 0
<a> assertEquals ( "/apathsomewhere" , cookie . getPath ( ) ) ; </a> 1
<a> assertTrue ( cookie . getPorts ( ) . isEmpty ( ) ) ; </a> 1
<a> assertTrue ( cookie . isSecure ( ) ) ; </a> 0
<a> assertEquals ( 0 , cookie . getVersion ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingSingleCookieV0ExtraParamsIgnored ( ) { </a> 0
<a> String cookieString = "myCookie=myValue;max-age=50;path=/apathsomewhere;domain=.adomainsomewhere;secure;comment=this is a comment;version=0;commentURL=http://aurl.com;port=\"80,8080\";discard;" ; </a> 1
<a> Set < Cookie > cookies = CookieDecoder . decode ( cookieString ) ; </a> 0
<a> assertEquals ( 1 , cookies . size ( ) ) ; </a> 0
<a> Cookie cookie = cookies . iterator ( ) . next ( ) ; </a> 0
<a> assertNotNull ( cookie ) ; </a> 0
<a> assertEquals ( "myValue" , cookie . getValue ( ) ) ; </a> 1
<a> assertNull ( cookie . getComment ( ) ) ; </a> 1
<a> assertNull ( cookie . getCommentUrl ( ) ) ; </a> 1
<a> assertEquals ( ".adomainsomewhere" , cookie . getDomain ( ) ) ; </a> 1
<a> assertFalse ( cookie . isDiscard ( ) ) ; </a> 0
<a> assertEquals ( 50 , cookie . getMaxAge ( ) ) ; </a> 1
<a> assertEquals ( "/apathsomewhere" , cookie . getPath ( ) ) ; </a> 1
<a> assertTrue ( cookie . getPorts ( ) . isEmpty ( ) ) ; </a> 1
<a> assertTrue ( cookie . isSecure ( ) ) ; </a> 0
<a> assertEquals ( 0 , cookie . getVersion ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingSingleCookieV1 ( ) { </a> 0
<a> String cookieString = "myCookie=myValue;max-age=50;path=/apathsomewhere;domain=.adomainsomewhere;secure;comment=this is a comment;version=1;" ; </a> 1
<a> Set < Cookie > cookies = CookieDecoder . decode ( cookieString ) ; </a> 0
<a> assertEquals ( 1 , cookies . size ( ) ) ; </a> 0
<a> Cookie cookie = cookies . iterator ( ) . next ( ) ; </a> 0
<a> assertEquals ( "myValue" , cookie . getValue ( ) ) ; </a> 1
<a> assertNotNull ( cookie ) ; </a> 0
<a> assertEquals ( "this is a comment" , cookie . getComment ( ) ) ; </a> 1
<a> assertNull ( cookie . getCommentUrl ( ) ) ; </a> 1
<a> assertEquals ( ".adomainsomewhere" , cookie . getDomain ( ) ) ; </a> 1
<a> assertFalse ( cookie . isDiscard ( ) ) ; </a> 0
<a> assertEquals ( 50 , cookie . getMaxAge ( ) ) ; </a> 1
<a> assertEquals ( "/apathsomewhere" , cookie . getPath ( ) ) ; </a> 1
<a> assertTrue ( cookie . getPorts ( ) . isEmpty ( ) ) ; </a> 1
<a> assertTrue ( cookie . isSecure ( ) ) ; </a> 0
<a> assertEquals ( 1 , cookie . getVersion ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingSingleCookieV1ExtraParamsIgnored ( ) { </a> 0
<a> String cookieString = "myCookie=myValue;max-age=50;path=/apathsomewhere;domain=.adomainsomewhere;secure;comment=this is a comment;version=1;commentURL=http://aurl.com;port='80,8080';discard;" ; </a> 1
<a> Set < Cookie > cookies = CookieDecoder . decode ( cookieString ) ; </a> 0
<a> assertEquals ( 1 , cookies . size ( ) ) ; </a> 0
<a> Cookie cookie = cookies . iterator ( ) . next ( ) ; </a> 0
<a> assertNotNull ( cookie ) ; </a> 0
<a> assertEquals ( "myValue" , cookie . getValue ( ) ) ; </a> 1
<a> assertEquals ( "this is a comment" , cookie . getComment ( ) ) ; </a> 1
<a> assertNull ( cookie . getCommentUrl ( ) ) ; </a> 1
<a> assertEquals ( ".adomainsomewhere" , cookie . getDomain ( ) ) ; </a> 1
<a> assertFalse ( cookie . isDiscard ( ) ) ; </a> 0
<a> assertEquals ( 50 , cookie . getMaxAge ( ) ) ; </a> 1
<a> assertEquals ( "/apathsomewhere" , cookie . getPath ( ) ) ; </a> 1
<a> assertTrue ( cookie . getPorts ( ) . isEmpty ( ) ) ; </a> 1
<a> assertTrue ( cookie . isSecure ( ) ) ; </a> 0
<a> assertEquals ( 1 , cookie . getVersion ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingSingleCookieV2 ( ) { </a> 0
<a> String cookieString = "myCookie=myValue;max-age=50;path=/apathsomewhere;domain=.adomainsomewhere;secure;comment=this is a comment;version=2;commentURL=http://aurl.com;port=\"80,8080\";discard;" ; </a> 1
<a> Set < Cookie > cookies = CookieDecoder . decode ( cookieString ) ; </a> 0
<a> assertEquals ( 1 , cookies . size ( ) ) ; </a> 0
<a> Cookie cookie = cookies . iterator ( ) . next ( ) ; </a> 0
<a> assertNotNull ( cookie ) ; </a> 0
<a> assertEquals ( "myValue" , cookie . getValue ( ) ) ; </a> 1
<a> assertEquals ( "this is a comment" , cookie . getComment ( ) ) ; </a> 1
<a> assertEquals ( "http://aurl.com" , cookie . getCommentUrl ( ) ) ; </a> 1
<a> assertEquals ( ".adomainsomewhere" , cookie . getDomain ( ) ) ; </a> 1
<a> assertTrue ( cookie . isDiscard ( ) ) ; </a> 0
<a> assertEquals ( 50 , cookie . getMaxAge ( ) ) ; </a> 1
<a> assertEquals ( "/apathsomewhere" , cookie . getPath ( ) ) ; </a> 1
<a> assertEquals ( 2 , cookie . getPorts ( ) . size ( ) ) ; </a> 1
<a> assertTrue ( cookie . getPorts ( ) . contains ( 80 ) ) ; </a> 1
<a> assertTrue ( cookie . getPorts ( ) . contains ( 8080 ) ) ; </a> 1
<a> assertTrue ( cookie . isSecure ( ) ) ; </a> 0
<a> assertEquals ( 2 , cookie . getVersion ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingMultipleCookies ( ) { </a> 0
<a> String c1 = "myCookie=myValue;max-age=50;path=/apathsomewhere;domain=.adomainsomewhere;secure;comment=this is a comment;version=2;commentURL=\"http://aurl.com\";port='80,8080';discard;" ; </a> 1
<a> String c2 = "myCookie2=myValue2;max-age=0;path=/anotherpathsomewhere;domain=.anotherdomainsomewhere;comment=this is another comment;version=2;commentURL=http://anotherurl.com;" ; </a> 1
<a> String c3 = "myCookie3=myValue3;max-age=0;version=2;" ; </a> 0
<a> Set < Cookie > cookies = CookieDecoder . decode ( c1 + c2 + c3 ) ; </a> 0
<a> assertEquals ( 3 , cookies . size ( ) ) ; </a> 0
<a> Iterator < Cookie > it = cookies . iterator ( ) ; </a> 0
<a> Cookie cookie = it . next ( ) ; </a> 0
<a> assertNotNull ( cookie ) ; </a> 0
<a> assertEquals ( "myValue" , cookie . getValue ( ) ) ; </a> 1
<a> assertEquals ( "this is a comment" , cookie . getComment ( ) ) ; </a> 1
<a> assertEquals ( "http://aurl.com" , cookie . getCommentUrl ( ) ) ; </a> 1
<a> assertEquals ( ".adomainsomewhere" , cookie . getDomain ( ) ) ; </a> 1
<a> assertTrue ( cookie . isDiscard ( ) ) ; </a> 0
<a> assertEquals ( 50 , cookie . getMaxAge ( ) ) ; </a> 1
<a> assertEquals ( "/apathsomewhere" , cookie . getPath ( ) ) ; </a> 1
<a> assertEquals ( 2 , cookie . getPorts ( ) . size ( ) ) ; </a> 1
<a> assertTrue ( cookie . getPorts ( ) . contains ( 80 ) ) ; </a> 1
<a> assertTrue ( cookie . getPorts ( ) . contains ( 8080 ) ) ; </a> 1
<a> assertTrue ( cookie . isSecure ( ) ) ; </a> 0
<a> assertEquals ( 2 , cookie . getVersion ( ) ) ; </a> 1
<a> cookie = it . next ( ) ; </a> 0
<a> assertNotNull ( cookie ) ; </a> 0
<a> assertEquals ( "myValue2" , cookie . getValue ( ) ) ; </a> 1
<a> assertEquals ( "this is another comment" , cookie . getComment ( ) ) ; </a> 1
<a> assertEquals ( "http://anotherurl.com" , cookie . getCommentUrl ( ) ) ; </a> 1
<a> assertEquals ( ".anotherdomainsomewhere" , cookie . getDomain ( ) ) ; </a> 1
<a> assertFalse ( cookie . isDiscard ( ) ) ; </a> 0
<a> assertEquals ( 0 , cookie . getMaxAge ( ) ) ; </a> 1
<a> assertEquals ( "/anotherpathsomewhere" , cookie . getPath ( ) ) ; </a> 1
<a> assertTrue ( cookie . getPorts ( ) . isEmpty ( ) ) ; </a> 1
<a> assertFalse ( cookie . isSecure ( ) ) ; </a> 0
<a> assertEquals ( 2 , cookie . getVersion ( ) ) ; </a> 1
<a> cookie = it . next ( ) ; </a> 0
<a> assertNotNull ( cookie ) ; </a> 0
<a> assertEquals ( "myValue3" , cookie . getValue ( ) ) ; </a> 1
<a> assertNull ( cookie . getComment ( ) ) ; </a> 1
<a> assertNull ( cookie . getCommentUrl ( ) ) ; </a> 1
<a> assertNull ( cookie . getDomain ( ) ) ; </a> 1
<a> assertFalse ( cookie . isDiscard ( ) ) ; </a> 0
<a> assertEquals ( 0 , cookie . getMaxAge ( ) ) ; </a> 1
<a> assertNull ( cookie . getPath ( ) ) ; </a> 1
<a> assertTrue ( cookie . getPorts ( ) . isEmpty ( ) ) ; </a> 1
<a> assertFalse ( cookie . isSecure ( ) ) ; </a> 0
<a> assertEquals ( 2 , cookie . getVersion ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingClientSideCookies ( ) { </a> 0
<a> String source = "$Version=\"1\"; " + </a> 0
<a> "Part_Number=\"Riding_Rocket_0023\"; $Path=\"/acme/ammo\"; " + </a> 0
<a> "Part_Number=\"Rocket_Launcher_0001\"; $Path=\"/acme\"" ; </a> 0
<a> Set < Cookie > cookies = CookieDecoder . decode ( source ) ; </a> 0
<a> Iterator < Cookie > it = cookies . iterator ( ) ; </a> 0
<a> Cookie c ; </a> 0
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( 1 , c . getVersion ( ) ) ; </a> 1
<a> assertEquals ( "Part_Number" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "Rocket_Launcher_0001" , c . getValue ( ) ) ; </a> 1
<a> assertEquals ( "/acme" , c . getPath ( ) ) ; </a> 1
<a> assertNull ( c . getComment ( ) ) ; </a> 1
<a> assertNull ( c . getCommentUrl ( ) ) ; </a> 1
<a> assertNull ( c . getDomain ( ) ) ; </a> 1
<a> assertTrue ( c . getPorts ( ) . isEmpty ( ) ) ; </a> 1
<a> assertEquals ( Long . MIN_VALUE , c . getMaxAge ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( 1 , c . getVersion ( ) ) ; </a> 1
<a> assertEquals ( "Part_Number" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "Riding_Rocket_0023" , c . getValue ( ) ) ; </a> 1
<a> assertEquals ( "/acme/ammo" , c . getPath ( ) ) ; </a> 1
<a> assertNull ( c . getComment ( ) ) ; </a> 1
<a> assertNull ( c . getCommentUrl ( ) ) ; </a> 1
<a> assertNull ( c . getDomain ( ) ) ; </a> 1
<a> assertTrue ( c . getPorts ( ) . isEmpty ( ) ) ; </a> 1
<a> assertEquals ( Long . MIN_VALUE , c . getMaxAge ( ) ) ; </a> 1
<a> assertFalse ( it . hasNext ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingCommaSeparatedClientSideCookies ( ) { </a> 0
<a> String source = </a> 0
<a> "$Version=\"1\"; session_id=\"1234\", " + </a> 0
<a> "$Version=\"1\"; session_id=\"1111\"; $Domain=\".cracker.edu\"" ; </a> 0
<a> Set < Cookie > cookies = CookieDecoder . decode ( source ) ; </a> 0
<a> Iterator < Cookie > it = cookies . iterator ( ) ; </a> 0
<a> Cookie c ; </a> 0
<a> assertTrue ( it . hasNext ( ) ) ; </a> 0
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( 1 , c . getVersion ( ) ) ; </a> 1
<a> assertEquals ( "session_id" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "1234" , c . getValue ( ) ) ; </a> 1
<a> assertNull ( c . getPath ( ) ) ; </a> 1
<a> assertNull ( c . getComment ( ) ) ; </a> 0
<a> assertNull ( c . getCommentUrl ( ) ) ; </a> 0
<a> assertNull ( c . getDomain ( ) ) ; </a> 0
<a> assertTrue ( c . getPorts ( ) . isEmpty ( ) ) ; </a> 0
<a> assertEquals ( Long . MIN_VALUE , c . getMaxAge ( ) ) ; </a> 1
<a> assertTrue ( it . hasNext ( ) ) ; </a> 0
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( 1 , c . getVersion ( ) ) ; </a> 1
<a> assertEquals ( "session_id" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "1111" , c . getValue ( ) ) ; </a> 1
<a> assertEquals ( ".cracker.edu" , c . getDomain ( ) ) ; </a> 1
<a> assertNull ( c . getPath ( ) ) ; </a> 1
<a> assertNull ( c . getComment ( ) ) ; </a> 1
<a> assertNull ( c . getCommentUrl ( ) ) ; </a> 1
<a> assertTrue ( c . getPorts ( ) . isEmpty ( ) ) ; </a> 1
<a> assertEquals ( Long . MIN_VALUE , c . getMaxAge ( ) ) ; </a> 1
<a> assertFalse ( it . hasNext ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingQuotedCookie ( ) { </a> 0
<a> String source = </a> 0
<a> "a=\"\"," + </a> 0
<a> "b=\"1\"," + </a> 0
<a> "c=\"\\\"1\\\"2\\\"\"," + </a> 0
<a> "d=\"1\\\"2\\\"3\"," + </a> 0
<a> "e=\"\\\"\\\"\"," + </a> 0
<a> "f=\"1\\\"\\\"2\"," + </a> 0
<a> "g=\"\\\\\"," + </a> 0
<a> "h=\"';,\\x\"" ; </a> 0
<a> Set < Cookie > cookies = CookieDecoder . decode ( source ) ; </a> 0
<a> Iterator < Cookie > it = cookies . iterator ( ) ; </a> 0
<a> Cookie c ; </a> 0
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "a" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "" , c . getValue ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "b" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "1" , c . getValue ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "c" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "\"1\"2\"" , c . getValue ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "d" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "1\"2\"3" , c . getValue ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "e" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "\"\"" , c . getValue ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "f" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "1\"\"2" , c . getValue ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "g" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "\\" , c . getValue ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "h" , c . getName ( ) ) ; </a> 0
<a> assertEquals ( "';,\\x" , c . getValue ( ) ) ; </a> 0
<a> assertFalse ( it . hasNext ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingGoogleAnalyticsCookie ( ) { </a> 0
<a> String source = </a> 0
<a> "ARPT=LWUKQPSWRTUN04CKKJI; " + </a> 0
<a> "kw-2E343B92-B097-442c-BFA5-BE371E0325A2=unfinished furniture; " + </a> 0
<a> "__utma=48461872.1094088325.1258140131.1258140131.1258140131.1; " + </a> 0
<a> "__utmb=48461872.13.10.1258140131; __utmc=48461872; " + </a> 0
<a> "__utmz=48461872.1258140131.1.1.utmcsr=overstock.com|utmccn=(referral)|utmcmd=referral|utmcct=/Home-Garden/Furniture/Clearance,/clearance,/32/dept.html" ; </a> 1
<a> Set < Cookie > cookies = CookieDecoder . decode ( source ) ; </a> 0
<a> Iterator < Cookie > it = cookies . iterator ( ) ; </a> 0
<a> Cookie c ; </a> 0
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "__utma" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "48461872.1094088325.1258140131.1258140131.1258140131.1" , c . getValue ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "__utmb" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "48461872.13.10.1258140131" , c . getValue ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "__utmc" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "48461872" , c . getValue ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "__utmz" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "48461872.1258140131.1.1.utmcsr=overstock.com|utmccn=(referral)|utmcmd=referral|utmcct=/Home-Garden/Furniture/Clearance,/clearance,/32/dept.html" , c . getValue ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "ARPT" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "LWUKQPSWRTUN04CKKJI" , c . getValue ( ) ) ; </a> 1
<a> c = it . next ( ) ; </a> 0
<a> assertEquals ( "kw-2E343B92-B097-442c-BFA5-BE371E0325A2" , c . getName ( ) ) ; </a> 1
<a> assertEquals ( "unfinished furniture" , c . getValue ( ) ) ; </a> 1
<a> assertFalse ( it . hasNext ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingLongDates ( ) { </a> 0
<a> Calendar cookieDate = Calendar . getInstance ( TimeZone . getTimeZone ( "UTC" ) ) ; </a> 0
<a> cookieDate . set ( 9999 , Calendar . DECEMBER , 31 , 23 , 59 , 59 ) ; </a> 0
<a> long expectedMaxAge = ( cookieDate . getTimeInMillis ( ) - System . currentTimeMillis ( ) ) / 1000 ; </a> 0
<a> String source = "Format=EU; expires=Fri, 31-Dec-9999 23:59:59 GMT; path=/" ; </a> 0
<a> Set < Cookie > cookies = CookieDecoder . decode ( source ) ; </a> 0
<a> Cookie c = cookies . iterator ( ) . next ( ) ; </a> 0
<a> assertTrue ( Math . abs ( expectedMaxAge - c . getMaxAge ( ) ) < 2 ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingValueWithComma ( ) { </a> 0
<a> String source = "UserCookie=timeZoneName=(GMT+04:00) Moscow, St. Petersburg, Volgograd&promocode=&region=BE;" + </a> 0
<a> " expires=Sat, 01-Dec-2012 10:53:31 GMT; path=/" ; </a> 0
<a> Set < Cookie > cookies = CookieDecoder . decode ( source ) ; </a> 0
<a> Cookie c = cookies . iterator ( ) . next ( ) ; </a> 0
<a> assertEquals ( "timeZoneName=(GMT+04:00) Moscow, St. Petersburg, Volgograd&promocode=&region=BE" , c . getValue ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingWeirdNames1 ( ) { </a> 0
<a> String src = "path=; expires=Mon, 01-Jan-1990 00:00:00 GMT; path=/; domain=.www.google.com" ; </a> 0
<a> Set < Cookie > cookies = CookieDecoder . decode ( src ) ; </a> 0
<a> Cookie c = cookies . iterator ( ) . next ( ) ; </a> 0
<a> assertEquals ( "path" , c . getName ( ) ) ; </a> 0
<a> assertEquals ( "" , c . getValue ( ) ) ; </a> 0
<a> assertEquals ( "/" , c . getPath ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingWeirdNames2 ( ) { </a> 0
<a> String src = "HTTPOnly=" ; </a> 0
<a> Set < Cookie > cookies = CookieDecoder . decode ( src ) ; </a> 0
<a> Cookie c = cookies . iterator ( ) . next ( ) ; </a> 0
<a> assertEquals ( "HTTPOnly" , c . getName ( ) ) ; </a> 0
<a> assertEquals ( "" , c . getValue ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingValuesWithCommasAndEquals ( ) { </a> 0
<a> String src = "A=v=1&lg=en-US,it-IT,it&intl=it&np=1;T=z=E" ; </a> 0
<a> Set < Cookie > cookies = CookieDecoder . decode ( src ) ; </a> 0
<a> Iterator < Cookie > i = cookies . iterator ( ) ; </a> 0
<a> Cookie c = i . next ( ) ; </a> 0
<a> assertEquals ( "A" , c . getName ( ) ) ; </a> 0
<a> assertEquals ( "v=1&lg=en-US,it-IT,it&intl=it&np=1" , c . getValue ( ) ) ; </a> 0
<a> c = i . next ( ) ; </a> 0
<a> assertEquals ( "T" , c . getName ( ) ) ; </a> 0
<a> assertEquals ( "z=E" , c . getValue ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodingLongValue ( ) { </a> 0
<a> String longValue = </a> 0
<a> "b!!!$Q!!$ha!!<NC=MN(F!!%#4!!<NC=MN(F!!2!d!!!!#=IvZB!!2,F!!!!'=KqtH!!2-9!!!!" + </a> 0
<a> "'=IvZM!!3f:!!!!$=HbQW!!3g'!!!!%=J^wI!!3g-!!!!%=J^wI!!3g1!!!!$=HbQW!!3g2!!!!" + </a> 0
<a> "$=HbQW!!3g5!!!!%=J^wI!!3g9!!!!$=HbQW!!3gT!!!!$=HbQW!!3gX!!!!#=J^wI!!3gY!!!!" + </a> 0
<a> "#=J^wI!!3gh!!!!$=HbQW!!3gj!!!!$=HbQW!!3gr!!!!$=HbQW!!3gx!!!!#=J^wI!!3h!!!!!" + </a> 0
<a> "$=HbQW!!3h$!!!!#=J^wI!!3h'!!!!$=HbQW!!3h,!!!!$=HbQW!!3h0!!!!%=J^wI!!3h1!!!!" + </a> 0
<a> "#=J^wI!!3h2!!!!$=HbQW!!3h4!!!!$=HbQW!!3h7!!!!$=HbQW!!3h8!!!!%=J^wI!!3h:!!!!" + </a> 0
<a> "#=J^wI!!3h@!!!!%=J^wI!!3hB!!!!$=HbQW!!3hC!!!!$=HbQW!!3hL!!!!$=HbQW!!3hQ!!!!" + </a> 0
<a> "$=HbQW!!3hS!!!!%=J^wI!!3hU!!!!$=HbQW!!3h[!!!!$=HbQW!!3h^!!!!$=HbQW!!3hd!!!!" + </a> 0
<a> "%=J^wI!!3he!!!!%=J^wI!!3hf!!!!%=J^wI!!3hg!!!!$=HbQW!!3hh!!!!%=J^wI!!3hi!!!!" + </a> 0
<a> "%=J^wI!!3hv!!!!$=HbQW!!3i/!!!!#=J^wI!!3i2!!!!#=J^wI!!3i3!!!!%=J^wI!!3i4!!!!" + </a> 0
<a> "$=HbQW!!3i7!!!!$=HbQW!!3i8!!!!$=HbQW!!3i9!!!!%=J^wI!!3i=!!!!#=J^wI!!3i>!!!!" + </a> 0
<a> "%=J^wI!!3iD!!!!$=HbQW!!3iF!!!!#=J^wI!!3iH!!!!%=J^wI!!3iM!!!!%=J^wI!!3iS!!!!" + </a> 0
<a> "#=J^wI!!3iU!!!!%=J^wI!!3iZ!!!!#=J^wI!!3i]!!!!%=J^wI!!3ig!!!!%=J^wI!!3ij!!!!" + </a> 0
<a> "%=J^wI!!3ik!!!!#=J^wI!!3il!!!!$=HbQW!!3in!!!!%=J^wI!!3ip!!!!$=HbQW!!3iq!!!!" + </a> 0
<a> "$=HbQW!!3it!!!!%=J^wI!!3ix!!!!#=J^wI!!3j!!!!!$=HbQW!!3j%!!!!$=HbQW!!3j'!!!!" + </a> 0
<a> "%=J^wI!!3j(!!!!%=J^wI!!9mJ!!!!'=KqtH!!=SE!!<NC=MN(F!!?VS!!<NC=MN(F!!Zw`!!!!" + </a> 0
<a> "%=KqtH!!j+C!!<NC=MN(F!!j+M!!<NC=MN(F!!j+a!!<NC=MN(F!!j,.!!<NC=MN(F!!n>M!!!!" + </a> 0
<a> "'=KqtH!!s1X!!!!$=MMyc!!s1_!!!!#=MN#O!!ypn!!!!'=KqtH!!ypr!!!!'=KqtH!#%h!!!!!" + </a> 0
<a> "%=KqtH!#%o!!!!!'=KqtH!#)H6!!<NC=MN(F!#*%'!!!!%=KqtH!#+k(!!!!'=KqtH!#-E!!!!!" + </a> 0
<a> "'=KqtH!#1)w!!!!'=KqtH!#1)y!!!!'=KqtH!#1*M!!!!#=KqtH!#1*p!!!!'=KqtH!#14Q!!<N" + </a> 0
<a> "C=MN(F!#14S!!<NC=MN(F!#16I!!<NC=MN(F!#16N!!<NC=MN(F!#16X!!<NC=MN(F!#16k!!<N" + </a> 0
<a> "C=MN(F!#17@!!<NC=MN(F!#17A!!<NC=MN(F!#1Cq!!!!'=KqtH!#7),!!!!#=KqtH!#7)b!!!!" + </a> 0
<a> "#=KqtH!#7Ww!!!!'=KqtH!#?cQ!!!!'=KqtH!#His!!!!'=KqtH!#Jrh!!!!'=KqtH!#O@M!!<N" + </a> 0
<a> "C=MN(F!#O@O!!<NC=MN(F!#OC6!!<NC=MN(F!#Os.!!!!#=KqtH!#YOW!!!!#=H/Li!#Zat!!!!" + </a> 0
<a> "'=KqtH!#ZbI!!!!%=KqtH!#Zbc!!!!'=KqtH!#Zbs!!!!%=KqtH!#Zby!!!!'=KqtH!#Zce!!!!" + </a> 0
<a> "'=KqtH!#Zdc!!!!%=KqtH!#Zea!!!!'=KqtH!#ZhI!!!!#=KqtH!#ZiD!!!!'=KqtH!#Zis!!!!" + </a> 0
<a> "'=KqtH!#Zj0!!!!#=KqtH!#Zj1!!!!'=KqtH!#Zj[!!!!'=KqtH!#Zj]!!!!'=KqtH!#Zj^!!!!" + </a> 0
<a> "'=KqtH!#Zjb!!!!'=KqtH!#Zk!!!!!'=KqtH!#Zk6!!!!#=KqtH!#Zk9!!!!%=KqtH!#Zk<!!!!" + </a> 0
<a> "'=KqtH!#Zl>!!!!'=KqtH!#]9R!!!!$=H/Lt!#]I6!!!!#=KqtH!#]Z#!!!!%=KqtH!#^*N!!!!" + </a> 0
<a> "#=KqtH!#^:m!!!!#=KqtH!#_*_!!!!%=J^wI!#`-7!!!!#=KqtH!#`T>!!!!'=KqtH!#`T?!!!!" + </a> 0
<a> "'=KqtH!#`TA!!!!'=KqtH!#`TB!!!!'=KqtH!#`TG!!!!'=KqtH!#`TP!!!!#=KqtH!#`U,!!!!" + </a> 0
<a> "'=KqtH!#`U/!!!!'=KqtH!#`U0!!!!#=KqtH!#`U9!!!!'=KqtH!#aEQ!!!!%=KqtH!#b<)!!!!" + </a> 0
<a> "'=KqtH!#c9-!!!!%=KqtH!#dxC!!!!%=KqtH!#dxE!!!!%=KqtH!#ev$!!!!'=KqtH!#fBi!!!!" + </a> 0
<a> "#=KqtH!#fBj!!!!'=KqtH!#fG)!!!!'=KqtH!#fG+!!!!'=KqtH!#g<d!!!!'=KqtH!#g<e!!!!" + </a> 0
<a> "'=KqtH!#g=J!!!!'=KqtH!#gat!!!!#=KqtH!#s`D!!!!#=J_#p!#sg?!!!!#=J_#p!#t<a!!!!" + </a> 0
<a> "#=KqtH!#t<c!!!!#=KqtH!#trY!!!!$=JiYj!#vA$!!!!'=KqtH!#xs_!!!!'=KqtH!$$rO!!!!" + </a> 0
<a> "#=KqtH!$$rP!!!!#=KqtH!$(!%!!!!'=KqtH!$)]o!!!!%=KqtH!$,@)!!!!'=KqtH!$,k]!!!!" + </a> 0
<a> "'=KqtH!$1]+!!!!%=KqtH!$3IO!!!!%=KqtH!$3J#!!!!'=KqtH!$3J.!!!!'=KqtH!$3J:!!!!" + </a> 0
<a> "#=KqtH!$3JH!!!!#=KqtH!$3JI!!!!#=KqtH!$3JK!!!!%=KqtH!$3JL!!!!'=KqtH!$3JS!!!!" + </a> 0
<a> "'=KqtH!$8+M!!!!#=KqtH!$99d!!!!%=KqtH!$:Lw!!!!#=LK+x!$:N@!!!!#=KqtG!$:NC!!!!" + </a> 0
<a> "#=KqtG!$:hW!!!!'=KqtH!$:i[!!!!'=KqtH!$:ih!!!!'=KqtH!$:it!!!!'=KqtH!$:kO!!!!" + </a> 0
<a> "'=KqtH!$>*B!!!!'=KqtH!$>hD!!!!+=J^x0!$?lW!!!!'=KqtH!$?ll!!!!'=KqtH!$?lm!!!!" + </a> 0
<a> "%=KqtH!$?mi!!!!'=KqtH!$?mx!!!!'=KqtH!$D7]!!!!#=J_#p!$D@T!!!!#=J_#p!$V<g!!!!" + </a> 0
<a> "'=KqtH" ; </a> 0
<a> Set < Cookie > cookies = CookieDecoder . decode ( "bh=\"" + longValue + "\";" ) ; </a> 0
<a> assertEquals ( 1 , cookies . size ( ) ) ; </a> 0
<a> Cookie c = cookies . iterator ( ) . next ( ) ; </a> 0
<a> assertEquals ( "bh" , c . getName ( ) ) ; </a> 0
<a> assertEquals ( longValue , c . getValue ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . handler . codec . compression . ZlibWrapper ; </a> 0
<a> import org . junit . Assert ; </a> 1
<a> import org . junit . Test ; </a> 1
<a> public class HttpContentCompressorTest { </a> 0
<a> @ Test </a> 0
<a> public void testGetTargetContentEncoding ( ) throws Exception { </a> 0
<a> HttpContentCompressor compressor = new HttpContentCompressor ( ) ; </a> 0
<a> String [ ] tests = { </a> 0
<a> "" , null , </a> 0
<a> "*" , "gzip" , </a> 0
<a> "*;q=0.0" , null , </a> 0
<a> "gzip" , "gzip" , </a> 0
<a> "compress, gzip;q=0.5" , "gzip" , </a> 0
<a> "gzip; q=0.5, identity" , "gzip" , </a> 0
<a> "gzip ; q=0.1" , "gzip" , </a> 0
<a> "gzip; q=0, deflate" , "deflate" , </a> 0
<a> " deflate ; q=0 , *;q=0.5" , "gzip" , </a> 0
<a> } ; </a> 0
<a> for ( int i = 0 ; i < tests . length ; i += 2 ) { </a> 0
<a> String acceptEncoding = tests [ i ] ; </a> 0
<a> String contentEncoding = tests [ i + 1 ] ; </a> 0
<a> ZlibWrapper targetWrapper = compressor . determineWrapper ( acceptEncoding ) ; </a> 0
<a> String targetEncoding = null ; </a> 0
<a> if ( targetWrapper != null ) { </a> 0
<a> switch ( targetWrapper ) { </a> 0
<a> case GZIP : </a> 0
<a> targetEncoding = "gzip" ; </a> 0
<a> break ; </a> 0
<a> case ZLIB : </a> 0
<a> targetEncoding = "deflate" ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> Assert . fail ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> Assert . assertEquals ( contentEncoding , targetEncoding ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import java . text . ParseException ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import junit . framework . Assert ; </a> 1
<a> import org . junit . Test ; </a> 1
<a> public class HttpHeaderDateFormatTest { </a> 0
<a> private static final Date DATE = new Date ( 784111777000L ) ; </a> 0
<a> @ Test </a> 0
<a> public void testParse ( ) throws ParseException { </a> 0
<a> HttpHeaderDateFormat format = new HttpHeaderDateFormat ( ) ; </a> 0
<a> { </a> 1
<a> final Date parsed = format . parse ( "Sun, 6 Nov 1994 08:49:37 GMT" ) ; </a> 1
<a> Assert . assertNotNull ( parsed ) ; </a> 1
<a> Assert . assertEquals ( DATE , parsed ) ; </a> 1
<a> } </a> 1
<a> { </a> 1
<a> final Date parsed = format . parse ( "Sun, 06 Nov 1994 08:49:37 GMT" ) ; </a> 1
<a> Assert . assertNotNull ( parsed ) ; </a> 1
<a> Assert . assertEquals ( DATE , parsed ) ; </a> 1
<a> } </a> 1
<a> { </a> 1
<a> final Date parsed = format . parse ( "Sunday, 06-Nov-94 08:49:37 GMT" ) ; </a> 1
<a> Assert . assertNotNull ( parsed ) ; </a> 1
<a> Assert . assertEquals ( DATE , parsed ) ; </a> 1
<a> } </a> 1
<a> { </a> 1
<a> final Date parsed = format . parse ( "Sunday, 6-Nov-94 08:49:37 GMT" ) ; </a> 1
<a> Assert . assertNotNull ( parsed ) ; </a> 1
<a> Assert . assertEquals ( DATE , parsed ) ; </a> 1
<a> } </a> 1
<a> { </a> 1
<a> final Date parsed = format . parse ( "Sun Nov 6 08:49:37 1994" ) ; </a> 1
<a> Assert . assertNotNull ( parsed ) ; </a> 1
<a> Assert . assertEquals ( DATE , parsed ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testFormat ( ) { </a> 0
<a> HttpHeaderDateFormat format = new HttpHeaderDateFormat ( ) ; </a> 0
<a> final String formatted = format . format ( DATE ) ; </a> 0
<a> Assert . assertNotNull ( formatted ) ; </a> 1
<a> Assert . assertEquals ( "Sun, 06 Nov 1994 08:49:37 GMT" , formatted ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . net . URI ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> import org . junit . Assert ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class QueryStringDecoderTest { </a> 0
<a> @ Test </a> 0
<a> public void testBasic ( ) throws Exception { </a> 0
<a> QueryStringDecoder d ; </a> 0
<a> d = new QueryStringDecoder ( "/foo?a=b=c" ) ; </a> 0
<a> Assert . assertEquals ( "/foo" , d . getPath ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , d . getParameters ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , d . getParameters ( ) . get ( "a" ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "b=c" , d . getParameters ( ) . get ( "a" ) . get ( 0 ) ) ; </a> 0
<a> d = new QueryStringDecoder ( "/foo?a=1&a=2" ) ; </a> 0
<a> Assert . assertEquals ( "/foo" , d . getPath ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , d . getParameters ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( 2 , d . getParameters ( ) . get ( "a" ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "1" , d . getParameters ( ) . get ( "a" ) . get ( 0 ) ) ; </a> 0
<a> Assert . assertEquals ( "2" , d . getParameters ( ) . get ( "a" ) . get ( 1 ) ) ; </a> 0
<a> d = new QueryStringDecoder ( "/foo?a=&a=2" ) ; </a> 0
<a> Assert . assertEquals ( "/foo" , d . getPath ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , d . getParameters ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( 2 , d . getParameters ( ) . get ( "a" ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "" , d . getParameters ( ) . get ( "a" ) . get ( 0 ) ) ; </a> 0
<a> Assert . assertEquals ( "2" , d . getParameters ( ) . get ( "a" ) . get ( 1 ) ) ; </a> 0
<a> d = new QueryStringDecoder ( "/foo?a=1&a=" ) ; </a> 0
<a> Assert . assertEquals ( "/foo" , d . getPath ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , d . getParameters ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( 2 , d . getParameters ( ) . get ( "a" ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "1" , d . getParameters ( ) . get ( "a" ) . get ( 0 ) ) ; </a> 0
<a> Assert . assertEquals ( "" , d . getParameters ( ) . get ( "a" ) . get ( 1 ) ) ; </a> 0
<a> d = new QueryStringDecoder ( "/foo?a=1&a=&a=" ) ; </a> 0
<a> Assert . assertEquals ( "/foo" , d . getPath ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , d . getParameters ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( 3 , d . getParameters ( ) . get ( "a" ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "1" , d . getParameters ( ) . get ( "a" ) . get ( 0 ) ) ; </a> 0
<a> Assert . assertEquals ( "" , d . getParameters ( ) . get ( "a" ) . get ( 1 ) ) ; </a> 0
<a> Assert . assertEquals ( "" , d . getParameters ( ) . get ( "a" ) . get ( 2 ) ) ; </a> 0
<a> d = new QueryStringDecoder ( "/foo?a=1=&a==2" ) ; </a> 0
<a> Assert . assertEquals ( "/foo" , d . getPath ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , d . getParameters ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( 2 , d . getParameters ( ) . get ( "a" ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "1=" , d . getParameters ( ) . get ( "a" ) . get ( 0 ) ) ; </a> 0
<a> Assert . assertEquals ( "=2" , d . getParameters ( ) . get ( "a" ) . get ( 1 ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testExotic ( ) throws Exception { </a> 0
<a> assertQueryString ( "" , "" ) ; </a> 0
<a> assertQueryString ( "foo" , "foo" ) ; </a> 0
<a> assertQueryString ( "/foo" , "/foo" ) ; </a> 0
<a> assertQueryString ( "?a=" , "?a" ) ; </a> 0
<a> assertQueryString ( "foo?a=" , "foo?a" ) ; </a> 0
<a> assertQueryString ( "/foo?a=" , "/foo?a" ) ; </a> 0
<a> assertQueryString ( "/foo?a=" , "/foo?a&" ) ; </a> 0
<a> assertQueryString ( "/foo?a=" , "/foo?&a" ) ; </a> 0
<a> assertQueryString ( "/foo?a=" , "/foo?&a&" ) ; </a> 0
<a> assertQueryString ( "/foo?a=" , "/foo?&=a" ) ; </a> 0
<a> assertQueryString ( "/foo?a=" , "/foo?=a&" ) ; </a> 0
<a> assertQueryString ( "/foo?a=" , "/foo?a=&" ) ; </a> 0
<a> assertQueryString ( "/foo?a=b&c=d" , "/foo?a=b&&c=d" ) ; </a> 0
<a> assertQueryString ( "/foo?a=b&c=d" , "/foo?a=b&=&c=d" ) ; </a> 0
<a> assertQueryString ( "/foo?a=b&c=d" , "/foo?a=b&==&c=d" ) ; </a> 0
<a> assertQueryString ( "/foo?a=b&c=&x=y" , "/foo?a=b&c&x=y" ) ; </a> 0
<a> assertQueryString ( "/foo?a=" , "/foo?a=" ) ; </a> 0
<a> assertQueryString ( "/foo?a=" , "/foo?&a=" ) ; </a> 0
<a> assertQueryString ( "/foo?a=b&c=d" , "/foo?a=b&c=d" ) ; </a> 0
<a> assertQueryString ( "/foo?a=1&a=&a=" , "/foo?a=1&a&a=" ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testHashDos ( ) throws Exception { </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 0
<a> buf . append ( '?' ) ; </a> 0
<a> for ( int i = 0 ; i < 65536 ; i ++ ) { </a> 0
<a> buf . append ( 'k' ) ; </a> 0
<a> buf . append ( i ) ; </a> 0
<a> buf . append ( "=v" ) ; </a> 0
<a> buf . append ( i ) ; </a> 0
<a> buf . append ( '&' ) ; </a> 0
<a> } </a> 0
<a> Assert . assertEquals ( 1024 , new QueryStringDecoder ( buf . toString ( ) ) . getParameters ( ) . size ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testHasPath ( ) throws Exception { </a> 0
<a> QueryStringDecoder decoder = new QueryStringDecoder ( "1=2" , false ) ; </a> 0
<a> Assert . assertEquals ( "" , decoder . getPath ( ) ) ; </a> 0
<a> Map < String , List < String > > params = decoder . getParameters ( ) ; </a> 0
<a> Assert . assertEquals ( 1 , params . size ( ) ) ; </a> 0
<a> Assert . assertTrue ( params . containsKey ( "1" ) ) ; </a> 0
<a> List < String > param = params . get ( "1" ) ; </a> 0
<a> Assert . assertNotNull ( param ) ; </a> 0
<a> Assert . assertEquals ( 1 , param . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "2" , param . get ( 0 ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testUrlDecoding ( ) throws Exception { </a> 0
<a> final String caffe = new String ( </a> 0
<a> new byte [ ] { 'C' , 'a' , 'f' , 'f' , ( byte ) 0xC3 , ( byte ) 0xA9 } , </a> 0
<a> "UTF-8" ) ; </a> 0
<a> final String [ ] tests = { </a> 0
<a> "" , "" , </a> 0
<a> "foo" , "foo" , </a> 0
<a> "f%%b" , "f%b" , </a> 0
<a> "f+o" , "f o" , </a> 0
<a> "f++" , "f " , </a> 0
<a> "fo%" , "unterminated escape sequence" , </a> 0
<a> "%42" , "B" , </a> 0
<a> "%5f" , "_" , </a> 0
<a> "f%4" , "partial escape sequence" , </a> 0
<a> "%x2" , "invalid escape sequence `%x2' at index 0 of: %x2" , </a> 0
<a> "%4x" , "invalid escape sequence `%4x' at index 0 of: %4x" , </a> 0
<a> "Caff%C3%A9" , caffe , </a> 0
<a> } ; </a> 0
<a> for ( int i = 0 ; i < tests . length ; i += 2 ) { </a> 0
<a> final String encoded = tests [ i ] ; </a> 0
<a> final String expected = tests [ i + 1 ] ; </a> 0
<a> try { </a> 0
<a> final String decoded = QueryStringDecoder . decodeComponent ( encoded ) ; </a> 0
<a> Assert . assertEquals ( expected , decoded ) ; </a> 0
<a> } catch ( IllegalArgumentException e ) { </a> 0
<a> Assert . assertTrue ( "String \"" + e . getMessage ( ) + "\" does" </a> 0
<a> + " not contain \"" + expected + '"' , </a> 0
<a> e . getMessage ( ) . contains ( expected ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void assertQueryString ( String expected , String actual ) { </a> 0
<a> QueryStringDecoder ed = new QueryStringDecoder ( expected , CharsetUtil . UTF_8 ) ; </a> 0
<a> QueryStringDecoder ad = new QueryStringDecoder ( actual , CharsetUtil . UTF_8 ) ; </a> 0
<a> Assert . assertEquals ( ed . getPath ( ) , ad . getPath ( ) ) ; </a> 0
<a> Assert . assertEquals ( ed . getParameters ( ) , ad . getParameters ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testURI ( ) { </a> 0
<a> URI uri = URI . create ( "http://localhost:8080/foo?param1=value1&param2=value2&param3=value3" ) ; </a> 0
<a> QueryStringDecoder decoder = new QueryStringDecoder ( uri ) ; </a> 0
<a> Assert . assertEquals ( "/foo" , decoder . getPath ( ) ) ; </a> 0
<a> Map < String , List < String > > params = decoder . getParameters ( ) ; </a> 0
<a> Assert . assertEquals ( 3 , params . size ( ) ) ; </a> 0
<a> Iterator < Entry < String , List < String > > > entries = params . entrySet ( ) . iterator ( ) ; </a> 0
<a> Entry < String , List < String > > entry = entries . next ( ) ; </a> 0
<a> Assert . assertEquals ( "param1" , entry . getKey ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , entry . getValue ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "value1" , entry . getValue ( ) . get ( 0 ) ) ; </a> 0
<a> entry = entries . next ( ) ; </a> 0
<a> Assert . assertEquals ( "param2" , entry . getKey ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , entry . getValue ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "value2" , entry . getValue ( ) . get ( 0 ) ) ; </a> 0
<a> entry = entries . next ( ) ; </a> 0
<a> Assert . assertEquals ( "param3" , entry . getKey ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , entry . getValue ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "value3" , entry . getValue ( ) . get ( 0 ) ) ; </a> 0
<a> Assert . assertFalse ( entries . hasNext ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testURISlashPath ( ) { </a> 0
<a> URI uri = URI . create ( "http://localhost:8080/?param1=value1&param2=value2&param3=value3" ) ; </a> 0
<a> QueryStringDecoder decoder = new QueryStringDecoder ( uri ) ; </a> 0
<a> Assert . assertEquals ( "/" , decoder . getPath ( ) ) ; </a> 0
<a> Map < String , List < String > > params = decoder . getParameters ( ) ; </a> 0
<a> Assert . assertEquals ( 3 , params . size ( ) ) ; </a> 0
<a> Iterator < Entry < String , List < String > > > entries = params . entrySet ( ) . iterator ( ) ; </a> 0
<a> Entry < String , List < String > > entry = entries . next ( ) ; </a> 0
<a> Assert . assertEquals ( "param1" , entry . getKey ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , entry . getValue ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "value1" , entry . getValue ( ) . get ( 0 ) ) ; </a> 0
<a> entry = entries . next ( ) ; </a> 0
<a> Assert . assertEquals ( "param2" , entry . getKey ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , entry . getValue ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "value2" , entry . getValue ( ) . get ( 0 ) ) ; </a> 0
<a> entry = entries . next ( ) ; </a> 0
<a> Assert . assertEquals ( "param3" , entry . getKey ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , entry . getValue ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "value3" , entry . getValue ( ) . get ( 0 ) ) ; </a> 0
<a> Assert . assertFalse ( entries . hasNext ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testURINoPath ( ) { </a> 0
<a> URI uri = URI . create ( "http://localhost:8080?param1=value1&param2=value2&param3=value3" ) ; </a> 0
<a> QueryStringDecoder decoder = new QueryStringDecoder ( uri ) ; </a> 0
<a> Assert . assertEquals ( "" , decoder . getPath ( ) ) ; </a> 0
<a> Map < String , List < String > > params = decoder . getParameters ( ) ; </a> 0
<a> Assert . assertEquals ( 3 , params . size ( ) ) ; </a> 0
<a> Iterator < Entry < String , List < String > > > entries = params . entrySet ( ) . iterator ( ) ; </a> 0
<a> Entry < String , List < String > > entry = entries . next ( ) ; </a> 0
<a> Assert . assertEquals ( "param1" , entry . getKey ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , entry . getValue ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "value1" , entry . getValue ( ) . get ( 0 ) ) ; </a> 0
<a> entry = entries . next ( ) ; </a> 0
<a> Assert . assertEquals ( "param2" , entry . getKey ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , entry . getValue ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "value2" , entry . getValue ( ) . get ( 0 ) ) ; </a> 0
<a> entry = entries . next ( ) ; </a> 0
<a> Assert . assertEquals ( "param3" , entry . getKey ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , entry . getValue ( ) . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( "value3" , entry . getValue ( ) . get ( 0 ) ) ; </a> 0
<a> Assert . assertFalse ( entries . hasNext ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . Values . * ; </a> 1
<a> import static io . netty . handler . codec . http . HttpVersion . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import io . netty . handler . codec . http . DefaultHttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpChunkAggregator ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders . Names ; </a> 0
<a> import io . netty . handler . codec . http . HttpMethod ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpRequestDecoder ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseDecoder ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseEncoder ; </a> 0
<a> import org . junit . Assert ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class WebSocketServerHandshaker08Test { </a> 0
<a> @ Test </a> 0
<a> public void testPerformOpeningHandshake ( ) { </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( </a> 1
<a> new HttpChunkAggregator ( 42 ) , new HttpRequestDecoder ( ) , new HttpResponseEncoder ( ) ) ; </a> 0
<a> HttpRequest req = new DefaultHttpRequest ( HTTP_1_1 , HttpMethod . GET , "/chat" ) ; </a> 0
<a> req . setHeader ( Names . HOST , "server.example.com" ) ; </a> 0
<a> req . setHeader ( Names . UPGRADE , WEBSOCKET . toLowerCase ( ) ) ; </a> 0
<a> req . setHeader ( Names . CONNECTION , "Upgrade" ) ; </a> 0
<a> req . setHeader ( Names . SEC_WEBSOCKET_KEY , "dGhlIHNhbXBsZSBub25jZQ==" ) ; </a> 0
<a> req . setHeader ( Names . SEC_WEBSOCKET_ORIGIN , "http://example.com" ) ; </a> 0
<a> req . setHeader ( Names . SEC_WEBSOCKET_PROTOCOL , "chat, superchat" ) ; </a> 0
<a> req . setHeader ( Names . SEC_WEBSOCKET_VERSION , "8" ) ; </a> 1
<a> new WebSocketServerHandshaker08 ( </a> 0
<a> "ws://example.com/chat" , "chat" , false , Integer . MAX_VALUE ) . handshake ( ch , req ) ; </a> 0
<a> ByteBuf resBuf = ch . readOutbound ( ) ; </a> 1
<a> EmbeddedByteChannel ch2 = new EmbeddedByteChannel ( new HttpResponseDecoder ( ) ) ; </a> 1
<a> ch2 . writeInbound ( resBuf ) ; </a> 0
<a> HttpResponse res = ( HttpResponse ) ch2 . readInbound ( ) ; </a> 0
<a> Assert . assertEquals ( </a> 0
<a> "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=" , res . getHeader ( Names . SEC_WEBSOCKET_ACCEPT ) ) ; </a> 1
<a> Assert . assertEquals ( "chat" , res . getHeader ( Names . SEC_WEBSOCKET_PROTOCOL ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 1
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 1
<a> public abstract class ByteToByteDecoder extends ChannelInboundByteHandlerAdapter { </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 1
<a> callDecode ( ctx , in , ctx . nextInboundByteBuffer ( ) ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> ByteBuf in = ctx . inboundByteBuffer ( ) ; </a> 1
<a> ByteBuf out = ctx . nextInboundByteBuffer ( ) ; </a> 0
<a> if ( ! in . readable ( ) ) { </a> 0
<a> callDecode ( ctx , in , out ) ; </a> 0
<a> } </a> 1
<a> int oldOutSize = out . readableBytes ( ) ; </a> 1
<a> try { </a> 1
<a> decodeLast ( ctx , in , out ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> if ( t instanceof CodecException ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } else { </a> 0
<a> ctx . fireExceptionCaught ( new DecoderException ( t ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( out . readableBytes ( ) > oldOutSize ) { </a> 1
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 1
<a> ctx . fireChannelInactive ( ) ; </a> 1
<a> } </a> 1
<a> private void callDecode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) { </a> 0
<a> int oldOutSize = out . readableBytes ( ) ; </a> 1
<a> while ( in . readable ( ) ) { </a> 0
<a> int oldInSize = in . readableBytes ( ) ; </a> 1
<a> try { </a> 0
<a> decode ( ctx , in , out ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> if ( t instanceof CodecException ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } else { </a> 0
<a> ctx . fireExceptionCaught ( new DecoderException ( t ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( oldInSize == in . readableBytes ( ) ) { </a> 0
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> in . unsafe ( ) . discardSomeReadBytes ( ) ; </a> 1
<a> if ( out . readableBytes ( ) > oldOutSize ) { </a> 1
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public abstract void decode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception ; </a> 0
<a> public void decodeLast ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception { </a> 0
<a> decode ( ctx , in , out ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 1
<a> import io . netty . channel . ChannelOutboundByteHandlerAdapter ; </a> 1
<a> public abstract class ByteToByteEncoder extends ChannelOutboundByteHandlerAdapter { </a> 1
<a> @ Override </a> 1
<a> public void flush ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> ByteBuf in = ctx . outboundByteBuffer ( ) ; </a> 0
<a> ByteBuf out = ctx . nextOutboundByteBuffer ( ) ; </a> 0
<a> int oldOutSize = out . readableBytes ( ) ; </a> 0
<a> while ( in . readable ( ) ) { </a> 0
<a> int oldInSize = in . readableBytes ( ) ; </a> 1
<a> try { </a> 0
<a> encode ( ctx , in , out ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 1
<a> if ( t instanceof CodecException ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } else { </a> 0
<a> ctx . fireExceptionCaught ( new EncoderException ( t ) ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> if ( oldInSize == in . readableBytes ( ) ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> in . unsafe ( ) . discardSomeReadBytes ( ) ; </a> 1
<a> ctx . flush ( future ) ; </a> 0
<a> } </a> 0
<a> public abstract void encode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandler ; </a> 1
<a> import io . netty . channel . ChannelOutboundMessageHandler ; </a> 1
<a> public abstract class ByteToMessageCodec < INBOUND_OUT , OUTBOUND_IN > </a> 0
<a> extends ChannelHandlerAdapter </a> 0
<a> implements ChannelInboundByteHandler , ChannelOutboundMessageHandler < OUTBOUND_IN > { </a> 0
<a> private final MessageToByteEncoder < OUTBOUND_IN > encoder = </a> 0
<a> new MessageToByteEncoder < OUTBOUND_IN > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void encode ( </a> 0
<a> ChannelHandlerContext ctx , </a> 0
<a> OUTBOUND_IN msg , ByteBuf out ) throws Exception { </a> 0
<a> ByteToMessageCodec . this . encode ( ctx , msg , out ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private final ByteToMessageDecoder < INBOUND_OUT > decoder = </a> 0
<a> new ByteToMessageDecoder < INBOUND_OUT > ( ) { </a> 0
<a> @ Override </a> 0
<a> public INBOUND_OUT decode ( </a> 0
<a> ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 0
<a> return ByteToMessageCodec . this . decode ( ctx , in ) ; </a> 1
<a> } </a> 0
<a> } ; </a> 0
<a> @ Override </a> 1
<a> public ByteBuf newInboundBuffer ( </a> 0
<a> ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return decoder . newInboundBuffer ( ctx ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> decoder . inboundBufferUpdated ( ctx ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public MessageBuf < OUTBOUND_IN > newOutboundBuffer ( </a> 0
<a> ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return encoder . newOutboundBuffer ( ctx ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void flush ( </a> 0
<a> ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> encoder . flush ( ctx , future ) ; </a> 0
<a> } </a> 1
<a> public abstract void encode ( </a> 0
<a> ChannelHandlerContext ctx , </a> 0
<a> OUTBOUND_IN msg , ByteBuf out ) throws Exception ; </a> 0
<a> public abstract INBOUND_OUT decode ( </a> 0
<a> ChannelHandlerContext ctx , ByteBuf in ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> public class CodecException extends RuntimeException { </a> 0
<a> private static final long serialVersionUID = - 1464830400709348473L ; </a> 0
<a> public CodecException ( ) { </a> 0
<a> } </a> 0
<a> public CodecException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public CodecException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public CodecException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> public class FixedLengthFrameDecoder extends ByteToMessageDecoder < Object > { </a> 0
<a> private final int frameLength ; </a> 0
<a> private final boolean allocateFullBuffer ; </a> 1
<a> public FixedLengthFrameDecoder ( int frameLength ) { </a> 1
<a> this ( frameLength , false ) ; </a> 1
<a> } </a> 1
<a> public FixedLengthFrameDecoder ( int frameLength , boolean allocateFullBuffer ) { </a> 1
<a> if ( frameLength <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "frameLength must be a positive integer: " + frameLength ) ; </a> 0
<a> } </a> 0
<a> this . frameLength = frameLength ; </a> 0
<a> this . allocateFullBuffer = allocateFullBuffer ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> if ( allocateFullBuffer ) { </a> 1
<a> return Unpooled . buffer ( frameLength ) ; </a> 1
<a> } else { </a> 1
<a> return super . newInboundBuffer ( ctx ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decode ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 0
<a> if ( in . readableBytes ( ) < frameLength ) { </a> 0
<a> return null ; </a> 0
<a> } else { </a> 0
<a> return in . readBytes ( frameLength ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . base64 ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . bytes ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . LengthFieldBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . LengthFieldPrepender ; </a> 0
<a> import io . netty . handler . codec . MessageToMessageEncoder ; </a> 0
<a> public class ByteArrayEncoder extends MessageToMessageEncoder < byte [ ] , ByteBuf > { </a> 0
<a> @ Override </a> 0
<a> public MessageBuf < byte [ ] > newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return Unpooled . messageBuffer ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof byte [ ] ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf encode ( ChannelHandlerContext ctx , byte [ ] msg ) throws Exception { </a> 0
<a> if ( msg . length == 0 ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return Unpooled . wrappedBuffer ( msg ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . bytes ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . compression ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> public class CompressionException extends RuntimeException { </a> 0
<a> private static final long serialVersionUID = 5603413481274811897L ; </a> 0
<a> public CompressionException ( ) { </a> 0
<a> } </a> 0
<a> public CompressionException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public CompressionException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public CompressionException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . compression ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . handler . codec . ByteToByteEncoder ; </a> 1
<a> public abstract class ZlibEncoder extends ByteToByteEncoder { </a> 0
<a> public abstract boolean isClosed ( ) ; </a> 0
<a> public abstract ChannelFuture close ( ) ; </a> 0
<a> public abstract ChannelFuture close ( ChannelFuture future ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import org . jboss . marshalling . Marshaller ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class DefaultMarshallerProvider implements MarshallerProvider { </a> 0
<a> private final MarshallerFactory factory ; </a> 0
<a> private final MarshallingConfiguration config ; </a> 0
<a> public DefaultMarshallerProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> this . factory = factory ; </a> 0
<a> this . config = config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Marshaller getMarshaller ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return factory . createMarshaller ( config ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . LengthFieldBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import java . io . StreamCorruptedException ; </a> 0
<a> import org . jboss . marshalling . ByteInput ; </a> 0
<a> import org . jboss . marshalling . Unmarshaller ; </a> 0
<a> public class MarshallingDecoder extends LengthFieldBasedFrameDecoder { </a> 0
<a> private final UnmarshallerProvider provider ; </a> 0
<a> public MarshallingDecoder ( UnmarshallerProvider provider ) { </a> 0
<a> this ( provider , 1048576 ) ; </a> 0
<a> } </a> 0
<a> public MarshallingDecoder ( UnmarshallerProvider provider , int maxObjectSize ) { </a> 0
<a> super ( maxObjectSize , 0 , 4 , 0 , 4 ) ; </a> 0
<a> this . provider = provider ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decode ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 0
<a> ByteBuf frame = ( ByteBuf ) super . decode ( ctx , in ) ; </a> 0
<a> if ( frame == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> Unmarshaller unmarshaller = provider . getUnmarshaller ( ctx ) ; </a> 0
<a> ByteInput input = new ChannelBufferByteInput ( frame ) ; </a> 0
<a> try { </a> 0
<a> unmarshaller . start ( input ) ; </a> 0
<a> Object obj = unmarshaller . readObject ( ) ; </a> 0
<a> unmarshaller . finish ( ) ; </a> 0
<a> return obj ; </a> 0
<a> } finally { </a> 0
<a> unmarshaller . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf extractFrame ( ByteBuf buffer , int index , int length ) { </a> 0
<a> return buffer . slice ( index , length ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import org . jboss . marshalling . Marshaller ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class ThreadLocalMarshallerProvider implements MarshallerProvider { </a> 0
<a> private final ThreadLocal < Marshaller > marshallers = new ThreadLocal < Marshaller > ( ) ; </a> 1
<a> private final MarshallerFactory factory ; </a> 0
<a> private final MarshallingConfiguration config ; </a> 0
<a> public ThreadLocalMarshallerProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> this . factory = factory ; </a> 0
<a> this . config = config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Marshaller getMarshaller ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> Marshaller marshaller = marshallers . get ( ) ; </a> 0
<a> if ( marshaller == null ) { </a> 0
<a> marshaller = factory . createMarshaller ( config ) ; </a> 0
<a> marshallers . set ( marshaller ) ; </a> 0
<a> } </a> 0
<a> return marshaller ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import java . io . EOFException ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . ObjectInputStream ; </a> 0
<a> import java . io . ObjectStreamClass ; </a> 0
<a> import java . io . StreamCorruptedException ; </a> 0
<a> class CompactObjectInputStream extends ObjectInputStream { </a> 0
<a> private final ClassResolver classResolver ; </a> 0
<a> CompactObjectInputStream ( InputStream in , ClassResolver classResolver ) throws IOException { </a> 0
<a> super ( in ) ; </a> 0
<a> this . classResolver = classResolver ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void readStreamHeader ( ) throws IOException { </a> 0
<a> int version = readByte ( ) & 0xFF ; </a> 0
<a> if ( version != STREAM_VERSION ) { </a> 0
<a> throw new StreamCorruptedException ( </a> 0
<a> "Unsupported version: " + version ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ObjectStreamClass readClassDescriptor ( ) </a> 0
<a> throws IOException , ClassNotFoundException { </a> 0
<a> int type = read ( ) ; </a> 0
<a> if ( type < 0 ) { </a> 0
<a> throw new EOFException ( ) ; </a> 0
<a> } </a> 0
<a> switch ( type ) { </a> 0
<a> case CompactObjectOutputStream . TYPE_FAT_DESCRIPTOR : </a> 0
<a> return super . readClassDescriptor ( ) ; </a> 0
<a> case CompactObjectOutputStream . TYPE_THIN_DESCRIPTOR : </a> 0
<a> String className = readUTF ( ) ; </a> 0
<a> Class < ? > clazz = classResolver . resolve ( className ) ; </a> 0
<a> return ObjectStreamClass . lookupAny ( clazz ) ; </a> 0
<a> default : </a> 0
<a> throw new StreamCorruptedException ( </a> 0
<a> "Unexpected class descriptor type: " + type ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { </a> 0
<a> Class < ? > clazz ; </a> 0
<a> try { </a> 0
<a> clazz = classResolver . resolve ( desc . getName ( ) ) ; </a> 0
<a> } catch ( ClassNotFoundException ex ) { </a> 0
<a> clazz = super . resolveClass ( desc ) ; </a> 0
<a> } </a> 0
<a> return clazz ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ByteBufInputStream ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . LengthFieldBasedFrameDecoder ; </a> 0
<a> import java . io . ObjectOutputStream ; </a> 0
<a> import java . io . StreamCorruptedException ; </a> 0
<a> public class ObjectDecoder extends LengthFieldBasedFrameDecoder { </a> 0
<a> private final ClassResolver classResolver ; </a> 0
<a> public ObjectDecoder ( ClassResolver classResolver ) { </a> 0
<a> this ( 1048576 , classResolver ) ; </a> 0
<a> } </a> 0
<a> public ObjectDecoder ( int maxObjectSize , ClassResolver classResolver ) { </a> 0
<a> super ( maxObjectSize , 0 , 4 , 0 , 4 ) ; </a> 0
<a> this . classResolver = classResolver ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decode ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 0
<a> ByteBuf frame = ( ByteBuf ) super . decode ( ctx , in ) ; </a> 0
<a> if ( frame == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return new CompactObjectInputStream ( </a> 0
<a> new ByteBufInputStream ( frame ) , classResolver ) . readObject ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf extractFrame ( ByteBuf buffer , int index , int length ) { </a> 0
<a> return buffer . slice ( index , length ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import java . lang . ref . Reference ; </a> 0
<a> import java . lang . ref . SoftReference ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class SoftReferenceMap < K , V > extends ReferenceMap < K , V > { </a> 0
<a> public SoftReferenceMap ( Map < K , Reference < V > > delegate ) { </a> 1
<a> super ( delegate ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> Reference < V > fold ( V value ) { </a> 0
<a> return new SoftReference < V > ( value ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . string ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import static org . junit . Assert . assertEquals ; </a> 0
<a> import static org . junit . Assert . assertTrue ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import io . netty . util . internal . Signal ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class ReplayingDecoderBufferTest { </a> 0
<a> @ Test </a> 0
<a> public void testGetUnsignedByte ( ) { </a> 0
<a> ReplayingDecoderBuffer buffer = new ReplayingDecoderBuffer ( Unpooled . copiedBuffer ( "TestBuffer" , CharsetUtil . ISO_8859_1 ) ) ; </a> 1
<a> boolean error ; </a> 0
<a> int i = 0 ; </a> 0
<a> try { </a> 0
<a> for ( ; ; ) { </a> 0
<a> buffer . getUnsignedByte ( i ) ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> } catch ( Signal e ) { </a> 0
<a> error = true ; </a> 0
<a> } </a> 0
<a> assertTrue ( error ) ; </a> 0
<a> assertEquals ( 10 , i ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testGetByte ( ) { </a> 0
<a> ReplayingDecoderBuffer buffer = new ReplayingDecoderBuffer ( Unpooled . copiedBuffer ( "TestBuffer" , CharsetUtil . ISO_8859_1 ) ) ; </a> 1
<a> boolean error ; </a> 0
<a> int i = 0 ; </a> 0
<a> try { </a> 0
<a> for ( ; ; ) { </a> 0
<a> buffer . getByte ( i ) ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> } catch ( Signal e ) { </a> 0
<a> error = true ; </a> 0
<a> } </a> 0
<a> assertTrue ( error ) ; </a> 0
<a> assertEquals ( 10 , i ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testGetBoolean ( ) { </a> 0
<a> ByteBuf buf = Unpooled . buffer ( 10 ) ; </a> 1
<a> while ( buf . writable ( ) ) { </a> 0
<a> buf . writeBoolean ( true ) ; </a> 0
<a> } </a> 0
<a> ReplayingDecoderBuffer buffer = new ReplayingDecoderBuffer ( buf ) ; </a> 0
<a> boolean error ; </a> 0
<a> int i = 0 ; </a> 0
<a> try { </a> 0
<a> for ( ; ; ) { </a> 0
<a> buffer . getBoolean ( i ) ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> } catch ( Signal e ) { </a> 0
<a> error = true ; </a> 0
<a> } </a> 0
<a> assertTrue ( error ) ; </a> 0
<a> assertEquals ( 10 , i ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> import junit . framework . Assert ; </a> 1
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . Marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> import org . jboss . marshalling . Unmarshaller ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public abstract class AbstractCompatibleMarshallingEncoderTest { </a> 0
<a> @ Test </a> 0
<a> public void testMarshalling ( ) throws IOException , ClassNotFoundException { </a> 1
<a> String testObject = new String ( "test" ) ; </a> 0
<a> final MarshallerFactory marshallerFactory = createMarshallerFactory ( ) ; </a> 0
<a> final MarshallingConfiguration configuration = createMarshallingConfig ( ) ; </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( createEncoder ( ) ) ; </a> 1
<a> ch . writeOutbound ( testObject ) ; </a> 0
<a> Assert . assertTrue ( ch . finish ( ) ) ; </a> 1
<a> ByteBuf buffer = ch . readOutbound ( ) ; </a> 1
<a> Unmarshaller unmarshaller = marshallerFactory . createUnmarshaller ( configuration ) ; </a> 0
<a> unmarshaller . start ( Marshalling . createByteInput ( truncate ( buffer ) . nioBuffer ( ) ) ) ; </a> 0
<a> String read = ( String ) unmarshaller . readObject ( ) ; </a> 0
<a> Assert . assertEquals ( testObject , read ) ; </a> 1
<a> Assert . assertEquals ( - 1 , unmarshaller . read ( ) ) ; </a> 1
<a> Assert . assertNull ( ch . readOutbound ( ) ) ; </a> 1
<a> unmarshaller . finish ( ) ; </a> 0
<a> unmarshaller . close ( ) ; </a> 0
<a> } </a> 0
<a> protected ByteBuf truncate ( ByteBuf buf ) { </a> 0
<a> return buf ; </a> 0
<a> } </a> 0
<a> protected ChannelHandler createEncoder ( ) { </a> 0
<a> return new CompatibleMarshallingEncoder ( createProvider ( ) ) ; </a> 0
<a> } </a> 0
<a> protected MarshallerProvider createProvider ( ) { </a> 0
<a> return new DefaultMarshallerProvider ( createMarshallerFactory ( ) , createMarshallingConfig ( ) ) ; </a> 0
<a> } </a> 0
<a> protected abstract MarshallerFactory createMarshallerFactory ( ) ; </a> 0
<a> protected abstract MarshallingConfiguration createMarshallingConfig ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> public enum InternalLogLevel { </a> 0
<a> TRACE , </a> 0
<a> DEBUG , </a> 0
<a> INFO , </a> 0
<a> WARN , </a> 0
<a> ERROR </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> public class JBossLoggerFactory extends InternalLoggerFactory { </a> 0
<a> @ Override </a> 0
<a> public InternalLogger newInstance ( String name ) { </a> 0
<a> final org . jboss . logging . Logger logger = </a> 0
<a> org . jboss . logging . Logger . getLogger ( name ) ; </a> 0
<a> return new JBossLogger ( logger ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> class Slf4JLogger extends AbstractInternalLogger { </a> 0
<a> private final Logger logger ; </a> 0
<a> Slf4JLogger ( Logger logger ) { </a> 0
<a> this . logger = logger ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg ) { </a> 0
<a> logger . trace ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg , Throwable cause ) { </a> 0
<a> logger . trace ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg ) { </a> 0
<a> logger . debug ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg , Throwable cause ) { </a> 0
<a> logger . debug ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg ) { </a> 0
<a> logger . error ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg , Throwable cause ) { </a> 0
<a> logger . error ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg ) { </a> 0
<a> logger . info ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg , Throwable cause ) { </a> 0
<a> logger . info ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isTraceEnabled ( ) { </a> 0
<a> return logger . isTraceEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDebugEnabled ( ) { </a> 0
<a> return logger . isDebugEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isErrorEnabled ( ) { </a> 0
<a> return logger . isErrorEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isInfoEnabled ( ) { </a> 0
<a> return logger . isInfoEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isWarnEnabled ( ) { </a> 0
<a> return logger . isWarnEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg ) { </a> 0
<a> logger . warn ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg , Throwable cause ) { </a> 0
<a> logger . warn ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return String . valueOf ( logger . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> public class Slf4JLoggerFactory extends InternalLoggerFactory { </a> 0
<a> @ Override </a> 0
<a> public InternalLogger newInstance ( String name ) { </a> 0
<a> final org . slf4j . Logger logger = </a> 0
<a> org . slf4j . LoggerFactory . getLogger ( name ) ; </a> 0
<a> return new Slf4JLogger ( logger ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> public interface Timeout { </a> 0
<a> Timer getTimer ( ) ; </a> 0
<a> TimerTask getTask ( ) ; </a> 0
<a> boolean isExpired ( ) ; </a> 0
<a> boolean isCancelled ( ) ; </a> 0
<a> boolean cancel ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> import java . util . concurrent . ConcurrentMap ; </a> 1
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 1
<a> public class UniqueName implements Comparable < UniqueName > { </a> 1
<a> private static final AtomicInteger nextId = new AtomicInteger ( ) ; </a> 1
<a> private final int id ; </a> 1
<a> private final String name ; </a> 1
<a> public UniqueName ( ConcurrentMap < String , Boolean > map , String name , Object ... args ) { </a> 1
<a> if ( map == null ) { </a> 1
<a> throw new NullPointerException ( "map" ) ; </a> 1
<a> } </a> 1
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> if ( args != null && args . length > 0 ) { </a> 1
<a> validateArgs ( args ) ; </a> 1
<a> } </a> 1
<a> if ( map . putIfAbsent ( name , Boolean . TRUE ) != null ) { </a> 1
<a> throw new IllegalArgumentException ( String . format ( "'%s' is already in use" , name ) ) ; </a> 1
<a> } </a> 1
<a> id = nextId . incrementAndGet ( ) ; </a> 1
<a> this . name = name ; </a> 1
<a> } </a> 1
<a> protected void validateArgs ( Object ... args ) { </a> 1
<a> } </a> 1
<a> public final String name ( ) { </a> 1
<a> return name ; </a> 1
<a> } </a> 1
<a> public final int id ( ) { </a> 1
<a> return id ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public final int hashCode ( ) { </a> 1
<a> return super . hashCode ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public final boolean equals ( Object o ) { </a> 1
<a> return super . equals ( o ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int compareTo ( UniqueName other ) { </a> 1
<a> if ( this == other ) { </a> 1
<a> return 0 ; </a> 1
<a> } </a> 1
<a> int returnCode = name . compareTo ( other . name ) ; </a> 1
<a> if ( returnCode != 0 ) { </a> 1
<a> return returnCode ; </a> 1
<a> } </a> 1
<a> return ( ( Integer ) id ) . compareTo ( ( Integer ) other . id ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String toString ( ) { </a> 1
<a> return name ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal ; </a> 0
<a> import java . util . Random ; </a> 0
<a> final class ThreadLocalRandom extends Random { </a> 0
<a> private static final long multiplier = 0x5DEECE66DL ; </a> 0
<a> private static final long addend = 0xBL ; </a> 0
<a> private static final long mask = ( 1L < < 48 ) - 1 ; </a> 0
<a> private long rnd ; </a> 0
<a> private boolean initialized ; </a> 0
<a> @ SuppressWarnings ( "unused" ) </a> 0
<a> private long pad0 , pad1 , pad2 , pad3 , pad4 , pad5 , pad6 , pad7 ; </a> 0
<a> private static final ThreadLocal < ThreadLocalRandom > localRandom = </a> 0
<a> new ThreadLocal < ThreadLocalRandom > ( ) { </a> 0
<a> @ Override </a> 0
<a> protected ThreadLocalRandom initialValue ( ) { </a> 0
<a> return new ThreadLocalRandom ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> ThreadLocalRandom ( ) { </a> 0
<a> } </a> 0
<a> static ThreadLocalRandom current ( ) { </a> 0
<a> return localRandom . get ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setSeed ( long seed ) { </a> 0
<a> if ( initialized ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> initialized = true ; </a> 0
<a> rnd = ( seed ^ multiplier ) & mask ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int next ( int bits ) { </a> 0
<a> rnd = rnd * multiplier + addend & mask ; </a> 0
<a> return ( int ) ( rnd > > > 48 - bits ) ; </a> 0
<a> } </a> 0
<a> private static final long serialVersionUID = - 5851777807851030925L ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal . jzlib ; </a> 0
<a> final class Adler32 { </a> 0
<a> private static final int BASE = 65521 ; </a> 0
<a> private static final int NMAX = 5552 ; </a> 0
<a> static long adler32 ( long adler , byte [ ] buf , int index , int len ) { </a> 0
<a> if ( buf == null ) { </a> 0
<a> return 1L ; </a> 0
<a> } </a> 0
<a> long s1 = adler & 0xffff ; </a> 0
<a> long s2 = adler > > 16 & 0xffff ; </a> 0
<a> int k ; </a> 0
<a> while ( len > 0 ) { </a> 0
<a> k = len < NMAX ? len : NMAX ; </a> 0
<a> len -= k ; </a> 0
<a> while ( k >= 16 ) { </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> k -= 16 ; </a> 0
<a> } </a> 0
<a> if ( k != 0 ) { </a> 0
<a> do { </a> 0
<a> s1 += buf [ index ++ ] & 0xff ; </a> 0
<a> s2 += s1 ; </a> 0
<a> } while ( -- k != 0 ) ; </a> 0
<a> } </a> 0
<a> s1 %= BASE ; </a> 0
<a> s2 %= BASE ; </a> 0
<a> } </a> 0
<a> return s2 < < 16 | s1 ; </a> 0
<a> } </a> 0
<a> private Adler32 ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal . jzlib ; </a> 0
<a> final class StaticTree { </a> 0
<a> static final short [ ] static_ltree = { 12 , 8 , 140 , 8 , 76 , 8 , 204 , 8 , 44 , 8 , </a> 0
<a> 172 , 8 , 108 , 8 , 236 , 8 , 28 , 8 , 156 , 8 , 92 , 8 , 220 , 8 , 60 , 8 , 188 , </a> 0
<a> 8 , 124 , 8 , 252 , 8 , 2 , 8 , 130 , 8 , 66 , 8 , 194 , 8 , 34 , 8 , 162 , 8 , 98 , </a> 0
<a> 8 , 226 , 8 , 18 , 8 , 146 , 8 , 82 , 8 , 210 , 8 , 50 , 8 , 178 , 8 , 114 , 8 , </a> 0
<a> 242 , 8 , 10 , 8 , 138 , 8 , 74 , 8 , 202 , 8 , 42 , 8 , 170 , 8 , 106 , 8 , 234 , </a> 0
<a> 8 , 26 , 8 , 154 , 8 , 90 , 8 , 218 , 8 , 58 , 8 , 186 , 8 , 122 , 8 , 250 , 8 , 6 , </a> 0
<a> 8 , 134 , 8 , 70 , 8 , 198 , 8 , 38 , 8 , 166 , 8 , 102 , 8 , 230 , 8 , 22 , 8 , </a> 0
<a> 150 , 8 , 86 , 8 , 214 , 8 , 54 , 8 , 182 , 8 , 118 , 8 , 246 , 8 , 14 , 8 , 142 , </a> 0
<a> 8 , 78 , 8 , 206 , 8 , 46 , 8 , 174 , 8 , 110 , 8 , 238 , 8 , 30 , 8 , 158 , 8 , 94 , </a> 0
<a> 8 , 222 , 8 , 62 , 8 , 190 , 8 , 126 , 8 , 254 , 8 , 1 , 8 , 129 , 8 , 65 , 8 , 193 , </a> 0
<a> 8 , 33 , 8 , 161 , 8 , 97 , 8 , 225 , 8 , 17 , 8 , 145 , 8 , 81 , 8 , 209 , 8 , 49 , </a> 0
<a> 8 , 177 , 8 , 113 , 8 , 241 , 8 , 9 , 8 , 137 , 8 , 73 , 8 , 201 , 8 , 41 , 8 , 169 , </a> 0
<a> 8 , 105 , 8 , 233 , 8 , 25 , 8 , 153 , 8 , 89 , 8 , 217 , 8 , 57 , 8 , 185 , 8 , </a> 0
<a> 121 , 8 , 249 , 8 , 5 , 8 , 133 , 8 , 69 , 8 , 197 , 8 , 37 , 8 , 165 , 8 , 101 , 8 , </a> 0
<a> 229 , 8 , 21 , 8 , 149 , 8 , 85 , 8 , 213 , 8 , 53 , 8 , 181 , 8 , 117 , 8 , 245 , </a> 0
<a> 8 , 13 , 8 , 141 , 8 , 77 , 8 , 205 , 8 , 45 , 8 , 173 , 8 , 109 , 8 , 237 , 8 , 29 , </a> 0
<a> 8 , 157 , 8 , 93 , 8 , 221 , 8 , 61 , 8 , 189 , 8 , 125 , 8 , 253 , 8 , 19 , 9 , </a> 0
<a> 275 , 9 , 147 , 9 , 403 , 9 , 83 , 9 , 339 , 9 , 211 , 9 , 467 , 9 , 51 , 9 , 307 , </a> 0
<a> 9 , 179 , 9 , 435 , 9 , 115 , 9 , 371 , 9 , 243 , 9 , 499 , 9 , 11 , 9 , 267 , 9 , </a> 0
<a> 139 , 9 , 395 , 9 , 75 , 9 , 331 , 9 , 203 , 9 , 459 , 9 , 43 , 9 , 299 , 9 , 171 , </a> 0
<a> 9 , 427 , 9 , 107 , 9 , 363 , 9 , 235 , 9 , 491 , 9 , 27 , 9 , 283 , 9 , 155 , 9 , </a> 0
<a> 411 , 9 , 91 , 9 , 347 , 9 , 219 , 9 , 475 , 9 , 59 , 9 , 315 , 9 , 187 , 9 , 443 , </a> 0
<a> 9 , 123 , 9 , 379 , 9 , 251 , 9 , 507 , 9 , 7 , 9 , 263 , 9 , 135 , 9 , 391 , 9 , </a> 0
<a> 71 , 9 , 327 , 9 , 199 , 9 , 455 , 9 , 39 , 9 , 295 , 9 , 167 , 9 , 423 , 9 , 103 , </a> 0
<a> 9 , 359 , 9 , 231 , 9 , 487 , 9 , 23 , 9 , 279 , 9 , 151 , 9 , 407 , 9 , 87 , 9 , </a> 0
<a> 343 , 9 , 215 , 9 , 471 , 9 , 55 , 9 , 311 , 9 , 183 , 9 , 439 , 9 , 119 , 9 , 375 , </a> 0
<a> 9 , 247 , 9 , 503 , 9 , 15 , 9 , 271 , 9 , 143 , 9 , 399 , 9 , 79 , 9 , 335 , 9 , </a> 0
<a> 207 , 9 , 463 , 9 , 47 , 9 , 303 , 9 , 175 , 9 , 431 , 9 , 111 , 9 , 367 , 9 , 239 , </a> 0
<a> 9 , 495 , 9 , 31 , 9 , 287 , 9 , 159 , 9 , 415 , 9 , 95 , 9 , 351 , 9 , 223 , 9 , </a> 0
<a> 479 , 9 , 63 , 9 , 319 , 9 , 191 , 9 , 447 , 9 , 127 , 9 , 383 , 9 , 255 , 9 , 511 , </a> 0
<a> 9 , 0 , 7 , 64 , 7 , 32 , 7 , 96 , 7 , 16 , 7 , 80 , 7 , 48 , 7 , 112 , 7 , 8 , 7 , </a> 0
<a> 72 , 7 , 40 , 7 , 104 , 7 , 24 , 7 , 88 , 7 , 56 , 7 , 120 , 7 , 4 , 7 , 68 , 7 , 36 , </a> 0
<a> 7 , 100 , 7 , 20 , 7 , 84 , 7 , 52 , 7 , 116 , 7 , 3 , 8 , 131 , 8 , 67 , 8 , 195 , </a> 0
<a> 8 , 35 , 8 , 163 , 8 , 99 , 8 , 227 , 8 } ; </a> 0
<a> static final short [ ] static_dtree = { 0 , 5 , 16 , 5 , 8 , 5 , 24 , 5 , 4 , 5 , 20 , </a> 0
<a> 5 , 12 , 5 , 28 , 5 , 2 , 5 , 18 , 5 , 10 , 5 , 26 , 5 , 6 , 5 , 22 , 5 , 14 , 5 , 30 , </a> 0
<a> 5 , 1 , 5 , 17 , 5 , 9 , 5 , 25 , 5 , 5 , 5 , 21 , 5 , 13 , 5 , 29 , 5 , 3 , 5 , 19 , </a> 0
<a> 5 , 11 , 5 , 27 , 5 , 7 , 5 , 23 , 5 } ; </a> 0
<a> static final StaticTree static_l_desc = new StaticTree ( static_ltree , </a> 0
<a> Tree . extra_lbits , JZlib . LITERALS + 1 , JZlib . L_CODES , JZlib . MAX_BITS ) ; </a> 0
<a> static final StaticTree static_d_desc = new StaticTree ( static_dtree , </a> 0
<a> Tree . extra_dbits , 0 , JZlib . D_CODES , JZlib . MAX_BITS ) ; </a> 0
<a> static final StaticTree static_bl_desc = new StaticTree ( null , Tree . extra_blbits , </a> 0
<a> 0 , JZlib . BL_CODES , JZlib . MAX_BL_BITS ) ; </a> 0
<a> final short [ ] static_tree ; </a> 0
<a> final int [ ] extra_bits ; </a> 0
<a> final int extra_base ; </a> 0
<a> final int elems ; </a> 0
<a> final int max_length ; </a> 0
<a> StaticTree ( short [ ] static_tree , int [ ] extra_bits , int extra_base , </a> 0
<a> int elems , int max_length ) { </a> 0
<a> this . static_tree = static_tree ; </a> 0
<a> this . extra_bits = extra_bits ; </a> 0
<a> this . extra_base = extra_base ; </a> 0
<a> this . elems = elems ; </a> 0
<a> this . max_length = max_length ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class CommonsLoggerFactoryTest { </a> 0
<a> @ Test </a> 0
<a> public void testCreation ( ) { </a> 0
<a> InternalLogger logger = new CommonsLoggerFactory ( ) . newInstance ( "foo" ) ; </a> 0
<a> assertTrue ( logger instanceof CommonsLogger ) ; </a> 0
<a> assertEquals ( "foo" , logger . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> import java . net . InetAddress ; </a> 1
<a> import java . net . UnknownHostException ; </a> 1
<a> import static org . junit . Assert . assertNotNull ; </a> 1
<a> import static org . junit . Assert . assertSame ; </a> 1
<a> import org . junit . Test ; </a> 1
<a> public class NetworkConstantsTest { </a> 0
<a> @ Test </a> 0
<a> public void testLocalhost ( ) throws UnknownHostException { </a> 1
<a> assertNotNull ( NetworkConstants . LOCALHOST ) ; </a> 0
<a> assertSame ( NetworkConstants . LOCALHOST , InetAddress . getLocalHost ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testLoopback ( ) throws UnknownHostException { </a> 1
<a> assertNotNull ( NetworkConstants . LOOPBACK_IF ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . discard ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioSocketChannel ; </a> 0
<a> public class DiscardClient { </a> 1
<a> private final String host ; </a> 1
<a> private final int port ; </a> 1
<a> private final int firstMessageSize ; </a> 1
<a> public DiscardClient ( String host , int port , int firstMessageSize ) { </a> 1
<a> this . host = host ; </a> 1
<a> this . port = port ; </a> 1
<a> this . firstMessageSize = firstMessageSize ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> Bootstrap b = new Bootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioSocketChannel ( ) ) </a> 0
<a> . remoteAddress ( host , port ) </a> 0
<a> . handler ( new DiscardClientHandler ( firstMessageSize ) ) ; </a> 1
<a> ChannelFuture f = b . connect ( ) . sync ( ) ; </a> 0
<a> f . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 1
<a> b . shutdown ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> if ( args . length < 2 || args . length > 3 ) { </a> 0
<a> System . err . println ( </a> 0
<a> "Usage: " + DiscardClient . class . getSimpleName ( ) + </a> 0
<a> " <host> <port> [<first message size>]" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> final String host = args [ 0 ] ; </a> 0
<a> final int port = Integer . parseInt ( args [ 1 ] ) ; </a> 0
<a> final int firstMessageSize ; </a> 0
<a> if ( args . length == 3 ) { </a> 0
<a> firstMessageSize = Integer . parseInt ( args [ 2 ] ) ; </a> 0
<a> } else { </a> 0
<a> firstMessageSize = 256 ; </a> 0
<a> } </a> 0
<a> new DiscardClient ( host , port , firstMessageSize ) . run ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . discard ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 1
<a> import java . util . logging . Level ; </a> 1
<a> import java . util . logging . Logger ; </a> 1
<a> public class DiscardClientHandler extends ChannelInboundByteHandlerAdapter { </a> 1
<a> private static final Logger logger = Logger . getLogger ( </a> 1
<a> DiscardClientHandler . class . getName ( ) ) ; </a> 1
<a> private final byte [ ] content ; </a> 0
<a> private ChannelHandlerContext ctx ; </a> 0
<a> public DiscardClientHandler ( int messageSize ) { </a> 1
<a> if ( messageSize <= 0 ) { </a> 1
<a> throw new IllegalArgumentException ( </a> 1
<a> "messageSize: " + messageSize ) ; </a> 1
<a> } </a> 1
<a> content = new byte [ messageSize ] ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) </a> 1
<a> throws Exception { </a> 1
<a> this . ctx = ctx ; </a> 0
<a> generateTraffic ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) </a> 1
<a> throws Exception { </a> 1
<a> in . clear ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , </a> 1
<a> Throwable cause ) throws Exception { </a> 1
<a> logger . log ( </a> 1
<a> Level . WARNING , </a> 1
<a> "Unexpected exception from downstream." , </a> 1
<a> cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> long counter ; </a> 0
<a> private void generateTraffic ( ) { </a> 0
<a> ByteBuf out = ctx . nextOutboundByteBuffer ( ) ; </a> 1
<a> while ( out . readableBytes ( ) < 65536 ) { </a> 1
<a> out . writeBytes ( content ) ; </a> 0
<a> } </a> 0
<a> ctx . flush ( ) . addListener ( GENERATE_TRAFFIC ) ; </a> 1
<a> } </a> 1
<a> private final ChannelFutureListener GENERATE_TRAFFIC = new ChannelFutureListener ( ) { </a> 1
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 1
<a> if ( future . isSuccess ( ) ) { </a> 0
<a> ctx . nextOutboundByteBuffer ( ) . discardReadBytes ( ) ; </a> 0
<a> generateTraffic ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . echo ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelOption ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioSocketChannel ; </a> 0
<a> import io . netty . handler . logging . LogLevel ; </a> 1
<a> import io . netty . handler . logging . LoggingHandler ; </a> 1
<a> import java . net . InetSocketAddress ; </a> 0
<a> public class EchoClient { </a> 1
<a> private final String host ; </a> 1
<a> private final int port ; </a> 1
<a> private final int firstMessageSize ; </a> 1
<a> public EchoClient ( String host , int port , int firstMessageSize ) { </a> 1
<a> this . host = host ; </a> 1
<a> this . port = port ; </a> 1
<a> this . firstMessageSize = firstMessageSize ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> Bootstrap b = new Bootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioSocketChannel ( ) ) </a> 0
<a> . option ( ChannelOption . TCP_NODELAY , true ) </a> 0
<a> . remoteAddress ( new InetSocketAddress ( host , port ) ) </a> 1
<a> . handler ( new ChannelInitializer < SocketChannel > ( ) { </a> 1
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 0
<a> ch . pipeline ( ) . addLast ( </a> 1
<a> new LoggingHandler ( LogLevel . INFO ) , </a> 1
<a> new EchoClientHandler ( firstMessageSize ) ) ; </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> ChannelFuture f = b . connect ( ) . sync ( ) ; </a> 0
<a> f . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> if ( args . length < 2 || args . length > 3 ) { </a> 0
<a> System . err . println ( </a> 0
<a> "Usage: " + EchoClient . class . getSimpleName ( ) + </a> 0
<a> " <host> <port> [<first message size>]" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> final String host = args [ 0 ] ; </a> 0
<a> final int port = Integer . parseInt ( args [ 1 ] ) ; </a> 0
<a> final int firstMessageSize ; </a> 0
<a> if ( args . length == 3 ) { </a> 0
<a> firstMessageSize = Integer . parseInt ( args [ 2 ] ) ; </a> 0
<a> } else { </a> 0
<a> firstMessageSize = 256 ; </a> 0
<a> } </a> 0
<a> new EchoClient ( host , port , firstMessageSize ) . run ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . factorial ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . ByteToMessageDecoder ; </a> 0
<a> import io . netty . handler . codec . CorruptedFrameException ; </a> 0
<a> import java . math . BigInteger ; </a> 0
<a> public class BigIntegerDecoder extends ByteToMessageDecoder < BigInteger > { </a> 0
<a> @ Override </a> 0
<a> public BigInteger decode ( ChannelHandlerContext ctx , ByteBuf in ) { </a> 0
<a> if ( in . readableBytes ( ) < 5 ) { </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> in . markReaderIndex ( ) ; </a> 0
<a> int magicNumber = in . readUnsignedByte ( ) ; </a> 0
<a> if ( magicNumber != 'F' ) { </a> 0
<a> in . resetReaderIndex ( ) ; </a> 0
<a> throw new CorruptedFrameException ( </a> 1
<a> "Invalid magic number: " + magicNumber ) ; </a> 1
<a> } </a> 0
<a> int dataLength = in . readInt ( ) ; </a> 0
<a> if ( in . readableBytes ( ) < dataLength ) { </a> 0
<a> in . resetReaderIndex ( ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> byte [ ] decoded = new byte [ dataLength ] ; </a> 0
<a> in . readBytes ( decoded ) ; </a> 0
<a> return new BigInteger ( decoded ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . factorial ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import java . math . BigInteger ; </a> 0
<a> import java . util . concurrent . BlockingQueue ; </a> 0
<a> import java . util . concurrent . LinkedBlockingQueue ; </a> 0
<a> import java . util . logging . Level ; </a> 1
<a> import java . util . logging . Logger ; </a> 1
<a> public class FactorialClientHandler extends ChannelInboundMessageHandlerAdapter < BigInteger > { </a> 1
<a> private static final Logger logger = Logger . getLogger ( </a> 1
<a> FactorialClientHandler . class . getName ( ) ) ; </a> 1
<a> private ChannelHandlerContext ctx ; </a> 0
<a> private int i = 1 ; </a> 0
<a> private int receivedMessages ; </a> 0
<a> private final int count ; </a> 1
<a> final BlockingQueue < BigInteger > answer = new LinkedBlockingQueue < BigInteger > ( ) ; </a> 0
<a> public FactorialClientHandler ( int count ) { </a> 1
<a> this . count = count ; </a> 1
<a> } </a> 1
<a> public BigInteger getFactorial ( ) { </a> 0
<a> boolean interrupted = false ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> try { </a> 0
<a> BigInteger factorial = answer . take ( ) ; </a> 1
<a> if ( interrupted ) { </a> 0
<a> Thread . currentThread ( ) . interrupt ( ) ; </a> 0
<a> } </a> 0
<a> return factorial ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> interrupted = true ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) { </a> 0
<a> this . ctx = ctx ; </a> 0
<a> sendNumbers ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( </a> 0
<a> ChannelHandlerContext ctx , final BigInteger msg ) { </a> 0
<a> receivedMessages ++ ; </a> 0
<a> if ( receivedMessages == count ) { </a> 1
<a> ctx . channel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) { </a> 0
<a> boolean offered = answer . offer ( msg ) ; </a> 0
<a> assert offered ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( </a> 1
<a> ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> logger . log ( </a> 1
<a> Level . WARNING , </a> 1
<a> "Unexpected exception from downstream." , cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> private void sendNumbers ( ) { </a> 0
<a> boolean finished = false ; </a> 0
<a> MessageBuf < Object > out = ctx . nextOutboundMessageBuffer ( ) ; </a> 1
<a> while ( out . size ( ) < 4096 ) { </a> 0
<a> if ( i <= count ) { </a> 1
<a> out . add ( Integer . valueOf ( i ) ) ; </a> 0
<a> i ++ ; </a> 1
<a> } else { </a> 1
<a> finished = true ; </a> 0
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> ChannelFuture f = ctx . flush ( ) ; </a> 1
<a> if ( ! finished ) { </a> 0
<a> f . addListener ( SEND_NUMBERS ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private final ChannelFutureListener SEND_NUMBERS = new ChannelFutureListener ( ) { </a> 1
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 0
<a> if ( future . isSuccess ( ) ) { </a> 0
<a> sendNumbers ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . factorial ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . MessageToByteEncoder ; </a> 0
<a> import java . math . BigInteger ; </a> 0
<a> public class NumberEncoder extends MessageToByteEncoder < Number > { </a> 0
<a> @ Override </a> 0
<a> public void encode ( </a> 0
<a> ChannelHandlerContext ctx , Number msg , ByteBuf out ) throws Exception { </a> 0
<a> BigInteger v ; </a> 0
<a> if ( msg instanceof BigInteger ) { </a> 0
<a> v = ( BigInteger ) msg ; </a> 0
<a> } else { </a> 0
<a> v = new BigInteger ( String . valueOf ( msg ) ) ; </a> 0
<a> } </a> 0
<a> byte [ ] data = v . toByteArray ( ) ; </a> 0
<a> int dataLength = data . length ; </a> 0
<a> out . writeByte ( ( byte ) 'F' ) ; </a> 0
<a> out . writeInt ( dataLength ) ; </a> 0
<a> out . writeBytes ( data ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . file ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> public class HttpStaticFileServer { </a> 1
<a> private final int port ; </a> 1
<a> public HttpStaticFileServer ( int port ) { </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 0
<a> public void run ( ) throws Exception { </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . localAddress ( port ) </a> 0
<a> . childHandler ( new HttpStaticFileServerInitializer ( ) ) ; </a> 1
<a> b . bind ( ) . sync ( ) . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8080 ; </a> 1
<a> } </a> 1
<a> new HttpStaticFileServer ( port ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . snoop ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . example . securechat . SecureChatSslContextFactory ; </a> 0
<a> import io . netty . handler . codec . http . HttpClientCodec ; </a> 0
<a> import io . netty . handler . codec . http . HttpContentDecompressor ; </a> 0
<a> import io . netty . handler . logging . LogLevel ; </a> 1
<a> import io . netty . handler . logging . LoggingHandler ; </a> 1
<a> import javax . net . ssl . SSLEngine ; </a> 0
<a> public class HttpSnoopClientInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> private final boolean ssl ; </a> 0
<a> public HttpSnoopClientInitializer ( boolean ssl ) { </a> 0
<a> this . ssl = ssl ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 1
<a> ChannelPipeline p = ch . pipeline ( ) ; </a> 0
<a> p . addLast ( "log" , new LoggingHandler ( LogLevel . INFO ) ) ; </a> 1
<a> if ( ssl ) { </a> 0
<a> SSLEngine engine = </a> 0
<a> SecureChatSslContextFactory . getClientContext ( ) . createSSLEngine ( ) ; </a> 0
<a> engine . setUseClientMode ( true ) ; </a> 0
<a> } </a> 0
<a> p . addLast ( "codec" , new HttpClientCodec ( ) ) ; </a> 1
<a> p . addLast ( "inflater" , new HttpContentDecompressor ( ) ) ; </a> 1
<a> p . addLast ( "handler" , new HttpSnoopClientHandler ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . snoop ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> public class HttpSnoopServer { </a> 1
<a> private final int port ; </a> 1
<a> public HttpSnoopServer ( int port ) { </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 0
<a> public void run ( ) throws Exception { </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . childHandler ( new HttpSnoopServerInitializer ( ) ) </a> 0
<a> . localAddress ( new InetSocketAddress ( port ) ) ; </a> 0
<a> Channel ch = b . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> ch . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8080 ; </a> 1
<a> } </a> 1
<a> new HttpSnoopServer ( port ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . autobahn ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpMethod . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpResponseStatus . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpVersion . * ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . handler . codec . http . DefaultHttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . BinaryWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . CloseWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . ContinuationWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . PingWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . PongWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . TextWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . WebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . WebSocketServerHandshaker ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . WebSocketServerHandshakerFactory ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class AutobahnServerHandler extends ChannelInboundMessageHandlerAdapter < Object > { </a> 1
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( AutobahnServerHandler . class ) ; </a> 0
<a> private WebSocketServerHandshaker handshaker ; </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 1
<a> if ( msg instanceof HttpRequest ) { </a> 0
<a> handleHttpRequest ( ctx , ( HttpRequest ) msg ) ; </a> 0
<a> } else if ( msg instanceof WebSocketFrame ) { </a> 0
<a> handleWebSocketFrame ( ctx , ( WebSocketFrame ) msg ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void handleHttpRequest ( ChannelHandlerContext ctx , HttpRequest req ) throws Exception { </a> 0
<a> if ( req . getMethod ( ) != GET ) { </a> 0
<a> sendHttpResponse ( ctx , req , new DefaultHttpResponse ( HTTP_1_1 , FORBIDDEN ) ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory ( </a> 0
<a> getWebSocketLocation ( req ) , null , false , Integer . MAX_VALUE ) ; </a> 0
<a> handshaker = wsFactory . newHandshaker ( req ) ; </a> 0
<a> if ( handshaker == null ) { </a> 0
<a> wsFactory . sendUnsupportedWebSocketVersionResponse ( ctx . channel ( ) ) ; </a> 0
<a> } else { </a> 0
<a> handshaker . handshake ( ctx . channel ( ) , req ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void handleWebSocketFrame ( ChannelHandlerContext ctx , WebSocketFrame frame ) { </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( String . format ( "Channel %s received %s" , ctx . channel ( ) . id ( ) , frame . getClass ( ) </a> 0
<a> . getSimpleName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> if ( frame instanceof CloseWebSocketFrame ) { </a> 0
<a> handshaker . close ( ctx . channel ( ) , ( CloseWebSocketFrame ) frame ) ; </a> 0
<a> } else if ( frame instanceof PingWebSocketFrame ) { </a> 0
<a> ctx . channel ( ) . write ( </a> 0
<a> new PongWebSocketFrame ( frame . isFinalFragment ( ) , frame . getRsv ( ) , frame . getBinaryData ( ) ) ) ; </a> 0
<a> } else if ( frame instanceof TextWebSocketFrame ) { </a> 0
<a> ctx . channel ( ) . write ( </a> 0
<a> new TextWebSocketFrame ( frame . isFinalFragment ( ) , frame . getRsv ( ) , frame . getBinaryData ( ) ) ) ; </a> 0
<a> } else if ( frame instanceof BinaryWebSocketFrame ) { </a> 0
<a> ctx . channel ( ) . write ( </a> 0
<a> new BinaryWebSocketFrame ( frame . isFinalFragment ( ) , frame . getRsv ( ) , frame . getBinaryData ( ) ) ) ; </a> 0
<a> } else if ( frame instanceof ContinuationWebSocketFrame ) { </a> 0
<a> ctx . channel ( ) . write ( </a> 0
<a> new ContinuationWebSocketFrame ( frame . isFinalFragment ( ) , frame . getRsv ( ) , frame . getBinaryData ( ) ) ) ; </a> 0
<a> } else if ( frame instanceof PongWebSocketFrame ) { </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( String . format ( "%s frame types not supported" , frame . getClass ( ) </a> 0
<a> . getName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void sendHttpResponse ( ChannelHandlerContext ctx , HttpRequest req , HttpResponse res ) { </a> 1
<a> if ( res . getStatus ( ) . getCode ( ) != 200 ) { </a> 0
<a> res . setContent ( Unpooled . copiedBuffer ( res . getStatus ( ) . toString ( ) , CharsetUtil . UTF_8 ) ) ; </a> 1
<a> setContentLength ( res , res . getContent ( ) . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> ChannelFuture f = ctx . channel ( ) . write ( res ) ; </a> 0
<a> if ( ! isKeepAlive ( req ) || res . getStatus ( ) . getCode ( ) != 200 ) { </a> 0
<a> f . addListener ( ChannelFutureListener . CLOSE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> cause . printStackTrace ( ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> private static String getWebSocketLocation ( HttpRequest req ) { </a> 1
<a> return "ws://" + req . getHeader ( HttpHeaders . Names . HOST ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . autobahn ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . http . HttpChunkAggregator ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequestDecoder ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseEncoder ; </a> 0
<a> public class AutobahnServerInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 0
<a> ChannelPipeline pipeline = ch . pipeline ( ) ; </a> 0
<a> pipeline . addLast ( "decoder" , new HttpRequestDecoder ( ) ) ; </a> 0
<a> pipeline . addLast ( "aggregator" , new HttpChunkAggregator ( 65536 ) ) ; </a> 0
<a> pipeline . addLast ( "encoder" , new HttpResponseEncoder ( ) ) ; </a> 0
<a> pipeline . addLast ( "handler" , new AutobahnServerHandler ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . client ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 1
<a> import io . netty . handler . codec . http . websocketx . CloseWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . PongWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . TextWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . WebSocketClientHandshaker ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . WebSocketFrame ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class WebSocketClientHandler extends ChannelInboundMessageHandlerAdapter < Object > { </a> 1
<a> private final WebSocketClientHandshaker handshaker ; </a> 0
<a> public WebSocketClientHandler ( WebSocketClientHandshaker handshaker ) { </a> 0
<a> this . handshaker = handshaker ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> System . out . println ( "WebSocket Client disconnected!" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 1
<a> Channel ch = ctx . channel ( ) ; </a> 0
<a> if ( ! handshaker . isHandshakeComplete ( ) ) { </a> 0
<a> handshaker . finishHandshake ( ch , ( HttpResponse ) msg ) ; </a> 1
<a> System . out . println ( "WebSocket Client connected!" ) ; </a> 0
<a> return ; </a> 1
<a> } </a> 0
<a> if ( msg instanceof HttpResponse ) { </a> 1
<a> HttpResponse response = ( HttpResponse ) msg ; </a> 1
<a> throw new Exception ( "Unexpected HttpResponse (status=" + response . getStatus ( ) + ", content=" </a> 1
<a> + response . getContent ( ) . toString ( CharsetUtil . UTF_8 ) + ")" ) ; </a> 0
<a> } </a> 0
<a> WebSocketFrame frame = ( WebSocketFrame ) msg ; </a> 0
<a> if ( frame instanceof TextWebSocketFrame ) { </a> 0
<a> TextWebSocketFrame textFrame = ( TextWebSocketFrame ) frame ; </a> 0
<a> System . out . println ( "WebSocket Client received message: " + textFrame . getText ( ) ) ; </a> 0
<a> } else if ( frame instanceof PongWebSocketFrame ) { </a> 0
<a> System . out . println ( "WebSocket Client received pong" ) ; </a> 0
<a> } else if ( frame instanceof CloseWebSocketFrame ) { </a> 0
<a> System . out . println ( "WebSocket Client received closing" ) ; </a> 0
<a> ch . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> cause . printStackTrace ( ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . client ; </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . sslserver ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . Names . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpMethod . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpResponseStatus . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpVersion . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . example . http . websocketx . server . WebSocketServerIndexPage ; </a> 1
<a> import io . netty . handler . codec . http . DefaultHttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . CloseWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . PingWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . PongWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . TextWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . WebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . WebSocketServerHandshaker ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . WebSocketServerHandshakerFactory ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class WebSocketSslServerHandler extends ChannelInboundMessageHandlerAdapter < Object > { </a> 1
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocketSslServerHandler . class ) ; </a> 0
<a> private static final String WEBSOCKET_PATH = "/websocket" ; </a> 0
<a> private WebSocketServerHandshaker handshaker ; </a> 1
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 1
<a> if ( msg instanceof HttpRequest ) { </a> 0
<a> handleHttpRequest ( ctx , ( HttpRequest ) msg ) ; </a> 0
<a> } else if ( msg instanceof WebSocketFrame ) { </a> 0
<a> handleWebSocketFrame ( ctx , ( WebSocketFrame ) msg ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void handleHttpRequest ( ChannelHandlerContext ctx , HttpRequest req ) throws Exception { </a> 0
<a> if ( req . getMethod ( ) != GET ) { </a> 0
<a> sendHttpResponse ( ctx , req , new DefaultHttpResponse ( HTTP_1_1 , FORBIDDEN ) ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( req . getUri ( ) . equals ( "/" ) ) { </a> 0
<a> HttpResponse res = new DefaultHttpResponse ( HTTP_1_1 , OK ) ; </a> 0
<a> ByteBuf content = WebSocketServerIndexPage . getContent ( getWebSocketLocation ( req ) ) ; </a> 1
<a> res . setHeader ( CONTENT_TYPE , "text/html; charset=UTF-8" ) ; </a> 0
<a> setContentLength ( res , content . readableBytes ( ) ) ; </a> 0
<a> res . setContent ( content ) ; </a> 0
<a> sendHttpResponse ( ctx , req , res ) ; </a> 0
<a> return ; </a> 0
<a> } else if ( req . getUri ( ) . equals ( "/favicon.ico" ) ) { </a> 0
<a> HttpResponse res = new DefaultHttpResponse ( HTTP_1_1 , NOT_FOUND ) ; </a> 0
<a> sendHttpResponse ( ctx , req , res ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory ( </a> 0
<a> getWebSocketLocation ( req ) , null , false ) ; </a> 1
<a> handshaker = wsFactory . newHandshaker ( req ) ; </a> 1
<a> if ( handshaker == null ) { </a> 1
<a> wsFactory . sendUnsupportedWebSocketVersionResponse ( ctx . channel ( ) ) ; </a> 0
<a> } else { </a> 0
<a> handshaker . handshake ( ctx . channel ( ) , req ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private void handleWebSocketFrame ( ChannelHandlerContext ctx , WebSocketFrame frame ) { </a> 0
<a> if ( frame instanceof CloseWebSocketFrame ) { </a> 0
<a> handshaker . close ( ctx . channel ( ) , ( CloseWebSocketFrame ) frame ) ; </a> 1
<a> return ; </a> 0
<a> } else if ( frame instanceof PingWebSocketFrame ) { </a> 0
<a> ctx . channel ( ) . write ( new PongWebSocketFrame ( frame . getBinaryData ( ) ) ) ; </a> 0
<a> return ; </a> 0
<a> } else if ( ! ( frame instanceof TextWebSocketFrame ) ) { </a> 0
<a> throw new UnsupportedOperationException ( String . format ( "%s frame types not supported" , frame . getClass ( ) </a> 0
<a> . getName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> String request = ( ( TextWebSocketFrame ) frame ) . getText ( ) ; </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( String . format ( "Channel %s received %s" , ctx . channel ( ) . id ( ) , request ) ) ; </a> 0
<a> } </a> 1
<a> ctx . channel ( ) . write ( new TextWebSocketFrame ( request . toUpperCase ( ) ) ) ; </a> 1
<a> } </a> 0
<a> private static void sendHttpResponse ( ChannelHandlerContext ctx , HttpRequest req , HttpResponse res ) { </a> 1
<a> if ( res . getStatus ( ) . getCode ( ) != 200 ) { </a> 0
<a> res . setContent ( Unpooled . copiedBuffer ( res . getStatus ( ) . toString ( ) , CharsetUtil . UTF_8 ) ) ; </a> 1
<a> setContentLength ( res , res . getContent ( ) . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> ChannelFuture f = ctx . channel ( ) . write ( res ) ; </a> 0
<a> if ( ! isKeepAlive ( req ) || res . getStatus ( ) . getCode ( ) != 200 ) { </a> 0
<a> f . addListener ( ChannelFutureListener . CLOSE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> cause . printStackTrace ( ) ; </a> 1
<a> ctx . close ( ) ; </a> 1
<a> } </a> 0
<a> private static String getWebSocketLocation ( HttpRequest req ) { </a> 1
<a> return "wss://" + req . getHeader ( HttpHeaders . Names . HOST ) + WEBSOCKET_PATH ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . objectecho ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioSocketChannel ; </a> 0
<a> import io . netty . example . echo . EchoClient ; </a> 0
<a> import io . netty . handler . codec . serialization . ClassResolvers ; </a> 0
<a> import io . netty . handler . codec . serialization . ObjectDecoder ; </a> 0
<a> import io . netty . handler . codec . serialization . ObjectEncoder ; </a> 0
<a> public class ObjectEchoClient { </a> 1
<a> private final String host ; </a> 0
<a> private final int port ; </a> 0
<a> private final int firstMessageSize ; </a> 0
<a> public ObjectEchoClient ( String host , int port , int firstMessageSize ) { </a> 1
<a> this . host = host ; </a> 0
<a> this . port = port ; </a> 0
<a> this . firstMessageSize = firstMessageSize ; </a> 0
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> Bootstrap b = new Bootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioSocketChannel ( ) ) </a> 0
<a> . remoteAddress ( host , port ) </a> 0
<a> . handler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 0
<a> ch . pipeline ( ) . addLast ( </a> 1
<a> new ObjectEncoder ( ) , </a> 0
<a> new ObjectDecoder ( ClassResolvers . cacheDisabled ( null ) ) , </a> 0
<a> new ObjectEchoClientHandler ( firstMessageSize ) ) ; </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> b . connect ( ) . sync ( ) . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> if ( args . length < 2 || args . length > 3 ) { </a> 0
<a> System . err . println ( </a> 0
<a> "Usage: " + ObjectEchoClient . class . getSimpleName ( ) + </a> 0
<a> " <host> <port> [<first message size>]" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> final String host = args [ 0 ] ; </a> 0
<a> final int port = Integer . parseInt ( args [ 1 ] ) ; </a> 0
<a> final int firstMessageSize ; </a> 0
<a> if ( args . length == 3 ) { </a> 0
<a> firstMessageSize = Integer . parseInt ( args [ 2 ] ) ; </a> 0
<a> } else { </a> 0
<a> firstMessageSize = 256 ; </a> 0
<a> } </a> 0
<a> new ObjectEchoClient ( host , port , firstMessageSize ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . proxy ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 1
<a> import io . netty . channel . socket . nio . NioSocketChannel ; </a> 0
<a> public class HexDumpProxyFrontendHandler extends ChannelInboundByteHandlerAdapter { </a> 1
<a> private final String remoteHost ; </a> 0
<a> private final int remotePort ; </a> 0
<a> private volatile Channel outboundChannel ; </a> 0
<a> public HexDumpProxyFrontendHandler ( String remoteHost , int remotePort ) { </a> 0
<a> this . remoteHost = remoteHost ; </a> 0
<a> this . remotePort = remotePort ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> final Channel inboundChannel = ctx . channel ( ) ; </a> 0
<a> Bootstrap b = new Bootstrap ( ) ; </a> 0
<a> b . group ( inboundChannel . eventLoop ( ) ) </a> 0
<a> . channel ( new NioSocketChannel ( ) ) </a> 0
<a> . remoteAddress ( remoteHost , remotePort ) </a> 0
<a> . handler ( new HexDumpProxyBackendHandler ( inboundChannel ) ) ; </a> 0
<a> ChannelFuture f = b . connect ( ) ; </a> 0
<a> outboundChannel = f . channel ( ) ; </a> 0
<a> f . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 1
<a> if ( future . isSuccess ( ) ) { </a> 0
<a> } else { </a> 0
<a> inboundChannel . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 0
<a> ByteBuf out = outboundChannel . outboundByteBuffer ( ) ; </a> 1
<a> out . discardReadBytes ( ) ; </a> 0
<a> out . writeBytes ( in ) ; </a> 1
<a> in . clear ( ) ; </a> 0
<a> if ( outboundChannel . isActive ( ) ) { </a> 0
<a> outboundChannel . flush ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> if ( outboundChannel != null ) { </a> 0
<a> closeOnFlush ( outboundChannel ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> cause . printStackTrace ( ) ; </a> 0
<a> closeOnFlush ( ctx . channel ( ) ) ; </a> 0
<a> } </a> 0
<a> static void closeOnFlush ( Channel ch ) { </a> 0
<a> if ( ch . isActive ( ) ) { </a> 0
<a> ch . flush ( ) . addListener ( ChannelFutureListener . CLOSE ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . proxy ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . logging . LogLevel ; </a> 0
<a> import io . netty . handler . logging . LoggingHandler ; </a> 0
<a> public class HexDumpProxyInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> private final String remoteHost ; </a> 0
<a> private final int remotePort ; </a> 0
<a> public HexDumpProxyInitializer ( String remoteHost , int remotePort ) { </a> 0
<a> this . remoteHost = remoteHost ; </a> 0
<a> this . remotePort = remotePort ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 1
<a> ch . pipeline ( ) . addLast ( </a> 0
<a> new LoggingHandler ( LogLevel . INFO ) , </a> 0
<a> new HexDumpProxyFrontendHandler ( remoteHost , remotePort ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . securechat ; </a> 0
<a> import java . io . ByteArrayInputStream ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> public final class SecureChatKeyStore { </a> 0
<a> private static final short [ ] DATA = { </a> 0
<a> 0xfe , 0xed , 0xfe , 0xed , 0x00 , 0x00 , 0x00 , 0x02 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x02 , 0x00 , 0x00 , 0x00 , 0x01 , </a> 0
<a> 0x00 , 0x07 , 0x65 , 0x78 , 0x61 , 0x6d , 0x70 , 0x6c , </a> 0
<a> 0x65 , 0x00 , 0x00 , 0x01 , 0x1a , 0x9f , 0x57 , 0xa5 , </a> 0
<a> 0x27 , 0x00 , 0x00 , 0x01 , 0x9a , 0x30 , 0x82 , 0x01 , </a> 0
<a> 0x96 , 0x30 , 0x0e , 0x06 , 0x0a , 0x2b , 0x06 , 0x01 , </a> 0
<a> 0x04 , 0x01 , 0x2a , 0x02 , 0x11 , 0x01 , 0x01 , 0x05 , </a> 0
<a> 0x00 , 0x04 , 0x82 , 0x01 , 0x82 , 0x48 , 0x6d , 0xcf , </a> 0
<a> 0x16 , 0xb5 , 0x50 , 0x95 , 0x36 , 0xbf , 0x47 , 0x27 , </a> 0
<a> 0x50 , 0x58 , 0x0d , 0xa2 , 0x52 , 0x7e , 0x25 , 0xab , </a> 0
<a> 0x14 , 0x1a , 0x26 , 0x5e , 0x2d , 0x8a , 0x23 , 0x90 , </a> 0
<a> 0x60 , 0x7f , 0x12 , 0x20 , 0x56 , 0xd1 , 0x43 , 0xa2 , </a> 0
<a> 0x6b , 0x47 , 0x5d , 0xed , 0x9d , 0xd4 , 0xe5 , 0x83 , </a> 0
<a> 0x28 , 0x89 , 0xc2 , 0x16 , 0x4c , 0x76 , 0x06 , 0xad , </a> 0
<a> 0x8e , 0x8c , 0x29 , 0x1a , 0x9b , 0x0f , 0xdd , 0x60 , </a> 0
<a> 0x4b , 0xb4 , 0x62 , 0x82 , 0x9e , 0x4a , 0x63 , 0x83 , </a> 0
<a> 0x2e , 0xd2 , 0x43 , 0x78 , 0xc2 , 0x32 , 0x1f , 0x60 , </a> 0
<a> 0xa9 , 0x8a , 0x7f , 0x0f , 0x7c , 0xa6 , 0x1d , 0xe6 , </a> 0
<a> 0x92 , 0x9e , 0x52 , 0xc7 , 0x7d , 0xbb , 0x35 , 0x3b , </a> 0
<a> 0xaa , 0x89 , 0x73 , 0x4c , 0xfb , 0x99 , 0x54 , 0x97 , </a> 0
<a> 0x99 , 0x28 , 0x6e , 0x66 , 0x5b , 0xf7 , 0x9b , 0x7e , </a> 0
<a> 0x6d , 0x8a , 0x2f , 0xfa , 0xc3 , 0x1e , 0x71 , 0xb9 , </a> 0
<a> 0xbd , 0x8f , 0xc5 , 0x63 , 0x25 , 0x31 , 0x20 , 0x02 , </a> 0
<a> 0xff , 0x02 , 0xf0 , 0xc9 , 0x2c , 0xdd , 0x3a , 0x10 , </a> 0
<a> 0x30 , 0xab , 0xe5 , 0xad , 0x3d , 0x1a , 0x82 , 0x77 , </a> 0
<a> 0x46 , 0xed , 0x03 , 0x38 , 0xa4 , 0x73 , 0x6d , 0x36 , </a> 0
<a> 0x36 , 0x33 , 0x70 , 0xb2 , 0x63 , 0x20 , 0xca , 0x03 , </a> 0
<a> 0xbf , 0x5a , 0xf4 , 0x7c , 0x35 , 0xf0 , 0x63 , 0x1a , </a> 0
<a> 0x12 , 0x33 , 0x12 , 0x58 , 0xd9 , 0xa2 , 0x63 , 0x6b , </a> 0
<a> 0x63 , 0x82 , 0x41 , 0x65 , 0x70 , 0x37 , 0x4b , 0x99 , </a> 0
<a> 0x04 , 0x9f , 0xdd , 0x5e , 0x07 , 0x01 , 0x95 , 0x9f , </a> 0
<a> 0x36 , 0xe8 , 0xc3 , 0x66 , 0x2a , 0x21 , 0x69 , 0x68 , </a> 0
<a> 0x40 , 0xe6 , 0xbc , 0xbb , 0x85 , 0x81 , 0x21 , 0x13 , </a> 0
<a> 0xe6 , 0xa4 , 0xcf , 0xd3 , 0x67 , 0xe3 , 0xfd , 0x75 , </a> 0
<a> 0xf0 , 0xdf , 0x83 , 0xe0 , 0xc5 , 0x36 , 0x09 , 0xac , </a> 0
<a> 0x1b , 0xd4 , 0xf7 , 0x2a , 0x23 , 0x57 , 0x1c , 0x5c , </a> 0
<a> 0x0f , 0xf4 , 0xcf , 0xa2 , 0xcf , 0xf5 , 0xbd , 0x9c , </a> 0
<a> 0x69 , 0x98 , 0x78 , 0x3a , 0x25 , 0xe4 , 0xfd , 0x85 , </a> 0
<a> 0x11 , 0xcc , 0x7d , 0xef , 0xeb , 0x74 , 0x60 , 0xb1 , </a> 0
<a> 0xb7 , 0xfb , 0x1f , 0x0e , 0x62 , 0xff , 0xfe , 0x09 , </a> 0
<a> 0x0a , 0xc3 , 0x80 , 0x2f , 0x10 , 0x49 , 0x89 , 0x78 , </a> 0
<a> 0xd2 , 0x08 , 0xfa , 0x89 , 0x22 , 0x45 , 0x91 , 0x21 , </a> 0
<a> 0xbc , 0x90 , 0x3e , 0xad , 0xb3 , 0x0a , 0xb4 , 0x0e , </a> 0
<a> 0x1c , 0xa1 , 0x93 , 0x92 , 0xd8 , 0x72 , 0x07 , 0x54 , </a> 0
<a> 0x60 , 0xe7 , 0x91 , 0xfc , 0xd9 , 0x3c , 0xe1 , 0x6f , </a> 0
<a> 0x08 , 0xe4 , 0x56 , 0xf6 , 0x0b , 0xb0 , 0x3c , 0x39 , </a> 0
<a> 0x8a , 0x2d , 0x48 , 0x44 , 0x28 , 0x13 , 0xca , 0xe9 , </a> 0
<a> 0xf7 , 0xa3 , 0xb6 , 0x8a , 0x5f , 0x31 , 0xa9 , 0x72 , </a> 0
<a> 0xf2 , 0xde , 0x96 , 0xf2 , 0xb1 , 0x53 , 0xb1 , 0x3e , </a> 0
<a> 0x24 , 0x57 , 0xfd , 0x18 , 0x45 , 0x1f , 0xc5 , 0x33 , </a> 0
<a> 0x1b , 0xa4 , 0xe8 , 0x21 , 0xfa , 0x0e , 0xb2 , 0xb9 , </a> 0
<a> 0xcb , 0xc7 , 0x07 , 0x41 , 0xdd , 0x2f , 0xb6 , 0x6a , </a> 0
<a> 0x23 , 0x18 , 0xed , 0xc1 , 0xef , 0xe2 , 0x4b , 0xec , </a> 0
<a> 0xc9 , 0xba , 0xfb , 0x46 , 0x43 , 0x90 , 0xd7 , 0xb5 , </a> 0
<a> 0x68 , 0x28 , 0x31 , 0x2b , 0x8d , 0xa8 , 0x51 , 0x63 , </a> 0
<a> 0xf7 , 0x53 , 0x99 , 0x19 , 0x68 , 0x85 , 0x66 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x01 , 0x00 , 0x05 , 0x58 , 0x2e , 0x35 , </a> 0
<a> 0x30 , 0x39 , 0x00 , 0x00 , 0x02 , 0x3a , 0x30 , 0x82 , </a> 0
<a> 0x02 , 0x36 , 0x30 , 0x82 , 0x01 , 0xe0 , 0xa0 , 0x03 , </a> 0
<a> 0x02 , 0x01 , 0x02 , 0x02 , 0x04 , 0x48 , 0x59 , 0xf1 , </a> 0
<a> 0x92 , 0x30 , 0x0d , 0x06 , 0x09 , 0x2a , 0x86 , 0x48 , </a> 0
<a> 0x86 , 0xf7 , 0x0d , 0x01 , 0x01 , 0x05 , 0x05 , 0x00 , </a> 0
<a> 0x30 , 0x81 , 0xa0 , 0x31 , 0x0b , 0x30 , 0x09 , 0x06 , </a> 0
<a> 0x03 , 0x55 , 0x04 , 0x06 , 0x13 , 0x02 , 0x4b , 0x52 , </a> 0
<a> 0x31 , 0x13 , 0x30 , 0x11 , 0x06 , 0x03 , 0x55 , 0x04 , </a> 0
<a> 0x08 , 0x13 , 0x0a , 0x4b , 0x79 , 0x75 , 0x6e , 0x67 , </a> 0
<a> 0x67 , 0x69 , 0x2d , 0x64 , 0x6f , 0x31 , 0x14 , 0x30 , </a> 0
<a> 0x12 , 0x06 , 0x03 , 0x55 , 0x04 , 0x07 , 0x13 , 0x0b , </a> 0
<a> 0x53 , 0x65 , 0x6f , 0x6e , 0x67 , 0x6e , 0x61 , 0x6d , </a> 0
<a> 0x2d , 0x73 , 0x69 , 0x31 , 0x1a , 0x30 , 0x18 , 0x06 , </a> 0
<a> 0x03 , 0x55 , 0x04 , 0x0a , 0x13 , 0x11 , 0x54 , 0x68 , </a> 0
<a> 0x65 , 0x20 , 0x4e , 0x65 , 0x74 , 0x74 , 0x79 , 0x20 , </a> 0
<a> 0x50 , 0x72 , 0x6f , 0x6a , 0x65 , 0x63 , 0x74 , 0x31 , </a> 0
<a> 0x18 , 0x30 , 0x16 , 0x06 , 0x03 , 0x55 , 0x04 , 0x0b , </a> 0
<a> 0x13 , 0x0f , 0x45 , 0x78 , 0x61 , 0x6d , 0x70 , 0x6c , </a> 0
<a> 0x65 , 0x20 , 0x41 , 0x75 , 0x74 , 0x68 , 0x6f , 0x72 , </a> 0
<a> 0x73 , 0x31 , 0x30 , 0x30 , 0x2e , 0x06 , 0x03 , 0x55 , </a> 0
<a> 0x04 , 0x03 , 0x13 , 0x27 , 0x73 , 0x65 , 0x63 , 0x75 , </a> 0
<a> 0x72 , 0x65 , 0x63 , 0x68 , 0x61 , 0x74 , 0x2e , 0x65 , </a> 0
<a> 0x78 , 0x61 , 0x6d , 0x70 , 0x6c , 0x65 , 0x2e , 0x6e , </a> 0
<a> 0x65 , 0x74 , 0x74 , 0x79 , 0x2e , 0x67 , 0x6c , 0x65 , </a> 0
<a> 0x61 , 0x6d , 0x79 , 0x6e , 0x6f , 0x64 , 0x65 , 0x2e , </a> 0
<a> 0x6e , 0x65 , 0x74 , 0x30 , 0x20 , 0x17 , 0x0d , 0x30 , </a> 0
<a> 0x38 , 0x30 , 0x36 , 0x31 , 0x39 , 0x30 , 0x35 , 0x34 , </a> 0
<a> 0x31 , 0x33 , 0x38 , 0x5a , 0x18 , 0x0f , 0x32 , 0x31 , </a> 0
<a> 0x38 , 0x37 , 0x31 , 0x31 , 0x32 , 0x34 , 0x30 , 0x35 , </a> 0
<a> 0x34 , 0x31 , 0x33 , 0x38 , 0x5a , 0x30 , 0x81 , 0xa0 , </a> 0
<a> 0x31 , 0x0b , 0x30 , 0x09 , 0x06 , 0x03 , 0x55 , 0x04 , </a> 0
<a> 0x06 , 0x13 , 0x02 , 0x4b , 0x52 , 0x31 , 0x13 , 0x30 , </a> 0
<a> 0x11 , 0x06 , 0x03 , 0x55 , 0x04 , 0x08 , 0x13 , 0x0a , </a> 0
<a> 0x4b , 0x79 , 0x75 , 0x6e , 0x67 , 0x67 , 0x69 , 0x2d , </a> 0
<a> 0x64 , 0x6f , 0x31 , 0x14 , 0x30 , 0x12 , 0x06 , 0x03 , </a> 0
<a> 0x55 , 0x04 , 0x07 , 0x13 , 0x0b , 0x53 , 0x65 , 0x6f , </a> 0
<a> 0x6e , 0x67 , 0x6e , 0x61 , 0x6d , 0x2d , 0x73 , 0x69 , </a> 0
<a> 0x31 , 0x1a , 0x30 , 0x18 , 0x06 , 0x03 , 0x55 , 0x04 , </a> 0
<a> 0x0a , 0x13 , 0x11 , 0x54 , 0x68 , 0x65 , 0x20 , 0x4e , </a> 0
<a> 0x65 , 0x74 , 0x74 , 0x79 , 0x20 , 0x50 , 0x72 , 0x6f , </a> 0
<a> 0x6a , 0x65 , 0x63 , 0x74 , 0x31 , 0x18 , 0x30 , 0x16 , </a> 0
<a> 0x06 , 0x03 , 0x55 , 0x04 , 0x0b , 0x13 , 0x0f , 0x45 , </a> 0
<a> 0x78 , 0x61 , 0x6d , 0x70 , 0x6c , 0x65 , 0x20 , 0x41 , </a> 0
<a> 0x75 , 0x74 , 0x68 , 0x6f , 0x72 , 0x73 , 0x31 , 0x30 , </a> 0
<a> 0x30 , 0x2e , 0x06 , 0x03 , 0x55 , 0x04 , 0x03 , 0x13 , </a> 0
<a> 0x27 , 0x73 , 0x65 , 0x63 , 0x75 , 0x72 , 0x65 , 0x63 , </a> 0
<a> 0x68 , 0x61 , 0x74 , 0x2e , 0x65 , 0x78 , 0x61 , 0x6d , </a> 0
<a> 0x70 , 0x6c , 0x65 , 0x2e , 0x6e , 0x65 , 0x74 , 0x74 , </a> 0
<a> 0x79 , 0x2e , 0x67 , 0x6c , 0x65 , 0x61 , 0x6d , 0x79 , </a> 0
<a> 0x6e , 0x6f , 0x64 , 0x65 , 0x2e , 0x6e , 0x65 , 0x74 , </a> 0
<a> 0x30 , 0x5c , 0x30 , 0x0d , 0x06 , 0x09 , 0x2a , 0x86 , </a> 0
<a> 0x48 , 0x86 , 0xf7 , 0x0d , 0x01 , 0x01 , 0x01 , 0x05 , </a> 0
<a> 0x00 , 0x03 , 0x4b , 0x00 , 0x30 , 0x48 , 0x02 , 0x41 , </a> 0
<a> 0x00 , 0xc3 , 0xe3 , 0x5e , 0x41 , 0xa7 , 0x87 , 0x11 , </a> 0
<a> 0x00 , 0x42 , 0x2a , 0xb0 , 0x4b , 0xed , 0xb2 , 0xe0 , </a> 0
<a> 0x23 , 0xdb , 0xb1 , 0x3d , 0x58 , 0x97 , 0x35 , 0x60 , </a> 0
<a> 0x0b , 0x82 , 0x59 , 0xd3 , 0x00 , 0xea , 0xd4 , 0x61 , </a> 0
<a> 0xb8 , 0x79 , 0x3f , 0xb6 , 0x3c , 0x12 , 0x05 , 0x93 , </a> 0
<a> 0x2e , 0x9a , 0x59 , 0x68 , 0x14 , 0x77 , 0x3a , 0xc8 , </a> 0
<a> 0x50 , 0x25 , 0x57 , 0xa4 , 0x49 , 0x18 , 0x63 , 0x41 , </a> 0
<a> 0xf0 , 0x2d , 0x28 , 0xec , 0x06 , 0xfb , 0xb4 , 0x9f , </a> 0
<a> 0xbf , 0x02 , 0x03 , 0x01 , 0x00 , 0x01 , 0x30 , 0x0d , </a> 0
<a> 0x06 , 0x09 , 0x2a , 0x86 , 0x48 , 0x86 , 0xf7 , 0x0d , </a> 0
<a> 0x01 , 0x01 , 0x05 , 0x05 , 0x00 , 0x03 , 0x41 , 0x00 , </a> 0
<a> 0x65 , 0x6c , 0x30 , 0x01 , 0xc2 , 0x8e , 0x3e , 0xcb , </a> 0
<a> 0xb3 , 0x77 , 0x48 , 0xe9 , 0x66 , 0x61 , 0x9a , 0x40 , </a> 0
<a> 0x86 , 0xaf , 0xf6 , 0x03 , 0xeb , 0xba , 0x6a , 0xf2 , </a> 0
<a> 0xfd , 0xe2 , 0xaf , 0x36 , 0x5e , 0x7b , 0xaa , 0x22 , </a> 0
<a> 0x04 , 0xdd , 0x2c , 0x20 , 0xc4 , 0xfc , 0xdd , 0xd0 , </a> 0
<a> 0x82 , 0x20 , 0x1c , 0x3d , 0xd7 , 0x9e , 0x5e , 0x5c , </a> 0
<a> 0x92 , 0x5a , 0x76 , 0x71 , 0x28 , 0xf5 , 0x07 , 0x7d , </a> 0
<a> 0xa2 , 0x81 , 0xba , 0x77 , 0x9f , 0x2a , 0xd9 , 0x44 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x01 , 0x00 , 0x05 , 0x6d , 0x79 , </a> 0
<a> 0x6b , 0x65 , 0x79 , 0x00 , 0x00 , 0x01 , 0x1a , 0x9f , </a> 0
<a> 0x5b , 0x56 , 0xa0 , 0x00 , 0x00 , 0x01 , 0x99 , 0x30 , </a> 0
<a> 0x82 , 0x01 , 0x95 , 0x30 , 0x0e , 0x06 , 0x0a , 0x2b , </a> 0
<a> 0x06 , 0x01 , 0x04 , 0x01 , 0x2a , 0x02 , 0x11 , 0x01 , </a> 0
<a> 0x01 , 0x05 , 0x00 , 0x04 , 0x82 , 0x01 , 0x81 , 0x29 , </a> 0
<a> 0xa8 , 0xb6 , 0x08 , 0x0c , 0x85 , 0x75 , 0x3e , 0xdd , </a> 0
<a> 0xb5 , 0xe5 , 0x1a , 0x87 , 0x68 , 0xd1 , 0x90 , 0x4b , </a> 0
<a> 0x29 , 0x31 , 0xee , 0x90 , 0xbc , 0x9d , 0x73 , 0xa0 , </a> 0
<a> 0x3f , 0xe9 , 0x0b , 0xa4 , 0xef , 0x30 , 0x9b , 0x36 , </a> 0
<a> 0x9a , 0xb2 , 0x54 , 0x77 , 0x81 , 0x07 , 0x4b , 0xaa , </a> 0
<a> 0xa5 , 0x77 , 0x98 , 0xe1 , 0xeb , 0xb5 , 0x7c , 0x4e , </a> 0
<a> 0x48 , 0xd5 , 0x08 , 0xfc , 0x2c , 0x36 , 0xe2 , 0x65 , </a> 0
<a> 0x03 , 0xac , 0xe5 , 0xf3 , 0x96 , 0xb7 , 0xd0 , 0xb5 , </a> 0
<a> 0x3b , 0x92 , 0xe4 , 0x14 , 0x05 , 0x7a , 0x6a , 0x92 , </a> 0
<a> 0x56 , 0xfe , 0x4e , 0xab , 0xd3 , 0x0e , 0x32 , 0x04 , </a> 0
<a> 0x22 , 0x22 , 0x74 , 0x47 , 0x7d , 0xec , 0x21 , 0x99 , </a> 0
<a> 0x30 , 0x31 , 0x64 , 0x46 , 0x64 , 0x9b , 0xc7 , 0x13 , </a> 0
<a> 0xbf , 0xbe , 0xd0 , 0x31 , 0x49 , 0xe7 , 0x3c , 0xbf , </a> 0
<a> 0xba , 0xb1 , 0x20 , 0xf9 , 0x42 , 0xf4 , 0xa9 , 0xa9 , </a> 0
<a> 0xe5 , 0x13 , 0x65 , 0x32 , 0xbf , 0x7c , 0xcc , 0x91 , </a> 0
<a> 0xd3 , 0xfd , 0x24 , 0x47 , 0x0b , 0xe5 , 0x53 , 0xad , </a> 0
<a> 0x50 , 0x30 , 0x56 , 0xd1 , 0xfa , 0x9c , 0x37 , 0xa8 , </a> 0
<a> 0xc1 , 0xce , 0xf6 , 0x0b , 0x18 , 0xaa , 0x7c , 0xab , </a> 0
<a> 0xbd , 0x1f , 0xdf , 0xe4 , 0x80 , 0xb8 , 0xa7 , 0xe0 , </a> 0
<a> 0xad , 0x7d , 0x50 , 0x74 , 0xf1 , 0x98 , 0x78 , 0xbc , </a> 0
<a> 0x58 , 0xb9 , 0xc2 , 0x52 , 0xbe , 0xd2 , 0x5b , 0x81 , </a> 0
<a> 0x94 , 0x83 , 0x8f , 0xb9 , 0x4c , 0xee , 0x01 , 0x2b , </a> 0
<a> 0x5e , 0xc9 , 0x6e , 0x9b , 0xf5 , 0x63 , 0x69 , 0xe4 , </a> 0
<a> 0xd8 , 0x0b , 0x47 , 0xd8 , 0xfd , 0xd8 , 0xe0 , 0xed , </a> 0
<a> 0xa8 , 0x27 , 0x03 , 0x74 , 0x1e , 0x5d , 0x32 , 0xe6 , </a> 0
<a> 0x5c , 0x63 , 0xc2 , 0xfb , 0x3f , 0xee , 0xb4 , 0x13 , </a> 0
<a> 0xc6 , 0x0e , 0x6e , 0x74 , 0xe0 , 0x22 , 0xac , 0xce , </a> 0
<a> 0x79 , 0xf9 , 0x43 , 0x68 , 0xc1 , 0x03 , 0x74 , 0x2b , </a> 0
<a> 0xe1 , 0x18 , 0xf8 , 0x7f , 0x76 , 0x9a , 0xea , 0x82 , </a> 0
<a> 0x3f , 0xc2 , 0xa6 , 0xa7 , 0x4c , 0xfe , 0xae , 0x29 , </a> 0
<a> 0x3b , 0xc1 , 0x10 , 0x7c , 0xd5 , 0x77 , 0x17 , 0x79 , </a> 0
<a> 0x5f , 0xcb , 0xad , 0x1f , 0xd8 , 0xa1 , 0xfd , 0x90 , </a> 0
<a> 0xe1 , 0x6b , 0xb2 , 0xef , 0xb9 , 0x41 , 0x26 , 0xa4 , </a> 0
<a> 0x0b , 0x4f , 0xc6 , 0x83 , 0x05 , 0x6f , 0xf0 , 0x64 , </a> 0
<a> 0x40 , 0xe1 , 0x44 , 0xc4 , 0xf9 , 0x40 , 0x2b , 0x3b , </a> 0
<a> 0x40 , 0xdb , 0xaf , 0x35 , 0xa4 , 0x9b , 0x9f , 0xc4 , </a> 0
<a> 0x74 , 0x07 , 0xe5 , 0x18 , 0x60 , 0xc5 , 0xfe , 0x15 , </a> 0
<a> 0x0e , 0x3a , 0x25 , 0x2a , 0x11 , 0xee , 0x78 , 0x2f , </a> 0
<a> 0xb8 , 0xd1 , 0x6e , 0x4e , 0x3c , 0x0a , 0xb5 , 0xb9 , </a> 0
<a> 0x40 , 0x86 , 0x27 , 0x6d , 0x8f , 0x53 , 0xb7 , 0x77 , </a> 0
<a> 0x36 , 0xec , 0x5d , 0xed , 0x32 , 0x40 , 0x43 , 0x82 , </a> 0
<a> 0xc3 , 0x52 , 0x58 , 0xc4 , 0x26 , 0x39 , 0xf3 , 0xb3 , </a> 0
<a> 0xad , 0x58 , 0xab , 0xb7 , 0xf7 , 0x8e , 0x0e , 0xba , </a> 0
<a> 0x8e , 0x78 , 0x9d , 0xbf , 0x58 , 0x34 , 0xbd , 0x77 , </a> 0
<a> 0x73 , 0xa6 , 0x50 , 0x55 , 0x00 , 0x60 , 0x26 , 0xbf , </a> 0
<a> 0x6d , 0xb4 , 0x98 , 0x8a , 0x18 , 0x83 , 0x89 , 0xf8 , </a> 0
<a> 0xcd , 0x0d , 0x49 , 0x06 , 0xae , 0x51 , 0x6e , 0xaf , </a> 0
<a> 0xbd , 0xe2 , 0x07 , 0x13 , 0xd8 , 0x64 , 0xcc , 0xbf , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x01 , 0x00 , 0x05 , 0x58 , 0x2e , </a> 0
<a> 0x35 , 0x30 , 0x39 , 0x00 , 0x00 , 0x02 , 0x34 , 0x30 , </a> 0
<a> 0x82 , 0x02 , 0x30 , 0x30 , 0x82 , 0x01 , 0xda , 0xa0 , </a> 0
<a> 0x03 , 0x02 , 0x01 , 0x02 , 0x02 , 0x04 , 0x48 , 0x59 , </a> 0
<a> 0xf2 , 0x84 , 0x30 , 0x0d , 0x06 , 0x09 , 0x2a , 0x86 , </a> 0
<a> 0x48 , 0x86 , 0xf7 , 0x0d , 0x01 , 0x01 , 0x05 , 0x05 , </a> 0
<a> 0x00 , 0x30 , 0x81 , 0x9d , 0x31 , 0x0b , 0x30 , 0x09 , </a> 0
<a> 0x06 , 0x03 , 0x55 , 0x04 , 0x06 , 0x13 , 0x02 , 0x4b , </a> 0
<a> 0x52 , 0x31 , 0x13 , 0x30 , 0x11 , 0x06 , 0x03 , 0x55 , </a> 0
<a> 0x04 , 0x08 , 0x13 , 0x0a , 0x4b , 0x79 , 0x75 , 0x6e , </a> 0
<a> 0x67 , 0x67 , 0x69 , 0x2d , 0x64 , 0x6f , 0x31 , 0x14 , </a> 0
<a> 0x30 , 0x12 , 0x06 , 0x03 , 0x55 , 0x04 , 0x07 , 0x13 , </a> 0
<a> 0x0b , 0x53 , 0x65 , 0x6f , 0x6e , 0x67 , 0x6e , 0x61 , </a> 0
<a> 0x6d , 0x2d , 0x73 , 0x69 , 0x31 , 0x1a , 0x30 , 0x18 , </a> 0
<a> 0x06 , 0x03 , 0x55 , 0x04 , 0x0a , 0x13 , 0x11 , 0x54 , </a> 0
<a> 0x68 , 0x65 , 0x20 , 0x4e , 0x65 , 0x74 , 0x74 , 0x79 , </a> 0
<a> 0x20 , 0x50 , 0x72 , 0x6f , 0x6a , 0x65 , 0x63 , 0x74 , </a> 0
<a> 0x31 , 0x15 , 0x30 , 0x13 , 0x06 , 0x03 , 0x55 , 0x04 , </a> 0
<a> 0x0b , 0x13 , 0x0c , 0x43 , 0x6f , 0x6e , 0x74 , 0x72 , </a> 0
<a> 0x69 , 0x62 , 0x75 , 0x74 , 0x6f , 0x72 , 0x73 , 0x31 , </a> 0
<a> 0x30 , 0x30 , 0x2e , 0x06 , 0x03 , 0x55 , 0x04 , 0x03 , </a> 0
<a> 0x13 , 0x27 , 0x73 , 0x65 , 0x63 , 0x75 , 0x72 , 0x65 , </a> 0
<a> 0x63 , 0x68 , 0x61 , 0x74 , 0x2e , 0x65 , 0x78 , 0x61 , </a> 0
<a> 0x6d , 0x70 , 0x6c , 0x65 , 0x2e , 0x6e , 0x65 , 0x74 , </a> 0
<a> 0x74 , 0x79 , 0x2e , 0x67 , 0x6c , 0x65 , 0x61 , 0x6d , </a> 0
<a> 0x79 , 0x6e , 0x6f , 0x64 , 0x65 , 0x2e , 0x6e , 0x65 , </a> 0
<a> 0x74 , 0x30 , 0x20 , 0x17 , 0x0d , 0x30 , 0x38 , 0x30 , </a> 0
<a> 0x36 , 0x31 , 0x39 , 0x30 , 0x35 , 0x34 , 0x35 , 0x34 , </a> 0
<a> 0x30 , 0x5a , 0x18 , 0x0f , 0x32 , 0x31 , 0x38 , 0x37 , </a> 0
<a> 0x31 , 0x31 , 0x32 , 0x33 , 0x30 , 0x35 , 0x34 , 0x35 , </a> 0
<a> 0x34 , 0x30 , 0x5a , 0x30 , 0x81 , 0x9d , 0x31 , 0x0b , </a> 0
<a> 0x30 , 0x09 , 0x06 , 0x03 , 0x55 , 0x04 , 0x06 , 0x13 , </a> 0
<a> 0x02 , 0x4b , 0x52 , 0x31 , 0x13 , 0x30 , 0x11 , 0x06 , </a> 0
<a> 0x03 , 0x55 , 0x04 , 0x08 , 0x13 , 0x0a , 0x4b , 0x79 , </a> 0
<a> 0x75 , 0x6e , 0x67 , 0x67 , 0x69 , 0x2d , 0x64 , 0x6f , </a> 0
<a> 0x31 , 0x14 , 0x30 , 0x12 , 0x06 , 0x03 , 0x55 , 0x04 , </a> 0
<a> 0x07 , 0x13 , 0x0b , 0x53 , 0x65 , 0x6f , 0x6e , 0x67 , </a> 0
<a> 0x6e , 0x61 , 0x6d , 0x2d , 0x73 , 0x69 , 0x31 , 0x1a , </a> 0
<a> 0x30 , 0x18 , 0x06 , 0x03 , 0x55 , 0x04 , 0x0a , 0x13 , </a> 0
<a> 0x11 , 0x54 , 0x68 , 0x65 , 0x20 , 0x4e , 0x65 , 0x74 , </a> 0
<a> 0x74 , 0x79 , 0x20 , 0x50 , 0x72 , 0x6f , 0x6a , 0x65 , </a> 0
<a> 0x63 , 0x74 , 0x31 , 0x15 , 0x30 , 0x13 , 0x06 , 0x03 , </a> 0
<a> 0x55 , 0x04 , 0x0b , 0x13 , 0x0c , 0x43 , 0x6f , 0x6e , </a> 0
<a> 0x74 , 0x72 , 0x69 , 0x62 , 0x75 , 0x74 , 0x6f , 0x72 , </a> 0
<a> 0x73 , 0x31 , 0x30 , 0x30 , 0x2e , 0x06 , 0x03 , 0x55 , </a> 0
<a> 0x04 , 0x03 , 0x13 , 0x27 , 0x73 , 0x65 , 0x63 , 0x75 , </a> 0
<a> 0x72 , 0x65 , 0x63 , 0x68 , 0x61 , 0x74 , 0x2e , 0x65 , </a> 0
<a> 0x78 , 0x61 , 0x6d , 0x70 , 0x6c , 0x65 , 0x2e , 0x6e , </a> 0
<a> 0x65 , 0x74 , 0x74 , 0x79 , 0x2e , 0x67 , 0x6c , 0x65 , </a> 0
<a> 0x61 , 0x6d , 0x79 , 0x6e , 0x6f , 0x64 , 0x65 , 0x2e , </a> 0
<a> 0x6e , 0x65 , 0x74 , 0x30 , 0x5c , 0x30 , 0x0d , 0x06 , </a> 0
<a> 0x09 , 0x2a , 0x86 , 0x48 , 0x86 , 0xf7 , 0x0d , 0x01 , </a> 0
<a> 0x01 , 0x01 , 0x05 , 0x00 , 0x03 , 0x4b , 0x00 , 0x30 , </a> 0
<a> 0x48 , 0x02 , 0x41 , 0x00 , 0x95 , 0xb3 , 0x47 , 0x17 , </a> 0
<a> 0x95 , 0x0f , 0x57 , 0xcf , 0x66 , 0x72 , 0x0a , 0x7e , </a> 0
<a> 0x5b , 0x54 , 0xea , 0x8c , 0x6f , 0x79 , 0xde , 0x94 , </a> 0
<a> 0xac , 0x0b , 0x5a , 0xd4 , 0xd6 , 0x1b , 0x58 , 0x12 , </a> 0
<a> 0x1a , 0x16 , 0x3d , 0xfe , 0xdf , 0xa5 , 0x2b , 0x86 , </a> 0
<a> 0xbc , 0x64 , 0xd4 , 0x80 , 0x1e , 0x3f , 0xf9 , 0xe2 , </a> 0
<a> 0x04 , 0x03 , 0x79 , 0x9b , 0xc1 , 0x5c , 0xf0 , 0xf1 , </a> 0
<a> 0xf3 , 0xf1 , 0xe3 , 0xbf , 0x3f , 0xc0 , 0x1f , 0xdd , </a> 0
<a> 0xdb , 0xc0 , 0x5b , 0x21 , 0x02 , 0x03 , 0x01 , 0x00 , </a> 0
<a> 0x01 , 0x30 , 0x0d , 0x06 , 0x09 , 0x2a , 0x86 , 0x48 , </a> 0
<a> 0x86 , 0xf7 , 0x0d , 0x01 , 0x01 , 0x05 , 0x05 , 0x00 , </a> 0
<a> 0x03 , 0x41 , 0x00 , 0x02 , 0xd7 , 0xdd , 0xbd , 0x0c , </a> 0
<a> 0x8e , 0x21 , 0x20 , 0xef , 0x9e , 0x4f , 0x1f , 0xf5 , </a> 0
<a> 0x49 , 0xf1 , 0xae , 0x58 , 0x9b , 0x94 , 0x3a , 0x1f , </a> 0
<a> 0x70 , 0x33 , 0xf0 , 0x9b , 0xbb , 0xe9 , 0xc0 , 0xf3 , </a> 0
<a> 0x72 , 0xcb , 0xde , 0xb6 , 0x56 , 0x72 , 0xcc , 0x1c , </a> 0
<a> 0xf0 , 0xd6 , 0x5a , 0x2a , 0xbc , 0xa1 , 0x7e , 0x23 , </a> 0
<a> 0x83 , 0xe9 , 0xe7 , 0xcf , 0x9e , 0xa5 , 0xf9 , 0xcc , </a> 0
<a> 0xc2 , 0x61 , 0xf4 , 0xdb , 0x40 , 0x93 , 0x1d , 0x63 , </a> 0
<a> 0x8a , 0x50 , 0x4c , 0x11 , 0x39 , 0xb1 , 0x91 , 0xc1 , </a> 0
<a> 0xe6 , 0x9d , 0xd9 , 0x1a , 0x62 , 0x1b , 0xb8 , 0xd3 , </a> 0
<a> 0xd6 , 0x9a , 0x6d , 0xb9 , 0x8e , 0x15 , 0x51 } ; </a> 0
<a> public static InputStream asInputStream ( ) { </a> 0
<a> byte [ ] data = new byte [ DATA . length ] ; </a> 0
<a> for ( int i = 0 ; i < data . length ; i ++ ) { </a> 0
<a> data [ i ] = ( byte ) DATA [ i ] ; </a> 0
<a> } </a> 0
<a> return new ByteArrayInputStream ( data ) ; </a> 0
<a> } </a> 0
<a> public static char [ ] getCertificatePassword ( ) { </a> 0
<a> return "secret" . toCharArray ( ) ; </a> 0
<a> } </a> 0
<a> public static char [ ] getKeyStorePassword ( ) { </a> 0
<a> return "secret" . toCharArray ( ) ; </a> 0
<a> } </a> 0
<a> private SecureChatKeyStore ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . securechat ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> import io . netty . example . telnet . TelnetServer ; </a> 0
<a> public class SecureChatServer { </a> 1
<a> private final int port ; </a> 1
<a> public SecureChatServer ( int port ) { </a> 0
<a> this . port = port ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws InterruptedException { </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . localAddress ( port ) </a> 0
<a> . childHandler ( new SecureChatServerInitializer ( ) ) ; </a> 0
<a> b . bind ( ) . sync ( ) . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8443 ; </a> 1
<a> } </a> 1
<a> new SecureChatServer ( port ) . run ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . securechat ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . group . ChannelGroup ; </a> 0
<a> import io . netty . channel . group . DefaultChannelGroup ; </a> 0
<a> import io . netty . handler . ssl . SslHandler ; </a> 0
<a> import java . net . InetAddress ; </a> 0
<a> import java . util . logging . Level ; </a> 1
<a> import java . util . logging . Logger ; </a> 1
<a> public class SecureChatServerHandler extends ChannelInboundMessageHandlerAdapter < String > { </a> 1
<a> private static final Logger logger = Logger . getLogger ( </a> 1
<a> SecureChatServerHandler . class . getName ( ) ) ; </a> 1
<a> static final ChannelGroup channels = new DefaultChannelGroup ( ) ; </a> 1
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> ctx . write ( </a> 1
<a> "Welcome to " + InetAddress . getLocalHost ( ) . getHostName ( ) + </a> 1
<a> " secure chat service!\n" ) ; </a> 1
<a> ctx . write ( </a> 1
<a> "Your session is protected by " + </a> 0
<a> ctx . pipeline ( ) . get ( SslHandler . class ) . getEngine ( ) . getSession ( ) . getCipherSuite ( ) + </a> 0
<a> " cipher suite.\n" ) ; </a> 0
<a> channels . add ( ctx . channel ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , String request ) throws Exception { </a> 1
<a> for ( Channel c : channels ) { </a> 0
<a> if ( c != ctx . channel ( ) ) { </a> 0
<a> c . write ( "[" + ctx . channel ( ) . remoteAddress ( ) + "] " + </a> 1
<a> request + '\n' ) ; </a> 1
<a> } else { </a> 0
<a> c . write ( "[you] " + request + '\n' ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> if ( request . toLowerCase ( ) . equals ( "bye" ) ) { </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> logger . log ( </a> 1
<a> Level . WARNING , </a> 1
<a> "Unexpected exception from downstream." , cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . securechat ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . DelimiterBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . Delimiters ; </a> 0
<a> import io . netty . handler . codec . string . StringDecoder ; </a> 0
<a> import io . netty . handler . codec . string . StringEncoder ; </a> 0
<a> import io . netty . handler . ssl . SslHandler ; </a> 0
<a> import javax . net . ssl . SSLEngine ; </a> 0
<a> public class SecureChatServerInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 0
<a> ChannelPipeline pipeline = ch . pipeline ( ) ; </a> 0
<a> SSLEngine engine = </a> 0
<a> SecureChatSslContextFactory . getServerContext ( ) . createSSLEngine ( ) ; </a> 0
<a> engine . setUseClientMode ( false ) ; </a> 0
<a> pipeline . addLast ( "ssl" , new SslHandler ( engine ) ) ; </a> 0
<a> pipeline . addLast ( "framer" , new DelimiterBasedFrameDecoder ( </a> 1
<a> 8192 , Delimiters . lineDelimiter ( ) ) ) ; </a> 1
<a> pipeline . addLast ( "decoder" , new StringDecoder ( ) ) ; </a> 1
<a> pipeline . addLast ( "encoder" , new StringEncoder ( ) ) ; </a> 0
<a> pipeline . addLast ( "handler" , new SecureChatServerHandler ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . securechat ; </a> 0
<a> import io . netty . handler . ssl . SslHandler ; </a> 0
<a> import java . security . KeyStore ; </a> 0
<a> import java . security . SecureRandom ; </a> 0
<a> import java . security . Security ; </a> 0
<a> import javax . net . ssl . KeyManager ; </a> 0
<a> import javax . net . ssl . KeyManagerFactory ; </a> 0
<a> import javax . net . ssl . SSLContext ; </a> 0
<a> import javax . net . ssl . SSLEngine ; </a> 0
<a> import javax . net . ssl . TrustManager ; </a> 0
<a> public final class SecureChatSslContextFactory { </a> 0
<a> private static final String PROTOCOL = "TLS" ; </a> 0
<a> private static final SSLContext SERVER_CONTEXT ; </a> 0
<a> private static final SSLContext CLIENT_CONTEXT ; </a> 0
<a> static { </a> 0
<a> String algorithm = Security . getProperty ( "ssl.KeyManagerFactory.algorithm" ) ; </a> 0
<a> if ( algorithm == null ) { </a> 0
<a> algorithm = "SunX509" ; </a> 0
<a> } </a> 0
<a> SSLContext serverContext ; </a> 0
<a> SSLContext clientContext ; </a> 0
<a> try { </a> 0
<a> KeyStore ks = KeyStore . getInstance ( "JKS" ) ; </a> 0
<a> ks . load ( SecureChatKeyStore . asInputStream ( ) , </a> 0
<a> SecureChatKeyStore . getKeyStorePassword ( ) ) ; </a> 0
<a> KeyManagerFactory kmf = KeyManagerFactory . getInstance ( algorithm ) ; </a> 0
<a> kmf . init ( ks , SecureChatKeyStore . getCertificatePassword ( ) ) ; </a> 0
<a> serverContext = SSLContext . getInstance ( PROTOCOL ) ; </a> 0
<a> serverContext . init ( kmf . getKeyManagers ( ) , null , null ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new Error ( </a> 0
<a> "Failed to initialize the server-side SSLContext" , e ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> clientContext = SSLContext . getInstance ( PROTOCOL ) ; </a> 0
<a> clientContext . init ( null , SecureChatTrustManagerFactory . getTrustManagers ( ) , null ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new Error ( </a> 0
<a> "Failed to initialize the client-side SSLContext" , e ) ; </a> 0
<a> } </a> 0
<a> SERVER_CONTEXT = serverContext ; </a> 0
<a> CLIENT_CONTEXT = clientContext ; </a> 0
<a> } </a> 0
<a> public static SSLContext getServerContext ( ) { </a> 0
<a> return SERVER_CONTEXT ; </a> 0
<a> } </a> 0
<a> public static SSLContext getClientContext ( ) { </a> 0
<a> return CLIENT_CONTEXT ; </a> 0
<a> } </a> 0
<a> private SecureChatSslContextFactory ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . telnet ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioSocketChannel ; </a> 0
<a> import java . io . BufferedReader ; </a> 0
<a> import java . io . InputStreamReader ; </a> 0
<a> public class TelnetClient { </a> 1
<a> private final String host ; </a> 1
<a> private final int port ; </a> 1
<a> public TelnetClient ( String host , int port ) { </a> 1
<a> this . host = host ; </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> Bootstrap b = new Bootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioSocketChannel ( ) ) </a> 0
<a> . remoteAddress ( host , port ) </a> 0
<a> . handler ( new TelnetClientInitializer ( ) ) ; </a> 1
<a> Channel ch = b . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> ChannelFuture lastWriteFuture = null ; </a> 0
<a> BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> String line = in . readLine ( ) ; </a> 0
<a> if ( line == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> lastWriteFuture = ch . write ( line + "\r\n" ) ; </a> 0
<a> if ( line . toLowerCase ( ) . equals ( "bye" ) ) { </a> 0
<a> ch . closeFuture ( ) . sync ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( lastWriteFuture != null ) { </a> 0
<a> lastWriteFuture . sync ( ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> if ( args . length != 2 ) { </a> 0
<a> System . err . println ( </a> 0
<a> "Usage: " + TelnetClient . class . getSimpleName ( ) + </a> 0
<a> " <host> <port>" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> String host = args [ 0 ] ; </a> 0
<a> int port = Integer . parseInt ( args [ 1 ] ) ; </a> 0
<a> new TelnetClient ( host , port ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . logging ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandler ; </a> 1
<a> import io . netty . channel . ChannelOutboundByteHandler ; </a> 1
<a> public class ByteLoggingHandler </a> 0
<a> extends LoggingHandler implements ChannelInboundByteHandler , ChannelOutboundByteHandler { </a> 1
<a> private static final String NEWLINE = String . format ( "%n" ) ; </a> 0
<a> private static final String [ ] BYTE2HEX = new String [ 256 ] ; </a> 0
<a> private static final String [ ] HEXPADDING = new String [ 16 ] ; </a> 0
<a> private static final String [ ] BYTEPADDING = new String [ 16 ] ; </a> 0
<a> private static final char [ ] BYTE2CHAR = new char [ 256 ] ; </a> 0
<a> static { </a> 0
<a> int i ; </a> 0
<a> for ( i = 0 ; i < 10 ; i ++ ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( 3 ) ; </a> 0
<a> buf . append ( " 0" ) ; </a> 0
<a> buf . append ( i ) ; </a> 0
<a> BYTE2HEX [ i ] = buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> for ( ; i < 16 ; i ++ ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( 3 ) ; </a> 0
<a> buf . append ( " 0" ) ; </a> 0
<a> buf . append ( ( char ) ( 'a' + i - 10 ) ) ; </a> 0
<a> BYTE2HEX [ i ] = buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> for ( ; i < BYTE2HEX . length ; i ++ ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( 3 ) ; </a> 0
<a> buf . append ( ' ' ) ; </a> 0
<a> buf . append ( Integer . toHexString ( i ) ) ; </a> 0
<a> BYTE2HEX [ i ] = buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> for ( i = 0 ; i < HEXPADDING . length ; i ++ ) { </a> 0
<a> int padding = HEXPADDING . length - i ; </a> 0
<a> StringBuilder buf = new StringBuilder ( padding * 3 ) ; </a> 0
<a> for ( int j = 0 ; j < padding ; j ++ ) { </a> 0
<a> buf . append ( " " ) ; </a> 0
<a> } </a> 0
<a> HEXPADDING [ i ] = buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> for ( i = 0 ; i < BYTEPADDING . length ; i ++ ) { </a> 0
<a> int padding = BYTEPADDING . length - i ; </a> 0
<a> StringBuilder buf = new StringBuilder ( padding ) ; </a> 0
<a> for ( int j = 0 ; j < padding ; j ++ ) { </a> 0
<a> buf . append ( ' ' ) ; </a> 0
<a> } </a> 0
<a> BYTEPADDING [ i ] = buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> for ( i = 0 ; i < BYTE2CHAR . length ; i ++ ) { </a> 0
<a> if ( i <= 0x1f || i >= 0x7f ) { </a> 0
<a> BYTE2CHAR [ i ] = '.' ; </a> 0
<a> } else { </a> 0
<a> BYTE2CHAR [ i ] = ( char ) i ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public ByteLoggingHandler ( ) { } </a> 0
<a> public ByteLoggingHandler ( Class < ? > clazz , LogLevel level ) { </a> 0
<a> super ( clazz , level ) ; </a> 0
<a> } </a> 0
<a> public ByteLoggingHandler ( Class < ? > clazz ) { </a> 0
<a> super ( clazz ) ; </a> 0
<a> } </a> 0
<a> public ByteLoggingHandler ( LogLevel level ) { </a> 0
<a> super ( level ) ; </a> 0
<a> } </a> 0
<a> public ByteLoggingHandler ( String name , LogLevel level ) { </a> 0
<a> super ( name , level ) ; </a> 0
<a> } </a> 0
<a> public ByteLoggingHandler ( String name ) { </a> 0
<a> super ( name ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return Unpooled . buffer ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return Unpooled . buffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) </a> 1
<a> throws Exception { </a> 1
<a> ByteBuf buf = ctx . inboundByteBuffer ( ) ; </a> 1
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , formatBuffer ( "RECEIVED" , buf ) ) ) ; </a> 1
<a> } </a> 0
<a> ctx . nextInboundByteBuffer ( ) . writeBytes ( buf ) ; </a> 1
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> public void flush ( ChannelHandlerContext ctx , ChannelFuture future ) </a> 0
<a> throws Exception { </a> 1
<a> ByteBuf buf = ctx . outboundByteBuffer ( ) ; </a> 1
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 1
<a> logger . log ( internalLevel , format ( ctx , formatBuffer ( "WRITE" , buf ) ) ) ; </a> 1
<a> } </a> 0
<a> ctx . nextOutboundByteBuffer ( ) . writeBytes ( buf ) ; </a> 1
<a> ctx . flush ( future ) ; </a> 0
<a> } </a> 0
<a> protected String formatBuffer ( String message , ByteBuf buf ) { </a> 0
<a> int length = buf . readableBytes ( ) ; </a> 0
<a> int rows = length / 16 + ( length % 15 == 0 ? 0 : 1 ) + 4 ; </a> 0
<a> StringBuilder dump = new StringBuilder ( rows * 80 + message . length ( ) + 16 ) ; </a> 0
<a> dump . append ( message ) . append ( '(' ) . append ( length ) . append ( 'B' ) . append ( ')' ) ; </a> 0
<a> dump . append ( </a> 0
<a> NEWLINE + " +-------------------------------------------------+" + </a> 0
<a> NEWLINE + " | 0 1 2 3 4 5 6 7 8 9 a b c d e f |" + </a> 0
<a> NEWLINE + "+--------+-------------------------------------------------+----------------+" ) ; </a> 0
<a> final int startIndex = buf . readerIndex ( ) ; </a> 0
<a> final int endIndex = buf . writerIndex ( ) ; </a> 0
<a> int i ; </a> 0
<a> for ( i = startIndex ; i < endIndex ; i ++ ) { </a> 0
<a> int relIdx = i - startIndex ; </a> 0
<a> int relIdxMod16 = relIdx & 15 ; </a> 0
<a> if ( relIdxMod16 == 0 ) { </a> 0
<a> dump . append ( NEWLINE ) ; </a> 0
<a> dump . append ( Long . toHexString ( relIdx & 0xFFFFFFFFL | 0x100000000L ) ) ; </a> 0
<a> dump . setCharAt ( dump . length ( ) - 9 , '|' ) ; </a> 0
<a> dump . append ( '|' ) ; </a> 0
<a> } </a> 0
<a> dump . append ( BYTE2HEX [ buf . getUnsignedByte ( i ) ] ) ; </a> 0
<a> if ( relIdxMod16 == 15 ) { </a> 0
<a> dump . append ( " |" ) ; </a> 0
<a> for ( int j = i - 15 ; j <= i ; j ++ ) { </a> 0
<a> dump . append ( BYTE2CHAR [ buf . getUnsignedByte ( j ) ] ) ; </a> 0
<a> } </a> 0
<a> dump . append ( '|' ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ( i - startIndex & 15 ) != 0 ) { </a> 0
<a> int remainder = length & 15 ; </a> 0
<a> dump . append ( HEXPADDING [ remainder ] ) ; </a> 0
<a> dump . append ( " |" ) ; </a> 0
<a> for ( int j = i - remainder ; j < i ; j ++ ) { </a> 0
<a> dump . append ( BYTE2CHAR [ buf . getUnsignedByte ( j ) ] ) ; </a> 0
<a> } </a> 0
<a> dump . append ( BYTEPADDING [ remainder ] ) ; </a> 0
<a> dump . append ( '|' ) ; </a> 0
<a> } </a> 0
<a> dump . append ( </a> 0
<a> NEWLINE + "+--------+-------------------------------------------------+----------------+" ) ; </a> 0
<a> return dump . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . logging ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . ssl ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ByteBufUtil ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFlushFutureNotifier ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandler ; </a> 1
<a> import io . netty . channel . ChannelOutboundByteHandler ; </a> 1
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . DefaultChannelFuture ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . util . internal . DetectionUtil ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . channels . ClosedChannelException ; </a> 0
<a> import java . nio . channels . DatagramChannel ; </a> 0
<a> import java . nio . channels . SocketChannel ; </a> 0
<a> import java . util . ArrayDeque ; </a> 1
<a> import java . util . Queue ; </a> 1
<a> import java . util . concurrent . Executor ; </a> 0
<a> import java . util . concurrent . ScheduledFuture ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . regex . Pattern ; </a> 0
<a> import javax . net . ssl . SSLEngine ; </a> 1
<a> import javax . net . ssl . SSLEngineResult ; </a> 1
<a> import javax . net . ssl . SSLEngineResult . Status ; </a> 1
<a> import javax . net . ssl . SSLException ; </a> 1
<a> public class SslHandler </a> 1
<a> extends ChannelHandlerAdapter </a> 0
<a> implements ChannelInboundByteHandler , ChannelOutboundByteHandler { </a> 1
<a> private static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( SslHandler . class ) ; </a> 0
<a> private static final Pattern IGNORABLE_CLASS_IN_STACK = Pattern . compile ( </a> 0
<a> "^.*(Socket|DatagramChannel|SctpChannel).*$" ) ; </a> 0
<a> private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern . compile ( </a> 0
<a> "^.*(?:connection.*reset|connection.*closed|broken.*pipe).*$" , </a> 0
<a> Pattern . CASE_INSENSITIVE ) ; </a> 0
<a> private volatile ChannelHandlerContext ctx ; </a> 0
<a> private final SSLEngine engine ; </a> 0
<a> private final Executor delegatedTaskExecutor ; </a> 0
<a> private final ChannelFlushFutureNotifier flushFutureNotifier = new ChannelFlushFutureNotifier ( ) ; </a> 0
<a> private final boolean startTls ; </a> 0
<a> private boolean sentFirstMessage ; </a> 0
<a> private final Queue < ChannelFuture > handshakeFutures = new ArrayDeque < ChannelFuture > ( ) ; </a> 0
<a> private final SSLEngineInboundCloseFuture sslCloseFuture = new SSLEngineInboundCloseFuture ( ) ; </a> 1
<a> public SslHandler ( SSLEngine engine ) { </a> 0
<a> this ( engine , ImmediateExecutor . INSTANCE ) ; </a> 1
<a> } </a> 0
<a> public SslHandler ( SSLEngine engine , boolean startTls ) { </a> 0
<a> this ( engine , startTls , ImmediateExecutor . INSTANCE ) ; </a> 0
<a> } </a> 0
<a> public SslHandler ( SSLEngine engine , Executor delegatedTaskExecutor ) { </a> 0
<a> this ( engine , false , delegatedTaskExecutor ) ; </a> 0
<a> } </a> 0
<a> public SslHandler ( SSLEngine engine , boolean startTls , Executor delegatedTaskExecutor ) { </a> 0
<a> if ( engine == null ) { </a> 0
<a> throw new NullPointerException ( "engine" ) ; </a> 0
<a> } </a> 0
<a> if ( delegatedTaskExecutor == null ) { </a> 0
<a> throw new NullPointerException ( "delegatedTaskExecutor" ) ; </a> 0
<a> } </a> 0
<a> this . engine = engine ; </a> 0
<a> this . delegatedTaskExecutor = delegatedTaskExecutor ; </a> 0
<a> this . startTls = startTls ; </a> 0
<a> } </a> 0
<a> public SSLEngine getEngine ( ) { </a> 0
<a> return engine ; </a> 0
<a> } </a> 0
<a> public ChannelFuture handshake ( ) { </a> 1
<a> return handshake ( ctx . newFuture ( ) ) ; </a> 0
<a> } </a> 1
<a> public ChannelFuture handshake ( final ChannelFuture future ) { </a> 0
<a> final ChannelHandlerContext ctx = this . ctx ; </a> 1
<a> ctx . executor ( ) . schedule ( new Runnable ( ) { </a> 0
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> if ( future . isDone ( ) ) { </a> 0
<a> return ; </a> 1
<a> } </a> 0
<a> SSLException e = new SSLException ( "handshake timed out" ) ; </a> 1
<a> future . setFailure ( e ) ; </a> 0
<a> ctx . fireExceptionCaught ( e ) ; </a> 1
<a> ctx . close ( ) ; </a> 1
<a> } </a> 1
<a> } , 10 , TimeUnit . SECONDS ) ; </a> 0
<a> ctx . executor ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 1
<a> public void run ( ) { </a> 0
<a> try { </a> 0
<a> engine . beginHandshake ( ) ; </a> 1
<a> handshakeFutures . add ( future ) ; </a> 0
<a> flush ( ctx , ctx . newFuture ( ) ) ; </a> 0
<a> } catch ( Exception e ) { </a> 1
<a> future . setFailure ( e ) ; </a> 0
<a> ctx . fireExceptionCaught ( e ) ; </a> 1
<a> ctx . close ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> return future ; </a> 0
<a> } </a> 0
<a> public ChannelFuture close ( ) { </a> 0
<a> return close ( ctx . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> public ChannelFuture close ( final ChannelFuture future ) { </a> 0
<a> final ChannelHandlerContext ctx = this . ctx ; </a> 0
<a> ctx . executor ( ) . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> engine . closeOutbound ( ) ; </a> 0
<a> ctx . flush ( future ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> public ChannelFuture sslCloseFuture ( ) { </a> 1
<a> return sslCloseFuture ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return Unpooled . buffer ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return Unpooled . buffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void disconnect ( final ChannelHandlerContext ctx , </a> 0
<a> final ChannelFuture future ) throws Exception { </a> 0
<a> closeOutboundAndChannel ( ctx , future , true ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( final ChannelHandlerContext ctx , </a> 0
<a> final ChannelFuture future ) throws Exception { </a> 0
<a> closeOutboundAndChannel ( ctx , future , false ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( final ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> final ByteBuf in = ctx . outboundByteBuffer ( ) ; </a> 1
<a> final ByteBuf out = ctx . nextOutboundByteBuffer ( ) ; </a> 1
<a> out . unsafe ( ) . discardSomeReadBytes ( ) ; </a> 1
<a> if ( startTls && ! sentFirstMessage ) { </a> 1
<a> sentFirstMessage = true ; </a> 0
<a> out . writeBytes ( in ) ; </a> 1
<a> ctx . flush ( future ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( ctx . executor ( ) == ctx . channel ( ) . eventLoop ( ) ) { </a> 1
<a> flushFutureNotifier . addFlushFuture ( future , in . readableBytes ( ) ) ; </a> 0
<a> } else { </a> 0
<a> synchronized ( flushFutureNotifier ) { </a> 1
<a> flushFutureNotifier . addFlushFuture ( future , in . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean unwrapLater = false ; </a> 0
<a> int bytesConsumed = 0 ; </a> 1
<a> try { </a> 0
<a> for ( ; ; ) { </a> 0
<a> SSLEngineResult result = wrap ( engine , in , out ) ; </a> 1
<a> bytesConsumed += result . bytesConsumed ( ) ; </a> 1
<a> if ( result . getStatus ( ) == Status . CLOSED ) { </a> 0
<a> if ( in . readable ( ) ) { </a> 0
<a> in . clear ( ) ; </a> 1
<a> SSLException e = new SSLException ( "SSLEngine already closed" ) ; </a> 0
<a> future . setFailure ( e ) ; </a> 0
<a> ctx . fireExceptionCaught ( e ) ; </a> 0
<a> flush0 ( ctx , bytesConsumed , e ) ; </a> 0
<a> bytesConsumed = 0 ; </a> 1
<a> } </a> 1
<a> break ; </a> 1
<a> } else { </a> 0
<a> switch ( result . getHandshakeStatus ( ) ) { </a> 0
<a> case NEED_WRAP : </a> 0
<a> ctx . flush ( ) ; </a> 1
<a> continue ; </a> 0
<a> case NEED_UNWRAP : </a> 0
<a> if ( ctx . inboundByteBuffer ( ) . readable ( ) ) { </a> 0
<a> unwrapLater = true ; </a> 0
<a> } </a> 1
<a> break ; </a> 0
<a> case NEED_TASK : </a> 1
<a> runDelegatedTasks ( ) ; </a> 1
<a> continue ; </a> 1
<a> case FINISHED : </a> 1
<a> setHandshakeSuccess ( ) ; </a> 1
<a> continue ; </a> 0
<a> case NOT_HANDSHAKING : </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new IllegalStateException ( "Unknown handshake status: " + result . getHandshakeStatus ( ) ) ; </a> 1
<a> } </a> 0
<a> if ( result . bytesConsumed ( ) == 0 && result . bytesProduced ( ) == 0 ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( unwrapLater ) { </a> 1
<a> inboundBufferUpdated ( ctx ) ; </a> 1
<a> } </a> 0
<a> } catch ( SSLException e ) { </a> 0
<a> setHandshakeFailure ( e ) ; </a> 1
<a> throw e ; </a> 0
<a> } finally { </a> 0
<a> in . unsafe ( ) . discardSomeReadBytes ( ) ; </a> 1
<a> flush0 ( ctx , bytesConsumed ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private void flush0 ( final ChannelHandlerContext ctx , final int bytesConsumed ) { </a> 1
<a> ctx . flush ( ctx . newFuture ( ) . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 1
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 1
<a> if ( ctx . executor ( ) == ctx . channel ( ) . eventLoop ( ) ) { </a> 1
<a> notifyFlushFutures ( bytesConsumed , future ) ; </a> 1
<a> } else { </a> 1
<a> synchronized ( flushFutureNotifier ) { </a> 1
<a> notifyFlushFutures ( bytesConsumed , future ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private void notifyFlushFutures ( final int bytesConsumed , ChannelFuture future ) { </a> 1
<a> if ( future . isSuccess ( ) ) { </a> 1
<a> flushFutureNotifier . increaseWriteCounter ( bytesConsumed ) ; </a> 1
<a> flushFutureNotifier . notifyFlushFutures ( ) ; </a> 1
<a> } else { </a> 1
<a> flushFutureNotifier . notifyFlushFutures ( future . cause ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> } ) ) ; </a> 1
<a> } </a> 0
<a> private void flush0 ( final ChannelHandlerContext ctx , final int bytesConsumed , final Throwable cause ) { </a> 1
<a> ChannelFuture flushFuture = ctx . flush ( ctx . newFuture ( ) . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 1
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 1
<a> if ( ctx . executor ( ) == ctx . channel ( ) . eventLoop ( ) ) { </a> 1
<a> notifyFlushFutures ( ctx , bytesConsumed , cause , future ) ; </a> 0
<a> } else { </a> 1
<a> synchronized ( flushFutureNotifier ) { </a> 1
<a> notifyFlushFutures ( ctx , bytesConsumed , cause , future ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void notifyFlushFutures ( final ChannelHandlerContext ctx , </a> 0
<a> final int bytesConsumed , final Throwable cause , ChannelFuture future ) { </a> 0
<a> flushFutureNotifier . increaseWriteCounter ( bytesConsumed ) ; </a> 1
<a> if ( future . isSuccess ( ) ) { </a> 1
<a> flushFutureNotifier . notifyFlushFutures ( cause ) ; </a> 1
<a> } else { </a> 1
<a> flushFutureNotifier . notifyFlushFutures ( cause , future . cause ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } ) ) ; </a> 1
<a> safeClose ( ctx , flushFuture , ctx . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> private static SSLEngineResult wrap ( SSLEngine engine , ByteBuf in , ByteBuf out ) throws SSLException { </a> 1
<a> ByteBuffer in0 = in . nioBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 0
<a> ByteBuffer out0 = out . nioBuffer ( out . writerIndex ( ) , out . writableBytes ( ) ) ; </a> 0
<a> SSLEngineResult result = engine . wrap ( in0 , out0 ) ; </a> 0
<a> in . skipBytes ( result . bytesConsumed ( ) ) ; </a> 0
<a> out . writerIndex ( out . writerIndex ( ) + result . bytesProduced ( ) ) ; </a> 0
<a> if ( result . getStatus ( ) == Status . BUFFER_OVERFLOW ) { </a> 1
<a> out . ensureWritableBytes ( engine . getSession ( ) . getPacketBufferSize ( ) ) ; </a> 0
<a> } else { </a> 1
<a> return result ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> setHandshakeFailure ( null ) ; </a> 0
<a> try { </a> 1
<a> inboundBufferUpdated ( ctx ) ; </a> 1
<a> } finally { </a> 1
<a> engine . closeOutbound ( ) ; </a> 0
<a> try { </a> 0
<a> engine . closeInbound ( ) ; </a> 0
<a> } catch ( SSLException ex ) { </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( "Failed to clean up SSLEngine." , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ctx . fireChannelInactive ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> if ( ignoreException ( cause ) ) { </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( </a> 0
<a> "Swallowing a 'connection reset by peer / " + </a> 0
<a> "broken pipe' error occurred while writing " + </a> 0
<a> "'closure_notify'" , cause ) ; </a> 0
<a> } </a> 0
<a> if ( ctx . channel ( ) . isActive ( ) ) { </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> super . exceptionCaught ( ctx , cause ) ; </a> 0
<a> } </a> 0
<a> private boolean ignoreException ( Throwable t ) { </a> 0
<a> if ( ! ( t instanceof SSLException ) && t instanceof IOException && engine . isOutboundDone ( ) ) { </a> 0
<a> String message = String . valueOf ( t . getMessage ( ) ) . toLowerCase ( ) ; </a> 0
<a> if ( IGNORABLE_ERROR_MESSAGE . matcher ( message ) . matches ( ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> StackTraceElement [ ] elements = t . getStackTrace ( ) ; </a> 0
<a> for ( StackTraceElement element : elements ) { </a> 0
<a> String classname = element . getClassName ( ) ; </a> 0
<a> String methodname = element . getMethodName ( ) ; </a> 0
<a> if ( classname . startsWith ( "io.netty." ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> if ( ! methodname . equals ( "read" ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> if ( IGNORABLE_CLASS_IN_STACK . matcher ( classname ) . matches ( ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Class < ? > clazz = getClass ( ) . getClassLoader ( ) . loadClass ( classname ) ; </a> 0
<a> if ( SocketChannel . class . isAssignableFrom ( clazz ) </a> 0
<a> || DatagramChannel . class . isAssignableFrom ( clazz ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( DetectionUtil . javaVersion ( ) >= 7 </a> 0
<a> && "com.sun.nio.sctp.SctpChannel" . equals ( clazz . getSuperclass ( ) . getName ( ) ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } catch ( ClassNotFoundException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( final ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> final ByteBuf in = ctx . inboundByteBuffer ( ) ; </a> 0
<a> if ( in . readableBytes ( ) < 5 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> boolean tls ; </a> 0
<a> switch ( in . getUnsignedByte ( in . readerIndex ( ) ) ) { </a> 0
<a> case 20 : </a> 0
<a> case 21 : </a> 0
<a> case 22 : </a> 0
<a> case 23 : </a> 0
<a> tls = true ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> tls = false ; </a> 0
<a> } </a> 0
<a> int packetLength = - 1 ; </a> 0
<a> if ( tls ) { </a> 0
<a> int majorVersion = in . getUnsignedByte ( in . readerIndex ( ) + 1 ) ; </a> 0
<a> if ( majorVersion == 3 ) { </a> 0
<a> packetLength = ( getShort ( in , in . readerIndex ( ) + 3 ) & 0xFFFF ) + 5 ; </a> 0
<a> if ( packetLength <= 5 ) { </a> 0
<a> tls = false ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> tls = false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! tls ) { </a> 0
<a> boolean sslv2 = true ; </a> 0
<a> int headerLength = ( in . getUnsignedByte ( </a> 0
<a> in . readerIndex ( ) ) & 0x80 ) != 0 ? 2 : 3 ; </a> 0
<a> int majorVersion = in . getUnsignedByte ( </a> 0
<a> in . readerIndex ( ) + headerLength + 1 ) ; </a> 0
<a> if ( majorVersion == 2 || majorVersion == 3 ) { </a> 0
<a> if ( headerLength == 2 ) { </a> 0
<a> packetLength = ( getShort ( in , in . readerIndex ( ) ) & 0x7FFF ) + 2 ; </a> 0
<a> } else { </a> 0
<a> packetLength = ( getShort ( in , in . readerIndex ( ) ) & 0x3FFF ) + 3 ; </a> 0
<a> } </a> 0
<a> if ( packetLength <= headerLength ) { </a> 0
<a> sslv2 = false ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> sslv2 = false ; </a> 0
<a> } </a> 0
<a> if ( ! sslv2 ) { </a> 0
<a> NotSslRecordException e = new NotSslRecordException ( </a> 0
<a> "not an SSL/TLS record: " + ByteBufUtil . hexDump ( in ) ) ; </a> 0
<a> in . skipBytes ( in . readableBytes ( ) ) ; </a> 0
<a> ctx . fireExceptionCaught ( e ) ; </a> 1
<a> setHandshakeFailure ( e ) ; </a> 1
<a> return ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> assert packetLength > 0 ; </a> 0
<a> final ByteBuf out = ctx . nextInboundByteBuffer ( ) ; </a> 1
<a> out . discardReadBytes ( ) ; </a> 0
<a> boolean wrapLater = false ; </a> 0
<a> int bytesProduced = 0 ; </a> 1
<a> try { </a> 0
<a> loop : </a> 1
<a> for ( ; ; ) { </a> 0
<a> SSLEngineResult result = unwrap ( engine , in , out ) ; </a> 1
<a> bytesProduced += result . bytesProduced ( ) ; </a> 1
<a> switch ( result . getStatus ( ) ) { </a> 1
<a> case CLOSED : </a> 1
<a> sslCloseFuture . setClosed ( ) ; </a> 1
<a> break ; </a> 1
<a> case BUFFER_UNDERFLOW : </a> 1
<a> break loop ; </a> 1
<a> } </a> 0
<a> switch ( result . getHandshakeStatus ( ) ) { </a> 1
<a> case NEED_UNWRAP : </a> 0
<a> break ; </a> 0
<a> case NEED_WRAP : </a> 0
<a> wrapLater = true ; </a> 1
<a> break ; </a> 0
<a> case NEED_TASK : </a> 0
<a> runDelegatedTasks ( ) ; </a> 0
<a> break ; </a> 0
<a> case FINISHED : </a> 0
<a> setHandshakeSuccess ( ) ; </a> 0
<a> continue ; </a> 0
<a> case NOT_HANDSHAKING : </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new IllegalStateException ( </a> 1
<a> "Unknown handshake status: " + result . getHandshakeStatus ( ) ) ; </a> 1
<a> } </a> 0
<a> if ( result . bytesConsumed ( ) == 0 && result . bytesProduced ( ) == 0 ) { </a> 1
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( wrapLater ) { </a> 0
<a> flush ( ctx , ctx . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> } catch ( SSLException e ) { </a> 0
<a> setHandshakeFailure ( e ) ; </a> 1
<a> throw e ; </a> 0
<a> } finally { </a> 1
<a> if ( bytesProduced > 0 ) { </a> 1
<a> in . discardReadBytes ( ) ; </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> private static short getShort ( ByteBuf buf , int offset ) { </a> 0
<a> return ( short ) ( buf . getByte ( offset ) < < 8 | buf . getByte ( offset + 1 ) & 0xFF ) ; </a> 0
<a> } </a> 0
<a> private static SSLEngineResult unwrap ( SSLEngine engine , ByteBuf in , ByteBuf out ) throws SSLException { </a> 1
<a> ByteBuffer in0 = in . nioBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 0
<a> ByteBuffer out0 = out . nioBuffer ( out . writerIndex ( ) , out . writableBytes ( ) ) ; </a> 0
<a> SSLEngineResult result = engine . unwrap ( in0 , out0 ) ; </a> 1
<a> in . skipBytes ( result . bytesConsumed ( ) ) ; </a> 1
<a> out . writerIndex ( out . writerIndex ( ) + result . bytesProduced ( ) ) ; </a> 0
<a> switch ( result . getStatus ( ) ) { </a> 0
<a> case BUFFER_OVERFLOW : </a> 0
<a> out . ensureWritableBytes ( engine . getSession ( ) . getApplicationBufferSize ( ) ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> return result ; </a> 0
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private void runDelegatedTasks ( ) { </a> 0
<a> for ( ; ; ) { </a> 0
<a> Runnable task = engine . getDelegatedTask ( ) ; </a> 0
<a> if ( task == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> delegatedTaskExecutor . execute ( task ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private void setHandshakeSuccess ( ) { </a> 0
<a> for ( ; ; ) { </a> 1
<a> ChannelFuture f = handshakeFutures . poll ( ) ; </a> 0
<a> if ( f == null ) { </a> 0
<a> break ; </a> 1
<a> } </a> 0
<a> f . setSuccess ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void setHandshakeFailure ( Throwable cause ) { </a> 1
<a> engine . closeOutbound ( ) ; </a> 0
<a> try { </a> 0
<a> engine . closeInbound ( ) ; </a> 0
<a> } catch ( SSLException e ) { </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( </a> 0
<a> "SSLEngine.closeInbound() raised an exception after " + </a> 0
<a> "a handshake failure." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( cause == null ) { </a> 0
<a> cause = new ClosedChannelException ( ) ; </a> 0
<a> } </a> 0
<a> for ( ; ; ) { </a> 1
<a> ChannelFuture f = handshakeFutures . poll ( ) ; </a> 0
<a> if ( f == null ) { </a> 0
<a> break ; </a> 1
<a> } </a> 1
<a> f . setFailure ( cause ) ; </a> 0
<a> } </a> 1
<a> flush0 ( ctx , 0 , cause ) ; </a> 1
<a> } </a> 0
<a> private void closeOutboundAndChannel ( </a> 0
<a> final ChannelHandlerContext ctx , final ChannelFuture future , boolean disconnect ) throws Exception { </a> 0
<a> if ( ! ctx . channel ( ) . isActive ( ) ) { </a> 0
<a> if ( disconnect ) { </a> 0
<a> ctx . disconnect ( future ) ; </a> 0
<a> } else { </a> 0
<a> ctx . close ( future ) ; </a> 0
<a> } </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> engine . closeOutbound ( ) ; </a> 0
<a> ChannelFuture closeNotifyFuture = ctx . newFuture ( ) ; </a> 0
<a> flush ( ctx , closeNotifyFuture ) ; </a> 1
<a> safeClose ( ctx , closeNotifyFuture , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> this . ctx = ctx ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void afterAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> if ( ctx . channel ( ) . isActive ( ) ) { </a> 0
<a> handshake ( ) ; </a> 1
<a> } else { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( final ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> if ( ! startTls && engine . getUseClientMode ( ) ) { </a> 0
<a> handshake ( ) . addListener ( new ChannelFutureListener ( ) { </a> 1
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 1
<a> if ( ! future . isSuccess ( ) ) { </a> 0
<a> ctx . pipeline ( ) . fireExceptionCaught ( future . cause ( ) ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } else { </a> 0
<a> ctx . fireChannelActive ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } else { </a> 0
<a> ctx . fireChannelActive ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void safeClose ( </a> 0
<a> final ChannelHandlerContext ctx , ChannelFuture flushFuture , </a> 0
<a> final ChannelFuture closeFuture ) { </a> 0
<a> if ( ! ctx . channel ( ) . isActive ( ) ) { </a> 0
<a> ctx . close ( closeFuture ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> final ScheduledFuture < ? > timeoutFuture = ctx . executor ( ) . schedule ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> logger . warn ( </a> 1
<a> ctx . channel ( ) + " last lssssswrite attempt timed out." + </a> 1
<a> " Force-closing the connection." ) ; </a> 1
<a> ctx . close ( closeFuture ) ; </a> 0
<a> } </a> 0
<a> } , 3 , TimeUnit . SECONDS ) ; </a> 0
<a> flushFuture . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture f ) </a> 0
<a> throws Exception { </a> 0
<a> timeoutFuture . cancel ( false ) ; </a> 0
<a> if ( ctx . channel ( ) . isActive ( ) ) { </a> 0
<a> ctx . close ( closeFuture ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private final class SSLEngineInboundCloseFuture extends DefaultChannelFuture { </a> 0
<a> public SSLEngineInboundCloseFuture ( ) { </a> 1
<a> super ( null , true ) ; </a> 0
<a> } </a> 1
<a> void setClosed ( ) { </a> 1
<a> super . setSuccess ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public Channel channel ( ) { </a> 1
<a> if ( ctx == null ) { </a> 0
<a> return null ; </a> 1
<a> } else { </a> 1
<a> return ctx . channel ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean setSuccess ( ) { </a> 0
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean setFailure ( Throwable cause ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . stream ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import java . util . Queue ; </a> 0
<a> public interface ChunkedMessageInput < T > extends ChunkedInput < MessageBuf < T > > { </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . timeout ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> public class IdleStateEvent { </a> 0
<a> private final IdleState state ; </a> 0
<a> private final int count ; </a> 0
<a> private final long durationMillis ; </a> 0
<a> public IdleStateEvent ( IdleState state , int count , long durationMillis ) { </a> 0
<a> if ( state == null ) { </a> 0
<a> throw new NullPointerException ( "state" ) ; </a> 0
<a> } </a> 0
<a> if ( count < 0 ) { </a> 0
<a> throw new IllegalStateException ( String . format ( "count: %d (expected: >= 0)" , count ) ) ; </a> 0
<a> } </a> 0
<a> if ( durationMillis < 0 ) { </a> 0
<a> throw new IllegalStateException ( String . format ( </a> 0
<a> "durationMillis: %d (expected: >= 0)" , durationMillis ) ) ; </a> 0
<a> } </a> 0
<a> this . state = state ; </a> 0
<a> this . count = count ; </a> 0
<a> this . durationMillis = durationMillis ; </a> 0
<a> } </a> 0
<a> public IdleState state ( ) { </a> 0
<a> return state ; </a> 0
<a> } </a> 0
<a> public int count ( ) { </a> 0
<a> return count ; </a> 0
<a> } </a> 0
<a> public long durationMillis ( ) { </a> 0
<a> return durationMillis ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return state + "(" + count + ", " + durationMillis + "ms)" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . timeout ; </a> 0
<a> public final class ReadTimeoutException extends TimeoutException { </a> 0
<a> private static final long serialVersionUID = 169287984113283421L ; </a> 0
<a> public static final ReadTimeoutException INSTANCE = new ReadTimeoutException ( ) ; </a> 0
<a> private ReadTimeoutException ( ) { } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . timeout ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> public class TimeoutException extends ChannelException { </a> 0
<a> private static final long serialVersionUID = 4673641882869672533L ; </a> 0
<a> TimeoutException ( ) { } </a> 0
<a> @ Override </a> 0
<a> public Throwable fillInStackTrace ( ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . stream ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import io . netty . channel . embedded . EmbeddedMessageChannel ; </a> 1
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . io . ByteArrayInputStream ; </a> 0
<a> import java . io . File ; </a> 0
<a> import java . io . FileOutputStream ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . nio . channels . Channels ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> import junit . framework . Assert ; </a> 1
<a> import org . junit . Test ; </a> 0
<a> public class ChunkedWriteHandlerTest { </a> 0
<a> private static final byte [ ] BYTES = new byte [ 1024 * 64 ] ; </a> 0
<a> private static final File TMP ; </a> 0
<a> static { </a> 0
<a> for ( int i = 0 ; i < BYTES . length ; i ++ ) { </a> 0
<a> BYTES [ i ] = ( byte ) i ; </a> 0
<a> } </a> 0
<a> FileOutputStream out = null ; </a> 0
<a> try { </a> 0
<a> TMP = File . createTempFile ( "netty-chunk-" , ".tmp" ) ; </a> 0
<a> TMP . deleteOnExit ( ) ; </a> 0
<a> out = new FileOutputStream ( TMP ) ; </a> 0
<a> out . write ( BYTES ) ; </a> 0
<a> out . flush ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new RuntimeException ( e ) ; </a> 0
<a> } finally { </a> 0
<a> if ( out != null ) { </a> 0
<a> try { </a> 0
<a> out . close ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testChunkedStream ( ) { </a> 0
<a> check ( new ChunkedStream ( new ByteArrayInputStream ( BYTES ) ) ) ; </a> 0
<a> check ( new ChunkedStream ( new ByteArrayInputStream ( BYTES ) ) , new ChunkedStream ( new ByteArrayInputStream ( BYTES ) ) , new ChunkedStream ( new ByteArrayInputStream ( BYTES ) ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testChunkedNioStream ( ) { </a> 0
<a> check ( new ChunkedNioStream ( Channels . newChannel ( new ByteArrayInputStream ( BYTES ) ) ) ) ; </a> 0
<a> check ( new ChunkedNioStream ( Channels . newChannel ( new ByteArrayInputStream ( BYTES ) ) ) , new ChunkedNioStream ( Channels . newChannel ( new ByteArrayInputStream ( BYTES ) ) ) , new ChunkedNioStream ( Channels . newChannel ( new ByteArrayInputStream ( BYTES ) ) ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testChunkedFile ( ) throws IOException { </a> 0
<a> check ( new ChunkedFile ( TMP ) ) ; </a> 0
<a> check ( new ChunkedFile ( TMP ) , new ChunkedFile ( TMP ) , new ChunkedFile ( TMP ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testChunkedNioFile ( ) throws IOException { </a> 0
<a> check ( new ChunkedNioFile ( TMP ) ) ; </a> 0
<a> check ( new ChunkedNioFile ( TMP ) , new ChunkedNioFile ( TMP ) , new ChunkedNioFile ( TMP ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testListenerNotifiedWhenIsEnd ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copiedBuffer ( "Test" , CharsetUtil . ISO_8859_1 ) ; </a> 0
<a> ChunkedByteInput input = new ChunkedByteInput ( ) { </a> 0
<a> private boolean done ; </a> 0
<a> private final ByteBuf buffer = Unpooled . copiedBuffer ( "Test" , CharsetUtil . ISO_8859_1 ) ; </a> 1
<a> @ Override </a> 0
<a> public boolean isEndOfInput ( ) throws Exception { </a> 0
<a> return done ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readChunk ( ByteBuf buffer ) throws Exception { </a> 0
<a> if ( done ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> done = true ; </a> 0
<a> buffer . writeBytes ( this . buffer . duplicate ( ) ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> final AtomicBoolean listenerNotified = new AtomicBoolean ( false ) ; </a> 0
<a> final ChannelFutureListener listener = new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 0
<a> listenerNotified . set ( true ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( new ChunkedWriteHandler ( ) ) ; </a> 1
<a> ch . outboundMessageBuffer ( ) . add ( input ) ; </a> 1
<a> ch . flush ( ) . addListener ( listener ) . syncUninterruptibly ( ) ; </a> 1
<a> ch . checkException ( ) ; </a> 0
<a> ch . finish ( ) ; </a> 0
<a> assertTrue ( listenerNotified . get ( ) ) ; </a> 0
<a> assertEquals ( buffer , ch . readOutbound ( ) ) ; </a> 1
<a> assertNull ( ch . readOutbound ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testChunkedMessageInput ( ) { </a> 0
<a> ChunkedMessageInput < Object > input = new ChunkedMessageInput < Object > ( ) { </a> 0
<a> private boolean done ; </a> 0
<a> @ Override </a> 0
<a> public boolean isEndOfInput ( ) throws Exception { </a> 0
<a> return done ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readChunk ( MessageBuf < Object > buffer ) throws Exception { </a> 1
<a> if ( done ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> done = true ; </a> 0
<a> buffer . add ( 0 ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> EmbeddedMessageChannel ch = new EmbeddedMessageChannel ( new ChunkedWriteHandler ( ) ) ; </a> 1
<a> ch . outboundMessageBuffer ( ) . add ( input ) ; </a> 1
<a> ch . flush ( ) . syncUninterruptibly ( ) ; </a> 1
<a> ch . checkException ( ) ; </a> 0
<a> assertTrue ( ch . finish ( ) ) ; </a> 0
<a> assertEquals ( 0 , ch . readOutbound ( ) ) ; </a> 0
<a> assertNull ( ch . readOutbound ( ) ) ; </a> 0
<a> } </a> 0
<a> private static void check ( ChunkedInput < ? > ... inputs ) { </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( new ChunkedWriteHandler ( ) ) ; </a> 1
<a> for ( ChunkedInput < ? > input : inputs ) { </a> 0
<a> ch . writeOutbound ( input ) ; </a> 0
<a> } </a> 0
<a> Assert . assertTrue ( ch . finish ( ) ) ; </a> 1
<a> int i = 0 ; </a> 0
<a> int read = 0 ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> ByteBuf buffer = ch . readOutbound ( ) ; </a> 1
<a> if ( buffer == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> while ( buffer . readable ( ) ) { </a> 0
<a> Assert . assertEquals ( BYTES [ i ++ ] , buffer . readByte ( ) ) ; </a> 1
<a> read ++ ; </a> 0
<a> if ( i == BYTES . length ) { </a> 0
<a> i = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Assert . assertEquals ( BYTES . length * inputs . length , read ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . transport . socket ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . testsuite . transport . socket . SocketTestPermutation . Factory ; </a> 0
<a> import io . netty . testsuite . util . TestUtils ; </a> 0
<a> import io . netty . util . NetworkConstants ; </a> 0
<a> import java . lang . reflect . InvocationTargetException ; </a> 0
<a> import java . lang . reflect . Method ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> import org . junit . Rule ; </a> 0
<a> import org . junit . rules . TestName ; </a> 0
<a> public abstract class AbstractDatagramTest { </a> 0
<a> private static final List < Entry < Factory < Bootstrap > , Factory < Bootstrap > > > COMBO = </a> 0
<a> SocketTestPermutation . datagram ( ) ; </a> 0
<a> @ Rule </a> 0
<a> public final TestName testName = new TestName ( ) ; </a> 0
<a> protected final InternalLogger logger = InternalLoggerFactory . getInstance ( getClass ( ) ) ; </a> 0
<a> protected volatile Bootstrap sb ; </a> 0
<a> protected volatile Bootstrap cb ; </a> 0
<a> protected volatile InetSocketAddress addr ; </a> 0
<a> protected void run ( ) throws Throwable { </a> 0
<a> int i = 0 ; </a> 0
<a> for ( Entry < Factory < Bootstrap > , Factory < Bootstrap > > e : COMBO ) { </a> 0
<a> sb = e . getKey ( ) . newInstance ( ) ; </a> 0
<a> cb = e . getValue ( ) . newInstance ( ) ; </a> 0
<a> addr = new InetSocketAddress ( </a> 0
<a> NetworkConstants . LOCALHOST , TestUtils . getFreePort ( ) ) ; </a> 0
<a> sb . localAddress ( addr ) ; </a> 0
<a> cb . localAddress ( 0 ) . remoteAddress ( addr ) ; </a> 0
<a> logger . info ( String . format ( </a> 0
<a> "Running: %s %d of %d" , testName . getMethodName ( ) , ++ i , COMBO . size ( ) ) ) ; </a> 0
<a> try { </a> 0
<a> Method m = getClass ( ) . getDeclaredMethod ( </a> 0
<a> testName . getMethodName ( ) , Bootstrap . class , Bootstrap . class ) ; </a> 0
<a> m . invoke ( this , sb , cb ) ; </a> 0
<a> } catch ( InvocationTargetException ex ) { </a> 0
<a> throw ex . getCause ( ) ; </a> 0
<a> } finally { </a> 0
<a> sb . shutdown ( ) ; </a> 0
<a> cb . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . transport . socket ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> import java . util . Random ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class SocketEchoTest extends AbstractSocketTest { </a> 0
<a> private static final Random random = new Random ( ) ; </a> 0
<a> static final byte [ ] data = new byte [ 1048576 ] ; </a> 0
<a> static { </a> 0
<a> random . nextBytes ( data ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSimpleEcho ( ) throws Throwable { </a> 0
<a> run ( ) ; </a> 0
<a> } </a> 0
<a> public void testSimpleEcho ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { </a> 0
<a> testSimpleEcho0 ( sb , cb , Integer . MAX_VALUE ) ; </a> 1
<a> } </a> 1
<a> @ Test </a> 1
<a> public void testSimpleEchoWithBoundedBuffer ( ) throws Throwable { </a> 1
<a> run ( ) ; </a> 1
<a> } </a> 1
<a> public void testSimpleEchoWithBoundedBuffer ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { </a> 1
<a> testSimpleEcho0 ( sb , cb , 32 ) ; </a> 1
<a> } </a> 1
<a> private static void testSimpleEcho0 ( ServerBootstrap sb , Bootstrap cb , int maxInboundBufferSize ) throws Throwable { </a> 1
<a> EchoHandler sh = new EchoHandler ( maxInboundBufferSize ) ; </a> 1
<a> EchoHandler ch = new EchoHandler ( maxInboundBufferSize ) ; </a> 1
<a> sb . childHandler ( sh ) ; </a> 0
<a> cb . handler ( ch ) ; </a> 0
<a> Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> Channel cc = cb . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> for ( int i = 0 ; i < data . length ; ) { </a> 0
<a> int length = Math . min ( random . nextInt ( 1024 * 64 ) , data . length - i ) ; </a> 0
<a> cc . write ( Unpooled . wrappedBuffer ( data , i , length ) ) ; </a> 0
<a> i += length ; </a> 0
<a> } </a> 0
<a> while ( ch . counter < data . length ) { </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> while ( sh . counter < data . length ) { </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> sh . channel . close ( ) . sync ( ) ; </a> 0
<a> ch . channel . close ( ) . sync ( ) ; </a> 0
<a> sc . close ( ) . sync ( ) ; </a> 0
<a> if ( sh . exception . get ( ) != null && ! ( sh . exception . get ( ) instanceof IOException ) ) { </a> 0
<a> throw sh . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null && ! ( ch . exception . get ( ) instanceof IOException ) ) { </a> 0
<a> throw ch . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> throw sh . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> throw ch . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class EchoHandler extends ChannelInboundByteHandlerAdapter { </a> 1
<a> private final int maxInboundBufferSize ; </a> 1
<a> volatile Channel channel ; </a> 0
<a> final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 0
<a> volatile int counter ; </a> 0
<a> EchoHandler ( int maxInboundBufferSize ) { </a> 1
<a> this . maxInboundBufferSize = maxInboundBufferSize ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . buffer ( 0 , maxInboundBufferSize ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) </a> 0
<a> throws Exception { </a> 0
<a> channel = ctx . channel ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( </a> 1
<a> ChannelHandlerContext ctx , ByteBuf in ) </a> 1
<a> throws Exception { </a> 1
<a> byte [ ] actual = new byte [ in . readableBytes ( ) ] ; </a> 0
<a> in . readBytes ( actual ) ; </a> 0
<a> int lastIdx = counter ; </a> 0
<a> for ( int i = 0 ; i < actual . length ; i ++ ) { </a> 0
<a> assertEquals ( data [ i + lastIdx ] , actual [ i ] ) ; </a> 0
<a> } </a> 0
<a> if ( channel . parent ( ) != null ) { </a> 0
<a> channel . write ( Unpooled . wrappedBuffer ( actual ) ) ; </a> 0
<a> } </a> 0
<a> counter += actual . length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , </a> 0
<a> Throwable cause ) throws Exception { </a> 0
<a> if ( exception . compareAndSet ( null , cause ) ) { </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . transport . socket ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . DelimiterBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . Delimiters ; </a> 0
<a> import io . netty . handler . codec . string . StringDecoder ; </a> 0
<a> import io . netty . handler . codec . string . StringEncoder ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . Random ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class SocketStringEchoTest extends AbstractSocketTest { </a> 0
<a> static final Random random = new Random ( ) ; </a> 0
<a> static final String [ ] data = new String [ 1024 ] ; </a> 0
<a> static { </a> 0
<a> for ( int i = 0 ; i < data . length ; i ++ ) { </a> 0
<a> int eLen = random . nextInt ( 512 ) ; </a> 0
<a> char [ ] e = new char [ eLen ] ; </a> 0
<a> for ( int j = 0 ; j < eLen ; j ++ ) { </a> 0
<a> e [ j ] = ( char ) ( 'a' + random . nextInt ( 26 ) ) ; </a> 0
<a> } </a> 0
<a> data [ i ] = new String ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testStringEcho ( ) throws Throwable { </a> 0
<a> run ( ) ; </a> 0
<a> } </a> 0
<a> public void testStringEcho ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { </a> 0
<a> final StringEchoHandler sh = new StringEchoHandler ( ) ; </a> 1
<a> final StringEchoHandler ch = new StringEchoHandler ( ) ; </a> 1
<a> sb . childHandler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel sch ) throws Exception { </a> 0
<a> sch . pipeline ( ) . addLast ( "framer" , new DelimiterBasedFrameDecoder ( 512 , Delimiters . lineDelimiter ( ) ) ) ; </a> 0
<a> sch . pipeline ( ) . addLast ( "decoder" , new StringDecoder ( CharsetUtil . ISO_8859_1 ) ) ; </a> 0
<a> sch . pipeline ( ) . addBefore ( "decoder" , "encoder" , new StringEncoder ( CharsetUtil . ISO_8859_1 ) ) ; </a> 0
<a> sch . pipeline ( ) . addAfter ( "decoder" , "handler" , sh ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> cb . handler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel sch ) throws Exception { </a> 0
<a> sch . pipeline ( ) . addLast ( "framer" , new DelimiterBasedFrameDecoder ( 512 , Delimiters . lineDelimiter ( ) ) ) ; </a> 0
<a> sch . pipeline ( ) . addLast ( "decoder" , new StringDecoder ( CharsetUtil . ISO_8859_1 ) ) ; </a> 0
<a> sch . pipeline ( ) . addBefore ( "decoder" , "encoder" , new StringEncoder ( CharsetUtil . ISO_8859_1 ) ) ; </a> 0
<a> sch . pipeline ( ) . addAfter ( "decoder" , "handler" , ch ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> Channel cc = cb . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> for ( String element : data ) { </a> 0
<a> String delimiter = random . nextBoolean ( ) ? "\r\n" : "\n" ; </a> 0
<a> cc . write ( element + delimiter ) ; </a> 0
<a> } </a> 0
<a> while ( ch . counter < data . length ) { </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> while ( sh . counter < data . length ) { </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> sh . channel . close ( ) . sync ( ) ; </a> 0
<a> ch . channel . close ( ) . sync ( ) ; </a> 0
<a> sc . close ( ) . sync ( ) ; </a> 0
<a> if ( sh . exception . get ( ) != null && ! ( sh . exception . get ( ) instanceof IOException ) ) { </a> 0
<a> throw sh . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null && ! ( ch . exception . get ( ) instanceof IOException ) ) { </a> 0
<a> throw ch . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> throw sh . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> throw ch . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static class StringEchoHandler extends ChannelInboundMessageHandlerAdapter < String > { </a> 1
<a> volatile Channel channel ; </a> 0
<a> final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 0
<a> volatile int counter ; </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) </a> 0
<a> throws Exception { </a> 0
<a> channel = ctx . channel ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , </a> 1
<a> String msg ) throws Exception { </a> 1
<a> assertEquals ( data [ counter ] , msg ) ; </a> 0
<a> if ( channel . parent ( ) != null ) { </a> 0
<a> String delimiter = random . nextBoolean ( ) ? "\r\n" : "\n" ; </a> 0
<a> channel . write ( msg + delimiter ) ; </a> 0
<a> } </a> 0
<a> counter ++ ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , </a> 0
<a> Throwable cause ) throws Exception { </a> 0
<a> if ( exception . compareAndSet ( null , cause ) ) { </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public class BlockingOperationException extends IllegalStateException { </a> 0
<a> private static final long serialVersionUID = 2462223247762460301L ; </a> 0
<a> public BlockingOperationException ( ) { } </a> 0
<a> public BlockingOperationException ( String s ) { </a> 0
<a> super ( s ) ; </a> 0
<a> } </a> 0
<a> public BlockingOperationException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> public BlockingOperationException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . ArrayDeque ; </a> 0
<a> import java . util . Queue ; </a> 0
<a> public class ChannelFlushFutureNotifier { </a> 0
<a> private long writeCounter ; </a> 0
<a> private final Queue < FlushCheckpoint > flushCheckpoints = new ArrayDeque < FlushCheckpoint > ( ) ; </a> 0
<a> public void addFlushFuture ( ChannelFuture future , int pendingDataSize ) { </a> 0
<a> long checkpoint = writeCounter + pendingDataSize ; </a> 0
<a> if ( future instanceof FlushCheckpoint ) { </a> 0
<a> FlushCheckpoint cp = ( FlushCheckpoint ) future ; </a> 0
<a> cp . flushCheckpoint ( checkpoint ) ; </a> 0
<a> flushCheckpoints . add ( cp ) ; </a> 0
<a> } else { </a> 0
<a> flushCheckpoints . add ( new DefaultFlushCheckpoint ( checkpoint , future ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void increaseWriteCounter ( long delta ) { </a> 0
<a> writeCounter += delta ; </a> 0
<a> } </a> 0
<a> public void notifyFlushFutures ( ) { </a> 0
<a> notifyFlushFutures0 ( null ) ; </a> 0
<a> } </a> 0
<a> public void notifyFlushFutures ( Throwable cause ) { </a> 0
<a> notifyFlushFutures ( ) ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> FlushCheckpoint cp = flushCheckpoints . poll ( ) ; </a> 0
<a> if ( cp == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> cp . future ( ) . setFailure ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void notifyFlushFutures ( Throwable cause1 , Throwable cause2 ) { </a> 0
<a> notifyFlushFutures0 ( cause1 ) ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> FlushCheckpoint cp = flushCheckpoints . poll ( ) ; </a> 0
<a> if ( cp == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> cp . future ( ) . setFailure ( cause2 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void notifyFlushFutures0 ( Throwable cause ) { </a> 0
<a> if ( flushCheckpoints . isEmpty ( ) ) { </a> 0
<a> writeCounter = 0 ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> final long writeCounter = this . writeCounter ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> FlushCheckpoint cp = flushCheckpoints . peek ( ) ; </a> 0
<a> if ( cp == null ) { </a> 0
<a> this . writeCounter = 0 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( cp . flushCheckpoint ( ) > writeCounter ) { </a> 0
<a> if ( writeCounter > 0 && flushCheckpoints . size ( ) == 1 ) { </a> 0
<a> this . writeCounter = 0 ; </a> 0
<a> cp . flushCheckpoint ( cp . flushCheckpoint ( ) - writeCounter ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> flushCheckpoints . remove ( ) ; </a> 0
<a> if ( cause == null ) { </a> 0
<a> cp . future ( ) . setSuccess ( ) ; </a> 0
<a> } else { </a> 0
<a> cp . future ( ) . setFailure ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> final long newWriteCounter = this . writeCounter ; </a> 0
<a> if ( newWriteCounter >= 0x1000000000000000L ) { </a> 0
<a> this . writeCounter = 0 ; </a> 0
<a> for ( FlushCheckpoint cp : flushCheckpoints ) { </a> 0
<a> cp . flushCheckpoint ( cp . flushCheckpoint ( ) - newWriteCounter ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> abstract static class FlushCheckpoint { </a> 0
<a> abstract long flushCheckpoint ( ) ; </a> 0
<a> abstract void flushCheckpoint ( long checkpoint ) ; </a> 0
<a> abstract ChannelFuture future ( ) ; </a> 0
<a> } </a> 0
<a> private static class DefaultFlushCheckpoint extends FlushCheckpoint { </a> 0
<a> private long checkpoint ; </a> 0
<a> private final ChannelFuture future ; </a> 0
<a> DefaultFlushCheckpoint ( long checkpoint , ChannelFuture future ) { </a> 0
<a> this . checkpoint = checkpoint ; </a> 0
<a> this . future = future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> long flushCheckpoint ( ) { </a> 0
<a> return checkpoint ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void flushCheckpoint ( long checkpoint ) { </a> 0
<a> this . checkpoint = checkpoint ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> ChannelFuture future ( ) { </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public interface ChannelFutureFactory { </a> 1
<a> ChannelFuture newFuture ( ) ; </a> 1
<a> ChannelFuture newSucceededFuture ( ) ; </a> 1
<a> ChannelFuture newFailedFuture ( Throwable cause ) ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . util . UniqueName ; </a> 1
<a> import java . net . InetAddress ; </a> 0
<a> import java . net . NetworkInterface ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import java . util . concurrent . ConcurrentMap ; </a> 1
<a> public class ChannelOption < T > extends UniqueName { </a> 1
<a> private static final ConcurrentMap < String , Boolean > names = new ConcurrentHashMap < String , Boolean > ( ) ; </a> 1
<a> public static final ChannelOption < Integer > CONNECT_TIMEOUT_MILLIS = </a> 1
<a> new ChannelOption < Integer > ( "CONNECT_TIMEOUT_MILLIS" ) ; </a> 1
<a> public static final ChannelOption < Integer > WRITE_SPIN_COUNT = </a> 1
<a> new ChannelOption < Integer > ( "WRITE_SPIN_COUNT" ) ; </a> 1
<a> public static final ChannelOption < Boolean > SO_BROADCAST = </a> 1
<a> new ChannelOption < Boolean > ( "SO_BROADCAST" ) ; </a> 1
<a> public static final ChannelOption < Boolean > SO_KEEPALIVE = </a> 1
<a> new ChannelOption < Boolean > ( "SO_KEEPALIVE" ) ; </a> 1
<a> public static final ChannelOption < Integer > SO_SNDBUF = </a> 1
<a> new ChannelOption < Integer > ( "SO_SNDBUF" ) ; </a> 1
<a> public static final ChannelOption < Integer > SO_RCVBUF = </a> 1
<a> new ChannelOption < Integer > ( "SO_RCVBUF" ) ; </a> 1
<a> public static final ChannelOption < Boolean > SO_REUSEADDR = </a> 1
<a> new ChannelOption < Boolean > ( "SO_REUSEADDR" ) ; </a> 1
<a> public static final ChannelOption < Integer > SO_LINGER = </a> 1
<a> new ChannelOption < Integer > ( "SO_LINGER" ) ; </a> 1
<a> public static final ChannelOption < Integer > SO_BACKLOG = </a> 1
<a> new ChannelOption < Integer > ( "SO_BACKLOG" ) ; </a> 1
<a> public static final ChannelOption < Integer > IP_TOS = </a> 1
<a> new ChannelOption < Integer > ( "IP_TOS" ) ; </a> 1
<a> public static final ChannelOption < InetAddress > IP_MULTICAST_ADDR = </a> 1
<a> new ChannelOption < InetAddress > ( "IP_MULTICAST_ADDR" ) ; </a> 1
<a> public static final ChannelOption < NetworkInterface > IP_MULTICAST_IF = </a> 1
<a> new ChannelOption < NetworkInterface > ( "IP_MULTICAST_IF" ) ; </a> 1
<a> public static final ChannelOption < Integer > IP_MULTICAST_TTL = </a> 1
<a> new ChannelOption < Integer > ( "IP_MULTICAST_TTL" ) ; </a> 1
<a> public static final ChannelOption < Boolean > IP_MULTICAST_LOOP_DISABLED = </a> 1
<a> new ChannelOption < Boolean > ( "IP_MULTICAST_LOOP_DISABLED" ) ; </a> 1
<a> public static final ChannelOption < Integer > UDP_RECEIVE_PACKET_SIZE = </a> 1
<a> new ChannelOption < Integer > ( "UDP_RECEIVE_PACKET_SIZE" ) ; </a> 1
<a> public static final ChannelOption < Boolean > TCP_NODELAY = </a> 1
<a> new ChannelOption < Boolean > ( "TCP_NODELAY" ) ; </a> 1
<a> public static final ChannelOption < Boolean > SCTP_DISABLE_FRAGMENTS = </a> 0
<a> new ChannelOption < Boolean > ( "SCTP_DISABLE_FRAGMENTS" ) ; </a> 0
<a> public static final ChannelOption < Boolean > SCTP_EXPLICIT_COMPLETE = </a> 0
<a> new ChannelOption < Boolean > ( "SCTP_EXPLICIT_COMPLETE" ) ; </a> 0
<a> public static final ChannelOption < Integer > SCTP_FRAGMENT_INTERLEAVE = </a> 0
<a> new ChannelOption < Integer > ( "SCTP_FRAGMENT_INTERLEAVE" ) ; </a> 0
<a> public static final ChannelOption < List < Integer > > SCTP_INIT_MAXSTREAMS = </a> 0
<a> new ChannelOption < List < Integer > > ( "SCTP_INIT_MAXSTREAMS" ) { </a> 0
<a> @ Override </a> 1
<a> public void validate ( List < Integer > value ) { </a> 1
<a> super . validate ( value ) ; </a> 1
<a> if ( value . size ( ) != 2 ) { </a> 1
<a> throw new IllegalArgumentException ( "value must be a List of 2 Integers: " + value ) ; </a> 1
<a> } </a> 1
<a> if ( value . get ( 0 ) == null ) { </a> 1
<a> throw new NullPointerException ( "value[0]" ) ; </a> 1
<a> } </a> 1
<a> if ( value . get ( 1 ) == null ) { </a> 1
<a> throw new NullPointerException ( "value[1]" ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> public static final ChannelOption < Boolean > SCTP_NODELAY = </a> 0
<a> new ChannelOption < Boolean > ( "SCTP_NODELAY" ) ; </a> 0
<a> public static final ChannelOption < SocketAddress > SCTP_PRIMARY_ADDR = </a> 0
<a> new ChannelOption < SocketAddress > ( "SCTP_PRIMARY_ADDR" ) ; </a> 0
<a> public static final ChannelOption < SocketAddress > SCTP_SET_PEER_PRIMARY_ADDR = </a> 0
<a> new ChannelOption < SocketAddress > ( "SCTP_SET_PEER_PRIMARY_ADDR" ) ; </a> 0
<a> public static final ChannelOption < Long > AIO_READ_TIMEOUT = </a> 0
<a> new ChannelOption < Long > ( "AIO_READ_TIMEOUT" ) ; </a> 0
<a> public static final ChannelOption < Long > AIO_WRITE_TIMEOUT = </a> 0
<a> new ChannelOption < Long > ( "AIO_WRITE_TIMEOUT" ) ; </a> 0
<a> public ChannelOption ( String name ) { </a> 0
<a> super ( names , name ) ; </a> 1
<a> } </a> 0
<a> public void validate ( T value ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( "value" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ChannelBuf ; </a> 1
<a> public interface ChannelOutboundHandler extends ChannelOperationHandler { </a> 0
<a> ChannelBuf newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> public interface ChannelOutboundMessageHandler < I > extends ChannelOutboundHandler { </a> 1
<a> @ Override </a> 1
<a> MessageBuf < I > newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import static io . netty . channel . DefaultChannelHandlerContext . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . ChannelBuf ; </a> 1
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . DefaultChannelHandlerContext . ByteBridge ; </a> 0
<a> import io . netty . channel . DefaultChannelHandlerContext . MessageBridge ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . IdentityHashMap ; </a> 0
<a> import java . util . LinkedHashMap ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . NoSuchElementException ; </a> 0
<a> import java . util . concurrent . Future ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 1
<a> public class DefaultChannelPipeline implements ChannelPipeline { </a> 0
<a> static final InternalLogger logger = InternalLoggerFactory . getInstance ( DefaultChannelPipeline . class ) ; </a> 0
<a> final Channel channel ; </a> 1
<a> private final Channel . Unsafe unsafe ; </a> 1
<a> final DefaultChannelHandlerContext head ; </a> 0
<a> private volatile DefaultChannelHandlerContext tail ; </a> 0
<a> private final Map < String , DefaultChannelHandlerContext > name2ctx = </a> 0
<a> new HashMap < String , DefaultChannelHandlerContext > ( 4 ) ; </a> 0
<a> private boolean firedChannelActive ; </a> 1
<a> private boolean fireInboundBufferUpdatedOnActivation ; </a> 1
<a> final Map < EventExecutorGroup , EventExecutor > childExecutors = </a> 1
<a> new IdentityHashMap < EventExecutorGroup , EventExecutor > ( ) ; </a> 1
<a> private final AtomicInteger suspendRead = new AtomicInteger ( ) ; </a> 1
<a> public DefaultChannelPipeline ( Channel channel ) { </a> 1
<a> if ( channel == null ) { </a> 1
<a> throw new NullPointerException ( "channel" ) ; </a> 1
<a> } </a> 1
<a> this . channel = channel ; </a> 0
<a> HeadHandler headHandler = new HeadHandler ( ) ; </a> 0
<a> head = new DefaultChannelHandlerContext ( </a> 0
<a> this , null , null , null , generateName ( headHandler ) , headHandler ) ; </a> 0
<a> tail = head ; </a> 0
<a> unsafe = channel . unsafe ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Channel channel ( ) { </a> 0
<a> return channel ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline addFirst ( String name , ChannelHandler handler ) { </a> 0
<a> return addFirst ( null , name , handler ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline addFirst ( EventExecutorGroup group , final String name , final ChannelHandler handler ) { </a> 0
<a> try { </a> 0
<a> Future < Throwable > future ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> checkDuplicateName ( name ) ; </a> 0
<a> final DefaultChannelHandlerContext nextCtx = head . next ; </a> 0
<a> final DefaultChannelHandlerContext newCtx = </a> 0
<a> new DefaultChannelHandlerContext ( this , group , head , nextCtx , name , handler ) ; </a> 0
<a> if ( ! newCtx . channel ( ) . isRegistered ( ) || newCtx . executor ( ) . inEventLoop ( ) ) { </a> 1
<a> addFirst0 ( name , nextCtx , newCtx ) ; </a> 0
<a> return this ; </a> 1
<a> } </a> 0
<a> future = newCtx . executor ( ) . submit ( new DefaultChannelPipelineModificationTask ( this ) { </a> 0
<a> @ Override </a> 1
<a> void doCall ( ) { </a> 0
<a> checkDuplicateName ( name ) ; </a> 1
<a> addFirst0 ( name , nextCtx , newCtx ) ; </a> 0
<a> } </a> 1
<a> } ) ; </a> 0
<a> } </a> 0
<a> Throwable result = future . get ( ) ; </a> 0
<a> if ( result != null ) { </a> 0
<a> throw result ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } catch ( RuntimeException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Error e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> throw new ChannelPipelineException ( t ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<a> private void addFirst0 ( </a> 0
<a> final String name , DefaultChannelHandlerContext nextCtx , DefaultChannelHandlerContext newCtx ) { </a> 0
<a> callBeforeAdd ( newCtx ) ; </a> 0
<a> if ( nextCtx != null ) { </a> 0
<a> nextCtx . prev = newCtx ; </a> 0
<a> } </a> 0
<a> head . next = newCtx ; </a> 0
<a> name2ctx . put ( name , newCtx ) ; </a> 1
<a> callAfterAdd ( newCtx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline addLast ( String name , ChannelHandler handler ) { </a> 0
<a> return addLast ( null , name , handler ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline addLast ( EventExecutorGroup group , final String name , final ChannelHandler handler ) { </a> 0
<a> try { </a> 0
<a> Future < Throwable > future ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> checkDuplicateName ( name ) ; </a> 0
<a> final DefaultChannelHandlerContext oldTail = tail ; </a> 0
<a> final DefaultChannelHandlerContext newTail = </a> 0
<a> new DefaultChannelHandlerContext ( this , group , oldTail , null , name , handler ) ; </a> 0
<a> if ( ! newTail . channel ( ) . isRegistered ( ) || newTail . executor ( ) . inEventLoop ( ) ) { </a> 0
<a> addLast0 ( name , oldTail , newTail ) ; </a> 0
<a> return this ; </a> 1
<a> } else { </a> 0
<a> future = newTail . executor ( ) . submit ( new DefaultChannelPipelineModificationTask ( this ) { </a> 0
<a> @ Override </a> 1
<a> void doCall ( ) { </a> 0
<a> checkDuplicateName ( name ) ; </a> 1
<a> addLast0 ( name , oldTail , newTail ) ; </a> 0
<a> } </a> 1
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Throwable result = future . get ( ) ; </a> 0
<a> if ( result != null ) { </a> 0
<a> throw result ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } catch ( RuntimeException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Error e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> throw new ChannelPipelineException ( t ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<a> private void addLast0 ( </a> 0
<a> final String name , DefaultChannelHandlerContext oldTail , DefaultChannelHandlerContext newTail ) { </a> 0
<a> callBeforeAdd ( newTail ) ; </a> 0
<a> oldTail . next = newTail ; </a> 0
<a> tail = newTail ; </a> 0
<a> name2ctx . put ( name , newTail ) ; </a> 0
<a> callAfterAdd ( newTail ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline addBefore ( String baseName , String name , ChannelHandler handler ) { </a> 0
<a> return addBefore ( null , baseName , name , handler ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline addBefore ( </a> 0
<a> EventExecutorGroup group , String baseName , final String name , final ChannelHandler handler ) { </a> 0
<a> try { </a> 0
<a> Future < Throwable > future ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> final DefaultChannelHandlerContext ctx = getContextOrDie ( baseName ) ; </a> 0
<a> checkDuplicateName ( name ) ; </a> 1
<a> final DefaultChannelHandlerContext newCtx = </a> 0
<a> new DefaultChannelHandlerContext ( this , group , ctx . prev , ctx , name , handler ) ; </a> 0
<a> if ( ! newCtx . channel ( ) . isRegistered ( ) || newCtx . executor ( ) . inEventLoop ( ) ) { </a> 1
<a> addBefore0 ( name , ctx , newCtx ) ; </a> 1
<a> return this ; </a> 1
<a> } else { </a> 0
<a> future = newCtx . executor ( ) . submit ( new DefaultChannelPipelineModificationTask ( this ) { </a> 0
<a> @ Override </a> 1
<a> void doCall ( ) { </a> 0
<a> checkDuplicateName ( name ) ; </a> 0
<a> addBefore0 ( name , ctx , newCtx ) ; </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> Throwable result = future . get ( ) ; </a> 0
<a> if ( result != null ) { </a> 0
<a> throw result ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } catch ( RuntimeException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Error e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> throw new ChannelPipelineException ( t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void addBefore0 ( final String name , DefaultChannelHandlerContext ctx , DefaultChannelHandlerContext newCtx ) { </a> 0
<a> callBeforeAdd ( newCtx ) ; </a> 0
<a> ctx . prev . next = newCtx ; </a> 0
<a> ctx . prev = newCtx ; </a> 0
<a> name2ctx . put ( name , newCtx ) ; </a> 0
<a> callAfterAdd ( newCtx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline addAfter ( String baseName , String name , ChannelHandler handler ) { </a> 0
<a> return addAfter ( null , baseName , name , handler ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline addAfter ( </a> 0
<a> EventExecutorGroup group , String baseName , final String name , final ChannelHandler handler ) { </a> 0
<a> try { </a> 0
<a> Future < Throwable > future ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> final DefaultChannelHandlerContext ctx = getContextOrDie ( baseName ) ; </a> 0
<a> if ( ctx == tail ) { </a> 0
<a> return addLast ( name , handler ) ; </a> 0
<a> } </a> 0
<a> checkDuplicateName ( name ) ; </a> 0
<a> final DefaultChannelHandlerContext newCtx = </a> 0
<a> new DefaultChannelHandlerContext ( this , group , ctx , ctx . next , name , handler ) ; </a> 0
<a> if ( ! newCtx . channel ( ) . isRegistered ( ) || newCtx . executor ( ) . inEventLoop ( ) ) { </a> 1
<a> addAfter0 ( name , ctx , newCtx ) ; </a> 1
<a> return this ; </a> 1
<a> } else { </a> 0
<a> future = newCtx . executor ( ) . submit ( new DefaultChannelPipelineModificationTask ( this ) { </a> 0
<a> @ Override </a> 1
<a> void doCall ( ) { </a> 0
<a> checkDuplicateName ( name ) ; </a> 1
<a> addAfter0 ( name , ctx , newCtx ) ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Throwable result = future . get ( ) ; </a> 0
<a> if ( result != null ) { </a> 0
<a> throw result ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } catch ( RuntimeException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Error e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> throw new ChannelPipelineException ( t ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<a> private void addAfter0 ( final String name , DefaultChannelHandlerContext ctx , DefaultChannelHandlerContext newCtx ) { </a> 0
<a> checkDuplicateName ( name ) ; </a> 0
<a> callBeforeAdd ( newCtx ) ; </a> 0
<a> ctx . next . prev = newCtx ; </a> 0
<a> ctx . next = newCtx ; </a> 0
<a> name2ctx . put ( name , newCtx ) ; </a> 0
<a> callAfterAdd ( newCtx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline addFirst ( ChannelHandler ... handlers ) { </a> 0
<a> return addFirst ( null , handlers ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline addFirst ( EventExecutorGroup executor , ChannelHandler ... handlers ) { </a> 1
<a> if ( handlers == null ) { </a> 0
<a> throw new NullPointerException ( "handlers" ) ; </a> 0
<a> } </a> 0
<a> if ( handlers . length == 0 || handlers [ 0 ] == null ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> int size ; </a> 0
<a> for ( size = 1 ; size < handlers . length ; size ++ ) { </a> 0
<a> if ( handlers [ size ] == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( int i = size - 1 ; i >= 0 ; i -- ) { </a> 0
<a> ChannelHandler h = handlers [ i ] ; </a> 0
<a> addFirst ( executor , generateName ( h ) , h ) ; </a> 1
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline addLast ( ChannelHandler ... handlers ) { </a> 0
<a> return addLast ( null , handlers ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline addLast ( EventExecutorGroup executor , ChannelHandler ... handlers ) { </a> 1
<a> if ( handlers == null ) { </a> 1
<a> throw new NullPointerException ( "handlers" ) ; </a> 1
<a> } </a> 1
<a> for ( ChannelHandler h : handlers ) { </a> 0
<a> if ( h == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> addLast ( executor , generateName ( h ) , h ) ; </a> 1
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> private static String generateName ( ChannelHandler handler ) { </a> 1
<a> String type = handler . getClass ( ) . getSimpleName ( ) ; </a> 0
<a> StringBuilder buf = new StringBuilder ( type . length ( ) + 10 ) ; </a> 0
<a> buf . append ( type ) ; </a> 0
<a> buf . append ( "-0" ) ; </a> 0
<a> buf . append ( Long . toHexString ( System . identityHashCode ( handler ) & 0xFFFFFFFFL | 0x100000000L ) ) ; </a> 0
<a> buf . setCharAt ( buf . length ( ) - 9 , 'x' ) ; </a> 0
<a> return buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void remove ( ChannelHandler handler ) { </a> 0
<a> remove ( getContextOrDie ( handler ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelHandler remove ( String name ) { </a> 0
<a> return remove ( getContextOrDie ( name ) ) . handler ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T extends ChannelHandler > T remove ( Class < T > handlerType ) { </a> 0
<a> return ( T ) remove ( getContextOrDie ( handlerType ) ) . handler ( ) ; </a> 0
<a> } </a> 0
<a> private DefaultChannelHandlerContext remove ( final DefaultChannelHandlerContext ctx ) { </a> 0
<a> try { </a> 0
<a> DefaultChannelHandlerContext context ; </a> 0
<a> Future < Throwable > future ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( head == tail ) { </a> 0
<a> return null ; </a> 0
<a> } else if ( ctx == head ) { </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } else if ( ctx == tail ) { </a> 0
<a> if ( head == tail ) { </a> 0
<a> throw new NoSuchElementException ( ) ; </a> 0
<a> } </a> 0
<a> final DefaultChannelHandlerContext oldTail = tail ; </a> 0
<a> if ( ! oldTail . channel ( ) . isRegistered ( ) || oldTail . executor ( ) . inEventLoop ( ) ) { </a> 0
<a> removeLast0 ( oldTail ) ; </a> 0
<a> return oldTail ; </a> 0
<a> } else { </a> 0
<a> future = oldTail . executor ( ) . submit ( new DefaultChannelPipelineModificationTask ( this ) { </a> 0
<a> @ Override </a> 0
<a> void doCall ( ) { </a> 0
<a> removeLast0 ( oldTail ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> context = oldTail ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( ! ctx . channel ( ) . isRegistered ( ) || ctx . executor ( ) . inEventLoop ( ) ) { </a> 0
<a> remove0 ( ctx ) ; </a> 0
<a> return ctx ; </a> 0
<a> } else { </a> 0
<a> future = ctx . executor ( ) . submit ( new DefaultChannelPipelineModificationTask ( this ) { </a> 0
<a> @ Override </a> 0
<a> void doCall ( ) { </a> 0
<a> remove0 ( ctx ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> context = ctx ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Throwable result = future . get ( ) ; </a> 0
<a> if ( result != null ) { </a> 0
<a> throw result ; </a> 0
<a> } </a> 0
<a> return context ; </a> 0
<a> } catch ( RuntimeException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Error e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> throw new ChannelPipelineException ( t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void remove0 ( DefaultChannelHandlerContext ctx ) { </a> 0
<a> callBeforeRemove ( ctx ) ; </a> 1
<a> DefaultChannelHandlerContext prev = ctx . prev ; </a> 0
<a> DefaultChannelHandlerContext next = ctx . next ; </a> 0
<a> prev . next = next ; </a> 0
<a> next . prev = prev ; </a> 0
<a> name2ctx . remove ( ctx . name ( ) ) ; </a> 0
<a> callAfterRemove ( ctx ) ; </a> 0
<a> ctx . readable ( true ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelHandler removeFirst ( ) { </a> 0
<a> if ( head == tail ) { </a> 0
<a> throw new NoSuchElementException ( ) ; </a> 0
<a> } </a> 0
<a> return remove ( head . next ) . handler ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelHandler removeLast ( ) { </a> 0
<a> try { </a> 0
<a> Future < Throwable > future ; </a> 0
<a> final DefaultChannelHandlerContext oldTail ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( head == tail ) { </a> 0
<a> throw new NoSuchElementException ( ) ; </a> 0
<a> } </a> 0
<a> oldTail = tail ; </a> 0
<a> if ( ! oldTail . channel ( ) . isRegistered ( ) || oldTail . executor ( ) . inEventLoop ( ) ) { </a> 0
<a> removeLast0 ( oldTail ) ; </a> 0
<a> return oldTail . handler ( ) ; </a> 0
<a> } else { </a> 0
<a> future = oldTail . executor ( ) . submit ( new DefaultChannelPipelineModificationTask ( this ) { </a> 0
<a> @ Override </a> 0
<a> void doCall ( ) { </a> 0
<a> removeLast0 ( oldTail ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Throwable result = future . get ( ) ; </a> 0
<a> if ( result != null ) { </a> 0
<a> throw result ; </a> 0
<a> } </a> 0
<a> return oldTail . handler ( ) ; </a> 0
<a> } catch ( RuntimeException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Error e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> throw new ChannelPipelineException ( t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void removeLast0 ( DefaultChannelHandlerContext oldTail ) { </a> 0
<a> callBeforeRemove ( oldTail ) ; </a> 0
<a> oldTail . prev . next = null ; </a> 0
<a> tail = oldTail . prev ; </a> 0
<a> name2ctx . remove ( oldTail . name ( ) ) ; </a> 0
<a> callBeforeRemove ( oldTail ) ; </a> 0
<a> oldTail . readable ( true ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void replace ( ChannelHandler oldHandler , String newName , ChannelHandler newHandler ) { </a> 0
<a> replace ( getContextOrDie ( oldHandler ) , newName , newHandler ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelHandler replace ( String oldName , String newName , ChannelHandler newHandler ) { </a> 0
<a> return replace ( getContextOrDie ( oldName ) , newName , newHandler ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> public < T extends ChannelHandler > T replace ( </a> 0
<a> Class < T > oldHandlerType , String newName , ChannelHandler newHandler ) { </a> 0
<a> return ( T ) replace ( getContextOrDie ( oldHandlerType ) , newName , newHandler ) ; </a> 0
<a> } </a> 0
<a> private ChannelHandler replace ( </a> 0
<a> final DefaultChannelHandlerContext ctx , final String newName , final ChannelHandler newHandler ) { </a> 0
<a> try { </a> 0
<a> Future < Throwable > future ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( ctx == head ) { </a> 0
<a> throw new IllegalArgumentException ( ) ; </a> 0
<a> } else if ( ctx == tail ) { </a> 0
<a> if ( head == tail ) { </a> 0
<a> throw new NoSuchElementException ( ) ; </a> 0
<a> } </a> 0
<a> final DefaultChannelHandlerContext oldTail = tail ; </a> 0
<a> final DefaultChannelHandlerContext newTail = </a> 0
<a> new DefaultChannelHandlerContext ( this , null , oldTail , null , newName , newHandler ) ; </a> 0
<a> if ( ! oldTail . channel ( ) . isRegistered ( ) || oldTail . executor ( ) . inEventLoop ( ) ) { </a> 0
<a> removeLast0 ( oldTail ) ; </a> 0
<a> checkDuplicateName ( newName ) ; </a> 0
<a> addLast0 ( newName , tail , newTail ) ; </a> 0
<a> return ctx . handler ( ) ; </a> 0
<a> } else { </a> 0
<a> future = oldTail . executor ( ) . submit ( new DefaultChannelPipelineModificationTask ( this ) { </a> 0
<a> @ Override </a> 0
<a> void doCall ( ) { </a> 0
<a> removeLast0 ( oldTail ) ; </a> 0
<a> checkDuplicateName ( newName ) ; </a> 0
<a> addLast0 ( newName , tail , newTail ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> boolean sameName = ctx . name ( ) . equals ( newName ) ; </a> 0
<a> if ( ! sameName ) { </a> 0
<a> checkDuplicateName ( newName ) ; </a> 0
<a> } </a> 0
<a> DefaultChannelHandlerContext prev = ctx . prev ; </a> 0
<a> DefaultChannelHandlerContext next = ctx . next ; </a> 0
<a> final DefaultChannelHandlerContext newCtx = </a> 0
<a> new DefaultChannelHandlerContext ( this , ctx . executor , prev , next , newName , newHandler ) ; </a> 0
<a> if ( ! newCtx . channel ( ) . isRegistered ( ) || newCtx . executor ( ) . inEventLoop ( ) ) { </a> 0
<a> replace0 ( ctx , newName , newCtx ) ; </a> 0
<a> return ctx . handler ( ) ; </a> 0
<a> } else { </a> 0
<a> future = newCtx . executor ( ) . submit ( new DefaultChannelPipelineModificationTask ( this ) { </a> 0
<a> @ Override </a> 0
<a> void doCall ( ) { </a> 0
<a> replace0 ( ctx , newName , newCtx ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Throwable result = future . get ( ) ; </a> 0
<a> if ( result != null ) { </a> 0
<a> throw result ; </a> 0
<a> } </a> 0
<a> return ctx . handler ( ) ; </a> 0
<a> } catch ( RuntimeException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Error e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> throw new ChannelPipelineException ( t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void replace0 ( DefaultChannelHandlerContext ctx , String newName , DefaultChannelHandlerContext newCtx ) { </a> 0
<a> boolean sameName = ctx . name ( ) . equals ( newName ) ; </a> 0
<a> DefaultChannelHandlerContext prev = ctx . prev ; </a> 0
<a> DefaultChannelHandlerContext next = ctx . next ; </a> 0
<a> callBeforeRemove ( ctx ) ; </a> 1
<a> callBeforeAdd ( newCtx ) ; </a> 0
<a> prev . next = newCtx ; </a> 0
<a> next . prev = newCtx ; </a> 0
<a> if ( ! sameName ) { </a> 0
<a> name2ctx . remove ( ctx . name ( ) ) ; </a> 0
<a> } </a> 0
<a> name2ctx . put ( newName , newCtx ) ; </a> 0
<a> ChannelHandlerLifeCycleException removeException = null ; </a> 0
<a> ChannelHandlerLifeCycleException addException = null ; </a> 0
<a> boolean removed = false ; </a> 1
<a> try { </a> 1
<a> callAfterRemove ( ctx ) ; </a> 0
<a> ctx . readable ( true ) ; </a> 1
<a> removed = true ; </a> 1
<a> } catch ( ChannelHandlerLifeCycleException e ) { </a> 0
<a> removeException = e ; </a> 1
<a> } </a> 1
<a> boolean added = false ; </a> 1
<a> try { </a> 1
<a> callAfterAdd ( newCtx ) ; </a> 0
<a> added = true ; </a> 1
<a> } catch ( ChannelHandlerLifeCycleException e ) { </a> 0
<a> addException = e ; </a> 1
<a> } </a> 1
<a> if ( ! removed && ! added ) { </a> 1
<a> logger . warn ( removeException . getMessage ( ) , removeException ) ; </a> 1
<a> logger . warn ( addException . getMessage ( ) , addException ) ; </a> 1
<a> throw new ChannelHandlerLifeCycleException ( </a> 0
<a> "Both " + ctx . handler ( ) . getClass ( ) . getName ( ) + </a> 1
<a> ".afterRemove() and " + newCtx . handler ( ) . getClass ( ) . getName ( ) + </a> 1
<a> ".afterAdd() failed; see logs." ) ; </a> 1
<a> } else if ( ! removed ) { </a> 1
<a> throw removeException ; </a> 1
<a> } else if ( ! added ) { </a> 1
<a> throw addException ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> private static void callBeforeAdd ( ChannelHandlerContext ctx ) { </a> 0
<a> ChannelHandler handler = ctx . handler ( ) ; </a> 0
<a> if ( handler instanceof ChannelStateHandlerAdapter ) { </a> 0
<a> ChannelStateHandlerAdapter h = ( ChannelStateHandlerAdapter ) handler ; </a> 0
<a> if ( ! h . isSharable ( ) && h . added ) { </a> 0
<a> throw new ChannelHandlerLifeCycleException ( </a> 0
<a> "Only a @Sharable handler can be added or removed multiple times." ) ; </a> 0
<a> } </a> 0
<a> h . added = true ; </a> 0
<a> } </a> 0
<a> try { </a> 1
<a> handler . beforeAdd ( ctx ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> throw new ChannelHandlerLifeCycleException ( </a> 0
<a> handler . getClass ( ) . getName ( ) + </a> 1
<a> ".beforeAdd() has thrown an exception; not adding." , t ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private void callAfterAdd ( ChannelHandlerContext ctx ) { </a> 1
<a> try { </a> 0
<a> ctx . handler ( ) . afterAdd ( ctx ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> boolean removed = false ; </a> 0
<a> try { </a> 0
<a> remove ( ( DefaultChannelHandlerContext ) ctx ) ; </a> 0
<a> removed = true ; </a> 0
<a> } catch ( Throwable t2 ) { </a> 0
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( "Failed to remove a handler: " + ctx . name ( ) , t2 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( removed ) { </a> 0
<a> throw new ChannelHandlerLifeCycleException ( </a> 0
<a> ctx . handler ( ) . getClass ( ) . getName ( ) + </a> 0
<a> ".afterAdd() has thrown an exception; removed." , t ) ; </a> 1
<a> } else { </a> 0
<a> throw new ChannelHandlerLifeCycleException ( </a> 0
<a> ctx . handler ( ) . getClass ( ) . getName ( ) + </a> 0
<a> ".afterAdd() has thrown an exception; also failed to remove." , t ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void callBeforeRemove ( ChannelHandlerContext ctx ) { </a> 1
<a> try { </a> 1
<a> ctx . handler ( ) . beforeRemove ( ctx ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> throw new ChannelHandlerLifeCycleException ( </a> 0
<a> ctx . handler ( ) . getClass ( ) . getName ( ) + </a> 1
<a> ".beforeRemove() has thrown an exception; not removing." , t ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> private static void callAfterRemove ( ChannelHandlerContext ctx ) { </a> 1
<a> try { </a> 1
<a> ctx . handler ( ) . afterRemove ( ctx ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> throw new ChannelHandlerLifeCycleException ( </a> 0
<a> ctx . handler ( ) . getClass ( ) . getName ( ) + </a> 1
<a> ".afterRemove() has thrown an exception." , t ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public synchronized ChannelHandler first ( ) { </a> 0
<a> DefaultChannelHandlerContext first = head . next ; </a> 0
<a> if ( first == null ) { </a> 1
<a> return null ; </a> 0
<a> } </a> 0
<a> return first . handler ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized ChannelHandler last ( ) { </a> 0
<a> DefaultChannelHandlerContext last = tail ; </a> 0
<a> if ( last == head || last == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return last . handler ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized ChannelHandler get ( String name ) { </a> 0
<a> DefaultChannelHandlerContext ctx = name2ctx . get ( name ) ; </a> 0
<a> if ( ctx == null ) { </a> 0
<a> return null ; </a> 0
<a> } else { </a> 0
<a> return ctx . handler ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public synchronized < T extends ChannelHandler > T get ( Class < T > handlerType ) { </a> 0
<a> ChannelHandlerContext ctx = context ( handlerType ) ; </a> 0
<a> if ( ctx == null ) { </a> 0
<a> return null ; </a> 0
<a> } else { </a> 0
<a> return ( T ) ctx . handler ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized ChannelHandlerContext context ( String name ) { </a> 0
<a> if ( name == null ) { </a> 1
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> return name2ctx . get ( name ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized ChannelHandlerContext context ( ChannelHandler handler ) { </a> 0
<a> if ( handler == null ) { </a> 0
<a> throw new NullPointerException ( "handler" ) ; </a> 0
<a> } </a> 0
<a> if ( name2ctx . isEmpty ( ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> DefaultChannelHandlerContext ctx = head ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> if ( ctx . handler ( ) == handler ) { </a> 0
<a> return ctx ; </a> 0
<a> } </a> 0
<a> ctx = ctx . next ; </a> 0
<a> if ( ctx == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized ChannelHandlerContext context ( </a> 0
<a> Class < ? extends ChannelHandler > handlerType ) { </a> 0
<a> if ( handlerType == null ) { </a> 0
<a> throw new NullPointerException ( "handlerType" ) ; </a> 0
<a> } </a> 0
<a> if ( name2ctx . isEmpty ( ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> DefaultChannelHandlerContext ctx = head . next ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> if ( handlerType . isAssignableFrom ( ctx . handler ( ) . getClass ( ) ) ) { </a> 0
<a> return ctx ; </a> 0
<a> } </a> 0
<a> ctx = ctx . next ; </a> 0
<a> if ( ctx == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public List < String > names ( ) { </a> 0
<a> List < String > list = new ArrayList < String > ( ) ; </a> 0
<a> if ( name2ctx . isEmpty ( ) ) { </a> 0
<a> return list ; </a> 0
<a> } </a> 0
<a> DefaultChannelHandlerContext ctx = head . next ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> list . add ( ctx . name ( ) ) ; </a> 0
<a> ctx = ctx . next ; </a> 0
<a> if ( ctx == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return list ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Map < String , ChannelHandler > toMap ( ) { </a> 0
<a> Map < String , ChannelHandler > map = new LinkedHashMap < String , ChannelHandler > ( ) ; </a> 0
<a> if ( name2ctx . isEmpty ( ) ) { </a> 0
<a> return map ; </a> 0
<a> } </a> 0
<a> DefaultChannelHandlerContext ctx = head . next ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> map . put ( ctx . name ( ) , ctx . handler ( ) ) ; </a> 0
<a> ctx = ctx . next ; </a> 0
<a> if ( ctx == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return map ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> buf . append ( '{' ) ; </a> 1
<a> DefaultChannelHandlerContext ctx = head . next ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> buf . append ( '(' ) ; </a> 1
<a> buf . append ( ctx . name ( ) ) ; </a> 1
<a> buf . append ( " = " ) ; </a> 1
<a> buf . append ( ctx . handler ( ) . getClass ( ) . getName ( ) ) ; </a> 1
<a> buf . append ( ')' ) ; </a> 1
<a> ctx = ctx . next ; </a> 0
<a> if ( ctx == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> buf . append ( ", " ) ; </a> 0
<a> } </a> 0
<a> buf . append ( '}' ) ; </a> 0
<a> return buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public MessageBuf < Object > inboundMessageBuffer ( ) { </a> 1
<a> return head . nextInboundMessageBuffer ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> public ByteBuf inboundByteBuffer ( ) { </a> 1
<a> return head . nextInboundByteBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public MessageBuf < Object > outboundMessageBuffer ( ) { </a> 1
<a> return nextOutboundMessageBuffer ( tail ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf outboundByteBuffer ( ) { </a> 1
<a> return nextOutboundByteBuffer ( tail ) ; </a> 0
<a> } </a> 1
<a> boolean hasNextOutboundByteBuffer ( DefaultChannelHandlerContext ctx ) { </a> 0
<a> for ( ; ; ) { </a> 1
<a> if ( ctx == null ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> if ( ctx . outByteBridge != null ) { </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> ctx = ctx . prev ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> boolean hasNextOutboundMessageBuffer ( DefaultChannelHandlerContext ctx ) { </a> 0
<a> for ( ; ; ) { </a> 1
<a> if ( ctx == null ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> if ( ctx . outMsgBridge != null ) { </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> ctx = ctx . prev ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> ByteBuf nextOutboundByteBuffer ( DefaultChannelHandlerContext ctx ) { </a> 1
<a> final DefaultChannelHandlerContext initialCtx = ctx ; </a> 1
<a> final Thread currentThread = Thread . currentThread ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> if ( ctx == null ) { </a> 1
<a> if ( initialCtx . next != null ) { </a> 0
<a> throw new NoSuchBufferException ( String . format ( </a> 1
<a> "the handler '%s' could not find a %s whose outbound buffer is %s." , </a> 1
<a> initialCtx . next . name ( ) , ChannelOutboundHandler . class . getSimpleName ( ) , </a> 1
<a> ByteBuf . class . getSimpleName ( ) ) ) ; </a> 1
<a> } else { </a> 1
<a> throw new NoSuchBufferException ( String . format ( </a> 1
<a> "the pipeline does not contain a %s whose outbound buffer is %s." , </a> 1
<a> ChannelOutboundHandler . class . getSimpleName ( ) , </a> 1
<a> ByteBuf . class . getSimpleName ( ) ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> if ( ctx . outByteBuf != null ) { </a> 1
<a> if ( ctx . executor ( ) . inEventLoop ( currentThread ) ) { </a> 1
<a> return ctx . outByteBuf ; </a> 1
<a> } else { </a> 1
<a> ByteBridge bridge = ctx . outByteBridge . get ( ) ; </a> 1
<a> if ( bridge == null ) { </a> 1
<a> bridge = new ByteBridge ( ) ; </a> 1
<a> if ( ! ctx . outByteBridge . compareAndSet ( null , bridge ) ) { </a> 1
<a> bridge = ctx . outByteBridge . get ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return bridge . byteBuf ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> ctx = ctx . prev ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> MessageBuf < Object > nextOutboundMessageBuffer ( DefaultChannelHandlerContext ctx ) { </a> 0
<a> final DefaultChannelHandlerContext initialCtx = ctx ; </a> 1
<a> final Thread currentThread = Thread . currentThread ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> if ( ctx == null ) { </a> 1
<a> if ( initialCtx . next != null ) { </a> 1
<a> throw new NoSuchBufferException ( String . format ( </a> 1
<a> "the handler '%s' could not find a %s whose outbound buffer is %s." , </a> 1
<a> initialCtx . next . name ( ) , ChannelOutboundHandler . class . getSimpleName ( ) , </a> 1
<a> MessageBuf . class . getSimpleName ( ) ) ) ; </a> 1
<a> } else { </a> 1
<a> throw new NoSuchBufferException ( String . format ( </a> 1
<a> "the pipeline does not contain a %s whose outbound buffer is %s." , </a> 1
<a> ChannelOutboundHandler . class . getSimpleName ( ) , </a> 1
<a> MessageBuf . class . getSimpleName ( ) ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> if ( ctx . outMsgBuf != null ) { </a> 1
<a> if ( ctx . executor ( ) . inEventLoop ( currentThread ) ) { </a> 1
<a> return ctx . outMsgBuf ; </a> 1
<a> } else { </a> 1
<a> MessageBridge bridge = ctx . outMsgBridge . get ( ) ; </a> 1
<a> if ( bridge == null ) { </a> 1
<a> bridge = new MessageBridge ( ) ; </a> 1
<a> if ( ! ctx . outMsgBridge . compareAndSet ( null , bridge ) ) { </a> 1
<a> bridge = ctx . outMsgBridge . get ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return bridge . msgBuf ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> ctx = ctx . prev ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void fireChannelRegistered ( ) { </a> 0
<a> head . fireChannelRegistered ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void fireChannelUnregistered ( ) { </a> 0
<a> head . fireChannelUnregistered ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void fireChannelActive ( ) { </a> 0
<a> firedChannelActive = true ; </a> 1
<a> head . fireChannelActive ( ) ; </a> 0
<a> if ( fireInboundBufferUpdatedOnActivation ) { </a> 1
<a> fireInboundBufferUpdatedOnActivation = false ; </a> 1
<a> head . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void fireChannelInactive ( ) { </a> 0
<a> head . fireChannelInactive ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void fireExceptionCaught ( Throwable cause ) { </a> 0
<a> head . fireExceptionCaught ( cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void fireUserEventTriggered ( Object event ) { </a> 0
<a> head . fireUserEventTriggered ( event ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void fireInboundBufferUpdated ( ) { </a> 0
<a> if ( ! firedChannelActive ) { </a> 1
<a> fireInboundBufferUpdatedOnActivation = true ; </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> head . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture bind ( SocketAddress localAddress ) { </a> 0
<a> return bind ( localAddress , channel . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture connect ( SocketAddress remoteAddress ) { </a> 0
<a> return connect ( remoteAddress , channel . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture connect ( SocketAddress remoteAddress , SocketAddress localAddress ) { </a> 0
<a> return connect ( remoteAddress , localAddress , channel . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture disconnect ( ) { </a> 0
<a> return disconnect ( channel . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture close ( ) { </a> 0
<a> return close ( channel . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture deregister ( ) { </a> 0
<a> return deregister ( channel . newFuture ( ) ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public ChannelFuture flush ( ) { </a> 1
<a> return flush ( channel . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture write ( Object message ) { </a> 1
<a> return write ( message , channel . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture bind ( SocketAddress localAddress , ChannelFuture future ) { </a> 0
<a> return bind ( firstContext ( DIR_OUTBOUND ) , localAddress , future ) ; </a> 1
<a> } </a> 1
<a> ChannelFuture bind ( </a> 1
<a> final DefaultChannelHandlerContext ctx , final SocketAddress localAddress , final ChannelFuture future ) { </a> 0
<a> if ( localAddress == null ) { </a> 0
<a> throw new NullPointerException ( "localAddress" ) ; </a> 0
<a> } </a> 0
<a> validateFuture ( future ) ; </a> 0
<a> EventExecutor executor = ctx . executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> try { </a> 1
<a> ( ( ChannelOperationHandler ) ctx . handler ( ) ) . bind ( ctx , localAddress , future ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 1
<a> notifyHandlerException ( t ) ; </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> executor . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> bind ( ctx , localAddress , future ) ; </a> 0
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture connect ( SocketAddress remoteAddress , ChannelFuture future ) { </a> 0
<a> return connect ( remoteAddress , null , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture connect ( SocketAddress remoteAddress , SocketAddress localAddress , ChannelFuture future ) { </a> 0
<a> return connect ( firstContext ( DIR_OUTBOUND ) , remoteAddress , localAddress , future ) ; </a> 1
<a> } </a> 1
<a> ChannelFuture connect ( </a> 1
<a> final DefaultChannelHandlerContext ctx , final SocketAddress remoteAddress , </a> 1
<a> final SocketAddress localAddress , final ChannelFuture future ) { </a> 0
<a> if ( remoteAddress == null ) { </a> 0
<a> throw new NullPointerException ( "remoteAddress" ) ; </a> 0
<a> } </a> 1
<a> validateFuture ( future ) ; </a> 0
<a> EventExecutor executor = ctx . executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> try { </a> 1
<a> ( ( ChannelOperationHandler ) ctx . handler ( ) ) . connect ( ctx , remoteAddress , localAddress , future ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 1
<a> notifyHandlerException ( t ) ; </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> executor . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> connect ( ctx , remoteAddress , localAddress , future ) ; </a> 0
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> return future ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelFuture disconnect ( ChannelFuture future ) { </a> 1
<a> return disconnect ( firstContext ( DIR_OUTBOUND ) , future ) ; </a> 1
<a> } </a> 1
<a> ChannelFuture disconnect ( final DefaultChannelHandlerContext ctx , final ChannelFuture future ) { </a> 0
<a> if ( ! ctx . channel ( ) . metadata ( ) . hasDisconnect ( ) ) { </a> 0
<a> return close ( ctx , future ) ; </a> 0
<a> } </a> 0
<a> validateFuture ( future ) ; </a> 0
<a> EventExecutor executor = ctx . executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> try { </a> 1
<a> ( ( ChannelOperationHandler ) ctx . handler ( ) ) . disconnect ( ctx , future ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 1
<a> notifyHandlerException ( t ) ; </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> executor . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> disconnect ( ctx , future ) ; </a> 0
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture close ( ChannelFuture future ) { </a> 0
<a> return close ( firstContext ( DIR_OUTBOUND ) , future ) ; </a> 1
<a> } </a> 0
<a> ChannelFuture close ( final DefaultChannelHandlerContext ctx , final ChannelFuture future ) { </a> 0
<a> validateFuture ( future ) ; </a> 0
<a> EventExecutor executor = ctx . executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> try { </a> 1
<a> ( ( ChannelOperationHandler ) ctx . handler ( ) ) . close ( ctx , future ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 1
<a> notifyHandlerException ( t ) ; </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> executor . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 1
<a> close ( ctx , future ) ; </a> 0
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture deregister ( final ChannelFuture future ) { </a> 0
<a> return deregister ( firstContext ( DIR_OUTBOUND ) , future ) ; </a> 1
<a> } </a> 0
<a> ChannelFuture deregister ( final DefaultChannelHandlerContext ctx , final ChannelFuture future ) { </a> 0
<a> validateFuture ( future ) ; </a> 0
<a> EventExecutor executor = ctx . executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> try { </a> 1
<a> ( ( ChannelOperationHandler ) ctx . handler ( ) ) . deregister ( ctx , future ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 1
<a> notifyHandlerException ( t ) ; </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> executor . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 1
<a> deregister ( ctx , future ) ; </a> 0
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture flush ( ChannelFuture future ) { </a> 0
<a> return flush ( firstContext ( DIR_OUTBOUND ) , future ) ; </a> 1
<a> } </a> 1
<a> ChannelFuture flush ( final DefaultChannelHandlerContext ctx , final ChannelFuture future ) { </a> 0
<a> validateFuture ( future ) ; </a> 0
<a> EventExecutor executor = ctx . executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> flush0 ( ctx , future ) ; </a> 0
<a> } else { </a> 0
<a> executor . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> flush ( ctx , future ) ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> return future ; </a> 0
<a> } </a> 1
<a> private void flush0 ( final DefaultChannelHandlerContext ctx , ChannelFuture future ) { </a> 0
<a> try { </a> 1
<a> ctx . flushBridge ( ) ; </a> 1
<a> ( ( ChannelOperationHandler ) ctx . handler ( ) ) . flush ( ctx , future ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> notifyHandlerException ( t ) ; </a> 0
<a> } finally { </a> 0
<a> if ( ctx . outByteBuf != null ) { </a> 1
<a> ByteBuf buf = ctx . outByteBuf ; </a> 1
<a> if ( ! buf . readable ( ) ) { </a> 0
<a> buf . discardReadBytes ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelFuture write ( Object message , ChannelFuture future ) { </a> 0
<a> return write ( tail , message , future ) ; </a> 0
<a> } </a> 1
<a> ChannelFuture write ( DefaultChannelHandlerContext ctx , final Object message , final ChannelFuture future ) { </a> 0
<a> if ( message == null ) { </a> 1
<a> throw new NullPointerException ( "message" ) ; </a> 1
<a> } </a> 1
<a> validateFuture ( future ) ; </a> 0
<a> final DefaultChannelHandlerContext initialCtx = ctx ; </a> 1
<a> EventExecutor executor ; </a> 1
<a> boolean msgBuf = false ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> if ( ctx == null ) { </a> 1
<a> if ( initialCtx . next != null ) { </a> 1
<a> throw new NoSuchBufferException ( String . format ( </a> 1
<a> "the handler '%s' could not find a %s which accepts a %s, and " + </a> 1
<a> "the transport does not accept it as-is." , </a> 1
<a> initialCtx . next . name ( ) , </a> 1
<a> ChannelOutboundHandler . class . getSimpleName ( ) , </a> 1
<a> message . getClass ( ) . getSimpleName ( ) ) ) ; </a> 1
<a> } else { </a> 1
<a> throw new NoSuchBufferException ( String . format ( </a> 1
<a> "the pipeline does not contain a %s which accepts a %s, and " + </a> 1
<a> "the transport does not accept it as-is." , </a> 1
<a> ChannelOutboundHandler . class . getSimpleName ( ) , </a> 1
<a> message . getClass ( ) . getSimpleName ( ) ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> if ( ctx . hasOutboundMessageBuffer ( ) ) { </a> 1
<a> msgBuf = true ; </a> 1
<a> executor = ctx . executor ( ) ; </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> if ( message instanceof ByteBuf && ctx . hasOutboundByteBuffer ( ) ) { </a> 1
<a> executor = ctx . executor ( ) ; </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> ctx = ctx . prev ; </a> 1
<a> } </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> if ( msgBuf ) { </a> 1
<a> ctx . outMsgBuf . add ( message ) ; </a> 1
<a> } else { </a> 1
<a> ByteBuf buf = ( ByteBuf ) message ; </a> 1
<a> ctx . outByteBuf . writeBytes ( buf , buf . readerIndex ( ) , buf . readableBytes ( ) ) ; </a> 1
<a> } </a> 1
<a> flush0 ( ctx , future ) ; </a> 1
<a> return future ; </a> 0
<a> } else { </a> 0
<a> final DefaultChannelHandlerContext ctx0 = ctx ; </a> 1
<a> executor . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> write ( ctx0 , message , future ) ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 0
<a> return future ; </a> 0
<a> } </a> 1
<a> private void validateFuture ( ChannelFuture future ) { </a> 1
<a> if ( future == null ) { </a> 1
<a> throw new NullPointerException ( "future" ) ; </a> 1
<a> } </a> 1
<a> if ( future . channel ( ) != channel ) { </a> 1
<a> throw new IllegalArgumentException ( String . format ( </a> 1
<a> "future.channel does not match: %s (expected: %s)" , future . channel ( ) , channel ) ) ; </a> 1
<a> } </a> 1
<a> if ( future . isDone ( ) ) { </a> 1
<a> throw new IllegalArgumentException ( "future already done" ) ; </a> 1
<a> } </a> 1
<a> if ( future instanceof ChannelFuture . Unsafe ) { </a> 1
<a> throw new IllegalArgumentException ( "internal use only future not allowed" ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private DefaultChannelHandlerContext firstContext ( int direction ) { </a> 1
<a> assert direction == DIR_INBOUND || direction == DIR_OUTBOUND ; </a> 1
<a> if ( direction > 0 ) { </a> 1
<a> return nextContext ( head . next , direction ) ; </a> 1
<a> } else { </a> 1
<a> return nextContext ( tail , direction ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> static DefaultChannelHandlerContext nextContext ( </a> 1
<a> DefaultChannelHandlerContext ctx , int direction ) { </a> 1
<a> assert direction == DIR_INBOUND || direction == DIR_OUTBOUND ; </a> 1
<a> if ( ctx == null ) { </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> DefaultChannelHandlerContext realCtx = ctx ; </a> 1
<a> if ( direction > 0 ) { </a> 1
<a> while ( ( realCtx . directions & direction ) == 0 ) { </a> 1
<a> realCtx = realCtx . next ; </a> 1
<a> if ( realCtx == null ) { </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> while ( ( realCtx . directions & direction ) == 0 ) { </a> 1
<a> realCtx = realCtx . prev ; </a> 1
<a> if ( realCtx == null ) { </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return realCtx ; </a> 1
<a> } </a> 0
<a> protected void notifyHandlerException ( Throwable cause ) { </a> 1
<a> if ( ! ( cause instanceof ChannelPipelineException ) ) { </a> 0
<a> cause = new ChannelPipelineException ( cause ) ; </a> 0
<a> } </a> 0
<a> if ( inExceptionCaught ( cause ) ) { </a> 1
<a> if ( logger . isWarnEnabled ( ) ) { </a> 1
<a> logger . warn ( </a> 1
<a> "An exception was thrown by a user handler " + </a> 1
<a> "while handling an exceptionCaught event" , cause ) ; </a> 1
<a> } </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> fireExceptionCaught ( cause ) ; </a> 0
<a> } </a> 0
<a> private static boolean inExceptionCaught ( Throwable cause ) { </a> 1
<a> if ( cause == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 1
<a> StackTraceElement [ ] trace = cause . getStackTrace ( ) ; </a> 1
<a> if ( trace != null ) { </a> 1
<a> for ( StackTraceElement t : trace ) { </a> 1
<a> if ( "exceptionCaught" . equals ( t . getMethodName ( ) ) ) { </a> 1
<a> return true ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> } </a> 1
<a> return inExceptionCaught ( cause . getCause ( ) ) ; </a> 1
<a> } </a> 1
<a> private void checkDuplicateName ( String name ) { </a> 0
<a> if ( name2ctx . containsKey ( name ) ) { </a> 0
<a> throw new IllegalArgumentException ( "Duplicate handler name: " + name ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private DefaultChannelHandlerContext getContextOrDie ( String name ) { </a> 0
<a> DefaultChannelHandlerContext ctx = ( DefaultChannelHandlerContext ) context ( name ) ; </a> 0
<a> if ( ctx == null || ctx == head ) { </a> 1
<a> throw new NoSuchElementException ( name ) ; </a> 0
<a> } else { </a> 0
<a> return ctx ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private DefaultChannelHandlerContext getContextOrDie ( ChannelHandler handler ) { </a> 0
<a> DefaultChannelHandlerContext ctx = ( DefaultChannelHandlerContext ) context ( handler ) ; </a> 0
<a> if ( ctx == null || ctx == head ) { </a> 1
<a> throw new NoSuchElementException ( handler . getClass ( ) . getName ( ) ) ; </a> 0
<a> } else { </a> 0
<a> return ctx ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private DefaultChannelHandlerContext getContextOrDie ( Class < ? extends ChannelHandler > handlerType ) { </a> 0
<a> DefaultChannelHandlerContext ctx = ( DefaultChannelHandlerContext ) context ( handlerType ) ; </a> 0
<a> if ( ctx == null || ctx == head ) { </a> 1
<a> throw new NoSuchElementException ( handlerType . getName ( ) ) ; </a> 0
<a> } else { </a> 0
<a> return ctx ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void readable ( DefaultChannelHandlerContext ctx , boolean readable ) { </a> 1
<a> if ( ctx . readable . compareAndSet ( ! readable , readable ) ) { </a> 1
<a> if ( ! readable ) { </a> 1
<a> if ( suspendRead . incrementAndGet ( ) == 1 ) { </a> 1
<a> unsafe . suspendRead ( ) ; </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> if ( suspendRead . decrementAndGet ( ) == 0 ) { </a> 1
<a> unsafe . resumeRead ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private final class HeadHandler implements ChannelOutboundHandler { </a> 0
<a> @ Override </a> 0
<a> public ChannelBuf newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> switch ( channel . metadata ( ) . bufferType ( ) ) { </a> 0
<a> case BYTE : </a> 0
<a> return Unpooled . buffer ( ) ; </a> 1
<a> case MESSAGE : </a> 0
<a> return Unpooled . messageBuffer ( ) ; </a> 0
<a> default : </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void afterAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void beforeRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void afterRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void bind ( </a> 0
<a> ChannelHandlerContext ctx , SocketAddress localAddress , ChannelFuture future ) </a> 0
<a> throws Exception { </a> 0
<a> unsafe . bind ( localAddress , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void connect ( </a> 0
<a> ChannelHandlerContext ctx , </a> 0
<a> SocketAddress remoteAddress , SocketAddress localAddress , </a> 0
<a> ChannelFuture future ) throws Exception { </a> 0
<a> unsafe . connect ( remoteAddress , localAddress , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void disconnect ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> unsafe . disconnect ( future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> unsafe . close ( future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void deregister ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> unsafe . deregister ( future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> unsafe . flush ( future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> ctx . fireExceptionCaught ( cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception { </a> 0
<a> ctx . fireUserEventTriggered ( evt ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . concurrent . Callable ; </a> 0
<a> import java . util . concurrent . Future ; </a> 0
<a> abstract class DefaultChannelPipelineModificationTask implements Callable < Throwable > { </a> 0
<a> private final ChannelPipeline lock ; </a> 0
<a> DefaultChannelPipelineModificationTask ( ChannelPipeline lock ) { </a> 0
<a> this . lock = lock ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Throwable call ( ) { </a> 0
<a> try { </a> 0
<a> synchronized ( lock ) { </a> 0
<a> doCall ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> return t ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> abstract void doCall ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public interface EventLoopGroup extends EventExecutorGroup { </a> 0
<a> @ Override </a> 0
<a> EventLoop next ( ) ; </a> 0
<a> ChannelFuture register ( Channel channel ) ; </a> 0
<a> ChannelFuture register ( Channel channel , ChannelFuture future ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . nio . channels . Channels ; </a> 0
<a> import java . util . concurrent . ExecutionException ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . TimeoutException ; </a> 0
<a> public class FailedChannelFuture extends CompleteChannelFuture { </a> 0
<a> private final Throwable cause ; </a> 0
<a> public FailedChannelFuture ( Channel channel , Throwable cause ) { </a> 0
<a> super ( channel ) ; </a> 0
<a> if ( cause == null ) { </a> 1
<a> throw new NullPointerException ( "cause" ) ; </a> 1
<a> } </a> 1
<a> this . cause = cause ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Throwable cause ( ) { </a> 0
<a> return cause ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isSuccess ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture sync ( ) throws InterruptedException { </a> 0
<a> return rethrow ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture syncUninterruptibly ( ) { </a> 0
<a> return rethrow ( ) ; </a> 0
<a> } </a> 0
<a> private ChannelFuture rethrow ( ) { </a> 0
<a> if ( cause instanceof RuntimeException ) { </a> 0
<a> throw ( RuntimeException ) cause ; </a> 0
<a> } </a> 0
<a> if ( cause instanceof Error ) { </a> 0
<a> throw ( Error ) cause ; </a> 0
<a> } </a> 0
<a> throw new ChannelException ( cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Void get ( ) throws InterruptedException , ExecutionException { </a> 0
<a> throw new ExecutionException ( cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Void get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , </a> 0
<a> TimeoutException { </a> 0
<a> throw new ExecutionException ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 1
<a> public abstract class MultithreadEventLoopGroup extends MultithreadEventExecutorGroup implements EventLoopGroup { </a> 0
<a> protected MultithreadEventLoopGroup ( int nThreads , ThreadFactory threadFactory , </a> 0
<a> Object ... args ) { </a> 0
<a> super ( nThreads , threadFactory , args ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public EventLoop next ( ) { </a> 0
<a> return ( EventLoop ) super . next ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture register ( Channel channel ) { </a> 0
<a> return next ( ) . register ( channel ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelFuture register ( Channel channel , ChannelFuture future ) { </a> 0
<a> return next ( ) . register ( channel , future ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import java . net . InetAddress ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . net . NetworkInterface ; </a> 0
<a> public interface DatagramChannel extends Channel { </a> 0
<a> @ Override </a> 0
<a> DatagramChannelConfig config ( ) ; </a> 0
<a> @ Override </a> 0
<a> InetSocketAddress localAddress ( ) ; </a> 0
<a> @ Override </a> 0
<a> InetSocketAddress remoteAddress ( ) ; </a> 0
<a> boolean isConnected ( ) ; </a> 0
<a> ChannelFuture joinGroup ( InetAddress multicastAddress ) ; </a> 0
<a> ChannelFuture joinGroup ( InetAddress multicastAddress , ChannelFuture future ) ; </a> 0
<a> ChannelFuture joinGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface ) ; </a> 0
<a> ChannelFuture joinGroup ( </a> 0
<a> InetSocketAddress multicastAddress , NetworkInterface networkInterface , ChannelFuture future ) ; </a> 0
<a> ChannelFuture joinGroup ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source ) ; </a> 0
<a> ChannelFuture joinGroup ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source , ChannelFuture future ) ; </a> 0
<a> ChannelFuture leaveGroup ( InetAddress multicastAddress ) ; </a> 0
<a> ChannelFuture leaveGroup ( InetAddress multicastAddress , ChannelFuture future ) ; </a> 0
<a> ChannelFuture leaveGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface ) ; </a> 0
<a> ChannelFuture leaveGroup ( </a> 0
<a> InetSocketAddress multicastAddress , NetworkInterface networkInterface , ChannelFuture future ) ; </a> 0
<a> ChannelFuture leaveGroup ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source ) ; </a> 0
<a> ChannelFuture leaveGroup ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source , </a> 0
<a> ChannelFuture future ) ; </a> 0
<a> ChannelFuture block ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , </a> 0
<a> InetAddress sourceToBlock ) ; </a> 0
<a> ChannelFuture block ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , </a> 0
<a> InetAddress sourceToBlock , ChannelFuture future ) ; </a> 0
<a> ChannelFuture block ( InetAddress multicastAddress , InetAddress sourceToBlock ) ; </a> 0
<a> ChannelFuture block ( </a> 0
<a> InetAddress multicastAddress , InetAddress sourceToBlock , ChannelFuture future ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket ; </a> 0
<a> import io . netty . channel . ChannelConfig ; </a> 0
<a> import java . net . InetAddress ; </a> 0
<a> import java . net . NetworkInterface ; </a> 0
<a> import java . net . StandardSocketOptions ; </a> 0
<a> public interface DatagramChannelConfig extends ChannelConfig { </a> 0
<a> int getSendBufferSize ( ) ; </a> 0
<a> void setSendBufferSize ( int sendBufferSize ) ; </a> 0
<a> int getReceiveBufferSize ( ) ; </a> 0
<a> void setReceiveBufferSize ( int receiveBufferSize ) ; </a> 0
<a> int getReceivePacketSize ( ) ; </a> 1
<a> void setReceivePacketSize ( int receivePacketSize ) ; </a> 0
<a> int getTrafficClass ( ) ; </a> 0
<a> void setTrafficClass ( int trafficClass ) ; </a> 0
<a> boolean isReuseAddress ( ) ; </a> 0
<a> void setReuseAddress ( boolean reuseAddress ) ; </a> 0
<a> boolean isBroadcast ( ) ; </a> 0
<a> void setBroadcast ( boolean broadcast ) ; </a> 0
<a> boolean isLoopbackModeDisabled ( ) ; </a> 0
<a> void setLoopbackModeDisabled ( boolean loopbackModeDisabled ) ; </a> 0
<a> int getTimeToLive ( ) ; </a> 0
<a> void setTimeToLive ( int ttl ) ; </a> 0
<a> InetAddress getInterface ( ) ; </a> 0
<a> void setInterface ( InetAddress interfaceAddress ) ; </a> 0
<a> NetworkInterface getNetworkInterface ( ) ; </a> 0
<a> void setNetworkInterface ( NetworkInterface networkInterface ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . aio ; </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . oio ; </a> 0
<a> import io . netty . buffer . ChannelBufType ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelMetadata ; </a> 0
<a> import io . netty . channel . socket . DefaultServerSocketChannelConfig ; </a> 0
<a> import io . netty . channel . socket . ServerSocketChannel ; </a> 0
<a> import io . netty . channel . socket . ServerSocketChannelConfig ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . net . ServerSocket ; </a> 0
<a> import java . net . Socket ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . net . SocketTimeoutException ; </a> 0
<a> import java . util . concurrent . locks . Lock ; </a> 0
<a> import java . util . concurrent . locks . ReentrantLock ; </a> 0
<a> public class OioServerSocketChannel extends AbstractOioMessageChannel </a> 0
<a> implements ServerSocketChannel { </a> 0
<a> private static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( OioServerSocketChannel . class ) ; </a> 0
<a> private static final ChannelMetadata METADATA = new ChannelMetadata ( ChannelBufType . MESSAGE , false ) ; </a> 0
<a> private static ServerSocket newServerSocket ( ) { </a> 0
<a> try { </a> 0
<a> return new ServerSocket ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( "failed to create a server socket" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> final ServerSocket socket ; </a> 0
<a> final Lock shutdownLock = new ReentrantLock ( ) ; </a> 0
<a> private final ServerSocketChannelConfig config ; </a> 0
<a> private volatile boolean readSuspended ; </a> 0
<a> public OioServerSocketChannel ( ) { </a> 0
<a> this ( newServerSocket ( ) ) ; </a> 0
<a> } </a> 0
<a> public OioServerSocketChannel ( ServerSocket socket ) { </a> 0
<a> this ( null , socket ) ; </a> 0
<a> } </a> 0
<a> public OioServerSocketChannel ( Integer id , ServerSocket socket ) { </a> 0
<a> super ( null , id ) ; </a> 0
<a> if ( socket == null ) { </a> 0
<a> throw new NullPointerException ( "socket" ) ; </a> 0
<a> } </a> 0
<a> boolean success = false ; </a> 0
<a> try { </a> 0
<a> socket . setSoTimeout ( SO_TIMEOUT ) ; </a> 0
<a> success = true ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( </a> 0
<a> "Failed to set the server socket timeout." , e ) ; </a> 0
<a> } finally { </a> 0
<a> if ( ! success ) { </a> 0
<a> try { </a> 0
<a> socket . close ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( </a> 0
<a> "Failed to close a partially initialized socket." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> this . socket = socket ; </a> 0
<a> config = new DefaultServerSocketChannelConfig ( socket ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelMetadata metadata ( ) { </a> 0
<a> return METADATA ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ServerSocketChannelConfig config ( ) { </a> 0
<a> return config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public InetSocketAddress remoteAddress ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isOpen ( ) { </a> 0
<a> return ! socket . isClosed ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isActive ( ) { </a> 0
<a> return isOpen ( ) && socket . isBound ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress localAddress0 ( ) { </a> 0
<a> return socket . getLocalSocketAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doBind ( SocketAddress localAddress ) throws Exception { </a> 0
<a> socket . bind ( localAddress ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doClose ( ) throws Exception { </a> 0
<a> socket . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int doReadMessages ( MessageBuf < Object > buf ) throws Exception { </a> 1
<a> if ( socket . isClosed ( ) ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> if ( readSuspended ) { </a> 1
<a> try { </a> 1
<a> Thread . sleep ( SO_TIMEOUT ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> } </a> 1
<a> return 0 ; </a> 1
<a> } </a> 1
<a> Socket s = null ; </a> 0
<a> try { </a> 0
<a> s = socket . accept ( ) ; </a> 0
<a> if ( s != null ) { </a> 1
<a> buf . add ( new OioSocketChannel ( this , null , s ) ) ; </a> 0
<a> if ( readSuspended ) { </a> 1
<a> return 0 ; </a> 1
<a> } </a> 1
<a> return 1 ; </a> 0
<a> } </a> 1
<a> } catch ( SocketTimeoutException e ) { </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Failed to create a new channel from an accepted socket." , t ) ; </a> 0
<a> if ( s != null ) { </a> 1
<a> try { </a> 0
<a> s . close ( ) ; </a> 0
<a> } catch ( Throwable t2 ) { </a> 0
<a> logger . warn ( "Failed to close a socket." , t2 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doConnect ( </a> 0
<a> SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress remoteAddress0 ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDisconnect ( ) throws Exception { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> protected void doWriteMessages ( MessageBuf < Object > buf ) throws Exception { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> protected AbstractOioMessageUnsafe newUnsafe ( ) { </a> 0
<a> return new OioServerSocketUnsafe ( ) ; </a> 0
<a> } </a> 0
<a> private final class OioServerSocketUnsafe extends AbstractOioMessageUnsafe { </a> 0
<a> @ Override </a> 0
<a> public void suspendRead ( ) { </a> 0
<a> readSuspended = true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void resumeRead ( ) { </a> 0
<a> readSuspended = false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import static org . easymock . EasyMock . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class FailedChannelFutureTest { </a> 0
<a> @ Test </a> 0
<a> public void testConstantProperties ( ) { </a> 0
<a> Channel channel = createMock ( Channel . class ) ; </a> 0
<a> Exception e = new Exception ( ) ; </a> 0
<a> FailedChannelFuture future = new FailedChannelFuture ( channel , e ) ; </a> 0
<a> assertFalse ( future . isSuccess ( ) ) ; </a> 0
<a> assertSame ( e , future . cause ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = NullPointerException . class ) </a> 0
<a> public void shouldDisallowNullException ( ) { </a> 0
<a> new FailedChannelFuture ( createMock ( Channel . class ) , null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
