<START_FILE>
<a> </a> 0
<a> package org . atmosphere . grizzly ; </a> 0
<a> import com . sun . grizzly . http . servlet . ServletAdapter ; </a> 1
<a> import com . sun . grizzly . tcp . http11 . GrizzlyAdapter ; </a> 1
<a> import org . atmosphere . container . GrizzlyCometSupport ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 1
<a> import org . atmosphere . cpr . FrameworkConfig ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 1
<a> import java . io . File ; </a> 1
<a> import java . net . MalformedURLException ; </a> 1
<a> import java . net . URISyntaxException ; </a> 1
<a> import java . net . URL ; </a> 1
<a> import java . net . URLClassLoader ; </a> 1
<a> public class AtmosphereAdapter extends ServletAdapter { </a> 1
<a> private String resourcePackage = null ; </a> 1
<a> private final AtmosphereServlet as = new GrizzlyAtmosphereServlet ( ) ; </a> 1
<a> @ Override </a> 1
<a> public void start ( ) { </a> 1
<a> if ( resourcePackage != null ) { </a> 1
<a> addInitParameter ( "com.sun.jersey.config.property.packages" , resourcePackage ) ; </a> 1
<a> } </a> 1
<a> setServletInstance ( as ) ; </a> 1
<a> super . start ( ) ; </a> 1
<a> } </a> 1
<a> public void setUseStreamForFlushingComments ( boolean useStreaming ) { </a> 1
<a> as . setUseStreamForFlushingComments ( useStreaming ) ; </a> 0
<a> } </a> 1
<a> public void addAtmosphereHandler ( String path , AtmosphereHandler ah ) { </a> 1
<a> as . addAtmosphereHandler ( path , ah ) ; </a> 0
<a> } </a> 1
<a> public String getResourcePackage ( ) { </a> 1
<a> return resourcePackage ; </a> 1
<a> } </a> 1
<a> public void setResourcePackage ( String resourcePackage ) { </a> 1
<a> this . resourcePackage = resourcePackage ; </a> 1
<a> } </a> 1
<a> private static class GrizzlyAtmosphereServlet extends AtmosphereServlet { </a> 1
<a> @ Override </a> 0
<a> protected void autoDetectContainer ( ) { </a> 1
<a> setUseStreamForFlushingComments ( true ) ; </a> 0
<a> cometSupport = new GrizzlyCometSupport ( getAtmosphereConfig ( ) ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> protected void autoDetectAtmosphereHandlers ( ServletContext servletContext , URLClassLoader classLoader ) </a> 1
<a> throws MalformedURLException , URISyntaxException { </a> 1
<a> try { </a> 0
<a> Class . forName ( "org.atmosphere.spade.AtmosphereSpadeLauncher" ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> super . autoDetectAtmosphereHandlers ( servletContext , classLoader ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> String realPath = servletContext . getRealPath ( FrameworkConfig . WEB_INF_CLASSES ) ; </a> 0
<a> if ( realPath == null ) { </a> 1
<a> URL u = servletContext . getResource ( FrameworkConfig . WEB_INF_CLASSES ) ; </a> 0
<a> if ( u == null ) return ; </a> 1
<a> realPath = u . getPath ( ) ; </a> 1
<a> } </a> 1
<a> File f = new File ( realPath ) ; </a> 1
<a> if ( ! f . exists ( ) ) { </a> 1
<a> String ctxPath = servletContext . getContextPath ( ) ; </a> 1
<a> if ( System . getProperty ( "os.name" ) . toLowerCase ( ) . startsWith ( "win" ) ) { </a> 0
<a> ctxPath = ctxPath . replace ( "/" , "\\" ) ; </a> 0
<a> } </a> 0
<a> int index = realPath . indexOf ( ctxPath ) ; </a> 1
<a> if ( index < 1 ) { </a> 1
<a> index = realPath . length ( ) ; </a> 1
<a> } </a> 1
<a> String trailer = realPath . substring ( 0 , index ) ; </a> 1
<a> f = new File ( trailer + servletContext . getContextPath ( ) + FrameworkConfig . WEB_INF_CLASSES ) ; </a> 0
<a> } </a> 1
<a> loadAtmosphereHandlersFromPath ( classLoader , realPath ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . guice ; </a> 0
<a> import com . google . inject . Injector ; </a> 0
<a> import com . google . inject . Key ; </a> 0
<a> import com . google . inject . TypeLiteral ; </a> 0
<a> import com . google . inject . name . Names ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . cpr . FrameworkConfig ; </a> 0
<a> import org . atmosphere . handler . ReflectorServletProcessor ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class AtmosphereGuiceServlet extends AtmosphereServlet { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( AtmosphereGuiceServlet . class ) ; </a> 0
<a> public static final String JERSEY_PROPERTIES = AtmosphereGuiceServlet . class . getName ( ) + ".properties" ; </a> 0
<a> private static final String GUICE_FILTER = "com.google.inject.servlet.GuiceFilter" ; </a> 0
<a> protected static final String SKIP_GUICE_FILTER = "SkipGuiceFilter" ; </a> 1
<a> private boolean guiceInstalled = false ; </a> 0
<a> @ Override </a> 0
<a> protected void loadConfiguration ( ServletConfig sc ) throws ServletException { </a> 1
<a> super . loadConfiguration ( sc ) ; </a> 0
<a> if ( ! guiceInstalled ) { </a> 0
<a> detectSupportedFramework ( sc ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean detectSupportedFramework ( ServletConfig sc ) { </a> 0
<a> Injector injector = ( Injector ) config . getServletContext ( ) . getAttribute ( Injector . class . getName ( ) ) ; </a> 0
<a> GuiceContainer guiceServlet = injector . getInstance ( GuiceContainer . class ) ; </a> 0
<a> setUseStreamForFlushingComments ( false ) ; </a> 0
<a> ReflectorServletProcessor rsp = new ReflectorServletProcessor ( ) ; </a> 0
<a> setDefaultBroadcasterClassName ( FrameworkConfig . JERSEY_BROADCASTER ) ; </a> 0
<a> setUseStreamForFlushingComments ( true ) ; </a> 0
<a> rsp . setServlet ( guiceServlet ) ; </a> 0
<a> if ( sc . getServletContext ( ) . getAttribute ( SKIP_GUICE_FILTER ) == null ) { </a> 1
<a> rsp . setFilterClassName ( GUICE_FILTER ) ; </a> 1
<a> } </a> 1
<a> getAtmosphereConfig ( ) . setSupportSession ( false ) ; </a> 0
<a> String mapping = sc . getInitParameter ( ApplicationConfig . PROPERTY_SERVLET_MAPPING ) ; </a> 0
<a> if ( mapping == null ) { </a> 0
<a> mapping = "/*" ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Map < String , String > props = injector . getInstance ( </a> 0
<a> Key . get ( new TypeLiteral < Map < String , String > > ( ) { </a> 0
<a> } , Names . named ( JERSEY_PROPERTIES ) ) ) ; </a> 0
<a> if ( props != null ) { </a> 0
<a> for ( String p : props . keySet ( ) ) { </a> 0
<a> addInitParameter ( p , props . get ( p ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> logger . debug ( "failed to add Jersey init parameters to Atmosphere servlet" , ex ) ; </a> 0
<a> } </a> 0
<a> addAtmosphereHandler ( mapping , rsp ) ; </a> 0
<a> guiceInstalled = true ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . atmosphere . guice ; </a> 0
<a> import com . google . inject . Inject ; </a> 0
<a> import com . google . inject . Injector ; </a> 0
<a> import com . google . inject . Scope ; </a> 0
<a> import com . google . inject . Singleton ; </a> 0
<a> import com . google . inject . servlet . ServletScopes ; </a> 0
<a> import com . sun . jersey . api . core . DefaultResourceConfig ; </a> 0
<a> import com . sun . jersey . api . core . ResourceConfig ; </a> 0
<a> import com . sun . jersey . core . spi . component . ComponentScope ; </a> 0
<a> import com . sun . jersey . core . spi . component . ioc . IoCComponentProviderFactory ; </a> 0
<a> import com . sun . jersey . guice . spi . container . GuiceComponentProviderFactory ; </a> 0
<a> import com . sun . jersey . spi . container . WebApplication ; </a> 0
<a> import com . sun . jersey . spi . container . servlet . ServletContainer ; </a> 0
<a> import com . sun . jersey . spi . container . servlet . WebConfig ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import java . util . Map ; </a> 0
<a> @ Singleton </a> 0
<a> public class GuiceContainer extends ServletContainer { </a> 0
<a> private static final long serialVersionUID = 1931878850157940335L ; </a> 0
<a> private final Injector injector ; </a> 0
<a> private WebApplication webapp ; </a> 0
<a> public class ServletGuiceComponentProviderFactory extends GuiceComponentProviderFactory { </a> 0
<a> public ServletGuiceComponentProviderFactory ( ResourceConfig config , Injector injector ) { </a> 0
<a> super ( config , injector ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Map < Scope , ComponentScope > createScopeMap ( ) { </a> 0
<a> Map < Scope , ComponentScope > m = super . createScopeMap ( ) ; </a> 0
<a> m . put ( ServletScopes . REQUEST , ComponentScope . PerRequest ) ; </a> 0
<a> return m ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Inject </a> 0
<a> public GuiceContainer ( Injector injector ) { </a> 0
<a> this . injector = injector ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ResourceConfig getDefaultResourceConfig ( Map < String , Object > props , </a> 0
<a> WebConfig webConfig ) throws ServletException { </a> 0
<a> return new DefaultResourceConfig ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void initiate ( ResourceConfig config , WebApplication webapp ) { </a> 0
<a> this . webapp = webapp ; </a> 0
<a> webapp . initiate ( config , new ServletGuiceComponentProviderFactory ( config , injector ) ) ; </a> 0
<a> } </a> 0
<a> public WebApplication getWebApplication ( ) { </a> 0
<a> return webapp ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . guice ; </a> 0
<a> import org . atmosphere . di . Injector ; </a> 0
<a> import org . atmosphere . di . ServletContextHolder ; </a> 0
<a> public final class GuiceInjector implements Injector { </a> 0
<a> @ Override </a> 0
<a> public void inject ( Object o ) { </a> 0
<a> com . google . inject . Injector injector = ( com . google . inject . Injector ) </a> 0
<a> ServletContextHolder . getServletContext ( ) . getAttribute ( com . google . inject . Injector . class . getName ( ) ) ; </a> 0
<a> if ( injector == null ) </a> 0
<a> throw new IllegalStateException ( "No Guice Injector found in current ServletContext !" ) ; </a> 0
<a> injector . injectMembers ( o ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . guice ; </a> 0
<a> import com . google . inject . Singleton ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> @ Singleton </a> 0
<a> public class GuiceManagedAtmosphereServlet extends AtmosphereGuiceServlet { </a> 0
<a> @ Override </a> 1
<a> protected void loadConfiguration ( ServletConfig sc ) throws ServletException { </a> 1
<a> sc . getServletContext ( ) . setAttribute ( SKIP_GUICE_FILTER , "true" ) ; </a> 1
<a> super . loadConfiguration ( sc ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . tests . guice ; </a> 0
<a> import com . ning . http . client . AsyncHttpClient ; </a> 0
<a> import com . ning . http . client . Response ; </a> 0
<a> import com . sun . grizzly . comet . CometAsyncFilter ; </a> 0
<a> import com . sun . grizzly . http . embed . GrizzlyWebServer ; </a> 0
<a> import com . sun . grizzly . http . servlet . ServletAdapter ; </a> 0
<a> import org . atmosphere . container . GrizzlyCometSupport ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . guice . AtmosphereGuiceServlet ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import org . testng . annotations . AfterMethod ; </a> 0
<a> import org . testng . annotations . BeforeMethod ; </a> 0
<a> import org . testng . annotations . Test ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import static org . testng . Assert . assertEquals ; </a> 0
<a> import static org . testng . Assert . assertNotNull ; </a> 0
<a> import static org . testng . Assert . assertTrue ; </a> 0
<a> import static org . testng . Assert . fail ; </a> 0
<a> public class GrizzlyGuiceJerseyTest { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( GrizzlyGuiceJerseyTest . class ) ; </a> 0
<a> protected static final String ROOT = "/*" ; </a> 0
<a> protected GrizzlyWebServer ws ; </a> 0
<a> protected ServletAdapter sa ; </a> 0
<a> protected AtmosphereServlet atmoServlet ; </a> 0
<a> public String urlTarget ; </a> 0
<a> public int port ; </a> 0
<a> public static class TestHelper { </a> 0
<a> public static int getEnvVariable ( final String varName , int defaultValue ) { </a> 0
<a> if ( null == varName ) { </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> String varValue = System . getenv ( varName ) ; </a> 0
<a> if ( null != varValue ) { </a> 0
<a> try { </a> 0
<a> return Integer . parseInt ( varValue ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ BeforeMethod ( alwaysRun = true ) </a> 0
<a> public void setUpGlobal ( ) throws Exception { </a> 0
<a> port = TestHelper . getEnvVariable ( "ATMOSPHERE_HTTP_PORT" , 9999 ) ; </a> 0
<a> urlTarget = "http://127.0.0.1:" + port + "/invoke" ; </a> 0
<a> atmoServlet = new AtmosphereGuiceServlet ( ) ; </a> 0
<a> atmoServlet . addInitParameter ( "com.sun.jersey.config.property.packages" , this . getClass ( ) . getPackage ( ) . getName ( ) ) ; </a> 0
<a> configureCometSupport ( ) ; </a> 0
<a> startServer ( ) ; </a> 0
<a> } </a> 0
<a> @ AfterMethod ( alwaysRun = true ) </a> 0
<a> public void unsetAtmosphereHandler ( ) throws Exception { </a> 0
<a> if ( atmoServlet != null ) atmoServlet . destroy ( ) ; </a> 0
<a> stopServer ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 ) </a> 0
<a> public void testSuspendTimeout ( ) { </a> 0
<a> logger . info ( "running test: testSuspendTimeout" ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( 10 , TimeUnit . SECONDS ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> String resume = r . getResponseBody ( ) ; </a> 0
<a> assertEquals ( resume , "resume" ) ; </a> 0
<a> long current = System . currentTimeMillis ( ) - t1 ; </a> 0
<a> assertTrue ( current > 5000 && current < 10000 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> public void configureCometSupport ( ) { </a> 0
<a> atmoServlet . setCometSupport ( new GrizzlyCometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 0
<a> public void startServer ( ) throws Exception { </a> 0
<a> ws = new GrizzlyWebServer ( port ) ; </a> 0
<a> sa = new ServletAdapter ( ) ; </a> 0
<a> ws . addAsyncFilter ( new CometAsyncFilter ( ) ) ; </a> 0
<a> sa . setServletInstance ( atmoServlet ) ; </a> 0
<a> ws . addGrizzlyAdapter ( sa , new String [ ] { ROOT } ) ; </a> 0
<a> sa . addServletListener ( GuiceConfig . class . getName ( ) ) ; </a> 0
<a> ws . start ( ) ; </a> 0
<a> } </a> 0
<a> public void stopServer ( ) throws Exception { </a> 0
<a> ws . stop ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . tests . guice ; </a> 0
<a> import com . google . inject . Guice ; </a> 0
<a> import com . google . inject . Injector ; </a> 0
<a> import com . google . inject . TypeLiteral ; </a> 0
<a> import com . google . inject . name . Names ; </a> 0
<a> import com . google . inject . servlet . GuiceServletContextListener ; </a> 0
<a> import com . google . inject . servlet . ServletModule ; </a> 0
<a> import org . atmosphere . guice . AtmosphereGuiceServlet ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class GuiceConfig extends GuiceServletContextListener { </a> 0
<a> @ Override </a> 0
<a> protected Injector getInjector ( ) { </a> 0
<a> return Guice . createInjector ( new ServletModule ( ) { </a> 0
<a> @ Override </a> 0
<a> protected void configureServlets ( ) { </a> 0
<a> bind ( PubSubTest . class ) ; </a> 0
<a> bind ( new TypeLiteral < Map < String , String > > ( ) { </a> 0
<a> } ) . annotatedWith ( Names . named ( AtmosphereGuiceServlet . JERSEY_PROPERTIES ) ) . toInstance ( </a> 0
<a> Collections . < String , String > emptyMap ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client ; </a> 0
<a> import com . google . gwt . core . client . Duration ; </a> 0
<a> import com . google . gwt . core . client . GWT ; </a> 0
<a> import com . google . gwt . core . client . JsArrayString ; </a> 0
<a> import com . google . gwt . core . client . Scheduler ; </a> 0
<a> import com . google . gwt . event . shared . HandlerRegistration ; </a> 0
<a> import com . google . gwt . user . client . Timer ; </a> 0
<a> import com . google . gwt . user . client . rpc . AsyncCallback ; </a> 0
<a> import org . atmosphere . gwt . client . extra . LoadRegister ; </a> 1
<a> import org . atmosphere . gwt . client . extra . LoadRegister . BeforeUnloadEvent ; </a> 1
<a> import org . atmosphere . gwt . client . extra . LoadRegister . UnloadEvent ; </a> 1
<a> import org . atmosphere . gwt . client . impl . CometTransport ; </a> 0
<a> import org . atmosphere . gwt . client . impl . WebSocketCometTransport ; </a> 0
<a> import java . io . Serializable ; </a> 1
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . logging . Level ; </a> 0
<a> import java . util . logging . Logger ; </a> 0
<a> public class AtmosphereClient { </a> 0
<a> private enum RefreshState { </a> 0
<a> CONNECTING , PRIMARY_DISCONNECTED , REFRESH_CONNECTED </a> 1
<a> } </a> 0
<a> private String url ; </a> 0
<a> private final AtmosphereGWTSerializer serializer ; </a> 0
<a> private final AtmosphereListener listener ; </a> 0
<a> private CometClientTransportWrapper primaryTransport ; </a> 0
<a> private CometClientTransportWrapper refreshTransport ; </a> 0
<a> private HandlerRegistration unloadHandlerReg ; </a> 0
<a> private boolean running ; </a> 0
<a> private RefreshState refreshState ; </a> 0
<a> private List < Object > refreshQueue ; </a> 0
<a> private static final Object REFRESH = new Object ( ) ; </a> 0
<a> private static final Object DISCONNECT = new Object ( ) ; </a> 0
<a> private int connectionCount ; </a> 0
<a> private int connectionTimeout = 10000 ; </a> 0
<a> private int reconnectionTimeout = 1000 ; </a> 0
<a> private boolean webSocketsEnabled = false ; </a> 0
<a> private Logger logger = Logger . getLogger ( getClass ( ) . getName ( ) ) ; </a> 0
<a> private AsyncCallback < Void > postCallback = new AsyncCallback < Void > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onFailure ( Throwable caught ) { </a> 0
<a> logger . log ( Level . SEVERE , "Failed to post message" , caught ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onSuccess ( Void result ) { </a> 0
<a> if ( logger . isLoggable ( Level . FINEST ) ) { </a> 0
<a> logger . log ( Level . FINEST , "post succeeded" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> public AtmosphereClient ( String url , AtmosphereListener listener ) { </a> 0
<a> this ( url , null , listener ) ; </a> 0
<a> } </a> 0
<a> public AtmosphereClient ( String url , AtmosphereGWTSerializer serializer , AtmosphereListener listener ) { </a> 0
<a> this ( url , serializer , listener , false ) ; </a> 0
<a> } </a> 0
<a> public AtmosphereClient ( String url , AtmosphereGWTSerializer serializer , AtmosphereListener listener , boolean webSocketsEnabled ) { </a> 0
<a> this . url = url ; </a> 0
<a> this . serializer = serializer ; </a> 0
<a> this . listener = listener ; </a> 0
<a> this . webSocketsEnabled = webSocketsEnabled ; </a> 0
<a> primaryTransport = new CometClientTransportWrapper ( ) ; </a> 0
<a> } </a> 0
<a> public String getUrl ( ) { </a> 0
<a> return url ; </a> 0
<a> } </a> 0
<a> public void setUrl ( String url ) { </a> 0
<a> this . url = url ; </a> 0
<a> } </a> 0
<a> public AtmosphereGWTSerializer getSerializer ( ) { </a> 0
<a> return serializer ; </a> 0
<a> } </a> 0
<a> public AtmosphereListener getListener ( ) { </a> 0
<a> return listener ; </a> 0
<a> } </a> 0
<a> public void setConnectionTimeout ( int connectionTimeout ) { </a> 0
<a> this . connectionTimeout = connectionTimeout ; </a> 0
<a> } </a> 0
<a> public int getConnectionTimeout ( ) { </a> 0
<a> return connectionTimeout ; </a> 0
<a> } </a> 0
<a> public void setReconnectionTimeout ( int reconnectionTimout ) { </a> 0
<a> this . reconnectionTimeout = reconnectionTimout ; </a> 0
<a> } </a> 0
<a> public int getReconnectionTimeout ( ) { </a> 0
<a> return reconnectionTimeout ; </a> 0
<a> } </a> 0
<a> public boolean isRunning ( ) { </a> 0
<a> return running ; </a> 0
<a> } </a> 0
<a> public int getConnectionID ( ) { </a> 0
<a> return primaryTransport . connectionID ; </a> 0
<a> } </a> 0
<a> public void post ( Serializable message ) { </a> 0
<a> primaryTransport . post ( message , postCallback ) ; </a> 0
<a> } </a> 0
<a> public void post ( Serializable message , AsyncCallback < Void > callback ) { </a> 0
<a> primaryTransport . post ( message , callback ) ; </a> 0
<a> } </a> 0
<a> public void post ( List < Serializable > messages ) { </a> 0
<a> primaryTransport . post ( messages , postCallback ) ; </a> 0
<a> } </a> 0
<a> public void post ( List < Serializable > messages , AsyncCallback < Void > callback ) { </a> 0
<a> primaryTransport . post ( messages , callback ) ; </a> 0
<a> } </a> 0
<a> public void broadcast ( Serializable message ) { </a> 0
<a> primaryTransport . broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> public void broadcast ( List < Serializable > messages ) { </a> 0
<a> primaryTransport . broadcast ( messages ) ; </a> 0
<a> } </a> 0
<a> public void start ( ) { </a> 0
<a> Scheduler . get ( ) . scheduleDeferred ( new Scheduler . ScheduledCommand ( ) { </a> 0
<a> @ Override </a> 0
<a> public void execute ( ) { </a> 0
<a> if ( ! running ) { </a> 0
<a> running = true ; </a> 0
<a> if ( unloadHandlerReg != null ) { </a> 0
<a> unloadHandlerReg . removeHandler ( ) ; </a> 0
<a> } </a> 0
<a> UnloadHandler handler = new UnloadHandler ( ) ; </a> 0
<a> final HandlerRegistration reg1 = LoadRegister . addBeforeUnloadHandler ( handler ) ; </a> 1
<a> final HandlerRegistration reg2 = LoadRegister . addUnloadHandler ( handler ) ; </a> 1
<a> unloadHandlerReg = new HandlerRegistration ( ) { </a> 0
<a> @ Override </a> 0
<a> public void removeHandler ( ) { </a> 0
<a> reg1 . removeHandler ( ) ; </a> 0
<a> reg2 . removeHandler ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> doConnect ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private class UnloadHandler implements LoadRegister . BeforeUnloadHandler , LoadRegister . UnloadHandler { </a> 1
<a> @ Override </a> 0
<a> public void onBeforeUnload ( BeforeUnloadEvent event ) { </a> 1
<a> doUnload ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onUnload ( UnloadEvent event ) { </a> 1
<a> doUnload ( ) ; </a> 0
<a> } </a> 0
<a> private void doUnload ( ) { </a> 0
<a> if ( ! done ) { </a> 0
<a> done = true ; </a> 0
<a> logger . log ( Level . FINE , "Stopping comet client because of page unload" ) ; </a> 0
<a> stop ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean done = false ; </a> 0
<a> } </a> 0
<a> public void stop ( ) { </a> 0
<a> if ( running ) { </a> 0
<a> running = false ; </a> 0
<a> if ( unloadHandlerReg != null ) { </a> 0
<a> unloadHandlerReg . removeHandler ( ) ; </a> 0
<a> unloadHandlerReg = null ; </a> 0
<a> } </a> 0
<a> doDisconnect ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void doConnect ( ) { </a> 0
<a> primaryTransport . connect ( ) ; </a> 0
<a> } </a> 0
<a> private void doDisconnect ( ) { </a> 0
<a> refreshState = null ; </a> 0
<a> primaryTransport . disconnect ( ) ; </a> 0
<a> if ( refreshTransport != null ) { </a> 0
<a> refreshTransport . disconnect ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void doOnConnected ( int heartbeat , int connectionID , CometClientTransportWrapper transport ) { </a> 0
<a> if ( refreshState != null ) { </a> 0
<a> if ( transport == refreshTransport ) { </a> 0
<a> if ( refreshState == RefreshState . PRIMARY_DISCONNECTED ) { </a> 0
<a> doneRefresh ( ) ; </a> 0
<a> } else if ( refreshState == RefreshState . CONNECTING ) { </a> 0
<a> primaryTransport . disconnect ( ) ; </a> 0
<a> doneRefresh ( ) ; </a> 0
<a> } else { </a> 0
<a> throw new IllegalStateException ( "Unexpected refresh state" ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> throw new IllegalStateException ( "Unexpected connection from primairyTransport" ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> listener . onConnected ( heartbeat , connectionID ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void doOnBeforeDisconnected ( CometClientTransportWrapper transport ) { </a> 0
<a> if ( refreshState == null && transport == primaryTransport ) { </a> 0
<a> listener . onBeforeDisconnected ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void doOnDisconnected ( CometClientTransportWrapper transport ) { </a> 0
<a> if ( refreshState != null ) { </a> 0
<a> if ( transport == primaryTransport ) { </a> 0
<a> if ( refreshState != RefreshState . CONNECTING ) { </a> 1
<a> throw new IllegalStateException ( "Unexpected refreshState" ) ; </a> 0
<a> } </a> 0
<a> refreshState = RefreshState . PRIMARY_DISCONNECTED ; </a> 0
<a> GWT . log ( "CometClient: primary disconnected before refresh transport was connected" ) ; </a> 1
<a> } else { </a> 0
<a> failedRefresh ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> listener . onDisconnected ( ) ; </a> 0
<a> if ( running ) { </a> 1
<a> doConnect ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> private void failedRefresh ( ) { </a> 0
<a> refreshState = null ; </a> 0
<a> GWT . log ( "CometClient: Failed refesh" ) ; </a> 1
<a> if ( refreshQueue != null ) { </a> 0
<a> for ( Object object : refreshQueue ) { </a> 0
<a> if ( object == REFRESH || object == DISCONNECT ) { </a> 0
<a> } else { </a> 0
<a> doOnMessage ( ( List < ? extends Serializable > ) object , primaryTransport ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> refreshQueue . clear ( ) ; </a> 0
<a> } </a> 0
<a> doDisconnect ( ) ; </a> 0
<a> doConnect ( ) ; </a> 1
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> private void doneRefresh ( ) { </a> 0
<a> refreshState = null ; </a> 0
<a> CometClientTransportWrapper temp = primaryTransport ; </a> 0
<a> primaryTransport = refreshTransport ; </a> 0
<a> refreshTransport = temp ; </a> 0
<a> if ( refreshQueue != null ) { </a> 0
<a> if ( refreshQueue . size ( ) > 0 ) { </a> 0
<a> GWT . log ( "CometClient: pushing queued messages" ) ; </a> 1
<a> } </a> 0
<a> for ( Object object : refreshQueue ) { </a> 0
<a> if ( object == REFRESH ) { </a> 0
<a> doOnRefresh ( primaryTransport ) ; </a> 0
<a> } else if ( object == DISCONNECT ) { </a> 0
<a> doOnDisconnected ( primaryTransport ) ; </a> 0
<a> } else { </a> 0
<a> doOnMessage ( ( List < ? extends Serializable > ) object , primaryTransport ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> refreshQueue . clear ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void doOnHeartbeat ( CometClientTransportWrapper transport ) { </a> 0
<a> if ( transport == primaryTransport ) { </a> 0
<a> listener . onHeartbeat ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void doOnRefresh ( CometClientTransportWrapper transport ) { </a> 0
<a> if ( refreshState == null && transport == primaryTransport ) { </a> 0
<a> refreshState = RefreshState . CONNECTING ; </a> 0
<a> if ( refreshTransport == null ) { </a> 0
<a> refreshTransport = new CometClientTransportWrapper ( ) ; </a> 0
<a> } </a> 0
<a> refreshTransport . connect ( ) ; </a> 0
<a> listener . onRefresh ( ) ; </a> 0
<a> } else if ( transport == refreshTransport ) { </a> 0
<a> refreshEnqueue ( REFRESH ) ; </a> 0
<a> } else { </a> 0
<a> throw new IllegalStateException ( "Unexpected refresh from primaryTransport" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void refreshEnqueue ( Object message ) { </a> 0
<a> if ( refreshQueue == null ) { </a> 0
<a> refreshQueue = new ArrayList < Object > ( ) ; </a> 0
<a> } </a> 0
<a> refreshQueue . add ( message ) ; </a> 0
<a> } </a> 0
<a> private void doOnError ( Throwable exception , boolean connected , CometClientTransportWrapper transport ) { </a> 0
<a> if ( connected ) { </a> 0
<a> doDisconnect ( ) ; </a> 1
<a> } </a> 0
<a> listener . onError ( exception , connected ) ; </a> 0
<a> if ( running ) { </a> 1
<a> primaryTransport . reconnectionTimer . schedule ( reconnectionTimeout ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> private void doOnMessage ( List < ? extends Serializable > messages , CometClientTransportWrapper transport ) { </a> 1
<a> if ( transport == primaryTransport ) { </a> 0
<a> listener . onMessage ( messages ) ; </a> 0
<a> } else if ( RefreshState . PRIMARY_DISCONNECTED . equals ( refreshState ) ) { </a> 0
<a> refreshEnqueue ( messages ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class CometClientTransportWrapper implements AtmosphereListener { </a> 0
<a> private CometTransport transport ; </a> 0
<a> private final Timer connectionTimer = createConnectionTimer ( ) ; </a> 0
<a> private final Timer reconnectionTimer = createReconnectionTimer ( ) ; </a> 0
<a> private final Timer heartbeatTimer = createHeartbeatTimer ( ) ; </a> 0
<a> private boolean webSocketSuccessful = false ; </a> 0
<a> private int heartbeatTimeout ; </a> 0
<a> private double lastReceivedTime ; </a> 0
<a> private int connectionID ; </a> 0
<a> public CometClientTransportWrapper ( ) { </a> 0
<a> if ( webSocketsEnabled && WebSocketCometTransport . hasWebSocketSupport ( ) ) { </a> 0
<a> transport = new WebSocketCometTransport ( ) ; </a> 0
<a> } else { </a> 0
<a> transport = GWT . create ( CometTransport . class ) ; </a> 0
<a> } </a> 0
<a> GWT . log ( "Created transport: " + transport . getClass ( ) . getName ( ) ) ; </a> 1
<a> transport . initiate ( AtmosphereClient . this , this ) ; </a> 0
<a> } </a> 0
<a> public void post ( Serializable message , AsyncCallback < Void > callback ) { </a> 0
<a> transport . post ( message , callback ) ; </a> 0
<a> } </a> 0
<a> public void post ( List < Serializable > messages , AsyncCallback < Void > callback ) { </a> 0
<a> transport . post ( messages , callback ) ; </a> 0
<a> } </a> 0
<a> public void broadcast ( Serializable message ) { </a> 0
<a> transport . broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> public void broadcast ( List < Serializable > messages ) { </a> 0
<a> transport . broadcast ( messages ) ; </a> 0
<a> } </a> 0
<a> public int getConnectionID ( ) { </a> 0
<a> return connectionID ; </a> 0
<a> } </a> 0
<a> public void connect ( ) { </a> 0
<a> connectionTimer . schedule ( connectionTimeout ) ; </a> 0
<a> transport . connect ( ++ connectionCount ) ; </a> 0
<a> } </a> 0
<a> public void disconnect ( ) { </a> 0
<a> cancelTimers ( ) ; </a> 1
<a> transport . disconnect ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onConnected ( int heartbeat , int connectionID ) { </a> 0
<a> heartbeatTimeout = heartbeat + connectionTimeout ; </a> 0
<a> lastReceivedTime = Duration . currentTimeMillis ( ) ; </a> 0
<a> this . connectionID = connectionID ; </a> 0
<a> if ( transport instanceof WebSocketCometTransport ) { </a> 0
<a> webSocketSuccessful = true ; </a> 0
<a> } </a> 0
<a> cancelTimers ( ) ; </a> 1
<a> heartbeatTimer . schedule ( heartbeatTimeout ) ; </a> 0
<a> doOnConnected ( heartbeat , connectionID , this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onBeforeDisconnected ( ) { </a> 0
<a> doOnBeforeDisconnected ( this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDisconnected ( ) { </a> 0
<a> cancelTimers ( ) ; </a> 1
<a> if ( transport instanceof WebSocketCometTransport && webSocketSuccessful == false ) { </a> 0
<a> transport = GWT . create ( CometTransport . class ) ; </a> 0
<a> transport . initiate ( AtmosphereClient . this , this ) ; </a> 0
<a> } </a> 0
<a> doOnDisconnected ( this ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onError ( Throwable exception , boolean connected ) { </a> 0
<a> cancelTimers ( ) ; </a> 1
<a> doOnError ( exception , connected , this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onHeartbeat ( ) { </a> 0
<a> lastReceivedTime = Duration . currentTimeMillis ( ) ; </a> 0
<a> doOnHeartbeat ( this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onRefresh ( ) { </a> 0
<a> lastReceivedTime = Duration . currentTimeMillis ( ) ; </a> 0
<a> doOnRefresh ( this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onMessage ( List < ? extends Serializable > messages ) { </a> 0
<a> lastReceivedTime = Duration . currentTimeMillis ( ) ; </a> 0
<a> doOnMessage ( messages , this ) ; </a> 0
<a> } </a> 0
<a> private void cancelTimers ( ) { </a> 1
<a> connectionTimer . cancel ( ) ; </a> 1
<a> reconnectionTimer . cancel ( ) ; </a> 1
<a> heartbeatTimer . cancel ( ) ; </a> 1
<a> } </a> 1
<a> private Timer createConnectionTimer ( ) { </a> 0
<a> return new Timer ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> doDisconnect ( ) ; </a> 0
<a> doOnError ( new TimeoutException ( url , connectionTimeout ) , false , CometClientTransportWrapper . this ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> private Timer createHeartbeatTimer ( ) { </a> 0
<a> return new Timer ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> double currentTimeMillis = Duration . currentTimeMillis ( ) ; </a> 0
<a> double difference = currentTimeMillis - lastReceivedTime ; </a> 0
<a> if ( difference >= heartbeatTimeout ) { </a> 0
<a> doDisconnect ( ) ; </a> 0
<a> doOnError ( new AtmosphereClientException ( "Heartbeat failed" ) , false , CometClientTransportWrapper . this ) ; </a> 0
<a> } else { </a> 0
<a> schedule ( heartbeatTimeout - ( int ) difference ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> private Timer createReconnectionTimer ( ) { </a> 0
<a> return new Timer ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> if ( running ) { </a> 0
<a> doConnect ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public native static JsArrayString split ( String string , String separator ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client ; </a> 0
<a> public class AtmosphereClientException extends Exception { </a> 0
<a> private static final long serialVersionUID = 1274546262360559017L ; </a> 0
<a> public AtmosphereClientException ( ) { </a> 0
<a> super ( ) ; </a> 0
<a> } </a> 0
<a> public AtmosphereClientException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public AtmosphereClientException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public AtmosphereClientException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client ; </a> 0
<a> import com . google . gwt . core . client . GWT ; </a> 0
<a> import com . google . gwt . rpc . client . impl . ClientWriterFactory ; </a> 0
<a> import com . google . gwt . user . client . rpc . SerializationException ; </a> 0
<a> import com . google . gwt . user . client . rpc . SerializationStreamReader ; </a> 0
<a> import com . google . gwt . user . client . rpc . impl . ClientSerializationStreamReader ; </a> 0
<a> import com . google . gwt . user . client . rpc . impl . ClientSerializationStreamWriter ; </a> 0
<a> import com . google . gwt . user . client . rpc . impl . Serializer ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> public abstract class AtmosphereGWTSerializer { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> public < T extends Serializable > T parse ( String message ) throws SerializationException { </a> 0
<a> if ( getMode ( ) == SerialMode . RPC ) { </a> 0
<a> try { </a> 0
<a> Serializer serializer = getSerializer ( ) ; </a> 0
<a> ClientSerializationStreamReader reader = new ClientSerializationStreamReader ( serializer ) ; </a> 0
<a> reader . prepareToRead ( message ) ; </a> 0
<a> return ( T ) reader . readObject ( ) ; </a> 0
<a> } catch ( RuntimeException e ) { </a> 0
<a> throw new SerializationException ( e ) ; </a> 0
<a> } </a> 0
<a> } else if ( getMode ( ) == SerialMode . DE_RPC ) { </a> 0
<a> try { </a> 0
<a> SerializationStreamReader reader = ClientWriterFactory . createReader ( message ) ; </a> 0
<a> return ( T ) reader . readObject ( ) ; </a> 0
<a> } catch ( RuntimeException e ) { </a> 0
<a> throw new SerializationException ( e ) ; </a> 0
<a> } </a> 0
<a> } else if ( getMode ( ) == SerialMode . PLAIN ) { </a> 0
<a> return ( T ) message ; </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( "Not implemented yet" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> public < T extends Serializable > String serialize ( T message ) throws SerializationException { </a> 0
<a> if ( getPushMode ( ) == SerialMode . RPC ) { </a> 0
<a> try { </a> 0
<a> Serializer serializer = getSerializer ( ) ; </a> 0
<a> ClientSerializationStreamWriter writer = new ClientSerializationStreamWriter ( serializer , GWT . getModuleBaseURL ( ) , GWT . getPermutationStrongName ( ) ) ; </a> 0
<a> writer . prepareToWrite ( ) ; </a> 0
<a> writer . writeObject ( message ) ; </a> 0
<a> return writer . toString ( ) ; </a> 0
<a> } catch ( RuntimeException e ) { </a> 0
<a> throw new SerializationException ( e ) ; </a> 0
<a> } </a> 0
<a> } else if ( getPushMode ( ) == SerialMode . PLAIN ) { </a> 0
<a> return message . toString ( ) ; </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( "Not implemented yet" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected abstract Serializer getSerializer ( ) ; </a> 0
<a> public abstract SerialMode getMode ( ) ; </a> 0
<a> public abstract SerialMode getPushMode ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> public @ interface SerialTypes { </a> 0
<a> Class < ? extends Serializable > [ ] value ( ) ; </a> 0
<a> SerialMode mode ( ) default SerialMode . RPC ; </a> 0
<a> SerialMode pushmode ( ) default SerialMode . RPC ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client ; </a> 0
<a> public class TimeoutException extends AtmosphereClientException { </a> 0
<a> private static final long serialVersionUID = 4432979311906335074L ; </a> 0
<a> public TimeoutException ( String url , int timeoutMillis ) { </a> 0
<a> super ( url + " timeout has expired after " + timeoutMillis + "ms" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . extra ; </a> 0
<a> import com . google . gwt . dom . client . Document ; </a> 1
<a> import com . google . gwt . dom . client . Element ; </a> 1
<a> import com . google . gwt . event . logical . shared . CloseEvent ; </a> 0
<a> import com . google . gwt . event . logical . shared . CloseHandler ; </a> 0
<a> import com . google . gwt . event . shared . EventHandler ; </a> 0
<a> import com . google . gwt . event . shared . GwtEvent ; </a> 0
<a> import com . google . gwt . event . shared . HandlerRegistration ; </a> 0
<a> import com . google . gwt . event . shared . SimpleEventBus ; </a> 0
<a> import com . google . gwt . user . client . Window ; </a> 0
<a> import com . google . gwt . user . client . Window . ClosingEvent ; </a> 0
<a> public class LoadRegister { </a> 0
<a> public static class BeforeUnloadEvent extends GwtEvent < BeforeUnloadHandler > { </a> 0
<a> private static Type TYPE ; </a> 0
<a> public static Type < BeforeUnloadHandler > getType ( ) { </a> 0
<a> return TYPE != null ? TYPE : ( TYPE = new Type ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Type < BeforeUnloadHandler > getAssociatedType ( ) { </a> 0
<a> return getType ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void dispatch ( BeforeUnloadHandler handler ) { </a> 0
<a> handler . onBeforeUnload ( this ) ; </a> 0
<a> } </a> 0
<a> protected BeforeUnloadEvent ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected static final BeforeUnloadEvent beforeUnloadEvent = new BeforeUnloadEvent ( ) ; </a> 0
<a> public static class UnloadEvent extends GwtEvent < UnloadHandler > { </a> 0
<a> private static Type TYPE ; </a> 0
<a> public static Type < UnloadHandler > getType ( ) { </a> 0
<a> return TYPE != null ? TYPE : ( TYPE = new Type ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Type < UnloadHandler > getAssociatedType ( ) { </a> 0
<a> return getType ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void dispatch ( UnloadHandler handler ) { </a> 0
<a> handler . onUnload ( this ) ; </a> 0
<a> } </a> 0
<a> protected UnloadEvent ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected static final UnloadEvent unloadEvent = new UnloadEvent ( ) ; </a> 0
<a> public interface BeforeUnloadHandler extends EventHandler { </a> 0
<a> public void onBeforeUnload ( BeforeUnloadEvent event ) ; </a> 0
<a> } </a> 0
<a> public interface UnloadHandler extends EventHandler { </a> 0
<a> public void onUnload ( UnloadEvent event ) ; </a> 0
<a> } </a> 0
<a> public static HandlerRegistration addBeforeUnloadHandler ( BeforeUnloadHandler handler ) { </a> 1
<a> maybeInit ( ) ; </a> 0
<a> return eventBus . addHandler ( BeforeUnloadEvent . getType ( ) , handler ) ; </a> 1
<a> } </a> 0
<a> public static HandlerRegistration addUnloadHandler ( UnloadHandler handler ) { </a> 1
<a> maybeInit ( ) ; </a> 0
<a> return eventBus . addHandler ( UnloadEvent . getType ( ) , handler ) ; </a> 1
<a> } </a> 0
<a> private static void maybeInit ( ) { </a> 0
<a> if ( ! initialized ) { </a> 0
<a> if ( isFirefox ( ) ) { </a> 1
<a> initWindowHandlers ( ) ; </a> 0
<a> } else { </a> 1
<a> initRootHandlers ( Document . get ( ) . getBody ( ) ) ; </a> 1
<a> } </a> 1
<a> initialized = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static String onBeforeUnload ( ) { </a> 0
<a> eventBus . fireEvent ( beforeUnloadEvent ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> static void onUnload ( ) { </a> 0
<a> eventBus . fireEvent ( unloadEvent ) ; </a> 0
<a> } </a> 0
<a> private static boolean isFirefox ( ) { </a> 1
<a> String ua = userAgent ( ) ; </a> 1
<a> return ua . indexOf ( "gecko" ) != - 1 && ua . indexOf ( "webkit" ) == - 1 ; </a> 1
<a> } </a> 0
<a> ; </a> 1
<a> private static native String userAgent ( ) ; </a> 0
<a> private static native Element getWindow ( ) ; </a> 0
<a> private static void initWindowHandlers ( ) { </a> 0
<a> Window . addWindowClosingHandler ( new Window . ClosingHandler ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onWindowClosing ( ClosingEvent event ) { </a> 0
<a> onBeforeUnload ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Window . addCloseHandler ( new CloseHandler < Window > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClose ( CloseEvent < Window > event ) { </a> 0
<a> onUnload ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private static native void initRootHandlers ( Element element ) ; </a> 0
<a> private static SimpleEventBus eventBus = new SimpleEventBus ( ) ; </a> 0
<a> private static boolean initialized = false ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . extra ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptException ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptObject ; </a> 0
<a> public final class Window extends JavaScriptObject { </a> 0
<a> public static native Window current ( ) ; </a> 0
<a> public Window open ( String url , String name , WindowFeatures features ) { </a> 0
<a> return open ( url , name , features . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> public native Window open ( String url , String name , String features ) ; </a> 0
<a> public native void close ( ) ; </a> 0
<a> public native void set ( String name , boolean flag ) ; </a> 0
<a> public native void set ( String name , int value ) ; </a> 0
<a> public native void set ( String name , String value ) ; </a> 0
<a> public native void set ( String name , Object value ) ; </a> 0
<a> public native boolean isset ( String name ) ; </a> 0
<a> public native boolean getFlag ( String name ) ; </a> 0
<a> public native int getInt ( String name ) throws JavaScriptException ; </a> 0
<a> public native String getString ( String name ) throws JavaScriptException ; </a> 0
<a> public native < X > X getObject ( String name ) throws JavaScriptException ; </a> 0
<a> protected Window ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . extra ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class WindowFeatures { </a> 0
<a> private Map < String , Integer > intValues = new HashMap < String , Integer > ( ) ; </a> 0
<a> private Map < String , Boolean > options = new HashMap < String , Boolean > ( ) ; </a> 0
<a> public WindowFeatures ( ) { </a> 0
<a> } </a> 0
<a> public WindowFeatures ( Integer left , Integer top , Integer height , Integer width ) { </a> 0
<a> setLeft ( left ) ; </a> 0
<a> setTop ( top ) ; </a> 0
<a> setWidth ( width ) ; </a> 0
<a> setHeight ( height ) ; </a> 0
<a> } </a> 0
<a> public WindowFeatures ( Boolean menubar , Boolean toolbar , Boolean location , Boolean personalbar , Boolean status ) { </a> 0
<a> setMenubar ( menubar ) ; </a> 0
<a> setToolbar ( toolbar ) ; </a> 0
<a> setLocation ( location ) ; </a> 0
<a> setPersonalbar ( personalbar ) ; </a> 0
<a> setStatus ( status ) ; </a> 0
<a> } </a> 0
<a> public WindowFeatures set ( String name , Integer value ) { </a> 0
<a> intValues . put ( name , value ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures set ( String name , Boolean option ) { </a> 0
<a> options . put ( name , option ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setDependent ( Boolean dependent ) { </a> 0
<a> options . put ( "dependent" , dependent ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setDialog ( Boolean dialog ) { </a> 0
<a> options . put ( "dialog" , dialog ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setFullscreen ( Boolean fullscreen ) { </a> 0
<a> options . put ( "fullscreen" , fullscreen ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setHeight ( Integer height ) { </a> 0
<a> intValues . put ( "height" , height ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setLeft ( Integer left ) { </a> 0
<a> intValues . put ( "left" , left ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setLocation ( Boolean location ) { </a> 0
<a> options . put ( "location" , location ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setMenubar ( Boolean menubar ) { </a> 0
<a> options . put ( "menubar" , menubar ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setMinimizable ( Boolean minimizable ) { </a> 0
<a> options . put ( "minimizable" , minimizable ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setPersonalbar ( Boolean personalbar ) { </a> 0
<a> options . put ( "personalbar" , personalbar ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setResizable ( Boolean resizable ) { </a> 0
<a> options . put ( "resizable" , resizable ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setScrollbars ( Boolean scrollbars ) { </a> 0
<a> options . put ( "scrollbars" , scrollbars ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setStatus ( Boolean status ) { </a> 0
<a> options . put ( "status" , status ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setToolbar ( Boolean toolbar ) { </a> 0
<a> options . put ( "toolbar" , toolbar ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setTop ( Integer top ) { </a> 0
<a> intValues . put ( "top" , top ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public WindowFeatures setWidth ( Integer width ) { </a> 0
<a> intValues . put ( "width" , width ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public String toString ( ) { </a> 0
<a> PropertyBuilder b = new PropertyBuilder ( ) ; </a> 0
<a> for ( Map . Entry < String , Integer > e : intValues . entrySet ( ) ) { </a> 0
<a> b . add ( e . getKey ( ) , e . getValue ( ) ) ; </a> 0
<a> } </a> 0
<a> for ( Map . Entry < String , Boolean > e : options . entrySet ( ) ) { </a> 0
<a> b . add ( e . getKey ( ) , e . getValue ( ) ) ; </a> 0
<a> } </a> 0
<a> return b . toString ( ) ; </a> 0
<a> } </a> 0
<a> private static class PropertyBuilder { </a> 0
<a> StringBuilder result = new StringBuilder ( ) ; </a> 0
<a> public PropertyBuilder add ( String name , Boolean value ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> add ( name , value ? "yes" : "no" ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public PropertyBuilder add ( String name , Integer value ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> add ( name , value . toString ( ) ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public PropertyBuilder add ( String name , String value ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> if ( result . length ( ) > 0 ) { </a> 0
<a> result . append ( "," ) ; </a> 0
<a> } </a> 0
<a> result . append ( name ) . append ( '=' ) . append ( value ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public String toString ( ) { </a> 0
<a> return result . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . extra ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptObject ; </a> 0
<a> import com . google . gwt . event . shared . EventBus ; </a> 0
<a> import com . google . gwt . event . shared . EventHandler ; </a> 0
<a> import com . google . gwt . event . shared . GwtEvent ; </a> 0
<a> import com . google . gwt . event . shared . HandlerRegistration ; </a> 0
<a> import com . google . gwt . event . shared . SimpleEventBus ; </a> 0
<a> import com . google . gwt . user . client . Timer ; </a> 0
<a> public class WindowSocket { </a> 0
<a> public static class MessageEvent extends GwtEvent < MessageHandler > { </a> 0
<a> private static Type TYPE ; </a> 0
<a> private String message ; </a> 0
<a> public static Type getType ( ) { </a> 0
<a> return TYPE != null ? TYPE : ( TYPE = new Type ( ) ) ; </a> 0
<a> } </a> 0
<a> public MessageEvent ( String message ) { </a> 0
<a> this . message = message ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Type < MessageHandler > getAssociatedType ( ) { </a> 0
<a> return getType ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void dispatch ( MessageHandler handler ) { </a> 0
<a> handler . onMessage ( message ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static interface MessageHandler extends EventHandler { </a> 0
<a> public void onMessage ( String message ) ; </a> 0
<a> } </a> 0
<a> public static boolean exists ( Window w , String socketName ) { </a> 0
<a> return getSocket ( w , socketName ) != null ; </a> 0
<a> } </a> 0
<a> public static void post ( Window w , String socketName , String message ) { </a> 0
<a> SocketImpl s = getSocket ( w , socketName ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> s . post ( message ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void bind ( String name ) { </a> 0
<a> unbind ( ) ; </a> 0
<a> Window w = Window . current ( ) ; </a> 0
<a> socket = getSocket ( w , name ) ; </a> 0
<a> if ( socket == null ) { </a> 0
<a> Sockets sockets = w . getObject ( "sockets" ) ; </a> 0
<a> if ( sockets == null ) { </a> 0
<a> sockets = Sockets . create ( ) ; </a> 0
<a> w . set ( "sockets" , sockets ) ; </a> 0
<a> } </a> 0
<a> socket = SocketImpl . create ( name ) ; </a> 0
<a> sockets . set ( socket , name ) ; </a> 0
<a> } </a> 0
<a> queueTimer . scheduleRepeating ( 250 ) ; </a> 0
<a> } </a> 0
<a> public void unbind ( ) { </a> 0
<a> if ( socket != null ) { </a> 0
<a> Sockets sockets = Window . current ( ) . getObject ( "sockets" ) ; </a> 0
<a> sockets . remove ( socket ) ; </a> 0
<a> queueTimer . cancel ( ) ; </a> 0
<a> queueTimer . run ( ) ; </a> 0
<a> socket = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public HandlerRegistration addHandler ( MessageHandler handler ) { </a> 0
<a> return listeners . addHandler ( MessageEvent . getType ( ) , handler ) ; </a> 0
<a> } </a> 0
<a> private static SocketImpl getSocket ( Window w , String name ) { </a> 0
<a> Sockets sockets = w . getObject ( "sockets" ) ; </a> 0
<a> if ( sockets == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return sockets . get ( name ) ; </a> 0
<a> } </a> 0
<a> private SocketImpl socket ; </a> 0
<a> private EventBus listeners = new SimpleEventBus ( ) ; </a> 0
<a> private Timer queueTimer = new Timer ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> if ( socket != null ) { </a> 0
<a> String m ; </a> 0
<a> while ( ( m = socket . poll ( ) ) != null ) { </a> 0
<a> listeners . fireEvent ( new MessageEvent ( m ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private final static class SocketImpl extends JavaScriptObject { </a> 0
<a> private static native SocketImpl create ( String xname ) ; </a> 0
<a> public native void post ( String message ) ; </a> 0
<a> public native String poll ( ) ; </a> 0
<a> protected SocketImpl ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final static class Sockets extends JavaScriptObject { </a> 0
<a> public static native Sockets create ( ) ; </a> 0
<a> public native SocketImpl set ( SocketImpl socket , String name ) ; </a> 0
<a> public native SocketImpl get ( String name ) ; </a> 0
<a> public native void remove ( SocketImpl socket ) ; </a> 0
<a> protected Sockets ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . user . client . rpc . AsyncCallback ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClient ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereListener ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> public interface CometTransport { </a> 0
<a> public void initiate ( AtmosphereClient client , AtmosphereListener listener ) ; </a> 0
<a> public void connect ( int connectionCount ) ; </a> 0
<a> public void disconnect ( ) ; </a> 0
<a> public void post ( Serializable message , AsyncCallback < Void > callback ) ; </a> 0
<a> public void post ( List < Serializable > messages , AsyncCallback < Void > callback ) ; </a> 0
<a> public void broadcast ( Serializable message ) ; </a> 0
<a> public void broadcast ( List < Serializable > messages ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptException ; </a> 0
<a> import com . google . gwt . dom . client . NativeEvent ; </a> 0
<a> import com . google . gwt . event . dom . client . KeyCodes ; </a> 0
<a> import com . google . gwt . event . dom . client . KeyDownEvent ; </a> 0
<a> import com . google . gwt . http . client . RequestException ; </a> 0
<a> import com . google . gwt . user . client . Event ; </a> 0
<a> import com . google . gwt . user . client . Event . NativePreviewEvent ; </a> 0
<a> import com . google . gwt . user . client . Event . NativePreviewHandler ; </a> 0
<a> import com . google . gwt . user . client . Timer ; </a> 0
<a> import com . google . gwt . xhr . client . ReadyStateChangeHandler ; </a> 0
<a> import com . google . gwt . xhr . client . XMLHttpRequest ; </a> 0
<a> public class HTTPRequestCometTransport extends StreamingProtocolTransport { </a> 0
<a> static { </a> 0
<a> Event . addNativePreviewHandler ( new NativePreviewHandler ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onPreviewNativeEvent ( NativePreviewEvent e ) { </a> 0
<a> if ( e . getTypeInt ( ) == Event . getTypeInt ( KeyDownEvent . getType ( ) . getName ( ) ) ) { </a> 0
<a> NativeEvent nativeEvent = e . getNativeEvent ( ) ; </a> 0
<a> if ( nativeEvent . getKeyCode ( ) == KeyCodes . KEY_ESCAPE ) { </a> 0
<a> nativeEvent . preventDefault ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private final static int POLLING_INTERVAL = 250 ; </a> 0
<a> private XMLHttpRequest xmlHttpRequest ; </a> 0
<a> private Timer pollingTimer = new Timer ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> if ( xmlHttpRequest != null && read < xmlHttpRequest . getResponseText ( ) . length ( ) ) { </a> 0
<a> onReceiving ( xmlHttpRequest . getStatus ( ) , xmlHttpRequest . getResponseText ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> @ Override </a> 0
<a> public void connect ( int connectionCount ) { </a> 0
<a> init ( ) ; </a> 0
<a> xmlHttpRequest = XMLHttpRequest . create ( ) ; </a> 0
<a> try { </a> 0
<a> xmlHttpRequest . open ( "GET" , getUrl ( connectionCount ) ) ; </a> 0
<a> xmlHttpRequest . setRequestHeader ( "Accept" , "application/comet" ) ; </a> 0
<a> xmlHttpRequest . setOnReadyStateChange ( new ReadyStateChangeHandler ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onReadyStateChange ( XMLHttpRequest request ) { </a> 0
<a> if ( ! aborted ) { </a> 0
<a> switch ( request . getReadyState ( ) ) { </a> 0
<a> case XMLHttpRequest . LOADING : </a> 0
<a> onReceiving ( request . getStatus ( ) , request . getResponseText ( ) ) ; </a> 0
<a> if ( needPolling ( ) ) { </a> 0
<a> pollingTimer . scheduleRepeating ( POLLING_INTERVAL ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> case XMLHttpRequest . DONE : </a> 0
<a> onLoaded ( request . getStatus ( ) , request . getResponseText ( ) ) ; </a> 0
<a> pollingTimer . cancel ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> request . clearOnReadyStateChange ( ) ; </a> 0
<a> if ( request . getReadyState ( ) != XMLHttpRequest . DONE ) { </a> 0
<a> request . abort ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> xmlHttpRequest . send ( ) ; </a> 0
<a> } catch ( JavaScriptException e ) { </a> 0
<a> if ( xmlHttpRequest != null ) { </a> 0
<a> xmlHttpRequest . abort ( ) ; </a> 0
<a> xmlHttpRequest = null ; </a> 0
<a> } </a> 0
<a> listener . onError ( new RequestException ( e . getMessage ( ) ) , false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void disconnect ( ) { </a> 0
<a> aborted = true ; </a> 0
<a> expectingDisconnection = true ; </a> 0
<a> super . disconnect ( ) ; </a> 0
<a> if ( xmlHttpRequest != null ) { </a> 0
<a> if ( xmlHttpRequest . getReadyState ( ) >= XMLHttpRequest . HEADERS_RECEIVED ) { </a> 0
<a> xmlHttpRequest . clearOnReadyStateChange ( ) ; </a> 0
<a> if ( xmlHttpRequest . getReadyState ( ) != XMLHttpRequest . DONE ) { </a> 0
<a> listener . onDisconnected ( ) ; </a> 0
<a> xmlHttpRequest . abort ( ) ; </a> 0
<a> } </a> 0
<a> xmlHttpRequest = null ; </a> 0
<a> } else { </a> 0
<a> new Timer ( ) { </a> 0
<a> XMLHttpRequest r = xmlHttpRequest ; </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> r . clearOnReadyStateChange ( ) ; </a> 0
<a> if ( r . getReadyState ( ) != XMLHttpRequest . DONE </a> 0
<a> && r . getReadyState ( ) != XMLHttpRequest . UNSENT ) { </a> 0
<a> listener . onDisconnected ( ) ; </a> 0
<a> r . abort ( ) ; </a> 0
<a> } </a> 0
<a> r = null ; </a> 0
<a> } </a> 0
<a> } . schedule ( 5000 ) ; </a> 0
<a> xmlHttpRequest = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected boolean needPolling ( ) { </a> 0
<a> String ua = getUserAgent ( ) ; </a> 0
<a> return ua . contains ( "opera" ) ; </a> 0
<a> } </a> 0
<a> public native static String getUserAgent ( ) ; </a> 0
<a> private void onLoaded ( int statusCode , String responseText ) { </a> 0
<a> xmlHttpRequest . clearOnReadyStateChange ( ) ; </a> 0
<a> xmlHttpRequest = null ; </a> 0
<a> onReceiving ( statusCode , responseText , false ) ; </a> 0
<a> } </a> 0
<a> private void onReceiving ( int statusCode , String responseText ) { </a> 0
<a> onReceiving ( statusCode , responseText , true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptObject ; </a> 0
<a> import com . google . gwt . dom . client . IFrameElement ; </a> 0
<a> public class IEHTMLFileCometTransport extends IFrameCometTransport { </a> 0
<a> private JavaScriptObject htmlFileWrapper ; </a> 0
<a> @ Override </a> 0
<a> protected IFrameElement createIFrame ( String html ) { </a> 0
<a> return createIFrameImpl ( this , html ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void destroyIFrame ( ) { </a> 0
<a> destroyHtmlFile ( ) ; </a> 0
<a> } </a> 0
<a> private static native IFrameElement createIFrameImpl ( IFrameCometTransport client , String html ) ; </a> 0
<a> private native void destroyHtmlFile ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . core . client . JsArrayString ; </a> 0
<a> import com . google . gwt . dom . client . BodyElement ; </a> 0
<a> import com . google . gwt . dom . client . IFrameElement ; </a> 0
<a> import com . google . gwt . dom . client . Node ; </a> 0
<a> import com . google . gwt . dom . client . NodeList ; </a> 0
<a> import com . google . gwt . user . client . rpc . SerializationException ; </a> 0
<a> import com . google . gwt . user . client . rpc . StatusCodeException ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClient ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClientException ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereListener ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class IFrameCometTransport extends BaseCometTransport { </a> 0
<a> private String domain ; </a> 0
<a> private IFrameElement iframe ; </a> 0
<a> private BodyElement body ; </a> 0
<a> private boolean connected ; </a> 0
<a> private boolean expectingDisconnection ; </a> 0
<a> @ Override </a> 0
<a> public void initiate ( AtmosphereClient client , AtmosphereListener listener ) { </a> 0
<a> super . initiate ( client , listener ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void connect ( int connectionCount ) { </a> 0
<a> domain = getDomain ( getDocumentDomain ( ) , client . getUrl ( ) ) ; </a> 0
<a> StringBuilder html = new StringBuilder ( "<html>" ) ; </a> 0
<a> if ( domain != null ) { </a> 0
<a> html . append ( "<script>document.domain='" ) . append ( domain ) . append ( "'</script>" ) ; </a> 0
<a> } </a> 0
<a> html . append ( "<iframe src=''></iframe></html>" ) ; </a> 0
<a> iframe = createIFrame ( html . toString ( ) ) ; </a> 0
<a> expectingDisconnection = false ; </a> 0
<a> String url = getUrl ( connectionCount ) ; </a> 0
<a> if ( domain != null ) { </a> 0
<a> url += "&d=" + domain ; </a> 0
<a> } </a> 0
<a> iframe . setSrc ( url ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void disconnect ( ) { </a> 0
<a> expectingDisconnection = true ; </a> 0
<a> super . disconnect ( ) ; </a> 0
<a> iframe . setSrc ( "" ) ; </a> 0
<a> destroyIFrame ( ) ; </a> 0
<a> iframe = null ; </a> 0
<a> body = null ; </a> 0
<a> if ( connected ) { </a> 0
<a> onDisconnected ( ) ; </a> 0
<a> } </a> 0
<a> connected = false ; </a> 0
<a> } </a> 0
<a> protected IFrameElement createIFrame ( String html ) { </a> 0
<a> return createIFrameImpl ( this , html ) ; </a> 0
<a> } </a> 0
<a> protected void destroyIFrame ( ) { </a> 0
<a> } </a> 0
<a> private static native IFrameElement createIFrameImpl ( IFrameCometTransport client , String domain ) ; </a> 0
<a> private native static String getDocumentDomain ( ) ; </a> 0
<a> private native static String getDomain ( String documentDomain , String url ) ; </a> 0
<a> private void collect ( ) { </a> 0
<a> if ( body != null ) { </a> 0
<a> NodeList < Node > childNodes = body . getChildNodes ( ) ; </a> 0
<a> if ( childNodes . getLength ( ) > 1 ) { </a> 0
<a> body . removeChild ( childNodes . getItem ( 0 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unused" ) </a> 0
<a> private void onMessages ( JsArrayString arguments ) { </a> 0
<a> collect ( ) ; </a> 0
<a> int length = arguments . length ( ) ; </a> 0
<a> List < Serializable > messages = new ArrayList < Serializable > ( length ) ; </a> 0
<a> for ( int i = 0 ; i < length ; i ++ ) { </a> 0
<a> String message = arguments . get ( i ) ; </a> 0
<a> switch ( message . charAt ( 0 ) ) { </a> 0
<a> case ']' : </a> 0
<a> messages . add ( message . substring ( 1 ) ) ; </a> 0
<a> break ; </a> 0
<a> case '[' : </a> 0
<a> case 'R' : </a> 0
<a> case 'r' : </a> 0
<a> case 'f' : </a> 0
<a> try { </a> 0
<a> messages . add ( parse ( message ) ) ; </a> 0
<a> } catch ( SerializationException e ) { </a> 0
<a> listener . onError ( e , true ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Invalid message received: " + message ) , true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> listener . onMessage ( messages ) ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unused" ) </a> 0
<a> private void onConnected ( int heartbeat , int connectionID ) { </a> 0
<a> connected = true ; </a> 0
<a> body = iframe . getContentDocument ( ) . getBody ( ) ; </a> 0
<a> collect ( ) ; </a> 0
<a> this . connectionId = connectionID ; </a> 0
<a> listener . onConnected ( heartbeat , connectionID ) ; </a> 0
<a> } </a> 0
<a> private void onDisconnected ( ) { </a> 0
<a> connected = false ; </a> 0
<a> body = null ; </a> 0
<a> if ( expectingDisconnection ) { </a> 0
<a> listener . onDisconnected ( ) ; </a> 0
<a> } else { </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Unexpected disconnection" ) , false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unused" ) </a> 0
<a> private void onError ( int statusCode , String message ) { </a> 0
<a> listener . onError ( new StatusCodeException ( statusCode , message ) , false ) ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unused" ) </a> 0
<a> private void onHeartbeat ( ) { </a> 0
<a> collect ( ) ; </a> 0
<a> listener . onHeartbeat ( ) ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unused" ) </a> 0
<a> private void onRefresh ( ) { </a> 0
<a> collect ( ) ; </a> 0
<a> listener . onRefresh ( ) ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unused" ) </a> 0
<a> private void onTerminate ( ) { </a> 0
<a> collect ( ) ; </a> 0
<a> disconnect ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . user . client . DOM ; </a> 0
<a> import com . google . gwt . user . client . Element ; </a> 0
<a> import com . google . gwt . user . client . rpc . SerializationException ; </a> 0
<a> import com . google . gwt . user . client . rpc . StatusCodeException ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClient ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClientException ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereListener ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> public class OperaEventSourceCometTransport extends BaseCometTransport { </a> 0
<a> private Element eventSource ; </a> 0
<a> private boolean connected ; </a> 0
<a> @ Override </a> 0
<a> public void initiate ( AtmosphereClient client , AtmosphereListener listener ) { </a> 0
<a> super . initiate ( client , listener ) ; </a> 0
<a> eventSource = createEventSource ( this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void connect ( int connectionCount ) { </a> 0
<a> DOM . setElementAttribute ( eventSource , "src" , getUrl ( connectionCount ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void disconnect ( ) { </a> 0
<a> DOM . setElementAttribute ( eventSource , "src" , "" ) ; </a> 0
<a> super . disconnect ( ) ; </a> 0
<a> if ( connected ) { </a> 0
<a> connected = false ; </a> 0
<a> listener . onDisconnected ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static native Element createEventSource ( OperaEventSourceCometTransport client ) ; </a> 0
<a> @ SuppressWarnings ( "unused" ) </a> 0
<a> private void onString ( String message ) { </a> 0
<a> listener . onMessage ( Collections . singletonList ( HTTPRequestCometTransport . unescape ( message ) ) ) ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unused" ) </a> 0
<a> private void onObject ( String message ) { </a> 0
<a> try { </a> 0
<a> listener . onMessage ( Collections . singletonList ( parse ( message ) ) ) ; </a> 0
<a> } catch ( SerializationException e ) { </a> 0
<a> listener . onError ( e , true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unused" ) </a> 0
<a> private void onConnection ( String message ) { </a> 0
<a> if ( message . startsWith ( "c" ) ) { </a> 0
<a> connected = true ; </a> 0
<a> String initParameters = message . substring ( 1 ) ; </a> 0
<a> try { </a> 0
<a> String [ ] params = initParameters . split ( ":" ) ; </a> 0
<a> connectionId = Integer . parseInt ( params [ 1 ] ) ; </a> 0
<a> listener . onConnected ( Integer . parseInt ( params [ 0 ] ) , connectionId ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Unexpected init parameters: " + initParameters ) , true ) ; </a> 0
<a> } </a> 0
<a> } else if ( message . startsWith ( "e" ) ) { </a> 0
<a> disconnect ( ) ; </a> 0
<a> String status = message . substring ( 1 ) ; </a> 0
<a> try { </a> 0
<a> int statusCode ; </a> 0
<a> String statusMessage ; </a> 0
<a> int index = status . indexOf ( ' ' ) ; </a> 0
<a> if ( index == - 1 ) { </a> 0
<a> statusCode = Integer . parseInt ( status ) ; </a> 0
<a> statusMessage = null ; </a> 0
<a> } else { </a> 0
<a> statusCode = Integer . parseInt ( status . substring ( 0 , index ) ) ; </a> 0
<a> statusMessage = HTTPRequestCometTransport . unescape ( status . substring ( index + 1 ) ) ; </a> 0
<a> } </a> 0
<a> listener . onError ( new StatusCodeException ( statusCode , statusMessage ) , false ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Unexpected status code: " + status ) , false ) ; </a> 0
<a> } </a> 0
<a> } else if ( message . equals ( "d" ) ) { </a> 0
<a> connected = false ; </a> 0
<a> disconnect ( ) ; </a> 0
<a> listener . onDisconnected ( ) ; </a> 0
<a> } else if ( message . equals ( "h" ) ) { </a> 0
<a> listener . onHeartbeat ( ) ; </a> 0
<a> } else { </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Unexpected connection status: " + message ) , true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . user . client . rpc . AsyncCallback ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> public interface ServerTransport { </a> 0
<a> public void disconnect ( ) ; </a> 0
<a> public void post ( Serializable message , AsyncCallback < Void > callback ) ; </a> 0
<a> public void post ( List < Serializable > messages , AsyncCallback < Void > callback ) ; </a> 0
<a> public void broadcast ( Serializable message ) ; </a> 0
<a> public void broadcast ( List < Serializable > messages ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . user . client . rpc . AsyncCallback ; </a> 0
<a> import com . google . gwt . user . client . rpc . SerializationException ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . logging . Level ; </a> 0
<a> import java . util . logging . Logger ; </a> 0
<a> abstract public class ServerTransportProtocol implements ServerTransport { </a> 0
<a> abstract void send ( String message , AsyncCallback < Void > callback ) ; </a> 0
<a> abstract String serialize ( Serializable message ) throws SerializationException ; </a> 0
<a> private Logger logger = Logger . getLogger ( getClass ( ) . getName ( ) ) ; </a> 0
<a> private AsyncCallback < Void > defaultCallback = new AsyncCallback < Void > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onFailure ( Throwable caught ) { </a> 0
<a> logger . log ( Level . SEVERE , "Failed send" , caught ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onSuccess ( Void result ) { </a> 0
<a> if ( logger . isLoggable ( Level . FINEST ) ) { </a> 0
<a> logger . log ( Level . FINEST , "Send succesfull" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> @ Override </a> 0
<a> public void disconnect ( ) { </a> 0
<a> send ( "c\nd\n\n" , defaultCallback ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void broadcast ( Serializable message ) { </a> 0
<a> if ( message instanceof String ) { </a> 0
<a> send ( "s\nb" + message + "\n\n" , defaultCallback ) ; </a> 1
<a> } else { </a> 0
<a> try { </a> 0
<a> send ( "o\nb" + serialize ( message ) + "\n\n" , defaultCallback ) ; </a> 1
<a> } catch ( SerializationException ex ) { </a> 0
<a> logger . log ( Level . SEVERE , "Failed to serialize message" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void broadcast ( List < Serializable > messages ) { </a> 0
<a> StringBuilder packet = new StringBuilder ( ) ; </a> 0
<a> for ( Serializable message : messages ) { </a> 0
<a> if ( message instanceof String ) { </a> 0
<a> packet . append ( "s\nb" ) . append ( message ) . append ( "\n\n" ) ; </a> 1
<a> } else { </a> 0
<a> try { </a> 0
<a> packet . append ( "o\nb" ) . append ( serialize ( message ) ) . append ( "\n\n" ) ; </a> 1
<a> } catch ( SerializationException ex ) { </a> 0
<a> logger . log ( Level . SEVERE , "Failed to serialize message" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( packet . length ( ) > 0 ) { </a> 0
<a> send ( packet . toString ( ) , defaultCallback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void post ( Serializable message , AsyncCallback < Void > callback ) { </a> 0
<a> if ( message instanceof String ) { </a> 0
<a> send ( "s\np" + message + "\n\n" , callback ) ; </a> 1
<a> } else { </a> 0
<a> try { </a> 0
<a> send ( "o\np" + serialize ( message ) + "\n\n" , callback ) ; </a> 1
<a> } catch ( SerializationException ex ) { </a> 0
<a> logger . log ( Level . SEVERE , "Failed to serialize message" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void post ( List < Serializable > messages , AsyncCallback < Void > callback ) { </a> 0
<a> StringBuilder packet = new StringBuilder ( ) ; </a> 0
<a> for ( Serializable message : messages ) { </a> 0
<a> if ( message instanceof String ) { </a> 0
<a> packet . append ( "s\np" ) . append ( message ) . append ( "\n\n" ) ; </a> 1
<a> } else { </a> 0
<a> try { </a> 0
<a> packet . append ( "o\np" ) . append ( serialize ( message ) ) . append ( "\n\n" ) ; </a> 1
<a> } catch ( SerializationException ex ) { </a> 0
<a> logger . log ( Level . SEVERE , "Failed to serialize message" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( packet . length ( ) > 0 ) { </a> 0
<a> send ( packet . toString ( ) , callback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . core . client . JsArrayString ; </a> 0
<a> import com . google . gwt . http . client . Response ; </a> 0
<a> import com . google . gwt . user . client . rpc . SerializationException ; </a> 0
<a> import com . google . gwt . user . client . rpc . StatusCodeException ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClient ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClientException ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> abstract public class StreamingProtocolTransport extends BaseCometTransport { </a> 0
<a> private static final String SEPARATOR = "\n" ; </a> 0
<a> protected boolean aborted ; </a> 0
<a> protected boolean expectingDisconnection ; </a> 0
<a> protected int read ; </a> 0
<a> public void init ( ) { </a> 0
<a> aborted = false ; </a> 0
<a> expectingDisconnection = false ; </a> 0
<a> read = 0 ; </a> 0
<a> } </a> 0
<a> protected void onReceiving ( int statusCode , String responseText , boolean connected ) { </a> 0
<a> if ( statusCode != Response . SC_OK ) { </a> 0
<a> if ( ! connected ) { </a> 0
<a> expectingDisconnection = true ; </a> 0
<a> listener . onError ( new StatusCodeException ( statusCode , responseText ) , connected ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> int index = responseText . lastIndexOf ( SEPARATOR ) ; </a> 0
<a> if ( index > read ) { </a> 0
<a> List < Serializable > messages = new ArrayList < Serializable > ( ) ; </a> 0
<a> JsArrayString data = AtmosphereClient . split ( responseText . substring ( read , index ) , SEPARATOR ) ; </a> 0
<a> int length = data . length ( ) ; </a> 0
<a> for ( int i = 0 ; i < length ; i ++ ) { </a> 0
<a> if ( aborted ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> parse ( data . get ( i ) , messages ) ; </a> 0
<a> } </a> 0
<a> read = index + 1 ; </a> 0
<a> if ( ! messages . isEmpty ( ) ) { </a> 0
<a> listener . onMessage ( messages ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! connected ) { </a> 0
<a> if ( expectingDisconnection ) { </a> 0
<a> listener . onDisconnected ( ) ; </a> 0
<a> } else { </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Unexpected disconnection" ) , false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void parse ( String message , List < Serializable > messages ) { </a> 0
<a> if ( expectingDisconnection ) { </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Expecting disconnection but received message: " + message ) , true ) ; </a> 0
<a> } else if ( message . isEmpty ( ) ) { </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Invalid empty message received" ) , true ) ; </a> 0
<a> } else { </a> 0
<a> char c = message . charAt ( 0 ) ; </a> 0
<a> switch ( c ) { </a> 0
<a> case '!' : </a> 0
<a> String initParameters = message . substring ( 1 ) ; </a> 0
<a> try { </a> 0
<a> String [ ] params = initParameters . split ( ":" ) ; </a> 0
<a> connectionId = Integer . parseInt ( params [ 1 ] ) ; </a> 0
<a> listener . onConnected ( Integer . parseInt ( params [ 0 ] ) , connectionId ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Unexpected init parameters: " + initParameters ) , true ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> case '?' : </a> 0
<a> expectingDisconnection = true ; </a> 0
<a> break ; </a> 0
<a> case '#' : </a> 0
<a> listener . onHeartbeat ( ) ; </a> 0
<a> break ; </a> 0
<a> case '@' : </a> 0
<a> listener . onRefresh ( ) ; </a> 0
<a> break ; </a> 0
<a> case '*' : </a> 0
<a> break ; </a> 0
<a> case '|' : </a> 0
<a> messages . add ( message . substring ( 1 ) ) ; </a> 0
<a> break ; </a> 0
<a> case ']' : </a> 0
<a> messages . add ( unescape ( message . substring ( 1 ) ) ) ; </a> 0
<a> break ; </a> 0
<a> case '[' : </a> 0
<a> case 'R' : </a> 0
<a> case 'r' : </a> 0
<a> case 'f' : </a> 0
<a> try { </a> 0
<a> messages . add ( parse ( message ) ) ; </a> 0
<a> } catch ( SerializationException e ) { </a> 0
<a> listener . onError ( e , true ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Invalid message received: " + message ) , true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static String unescape ( String string ) { </a> 0
<a> return string . replace ( "\\n" , "\n" ) . replace ( "\\\\" , "\\" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptObject ; </a> 0
<a> public class WebSocket extends JavaScriptObject { </a> 0
<a> public enum ReadyState { </a> 0
<a> CONNECTING , </a> 0
<a> OPEN , </a> 0
<a> CLOSED </a> 0
<a> } </a> 0
<a> public static native WebSocket create ( String url ) ; </a> 0
<a> public static native WebSocket create ( String url , String protocol ) ; </a> 0
<a> protected WebSocket ( ) { </a> 0
<a> } </a> 0
<a> public final native ReadyState getReadyState ( ) ; </a> 0
<a> public final native int getBufferedAmount ( ) ; </a> 0
<a> public final native void send ( String data ) ; </a> 0
<a> public final native void close ( ) ; </a> 0
<a> public final native void setListener ( WebSocketListener listener ) ; </a> 0
<a> public final native void clearListener ( ) ; </a> 0
<a> public native static boolean isSupported ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . core . client . JsArrayString ; </a> 0
<a> import com . google . gwt . user . client . rpc . SerializationException ; </a> 0
<a> import com . google . gwt . user . client . rpc . StatusCodeException ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClient ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClientException ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> public class WebSocketCometTransport extends BaseCometTransport { </a> 0
<a> @ Override </a> 0
<a> public void connect ( int connectionCount ) { </a> 0
<a> disconnect ( ) ; </a> 0
<a> String url = getUrl ( connectionCount ) ; </a> 0
<a> url = url . replaceFirst ( "http://" , "ws://" ) ; </a> 0
<a> url = url . replaceFirst ( "https://" , "wss://" ) ; </a> 0
<a> socket = WebSocket . create ( url ) ; </a> 0
<a> socket . setListener ( socketListener ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void disconnect ( ) { </a> 0
<a> if ( socket != null ) { </a> 0
<a> super . disconnect ( ) ; </a> 0
<a> socket . close ( ) ; </a> 0
<a> } </a> 0
<a> socket = null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ServerTransport getServerTransport ( ) { </a> 0
<a> return super . getServerTransport ( ) ; </a> 0
<a> } </a> 0
<a> public static boolean hasWebSocketSupport ( ) { </a> 0
<a> return WebSocket . isSupported ( ) ; </a> 0
<a> } </a> 0
<a> private boolean connected = false ; </a> 1
<a> @ SuppressWarnings ( "unused" ) </a> 0
<a> private final void logError ( String message ) { </a> 0
<a> listener . onError ( new AtmosphereClientException ( message ) , connected ) ; </a> 0
<a> } </a> 0
<a> private void parseMessage ( String message ) { </a> 0
<a> if ( message . startsWith ( "s\n" ) ) { </a> 0
<a> listener . onMessage ( Collections . singletonList ( </a> 0
<a> HTTPRequestCometTransport . unescape ( message . substring ( 2 ) ) ) ) ; </a> 0
<a> } else if ( message . startsWith ( "o\n" ) ) { </a> 0
<a> try { </a> 0
<a> listener . onMessage ( Collections . singletonList ( parse ( message . substring ( 2 ) ) ) ) ; </a> 0
<a> } catch ( SerializationException e ) { </a> 0
<a> listener . onError ( e , true ) ; </a> 0
<a> } </a> 0
<a> } else if ( message . startsWith ( "c\n" ) ) { </a> 0
<a> onConnection ( message . substring ( 2 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onConnection ( String message ) { </a> 0
<a> if ( message . startsWith ( "c" ) ) { </a> 0
<a> connected = true ; </a> 1
<a> String initParameters = message . substring ( 1 ) ; </a> 0
<a> try { </a> 0
<a> String [ ] params = initParameters . split ( ":" ) ; </a> 0
<a> connectionId = Integer . parseInt ( params [ 1 ] ) ; </a> 0
<a> listener . onConnected ( Integer . parseInt ( params [ 0 ] ) , connectionId ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Unexpected init parameters: " + initParameters ) , true ) ; </a> 0
<a> } </a> 0
<a> } else if ( message . startsWith ( "e" ) ) { </a> 0
<a> disconnect ( ) ; </a> 0
<a> String status = message . substring ( 1 ) ; </a> 0
<a> try { </a> 0
<a> int statusCode ; </a> 0
<a> String statusMessage ; </a> 0
<a> int index = status . indexOf ( ' ' ) ; </a> 0
<a> if ( index == - 1 ) { </a> 0
<a> statusCode = Integer . parseInt ( status ) ; </a> 0
<a> statusMessage = null ; </a> 0
<a> } else { </a> 0
<a> statusCode = Integer . parseInt ( status . substring ( 0 , index ) ) ; </a> 0
<a> statusMessage = HTTPRequestCometTransport . unescape ( status . substring ( index + 1 ) ) ; </a> 0
<a> } </a> 0
<a> listener . onError ( new StatusCodeException ( statusCode , statusMessage ) , false ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Unexpected status code: " + status ) , false ) ; </a> 0
<a> } </a> 0
<a> } else if ( message . equals ( "d" ) ) { </a> 0
<a> disconnect ( ) ; </a> 0
<a> } else if ( message . equals ( "h" ) ) { </a> 0
<a> listener . onHeartbeat ( ) ; </a> 0
<a> } else { </a> 0
<a> listener . onError ( new AtmosphereClientException ( "Unexpected connection status: " + message ) , true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private WebSocket socket ; </a> 0
<a> private WebSocketListener socketListener = new WebSocketListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onOpen ( WebSocket socket ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onClose ( WebSocket socket ) { </a> 0
<a> connected = false ; </a> 1
<a> listener . onDisconnected ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onError ( WebSocket socket ) { </a> 1
<a> connected = false ; </a> 1
<a> listener . onError ( new IllegalStateException ( "Websocket Connection Error" ) , false ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onMessage ( WebSocket socket , String message ) { </a> 0
<a> JsArrayString messages = AtmosphereClient . split ( message , "\n\n" ) ; </a> 0
<a> int len = messages . length ( ) ; </a> 0
<a> for ( int i = 0 ; i < len ; i ++ ) { </a> 0
<a> parseMessage ( messages . get ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . client . impl ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptObject ; </a> 0
<a> public class XDomainRequest extends JavaScriptObject { </a> 0
<a> public static native XDomainRequest create ( ) ; </a> 0
<a> public native static boolean isSupported ( ) ; </a> 0
<a> public final native void setListener ( XDomainRequestListener listener ) ; </a> 0
<a> public final native void clearListener ( ) ; </a> 0
<a> public final native String getContentType ( ) ; </a> 0
<a> public final native String getResponseText ( ) ; </a> 0
<a> public final native void setTimeout ( int timeout ) ; </a> 0
<a> public final native int getTimeout ( ) ; </a> 0
<a> public final native void abort ( ) ; </a> 0
<a> public final native void openGET ( String url ) ; </a> 0
<a> public final native void openPOST ( String url ) ; </a> 0
<a> public final native void send ( ) ; </a> 0
<a> public final native void send ( String data ) ; </a> 0
<a> protected XDomainRequest ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . rebind ; </a> 0
<a> import com . google . gwt . core . ext . GeneratorContextExt ; </a> 0
<a> import com . google . gwt . core . ext . GeneratorExt ; </a> 0
<a> import com . google . gwt . core . ext . TreeLogger ; </a> 0
<a> import com . google . gwt . core . ext . UnableToCompleteException ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JClassType ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JField ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JType ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . NotFoundException ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . TypeOracle ; </a> 0
<a> import com . google . gwt . dev . javac . rebind . RebindResult ; </a> 0
<a> import com . google . gwt . dev . javac . rebind . RebindStatus ; </a> 0
<a> import com . google . gwt . dev . util . collect . Lists ; </a> 0
<a> import com . google . gwt . rpc . linker . RpcDataArtifact ; </a> 0
<a> import com . google . gwt . user . client . rpc . impl . Serializer ; </a> 0
<a> import com . google . gwt . user . rebind . ClassSourceFileComposerFactory ; </a> 0
<a> import com . google . gwt . user . rebind . SourceWriter ; </a> 0
<a> import com . google . gwt . user . rebind . rpc . SerializableTypeOracle ; </a> 0
<a> import com . google . gwt . user . rebind . rpc . SerializableTypeOracleBuilder ; </a> 0
<a> import com . google . gwt . user . rebind . rpc . SerializationUtils ; </a> 0
<a> import com . google . gwt . user . rebind . rpc . TypeSerializerCreator ; </a> 0
<a> import org . atmosphere . gwt . client . SerialMode ; </a> 0
<a> import org . atmosphere . gwt . client . SerialTypes ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . io . OutputStreamWriter ; </a> 0
<a> import java . io . PrintWriter ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class SerializerGenerator extends GeneratorExt { </a> 0
<a> @ Override </a> 0
<a> public RebindResult generateIncrementally ( TreeLogger logger , GeneratorContextExt context , String typeName ) throws UnableToCompleteException { </a> 0
<a> TypeOracle typeOracle = context . getTypeOracle ( ) ; </a> 0
<a> String packageName = "comet" ; </a> 0
<a> String className = typeName . replace ( '.' , '_' ) + "Impl" ; </a> 0
<a> PrintWriter printWriter = context . tryCreate ( logger , packageName , className ) ; </a> 0
<a> if ( printWriter != null ) { </a> 0
<a> try { </a> 0
<a> JClassType type = typeOracle . getType ( typeName ) ; </a> 0
<a> SerialTypes annotation = type . getAnnotation ( SerialTypes . class ) ; </a> 0
<a> if ( annotation == null ) { </a> 0
<a> logger . log ( TreeLogger . ERROR , "No SerialTypes annotation on CometSerializer type: " + typeName ) ; </a> 0
<a> throw new UnableToCompleteException ( ) ; </a> 0
<a> } </a> 0
<a> SerializableTypeOracleBuilder typesSentToBrowserBuilder = new SerializableTypeOracleBuilder ( </a> 0
<a> logger , context . getPropertyOracle ( ) , context ) ; </a> 0
<a> SerializableTypeOracleBuilder typesSentFromBrowserBuilder = new SerializableTypeOracleBuilder ( </a> 0
<a> logger , context . getPropertyOracle ( ) , context ) ; </a> 0
<a> for ( Class < ? extends Serializable > serializable : annotation . value ( ) ) { </a> 0
<a> int rank = 0 ; </a> 0
<a> if ( serializable . isArray ( ) ) { </a> 0
<a> while ( serializable . isArray ( ) ) { </a> 0
<a> serializable = ( Class < ? extends Serializable > ) serializable . getComponentType ( ) ; </a> 0
<a> rank ++ ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> JType resolvedType = typeOracle . getType ( serializable . getCanonicalName ( ) ) ; </a> 0
<a> while ( rank > 0 ) { </a> 0
<a> resolvedType = typeOracle . getArrayType ( resolvedType ) ; </a> 0
<a> rank -- ; </a> 0
<a> } </a> 0
<a> typesSentToBrowserBuilder . addRootType ( logger , resolvedType ) ; </a> 0
<a> typesSentFromBrowserBuilder . addRootType ( logger , resolvedType ) ; </a> 0
<a> } </a> 0
<a> OutputStream pathInfo = context . tryCreateResource ( logger , typeName + ".rpc.log" ) ; </a> 0
<a> PrintWriter writer = new PrintWriter ( new OutputStreamWriter ( pathInfo ) ) ; </a> 0
<a> writer . write ( "====================================\n" ) ; </a> 0
<a> writer . write ( "Types potentially sent from server:\n" ) ; </a> 0
<a> writer . write ( "====================================\n\n" ) ; </a> 0
<a> writer . flush ( ) ; </a> 0
<a> typesSentToBrowserBuilder . setLogOutputWriter ( writer ) ; </a> 0
<a> SerializableTypeOracle typesSentToBrowser = typesSentToBrowserBuilder . build ( logger ) ; </a> 0
<a> writer . write ( "===================================\n" ) ; </a> 0
<a> writer . write ( "Types potentially sent from browser:\n" ) ; </a> 0
<a> writer . write ( "===================================\n\n" ) ; </a> 0
<a> writer . flush ( ) ; </a> 0
<a> typesSentFromBrowserBuilder . setLogOutputWriter ( writer ) ; </a> 0
<a> SerializableTypeOracle typesSentFromBrowser = typesSentFromBrowserBuilder . build ( logger ) ; </a> 0
<a> writer . close ( ) ; </a> 0
<a> if ( pathInfo != null ) { </a> 0
<a> context . commitResource ( logger , pathInfo ) . setPrivate ( true ) ; </a> 0
<a> } </a> 0
<a> final String modifiedTypeName = typeName . replace ( '.' , '_' ) ; </a> 0
<a> TypeSerializerCreator tsc = new TypeSerializerCreator ( logger , typesSentFromBrowser , typesSentToBrowser , context , "comet." + modifiedTypeName , modifiedTypeName ) ; </a> 0
<a> String realize = tsc . realize ( logger ) ; </a> 0
<a> ClassSourceFileComposerFactory composerFactory = new ClassSourceFileComposerFactory ( packageName , className ) ; </a> 0
<a> composerFactory . addImport ( Serializer . class . getName ( ) ) ; </a> 0
<a> composerFactory . addImport ( SerialMode . class . getName ( ) ) ; </a> 0
<a> composerFactory . setSuperclass ( typeName ) ; </a> 0
<a> SourceWriter sourceWriter = composerFactory . createSourceWriter ( context , printWriter ) ; </a> 0
<a> sourceWriter . print ( "private Serializer SERIALIZER = new " + realize + "();" ) ; </a> 0
<a> sourceWriter . print ( "protected Serializer getSerializer() {return SERIALIZER;}" ) ; </a> 0
<a> sourceWriter . print ( "public SerialMode getMode() {return SerialMode." + annotation . mode ( ) . name ( ) + ";}" ) ; </a> 0
<a> sourceWriter . print ( "public SerialMode getPushMode() {return SerialMode." + annotation . pushmode ( ) . name ( ) + ";}" ) ; </a> 0
<a> sourceWriter . commit ( logger ) ; </a> 0
<a> if ( annotation . mode ( ) == SerialMode . DE_RPC ) { </a> 0
<a> RpcDataArtifact data = new RpcDataArtifact ( type . getQualifiedSourceName ( ) ) ; </a> 0
<a> for ( JType t : typesSentToBrowser . getSerializableTypes ( ) ) { </a> 0
<a> if ( ! ( t instanceof JClassType ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> JField [ ] serializableFields = SerializationUtils . getSerializableFields ( context . getTypeOracle ( ) , ( JClassType ) t ) ; </a> 0
<a> List < String > names = Lists . create ( ) ; </a> 0
<a> for ( int i = 0 , j = serializableFields . length ; i < j ; i ++ ) { </a> 0
<a> names = Lists . add ( names , serializableFields [ i ] . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> data . setFields ( SerializationUtils . getRpcTypeName ( t ) , names ) ; </a> 0
<a> } </a> 0
<a> context . commitArtifact ( logger , data ) ; </a> 0
<a> } </a> 0
<a> } catch ( NotFoundException e ) { </a> 0
<a> logger . log ( TreeLogger . ERROR , "" , e ) ; </a> 0
<a> throw new UnableToCompleteException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return new RebindResult ( RebindStatus . USE_PARTIAL_CACHED , packageName + '.' + className ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . shared ; </a> 0
<a> public class Constants { </a> 0
<a> public static final String MODULE_BASE_PARAMETER = "b" ; </a> 0
<a> public static final String STRONG_NAME_PARAMETER = "p" ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . js ; </a> 0
<a> import com . google . gwt . core . client . EntryPoint ; </a> 0
<a> import com . google . gwt . core . client . GWT ; </a> 0
<a> import com . google . gwt . core . client . Scheduler ; </a> 0
<a> import com . google . gwt . dom . client . Document ; </a> 0
<a> import com . google . gwt . dom . client . ScriptElement ; </a> 0
<a> public class JsClient implements EntryPoint { </a> 0
<a> @ Override </a> 0
<a> public void onModuleLoad ( ) { </a> 0
<a> GWT . create ( Client . class ) ; </a> 0
<a> GWT . create ( OnConnected . class ) ; </a> 0
<a> GWT . create ( OnBeforeDisconnected . class ) ; </a> 0
<a> GWT . create ( OnDisconnected . class ) ; </a> 0
<a> GWT . create ( OnError . class ) ; </a> 0
<a> GWT . create ( OnMessage . class ) ; </a> 0
<a> GWT . create ( OnHeartbeat . class ) ; </a> 0
<a> include ( GWT . getModuleBaseURL ( ) + "JSON.js" ) ; </a> 0
<a> Scheduler . get ( ) . scheduleDeferred ( new Scheduler . ScheduledCommand ( ) { </a> 0
<a> @ Override </a> 0
<a> public void execute ( ) { </a> 0
<a> onLoadImpl ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> protected void include ( String source ) { </a> 0
<a> ScriptElement el = Document . get ( ) . createScriptElement ( ) ; </a> 0
<a> el . setType ( "text/javascript" ) ; </a> 0
<a> el . setSrc ( source ) ; </a> 0
<a> Document . get ( ) . getBody ( ) . appendChild ( el ) ; </a> 0
<a> } </a> 0
<a> private native void onLoadImpl ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . js ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereGWTSerializer ; </a> 0
<a> import org . atmosphere . gwt . client . SerialMode ; </a> 0
<a> import org . atmosphere . gwt . client . SerialTypes ; </a> 0
<a> @ SerialTypes ( value = String . class , mode = SerialMode . PLAIN , pushmode = SerialMode . PLAIN ) </a> 0
<a> abstract public class JsSerializer extends AtmosphereGWTSerializer { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . js ; </a> 0
<a> import org . timepedia . exporter . client . Export ; </a> 0
<a> import org . timepedia . exporter . client . ExportClosure ; </a> 0
<a> import org . timepedia . exporter . client . ExportPackage ; </a> 0
<a> import org . timepedia . exporter . client . Exportable ; </a> 0
<a> @ Export </a> 0
<a> @ ExportPackage ( "atmosphere" ) </a> 0
<a> @ ExportClosure </a> 0
<a> public interface OnBeforeDisconnected extends Exportable { </a> 0
<a> public void execute ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . js ; </a> 0
<a> import org . timepedia . exporter . client . Export ; </a> 0
<a> import org . timepedia . exporter . client . ExportClosure ; </a> 0
<a> import org . timepedia . exporter . client . ExportPackage ; </a> 0
<a> import org . timepedia . exporter . client . Exportable ; </a> 0
<a> @ Export </a> 0
<a> @ ExportPackage ( "atmosphere" ) </a> 0
<a> @ ExportClosure </a> 0
<a> public interface OnConnected extends Exportable { </a> 0
<a> public void execute ( int heartbeat , int connectionID ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . js ; </a> 0
<a> import org . timepedia . exporter . client . Export ; </a> 0
<a> import org . timepedia . exporter . client . ExportClosure ; </a> 0
<a> import org . timepedia . exporter . client . ExportPackage ; </a> 0
<a> import org . timepedia . exporter . client . Exportable ; </a> 0
<a> @ Export </a> 0
<a> @ ExportPackage ( "atmosphere" ) </a> 0
<a> @ ExportClosure </a> 0
<a> public interface OnDisconnected extends Exportable { </a> 0
<a> public void execute ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . js ; </a> 0
<a> import org . timepedia . exporter . client . Export ; </a> 0
<a> import org . timepedia . exporter . client . ExportClosure ; </a> 0
<a> import org . timepedia . exporter . client . ExportPackage ; </a> 0
<a> import org . timepedia . exporter . client . Exportable ; </a> 0
<a> @ Export </a> 0
<a> @ ExportPackage ( "atmosphere" ) </a> 0
<a> @ ExportClosure </a> 0
<a> public interface OnError extends Exportable { </a> 0
<a> public void execute ( String error , boolean connected ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . js ; </a> 0
<a> import org . timepedia . exporter . client . Export ; </a> 0
<a> import org . timepedia . exporter . client . ExportClosure ; </a> 0
<a> import org . timepedia . exporter . client . ExportPackage ; </a> 0
<a> import org . timepedia . exporter . client . Exportable ; </a> 0
<a> @ Export </a> 0
<a> @ ExportPackage ( "atmosphere" ) </a> 0
<a> @ ExportClosure </a> 0
<a> public interface OnHeartbeat extends Exportable { </a> 0
<a> public void execute ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . js ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptObject ; </a> 0
<a> import org . timepedia . exporter . client . Export ; </a> 0
<a> import org . timepedia . exporter . client . ExportClosure ; </a> 0
<a> import org . timepedia . exporter . client . ExportPackage ; </a> 0
<a> import org . timepedia . exporter . client . Exportable ; </a> 0
<a> @ Export </a> 0
<a> @ ExportPackage ( "atmosphere" ) </a> 0
<a> @ ExportClosure </a> 0
<a> public interface OnMessage extends Exportable { </a> 0
<a> public void execute ( JavaScriptObject message ) ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . poll ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . handler . ReflectorServletProcessor ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> public class AtmospherePollHandler extends ReflectorServletProcessor { </a> 0
<a> @ Override </a> 0
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isCancelled ( ) || event . getMessage ( ) == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> HttpServletRequest request = event . getResource ( ) . getRequest ( ) ; </a> 0
<a> if ( Boolean . FALSE . equals ( request . getAttribute ( AtmospherePollService . GWT_SUSPENDED ) ) </a> 0
<a> || request . getAttribute ( AtmospherePollService . GWT_REQUEST ) == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> boolean success = false ; </a> 0
<a> try { </a> 0
<a> AtmospherePollService . writeResponse ( event . getResource ( ) , event . getMessage ( ) ) ; </a> 0
<a> success = true ; </a> 0
<a> } catch ( IllegalArgumentException ex ) { </a> 0
<a> } </a> 0
<a> if ( success && event . isSuspended ( ) ) { </a> 0
<a> request . removeAttribute ( AtmospherePollService . GWT_SUSPENDED ) ; </a> 0
<a> event . getResource ( ) . resume ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . poll ; </a> 0
<a> import com . google . gwt . user . client . rpc . IncompatibleRemoteServiceException ; </a> 0
<a> import com . google . gwt . user . client . rpc . SerializationException ; </a> 0
<a> import com . google . gwt . user . server . rpc . AbstractRemoteServiceServlet ; </a> 0
<a> import com . google . gwt . user . server . rpc . RPC ; </a> 0
<a> import com . google . gwt . user . server . rpc . RPCRequest ; </a> 0
<a> import com . google . gwt . user . server . rpc . RPCServletUtils ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicyLoader ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicyProvider ; </a> 0
<a> import com . google . gwt . user . server . rpc . UnexpectedException ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import org . atmosphere . cpr . FrameworkConfig ; </a> 0
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServlet ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> import java . net . URL ; </a> 0
<a> import java . text . ParseException ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class AtmospherePollService extends AbstractRemoteServiceServlet </a> 0
<a> implements SerializationPolicyProvider { </a> 0
<a> public final static String GWT_SUSPENDED = "GWT_SUSPENDED" ; </a> 0
<a> public final static String GWT_REQUEST = "GWT_REQUEST" ; </a> 0
<a> public class SuspendInfo { </a> 0
<a> private AtmosphereResource < HttpServletRequest , HttpServletResponse > atm ; </a> 0
<a> SuspendInfo ( AtmosphereResource atm ) { </a> 0
<a> this . atm = atm ; </a> 0
<a> } </a> 0
<a> public void writeAndResume ( Object message ) throws IOException { </a> 0
<a> try { </a> 0
<a> AtmospherePollService . writeResponse ( atm , message ) ; </a> 0
<a> } finally { </a> 0
<a> atm . getRequest ( ) . removeAttribute ( GWT_SUSPENDED ) ; </a> 0
<a> atm . resume ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public Broadcaster getBroadcaster ( ) { </a> 0
<a> return atm . getBroadcaster ( ) ; </a> 0
<a> } </a> 0
<a> public Broadcaster createBroadcaster ( String ID ) { </a> 0
<a> try { </a> 0
<a> Broadcaster b = BroadcasterFactory . getDefault ( ) . get ( DefaultBroadcaster . class , ID ) ; </a> 0
<a> atm . setBroadcaster ( b ) ; </a> 0
<a> return b ; </a> 0
<a> } catch ( IllegalAccessException e ) { </a> 0
<a> } catch ( InstantiationException e ) { </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected SuspendInfo suspend ( ) { </a> 0
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > atm = getAtmosphereResource ( ) ; </a> 0
<a> if ( atm == null ) { </a> 0
<a> throw new UnexpectedException ( "Failed to find Atmosphere resource have you setup Atmosphere?" , null ) ; </a> 0
<a> } </a> 0
<a> atm . getRequest ( ) . setAttribute ( GWT_SUSPENDED , true ) ; </a> 0
<a> atm . suspend ( - 1 , false ) ; </a> 0
<a> return new SuspendInfo ( atm ) ; </a> 0
<a> } </a> 0
<a> protected SuspendInfo suspend ( long timeout ) { </a> 0
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > atm = getAtmosphereResource ( ) ; </a> 0
<a> atm . getRequest ( ) . setAttribute ( GWT_SUSPENDED , true ) ; </a> 0
<a> atm . suspend ( timeout , false ) ; </a> 0
<a> return new SuspendInfo ( atm ) ; </a> 0
<a> } </a> 0
<a> protected boolean isSuspended ( ) { </a> 0
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > atm = getAtmosphereResource ( ) ; </a> 0
<a> if ( atm == null ) { </a> 0
<a> throw new UnexpectedException ( "Failed to find Atmosphere resource have you setup Atmosphere?" , null ) ; </a> 0
<a> } </a> 0
<a> Boolean var = ( Boolean ) atm . getRequest ( ) . getAttribute ( GWT_SUSPENDED ) ; </a> 0
<a> return Boolean . TRUE . equals ( var ) ; </a> 0
<a> } </a> 0
<a> static void writeResponse ( AtmosphereResource < HttpServletRequest , HttpServletResponse > resource , Object message ) throws IOException { </a> 0
<a> try { </a> 0
<a> RPCRequest rpcRequest = ( RPCRequest ) resource . getRequest ( ) . getAttribute ( AtmospherePollService . GWT_REQUEST ) ; </a> 0
<a> String response = encodeResponse ( rpcRequest , message ) ; </a> 0
<a> writeResponse ( resource . getRequest ( ) , resource . getResponse ( ) , </a> 0
<a> resource . getAtmosphereConfig ( ) . getServletContext ( ) , </a> 0
<a> response ) ; </a> 0
<a> } catch ( IncompatibleRemoteServiceException ex ) { </a> 0
<a> try { </a> 0
<a> String error = RPC . encodeResponseForFailure ( null , ex ) ; </a> 0
<a> writeResponse ( resource . getRequest ( ) , resource . getResponse ( ) , </a> 0
<a> resource . getAtmosphereConfig ( ) . getServletContext ( ) , </a> 0
<a> error ) ; </a> 0
<a> } catch ( SerializationException ex2 ) { </a> 0
<a> throw new IOException ( ex2 ) ; </a> 0
<a> } </a> 0
<a> } catch ( SerializationException ex ) { </a> 0
<a> throw new IOException ( ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static String encodeResponse ( RPCRequest rpcRequest , Object message ) throws SerializationException { </a> 0
<a> if ( rpcRequest == null ) { </a> 0
<a> throw new NullPointerException ( "rpcRequest" ) ; </a> 0
<a> } </a> 0
<a> if ( rpcRequest . getSerializationPolicy ( ) == null ) { </a> 0
<a> throw new NullPointerException ( "serializationPolicy" ) ; </a> 0
<a> } </a> 0
<a> String responsePayload ; </a> 0
<a> responsePayload = RPC . encodeResponseForSuccess ( rpcRequest . getMethod ( ) , message , </a> 0
<a> rpcRequest . getSerializationPolicy ( ) , rpcRequest . getFlags ( ) ) ; </a> 0
<a> return responsePayload ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onAfterRequestDeserialized ( RPCRequest rpcRequest ) { </a> 0
<a> getAtmosphereResource ( ) . getRequest ( ) . setAttribute ( GWT_REQUEST , rpcRequest ) ; </a> 0
<a> } </a> 0
<a> private AtmosphereResource < HttpServletRequest , HttpServletResponse > getAtmosphereResource ( ) { </a> 0
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > atm = </a> 0
<a> ( AtmosphereResource < HttpServletRequest , HttpServletResponse > ) </a> 0
<a> getThreadLocalRequest ( ) . getAttribute ( FrameworkConfig . ATMOSPHERE_RESOURCE ) ; </a> 0
<a> if ( atm == null ) { </a> 0
<a> throw new UnexpectedException ( "Failed to find Atmosphere resource have you setup Atmosphere?" , null ) ; </a> 0
<a> } </a> 0
<a> return atm ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void processPost ( HttpServletRequest request , </a> 0
<a> HttpServletResponse response ) throws IOException , ServletException , </a> 0
<a> SerializationException { </a> 0
<a> String requestPayload = readContent ( request ) ; </a> 0
<a> onBeforeRequestDeserialized ( requestPayload ) ; </a> 0
<a> String responsePayload = processCall ( requestPayload ) ; </a> 0
<a> if ( ! isSuspended ( ) ) { </a> 0
<a> onAfterResponseSerialized ( responsePayload ) ; </a> 0
<a> writeResponse ( request , response , getServletContext ( ) , responsePayload ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected static boolean shouldCompressResponse ( HttpServletRequest request , </a> 0
<a> HttpServletResponse response , String responsePayload ) { </a> 0
<a> return RPCServletUtils . exceedsUncompressedContentLengthLimit ( responsePayload ) ; </a> 0
<a> } </a> 0
<a> protected static void writeResponse ( HttpServletRequest request , </a> 0
<a> HttpServletResponse response , ServletContext context , String responsePayload ) throws IOException { </a> 0
<a> boolean gzipEncode = RPCServletUtils . acceptsGzipEncoding ( request ) </a> 0
<a> && shouldCompressResponse ( request , response , responsePayload ) ; </a> 0
<a> RPCServletUtils . writeResponse ( context , response , </a> 0
<a> responsePayload , gzipEncode ) ; </a> 0
<a> } </a> 0
<a> static SerializationPolicy loadSerializationPolicy ( HttpServlet servlet , </a> 0
<a> HttpServletRequest request , String moduleBaseURL , String strongName ) { </a> 0
<a> String contextPath = request . getContextPath ( ) ; </a> 0
<a> String modulePath = null ; </a> 0
<a> if ( moduleBaseURL != null ) { </a> 0
<a> try { </a> 0
<a> modulePath = new URL ( moduleBaseURL ) . getPath ( ) ; </a> 0
<a> } catch ( MalformedURLException ex ) { </a> 0
<a> servlet . log ( "Malformed moduleBaseURL: " + moduleBaseURL , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> SerializationPolicy serializationPolicy = null ; </a> 0
<a> if ( modulePath == null || ! modulePath . startsWith ( contextPath ) ) { </a> 0
<a> String message = "ERROR: The module path requested, " </a> 0
<a> + modulePath </a> 0
<a> + ", is not in the same web application as this servlet, " </a> 0
<a> + contextPath </a> 0
<a> + ". Your module may not be properly configured or your client and server code maybe out of date." ; </a> 0
<a> servlet . log ( message , null ) ; </a> 0
<a> } else { </a> 0
<a> String contextRelativePath = modulePath . substring ( contextPath . length ( ) ) ; </a> 0
<a> String serializationPolicyFilePath = SerializationPolicyLoader . getSerializationPolicyFileName ( contextRelativePath </a> 0
<a> + strongName ) ; </a> 0
<a> InputStream is = servlet . getServletContext ( ) . getResourceAsStream ( </a> 0
<a> serializationPolicyFilePath ) ; </a> 0
<a> try { </a> 0
<a> if ( is != null ) { </a> 0
<a> try { </a> 0
<a> serializationPolicy = SerializationPolicyLoader . loadFromStream ( is , </a> 0
<a> null ) ; </a> 0
<a> } catch ( ParseException e ) { </a> 0
<a> servlet . log ( "ERROR: Failed to parse the policy file '" </a> 0
<a> + serializationPolicyFilePath + "'" , e ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> servlet . log ( "ERROR: Could not read the policy file '" </a> 0
<a> + serializationPolicyFilePath + "'" , e ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> String message = "ERROR: The serialization policy file '" </a> 0
<a> + serializationPolicyFilePath </a> 0
<a> + "' was not found; did you forget to include it in this deployment?" ; </a> 0
<a> servlet . log ( message ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> if ( is != null ) { </a> 0
<a> try { </a> 0
<a> is . close ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return serializationPolicy ; </a> 0
<a> } </a> 0
<a> private final Map < String , SerializationPolicy > serializationPolicyCache = new HashMap < String , SerializationPolicy > ( ) ; </a> 0
<a> public AtmospherePollService ( ) { </a> 0
<a> } </a> 0
<a> public final SerializationPolicy getSerializationPolicy ( String moduleBaseURL , </a> 0
<a> String strongName ) { </a> 0
<a> SerializationPolicy serializationPolicy = getCachedSerializationPolicy ( </a> 0
<a> moduleBaseURL , strongName ) ; </a> 0
<a> if ( serializationPolicy != null ) { </a> 0
<a> return serializationPolicy ; </a> 0
<a> } </a> 0
<a> serializationPolicy = doGetSerializationPolicy ( getThreadLocalRequest ( ) , </a> 0
<a> moduleBaseURL , strongName ) ; </a> 0
<a> if ( serializationPolicy == null ) { </a> 0
<a> log ( </a> 0
<a> "WARNING: Failed to get the SerializationPolicy '" </a> 0
<a> + strongName </a> 0
<a> + "' for module '" </a> 0
<a> + moduleBaseURL </a> 0
<a> + "'; a legacy, 1.3.3 compatible, serialization policy will be used. You may experience SerializationExceptions as a result." , </a> 0
<a> null ) ; </a> 0
<a> serializationPolicy = RPC . getDefaultSerializationPolicy ( ) ; </a> 0
<a> } </a> 0
<a> putCachedSerializationPolicy ( moduleBaseURL , strongName , serializationPolicy ) ; </a> 0
<a> return serializationPolicy ; </a> 0
<a> } </a> 0
<a> public String processCall ( String payload ) throws SerializationException { </a> 0
<a> try { </a> 0
<a> RPCRequest rpcRequest = RPC . decodeRequest ( payload , this . getClass ( ) , this ) ; </a> 0
<a> onAfterRequestDeserialized ( rpcRequest ) ; </a> 0
<a> return RPC . invokeAndEncodeResponse ( this , rpcRequest . getMethod ( ) , </a> 0
<a> rpcRequest . getParameters ( ) , rpcRequest . getSerializationPolicy ( ) , </a> 0
<a> rpcRequest . getFlags ( ) ) ; </a> 0
<a> } catch ( IncompatibleRemoteServiceException ex ) { </a> 0
<a> log ( </a> 0
<a> "An IncompatibleRemoteServiceException was thrown while processing this call." , </a> 0
<a> ex ) ; </a> 0
<a> return RPC . encodeResponseForFailure ( null , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected SerializationPolicy doGetSerializationPolicy ( </a> 0
<a> HttpServletRequest request , String moduleBaseURL , String strongName ) { </a> 0
<a> return loadSerializationPolicy ( this , request , moduleBaseURL , strongName ) ; </a> 0
<a> } </a> 0
<a> protected void onAfterResponseSerialized ( String serializedResponse ) { </a> 0
<a> } </a> 0
<a> protected void onBeforeRequestDeserialized ( String serializedRequest ) { </a> 0
<a> } </a> 0
<a> private SerializationPolicy getCachedSerializationPolicy ( </a> 0
<a> String moduleBaseURL , String strongName ) { </a> 0
<a> synchronized ( serializationPolicyCache ) { </a> 0
<a> return serializationPolicyCache . get ( moduleBaseURL + strongName ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void putCachedSerializationPolicy ( String moduleBaseURL , </a> 0
<a> String strongName , SerializationPolicy serializationPolicy ) { </a> 0
<a> synchronized ( serializationPolicyCache ) { </a> 0
<a> serializationPolicyCache . put ( moduleBaseURL + strongName , </a> 0
<a> serializationPolicy ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . servlet . http . HttpSession ; </a> 1
<a> import java . io . Serializable ; </a> 1
<a> import java . util . List ; </a> 1
<a> public interface GwtAtmosphereResource { </a> 0
<a> public Broadcaster getBroadcaster ( ) ; </a> 0
<a> public HttpSession getSession ( ) ; </a> 0
<a> public HttpSession getSession ( boolean create ) ; </a> 0
<a> public int getHeartBeatInterval ( ) ; </a> 0
<a> @ Deprecated </a> 0
<a> public void broadcast ( Serializable message ) ; </a> 0
<a> public void post ( Serializable message ) ; </a> 0
<a> @ Deprecated </a> 0
<a> public void broadcast ( List < Serializable > messages ) ; </a> 0
<a> public void post ( List < Serializable > messages ) ; </a> 0
<a> public AtmosphereResource < HttpServletRequest , HttpServletResponse > getAtmosphereResource ( ) ; </a> 0
<a> public HttpServletRequest getRequest ( ) ; </a> 0
<a> public HttpServletResponse getResponse ( ) ; </a> 0
<a> public boolean isAlive ( ) ; </a> 0
<a> public < T > void setAttribute ( String name , T value ) ; </a> 0
<a> public < T > T getAttribute ( String name ) ; </a> 0
<a> public int getConnectionID ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> public interface GwtResponseWriter { </a> 0
<a> public void write ( Serializable message ) throws IOException ; </a> 0
<a> public void write ( Serializable message , boolean flush ) throws IOException ; </a> 0
<a> public void write ( List < ? extends Serializable > messages ) throws IOException ; </a> 0
<a> public void write ( List < ? extends Serializable > messages , boolean flush ) throws IOException ; </a> 0
<a> public void heartbeat ( ) throws IOException ; </a> 0
<a> public void terminate ( ) throws IOException ; </a> 0
<a> public boolean isTerminated ( ) ; </a> 0
<a> public long getLastWriteTime ( ) ; </a> 0
<a> public void sendError ( int statusCode ) throws IOException ; </a> 0
<a> public void sendError ( int statusCode , String message ) throws IOException ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> public interface SystemMessage extends Serializable { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . deflate ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> public final class Deflater { </a> 0
<a> private int [ ] window ; </a> 0
<a> private int windowPtr ; </a> 0
<a> private int windowState ; </a> 0
<a> private int recentBytes ; </a> 0
<a> private char [ ] windowLink ; </a> 0
<a> private char [ ] hashTable ; </a> 0
<a> private byte [ ] ucBuffer ; </a> 0
<a> private int ucBufferPtr ; </a> 0
<a> private int seqLen ; </a> 0
<a> private int seqPtr ; </a> 0
<a> private int seqDist ; </a> 0
<a> private int maxChainLengthTriplet ; </a> 0
<a> private int maxDistanceTriplet ; </a> 0
<a> private int maxChainLengthSeq1 ; </a> 0
<a> private int maxDistanceSeq1 ; </a> 0
<a> private int goodSequenceLength ; </a> 0
<a> private int maxLazyLength ; </a> 0
<a> private int maxChainLengthSeq2 ; </a> 0
<a> private int maxDistanceSeq2 ; </a> 0
<a> private boolean huffOnly ; </a> 0
<a> private int [ ] buffer ; </a> 0
<a> private int bufferPtr ; </a> 0
<a> private OutputStream out ; </a> 0
<a> private int outByte ; </a> 0
<a> private int outPtr ; </a> 0
<a> private byte [ ] outBuf ; </a> 0
<a> private int outBufPtr ; </a> 0
<a> private boolean noOutput ; </a> 0
<a> public static final int HUFF = 1 ; </a> 0
<a> public static final int SPEED = 2 ; </a> 0
<a> public static final int MEDIUM = 3 ; </a> 0
<a> public static final int COMPACT = 4 ; </a> 0
<a> public Deflater ( ) { </a> 0
<a> this ( 0 , 15 ) ; </a> 0
<a> } </a> 0
<a> public Deflater ( int level ) { </a> 0
<a> this ( level , 15 ) ; </a> 0
<a> } </a> 0
<a> public Deflater ( int level , int windowBits ) { </a> 0
<a> if ( windowBits < 9 || windowBits > 15 ) </a> 0
<a> throw new IllegalArgumentException ( "invalid LZ77 window bit length: " + windowBits ) ; </a> 0
<a> int bufferLen = 16384 ; </a> 0
<a> int windowLen = 1 < < windowBits ; </a> 0
<a> window = new int [ windowLen ] ; </a> 0
<a> windowLink = new char [ windowLen ] ; </a> 0
<a> hashTable = new char [ windowLen ] ; </a> 0
<a> maxDistanceTriplet = windowLen - 261 ; </a> 0
<a> maxDistanceSeq1 = windowLen - 261 ; </a> 0
<a> maxDistanceSeq2 = windowLen - 261 ; </a> 0
<a> if ( level == 0 ) </a> 0
<a> level = MEDIUM ; </a> 0
<a> switch ( level ) { </a> 0
<a> case SPEED : </a> 0
<a> maxChainLengthTriplet = 16 ; </a> 0
<a> maxChainLengthSeq1 = 8 ; </a> 0
<a> goodSequenceLength = 8 ; </a> 0
<a> maxLazyLength = 4 ; </a> 0
<a> maxChainLengthSeq2 = 4 ; </a> 0
<a> break ; </a> 0
<a> case MEDIUM : </a> 0
<a> maxChainLengthTriplet = 128 ; </a> 0
<a> maxChainLengthSeq1 = 128 ; </a> 0
<a> goodSequenceLength = 64 ; </a> 0
<a> maxLazyLength = 64 ; </a> 0
<a> maxChainLengthSeq2 = 32 ; </a> 0
<a> break ; </a> 0
<a> case COMPACT : </a> 0
<a> maxChainLengthTriplet = 1024 ; </a> 0
<a> maxChainLengthSeq1 = 1024 ; </a> 0
<a> goodSequenceLength = 258 ; </a> 0
<a> maxLazyLength = 258 ; </a> 0
<a> maxChainLengthSeq2 = 1024 ; </a> 0
<a> break ; </a> 0
<a> case HUFF : </a> 0
<a> huffOnly = true ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new IllegalArgumentException ( "unknown compression level: " + level ) ; </a> 0
<a> } </a> 0
<a> buffer = new int [ bufferLen ] ; </a> 0
<a> ucBuffer = new byte [ 4 * bufferLen + 258 ] ; </a> 0
<a> outBuf = new byte [ 4096 ] ; </a> 0
<a> } </a> 0
<a> public OutputStream getOut ( ) { </a> 0
<a> return out ; </a> 0
<a> } </a> 0
<a> public void setOut ( OutputStream out ) { </a> 0
<a> this . out = out ; </a> 0
<a> } </a> 0
<a> private static int makeCopySymbol ( int len , int dist ) { </a> 0
<a> int symlen , elen ; </a> 0
<a> if ( len <= 10 ) { </a> 0
<a> symlen = 254 + len ; </a> 0
<a> elen = 0 ; </a> 0
<a> } else if ( len == 258 ) { </a> 0
<a> symlen = 285 ; </a> 0
<a> elen = 0 ; </a> 0
<a> } else { </a> 0
<a> int i ; </a> 0
<a> for ( i = 9 ; i < 29 ; i ++ ) </a> 0
<a> if ( LENGTH [ i ] > len ) </a> 0
<a> break ; </a> 0
<a> symlen = 256 + i ; </a> 0
<a> elen = len - LENGTH [ i - 1 ] ; </a> 0
<a> } </a> 0
<a> int symdist , edist ; </a> 0
<a> if ( dist <= 4 ) { </a> 0
<a> symdist = dist - 1 ; </a> 0
<a> edist = 0 ; </a> 0
<a> } else { </a> 0
<a> int i ; </a> 0
<a> for ( i = 5 ; i < 30 ; i ++ ) </a> 0
<a> if ( DIST [ i ] > dist ) </a> 0
<a> break ; </a> 0
<a> symdist = i - 1 ; </a> 0
<a> edist = dist - DIST [ i - 1 ] ; </a> 0
<a> } </a> 0
<a> return symlen + ( elen < < 9 ) + ( symdist < < 14 ) + ( edist < < 19 ) ; </a> 0
<a> } </a> 0
<a> private static int findPreviousSequence ( int [ ] win , int winMask , char [ ] wlink , int orig , int dist , int len , int end , int maxLen , int maxDist ) { </a> 0
<a> int n = orig ; </a> 0
<a> int chainLength = maxLen ; </a> 0
<a> loop : </a> 0
<a> while ( chainLength -- > 0 ) { </a> 0
<a> int d = wlink [ n ] ; </a> 0
<a> if ( d == 0 ) </a> 0
<a> return 0 ; </a> 0
<a> dist += d ; </a> 0
<a> if ( dist > maxDist ) </a> 0
<a> return 0 ; </a> 0
<a> n = ( n - d ) & winMask ; </a> 0
<a> int tm = len ; </a> 0
<a> int j = orig , k = n ; </a> 0
<a> if ( tm >= 3 ) { </a> 0
<a> while ( tm >= 3 ) { </a> 0
<a> if ( win [ j ] != win [ k ] ) </a> 0
<a> continue loop ; </a> 0
<a> tm -= 3 ; </a> 0
<a> j = ( j + 3 ) & winMask ; </a> 0
<a> k = ( k + 3 ) & winMask ; </a> 0
<a> } </a> 0
<a> switch ( tm ) { </a> 0
<a> case 1 : </a> 0
<a> j = ( j - 2 ) & winMask ; </a> 0
<a> k = ( k - 2 ) & winMask ; </a> 0
<a> if ( win [ j ] != win [ k ] ) </a> 0
<a> continue loop ; </a> 0
<a> k = ( k + 3 ) & winMask ; </a> 0
<a> break ; </a> 0
<a> case 2 : </a> 0
<a> j = ( j - 1 ) & winMask ; </a> 0
<a> k = ( k - 1 ) & winMask ; </a> 0
<a> if ( win [ j ] != win [ k ] ) </a> 0
<a> continue loop ; </a> 0
<a> k = ( k + 3 ) & winMask ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( win [ j ] != win [ k ] ) </a> 0
<a> continue loop ; </a> 0
<a> k = ( k + tm ) & winMask ; </a> 0
<a> } </a> 0
<a> if ( win [ k ] == end ) </a> 0
<a> return dist ; </a> 0
<a> } </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> private void updateUCBuffer ( byte [ ] buf , int off1 , int off2 ) { </a> 0
<a> int uLen = ucBuffer . length ; </a> 0
<a> int sInc = ( uLen > > > 1 ) ; </a> 0
<a> while ( off1 < off2 ) { </a> 0
<a> int free = uLen - ucBufferPtr ; </a> 0
<a> int tc = off2 - off1 ; </a> 0
<a> if ( tc > sInc ) </a> 0
<a> tc = sInc ; </a> 0
<a> if ( tc > free ) { </a> 0
<a> System . arraycopy ( buf , off1 , ucBuffer , ucBufferPtr , free ) ; </a> 0
<a> System . arraycopy ( buf , off1 + free , ucBuffer , 0 , tc - free ) ; </a> 0
<a> ucBufferPtr = tc - free ; </a> 0
<a> } else { </a> 0
<a> System . arraycopy ( buf , off1 , ucBuffer , ucBufferPtr , tc ) ; </a> 0
<a> ucBufferPtr += tc ; </a> 0
<a> } </a> 0
<a> off1 += tc ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void process ( byte [ ] buf , int off , int len ) throws IOException { </a> 0
<a> if ( len == 0 ) </a> 0
<a> return ; </a> 0
<a> int origOff = off ; </a> 0
<a> if ( huffOnly ) { </a> 0
<a> int [ ] sb = buffer ; </a> 0
<a> int sbPtr = bufferPtr ; </a> 0
<a> int sbLen = sb . length ; </a> 0
<a> while ( len -- > 0 ) { </a> 0
<a> int bv = buf [ off ++ ] & 0xFF ; </a> 0
<a> sb [ sbPtr ++ ] = bv ; </a> 0
<a> if ( sbPtr == sbLen ) { </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> origOff = off ; </a> 0
<a> endBlock ( false , sbPtr ) ; </a> 0
<a> sbPtr = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> bufferPtr = sbPtr ; </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( windowState < 2 ) { </a> 0
<a> int bv = buf [ off ++ ] & 0xFF ; </a> 0
<a> len -- ; </a> 0
<a> if ( windowState == 0 ) { </a> 0
<a> recentBytes = bv ; </a> 0
<a> seqLen = 1 ; </a> 0
<a> if ( len == 0 ) { </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> bv = buf [ off ++ ] & 0xFF ; </a> 0
<a> len -- ; </a> 0
<a> } </a> 0
<a> recentBytes = ( recentBytes < < 8 ) | bv ; </a> 0
<a> windowState = 2 ; </a> 0
<a> seqLen = 2 ; </a> 0
<a> if ( len == 0 ) { </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int [ ] win = window ; </a> 0
<a> int winMask = win . length - 1 ; </a> 0
<a> int winPtr = windowPtr ; </a> 0
<a> int recent = recentBytes ; </a> 0
<a> char [ ] wlink = windowLink ; </a> 0
<a> char [ ] ht = hashTable ; </a> 0
<a> int htMask = ht . length - 1 ; </a> 0
<a> int sLen = seqLen ; </a> 0
<a> int sPtr = seqPtr ; </a> 0
<a> int sDist = seqDist ; </a> 0
<a> int [ ] sb = buffer ; </a> 0
<a> int sbPtr = bufferPtr ; </a> 0
<a> int sbLen = sb . length ; </a> 0
<a> int maxCL0 = maxChainLengthTriplet ; </a> 0
<a> int maxDistCL0 = maxDistanceTriplet ; </a> 0
<a> int maxCL1 = maxChainLengthSeq1 ; </a> 0
<a> int maxDistCL1 = maxDistanceSeq1 ; </a> 0
<a> int goodSLen = goodSequenceLength ; </a> 0
<a> int maxLLen = maxLazyLength ; </a> 0
<a> int maxCL2 = maxChainLengthSeq2 ; </a> 0
<a> int maxDistCL2 = maxDistanceSeq2 ; </a> 0
<a> loop : </a> 0
<a> while ( len -- > 0 ) { </a> 0
<a> int b0 = buf [ off ++ ] & 0xFF ; </a> 0
<a> int triplet = ( recent < < 8 ) | b0 ; </a> 0
<a> recent = triplet & 0xFFFF ; </a> 0
<a> win [ winPtr ] = triplet ; </a> 0
<a> int h = ( triplet + ( triplet > > > 4 ) + ( triplet > > > 8 ) + ( triplet > > > 9 ) - ( triplet > > > 16 ) ) & htMask ; </a> 0
<a> int link = ht [ h ] - 1 ; </a> 0
<a> int dist ; </a> 0
<a> if ( link < 0 ) { </a> 0
<a> dist = 0 ; </a> 0
<a> } else { </a> 0
<a> int pv = win [ link ] ; </a> 0
<a> int ph = ( pv + ( pv > > > 4 ) + ( pv > > > 8 ) + ( pv > > > 9 ) - ( pv > > > 16 ) ) & htMask ; </a> 0
<a> if ( ph == h ) { </a> 0
<a> dist = ( winPtr - link ) & winMask ; </a> 0
<a> } else { </a> 0
<a> dist = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ht [ h ] = ( char ) ( winPtr + 1 ) ; </a> 0
<a> wlink [ winPtr ] = ( char ) dist ; </a> 0
<a> int thisPtr = winPtr ; </a> 0
<a> winPtr = ( winPtr + 1 ) & winMask ; </a> 0
<a> if ( sLen < 2 ) { </a> 0
<a> sLen ++ ; </a> 0
<a> continue loop ; </a> 0
<a> } </a> 0
<a> if ( sLen == 2 ) { </a> 0
<a> if ( dist == 0 ) { </a> 0
<a> sb [ sbPtr ++ ] = triplet > > > 16 ; </a> 0
<a> if ( sbPtr == sbLen ) { </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> origOff = off ; </a> 0
<a> endBlock ( false , sbPtr ) ; </a> 0
<a> sbPtr = 0 ; </a> 0
<a> } </a> 0
<a> continue loop ; </a> 0
<a> } </a> 0
<a> sDist = dist ; </a> 0
<a> findTriplet : </a> 0
<a> do { </a> 0
<a> int n = link ; </a> 0
<a> int chainLen = maxCL0 ; </a> 0
<a> while ( chainLen -- > 0 ) { </a> 0
<a> if ( win [ n ] == triplet ) </a> 0
<a> break findTriplet ; </a> 0
<a> int d = wlink [ n ] ; </a> 0
<a> if ( d == 0 ) </a> 0
<a> break ; </a> 0
<a> sDist += d ; </a> 0
<a> if ( sDist > maxDistCL0 ) </a> 0
<a> break ; </a> 0
<a> n = ( n - d ) & winMask ; </a> 0
<a> } </a> 0
<a> sDist = 0 ; </a> 0
<a> } </a> 0
<a> while ( false ) ; </a> 0
<a> if ( sDist == 0 ) { </a> 0
<a> sb [ sbPtr ++ ] = triplet > > > 16 ; </a> 0
<a> if ( sbPtr == sbLen ) { </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> origOff = off ; </a> 0
<a> endBlock ( false , sbPtr ) ; </a> 0
<a> sbPtr = 0 ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> sPtr = ( thisPtr - sDist ) & winMask ; </a> 0
<a> sLen = 3 ; </a> 0
<a> if ( sPtr == winPtr ) { </a> 0
<a> sb [ sbPtr ++ ] = makeCopySymbol ( sLen , sDist ) ; </a> 0
<a> if ( sbPtr == sbLen ) { </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> origOff = off ; </a> 0
<a> endBlock ( false , sbPtr ) ; </a> 0
<a> sbPtr = 0 ; </a> 0
<a> } </a> 0
<a> sLen = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> continue loop ; </a> 0
<a> } </a> 0
<a> if ( win [ ( thisPtr - sDist ) & winMask ] == triplet ) { </a> 0
<a> sLen ++ ; </a> 0
<a> if ( sPtr == winPtr || sLen == 258 ) { </a> 0
<a> sb [ sbPtr ++ ] = makeCopySymbol ( sLen , sDist ) ; </a> 0
<a> if ( sbPtr == sbLen ) { </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> origOff = off ; </a> 0
<a> endBlock ( false , sbPtr ) ; </a> 0
<a> sbPtr = 0 ; </a> 0
<a> } </a> 0
<a> sLen = 0 ; </a> 0
<a> } </a> 0
<a> continue loop ; </a> 0
<a> } </a> 0
<a> int sDistNew = findPreviousSequence ( win , winMask , wlink , sPtr , sDist , sLen - 2 , triplet , sLen > goodSLen ? ( maxCL1 > > > 2 ) : maxCL1 , maxDistCL1 ) ; </a> 0
<a> if ( sDistNew > 0 ) { </a> 0
<a> sDist = sDistNew ; </a> 0
<a> sPtr = ( thisPtr - ( sLen - 2 ) - sDistNew ) & winMask ; </a> 0
<a> sLen ++ ; </a> 0
<a> if ( sPtr == winPtr || sLen == 258 ) { </a> 0
<a> sb [ sbPtr ++ ] = makeCopySymbol ( sLen , sDist ) ; </a> 0
<a> if ( sbPtr == sbLen ) { </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> origOff = off ; </a> 0
<a> endBlock ( false , sbPtr ) ; </a> 0
<a> sbPtr = 0 ; </a> 0
<a> } </a> 0
<a> sLen = 0 ; </a> 0
<a> } </a> 0
<a> continue loop ; </a> 0
<a> } </a> 0
<a> if ( sLen <= maxLLen ) { </a> 0
<a> int refPtr = ( thisPtr - ( sLen - 2 ) + 1 ) & winMask ; </a> 0
<a> int mdc = maxDistCL2 ; </a> 0
<a> if ( mdc > sDist ) </a> 0
<a> mdc = sDist ; </a> 0
<a> sDistNew = findPreviousSequence ( win , winMask , wlink , refPtr , 0 , sLen - 3 , triplet , maxCL2 , mdc ) ; </a> 0
<a> if ( sDistNew > 0 ) { </a> 0
<a> sb [ sbPtr ++ ] = win [ sPtr ] > > > 16 ; </a> 0
<a> if ( sbPtr == sbLen ) { </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> origOff = off ; </a> 0
<a> endBlock ( false , sbPtr ) ; </a> 0
<a> sbPtr = 0 ; </a> 0
<a> } </a> 0
<a> sDist = sDistNew ; </a> 0
<a> sPtr = ( refPtr - sDistNew ) & winMask ; </a> 0
<a> if ( sPtr == winPtr ) { </a> 0
<a> sb [ sbPtr ++ ] = makeCopySymbol ( sLen , sDist ) ; </a> 0
<a> if ( sbPtr == sbLen ) { </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> origOff = off ; </a> 0
<a> endBlock ( false , sbPtr ) ; </a> 0
<a> sbPtr = 0 ; </a> 0
<a> } </a> 0
<a> sLen = 0 ; </a> 0
<a> } </a> 0
<a> continue loop ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( sLen == 3 && sDist > 6144 ) { </a> 0
<a> int ot = win [ sPtr ] ; </a> 0
<a> for ( int k = 16 ; k >= 0 ; k -= 8 ) { </a> 0
<a> sb [ sbPtr ++ ] = ( ot > > > k ) & 0xFF ; </a> 0
<a> if ( sbPtr == sbLen ) { </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> origOff = off ; </a> 0
<a> endBlock ( false , sbPtr ) ; </a> 0
<a> sbPtr = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> sb [ sbPtr ++ ] = makeCopySymbol ( sLen , sDist ) ; </a> 0
<a> if ( sbPtr == sbLen ) { </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> origOff = off ; </a> 0
<a> endBlock ( false , sbPtr ) ; </a> 0
<a> sbPtr = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> sLen = 1 ; </a> 0
<a> } </a> 0
<a> windowPtr = winPtr ; </a> 0
<a> recentBytes = recent ; </a> 0
<a> seqLen = sLen ; </a> 0
<a> seqPtr = sPtr ; </a> 0
<a> seqDist = sDist ; </a> 0
<a> bufferPtr = sbPtr ; </a> 0
<a> updateUCBuffer ( buf , origOff , off ) ; </a> 0
<a> } </a> 0
<a> private void prepareFlush ( ) throws IOException { </a> 0
<a> switch ( seqLen ) { </a> 0
<a> case 0 : </a> 0
<a> break ; </a> 0
<a> case 1 : </a> 0
<a> buffer [ bufferPtr ++ ] = recentBytes & 0xFF ; </a> 0
<a> if ( bufferPtr == buffer . length ) </a> 0
<a> endBlock ( false , bufferPtr ) ; </a> 0
<a> break ; </a> 0
<a> case 2 : </a> 0
<a> buffer [ bufferPtr ++ ] = ( recentBytes > > > 8 ) & 0xFF ; </a> 0
<a> if ( bufferPtr == buffer . length ) </a> 0
<a> endBlock ( false , bufferPtr ) ; </a> 0
<a> buffer [ bufferPtr ++ ] = recentBytes & 0xFF ; </a> 0
<a> if ( bufferPtr == buffer . length ) </a> 0
<a> endBlock ( false , bufferPtr ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> buffer [ bufferPtr ++ ] = makeCopySymbol ( seqLen , seqDist ) ; </a> 0
<a> if ( bufferPtr == buffer . length ) </a> 0
<a> endBlock ( false , bufferPtr ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> seqLen = 0 ; </a> 0
<a> } </a> 0
<a> private static void heapSort ( int [ ] val , int off , int len ) { </a> 0
<a> if ( len <= 1 ) </a> 0
<a> return ; </a> 0
<a> int corr = off - 1 ; </a> 0
<a> for ( int i = 2 ; i <= len ; i ++ ) { </a> 0
<a> int j = i ; </a> 0
<a> int v = val [ corr + j ] ; </a> 0
<a> while ( j > 1 ) { </a> 0
<a> int k = j > > > 1 ; </a> 0
<a> int f = val [ corr + k ] ; </a> 0
<a> if ( f > v ) </a> 0
<a> break ; </a> 0
<a> val [ corr + j ] = f ; </a> 0
<a> val [ corr + k ] = v ; </a> 0
<a> j = k ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( int i = len ; i > 1 ; i -- ) { </a> 0
<a> int v = val [ corr + i ] ; </a> 0
<a> val [ corr + i ] = val [ corr + 1 ] ; </a> 0
<a> val [ corr + 1 ] = v ; </a> 0
<a> int j = 1 ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> int kl = j < < 1 ; </a> 0
<a> int kr = kl + 1 ; </a> 0
<a> if ( kl >= i ) </a> 0
<a> break ; </a> 0
<a> int si ; </a> 0
<a> int sv ; </a> 0
<a> if ( kr >= i ) { </a> 0
<a> si = kl ; </a> 0
<a> sv = val [ corr + kl ] ; </a> 0
<a> } else { </a> 0
<a> int cl = val [ corr + kl ] ; </a> 0
<a> int cr = val [ corr + kr ] ; </a> 0
<a> if ( cl > cr ) { </a> 0
<a> si = kl ; </a> 0
<a> sv = cl ; </a> 0
<a> } else { </a> 0
<a> si = kr ; </a> 0
<a> sv = cr ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( v > sv ) </a> 0
<a> break ; </a> 0
<a> val [ corr + j ] = sv ; </a> 0
<a> val [ corr + si ] = v ; </a> 0
<a> j = si ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static int [ ] makeHuffmanCodes ( int [ ] freq , int maxCodeLen ) { </a> 0
<a> int alphLen = freq . length ; </a> 0
<a> int [ ] freqTmp = new int [ alphLen ] ; </a> 0
<a> for ( int i = 0 ; i < alphLen ; i ++ ) </a> 0
<a> freqTmp [ i ] = i + ( 1 < < 9 ) + ( freq [ i ] < < 10 ) ; </a> 0
<a> heapSort ( freqTmp , 0 , alphLen ) ; </a> 0
<a> int freqTmpPtr = 0 ; </a> 0
<a> while ( freqTmpPtr < alphLen && ( freqTmp [ freqTmpPtr ] > > > 10 ) == 0 ) </a> 0
<a> freqTmpPtr ++ ; </a> 0
<a> if ( freqTmpPtr == alphLen ) { </a> 0
<a> return new int [ alphLen ] ; </a> 0
<a> } </a> 0
<a> if ( freqTmpPtr == ( alphLen - 1 ) ) { </a> 0
<a> int [ ] clen = new int [ alphLen ] ; </a> 0
<a> clen [ freqTmp [ freqTmpPtr ] & 0x1FF ] = 1 ; </a> 0
<a> return clen ; </a> 0
<a> } </a> 0
<a> int [ ] fifo = new int [ alphLen - 1 ] ; </a> 0
<a> int fifoHead = 0 , fifoRear = 0 ; </a> 0
<a> int [ ] tree = new int [ alphLen - 1 ] ; </a> 0
<a> int treePtr = 0 ; </a> 0
<a> int rootIndex ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> if ( freqTmpPtr == alphLen && fifoRear == ( fifoHead + 1 ) ) { </a> 0
<a> rootIndex = fifo [ fifoHead ] & 0x1FF ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> int n0 , n1 ; </a> 0
<a> if ( fifoRear == fifoHead ) { </a> 0
<a> n0 = freqTmp [ freqTmpPtr ++ ] ; </a> 0
<a> n1 = freqTmp [ freqTmpPtr ++ ] ; </a> 0
<a> } else if ( freqTmpPtr == alphLen ) { </a> 0
<a> n0 = fifo [ fifoHead ++ ] ; </a> 0
<a> n1 = fifo [ fifoHead ++ ] ; </a> 0
<a> } else { </a> 0
<a> int f = fifo [ fifoHead ] ; </a> 0
<a> int q = freqTmp [ freqTmpPtr ] ; </a> 0
<a> if ( f < q ) { </a> 0
<a> n0 = f ; </a> 0
<a> fifoHead ++ ; </a> 0
<a> } else { </a> 0
<a> n0 = q ; </a> 0
<a> freqTmpPtr ++ ; </a> 0
<a> } </a> 0
<a> if ( fifoHead == fifoRear ) { </a> 0
<a> n1 = freqTmp [ freqTmpPtr ++ ] ; </a> 0
<a> } else if ( freqTmpPtr == alphLen ) { </a> 0
<a> n1 = fifo [ fifoHead ++ ] ; </a> 0
<a> } else { </a> 0
<a> f = fifo [ fifoHead ] ; </a> 0
<a> q = freqTmp [ freqTmpPtr ] ; </a> 0
<a> if ( f < q ) { </a> 0
<a> n1 = f ; </a> 0
<a> fifoHead ++ ; </a> 0
<a> } else { </a> 0
<a> n1 = q ; </a> 0
<a> freqTmpPtr ++ ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int ni = ( n0 & ~ 0x3FF ) + ( n1 & ~ 0x3FF ) + treePtr ; </a> 0
<a> fifo [ fifoRear ++ ] = ni ; </a> 0
<a> int nv = ( n0 & 0x3FF ) + ( ( n1 & 0x3FF ) < < 10 ) ; </a> 0
<a> tree [ treePtr ++ ] = nv ; </a> 0
<a> } </a> 0
<a> int [ ] blCount = new int [ maxCodeLen + 1 ] ; </a> 0
<a> int overdeep = getCodeLengths ( tree , rootIndex , 0 , blCount , maxCodeLen ) ; </a> 0
<a> int dpi = maxCodeLen ; </a> 0
<a> while ( overdeep -- > 0 ) { </a> 0
<a> if ( dpi == maxCodeLen ) { </a> 0
<a> do { </a> 0
<a> dpi -- ; </a> 0
<a> } </a> 0
<a> while ( blCount [ dpi ] == 0 ) ; </a> 0
<a> } </a> 0
<a> blCount [ dpi ] -- ; </a> 0
<a> blCount [ ++ dpi ] += 2 ; </a> 0
<a> } </a> 0
<a> int [ ] codeLen = new int [ alphLen ] ; </a> 0
<a> int p = 0 ; </a> 0
<a> while ( ( freqTmp [ p ] > > > 10 ) == 0 ) </a> 0
<a> p ++ ; </a> 0
<a> for ( int bits = maxCodeLen ; bits > 0 ; bits -- ) { </a> 0
<a> for ( int k = blCount [ bits ] ; k > 0 ; k -- ) { </a> 0
<a> int sym = freqTmp [ p ++ ] & 0x1FF ; </a> 0
<a> codeLen [ sym ] = bits ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return codeLen ; </a> 0
<a> } </a> 0
<a> private static int getCodeLengths ( int [ ] tree , int idx , int depth , int [ ] blCount , int maxCodeLen ) { </a> 0
<a> if ( ( idx & 0x200 ) != 0 ) { </a> 0
<a> if ( depth > maxCodeLen ) { </a> 0
<a> return 1 ; </a> 0
<a> } else { </a> 0
<a> blCount [ depth ] ++ ; </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int s ; </a> 0
<a> if ( depth == maxCodeLen ) { </a> 0
<a> blCount [ maxCodeLen ] ++ ; </a> 0
<a> s = - 1 ; </a> 0
<a> } else { </a> 0
<a> s = 0 ; </a> 0
<a> } </a> 0
<a> int n = tree [ idx ] ; </a> 0
<a> int l = n & 0x3FF ; </a> 0
<a> int r = ( n > > > 10 ) & 0x3FF ; </a> 0
<a> s += getCodeLengths ( tree , l , depth + 1 , blCount , maxCodeLen ) ; </a> 0
<a> s += getCodeLengths ( tree , r , depth + 1 , blCount , maxCodeLen ) ; </a> 0
<a> return s ; </a> 0
<a> } </a> 0
<a> private static final int [ ] FIXED_LIT_CODE ; </a> 0
<a> static { </a> 0
<a> int [ ] fixedLitCodeLen = new int [ 288 ] ; </a> 0
<a> for ( int i = 0 ; i < 144 ; i ++ ) </a> 0
<a> fixedLitCodeLen [ i ] = 8 ; </a> 0
<a> for ( int i = 144 ; i < 256 ; i ++ ) </a> 0
<a> fixedLitCodeLen [ i ] = 9 ; </a> 0
<a> for ( int i = 256 ; i < 280 ; i ++ ) </a> 0
<a> fixedLitCodeLen [ i ] = 7 ; </a> 0
<a> for ( int i = 280 ; i < 288 ; i ++ ) </a> 0
<a> fixedLitCodeLen [ i ] = 8 ; </a> 0
<a> FIXED_LIT_CODE = makeCanonicalHuff ( fixedLitCodeLen , 15 ) ; </a> 0
<a> } </a> 0
<a> private static final int [ ] FIXED_DIST_CODE ; </a> 0
<a> static { </a> 0
<a> int [ ] fixedDistCodeLen = new int [ 32 ] ; </a> 0
<a> for ( int i = 0 ; i < 32 ; i ++ ) </a> 0
<a> fixedDistCodeLen [ i ] = 5 ; </a> 0
<a> FIXED_DIST_CODE = makeCanonicalHuff ( fixedDistCodeLen , 15 ) ; </a> 0
<a> } </a> 0
<a> private static int [ ] compressTrees ( int [ ] tree1 , int tree1len , int [ ] tree2 , int tree2len , int [ ] freq ) { </a> 0
<a> int inLen = tree1len + tree2len ; </a> 0
<a> int [ ] in = new int [ inLen ] ; </a> 0
<a> System . arraycopy ( tree1 , 0 , in , 0 , tree1len ) ; </a> 0
<a> System . arraycopy ( tree2 , 0 , in , tree1len , tree2len ) ; </a> 0
<a> int ptr = 0 ; </a> 0
<a> int [ ] ct = new int [ inLen ] ; </a> 0
<a> int ctPtr = 0 ; </a> 0
<a> while ( ptr < inLen ) { </a> 0
<a> int v = in [ ptr ++ ] ; </a> 0
<a> if ( v == 0 ) { </a> 0
<a> int r = 1 ; </a> 0
<a> while ( r < 138 && ptr < inLen ) { </a> 0
<a> if ( in [ ptr ] != 0 ) </a> 0
<a> break ; </a> 0
<a> r ++ ; </a> 0
<a> ptr ++ ; </a> 0
<a> } </a> 0
<a> switch ( r ) { </a> 0
<a> case 1 : </a> 0
<a> ct [ ctPtr ++ ] = 0 ; </a> 0
<a> freq [ 0 ] ++ ; </a> 0
<a> break ; </a> 0
<a> case 2 : </a> 0
<a> ct [ ctPtr ++ ] = 0 ; </a> 0
<a> ct [ ctPtr ++ ] = 0 ; </a> 0
<a> freq [ 0 ] += 2 ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> if ( r <= 10 ) { </a> 0
<a> ct [ ctPtr ++ ] = 17 + ( ( r - 3 ) < < 5 ) ; </a> 0
<a> freq [ 17 ] ++ ; </a> 0
<a> } else { </a> 0
<a> ct [ ctPtr ++ ] = 18 + ( ( r - 11 ) < < 5 ) ; </a> 0
<a> freq [ 18 ] ++ ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> int r = 0 ; </a> 0
<a> while ( r < 6 && ptr < inLen ) { </a> 0
<a> if ( in [ ptr ] != v ) </a> 0
<a> break ; </a> 0
<a> r ++ ; </a> 0
<a> ptr ++ ; </a> 0
<a> } </a> 0
<a> ct [ ctPtr ++ ] = v ; </a> 0
<a> freq [ v ] ++ ; </a> 0
<a> switch ( r ) { </a> 0
<a> case 0 : </a> 0
<a> break ; </a> 0
<a> case 1 : </a> 0
<a> ct [ ctPtr ++ ] = v ; </a> 0
<a> freq [ v ] ++ ; </a> 0
<a> break ; </a> 0
<a> case 2 : </a> 0
<a> ct [ ctPtr ++ ] = v ; </a> 0
<a> ct [ ctPtr ++ ] = v ; </a> 0
<a> freq [ v ] += 2 ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> ct [ ctPtr ++ ] = 16 + ( ( r - 3 ) < < 5 ) ; </a> 0
<a> freq [ 16 ] ++ ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int [ ] res = new int [ ctPtr ] ; </a> 0
<a> System . arraycopy ( ct , 0 , res , 0 , ctPtr ) ; </a> 0
<a> return res ; </a> 0
<a> } </a> 0
<a> private void writeBits ( int val , int num ) throws IOException { </a> 0
<a> if ( num == 0 ) </a> 0
<a> return ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> int fs = 8 - outPtr ; </a> 0
<a> int v = outByte | ( val < < outPtr ) ; </a> 0
<a> if ( fs > num ) { </a> 0
<a> outByte = v ; </a> 0
<a> outPtr += num ; </a> 0
<a> return ; </a> 0
<a> } else if ( fs == num ) { </a> 0
<a> outBuf [ outBufPtr ++ ] = ( byte ) v ; </a> 0
<a> if ( outBufPtr == outBuf . length ) { </a> 0
<a> out . write ( outBuf ) ; </a> 0
<a> outBufPtr = 0 ; </a> 0
<a> } </a> 0
<a> outByte = 0 ; </a> 0
<a> outPtr = 0 ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> outBuf [ outBufPtr ++ ] = ( byte ) v ; </a> 0
<a> if ( outBufPtr == outBuf . length ) { </a> 0
<a> out . write ( outBuf ) ; </a> 0
<a> outBufPtr = 0 ; </a> 0
<a> } </a> 0
<a> val >>>= fs ; </a> 0
<a> num -= fs ; </a> 0
<a> outByte = 0 ; </a> 0
<a> outPtr = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void sendBuffered ( ) throws IOException { </a> 0
<a> if ( outBufPtr > 0 ) { </a> 0
<a> out . write ( outBuf , 0 , outBufPtr ) ; </a> 0
<a> outBufPtr = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void endBlock ( boolean fin , int sbPtr ) throws IOException { </a> 0
<a> if ( noOutput ) { </a> 0
<a> bufferPtr = 0 ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> int [ ] sb = buffer ; </a> 0
<a> int [ ] freqLit = new int [ 286 ] ; </a> 0
<a> int [ ] freqDist = new int [ 30 ] ; </a> 0
<a> freqLit [ 256 ] = 1 ; </a> 0
<a> int csU = 0 ; </a> 0
<a> for ( int i = 0 ; i < sbPtr ; i ++ ) { </a> 0
<a> int val = sb [ i ] ; </a> 0
<a> int sym = val & 0x1FF ; </a> 0
<a> freqLit [ sym ] ++ ; </a> 0
<a> if ( sym < 256 ) { </a> 0
<a> csU += 8 ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> csU += 8 * ( LENGTH [ sym - 257 ] + ( ( val > > > 9 ) & 0x1F ) ) ; </a> 0
<a> int dist = ( val > > > 14 ) & 0x1F ; </a> 0
<a> freqDist [ dist ] ++ ; </a> 0
<a> } </a> 0
<a> int csUextra = 0 ; </a> 0
<a> for ( int t = 0 ; t < csU ; t += 65535 ) { </a> 0
<a> if ( t == 0 ) { </a> 0
<a> if ( outPtr > 5 ) { </a> 0
<a> csUextra = 48 - outPtr ; </a> 0
<a> } else { </a> 0
<a> csUextra = 40 - outPtr ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> csUextra += 40 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int uDataLen = ( csU > > > 3 ) ; </a> 0
<a> csU += csUextra ; </a> 0
<a> Huff huff = new Huff ( freqLit , freqDist ) ; </a> 0
<a> int csD = huff . getDynamicBitLength ( ) ; </a> 0
<a> int csF = huff . getFixedBitLength ( ) ; </a> 0
<a> if ( csU <= csF && csU <= csD ) { </a> 0
<a> writeBits ( fin ? 1 : 0 , 3 ) ; </a> 0
<a> if ( outPtr > 0 ) </a> 0
<a> writeBits ( 0 , 8 - outPtr ) ; </a> 0
<a> writeBits ( uDataLen | ( ~ uDataLen < < 16 ) , 32 ) ; </a> 0
<a> sendBuffered ( ) ; </a> 0
<a> out . write ( ucBuffer , 0 , uDataLen ) ; </a> 0
<a> } else if ( csF <= csD ) { </a> 0
<a> writeBits ( fin ? 3 : 2 , 3 ) ; </a> 0
<a> for ( int i = 0 ; i < sbPtr ; i ++ ) { </a> 0
<a> int val = buffer [ i ] ; </a> 0
<a> int sym = val & 0x1FF ; </a> 0
<a> if ( sym < 256 ) { </a> 0
<a> writeBits ( FIXED_LIT_CODE [ sym ] , sym < 144 ? 8 : 9 ) ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> writeBits ( FIXED_LIT_CODE [ sym ] , sym < 280 ? 7 : 8 ) ; </a> 0
<a> int eLenNum = LENGTH_ENUM [ sym - 257 ] ; </a> 0
<a> if ( eLenNum > 0 ) </a> 0
<a> writeBits ( ( val > > > 9 ) & 0x1F , eLenNum ) ; </a> 0
<a> int dist = ( val > > > 14 ) & 0x1F ; </a> 0
<a> writeBits ( FIXED_DIST_CODE [ dist ] , 5 ) ; </a> 0
<a> int eDistNum = DIST_ENUM [ dist ] ; </a> 0
<a> if ( eDistNum > 0 ) </a> 0
<a> writeBits ( val > > > 19 , eDistNum ) ; </a> 0
<a> } </a> 0
<a> writeBits ( FIXED_LIT_CODE [ 256 ] , 7 ) ; </a> 0
<a> } else { </a> 0
<a> int [ ] litCode = huff . getLitCode ( ) ; </a> 0
<a> int [ ] litCodeLen = huff . getLitCodeLen ( ) ; </a> 0
<a> int [ ] distCode = huff . getDistCode ( ) ; </a> 0
<a> int [ ] distCodeLen = huff . getDistCodeLen ( ) ; </a> 0
<a> int [ ] compTrees = huff . getCompTrees ( ) ; </a> 0
<a> int compTreesLen = compTrees . length ; </a> 0
<a> int [ ] ctCode = huff . getCTCode ( ) ; </a> 0
<a> int [ ] ctCodeLen = huff . getCTCodeLen ( ) ; </a> 0
<a> int [ ] permCT = huff . getPermCT ( ) ; </a> 0
<a> int permCTLen = permCT . length ; </a> 0
<a> writeBits ( fin ? 5 : 4 , 3 ) ; </a> 0
<a> writeBits ( litCode . length - 257 , 5 ) ; </a> 0
<a> writeBits ( distCode . length - 1 , 5 ) ; </a> 0
<a> writeBits ( permCTLen - 4 , 4 ) ; </a> 0
<a> for ( int i = 0 ; i < permCTLen ; i ++ ) </a> 0
<a> writeBits ( permCT [ i ] , 3 ) ; </a> 0
<a> for ( int i = 0 ; i < compTreesLen ; i ++ ) { </a> 0
<a> int v = compTrees [ i ] ; </a> 0
<a> int s = v & 0x1F ; </a> 0
<a> writeBits ( ctCode [ s ] , ctCodeLen [ s ] ) ; </a> 0
<a> int ebits ; </a> 0
<a> switch ( s ) { </a> 0
<a> case 16 : </a> 0
<a> ebits = 2 ; </a> 0
<a> break ; </a> 0
<a> case 17 : </a> 0
<a> ebits = 3 ; </a> 0
<a> break ; </a> 0
<a> case 18 : </a> 0
<a> ebits = 7 ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> writeBits ( ( v > > > 5 ) , ebits ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < sbPtr ; i ++ ) { </a> 0
<a> int val = buffer [ i ] ; </a> 0
<a> int sym = val & 0x1FF ; </a> 0
<a> writeBits ( litCode [ sym ] , litCodeLen [ sym ] ) ; </a> 0
<a> if ( sym < 256 ) </a> 0
<a> continue ; </a> 0
<a> int eLenNum = LENGTH_ENUM [ sym - 257 ] ; </a> 0
<a> if ( eLenNum > 0 ) </a> 0
<a> writeBits ( ( val > > > 9 ) & 0x1F , eLenNum ) ; </a> 0
<a> int dist = ( val > > > 14 ) & 0x1F ; </a> 0
<a> writeBits ( distCode [ dist ] , distCodeLen [ dist ] ) ; </a> 0
<a> int eDistNum = DIST_ENUM [ dist ] ; </a> 0
<a> if ( eDistNum > 0 ) </a> 0
<a> writeBits ( val > > > 19 , eDistNum ) ; </a> 0
<a> } </a> 0
<a> writeBits ( litCode [ 256 ] , litCodeLen [ 256 ] ) ; </a> 0
<a> } </a> 0
<a> sendBuffered ( ) ; </a> 0
<a> bufferPtr = 0 ; </a> 0
<a> int uLen = ucBuffer . length ; </a> 0
<a> int uRealLen = ucBufferPtr ; </a> 0
<a> while ( uRealLen < uDataLen ) </a> 0
<a> uRealLen += uLen ; </a> 0
<a> if ( uDataLen < uRealLen ) { </a> 0
<a> int tm = uRealLen - uDataLen ; </a> 0
<a> if ( tm > 258 ) </a> 0
<a> throw new Error ( "too much data: " + tm ) ; </a> 0
<a> if ( tm <= ucBufferPtr ) { </a> 0
<a> System . arraycopy ( ucBuffer , ucBufferPtr - tm , ucBuffer , 0 , tm ) ; </a> 0
<a> } else { </a> 0
<a> int fpl = tm - ucBufferPtr ; </a> 0
<a> System . arraycopy ( ucBuffer , 0 , ucBuffer , fpl , ucBufferPtr ) ; </a> 0
<a> System . arraycopy ( ucBuffer , uLen - fpl , ucBuffer , 0 , fpl ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ucBufferPtr = uRealLen - uDataLen ; </a> 0
<a> } </a> 0
<a> private static class Huff { </a> 0
<a> private int [ ] litCode , litCodeLen ; </a> 0
<a> private int [ ] distCode , distCodeLen ; </a> 0
<a> private int [ ] compTrees ; </a> 0
<a> private int [ ] ctCode , ctCodeLen ; </a> 0
<a> private int [ ] permCT ; </a> 0
<a> private int csD , csF ; </a> 0
<a> private Huff ( int [ ] freqLit , int [ ] freqDist ) { </a> 0
<a> csD = 17 ; </a> 0
<a> csF = 3 ; </a> 0
<a> litCodeLen = makeHuffmanCodes ( freqLit , 15 ) ; </a> 0
<a> distCodeLen = makeHuffmanCodes ( freqDist , 15 ) ; </a> 0
<a> for ( int i = 0 ; i < litCodeLen . length ; i ++ ) { </a> 0
<a> int f = freqLit [ i ] ; </a> 0
<a> int elen ; </a> 0
<a> elen = ( i >= 257 ) ? LENGTH_ENUM [ i - 257 ] : 0 ; </a> 0
<a> csD += ( litCodeLen [ i ] + elen ) * f ; </a> 0
<a> int fcl ; </a> 0
<a> if ( i < 256 ) { </a> 0
<a> fcl = ( i < 144 ) ? 8 : 9 ; </a> 0
<a> } else { </a> 0
<a> fcl = ( i < 280 ) ? 7 : 8 ; </a> 0
<a> } </a> 0
<a> csF += ( fcl + elen ) * f ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < distCodeLen . length ; i ++ ) { </a> 0
<a> int f = freqDist [ i ] ; </a> 0
<a> int edist = DIST_ENUM [ i ] ; </a> 0
<a> csD += ( distCodeLen [ i ] + edist ) * f ; </a> 0
<a> csF += ( 5 + edist ) * f ; </a> 0
<a> } </a> 0
<a> litCode = makeCanonicalHuff ( litCodeLen , 15 ) ; </a> 0
<a> distCode = makeCanonicalHuff ( distCodeLen , 15 ) ; </a> 0
<a> if ( distCode . length == 0 ) </a> 0
<a> distCode = new int [ 1 ] ; </a> 0
<a> int [ ] freqCT = new int [ 19 ] ; </a> 0
<a> compTrees = compressTrees ( litCodeLen , litCode . length , distCodeLen , distCode . length , freqCT ) ; </a> 0
<a> ctCodeLen = makeHuffmanCodes ( freqCT , 7 ) ; </a> 0
<a> ctCode = makeCanonicalHuff ( ctCodeLen , 7 ) ; </a> 0
<a> for ( int i = 0 ; i < 19 ; i ++ ) { </a> 0
<a> int ccl = ctCodeLen [ i ] ; </a> 0
<a> switch ( i ) { </a> 0
<a> case 16 : </a> 0
<a> ccl += 2 ; </a> 0
<a> break ; </a> 0
<a> case 17 : </a> 0
<a> ccl += 3 ; </a> 0
<a> break ; </a> 0
<a> case 18 : </a> 0
<a> ccl += 7 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> csD += freqCT [ i ] * ccl ; </a> 0
<a> } </a> 0
<a> int [ ] permCTtmp = new int [ 19 ] ; </a> 0
<a> int permCTLen = 0 ; </a> 0
<a> for ( int i = 0 ; i < 19 ; i ++ ) { </a> 0
<a> int len = ctCodeLen [ PERM_CT [ i ] ] ; </a> 0
<a> if ( len > 0 ) </a> 0
<a> permCTLen = i + 1 ; </a> 0
<a> permCTtmp [ i ] = len ; </a> 0
<a> } </a> 0
<a> permCT = new int [ permCTLen ] ; </a> 0
<a> System . arraycopy ( permCTtmp , 0 , permCT , 0 , permCTLen ) ; </a> 0
<a> csD += 3 * permCTLen ; </a> 0
<a> } </a> 0
<a> private int [ ] getLitCode ( ) { </a> 0
<a> return litCode ; </a> 0
<a> } </a> 0
<a> private int [ ] getLitCodeLen ( ) { </a> 0
<a> return litCodeLen ; </a> 0
<a> } </a> 0
<a> private int [ ] getDistCode ( ) { </a> 0
<a> return distCode ; </a> 0
<a> } </a> 0
<a> private int [ ] getDistCodeLen ( ) { </a> 0
<a> return distCodeLen ; </a> 0
<a> } </a> 0
<a> private int [ ] getCompTrees ( ) { </a> 0
<a> return compTrees ; </a> 0
<a> } </a> 0
<a> private int [ ] getCTCode ( ) { </a> 0
<a> return ctCode ; </a> 0
<a> } </a> 0
<a> private int [ ] getCTCodeLen ( ) { </a> 0
<a> return ctCodeLen ; </a> 0
<a> } </a> 0
<a> private int [ ] getPermCT ( ) { </a> 0
<a> return permCT ; </a> 0
<a> } </a> 0
<a> private int getDynamicBitLength ( ) { </a> 0
<a> return csD ; </a> 0
<a> } </a> 0
<a> private int getFixedBitLength ( ) { </a> 0
<a> return csF ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void writeEmptySH ( boolean fin ) throws IOException { </a> 0
<a> writeBits ( fin ? 3 : 2 , 10 ) ; </a> 0
<a> } </a> 0
<a> private void writeEmptyUD ( boolean fin , boolean wd ) throws IOException { </a> 0
<a> writeBits ( fin ? 1 : 0 , 3 ) ; </a> 0
<a> if ( outPtr > 0 ) </a> 0
<a> writeBits ( 0 , 8 - outPtr ) ; </a> 0
<a> if ( wd ) </a> 0
<a> writeBits ( 0xFFFF0000 , 32 ) ; </a> 0
<a> } </a> 0
<a> public void terminate ( ) throws IOException { </a> 0
<a> prepareFlush ( ) ; </a> 0
<a> if ( bufferPtr == 0 ) { </a> 0
<a> writeEmptySH ( true ) ; </a> 0
<a> } else { </a> 0
<a> endBlock ( true , bufferPtr ) ; </a> 0
<a> } </a> 0
<a> if ( outPtr > 0 ) </a> 0
<a> writeBits ( 0 , 8 - outPtr ) ; </a> 0
<a> sendBuffered ( ) ; </a> 0
<a> } </a> 0
<a> public void flushSync ( boolean withData ) throws IOException { </a> 0
<a> prepareFlush ( ) ; </a> 0
<a> if ( bufferPtr != 0 ) </a> 0
<a> endBlock ( false , bufferPtr ) ; </a> 0
<a> writeEmptyUD ( false , withData ) ; </a> 0
<a> sendBuffered ( ) ; </a> 0
<a> } </a> 0
<a> static final int [ ] LENGTH ; </a> 0
<a> static final int [ ] LENGTH_ENUM = { </a> 0
<a> 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , </a> 0
<a> 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 0 </a> 0
<a> } ; </a> 0
<a> static { </a> 0
<a> LENGTH = new int [ 29 ] ; </a> 0
<a> LENGTH [ 0 ] = 3 ; </a> 0
<a> int l = 3 ; </a> 0
<a> for ( int i = 1 ; i < 28 ; i ++ ) { </a> 0
<a> l += 1 < < LENGTH_ENUM [ i - 1 ] ; </a> 0
<a> LENGTH [ i ] = l ; </a> 0
<a> } </a> 0
<a> LENGTH [ 28 ] = 258 ; </a> 0
<a> } </a> 0
<a> static final int [ ] DIST ; </a> 0
<a> static final int [ ] DIST_ENUM = { </a> 0
<a> 0 , 0 , 0 , 0 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 , 6 , 7 , 7 , </a> 0
<a> 8 , 8 , 9 , 9 , 10 , 10 , 11 , 11 , 12 , 12 , 13 , 13 </a> 0
<a> } ; </a> 0
<a> static { </a> 0
<a> DIST = new int [ 30 ] ; </a> 0
<a> DIST [ 0 ] = 1 ; </a> 0
<a> int d = 1 ; </a> 0
<a> for ( int i = 1 ; i < 30 ; i ++ ) { </a> 0
<a> d += 1 < < DIST_ENUM [ i - 1 ] ; </a> 0
<a> DIST [ i ] = d ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static final int [ ] PERM_CT = { </a> 0
<a> 16 , 17 , 18 , 0 , 8 , 7 , 9 , 6 , 10 , 5 , </a> 0
<a> 11 , 4 , 12 , 3 , 13 , 2 , 14 , 1 , 15 </a> 0
<a> } ; </a> 0
<a> static int [ ] makeCanonicalHuff ( int [ ] codeLen , int maxCodeLen ) { </a> 0
<a> int alphLen = codeLen . length ; </a> 0
<a> int actualAlphLen = 0 ; </a> 0
<a> int [ ] blCount = new int [ maxCodeLen + 1 ] ; </a> 0
<a> for ( int n = 0 ; n < alphLen ; n ++ ) { </a> 0
<a> int len = codeLen [ n ] ; </a> 0
<a> if ( len < 0 || len > maxCodeLen ) </a> 0
<a> return null ; </a> 0
<a> if ( len > 0 ) { </a> 0
<a> actualAlphLen = n + 1 ; </a> 0
<a> blCount [ len ] ++ ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int [ ] nextCode = new int [ maxCodeLen + 1 ] ; </a> 0
<a> int codeVal = 0 ; </a> 0
<a> for ( int bits = 1 ; bits <= maxCodeLen ; bits ++ ) { </a> 0
<a> codeVal = ( codeVal + blCount [ bits - 1 ] ) < < 1 ; </a> 0
<a> nextCode [ bits ] = codeVal ; </a> 0
<a> } </a> 0
<a> int [ ] code = new int [ actualAlphLen ] ; </a> 0
<a> for ( int n = 0 ; n < actualAlphLen ; n ++ ) { </a> 0
<a> int len = codeLen [ n ] ; </a> 0
<a> if ( len != 0 ) { </a> 0
<a> int w = nextCode [ len ] ; </a> 0
<a> if ( w >= ( 1 < < len ) ) </a> 0
<a> return null ; </a> 0
<a> code [ n ] = reverse ( w , len ) ; </a> 0
<a> nextCode [ len ] = w + 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return code ; </a> 0
<a> } </a> 0
<a> private static int reverse ( int cc , int q ) { </a> 0
<a> int v = 0 ; </a> 0
<a> while ( q -- > 0 ) { </a> 0
<a> v <<= 1 ; </a> 0
<a> if ( ( cc & 1 ) != 0 ) </a> 0
<a> v ++ ; </a> 0
<a> cc >>>= 1 ; </a> 0
<a> } </a> 0
<a> return v ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . deflate ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> public class DeflaterOutputStream extends OutputStream { </a> 0
<a> private Deflater deflater ; </a> 0
<a> public DeflaterOutputStream ( OutputStream out ) throws IOException { </a> 0
<a> this ( out , Deflater . MEDIUM ) ; </a> 0
<a> } </a> 0
<a> public DeflaterOutputStream ( OutputStream out , int level ) throws IOException { </a> 0
<a> deflater = new Deflater ( level ) ; </a> 0
<a> deflater . setOut ( out ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws IOException { </a> 0
<a> deflater . terminate ( ) ; </a> 0
<a> deflater . getOut ( ) . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( ) throws IOException { </a> 0
<a> deflater . flushSync ( true ) ; </a> 0
<a> deflater . getOut ( ) . flush ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( int b ) throws IOException { </a> 0
<a> write ( new byte [ ] { ( byte ) b } , 0 , 1 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( byte [ ] buf ) throws IOException { </a> 0
<a> write ( buf , 0 , buf . length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( byte [ ] buf , int off , int len ) throws IOException { </a> 0
<a> deflater . process ( buf , off , len ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . impl ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> public class CountOutputStream extends OutputStream { </a> 0
<a> private int count ; </a> 0
<a> private final OutputStream out ; </a> 0
<a> private boolean ignoreFlush ; </a> 0
<a> public CountOutputStream ( OutputStream out ) { </a> 0
<a> this . out = out ; </a> 0
<a> } </a> 0
<a> public int getCount ( ) { </a> 0
<a> return count ; </a> 0
<a> } </a> 0
<a> public void setIgnoreFlush ( boolean ignoreFlush ) { </a> 0
<a> this . ignoreFlush = ignoreFlush ; </a> 0
<a> } </a> 0
<a> public boolean isIgnoreFlush ( ) { </a> 0
<a> return ignoreFlush ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( int b ) throws IOException { </a> 0
<a> out . write ( b ) ; </a> 0
<a> count ++ ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( byte [ ] b ) throws IOException { </a> 0
<a> out . write ( b ) ; </a> 0
<a> count += b . length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( byte [ ] b , int off , int len ) throws IOException { </a> 0
<a> out . write ( b , off , len ) ; </a> 0
<a> count += len ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( ) throws IOException { </a> 0
<a> if ( ! ignoreFlush ) { </a> 0
<a> out . flush ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . impl ; </a> 0
<a> import com . google . gwt . rpc . server . ClientOracle ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereEventLifecycle ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . Serializer ; </a> 0
<a> import org . atmosphere . gwt . server . AtmosphereGwtHandler ; </a> 0
<a> import org . atmosphere . gwt . server . GwtAtmosphereResource ; </a> 0
<a> import org . atmosphere . gwt . server . GwtResponseWriter ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . servlet . http . HttpSession ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . Collection ; </a> 1
<a> import java . util . List ; </a> 0
<a> import java . util . concurrent . ScheduledFuture ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public class GwtAtmosphereResourceImpl implements GwtAtmosphereResource { </a> 0
<a> public static final String HEARTBEAT_MESSAGE = "4dc5bdb9-edc8-4edf-8833-ab478326d8c9" ; </a> 0
<a> public GwtAtmosphereResourceImpl ( AtmosphereResource < HttpServletRequest , HttpServletResponse > resource , </a> 0
<a> AtmosphereGwtHandler servlet , int heartBeatInterval ) throws IOException { </a> 0
<a> this . atmosphereHandler = servlet ; </a> 0
<a> this . atmResource = resource ; </a> 0
<a> this . heartBeatInterval = heartBeatInterval ; </a> 0
<a> this . writer = createResponseWriter ( ) ; </a> 0
<a> resource . getRequest ( ) . setAttribute ( GwtAtmosphereResource . class . getName ( ) , this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Broadcaster getBroadcaster ( ) { </a> 0
<a> return atmResource . getBroadcaster ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public HttpSession getSession ( ) { </a> 0
<a> return atmResource . getRequest ( ) . getSession ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public HttpSession getSession ( boolean create ) { </a> 0
<a> return atmResource . getRequest ( ) . getSession ( create ) ; </a> 0
<a> } </a> 0
<a> GwtResponseWriter getResponseWriter ( ) { </a> 0
<a> return writer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getHeartBeatInterval ( ) { </a> 0
<a> return heartBeatInterval ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void broadcast ( Serializable message ) { </a> 0
<a> getBroadcaster ( ) . broadcast ( message , atmResource ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void broadcast ( List < Serializable > messages ) { </a> 0
<a> getBroadcaster ( ) . broadcast ( messages , atmResource ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void post ( Serializable message ) { </a> 0
<a> getBroadcaster ( ) . broadcast ( message , atmResource ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void post ( List < Serializable > messages ) { </a> 0
<a> getBroadcaster ( ) . broadcast ( messages , atmResource ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public AtmosphereResource < HttpServletRequest , HttpServletResponse > getAtmosphereResource ( ) { </a> 0
<a> return atmResource ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isAlive ( ) { </a> 0
<a> if ( writer . isTerminated ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ( System . currentTimeMillis ( ) - startTime ) < WARMUP_TIME ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( atmResource . getBroadcaster ( ) == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> Collection < AtmosphereResource < ? , ? > > res = atmResource . getBroadcaster ( ) . getAtmosphereResources ( ) ; </a> 0
<a> for ( AtmosphereResource < ? , ? > ar : res ) { </a> 0
<a> if ( ar == atmResource ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return suspended ; </a> 0
<a> } </a> 0
<a> long getStartTime ( ) { </a> 0
<a> return startTime ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public HttpServletRequest getRequest ( ) { </a> 0
<a> return atmResource . getRequest ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public HttpServletResponse getResponse ( ) { </a> 0
<a> return atmResource . getResponse ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getConnectionID ( ) { </a> 0
<a> return writer . connectionID ; </a> 0
<a> } </a> 0
<a> public void suspend ( ) throws IOException { </a> 0
<a> suspend ( - 1 ) ; </a> 0
<a> } </a> 0
<a> public void suspend ( int timeout ) throws IOException { </a> 0
<a> if ( ! suspended ) { </a> 0
<a> atmResource . setSerializer ( serializer ) ; </a> 1
<a> if ( atmResource instanceof AtmosphereEventLifecycle ) { </a> 1
<a> AtmosphereEventLifecycle ael = ( AtmosphereEventLifecycle ) atmResource ; </a> 1
<a> ael . addEventListener ( eventListener ) ; </a> 1
<a> } </a> 1
<a> writer . suspend ( ) ; </a> 0
<a> atmResource . suspend ( timeout , false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void resume ( ) { </a> 0
<a> atmResource . resume ( ) ; </a> 0
<a> } </a> 0
<a> void resumeAfterDeath ( ) { </a> 0
<a> atmosphereHandler . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> atmResource . resume ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > void setAttribute ( String name , T value ) { </a> 0
<a> atmResource . getRequest ( ) . setAttribute ( name , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > T getAttribute ( String name ) { </a> 0
<a> return ( T ) atmResource . getRequest ( ) . getAttribute ( name ) ; </a> 0
<a> } </a> 0
<a> public GwtResponseWriterImpl getWriterImpl ( ) { </a> 0
<a> return writer ; </a> 0
<a> } </a> 0
<a> ScheduledFuture < ? > scheduleHeartbeat ( ) { </a> 0
<a> return getBroadcaster ( ) . getBroadcasterConfig ( ) . getScheduledExecutorService ( ) </a> 0
<a> . schedule ( heartBeatTask , heartBeatInterval , TimeUnit . MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> void terminate ( boolean serverInitiated ) { </a> 0
<a> AtmosphereGwtHandler s = atmosphereHandler ; </a> 0
<a> if ( s != null ) { </a> 0
<a> atmosphereHandler = null ; </a> 0
<a> if ( suspended ) { </a> 0
<a> atmResource . resume ( ) ; </a> 0
<a> } </a> 0
<a> s . cometTerminated ( this , serverInitiated ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private GwtResponseWriterImpl createResponseWriter ( ) throws IOException { </a> 0
<a> ClientOracle clientOracle = RPCUtil . getClientOracle ( atmResource . getRequest ( ) , atmosphereHandler . getServletContext ( ) ) ; </a> 0
<a> SerializationPolicy serializationPolicy = clientOracle == null ? RPCUtil . createSimpleSerializationPolicy ( ) : null ; </a> 0
<a> String transport = atmResource . getRequest ( ) . getParameter ( "tr" ) ; </a> 0
<a> if ( "WebSocket" . equals ( transport ) ) { </a> 0
<a> logger . debug ( "atmosphere-gwt Using websocket" ) ; </a> 0
<a> return new WebsocketResponseWriter ( this , serializationPolicy , clientOracle ) ; </a> 0
<a> } else if ( "HTTPRequest" . equals ( transport ) ) { </a> 0
<a> logger . debug ( "atmosphere-gwt Using XMLHttpRequest" ) ; </a> 0
<a> return new HTTPRequestResponseWriter ( this , serializationPolicy , clientOracle ) ; </a> 0
<a> } else if ( "IFrame" . equals ( transport ) ) { </a> 0
<a> logger . debug ( "atmosphere-gwt Using streaming IFrame" ) ; </a> 0
<a> return new IFrameResponseWriter ( this , serializationPolicy , clientOracle ) ; </a> 0
<a> } else if ( "OperaEventSource" . equals ( transport ) ) { </a> 0
<a> logger . debug ( "atmosphere-gwt Using Opera EventSource" ) ; </a> 0
<a> return new OperaEventSourceResponseWriter ( this , serializationPolicy , clientOracle ) ; </a> 0
<a> } else if ( "IEXDomainRequest" . equals ( transport ) ) { </a> 0
<a> logger . debug ( "atmosphere-gwt Using IE XDomainRequest" ) ; </a> 0
<a> return new IEXDomainRequestResponseWriter ( this , serializationPolicy , clientOracle ) ; </a> 0
<a> } else if ( "IEHTMLFile" . equals ( transport ) ) { </a> 0
<a> logger . debug ( "atmosphere-gwt Using IE html file iframe" ) ; </a> 0
<a> return new IEHTMLFileResponseWriter ( this , serializationPolicy , clientOracle ) ; </a> 0
<a> } else { </a> 0
<a> throw new IllegalStateException ( "Failed to determine responsewriter" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final static long WARMUP_TIME = 10000 ; </a> 0
<a> private long startTime = System . currentTimeMillis ( ) ; </a> 0
<a> private final GwtResponseWriterImpl writer ; </a> 0
<a> private AtmosphereResource < HttpServletRequest , HttpServletResponse > atmResource ; </a> 0
<a> private final int heartBeatInterval ; </a> 0
<a> private AtmosphereGwtHandler atmosphereHandler ; </a> 0
<a> private boolean suspended = false ; </a> 0
<a> private Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; </a> 0
<a> private Runnable heartBeatTask = new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> if ( isAlive ( ) ) { </a> 0
<a> broadcast ( HEARTBEAT_MESSAGE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private final Serializer serializer = new Serializer ( ) { </a> 0
<a> @ Override </a> 0
<a> public void write ( OutputStream out , Object o ) throws IOException { </a> 0
<a> if ( o instanceof Serializable ) { </a> 0
<a> try { </a> 0
<a> writer . write ( ( Serializable ) o ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> if ( writer . isTerminated ( ) ) { </a> 0
<a> logger . debug ( "broadcast failed, connection terminated:" + e . getMessage ( ) , e ) ; </a> 0
<a> } </a> 0
<a> throw e ; </a> 0
<a> } </a> 0
<a> } else if ( o instanceof List ) { </a> 0
<a> List < ? > list = ( List ) o ; </a> 0
<a> if ( list . size ( ) > 0 ) { </a> 0
<a> if ( ! ( list . get ( 0 ) instanceof Serializable ) ) { </a> 0
<a> throw new IOException ( "Failed to write a list of objects that are not serializable" ) ; </a> 0
<a> } </a> 0
<a> writer . write ( ( List < Serializable > ) o ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> logger . warn ( "Failed to write an object that is not serializable" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private final AtmosphereResourceEventListener eventListener = new AtmosphereResourceEventListener ( ) { </a> 1
<a> @ Override </a> 0
<a> public void onSuspend ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > are ) { </a> 0
<a> suspended = true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> suspended = false ; </a> 0
<a> writer . setTerminated ( false ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> suspended = false ; </a> 0
<a> writer . setTerminated ( false ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> } </a> 1
<a> } ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . impl ; </a> 0
<a> import com . google . gwt . rpc . server . ClientOracle ; </a> 0
<a> import com . google . gwt . rpc . server . RPC ; </a> 0
<a> import com . google . gwt . user . client . rpc . SerializationException ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> import com . google . gwt . user . server . rpc . impl . ServerSerializationStreamWriter ; </a> 0
<a> import org . atmosphere . gwt . server . GwtResponseWriter ; </a> 1
<a> import org . atmosphere . gwt . server . deflate . DeflaterOutputStream ; </a> 1
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . servlet . http . HttpSession ; </a> 0
<a> import java . io . ByteArrayOutputStream ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> import java . io . NotSerializableException ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . io . OutputStreamWriter ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . io . UnsupportedEncodingException ; </a> 0
<a> import java . io . Writer ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . concurrent . ScheduledFuture ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> public abstract class GwtResponseWriterImpl implements GwtResponseWriter { </a> 0
<a> protected Writer writer ; </a> 0
<a> protected final GwtAtmosphereResourceImpl resource ; </a> 0
<a> protected final int connectionID ; </a> 0
<a> protected final Logger logger = LoggerFactory . getLogger ( getClass ( ) ) ; </a> 0
<a> protected GwtResponseWriterImpl ( GwtAtmosphereResourceImpl resource , SerializationPolicy serializationPolicy , ClientOracle clientOracle ) { </a> 0
<a> this . resource = resource ; </a> 0
<a> this . serializationPolicy = serializationPolicy ; </a> 0
<a> this . clientOracle = clientOracle ; </a> 0
<a> this . connectionID = connectionIDs . getAndIncrement ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized boolean isTerminated ( ) { </a> 0
<a> return terminated ; </a> 0
<a> } </a> 0
<a> protected boolean isDeRPC ( ) { </a> 0
<a> return clientOracle != null ; </a> 0
<a> } </a> 0
<a> public HttpServletRequest getRequest ( ) { </a> 0
<a> return resource . getAtmosphereResource ( ) . getRequest ( ) ; </a> 0
<a> } </a> 0
<a> public HttpServletResponse getResponse ( ) { </a> 0
<a> return resource . getAtmosphereResource ( ) . getResponse ( ) ; </a> 0
<a> } </a> 0
<a> synchronized void scheduleHeartbeat ( ) { </a> 0
<a> if ( logger . isTraceEnabled ( ) ) { </a> 0
<a> logger . trace ( "Schedule heartbeat for [" + connectionID + "]" ) ; </a> 0
<a> logger . trace ( "Last write for [" + connectionID + "] was " + new Date ( lastWriteTime ) . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> lastWriteTime = System . currentTimeMillis ( ) ; </a> 0
<a> if ( heartbeatFuture != null ) { </a> 0
<a> heartbeatFuture . cancel ( false ) ; </a> 0
<a> } </a> 0
<a> heartbeatFuture = resource . scheduleHeartbeat ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void sendError ( int statusCode ) throws IOException { </a> 0
<a> sendError ( statusCode , null ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized void sendError ( int statusCode , String message ) throws IOException { </a> 0
<a> try { </a> 0
<a> if ( writer == null ) { </a> 0
<a> getResponse ( ) . reset ( ) ; </a> 0
<a> getResponse ( ) . setHeader ( "Cache-Control" , "no-cache" ) ; </a> 0
<a> getResponse ( ) . setCharacterEncoding ( "UTF-8" ) ; </a> 0
<a> writer = new OutputStreamWriter ( getResponse ( ) . getOutputStream ( ) , "UTF-8" ) ; </a> 0
<a> } </a> 0
<a> doSendError ( statusCode , message ) ; </a> 0
<a> } catch ( IllegalStateException e ) { </a> 0
<a> logger . error ( "Error resetting response to send error: " + e . getMessage ( ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . debug ( "Failed to send error to client" , e ) ; </a> 0
<a> } finally { </a> 0
<a> setTerminated ( true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected OutputStream getOutputStream ( OutputStream outputStream ) { </a> 0
<a> return outputStream ; </a> 0
<a> } </a> 0
<a> public synchronized void initiate ( ) throws IOException { </a> 0
<a> getResponse ( ) . setHeader ( "Cache-Control" , "no-cache" ) ; </a> 0
<a> getResponse ( ) . setCharacterEncoding ( "UTF-8" ) ; </a> 0
<a> OutputStream outputStream = getResponse ( ) . getOutputStream ( ) ; </a> 0
<a> outputStream = getOutputStream ( outputStream ) ; </a> 0
<a> String acceptEncoding = getRequest ( ) . getHeader ( "Accept-Encoding" ) ; </a> 0
<a> if ( acceptEncoding != null && acceptEncoding . contains ( "deflate" ) ) { </a> 0
<a> getResponse ( ) . setHeader ( "Content-Encoding" , "deflate" ) ; </a> 0
<a> outputStream = new DeflaterOutputStream ( outputStream ) ; </a> 0
<a> } </a> 0
<a> writer = new OutputStreamWriter ( outputStream , "UTF-8" ) ; </a> 0
<a> if ( logger . isTraceEnabled ( ) ) { </a> 0
<a> logger . trace ( "Initiated [" + connectionID + "]" ) ; </a> 0
<a> } </a> 0
<a> getRequest ( ) . setAttribute ( "connectionID" , connectionID ) ; </a> 0
<a> scheduleHeartbeat ( ) ; </a> 0
<a> } </a> 0
<a> public void suspend ( ) throws IOException { </a> 0
<a> try { </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( terminated ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( logger . isTraceEnabled ( ) ) { </a> 0
<a> logger . trace ( "Suspending [" + connectionID + "]" ) ; </a> 0
<a> } </a> 0
<a> doSuspend ( ) ; </a> 0
<a> flush ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . error ( "Error suspending response" , e ) ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> setTerminated ( false ) ; </a> 0
<a> } </a> 0
<a> throw e ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized void terminate ( ) throws IOException { </a> 0
<a> if ( ! terminated ) { </a> 0
<a> try { </a> 0
<a> doTerminate ( ) ; </a> 0
<a> flush ( ) ; </a> 0
<a> } finally { </a> 0
<a> setTerminated ( true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void tryTerminate ( ) { </a> 0
<a> try { </a> 0
<a> terminate ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . error ( "Error terminating response" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( Serializable message ) throws IOException { </a> 0
<a> write ( Collections . singletonList ( message ) , true ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( Serializable message , boolean flush ) throws IOException { </a> 0
<a> write ( Collections . singletonList ( message ) , flush ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( List < ? extends Serializable > messages ) throws IOException { </a> 0
<a> write ( messages , true ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized void write ( List < ? extends Serializable > messages , boolean flush ) throws IOException { </a> 0
<a> if ( terminated ) { </a> 0
<a> throw new IOException ( "CometServletResponse terminated" ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> if ( messages . size ( ) == 1 && messages . get ( 0 ) instanceof String </a> 0
<a> && messages . get ( 0 ) . equals ( GwtAtmosphereResourceImpl . HEARTBEAT_MESSAGE ) ) { </a> 0
<a> heartbeat ( ) ; </a> 0
<a> } else { </a> 0
<a> if ( logger . isTraceEnabled ( ) ) { </a> 0
<a> logger . trace ( "Writing #" + messages . size ( ) + " messages to [" + connectionID + "]" ) ; </a> 0
<a> } </a> 0
<a> doWrite ( messages ) ; </a> 0
<a> if ( flush ) { </a> 0
<a> flush ( ) ; </a> 0
<a> } </a> 0
<a> scheduleHeartbeat ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> resource . resumeAfterDeath ( ) ; </a> 0
<a> setTerminated ( false ) ; </a> 0
<a> throw e ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized void heartbeat ( ) throws IOException { </a> 0
<a> if ( ! terminated ) { </a> 0
<a> try { </a> 0
<a> logger . trace ( "Sending heartbeat [" + connectionID + "]" ) ; </a> 0
<a> doHeartbeat ( ) ; </a> 0
<a> flush ( ) ; </a> 0
<a> scheduleHeartbeat ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . debug ( "Failed to send heartbeat" , e ) ; </a> 0
<a> setTerminated ( false ) ; </a> 0
<a> throw e ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> synchronized void flush ( ) throws IOException { </a> 0
<a> writer . flush ( ) ; </a> 0
<a> } </a> 0
<a> synchronized void setTerminated ( boolean serverInitiated ) { </a> 0
<a> if ( ! terminated ) { </a> 0
<a> terminated = true ; </a> 0
<a> if ( logger . isTraceEnabled ( ) ) { </a> 0
<a> logger . trace ( "Terminating [" + connectionID + "]" ) ; </a> 0
<a> } </a> 0
<a> if ( heartbeatFuture != null ) { </a> 0
<a> heartbeatFuture . cancel ( false ) ; </a> 0
<a> heartbeatFuture = null ; </a> 0
<a> } </a> 0
<a> if ( serverInitiated ) { </a> 0
<a> try { </a> 0
<a> if ( writer != null ) { </a> 0
<a> writer . close ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . error ( "Error closing connection" , e ) ; </a> 0
<a> } </a> 0
<a> resource . terminate ( serverInitiated ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public long getLastWriteTime ( ) { </a> 0
<a> return lastWriteTime ; </a> 0
<a> } </a> 0
<a> protected abstract void doSendError ( int statusCode , String message ) throws IOException ; </a> 0
<a> protected abstract void doSuspend ( ) throws IOException ; </a> 0
<a> protected abstract void doWrite ( List < ? extends Serializable > messages ) throws IOException ; </a> 0
<a> protected abstract void doHeartbeat ( ) throws IOException ; </a> 0
<a> protected abstract void doTerminate ( ) throws IOException ; </a> 0
<a> protected boolean hasSession ( ) { </a> 0
<a> HttpSession session = resource . getSession ( false ) ; </a> 0
<a> return session != null ; </a> 0
<a> } </a> 0
<a> protected String serialize ( Serializable message ) throws NotSerializableException , UnsupportedEncodingException { </a> 0
<a> try { </a> 0
<a> if ( clientOracle == null ) { </a> 0
<a> ServerSerializationStreamWriter streamWriter = new ServerSerializationStreamWriter ( serializationPolicy ) ; </a> 0
<a> streamWriter . prepareToWrite ( ) ; </a> 0
<a> streamWriter . writeObject ( message ) ; </a> 0
<a> return streamWriter . toString ( ) ; </a> 0
<a> } else { </a> 0
<a> ByteArrayOutputStream result = new ByteArrayOutputStream ( ) ; </a> 0
<a> RPC . streamResponseForSuccess ( clientOracle , result , message ) ; </a> 0
<a> return new String ( result . toByteArray ( ) , "UTF-8" ) ; </a> 0
<a> } </a> 0
<a> } catch ( SerializationException e ) { </a> 0
<a> throw new NotSerializableException ( "Unable to serialize object, message: " + e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final SerializationPolicy serializationPolicy ; </a> 0
<a> private final ClientOracle clientOracle ; </a> 0
<a> private boolean terminated ; </a> 0
<a> private volatile long lastWriteTime ; </a> 0
<a> private ScheduledFuture < ? > heartbeatFuture ; </a> 0
<a> private static AtomicInteger connectionIDs = new AtomicInteger ( 1 ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . impl ; </a> 0
<a> import com . google . gwt . rpc . server . ClientOracle ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> public class HTTPRequestResponseWriter extends StreamingProtocolResponseWriter { </a> 0
<a> public HTTPRequestResponseWriter ( GwtAtmosphereResourceImpl resource , SerializationPolicy serializationPolicy , ClientOracle clientOracle ) { </a> 0
<a> super ( resource , serializationPolicy , clientOracle ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int getPaddingRequired ( ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> String getContentType ( ) { </a> 0
<a> return "application/comet" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . impl ; </a> 0
<a> import com . google . gwt . rpc . server . ClientOracle ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> public class IEHTMLFileResponseWriter extends IFrameResponseWriter { </a> 0
<a> public IEHTMLFileResponseWriter ( GwtAtmosphereResourceImpl resource , SerializationPolicy serializationPolicy , ClientOracle clientOracle ) { </a> 0
<a> super ( resource , serializationPolicy , clientOracle ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . impl ; </a> 0
<a> import com . google . gwt . rpc . server . ClientOracle ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> public class IEXDomainRequestResponseWriter extends StreamingProtocolResponseWriter { </a> 0
<a> public IEXDomainRequestResponseWriter ( GwtAtmosphereResourceImpl resource , SerializationPolicy serializationPolicy , ClientOracle clientOracle ) { </a> 0
<a> super ( resource , serializationPolicy , clientOracle ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int getPaddingRequired ( ) { </a> 0
<a> return 2048 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> String getContentType ( ) { </a> 0
<a> return "application/comet" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . impl ; </a> 0
<a> import com . google . gwt . rpc . server . ClientOracle ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> abstract public class ManagedStreamResponseWriter extends GwtResponseWriterImpl { </a> 0
<a> private CountOutputStream countOutputStream ; </a> 0
<a> private boolean refresh ; </a> 0
<a> protected Integer length ; </a> 0
<a> protected final boolean chrome ; </a> 0
<a> public ManagedStreamResponseWriter ( GwtAtmosphereResourceImpl resource , SerializationPolicy serializationPolicy , ClientOracle clientOracle ) { </a> 0
<a> super ( resource , serializationPolicy , clientOracle ) ; </a> 0
<a> String userAgent = resource . getAtmosphereResource ( ) . getRequest ( ) . getHeader ( "User-Agent" ) ; </a> 0
<a> chrome = userAgent != null && userAgent . contains ( "Chrome" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected OutputStream getOutputStream ( OutputStream outputStream ) { </a> 0
<a> countOutputStream = new CountOutputStream ( outputStream ) ; </a> 0
<a> return countOutputStream ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doSuspend ( ) throws IOException { </a> 0
<a> int paddingRequired ; </a> 0
<a> String paddingParameter = getRequest ( ) . getParameter ( "padding" ) ; </a> 0
<a> if ( paddingParameter != null ) { </a> 0
<a> paddingRequired = Integer . parseInt ( paddingParameter ) ; </a> 0
<a> } else { </a> 0
<a> paddingRequired = getPaddingRequired ( ) ; </a> 0
<a> } </a> 0
<a> String lengthParameter = getRequest ( ) . getParameter ( "length" ) ; </a> 0
<a> if ( lengthParameter != null ) { </a> 0
<a> length = Integer . parseInt ( lengthParameter ) ; </a> 0
<a> } </a> 0
<a> if ( paddingRequired > 0 ) { </a> 0
<a> countOutputStream . setIgnoreFlush ( true ) ; </a> 0
<a> writer . flush ( ) ; </a> 0
<a> int written = countOutputStream . getCount ( ) ; </a> 0
<a> if ( paddingRequired > written ) { </a> 0
<a> CharSequence padding = getPadding ( paddingRequired - written ) ; </a> 0
<a> if ( padding != null ) { </a> 0
<a> writer . append ( padding ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> countOutputStream . setIgnoreFlush ( false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized void write ( List < ? extends Serializable > messages , boolean flush ) throws IOException { </a> 0
<a> super . write ( messages , flush ) ; </a> 0
<a> checkLength ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized void heartbeat ( ) throws IOException { </a> 0
<a> super . heartbeat ( ) ; </a> 0
<a> checkLength ( ) ; </a> 0
<a> } </a> 0
<a> private void checkLength ( ) throws IOException { </a> 0
<a> int count = countOutputStream . getCount ( ) ; </a> 0
<a> if ( chrome ) { </a> 0
<a> count = 2 * count ; </a> 0
<a> } </a> 0
<a> if ( ! refresh && isOverRefreshLength ( count ) ) { </a> 0
<a> refresh = true ; </a> 0
<a> doRefresh ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected abstract void doRefresh ( ) throws IOException ; </a> 0
<a> protected abstract int getPaddingRequired ( ) ; </a> 0
<a> protected abstract CharSequence getPadding ( int padding ) ; </a> 0
<a> protected abstract boolean isOverRefreshLength ( int written ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . impl ; </a> 0
<a> import com . google . gwt . rpc . server . ClientOracle ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class OperaEventSourceResponseWriter extends GwtResponseWriterImpl { </a> 0
<a> public OperaEventSourceResponseWriter ( GwtAtmosphereResourceImpl resource , SerializationPolicy serializationPolicy , ClientOracle clientOracle ) { </a> 0
<a> super ( resource , serializationPolicy , clientOracle ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void initiate ( ) throws IOException { </a> 0
<a> getResponse ( ) . setContentType ( "application/x-dom-event-stream" ) ; </a> 0
<a> super . initiate ( ) ; </a> 0
<a> writer . append ( "Event: c\ndata: c" ) </a> 0
<a> . append ( String . valueOf ( resource . getHeartBeatInterval ( ) ) ) . append ( ':' ) </a> 0
<a> . append ( String . valueOf ( connectionID ) ) . append ( "\n\n" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doSendError ( int statusCode , String message ) throws IOException { </a> 0
<a> getResponse ( ) . setContentType ( "application/x-dom-event-stream" ) ; </a> 0
<a> writer . append ( "Event: c\ndata: e" ) . append ( String . valueOf ( statusCode ) ) ; </a> 0
<a> if ( message != null ) { </a> 0
<a> writer . append ( ' ' ) . append ( HTTPRequestResponseWriter . escape ( message ) ) ; </a> 0
<a> } </a> 0
<a> writer . append ( "\n\n" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doSuspend ( ) throws IOException { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doWrite ( List < ? extends Serializable > messages ) throws IOException { </a> 0
<a> for ( Serializable message : messages ) { </a> 0
<a> CharSequence string ; </a> 0
<a> char event ; </a> 0
<a> if ( message instanceof CharSequence ) { </a> 0
<a> string = HTTPRequestResponseWriter . escape ( ( CharSequence ) message ) ; </a> 1
<a> event = 's' ; </a> 0
<a> } else { </a> 0
<a> string = serialize ( message ) ; </a> 0
<a> event = 'o' ; </a> 0
<a> } </a> 0
<a> writer . append ( "Event: " ) . append ( event ) . append ( '\n' ) ; </a> 0
<a> writer . append ( "data: " ) . append ( string ) . append ( "\n\n" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doHeartbeat ( ) throws IOException { </a> 0
<a> writer . append ( "Event: c\ndata: h\n\n" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void doTerminate ( ) throws IOException { </a> 0
<a> writer . append ( "Event: c\ndata: d\n\n" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . impl ; </a> 0
<a> import com . google . gwt . rpc . server . ClientOracle ; </a> 0
<a> import com . google . gwt . rpc . server . HostedModeClientOracle ; </a> 0
<a> import com . google . gwt . rpc . server . WebModeClientOracle ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> import org . atmosphere . gwt . shared . Constants ; </a> 1
<a> import javax . servlet . ServletContext ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . lang . ref . SoftReference ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> import java . net . URL ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class RPCUtil { </a> 0
<a> protected static final String CLIENT_ORACLE_EXTENSION = ".gwt.rpc" ; </a> 0
<a> public static SerializationPolicy createSimpleSerializationPolicy ( ) { </a> 0
<a> if ( policy != null ) { </a> 0
<a> return policy ; </a> 0
<a> } </a> 0
<a> policy = new SerializationPolicy ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean shouldDeserializeFields ( final Class < ? > clazz ) { </a> 0
<a> return Object . class != clazz ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean shouldSerializeFields ( final Class < ? > clazz ) { </a> 0
<a> return Object . class != clazz ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void validateDeserialize ( final Class < ? > clazz ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void validateSerialize ( final Class < ? > clazz ) { </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> return policy ; </a> 0
<a> } </a> 0
<a> protected static ClientOracle getClientOracle ( HttpServletRequest request , ServletContext context ) throws IOException { </a> 0
<a> String permutationStrongName = request . getParameter ( Constants . STRONG_NAME_PARAMETER ) ; </a> 0
<a> if ( permutationStrongName == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> ClientOracle toReturn ; </a> 0
<a> synchronized ( clientOracleCache ) { </a> 0
<a> if ( clientOracleCache . containsKey ( permutationStrongName ) ) { </a> 0
<a> toReturn = clientOracleCache . get ( permutationStrongName ) . get ( ) ; </a> 0
<a> if ( toReturn != null ) { </a> 0
<a> return toReturn ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( "HostedMode" . equals ( permutationStrongName ) ) { </a> 0
<a> toReturn = new HostedModeClientOracle ( ) ; </a> 0
<a> } else { </a> 0
<a> String moduleBase = request . getParameter ( Constants . MODULE_BASE_PARAMETER ) ; </a> 0
<a> if ( moduleBase == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> String basePath = new URL ( moduleBase ) . getPath ( ) ; </a> 0
<a> if ( basePath == null ) { </a> 0
<a> throw new MalformedURLException ( "Blocked request without GWT base path parameter (XSRF attack?)" ) ; </a> 0
<a> } </a> 0
<a> String contextPath = context . getContextPath ( ) ; </a> 0
<a> if ( ! basePath . startsWith ( contextPath ) ) { </a> 0
<a> throw new MalformedURLException ( "Blocked request with invalid GWT base path parameter (XSRF attack?)" ) ; </a> 0
<a> } </a> 0
<a> basePath = basePath . substring ( contextPath . length ( ) ) ; </a> 0
<a> InputStream in = findClientOracleData ( basePath , permutationStrongName , context ) ; </a> 0
<a> toReturn = WebModeClientOracle . load ( in ) ; </a> 0
<a> } </a> 0
<a> clientOracleCache . put ( permutationStrongName , new SoftReference < ClientOracle > ( toReturn ) ) ; </a> 0
<a> } </a> 0
<a> return toReturn ; </a> 0
<a> } </a> 0
<a> private static InputStream findClientOracleData ( String requestModuleBasePath , String permutationStrongName </a> 0
<a> , ServletContext context ) throws IOException { </a> 0
<a> String resourcePath = requestModuleBasePath + permutationStrongName + CLIENT_ORACLE_EXTENSION ; </a> 0
<a> InputStream in = context . getResourceAsStream ( resourcePath ) ; </a> 0
<a> if ( in == null ) { </a> 0
<a> throw new IOException ( "Could not find ClientOracle data for permutation " + permutationStrongName ) ; </a> 0
<a> } </a> 0
<a> return in ; </a> 0
<a> } </a> 0
<a> private static final Map < String , SoftReference < ClientOracle > > clientOracleCache = new HashMap < String , SoftReference < ClientOracle > > ( ) ; </a> 0
<a> private static SerializationPolicy policy ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . impl ; </a> 0
<a> import com . google . gwt . rpc . server . ClientOracle ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> abstract public class StreamingProtocolResponseWriter extends ManagedStreamResponseWriter { </a> 0
<a> private static final int MAX_PADDING_REQUIRED = 2048 ; </a> 0
<a> private static final String PADDING_STRING ; </a> 0
<a> static { </a> 0
<a> char [ ] padding = new char [ MAX_PADDING_REQUIRED + 1 ] ; </a> 0
<a> for ( int i = 0 ; i < padding . length - 1 ; i ++ ) { </a> 0
<a> padding [ i ] = '*' ; </a> 0
<a> } </a> 0
<a> padding [ padding . length - 1 ] = '\n' ; </a> 0
<a> PADDING_STRING = new String ( padding ) ; </a> 0
<a> } </a> 0
<a> public StreamingProtocolResponseWriter ( GwtAtmosphereResourceImpl resource , SerializationPolicy serializationPolicy , ClientOracle clientOracle ) { </a> 0
<a> super ( resource , serializationPolicy , clientOracle ) ; </a> 0
<a> } </a> 0
<a> abstract String getContentType ( ) ; </a> 0
<a> @ Override </a> 0
<a> public void initiate ( ) throws IOException { </a> 0
<a> getResponse ( ) . setContentType ( getContentType ( ) ) ; </a> 0
<a> String origin = getRequest ( ) . getHeader ( "Origin" ) ; </a> 0
<a> if ( origin != null ) { </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( "Origin: " + origin ) ; </a> 0
<a> } </a> 0
<a> getResponse ( ) . setHeader ( "Access-Control-Allow-Origin" , origin ) ; </a> 0
<a> } </a> 0
<a> super . initiate ( ) ; </a> 0
<a> writer . append ( '!' ) . append ( String . valueOf ( resource . getHeartBeatInterval ( ) ) ) . append ( ':' ) ; </a> 0
<a> writer . append ( String . valueOf ( connectionID ) ) . append ( '\n' ) ; </a> 0
<a> } </a> 0
<a> static CharSequence escape ( CharSequence string ) { </a> 0
<a> int length = ( string != null ) ? string . length ( ) : 0 ; </a> 0
<a> int i = 0 ; </a> 0
<a> loop : </a> 0
<a> while ( i < length ) { </a> 0
<a> char ch = string . charAt ( i ) ; </a> 0
<a> switch ( ch ) { </a> 0
<a> case '\\' : </a> 0
<a> case '\n' : </a> 0
<a> break loop ; </a> 0
<a> } </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> if ( i == length ) </a> 0
<a> return string ; </a> 0
<a> StringBuilder str = new StringBuilder ( string . length ( ) * 2 ) ; </a> 0
<a> str . append ( string , 0 , i ) ; </a> 0
<a> while ( i < length ) { </a> 0
<a> char ch = string . charAt ( i ) ; </a> 0
<a> switch ( ch ) { </a> 0
<a> case '\\' : </a> 0
<a> str . append ( "\\\\" ) ; </a> 0
<a> break ; </a> 0
<a> case '\n' : </a> 0
<a> str . append ( "\\n" ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> str . append ( ch ) ; </a> 0
<a> } </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> return str ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected CharSequence getPadding ( int padding ) { </a> 0
<a> if ( padding > PADDING_STRING . length ( ) - 1 ) { </a> 0
<a> StringBuilder result = new StringBuilder ( padding ) ; </a> 0
<a> while ( padding > 0 ) { </a> 0
<a> if ( padding > PADDING_STRING . length ( ) - 1 ) { </a> 0
<a> result . append ( PADDING_STRING ) ; </a> 0
<a> padding -= PADDING_STRING . length ( ) - 1 ; </a> 0
<a> } else { </a> 0
<a> result . append ( PADDING_STRING . substring ( PADDING_STRING . length ( ) - 1 - padding ) ) ; </a> 0
<a> padding = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return result . toString ( ) ; </a> 0
<a> } else { </a> 0
<a> return PADDING_STRING . substring ( PADDING_STRING . length ( ) - padding - 1 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doSendError ( int statusCode , String message ) throws IOException { </a> 0
<a> getResponse ( ) . setStatus ( statusCode ) ; </a> 0
<a> if ( message != null ) { </a> 0
<a> writer . append ( message ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doWrite ( List < ? extends Serializable > messages ) throws IOException { </a> 0
<a> for ( Serializable message : messages ) { </a> 0
<a> CharSequence string ; </a> 0
<a> if ( message instanceof CharSequence ) { </a> 0
<a> string = escape ( ( CharSequence ) message ) ; </a> 1
<a> if ( string == message ) { </a> 0
<a> writer . append ( '|' ) ; </a> 0
<a> } else { </a> 0
<a> writer . append ( ']' ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> string = serialize ( message ) ; </a> 0
<a> } </a> 0
<a> writer . append ( string ) . append ( '\n' ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isOverRefreshLength ( int written ) { </a> 0
<a> if ( length != null ) { </a> 0
<a> return written > length ; </a> 0
<a> } else { </a> 0
<a> return written > 5 * 1024 * 1024 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doHeartbeat ( ) throws IOException { </a> 0
<a> writer . append ( "#\n" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doTerminate ( ) throws IOException { </a> 0
<a> writer . append ( "?\n" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doRefresh ( ) throws IOException { </a> 0
<a> writer . append ( "@\n" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . gwt . server . impl ; </a> 0
<a> import com . google . gwt . rpc . server . ClientOracle ; </a> 0
<a> import com . google . gwt . user . server . rpc . SerializationPolicy ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class WebsocketResponseWriter extends GwtResponseWriterImpl { </a> 0
<a> public WebsocketResponseWriter ( GwtAtmosphereResourceImpl resource , SerializationPolicy serializationPolicy , ClientOracle clientOracle ) { </a> 0
<a> super ( resource , serializationPolicy , clientOracle ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void initiate ( ) throws IOException { </a> 0
<a> super . initiate ( ) ; </a> 0
<a> writer . append ( "c\nc" ) </a> 0
<a> . append ( String . valueOf ( resource . getHeartBeatInterval ( ) ) ) . append ( ':' ) </a> 0
<a> . append ( String . valueOf ( connectionID ) ) . append ( "\n\n" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doSendError ( int statusCode , String message ) throws IOException { </a> 0
<a> writer . append ( "c\ne" ) . append ( String . valueOf ( statusCode ) ) ; </a> 0
<a> if ( message != null ) { </a> 0
<a> writer . append ( ' ' ) . append ( HTTPRequestResponseWriter . escape ( message ) ) ; </a> 0
<a> } </a> 0
<a> writer . append ( "\n\n" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doSuspend ( ) throws IOException { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doWrite ( List < ? extends Serializable > messages ) throws IOException { </a> 0
<a> for ( Serializable message : messages ) { </a> 0
<a> CharSequence string ; </a> 0
<a> char event ; </a> 0
<a> if ( message instanceof CharSequence ) { </a> 0
<a> string = HTTPRequestResponseWriter . escape ( ( CharSequence ) message ) ; </a> 0
<a> event = 's' ; </a> 0
<a> } else { </a> 0
<a> string = serialize ( message ) ; </a> 0
<a> event = 'o' ; </a> 0
<a> } </a> 0
<a> writer . append ( event ) . append ( '\n' ) ; </a> 0
<a> writer . append ( string ) . append ( "\n\n" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doHeartbeat ( ) throws IOException { </a> 0
<a> writer . append ( "c\nh\n\n" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void doTerminate ( ) throws IOException { </a> 0
<a> writer . append ( "c\nd\n\n" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( </a> 0
<a> { ElementType . METHOD , ElementType . FIELD , ElementType . CONSTRUCTOR , ElementType . TYPE } ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> public @ interface Export { </a> 0
<a> String value ( ) default "" ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( ElementType . TYPE ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> public @ interface ExportPackage { </a> 0
<a> String value ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> public interface Exportable { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> public interface Exporter { </a> 0
<a> @ Deprecated </a> 0
<a> void export ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> import com . google . gwt . core . client . GWT ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptObject ; </a> 0
<a> import com . google . gwt . core . client . JsArray ; </a> 0
<a> import com . google . gwt . core . client . JsArrayNumber ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . IdentityHashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class ExporterBaseActual extends ExporterBaseImpl { </a> 0
<a> public static final String WRAPPER_PROPERTY = "__gwtex_wrap" ; </a> 0
<a> private native static JavaScriptObject wrap0 ( Exportable type , </a> 0
<a> JavaScriptObject constructor , String wrapProp ) ; </a> 0
<a> private HashMap typeMap = new HashMap ( ) ; </a> 0
<a> private HashMap < Class , JavaScriptObject > dispatchMap </a> 0
<a> = new HashMap < Class , JavaScriptObject > ( ) ; </a> 0
<a> private HashMap < Class , JavaScriptObject > staticDispatchMap </a> 0
<a> = new HashMap < Class , JavaScriptObject > ( ) ; </a> 0
<a> private IdentityHashMap < Object , JavaScriptObject > wrapperMap = null ; </a> 0
<a> public ExporterBaseActual ( ) { </a> 0
<a> if ( ! GWT . isScript ( ) ) { </a> 0
<a> wrapperMap = new IdentityHashMap < Object , JavaScriptObject > ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void addTypeMap ( Exportable type , </a> 0
<a> JavaScriptObject exportedConstructor ) { </a> 0
<a> addTypeMap ( type . getClass ( ) , exportedConstructor ) ; </a> 0
<a> } </a> 0
<a> public void addTypeMap ( Class type , JavaScriptObject exportedConstructor ) { </a> 0
<a> typeMap . put ( type , exportedConstructor ) ; </a> 0
<a> } </a> 0
<a> public void setWrapper ( Object instance , JavaScriptObject wrapper ) { </a> 0
<a> if ( GWT . isScript ( ) ) { </a> 0
<a> setWrapperJS ( instance , wrapper , WRAPPER_PROPERTY ) ; </a> 0
<a> } else { </a> 0
<a> setWrapperHosted ( instance , wrapper ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public JavaScriptObject typeConstructor ( Exportable type ) { </a> 0
<a> return typeConstructor ( type . getClass ( ) ) ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject typeConstructor ( Class type ) { </a> 0
<a> Object o = typeMap . get ( type ) ; </a> 0
<a> return ( JavaScriptObject ) o ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject wrap ( Exportable type ) { </a> 0
<a> if ( type == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( ! GWT . isScript ( ) ) { </a> 0
<a> JavaScriptObject wrapper = wrapperMap . get ( type ) ; </a> 0
<a> if ( wrapper != null ) { </a> 0
<a> return wrapper ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> JavaScriptObject wrapper = getWrapperJS ( type , WRAPPER_PROPERTY ) ; </a> 0
<a> if ( wrapper != null ) { </a> 0
<a> return wrapper ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> JavaScriptObject wrapper = wrap0 ( type , typeConstructor ( type ) , </a> 0
<a> WRAPPER_PROPERTY ) ; </a> 0
<a> setWrapper ( type , wrapper ) ; </a> 0
<a> return wrapper ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject wrap ( Exportable [ ] type ) { </a> 0
<a> if ( type == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> JavaScriptObject wrapper = getWrapper ( type ) ; </a> 0
<a> JsArray < JavaScriptObject > wrapperArray = wrapper . cast ( ) ; </a> 0
<a> for ( int i = 0 ; i < type . length ; i ++ ) { </a> 0
<a> wrapperArray . set ( i , wrap ( type [ i ] ) ) ; </a> 0
<a> } </a> 0
<a> return wrapper ; </a> 0
<a> } </a> 0
<a> private JavaScriptObject getWrapper ( Object type ) { </a> 0
<a> JavaScriptObject wrapper = null ; </a> 0
<a> if ( ! GWT . isScript ( ) ) { </a> 0
<a> wrapper = wrapperMap . get ( type ) ; </a> 0
<a> } else { </a> 0
<a> wrapper = getWrapperJS ( type , WRAPPER_PROPERTY ) ; </a> 0
<a> } </a> 0
<a> if ( wrapper == null ) { </a> 0
<a> wrapper = JavaScriptObject . createArray ( ) ; </a> 0
<a> setWrapper ( type , wrapper ) ; </a> 0
<a> } </a> 0
<a> return wrapper ; </a> 0
<a> } </a> 0
<a> private static native JavaScriptObject reinterpretCast ( Object nl ) ; </a> 0
<a> @ Override </a> 0
<a> public JavaScriptObject wrap ( float [ ] type ) { </a> 0
<a> if ( ! GWT . isScript ( ) ) { </a> 0
<a> if ( type == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> JavaScriptObject wrapper = getWrapper ( type ) ; </a> 0
<a> JsArrayNumber wrapperArray = wrapper . cast ( ) ; </a> 0
<a> for ( int i = 0 ; i < type . length ; i ++ ) { </a> 0
<a> wrapperArray . set ( i , type [ i ] ) ; </a> 0
<a> } </a> 0
<a> return wrapper ; </a> 0
<a> } else { </a> 0
<a> return reinterpretCast ( type ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public JavaScriptObject wrap ( byte [ ] type ) { </a> 0
<a> if ( ! GWT . isScript ( ) ) { </a> 0
<a> if ( type == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> JavaScriptObject wrapper = getWrapper ( type ) ; </a> 0
<a> JsArrayNumber wrapperArray = wrapper . cast ( ) ; </a> 0
<a> for ( int i = 0 ; i < type . length ; i ++ ) { </a> 0
<a> wrapperArray . set ( i , type [ i ] ) ; </a> 0
<a> } </a> 0
<a> return wrapper ; </a> 0
<a> } else { </a> 0
<a> return reinterpretCast ( type ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public JavaScriptObject wrap ( char [ ] type ) { </a> 0
<a> if ( ! GWT . isScript ( ) ) { </a> 0
<a> if ( type == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> JavaScriptObject wrapper = getWrapper ( type ) ; </a> 0
<a> JsArrayNumber wrapperArray = wrapper . cast ( ) ; </a> 0
<a> for ( int i = 0 ; i < type . length ; i ++ ) { </a> 0
<a> wrapperArray . set ( i , type [ i ] ) ; </a> 0
<a> } </a> 0
<a> return wrapper ; </a> 0
<a> } else { </a> 0
<a> return reinterpretCast ( type ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public JavaScriptObject wrap ( int [ ] type ) { </a> 0
<a> if ( ! GWT . isScript ( ) ) { </a> 0
<a> if ( type == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> JavaScriptObject wrapper = getWrapper ( type ) ; </a> 0
<a> JsArrayNumber wrapperArray = wrapper . cast ( ) ; </a> 0
<a> for ( int i = 0 ; i < type . length ; i ++ ) { </a> 0
<a> wrapperArray . set ( i , type [ i ] ) ; </a> 0
<a> } </a> 0
<a> return wrapper ; </a> 0
<a> } else { </a> 0
<a> return reinterpretCast ( type ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public JavaScriptObject wrap ( long [ ] type ) { </a> 0
<a> if ( ! GWT . isScript ( ) ) { </a> 0
<a> if ( type == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> JavaScriptObject wrapper = getWrapper ( type ) ; </a> 0
<a> JsArrayNumber wrapperArray = wrapper . cast ( ) ; </a> 0
<a> for ( int i = 0 ; i < type . length ; i ++ ) { </a> 0
<a> wrapperArray . set ( i , type [ i ] ) ; </a> 0
<a> } </a> 0
<a> return wrapper ; </a> 0
<a> } else { </a> 0
<a> return reinterpretCast ( type ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public JavaScriptObject wrap ( short [ ] type ) { </a> 0
<a> if ( ! GWT . isScript ( ) ) { </a> 0
<a> if ( type == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> JavaScriptObject wrapper = getWrapper ( type ) ; </a> 0
<a> JsArrayNumber wrapperArray = wrapper . cast ( ) ; </a> 0
<a> for ( int i = 0 ; i < type . length ; i ++ ) { </a> 0
<a> wrapperArray . set ( i , type [ i ] ) ; </a> 0
<a> } </a> 0
<a> return wrapper ; </a> 0
<a> } else { </a> 0
<a> return reinterpretCast ( type ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public JavaScriptObject wrap ( double [ ] type ) { </a> 0
<a> if ( ! GWT . isScript ( ) ) { </a> 0
<a> if ( type == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> JavaScriptObject wrapper = getWrapper ( type ) ; </a> 0
<a> JsArrayNumber wrapperArray = wrapper . cast ( ) ; </a> 0
<a> for ( int i = 0 ; i < type . length ; i ++ ) { </a> 0
<a> wrapperArray . set ( i , type [ i ] ) ; </a> 0
<a> } </a> 0
<a> return wrapper ; </a> 0
<a> } else { </a> 0
<a> return reinterpretCast ( type ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private native JavaScriptObject getWrapperJS ( Object type , String wrapProp ) ; </a> 0
<a> private void setWrapperHosted ( Object instance , JavaScriptObject wrapper ) { </a> 0
<a> wrapperMap . put ( instance , wrapper ) ; </a> 0
<a> } </a> 0
<a> private native void setWrapperJS ( Object instance , JavaScriptObject wrapper , </a> 0
<a> String wrapperProperty ) ; </a> 0
<a> private native void declarePackage0 ( JavaScriptObject prefix , String pkg ) ; </a> 0
<a> @ Override </a> 0
<a> public void declarePackage ( String packageName , </a> 0
<a> String enclosingClassesString ) { </a> 0
<a> String superPackages [ ] = packageName . split ( "\\." ) ; </a> 0
<a> JavaScriptObject prefix = getWindow ( ) ; </a> 0
<a> for ( int i = 0 ; i < superPackages . length ; i ++ ) { </a> 0
<a> if ( ! superPackages [ i ] . equals ( "client" ) ) { </a> 0
<a> declarePackage0 ( prefix , superPackages [ i ] ) ; </a> 0
<a> prefix = getProp ( prefix , superPackages [ i ] ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> String enclosingClasses [ ] = enclosingClassesString . split ( "\\." ) ; </a> 0
<a> for ( String enclosingName : enclosingClasses ) { </a> 0
<a> if ( ! enclosingName . trim ( ) . equals ( "" ) ) { </a> 0
<a> declarePackage0 ( prefix , enclosingName ) ; </a> 0
<a> prefix = getProp ( prefix , enclosingName ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static native JavaScriptObject getWindow ( ) ; </a> 0
<a> private static native JavaScriptObject getProp ( JavaScriptObject jso , </a> 0
<a> String key ) ; </a> 0
<a> @ Override </a> 0
<a> public JavaScriptObject getDispatch ( Class clazz , String meth , </a> 0
<a> JsArray < JavaScriptObject > arguments , boolean isStatic ) { </a> 0
<a> Map < Class , JavaScriptObject > dmap = isStatic ? staticDispatchMap </a> 0
<a> : dispatchMap ; </a> 0
<a> JsArray < SignatureJSO > sigs = getSigs ( dmap . get ( clazz ) . cast ( ) , meth , </a> 0
<a> arguments . length ( ) ) ; </a> 0
<a> for ( int i = 0 ; i < sigs . length ( ) ; i ++ ) { </a> 0
<a> SignatureJSO sig = sigs . get ( i ) ; </a> 0
<a> if ( sig . matches ( arguments ) ) { </a> 0
<a> JavaScriptObject javaFunc = sig . getFunction ( ) ; </a> 0
<a> if ( ! GWT . isScript ( ) ) { </a> 0
<a> JavaScriptObject wrapFunc = sig . getWrapperFunc ( ) ; </a> 0
<a> return wrapFunc != null ? wrapFunction ( wrapFunc , javaFunc ) : javaFunc ; </a> 0
<a> } else { </a> 0
<a> return javaFunc ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> throw new RuntimeException ( </a> 0
<a> "Can't find exported method for given arguments" ) ; </a> 0
<a> } </a> 0
<a> private native static JavaScriptObject wrapFunction ( JavaScriptObject wrapFunc , </a> 0
<a> JavaScriptObject javaFunc ) ; </a> 0
<a> private native JsArray < SignatureJSO > getSigs ( JavaScriptObject jsoMap , </a> 0
<a> String meth , int arity ) ; </a> 0
<a> @ Override </a> 0
<a> public void registerDispatchMap ( Class clazz , JavaScriptObject dispMap , </a> 0
<a> boolean isStatic ) { </a> 0
<a> if ( isStatic ) { </a> 0
<a> staticDispatchMap . put ( clazz , dispMap ) ; </a> 0
<a> } else { </a> 0
<a> dispatchMap . put ( clazz , dispMap ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> final public static class SignatureJSO extends JavaScriptObject { </a> 0
<a> protected SignatureJSO ( ) { </a> 0
<a> } </a> 0
<a> public boolean matches ( JsArray < JavaScriptObject > arguments ) { </a> 0
<a> for ( int i = 0 ; i < arguments . length ( ) ; i ++ ) { </a> 0
<a> Object jsType = getObject ( i + 2 ) ; </a> 0
<a> String argJsType = typeof ( arguments , i ) ; </a> 0
<a> if ( argJsType . equals ( "object" ) ) { </a> 0
<a> Object gwtObject = getJavaObject ( arguments , i ) ; </a> 0
<a> if ( gwtObject != null ) { </a> 0
<a> if ( ! gwtObject . getClass ( ) . equals ( jsType ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } else if ( ! jsType . equals ( "object" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } else if ( ! jsType . equals ( argJsType ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public native Object getJavaObject ( JavaScriptObject args , int i ) ; </a> 0
<a> public native static String typeof ( JavaScriptObject args , int i ) ; </a> 0
<a> public native Object getObject ( int i ) ; </a> 0
<a> public native JavaScriptObject getFunction ( ) ; </a> 0
<a> public native JavaScriptObject getWrapperFunc ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> import com . google . gwt . core . client . JavaScriptObject ; </a> 0
<a> import com . google . gwt . core . client . JsArray ; </a> 0
<a> public class ExporterBaseImpl { </a> 0
<a> public void addTypeMap ( Exportable type , </a> 0
<a> JavaScriptObject exportedConstructor ) { </a> 0
<a> } </a> 0
<a> public void addTypeMap ( Class type , JavaScriptObject exportedConstructor ) { </a> 0
<a> } </a> 0
<a> public void setWrapper ( Object instance , JavaScriptObject wrapper ) { </a> 0
<a> } </a> 0
<a> public JavaScriptObject typeConstructor ( Exportable type ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject typeConstructor ( String type ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject wrap ( Exportable type ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject wrap ( Exportable [ ] type ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject wrap ( double [ ] type ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject wrap ( float [ ] type ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject wrap ( int [ ] type ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject wrap ( char [ ] type ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject wrap ( byte [ ] type ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject wrap ( long [ ] type ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public JavaScriptObject wrap ( short [ ] type ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public void declarePackage ( String packageName , String enclosingClasses ) { </a> 0
<a> } </a> 0
<a> public JavaScriptObject getDispatch ( Class clazz , String meth , </a> 0
<a> JsArray < JavaScriptObject > arguments , boolean isStatic ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public void registerDispatchMap ( Class clazz , JavaScriptObject dispMap , boolean isStatic ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( </a> 0
<a> { ElementType . METHOD , ElementType . FIELD } ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> public @ interface SOptional { </a> 0
<a> public abstract boolean value ( ) default false ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( </a> 0
<a> { ElementType . METHOD , ElementType . FIELD } ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> public @ interface SType { </a> 0
<a> public abstract String value ( ) default "" ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . client ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( ElementType . TYPE ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> public @ interface StructuralType { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . doclet ; </a> 0
<a> public class JsDoclet { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . GeneratorContext ; </a> 0
<a> import com . google . gwt . core . ext . TreeLogger ; </a> 0
<a> import com . google . gwt . core . ext . UnableToCompleteException ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JClassType ; </a> 0
<a> import com . google . gwt . user . rebind . ClassSourceFileComposerFactory ; </a> 0
<a> import com . google . gwt . user . rebind . SourceWriter ; </a> 0
<a> import java . io . PrintWriter ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . HashSet ; </a> 0
<a> public class ClassExporter { </a> 0
<a> private TreeLogger logger ; </a> 0
<a> private GeneratorContext ctx ; </a> 0
<a> private ExportableTypeOracle xTypeOracle ; </a> 0
<a> private SourceWriter sw ; </a> 0
<a> private ArrayList < JExportableClassType > exported ; </a> 0
<a> private HashSet < String > visited ; </a> 0
<a> private static final String ARG_PREFIX = "arg" ; </a> 0
<a> public ClassExporter ( TreeLogger logger , GeneratorContext ctx ) { </a> 0
<a> this ( logger , ctx , new HashSet < String > ( ) ) ; </a> 0
<a> } </a> 0
<a> public ClassExporter ( TreeLogger logger , GeneratorContext ctx , </a> 0
<a> HashSet < String > visited ) { </a> 0
<a> this . logger = logger ; </a> 0
<a> this . ctx = ctx ; </a> 0
<a> xTypeOracle = new ExportableTypeOracle ( ctx . getTypeOracle ( ) , logger ) ; </a> 0
<a> this . visited = visited ; </a> 0
<a> exported = new ArrayList < JExportableClassType > ( ) ; </a> 0
<a> } </a> 0
<a> public void exportClosure ( JExportableClassType requestedType ) </a> 0
<a> throws UnableToCompleteException { </a> 0
<a> if ( requestedType == null ) { </a> 0
<a> logger . log ( TreeLogger . ERROR , </a> 0
<a> "Type '" + requestedType . getQualifiedSourceName ( ) </a> 0
<a> + "' does not implement Exportable" , null ) ; </a> 0
<a> throw new UnableToCompleteException ( ) ; </a> 0
<a> } </a> 0
<a> String genName = requestedType . getExporterImplementationName ( ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . println ( "private " + ExportableTypeOracle . JSO_CLASS + " jso;" ) ; </a> 0
<a> sw . println ( ) ; </a> 0
<a> sw . println ( "public " + genName + "() { export(); }" ) ; </a> 0
<a> sw . println ( </a> 0
<a> "public " + genName + "(" + ExportableTypeOracle . JSO_CLASS + " jso) {" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . println ( "this.jso = jso;" ) ; </a> 0
<a> if ( requestedType . isStructuralType ( ) ) { </a> 0
<a> sw . println ( "___importStructuralType();" ) ; </a> 0
<a> } </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> sw . println ( ) ; </a> 0
<a> sw . println ( "public static " + genName + " makeClosure(" </a> 0
<a> + ExportableTypeOracle . JSO_CLASS + " closure) {" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . println ( "return new " + genName + "(closure);" ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> sw . println ( ) ; </a> 0
<a> JExportableMethod [ ] methods = requestedType . getExportableMethods ( ) ; </a> 0
<a> if ( methods . length != 1 ) { </a> 0
<a> logger . log ( TreeLogger . ERROR , </a> 0
<a> "Interface " + requestedType . getQualifiedSourceName ( ) </a> 0
<a> + " has more than one " </a> 0
<a> + "declared method. @gwt.exportClosure only currently works for " </a> 0
<a> + "single method interfaces." , null ) ; </a> 0
<a> throw new UnableToCompleteException ( ) ; </a> 0
<a> } </a> 0
<a> JExportableMethod method = methods [ 0 ] ; </a> 0
<a> JExportableType retType = method . getExportableReturnType ( ) ; </a> 0
<a> if ( retType == null ) { </a> 0
<a> logger . log ( TreeLogger . ERROR , </a> 0
<a> "Return type of method " + method + " is not exportable." , null ) ; </a> 0
<a> throw new UnableToCompleteException ( ) ; </a> 0
<a> } </a> 0
<a> if ( retType . needsExport ( ) && ! exported </a> 0
<a> . contains ( retType . getQualifiedSourceName ( ) ) ) { </a> 0
<a> if ( exportDependentClass ( retType . getQualifiedSourceName ( ) ) ) { </a> 0
<a> exported . add ( ( JExportableClassType ) retType ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> exportDependentParams ( method ) ; </a> 0
<a> boolean isVoid = retType . getQualifiedSourceName ( ) . equals ( "void" ) ; </a> 0
<a> boolean noParams = method . getExportableParameters ( ) . length == 0 ; </a> 0
<a> sw . print ( </a> 0
<a> "public " + method . getExportableReturnType ( ) . getQualifiedSourceName ( ) ) ; </a> 0
<a> sw . print ( " " + method . getName ( ) + "(" ) ; </a> 0
<a> declareParameters ( method , - 1 , true ) ; </a> 0
<a> sw . println ( ") {" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . print ( ( isVoid ? "" : "return " ) + "invoke(jso" + ( noParams ? "" : "," ) ) ; </a> 0
<a> declareJavaPassedValues ( method , false ) ; </a> 0
<a> sw . println ( ");" ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> sw . println ( ) ; </a> 0
<a> sw . print ( "public native " + ( isVoid ? "void" </a> 0
<a> : method . getExportableReturnType ( ) . getQualifiedSourceName ( ) ) ) ; </a> 0
<a> sw . print ( " invoke(" + ExportableTypeOracle . JSO_CLASS + " closure" ) ; </a> 0
<a> if ( method . getExportableParameters ( ) . length > 0 ) { </a> 0
<a> sw . print ( ", " ) ; </a> 0
<a> } </a> 0
<a> declareParameters ( method , - 1 , true ) ; </a> 0
<a> sw . println ( ") /*-{" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . print ( ( ! isVoid ? "var result= " : "" ) + "closure(" ) ; </a> 0
<a> declareJavaPassedValues ( method , true ) ; </a> 0
<a> sw . println ( ");" ) ; </a> 0
<a> boolean isArray = retType instanceof JExportableArrayType ; </a> 0
<a> if ( retType . needsExport ( ) && ! isVoid && ! isArray ) { </a> 0
<a> sw . println ( "if(result != null && result != undefined) " </a> 0
<a> + "result=result.instance;" ) ; </a> 0
<a> sw . println ( "else if(result == undefined) result=null;" ) ; </a> 0
<a> } </a> 0
<a> if ( ! isVoid ) { </a> 0
<a> sw . println ( "return result;" ) ; </a> 0
<a> } </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}-*/;" ) ; </a> 0
<a> sw . println ( ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> } </a> 0
<a> public String exportClass ( String requestedClass , boolean export ) </a> 0
<a> throws UnableToCompleteException { </a> 0
<a> JExportableClassType requestedType = xTypeOracle </a> 0
<a> . findExportableClassType ( requestedClass ) ; </a> 0
<a> if ( requestedType == null ) { </a> 0
<a> logger . log ( TreeLogger . ERROR , </a> 0
<a> "Type '" + requestedClass + "' does not implement Exportable" , null ) ; </a> 0
<a> throw new UnableToCompleteException ( ) ; </a> 0
<a> } </a> 0
<a> exported . add ( requestedType ) ; </a> 0
<a> visited . add ( requestedType . getQualifiedSourceName ( ) ) ; </a> 0
<a> String genName = requestedType . getExporterImplementationName ( ) ; </a> 0
<a> String packageName = requestedType . getPackageName ( ) ; </a> 0
<a> String qualName = requestedType . getQualifiedExporterImplementationName ( ) ; </a> 0
<a> boolean isClosure = xTypeOracle . isClosure ( requestedClass ) ; </a> 0
<a> String superClass = xTypeOracle . isStructuralType ( requestedType . getType ( ) ) </a> 0
<a> ? requestedClass : null ; </a> 0
<a> if ( isClosure ) { </a> 0
<a> sw = getSourceWriter ( logger , ctx , packageName , genName , superClass , </a> 0
<a> "Exporter" , requestedType . getQualifiedSourceName ( ) ) ; </a> 0
<a> } else { </a> 0
<a> sw = getSourceWriter ( logger , ctx , packageName , genName , superClass , </a> 0
<a> "Exporter" ) ; </a> 0
<a> } </a> 0
<a> if ( sw == null ) { </a> 0
<a> return qualName ; </a> 0
<a> } </a> 0
<a> if ( export && xTypeOracle . isExportAll ( requestedClass ) ) { </a> 0
<a> exportAll ( genName ) ; </a> 0
<a> } else if ( export ) { </a> 0
<a> if ( isClosure ) { </a> 0
<a> exportClosure ( requestedType ) ; </a> 0
<a> } else if ( requestedType . isStructuralType ( ) ) { </a> 0
<a> exportStructuralTypeConstructor ( genName , requestedType ) ; </a> 0
<a> } </a> 0
<a> if ( requestedType . isStructuralType ( ) ) { </a> 0
<a> exportStructuralTypeImporter ( requestedType ) ; </a> 0
<a> exportStructuralTypeMatchMethod ( requestedType ) ; </a> 0
<a> } </a> 0
<a> sw . indent ( ) ; </a> 0
<a> if ( ! isClosure ) { </a> 0
<a> sw . println ( "public " + genName + "() { export(); }" ) ; </a> 0
<a> } </a> 0
<a> sw . println ( "public native void export0() /*-{" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> declarePackages ( requestedType ) ; </a> 0
<a> exportConstructor ( requestedType ) ; </a> 0
<a> exportFields ( requestedType ) ; </a> 0
<a> exportMethods ( requestedType ) ; </a> 0
<a> registerTypeMap ( requestedType ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}-*/;" ) ; </a> 0
<a> sw . println ( ) ; </a> 0
<a> if ( requestedType . isInstantiable ( ) ) { </a> 0
<a> exportStaticFactoryConstructors ( requestedType ) ; </a> 0
<a> } </a> 0
<a> if ( requestedType . isStructuralType ( ) ) { </a> 0
<a> exportStructuralTypeFields ( requestedType ) ; </a> 0
<a> } </a> 0
<a> genExportMethod ( requestedType , exported ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> } else { </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . println ( "public void export() {}" ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> } </a> 0
<a> sw . commit ( logger ) ; </a> 0
<a> return qualName ; </a> 0
<a> } </a> 0
<a> private void exportStructuralTypeMatchMethod ( </a> 0
<a> JExportableClassType requestedType ) throws UnableToCompleteException { </a> 0
<a> sw . println ( "public static native boolean ___match(JavaScriptObject jso) /*-{" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . print ( "return " ) ; </a> 0
<a> for ( JStructuralTypeField field : requestedType . getStructuralTypeFields ( ) ) { </a> 0
<a> JExportableType eType = field . getExportableType ( ) ; </a> 0
<a> if ( eType == null ) { </a> 0
<a> logger . log ( TreeLogger . ERROR , </a> 0
<a> "Structural type field " + field . getMethodName ( ) + " for class " </a> 0
<a> + requestedType . getQualifiedSourceName ( ) </a> 0
<a> + " is not exportable." ) ; </a> 0
<a> throw new UnableToCompleteException ( ) ; </a> 0
<a> } </a> 0
<a> if ( eType instanceof JExportableClassType ) { </a> 0
<a> JExportableClassType cType = ( JExportableClassType ) field </a> 0
<a> . getExportableType ( ) ; </a> 0
<a> if ( cType . needsExport ( ) && cType . isStructuralType ( ) ) { </a> 0
<a> sw . print ( "(jso." + field . getName ( ) + " && @" </a> 0
<a> + ( ( JExportableClassType ) eType ) </a> 0
<a> . getQualifiedExporterImplementationName ( ) </a> 0
<a> + "::___match(Lcom/google/gwt/core/client/JavaScriptObject;)(jso." </a> 0
<a> + field . getName ( ) + ") &&" ) ; </a> 0
<a> } else if ( cType . needsExport ( ) ) { </a> 0
<a> sw . print ( "(jso." + field . getName ( ) + " && jso." + field . getName ( ) </a> 0
<a> + ".__gwt__instance) && " ) ; </a> 0
<a> } else if ( ! cType . needsExport ( ) ) { </a> 0
<a> sw . print ( </a> 0
<a> "typeof(jso." + field . getName ( ) + ") == '" + eType . getJsTypeOf ( ) </a> 0
<a> + "' && " ) ; </a> 0
<a> } </a> 0
<a> } else if ( eType instanceof JExportablePrimitiveType ) { </a> 0
<a> sw . print ( </a> 0
<a> "typeof(jso." + field . getName ( ) + ") == '" + eType . getJsTypeOf ( ) </a> 0
<a> + "' && " ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> sw . println ( "true;" ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}-*/;" ) ; </a> 0
<a> } </a> 0
<a> private void exportStructuralTypeImporter ( </a> 0
<a> JExportableClassType requestedType ) { </a> 0
<a> sw . println ( "public void ___importStructuralType() {" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> for ( JStructuralTypeField field : requestedType . getStructuralTypeFields ( ) ) { </a> 0
<a> sw . println ( "super." + field . getMethodName ( ) + "((" + field . getFieldType ( ) </a> 0
<a> + ")org.timepedia.exporter.client.ExporterUtil.getStructuralField" </a> 0
<a> + field . getFieldLowestType ( ) + "(jso, \"" + field . getName ( ) </a> 0
<a> + "\"));" ) ; </a> 0
<a> } </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> } </a> 0
<a> private void exportStructuralTypeConstructor ( String genName , </a> 0
<a> JExportableClassType requestedType ) { </a> 0
<a> sw . println ( "private " + ExportableTypeOracle . JSO_CLASS + " jso;" ) ; </a> 0
<a> sw . println ( ) ; </a> 0
<a> sw . println ( </a> 0
<a> "public " + genName + "(" + ExportableTypeOracle . JSO_CLASS + " jso) {" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . println ( "this.jso = jso;" ) ; </a> 0
<a> if ( requestedType . isStructuralType ( ) ) { </a> 0
<a> sw . println ( "___importStructuralType();" ) ; </a> 0
<a> } </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> sw . println ( ) ; </a> 0
<a> } </a> 0
<a> private void exportStructuralTypeFields ( JExportableClassType requestedType ) { </a> 0
<a> for ( JStructuralTypeField field : requestedType . getStructuralTypeFields ( ) ) { </a> 0
<a> exportStructuralTypeField ( field ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void exportStructuralTypeField ( JStructuralTypeField field ) { </a> 0
<a> sw . println ( "public " + field . JavaDeclaration ( ) + "{" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> if ( field . isVoidReturn ( ) ) { </a> 0
<a> sw . println ( "super." + field . getMethodName ( ) + "(arg);" ) ; </a> 0
<a> sw . println ( </a> 0
<a> "org.timepedia.exporter.client.ExporterUtil.setStructuralField(" </a> 0
<a> + "jso, \"" + field . getName ( ) + "\", arg);" ) ; </a> 0
<a> } else { </a> 0
<a> sw . println ( field . getReturnType ( ) + " x = super." + field . getMethodName ( ) </a> 0
<a> + "(arg);" ) ; </a> 0
<a> sw . println ( </a> 0
<a> "org.timepedia.exporter.client.ExporterUtil.setStructuralField(" </a> 0
<a> + "jso, '" + field . getName ( ) + "', arg);" ) ; </a> 0
<a> sw . println ( "return x;" ) ; </a> 0
<a> } </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> } </a> 0
<a> private void exportAll ( String genName ) { </a> 0
<a> sw . println ( "public " + genName + "() { export(); } " ) ; </a> 0
<a> sw . println ( "public void export() { " ) ; </a> 0
<a> for ( JClassType type : xTypeOracle . findAllExportableTypes ( ) ) { </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . println ( "GWT.create(" + type . getQualifiedSourceName ( ) + ".class);" ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> } </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> } </a> 0
<a> private void registerTypeMap ( JExportableClassType requestedType ) { </a> 0
<a> sw . print ( </a> 0
<a> "@org.timepedia.exporter.client.ExporterUtil::addTypeMap(Ljava/lang/Class;Lcom/google/gwt/core/client/JavaScriptObject;)(" </a> 0
<a> + </a> 0
<a> "@" + requestedType . getQualifiedSourceName ( ) + "::class, $wnd." </a> 0
<a> + requestedType . getJSQualifiedExportName ( ) + ");" ) ; </a> 0
<a> } </a> 0
<a> private void exportStaticFactoryConstructors ( </a> 0
<a> JExportableClassType requestedType ) { </a> 0
<a> JExportableConstructor [ ] constructors = requestedType </a> 0
<a> . getExportableConstructors ( ) ; </a> 0
<a> for ( JExportableConstructor constructor : constructors ) { </a> 0
<a> exportStaticFactoryConstructor ( constructor ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void exportMethods ( JExportableClassType requestedType ) </a> 0
<a> throws UnableToCompleteException { </a> 0
<a> HashMap < String , DispatchTable > dispatchMap = buildDispatchTableMap ( </a> 0
<a> requestedType , false ) ; </a> 0
<a> HashMap < String , DispatchTable > staticDispatchMap = buildDispatchTableMap ( </a> 0
<a> requestedType , true ) ; </a> 0
<a> HashSet < String > exported = new HashSet < String > ( ) ; </a> 0
<a> HashSet < String > staticExported = new HashSet < String > ( ) ; </a> 0
<a> for ( JExportableMethod method : requestedType . getExportableMethods ( ) ) { </a> 0
<a> if ( method . isStatic ( ) ? ! staticExported . contains ( method . getName ( ) ) </a> 0
<a> : ! exported . contains ( method . getName ( ) ) ) { </a> 0
<a> exportMethod ( method , </a> 0
<a> method . isStatic ( ) ? staticDispatchMap : dispatchMap ) ; </a> 0
<a> if ( method . isStatic ( ) ) { </a> 0
<a> exported . add ( method . getName ( ) ) ; </a> 0
<a> } else { </a> 0
<a> staticExported . add ( method . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! xTypeOracle </a> 0
<a> . isClosure ( requestedType . getType ( ) . getQualifiedSourceName ( ) ) ) { </a> 0
<a> if ( DispatchTable . isAnyOverridden ( dispatchMap ) ) { </a> 0
<a> registerDispatchMap ( requestedType , dispatchMap , false ) ; </a> 0
<a> } </a> 0
<a> if ( DispatchTable . isAnyOverridden ( staticDispatchMap ) ) { </a> 0
<a> registerDispatchMap ( requestedType , staticDispatchMap , true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void registerDispatchMap ( JExportableClassType requestedType , </a> 0
<a> HashMap < String , DispatchTable > dispatchMap , boolean isStatic ) { </a> 0
<a> sw . print ( "@org.timepedia.exporter.client.ExporterUtil::registerDispatchMap(" </a> 0
<a> + "Ljava/lang/Class;Lcom/google/gwt/core/client/JavaScriptObject;Z)(@" </a> 0
<a> + requestedType . getQualifiedSourceName ( ) + "::class," </a> 0
<a> + DispatchTable . toJSON ( dispatchMap ) + ", " + isStatic + ");" ) ; </a> 0
<a> } </a> 0
<a> private HashMap < String , DispatchTable > buildDispatchTableMap ( </a> 0
<a> JExportableClassType requestedType , boolean staticDispatch ) </a> 0
<a> throws UnableToCompleteException { </a> 0
<a> HashMap < String , DispatchTable > dispMap </a> 0
<a> = new HashMap < String , DispatchTable > ( ) ; </a> 0
<a> for ( JExportableMethod meth : requestedType . getExportableMethods ( ) ) { </a> 0
<a> if ( staticDispatch && ! meth . isStatic ( ) || ! staticDispatch && meth </a> 0
<a> . isStatic ( ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> DispatchTable dt = dispMap . get ( meth . getUnqualifiedExportName ( ) ) ; </a> 0
<a> if ( dt == null ) { </a> 0
<a> dt = new DispatchTable ( ) ; </a> 0
<a> dispMap . put ( meth . getUnqualifiedExportName ( ) , dt ) ; </a> 0
<a> } </a> 0
<a> if ( ! dt . addSignature ( meth , meth . getExportableParameters ( ) ) ) { </a> 0
<a> logger . log ( TreeLogger . ERROR , </a> 0
<a> "Ambiguous method signature " + meth . getJSNIReference ( ) </a> 0
<a> + " would conflict in JS with another method" ) ; </a> 0
<a> throw new UnableToCompleteException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return dispMap ; </a> 0
<a> } </a> 0
<a> private void exportConstructor ( JExportableClassType requestedType ) </a> 0
<a> throws UnableToCompleteException { </a> 0
<a> sw . println ( "if($wnd." + requestedType . getJSQualifiedExportName ( ) + ") {" ) ; </a> 0
<a> sw . println ( </a> 0
<a> "var pkg = $wnd." + requestedType . getJSQualifiedExportName ( ) + ";" ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> sw . print ( "$wnd." + requestedType . getJSQualifiedExportName ( ) </a> 0
<a> + " = $entry(function(" ) ; </a> 0
<a> sw . println ( ") {" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . println ( "if(arguments.length == 1 && (arguments[0] != null && " </a> 0
<a> + "arguments[0].@java.lang.Object::getClass()() == " + "@" </a> 0
<a> + requestedType . getQualifiedSourceName ( ) + "::class)) {" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . println ( " this.__gwt_instance = arguments[0];" ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> JExportableConstructor [ ] constructors = requestedType </a> 0
<a> . getExportableConstructors ( ) ; </a> 0
<a> HashMap < Integer , JExportableConstructor > arity </a> 0
<a> = new HashMap < Integer , JExportableConstructor > ( ) ; </a> 0
<a> for ( JExportableConstructor constructor : constructors ) { </a> 0
<a> int numArguments = constructor . getExportableParameters ( ) . length ; </a> 0
<a> JExportableConstructor conflicting = arity . get ( numArguments ) ; </a> 0
<a> if ( conflicting != null ) { </a> 0
<a> logger . log ( TreeLogger . ERROR , </a> 0
<a> "Constructor " + conflicting + " with " + numArguments + " " </a> 0
<a> + "arguments conflicts with " + constructor + "." </a> 0
<a> + "Two constructors may not have identical numbers of " </a> 0
<a> + "arguments." , null ) ; </a> 0
<a> throw new UnableToCompleteException ( ) ; </a> 0
<a> } </a> 0
<a> arity . put ( numArguments , constructor ) ; </a> 0
<a> sw . println ( "else if(arguments.length == " + numArguments + ") {" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . print ( "this.__gwt_instance = @" </a> 0
<a> + constructor . getStaticFactoryJSNIReference ( ) + "(" ) ; </a> 0
<a> declareJSPassedValues ( constructor , true ) ; </a> 0
<a> sw . println ( ");" ) ; </a> 0
<a> sw . println ( </a> 0
<a> "@org.timepedia.exporter.client.ExporterUtil::setWrapper(Ljava/lang/Object;Lcom/google/gwt/core/client/JavaScriptObject;)(this.__gwt_instance, this);" ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> } </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "});" ) ; </a> 0
<a> JExportableClassType superClass = requestedType </a> 0
<a> . getExportableSuperClassType ( ) ; </a> 0
<a> if ( superClass != null && superClass . needsExport ( ) && ! exported </a> 0
<a> . contains ( superClass ) ) { </a> 0
<a> if ( exportDependentClass ( superClass . getQualifiedSourceName ( ) ) ) { </a> 0
<a> ; </a> 0
<a> } </a> 0
<a> exported . add ( superClass ) ; </a> 0
<a> } </a> 0
<a> sw . print ( "var _=$wnd." + requestedType . getJSQualifiedExportName ( ) </a> 0
<a> + ".prototype = " ) ; </a> 0
<a> sw . println ( superClass == null ? "new Object();" </a> 0
<a> : "new $wnd." + superClass . getJSQualifiedExportName ( ) + "();" ) ; </a> 0
<a> sw . println ( "if(pkg) {" ) ; </a> 0
<a> sw . println ( </a> 0
<a> "for(p in pkg) { $wnd." + requestedType . getJSQualifiedExportName ( ) </a> 0
<a> + "[p]=pkg[p]; }" ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> } </a> 0
<a> private void exportStaticFactoryConstructor ( </a> 0
<a> JExportableConstructor constructor ) { </a> 0
<a> JExportableClassType consType = ( JExportableClassType ) constructor </a> 0
<a> . getExportableReturnType ( ) ; </a> 0
<a> String typeName = consType . getQualifiedSourceName ( ) ; </a> 0
<a> sw . print ( "public static " + typeName + " " </a> 0
<a> + constructor . getStaticFactoryMethodName ( ) + "(" ) ; </a> 0
<a> declareParameters ( constructor , - 1 ) ; </a> 0
<a> sw . println ( ") {" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . print ( "return new " + typeName + "(" ) ; </a> 0
<a> declareJavaPassedValues ( constructor , false ) ; </a> 0
<a> sw . println ( ");" ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> } </a> 0
<a> private void debugJSPassedValues ( JExportableMethod method ) { </a> 0
<a> JExportableParameter params [ ] = method . getExportableParameters ( ) ; </a> 0
<a> for ( int i = 0 ; i < params . length ; i ++ ) { </a> 0
<a> sw . print ( </a> 0
<a> "$wnd.alert(\"\"+" + params [ i ] . getExportParameterValue ( ARG_PREFIX + i ) </a> 0
<a> + ");" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void declareJSPassedValues ( JExportableMethod method , </a> 0
<a> boolean useArgumentsArray ) { </a> 0
<a> JExportableParameter params [ ] = method . getExportableParameters ( ) ; </a> 0
<a> for ( int i = 0 ; i < params . length ; i ++ ) { </a> 0
<a> sw . print ( params [ i ] . getExportParameterValue ( </a> 0
<a> useArgumentsArray ? "arguments[" + i + "]" : ARG_PREFIX + i ) ) ; </a> 0
<a> if ( i < params . length - 1 ) { </a> 0
<a> sw . print ( ", " ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void declareJavaPassedValues ( JExportableMethod method , boolean wrap ) { </a> 0
<a> JExportableParameter params [ ] = method . getExportableParameters ( ) ; </a> 0
<a> for ( int i = 0 ; i < params . length ; i ++ ) { </a> 0
<a> JExportableType eType = params [ i ] . getExportableType ( ) ; </a> 0
<a> boolean needExport = eType != null && eType . needsExport ( ) ; </a> 0
<a> boolean isArray = eType instanceof JExportableArrayType ; </a> 0
<a> String arrayType = needExport && isArray ? ( "L" </a> 0
<a> + ( ( JExportableArrayType ) eType ) . getJSNIReference ( ) ) : "" ; </a> 0
<a> if ( wrap && needExport ) { </a> 0
<a> sw . print ( "@org.timepedia.exporter.client.ExporterUtil::wrap(" </a> 0
<a> + ( isArray ? arrayType </a> 0
<a> : "Lorg/timepedia/exporter/client/Exportable;" ) + ")(" ) ; </a> 0
<a> } </a> 0
<a> sw . print ( ARG_PREFIX + i ) ; </a> 0
<a> if ( wrap && needExport ) { </a> 0
<a> sw . print ( ")" ) ; </a> 0
<a> } </a> 0
<a> if ( i < params . length - 1 ) { </a> 0
<a> sw . print ( ", " ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void declareParameters ( JExportableMethod method , int arity , </a> 0
<a> boolean includeTypes ) { </a> 0
<a> JExportableParameter params [ ] = method . getExportableParameters ( ) ; </a> 0
<a> int numParams = includeTypes || arity < 0 ? params . length : arity ; </a> 0
<a> for ( int i = 0 ; i < numParams ; </a> 0
<a> i ++ ) { </a> 0
<a> sw . print ( </a> 0
<a> ( includeTypes ? params [ i ] . getTypeName ( ) : "" ) + " " + ARG_PREFIX + i ) ; </a> 0
<a> if ( i < numParams - 1 ) { </a> 0
<a> sw . print ( ", " ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void declareParameters ( JExportableMethod method , int arity ) { </a> 0
<a> declareParameters ( method , arity , true ) ; </a> 0
<a> } </a> 0
<a> private void declareJSParameters ( JExportableMethod method , int arity ) { </a> 0
<a> declareParameters ( method , arity , false ) ; </a> 0
<a> } </a> 0
<a> private void exportFields ( JExportableClassType requestedType ) </a> 0
<a> throws UnableToCompleteException { </a> 0
<a> for ( JExportableField field : requestedType . getExportableFields ( ) ) { </a> 0
<a> sw . print ( "$wnd." + field . getJSQualifiedExportName ( ) + " = " ) ; </a> 0
<a> sw . println ( "@" + field . getJSNIReference ( ) + ";" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void exportMethod ( JExportableMethod method , </a> 0
<a> HashMap < String , DispatchTable > dispatchMap ) </a> 0
<a> throws UnableToCompleteException { </a> 0
<a> JExportableType retType = method . getExportableReturnType ( ) ; </a> 0
<a> if ( retType == null ) { </a> 0
<a> logger . log ( TreeLogger . ERROR , </a> 0
<a> "Return type of method " + method . toString ( ) + " is not Exportable." , </a> 0
<a> null ) ; </a> 0
<a> throw new UnableToCompleteException ( ) ; </a> 0
<a> } </a> 0
<a> int arity = method . getExportableParameters ( ) . length ; </a> 0
<a> String name = method . getUnqualifiedExportName ( ) ; </a> 0
<a> String key = name + "_" + arity ; </a> 0
<a> if ( retType != null && retType . needsExport ( ) && ! exported </a> 0
<a> . contains ( retType ) ) { </a> 0
<a> if ( exportDependentClass ( retType . getQualifiedSourceName ( ) ) ) { </a> 0
<a> ; </a> 0
<a> } </a> 0
<a> exported . add ( ( JExportableClassType ) retType ) ; </a> 0
<a> } </a> 0
<a> exportDependentParams ( method ) ; </a> 0
<a> String returnTypeCast = retType != null ? retType . getHostedModeJsTypeCast ( ) </a> 0
<a> : null ; </a> 0
<a> if ( method . isStatic ( ) ) { </a> 0
<a> sw . print ( "$wnd." + method . getJSQualifiedExportName ( ) + " = " ) ; </a> 0
<a> } else { </a> 0
<a> sw . print ( "_." + method . getUnqualifiedExportName ( ) + "= " ) ; </a> 0
<a> } </a> 0
<a> if ( returnTypeCast != null ) { </a> 0
<a> sw . print ( </a> 0
<a> "@org.timepedia.exporter.client.ExporterHostedModeUtil::deboxHostedMode(Lcom/google/gwt/core/client/JavaScriptObject;Lcom/google/gwt/core/client/JavaScriptObject;)(" </a> 0
<a> + returnTypeCast + "," ) ; </a> 0
<a> } </a> 0
<a> sw . print ( "$entry(function(" ) ; </a> 0
<a> DispatchTable dt = dispatchMap . get ( method . getUnqualifiedExportName ( ) ) ; </a> 0
<a> declareJSParameters ( method , dt . isOverloaded ( ) ? dt . maxArity ( ) : - 1 ) ; </a> 0
<a> sw . print ( ") { " ) ; </a> 0
<a> boolean isVoid = retType . getQualifiedSourceName ( ) . equals ( "void" ) ; </a> 0
<a> if ( ! dt . isOverloaded ( ) ) { </a> 0
<a> sw . print ( ( isVoid ? "" : "var x=" ) </a> 0
<a> + ( method . isStatic ( ) ? "@" : "this.__gwt_instance.@" ) </a> 0
<a> + method . getJSNIReference ( ) + "(" ) ; </a> 0
<a> declareJSPassedValues ( method , false ) ; </a> 0
<a> sw . print ( ");" ) ; </a> 0
<a> } else { </a> 0
<a> sw . print ( ( isVoid ? "" </a> 0
<a> : "var x=@org.timepedia.exporter.client.ExporterUtil::getDispatch(" </a> 0
<a> + "Ljava/lang/Class;Ljava/lang/String;" </a> 0
<a> + "Lcom/google/gwt/core/client/JsArray;Z)" + "(@" + method </a> 0
<a> . getEnclosingExportType ( ) . getQualifiedSourceName ( ) ) + "::class,'" </a> 0
<a> + method . getUnqualifiedExportName ( ) + "', arguments," </a> 0
<a> + method . isStatic ( ) + ").apply(" </a> 0
<a> + ( method . isStatic ( ) ? "null" : "this.__gwt_instance" ) </a> 0
<a> + ", arguments" ) ; </a> 0
<a> sw . print ( ");" ) ; </a> 0
<a> } </a> 0
<a> if ( dt . isOverloaded ( ) || ! retType . needsExport ( ) ) { </a> 0
<a> sw . print ( isVoid ? "" : "return (" ) ; </a> 0
<a> } else { </a> 0
<a> boolean isArray = retType instanceof JExportableArrayType ; </a> 0
<a> String arrayType = isArray ? ( ( JExportableArrayType ) retType ) </a> 0
<a> . getJSNIReference ( ) : "" ; </a> 0
<a> sw . print ( ( isVoid ? "" : "return " ) </a> 0
<a> + "@org.timepedia.exporter.client.ExporterUtil::wrap(" </a> 0
<a> + ( isArray ? "Lorg/timepedia/exporter/client/Exportable;" </a> 0
<a> : "Lorg/timepedia/exporter/client/Exportable;" ) + ")(" </a> 0
<a> ) ; </a> 0
<a> } </a> 0
<a> if ( ! isVoid ) { </a> 0
<a> sw . println ( "x);" ) ; </a> 0
<a> } </a> 0
<a> sw . print ( "})" ) ; </a> 0
<a> if ( returnTypeCast != null ) { </a> 0
<a> sw . print ( ")" ) ; </a> 0
<a> } </a> 0
<a> sw . println ( ";" ) ; </a> 0
<a> } </a> 0
<a> private void exportDependentParams ( JExportableMethod method ) </a> 0
<a> throws UnableToCompleteException { </a> 0
<a> for ( JExportableParameter param : method . getExportableParameters ( ) ) { </a> 0
<a> JExportableType eType = param . getExportableType ( ) ; </a> 0
<a> if ( eType != null && eType . needsExport ( ) && ! exported . contains ( eType ) ) { </a> 0
<a> if ( exportDependentClass ( eType . getQualifiedSourceName ( ) ) ) { </a> 0
<a> exported . add ( ( JExportableClassType ) eType ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean exportDependentClass ( String qualifiedSourceName ) </a> 0
<a> throws UnableToCompleteException { </a> 0
<a> if ( visited . contains ( qualifiedSourceName ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> JExportableType xType = xTypeOracle . findExportableType ( qualifiedSourceName ) ; </a> 0
<a> if ( xType instanceof JExportableArrayType ) { </a> 0
<a> JExportableType xcompType = ( ( JExportableArrayType ) xType ) </a> 0
<a> . getComponentType ( ) ; </a> 0
<a> if ( xcompType instanceof JExportablePrimitiveType ) { </a> 0
<a> return false ; </a> 0
<a> } else { </a> 0
<a> return exportDependentClass ( xcompType . getQualifiedSourceName ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> visited . add ( qualifiedSourceName ) ; </a> 0
<a> ClassExporter exporter = new ClassExporter ( logger , ctx , visited ) ; </a> 0
<a> exporter . exportClass ( qualifiedSourceName , true ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> private void declarePackages ( JExportableClassType requestedClassType ) { </a> 0
<a> String requestedPackageName = requestedClassType . getJSExportPackage ( ) ; </a> 0
<a> String enclosingClasses [ ] = requestedClassType . getEnclosingClasses ( ) ; </a> 0
<a> String enclosing = "" ; </a> 0
<a> for ( String enclosingClass : enclosingClasses ) { </a> 0
<a> enclosing += enclosingClass + "." ; </a> 0
<a> } </a> 0
<a> enclosing = enclosing . length ( ) > 0 ? enclosing </a> 0
<a> . substring ( 0 , enclosing . length ( ) - 1 ) : enclosing ; </a> 0
<a> sw . println ( </a> 0
<a> "@org.timepedia.exporter.client.ExporterUtil::declarePackage(Ljava/lang/String;Ljava/lang/String;)('" </a> 0
<a> + requestedPackageName + "','" + enclosing + "');" ) ; </a> 0
<a> } </a> 0
<a> private void genExportMethod ( JExportableClassType requestedType , </a> 0
<a> ArrayList < JExportableClassType > exported ) { </a> 0
<a> sw . println ( "private static boolean exported;" ) ; </a> 0
<a> sw . println ( "public void export() { " ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . println ( "if(!exported) {" ) ; </a> 0
<a> sw . indent ( ) ; </a> 0
<a> sw . println ( "exported=true;" ) ; </a> 0
<a> int exprCount = 0 ; </a> 0
<a> for ( JExportableClassType classType : exported ) { </a> 0
<a> if ( requestedType . getQualifiedSourceName ( ) </a> 0
<a> . equals ( classType . getQualifiedSourceName ( ) ) </a> 0
<a> || classType instanceof JExportableArrayType ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> String qualName = classType . getQualifiedSourceName ( ) ; </a> 0
<a> String var = "export" + exprCount ++ ; </a> 0
<a> sw . println ( ExportableTypeOracle . EXPORTER_CLASS + " " + var + " = (" </a> 0
<a> + ExportableTypeOracle . EXPORTER_CLASS + ") GWT.create(" + qualName </a> 0
<a> + ".class);" ) ; </a> 0
<a> } </a> 0
<a> sw . println ( "export0();" ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> sw . outdent ( ) ; </a> 0
<a> sw . println ( "}" ) ; </a> 0
<a> } </a> 0
<a> protected SourceWriter getSourceWriter ( TreeLogger logger , </a> 0
<a> GeneratorContext context , String packageName , String className , </a> 0
<a> String superClass , String ... interfaceNames ) { </a> 0
<a> PrintWriter printWriter = context . tryCreate ( logger , packageName , className ) ; </a> 0
<a> if ( printWriter == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> ClassSourceFileComposerFactory composerFactory </a> 0
<a> = new ClassSourceFileComposerFactory ( packageName , className ) ; </a> 0
<a> composerFactory . addImport ( "com.google.gwt.core.client.GWT" ) ; </a> 0
<a> composerFactory . addImport ( "com.google.gwt.core.client.JavaScriptObject" ) ; </a> 0
<a> if ( superClass != null ) { </a> 0
<a> composerFactory . setSuperclass ( superClass ) ; </a> 0
<a> } </a> 0
<a> for ( String interfaceName : interfaceNames ) { </a> 0
<a> composerFactory . addImplementedInterface ( interfaceName ) ; </a> 0
<a> } </a> 0
<a> composerFactory . addImport ( "org.timepedia.exporter.client.Exporter" ) ; </a> 0
<a> return composerFactory . createSourceWriter ( context , printWriter ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . TreeLogger ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JAbstractMethod ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JClassType ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JConstructor ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JField ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JType ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . TypeOracle ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . TypeOracleException ; </a> 0
<a> import org . timepedia . exporter . client . Export ; </a> 0
<a> import org . timepedia . exporter . client . ExportClosure ; </a> 0
<a> import org . timepedia . exporter . client . NoExport ; </a> 0
<a> import org . timepedia . exporter . client . StructuralType ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class ExportableTypeOracle { </a> 0
<a> public static final String JSO_CLASS </a> 0
<a> = "com.google.gwt.core.client.JavaScriptObject" ; </a> 0
<a> static final String EXPORTER_CLASS = "org.timepedia.exporter.client.Exporter" ; </a> 0
<a> static final String EXPORTABLE_CLASS </a> 0
<a> = "org.timepedia.exporter.client.Exportable" ; </a> 0
<a> static final String EXPORTALL_CLASS = "org.timepedia.exporter.client.ExporterUtil.ExportAll" ; </a> 0
<a> static final String EXPORT_OVERLAY_CLASS </a> 0
<a> = "org.timepedia.exporter.client.ExportOverlay" ; </a> 0
<a> private static final String STRING_CLASS = "java.lang.String" ; </a> 0
<a> private JClassType exportAllType ; </a> 0
<a> public boolean isExportable ( JField field ) { </a> 0
<a> return field . isStatic ( ) && field . isPublic ( ) && field . isFinal ( ) && ( </a> 0
<a> isExportable ( field . getAnnotation ( Export . class ) ) || ( </a> 0
<a> isExportable ( field . getEnclosingType ( ) ) && ! isNotExportable ( </a> 0
<a> field . getAnnotation ( NoExport . class ) ) ) ) ; </a> 0
<a> } </a> 0
<a> public boolean isExportable ( JClassType type ) { </a> 0
<a> return isExportable ( type . getAnnotation ( Export . class ) ) || ( </a> 0
<a> type . isInterface ( ) != null && isExportable ( </a> 0
<a> type . getAnnotation ( ExportClosure . class ) ) ) ; </a> 0
<a> } </a> 0
<a> public static boolean isExportable ( Export annotation ) { </a> 0
<a> return annotation != null ; </a> 0
<a> } </a> 0
<a> public boolean isExportable ( JAbstractMethod method ) { </a> 0
<a> if ( method instanceof JConstructor ) { </a> 0
<a> if ( method . getParameters ( ) . length == 0 && method . isPublic ( ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return ( isExportable ( method . getEnclosingType ( ) ) && method . isPublic ( ) </a> 0
<a> && ! isNotExportable ( method . getAnnotation ( NoExport . class ) ) ) </a> 0
<a> || ( isExportable ( method . getAnnotation ( Export . class ) ) ) ; </a> 0
<a> } </a> 0
<a> private static boolean isExportable ( ExportClosure annotation ) { </a> 0
<a> return annotation != null ; </a> 0
<a> } </a> 0
<a> private static boolean isNotExportable ( NoExport annotation ) { </a> 0
<a> return annotation != null ; </a> 0
<a> } </a> 0
<a> private TypeOracle typeOracle ; </a> 0
<a> private TreeLogger log ; </a> 0
<a> private JClassType exportableType = null ; </a> 0
<a> private JClassType jsoType = null ; </a> 0
<a> private JClassType stringType = null ; </a> 0
<a> private JClassType exportOverlayType ; </a> 0
<a> private Map < String , JExportOverlayClassType > overlayTypes </a> 0
<a> = new HashMap < String , JExportOverlayClassType > ( ) ; </a> 0
<a> public ExportableTypeOracle ( TypeOracle typeOracle , TreeLogger log ) { </a> 0
<a> this . typeOracle = typeOracle ; </a> 0
<a> this . log = log ; </a> 0
<a> exportableType = typeOracle . findType ( EXPORTABLE_CLASS ) ; </a> 0
<a> exportOverlayType = typeOracle . findType ( EXPORT_OVERLAY_CLASS ) ; </a> 0
<a> exportAllType = typeOracle . findType ( EXPORTALL_CLASS ) ; </a> 0
<a> jsoType = typeOracle . findType ( JSO_CLASS ) ; </a> 0
<a> stringType = typeOracle . findType ( STRING_CLASS ) ; </a> 0
<a> assert exportableType != null ; </a> 0
<a> assert exportOverlayType != null ; </a> 0
<a> assert jsoType != null ; </a> 0
<a> assert stringType != null ; </a> 0
<a> for ( JClassType t : typeOracle . getTypes ( ) ) { </a> 0
<a> if ( t . isAssignableTo ( exportOverlayType ) && ! t . equals ( exportOverlayType ) ) { </a> 0
<a> JClassType targetType = getExportOverlayType ( t ) ; </a> 0
<a> overlayTypes . put ( targetType . getQualifiedSourceName ( ) , </a> 0
<a> new JExportOverlayClassType ( this , t ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public JExportableClassType findExportableClassType ( String requestedClass ) { </a> 0
<a> JClassType requestedType = typeOracle . findType ( requestedClass ) ; </a> 0
<a> if ( requestedType != null ) { </a> 0
<a> if ( requestedType . isAssignableTo ( exportOverlayType ) ) { </a> 0
<a> return new JExportOverlayClassType ( this , requestedType ) ; </a> 0
<a> } else if ( requestedType . isAssignableTo ( exportableType ) ) { </a> 0
<a> return new JExportableClassType ( this , requestedType ) ; </a> 0
<a> } </a> 0
<a> JExportOverlayClassType exportOverlay = overlayTypes . get ( requestedClass ) ; </a> 0
<a> return exportOverlay ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public JExportableType findExportableType ( String paramTypeName ) { </a> 0
<a> try { </a> 0
<a> JType type = typeOracle . parse ( paramTypeName ) ; </a> 0
<a> JClassType cType = type != null ? type . isClassOrInterface ( ) : null ; </a> 0
<a> if ( type . isPrimitive ( ) != null ) { </a> 0
<a> return new JExportablePrimitiveType ( this , type . isPrimitive ( ) ) ; </a> 0
<a> } else if ( type . isArray ( ) != null ) { </a> 0
<a> return new JExportableArrayType ( this , type . isArray ( ) ) ; </a> 0
<a> } else if ( overlayTypes . containsKey ( paramTypeName ) ) { </a> 0
<a> return overlayTypes . get ( paramTypeName ) ; </a> 0
<a> } else if ( cType . isAssignableTo ( exportOverlayType ) ) { </a> 0
<a> return new JExportOverlayClassType ( this , type . isClassOrInterface ( ) ) ; </a> 0
<a> } else if ( cType != null && ( cType . isAssignableTo ( exportableType ) </a> 0
<a> || cType . isAssignableTo ( stringType ) || cType </a> 0
<a> . isAssignableTo ( jsoType ) ) ) { </a> 0
<a> return new JExportableClassType ( this , type . isClassOrInterface ( ) ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } catch ( TypeOracleException e ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public JExportableClassType findFirstExportableSuperClassType ( </a> 0
<a> JClassType type ) { </a> 0
<a> if ( type == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> JExportableClassType exportable = findExportableClassType ( </a> 0
<a> type . getQualifiedSourceName ( ) ) ; </a> 0
<a> return exportable != null && exportable . needsExport ( ) ? exportable </a> 0
<a> : findFirstExportableSuperClassType ( type . getSuperclass ( ) ) ; </a> 0
<a> } </a> 0
<a> public JClassType getExportOverlayType ( JClassType requestedType ) { </a> 0
<a> JClassType [ ] inf = requestedType . getImplementedInterfaces ( ) ; </a> 0
<a> for ( JClassType i : inf ) { </a> 0
<a> if ( isExportOverlay ( i ) ) { </a> 0
<a> return i . isParameterized ( ) . getTypeArgs ( ) [ 0 ] ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public boolean isArray ( JExportableClassType jExportableClassType ) { </a> 0
<a> return jExportableClassType . getType ( ) . isArray ( ) != null ; </a> 0
<a> } </a> 0
<a> public boolean isClosure ( String qualifiedSourceName ) { </a> 0
<a> if ( qualifiedSourceName == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> JType type = typeOracle . findType ( qualifiedSourceName ) ; </a> 0
<a> if ( type == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> JClassType cType = type . isClassOrInterface ( ) ; </a> 0
<a> if ( cType != null && cType . isAssignableTo ( exportableType ) ) { </a> 0
<a> ExportClosure ann = cType . getAnnotation ( ExportClosure . class ) ; </a> 0
<a> if ( ann != null && cType . isInterface ( ) != null ) { </a> 0
<a> return cType . getMethods ( ) . length == 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> public boolean isExportOverlay ( JClassType i ) { </a> 0
<a> return i . isAssignableTo ( exportOverlayType ) ; </a> 0
<a> } </a> 0
<a> public boolean isJavaScriptObject ( JExportableClassType type ) { </a> 0
<a> return type . getType ( ) . isAssignableTo ( jsoType ) ; </a> 0
<a> } </a> 0
<a> public boolean isString ( JExportableClassType type ) { </a> 0
<a> return type . getType ( ) . isAssignableTo ( stringType ) ; </a> 0
<a> } </a> 0
<a> public boolean isString ( JType type ) { </a> 0
<a> return type . isClass ( ) != null && type . isClass ( ) . isAssignableTo ( stringType ) ; </a> 0
<a> } </a> 0
<a> public boolean isJavaScriptObject ( JType type ) { </a> 0
<a> return type . isClass ( ) != null && type . isClass ( ) . isAssignableTo ( jsoType ) ; </a> 0
<a> } </a> 0
<a> public boolean isExportAll ( String requestedClass ) { </a> 0
<a> return typeOracle . findType ( requestedClass ) . isAssignableTo ( exportAllType ) ; </a> 0
<a> } </a> 0
<a> public List < JClassType > findAllExportableTypes ( ) { </a> 0
<a> ArrayList < JClassType > types = new ArrayList < JClassType > ( ) ; </a> 0
<a> for ( JClassType t : typeOracle . getTypes ( ) ) { </a> 0
<a> if ( t . equals ( exportAllType ) || t . equals ( exportableType ) || t </a> 0
<a> . equals ( exportOverlayType ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> if ( t . isAssignableTo ( exportableType ) || t </a> 0
<a> . isAssignableTo ( exportOverlayType ) ) { </a> 0
<a> if ( t . isDefaultInstantiable ( ) && t . isPublic ( ) ) { </a> 0
<a> types . add ( t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return types ; </a> 0
<a> } </a> 0
<a> public boolean isStructuralType ( JClassType type ) { </a> 0
<a> return false && type . getAnnotation ( StructuralType . class ) != null ; </a> 0
<a> } </a> 0
<a> public String getJsTypeOf ( JClassType type ) { </a> 0
<a> if ( type . isAssignableTo ( stringType ) ) { </a> 0
<a> return "string" ; </a> 0
<a> } else if ( type . isAssignableTo ( jsoType ) ) { </a> 0
<a> return "object" ; </a> 0
<a> } </a> 0
<a> return "@" + type . getQualifiedSourceName ( ) + "::class" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . Generator ; </a> 0
<a> import com . google . gwt . core . ext . GeneratorContext ; </a> 0
<a> import com . google . gwt . core . ext . TreeLogger ; </a> 0
<a> import com . google . gwt . core . ext . UnableToCompleteException ; </a> 0
<a> public class ExporterGenerator extends Generator { </a> 0
<a> public String generate ( TreeLogger logger , GeneratorContext ctx , </a> 0
<a> String requestedClass ) throws UnableToCompleteException { </a> 0
<a> ClassExporter classExporter = new ClassExporter ( logger , ctx ) ; </a> 0
<a> String generatedClass = classExporter . exportClass ( requestedClass , true ) ; </a> 0
<a> return generatedClass ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . Generator ; </a> 0
<a> import com . google . gwt . core . ext . GeneratorContext ; </a> 0
<a> import com . google . gwt . core . ext . TreeLogger ; </a> 0
<a> import com . google . gwt . core . ext . UnableToCompleteException ; </a> 0
<a> public class ExporterGeneratorNoExport extends Generator { </a> 0
<a> public String generate ( TreeLogger logger , GeneratorContext ctx , </a> 0
<a> String requestedClass ) throws UnableToCompleteException { </a> 0
<a> ClassExporter classExporter = new ClassExporter ( logger , ctx ) ; </a> 0
<a> String generatedClass = classExporter . exportClass ( requestedClass , false ) ; </a> 0
<a> return generatedClass ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JClassType ; </a> 0
<a> public class JExportOverlayClassType extends JExportableClassType { </a> 0
<a> private JClassType exportType ; </a> 0
<a> public JExportOverlayClassType ( ExportableTypeOracle exportableTypeOracle , </a> 0
<a> JClassType requestedType ) { </a> 0
<a> super ( exportableTypeOracle , requestedType ) ; </a> 0
<a> exportType = exportableTypeOracle . getExportOverlayType ( requestedType ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public JClassType getType ( ) { </a> 0
<a> return exportType ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> public interface JExportable { </a> 0
<a> public String getJSQualifiedExportName ( ) ; </a> 0
<a> public String getJSNIReference ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JArrayType ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JType ; </a> 0
<a> import org . timepedia . exporter . client . ExporterUtil ; </a> 0
<a> public class JExportableArrayType extends JExportableClassType </a> 0
<a> implements JExportableType { </a> 0
<a> public JExportableArrayType ( ExportableTypeOracle exportableTypeOracle , </a> 0
<a> JArrayType array ) { </a> 0
<a> super ( exportableTypeOracle , array ) ; </a> 0
<a> this . exportableTypeOracle = exportableTypeOracle ; </a> 0
<a> this . array = array ; </a> 0
<a> } </a> 0
<a> private ExportableTypeOracle exportableTypeOracle ; </a> 0
<a> private JArrayType array ; </a> 0
<a> public boolean needsExport ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public String getQualifiedSourceName ( ) { </a> 0
<a> return array . getQualifiedSourceName ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String getWrapperFunc ( ) { </a> 0
<a> JType type = array . getComponentType ( ) ; </a> 0
<a> return "@" + ExporterUtil . class . getName ( ) + "::wrap([" </a> 0
<a> + type . getJNISignature ( ) + ")" ; </a> 0
<a> } </a> 0
<a> public JExportableType getComponentType ( ) { </a> 0
<a> return exportableTypeOracle </a> 0
<a> . findExportableType ( array . getComponentType ( ) . getQualifiedSourceName ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JClassType ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JConstructor ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JField ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JMethod ; </a> 0
<a> import org . timepedia . exporter . client . ExportPackage ; </a> 0
<a> import org . timepedia . exporter . client . ExporterUtil ; </a> 0
<a> import org . timepedia . exporter . client . SType ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> public class JExportableClassType implements JExportable , JExportableType { </a> 0
<a> private static final String IMPL_EXTENSION = "ExporterImpl" ; </a> 0
<a> private ExportableTypeOracle exportableTypeOracle ; </a> 0
<a> private JClassType type ; </a> 0
<a> public JExportableClassType ( ExportableTypeOracle exportableTypeOracle , </a> 0
<a> JClassType type ) { </a> 0
<a> this . exportableTypeOracle = exportableTypeOracle ; </a> 0
<a> this . type = type ; </a> 0
<a> } </a> 0
<a> public boolean equals ( Object o ) { </a> 0
<a> if ( this == o ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( o == null || getClass ( ) != o . getClass ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> JExportableClassType that = ( JExportableClassType ) o ; </a> 0
<a> return getQualifiedSourceName ( ) . equals ( that . getQualifiedSourceName ( ) ) ; </a> 0
<a> } </a> 0
<a> public String [ ] getEnclosingClasses ( ) { </a> 0
<a> String [ ] enc = type . getName ( ) . split ( "\\." ) ; </a> 0
<a> String [ ] enclosingTypes = new String [ enc . length - 1 ] ; </a> 0
<a> if ( enc . length > 1 ) { </a> 0
<a> System . arraycopy ( enc , 0 , enclosingTypes , 0 , enclosingTypes . length ) ; </a> 0
<a> } </a> 0
<a> return enclosingTypes ; </a> 0
<a> } </a> 0
<a> public JExportableConstructor [ ] getExportableConstructors ( ) { </a> 0
<a> ArrayList < JExportableConstructor > exportableCons </a> 0
<a> = new ArrayList < JExportableConstructor > ( ) ; </a> 0
<a> if ( isInstantiable ( ) ) { </a> 0
<a> JClassType exportType = type ; </a> 0
<a> if ( exportableTypeOracle . isExportOverlay ( type ) ) { </a> 0
<a> exportType = exportableTypeOracle . getExportOverlayType ( type ) ; </a> 0
<a> } </a> 0
<a> for ( JConstructor method : exportType . getConstructors ( ) ) { </a> 0
<a> if ( method . isConstructor ( ) == null ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> if ( exportableTypeOracle . isExportable ( method ) ) { </a> 0
<a> exportableCons . add ( new JExportableConstructor ( this , method ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return exportableCons . toArray ( new JExportableConstructor [ 0 ] ) ; </a> 0
<a> } </a> 0
<a> public JExportableField [ ] getExportableFields ( ) { </a> 0
<a> ArrayList < JExportableField > exportableFields </a> 0
<a> = new ArrayList < JExportableField > ( ) ; </a> 0
<a> for ( JField field : type . getFields ( ) ) { </a> 0
<a> if ( exportableTypeOracle . isExportable ( field ) ) { </a> 0
<a> exportableFields . add ( new JExportableField ( this , field ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return exportableFields . toArray ( new JExportableField [ 0 ] ) ; </a> 0
<a> } </a> 0
<a> public JExportableMethod [ ] getExportableMethods ( ) { </a> 0
<a> ArrayList < JExportableMethod > exportableMethods </a> 0
<a> = new ArrayList < JExportableMethod > ( ) ; </a> 0
<a> for ( JMethod method : type . getMethods ( ) ) { </a> 0
<a> if ( method . isConstructor ( ) != null ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> if ( exportableTypeOracle . isExportable ( method ) ) { </a> 0
<a> exportableMethods . add ( new JExportableMethod ( this , method ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return exportableMethods . toArray ( new JExportableMethod [ 0 ] ) ; </a> 0
<a> } </a> 0
<a> public JExportableClassType getExportableSuperClassType ( ) { </a> 0
<a> return exportableTypeOracle </a> 0
<a> . findFirstExportableSuperClassType ( type . getSuperclass ( ) ) ; </a> 0
<a> } </a> 0
<a> public ExportableTypeOracle getExportableTypeOracle ( ) { </a> 0
<a> return exportableTypeOracle ; </a> 0
<a> } </a> 0
<a> public String getExporterImplementationName ( ) { </a> 0
<a> return type . getSimpleSourceName ( ) + IMPL_EXTENSION ; </a> 0
<a> } </a> 0
<a> public String getHostedModeJsTypeCast ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public String getJsTypeOf ( ) { </a> 0
<a> return exportableTypeOracle . getJsTypeOf ( getType ( ) ) ; </a> 0
<a> } </a> 0
<a> public String getJSConstructor ( ) { </a> 0
<a> return getJSExportPackage ( ) + "." + type . getName ( ) ; </a> 0
<a> } </a> 0
<a> public String getJSExportPackage ( ) { </a> 0
<a> String requestedPackageName = getPrefix ( ) ; </a> 0
<a> ExportPackage ann = type . getAnnotation ( ExportPackage . class ) ; </a> 0
<a> if ( ann != null ) { </a> 0
<a> requestedPackageName = ann . value ( ) ; </a> 0
<a> } else if ( type . getEnclosingType ( ) != null ) { </a> 0
<a> JExportableClassType encType = exportableTypeOracle </a> 0
<a> . findExportableClassType ( </a> 0
<a> type . getEnclosingType ( ) . getQualifiedSourceName ( ) ) ; </a> 0
<a> if ( encType != null ) { </a> 0
<a> return encType . getJSExportPackage ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return requestedPackageName ; </a> 0
<a> } </a> 0
<a> public String getJSNIReference ( ) { </a> 0
<a> return type . getJNISignature ( ) ; </a> 0
<a> } </a> 0
<a> public String getJSQualifiedExportName ( ) { </a> 0
<a> return getJSConstructor ( ) ; </a> 0
<a> } </a> 0
<a> public String getPackageName ( ) { </a> 0
<a> return type . getPackage ( ) . getName ( ) ; </a> 0
<a> } </a> 0
<a> public String getPrefix ( ) { </a> 0
<a> String prefix = "" ; </a> 0
<a> boolean firstClientPackage = true ; </a> 0
<a> for ( String pkg : type . getPackage ( ) . getName ( ) . split ( "\\." ) ) { </a> 0
<a> if ( firstClientPackage && pkg . equals ( "client" ) ) { </a> 0
<a> firstClientPackage = false ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> prefix += pkg ; </a> 0
<a> prefix += '.' ; </a> 0
<a> } </a> 0
<a> return prefix . substring ( 0 , prefix . length ( ) - 1 ) ; </a> 0
<a> } </a> 0
<a> public String getQualifiedExporterImplementationName ( ) { </a> 0
<a> return getPackageName ( ) + "." + getExporterImplementationName ( ) ; </a> 0
<a> } </a> 0
<a> public String getQualifiedSourceName ( ) { </a> 0
<a> return getType ( ) . getQualifiedSourceName ( ) ; </a> 0
<a> } </a> 0
<a> public JStructuralTypeField [ ] getStructuralTypeFields ( ) { </a> 0
<a> if ( ! isStructuralType ( ) ) { </a> 0
<a> return new JStructuralTypeField [ 0 ] ; </a> 0
<a> } else { </a> 0
<a> ArrayList < JStructuralTypeField > fields </a> 0
<a> = new ArrayList < JStructuralTypeField > ( ) ; </a> 0
<a> for ( JMethod method : type . getMethods ( ) ) { </a> 0
<a> if ( method . getName ( ) . startsWith ( "set" ) </a> 0
<a> && Character . isUpperCase ( method . getName ( ) . charAt ( 3 ) ) </a> 0
<a> && method . getParameters ( ) . length == 1 </a> 0
<a> || method . getAnnotation ( SType . class ) != null ) { </a> 0
<a> fields . add ( new JStructuralTypeField ( this , method ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return fields . toArray ( new JStructuralTypeField [ 0 ] ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public JClassType getType ( ) { </a> 0
<a> return type ; </a> 0
<a> } </a> 0
<a> public JClassType getTypeToExport ( ) { </a> 0
<a> return type ; </a> 0
<a> } </a> 0
<a> public String getWrapperFunc ( ) { </a> 0
<a> if ( ! needsExport ( ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return "@" + ExporterUtil . class . getName ( ) </a> 0
<a> + "::wrap(Lorg/timepedia/exporter/client/Exportable;)" ; </a> 0
<a> } </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return getQualifiedSourceName ( ) . hashCode ( ) ; </a> 0
<a> } </a> 0
<a> public boolean isPrimitive ( ) { </a> 0
<a> return type . isPrimitive ( ) != null ; </a> 0
<a> } </a> 0
<a> public boolean isStructuralType ( ) { </a> 0
<a> return exportableTypeOracle . isStructuralType ( this . getType ( ) ) ; </a> 0
<a> } </a> 0
<a> public boolean isTransparentType ( ) { </a> 0
<a> return exportableTypeOracle . isJavaScriptObject ( this ) </a> 0
<a> || exportableTypeOracle . isString ( this ) || exportableTypeOracle </a> 0
<a> . isArray ( this ) ; </a> 0
<a> } </a> 0
<a> public boolean needsExport ( ) { </a> 0
<a> return ! isPrimitive ( ) && ! isTransparentType ( ) ; </a> 0
<a> } </a> 0
<a> public boolean isInstantiable ( ) { </a> 0
<a> return type . isInterface ( ) == null && ! type . isAbstract ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JAbstractMethod ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JParameter ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JType ; </a> 0
<a> public class JExportableConstructor extends JExportableMethod { </a> 0
<a> private static final String STATIC_FACTORY_NAME = "___create" ; </a> 0
<a> public JExportableConstructor ( JExportableClassType exportableEnclosingType , </a> 0
<a> JAbstractMethod method ) { </a> 0
<a> super ( exportableEnclosingType , method ) ; </a> 0
<a> } </a> 0
<a> private void assertExportable ( JType param ) { </a> 0
<a> } </a> 0
<a> public String getJSNIReference ( ) { </a> 0
<a> String reference = exportableEnclosingType . getQualifiedSourceName ( ) + "::" </a> 0
<a> + getStaticFactoryMethodName ( ) + "(" ; </a> 0
<a> JParameter [ ] params = method . getParameters ( ) ; </a> 0
<a> for ( int i = 0 ; i < params . length ; i ++ ) { </a> 0
<a> reference += params [ i ] . getType ( ) . getJNISignature ( ) ; </a> 0
<a> } </a> 0
<a> reference += ")" ; </a> 0
<a> return reference ; </a> 0
<a> } </a> 0
<a> public String getStaticFactoryMethodName ( ) { </a> 0
<a> return STATIC_FACTORY_NAME ; </a> 0
<a> } </a> 0
<a> public JExportableType getExportableReturnType ( ) { </a> 0
<a> return exportableEnclosingType ; </a> 0
<a> } </a> 0
<a> public String getStaticFactoryJSNIReference ( ) { </a> 0
<a> String reference = </a> 0
<a> exportableEnclosingType . getQualifiedExporterImplementationName ( ) + "::" </a> 0
<a> + getStaticFactoryMethodName ( ) + "(" ; </a> 0
<a> JParameter [ ] params = method . getParameters ( ) ; </a> 0
<a> for ( int i = 0 ; i < params . length ; i ++ ) { </a> 0
<a> reference += params [ i ] . getType ( ) . getJNISignature ( ) ; </a> 0
<a> } </a> 0
<a> reference += ")" ; </a> 0
<a> return reference ; </a> 0
<a> } </a> 0
<a> public String getJSQualifiedExportName ( ) { </a> 0
<a> return exportableEnclosingType . getJSQualifiedExportName ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JField ; </a> 0
<a> import org . timepedia . exporter . client . Export ; </a> 0
<a> public class JExportableField { </a> 0
<a> private JExportableClassType enclosingExportType ; </a> 0
<a> private JField field ; </a> 0
<a> private String exportName ; </a> 0
<a> public JExportableField ( JExportableClassType enclosingExportType , </a> 0
<a> JField field ) { </a> 0
<a> this . enclosingExportType = enclosingExportType ; </a> 0
<a> this . field = field ; </a> 0
<a> Export ann = field . getAnnotation ( Export . class ) ; </a> 0
<a> if ( ann != null && ann . value ( ) . length ( ) > 0 ) { </a> 0
<a> exportName = ann . value ( ) ; </a> 0
<a> } else { </a> 0
<a> exportName = field . getName ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public String getJSExportName ( ) { </a> 0
<a> return exportName ; </a> 0
<a> } </a> 0
<a> public String getJSQualifiedExportName ( ) { </a> 0
<a> return enclosingExportType . getJSQualifiedExportName ( ) + "." </a> 0
<a> + getJSExportName ( ) ; </a> 0
<a> } </a> 0
<a> public String getJSNIReference ( ) { </a> 0
<a> return field . getEnclosingType ( ) . getQualifiedSourceName ( ) + "::" + field </a> 0
<a> . getName ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JAbstractMethod ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JConstructor ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JMethod ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JParameter ; </a> 0
<a> import org . timepedia . exporter . client . Export ; </a> 0
<a> public class JExportableMethod implements JExportable { </a> 0
<a> protected JExportableClassType exportableEnclosingType ; </a> 0
<a> protected JAbstractMethod method ; </a> 0
<a> private String exportName ; </a> 0
<a> public JExportableMethod ( JExportableClassType exportableEnclosingType , </a> 0
<a> JAbstractMethod method ) { </a> 0
<a> this . exportableEnclosingType = exportableEnclosingType ; </a> 0
<a> this . method = method ; </a> 0
<a> Export ann = method . getAnnotation ( Export . class ) ; </a> 0
<a> if ( ann != null && ann . value ( ) . length ( ) > 0 ) { </a> 0
<a> exportName = ann . value ( ) ; </a> 0
<a> } else { </a> 0
<a> exportName = method . getName ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public String getUnqualifiedExportName ( ) { </a> 0
<a> return exportName ; </a> 0
<a> } </a> 0
<a> public String getJSQualifiedExportName ( ) { </a> 0
<a> return getEnclosingExportType ( ) . getJSQualifiedExportName ( ) + "." </a> 0
<a> + getUnqualifiedExportName ( ) ; </a> 0
<a> } </a> 0
<a> public JExportableType getExportableReturnType ( ) { </a> 0
<a> ExportableTypeOracle xTypeOracle = getExportableTypeOracle ( ) ; </a> 0
<a> String returnTypeName = ( ( JMethod ) method ) . getReturnType ( ) </a> 0
<a> . getQualifiedSourceName ( ) ; </a> 0
<a> return xTypeOracle . findExportableType ( returnTypeName ) ; </a> 0
<a> } </a> 0
<a> public JExportableParameter [ ] getExportableParameters ( ) { </a> 0
<a> JParameter [ ] params = method . getParameters ( ) ; </a> 0
<a> JExportableParameter [ ] eparams = new JExportableParameter [ params . length ] ; </a> 0
<a> int i = 0 ; </a> 0
<a> for ( JParameter param : params ) { </a> 0
<a> eparams [ i ++ ] = new JExportableParameter ( this , param ) ; </a> 0
<a> } </a> 0
<a> return eparams ; </a> 0
<a> } </a> 0
<a> public JExportableClassType getEnclosingExportType ( ) { </a> 0
<a> return exportableEnclosingType ; </a> 0
<a> } </a> 0
<a> public String getJSNIReference ( ) { </a> 0
<a> String reference = exportableEnclosingType . getQualifiedSourceName ( ) + "::" </a> 0
<a> + method . getName ( ) + "(" ; </a> 0
<a> JParameter [ ] params = method . getParameters ( ) ; </a> 0
<a> for ( int i = 0 ; i < params . length ; i ++ ) { </a> 0
<a> reference += params [ i ] . getType ( ) . getJNISignature ( ) ; </a> 0
<a> } </a> 0
<a> reference += ")" ; </a> 0
<a> return reference ; </a> 0
<a> } </a> 0
<a> public boolean isStatic ( ) { </a> 0
<a> if ( method instanceof JConstructor ) { </a> 0
<a> return false ; </a> 0
<a> } else { </a> 0
<a> return ( ( JMethod ) method ) . isStatic ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public ExportableTypeOracle getExportableTypeOracle ( ) { </a> 0
<a> return getEnclosingExportType ( ) . getExportableTypeOracle ( ) ; </a> 0
<a> } </a> 0
<a> public String toString ( ) { </a> 0
<a> String str = exportableEnclosingType . getQualifiedSourceName ( ) + "." </a> 0
<a> + method . getName ( ) + "(" ; </a> 0
<a> JExportableParameter [ ] params = getExportableParameters ( ) ; </a> 0
<a> for ( int i = 0 ; i < params . length ; i ++ ) { </a> 0
<a> str += params [ i ] ; </a> 0
<a> if ( i < params . length - 1 ) { </a> 0
<a> str += ", " ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return str + ")" ; </a> 0
<a> } </a> 0
<a> public String getName ( ) { </a> 0
<a> return method . getName ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JParameter ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JPrimitiveType ; </a> 0
<a> public class JExportableParameter { </a> 0
<a> private JParameter param ; </a> 0
<a> private JExportableClassType exportableEnclosingType ; </a> 0
<a> public JExportableParameter ( JExportableMethod exportableMethod , </a> 0
<a> JParameter param ) { </a> 0
<a> this . param = param ; </a> 0
<a> this . exportableEnclosingType = exportableMethod . getEnclosingExportType ( ) ; </a> 0
<a> } </a> 0
<a> public String getTypeName ( ) { </a> 0
<a> return param . getType ( ) . getQualifiedSourceName ( ) ; </a> 0
<a> } </a> 0
<a> public String getExportParameterValue ( String argName ) { </a> 0
<a> ExportableTypeOracle xTypeOracle = exportableEnclosingType </a> 0
<a> . getExportableTypeOracle ( ) ; </a> 0
<a> String paramTypeName = param . getType ( ) . getQualifiedSourceName ( ) ; </a> 0
<a> JExportableType type = xTypeOracle . findExportableType ( paramTypeName ) ; </a> 0
<a> if ( type != null && type . needsExport ( ) ) { </a> 0
<a> JExportableClassType cType = ( JExportableClassType ) type ; </a> 0
<a> if ( exportableEnclosingType . getExportableTypeOracle ( ) </a> 0
<a> . isClosure ( type . getQualifiedSourceName ( ) ) ) { </a> 0
<a> String value = "(" + argName + ".constructor == $wnd." </a> 0
<a> + cType . getJSQualifiedExportName ( ) + " ? " + argName </a> 0
<a> + ".__gwt_instance : " + "(" + argName + ".@java.lang.Object" </a> 0
<a> + "::typeMarker ? " + argName + " : @" </a> 0
<a> + cType . getQualifiedExporterImplementationName ( ) + "::" </a> 0
<a> + "makeClosure(Lcom/google/gwt/core/client/JavaScriptObject;)(" </a> 0
<a> + argName + ")))" ; </a> 0
<a> return value ; </a> 0
<a> } else { </a> 0
<a> return argName + ".__gwt_instance" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return argName ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object o ) { </a> 0
<a> if ( this == o ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( o == null || getClass ( ) != o . getClass ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> JExportableParameter that = ( JExportableParameter ) o ; </a> 0
<a> return getJsTypeOf ( ) . equals ( that . getJsTypeOf ( ) ) ; </a> 0
<a> } </a> 0
<a> public String getJsTypeOf ( ) { </a> 0
<a> if ( param == null ) { </a> 0
<a> return "null" ; </a> 0
<a> } else if ( param . getType ( ) . isArray ( ) != null ) { </a> 0
<a> return "array" ; </a> 0
<a> } else if ( param . getType ( ) . isPrimitive ( ) != null ) { </a> 0
<a> JPrimitiveType prim = param . getType ( ) . isPrimitive ( ) ; </a> 0
<a> return prim == JPrimitiveType . BOOLEAN ? "boolean" : "number" ; </a> 0
<a> } else if ( exportableEnclosingType . getExportableTypeOracle ( ) </a> 0
<a> . isString ( param . getType ( ) ) ) { </a> 0
<a> return "string" ; </a> 0
<a> } else if ( exportableEnclosingType . getExportableTypeOracle ( ) </a> 0
<a> . isJavaScriptObject ( param . getType ( ) ) ) { </a> 0
<a> return "object" ; </a> 0
<a> } else { </a> 0
<a> return "@" + param . getType ( ) . getQualifiedSourceName ( ) + "::class" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return param != null ? getJsTypeOf ( ) . hashCode ( ) : 0 ; </a> 0
<a> } </a> 0
<a> public String toString ( ) { </a> 0
<a> return param . getType ( ) . getSimpleSourceName ( ) ; </a> 0
<a> } </a> 0
<a> public JExportableType getExportableType ( ) { </a> 0
<a> return exportableEnclosingType . getExportableTypeOracle ( ) </a> 0
<a> . findExportableClassType ( getTypeName ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JPrimitiveType ; </a> 0
<a> public class JExportablePrimitiveType implements JExportableType { </a> 0
<a> private ExportableTypeOracle exportableTypeOracle ; </a> 0
<a> private JPrimitiveType primitive ; </a> 0
<a> public JExportablePrimitiveType ( ExportableTypeOracle exportableTypeOracle , </a> 0
<a> JPrimitiveType primitive ) { </a> 0
<a> this . exportableTypeOracle = exportableTypeOracle ; </a> 0
<a> this . primitive = primitive ; </a> 0
<a> } </a> 0
<a> public boolean needsExport ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> public String getQualifiedSourceName ( ) { </a> 0
<a> return primitive . getQualifiedSourceName ( ) ; </a> 0
<a> } </a> 0
<a> public String getHostedModeJsTypeCast ( ) { </a> 0
<a> return primitive . getSimpleSourceName ( ) . equals ( "Boolean" ) ? "Boolean" </a> 0
<a> : "Number" ; </a> 0
<a> } </a> 0
<a> public String getWrapperFunc ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public String getJsTypeOf ( ) { </a> 0
<a> JPrimitiveType prim = primitive . isPrimitive ( ) ; </a> 0
<a> return prim == JPrimitiveType . BOOLEAN ? "boolean" : "number" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> public interface JExportableType { </a> 0
<a> boolean needsExport ( ) ; </a> 0
<a> String getQualifiedSourceName ( ) ; </a> 0
<a> String getHostedModeJsTypeCast ( ) ; </a> 0
<a> String getJsTypeOf ( ) ; </a> 0
<a> String getWrapperFunc ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . timepedia . exporter . rebind ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JMethod ; </a> 0
<a> import com . google . gwt . core . ext . typeinfo . JPrimitiveType ; </a> 0
<a> import org . timepedia . exporter . client . SType ; </a> 0
<a> public class JStructuralTypeField { </a> 0
<a> private JExportableClassType exportableClassType ; </a> 0
<a> private JMethod setterMethod ; </a> 0
<a> public JStructuralTypeField ( JExportableClassType exportableClassType , </a> 0
<a> JMethod setterMethod ) { </a> 0
<a> this . exportableClassType = exportableClassType ; </a> 0
<a> this . setterMethod = setterMethod ; </a> 0
<a> } </a> 0
<a> public String JavaDeclaration ( ) { </a> 0
<a> return setterMethod . getReturnType ( ) . getQualifiedSourceName ( ) + " " </a> 0
<a> + setterMethod . getName ( ) + "(" </a> 0
<a> + setterMethod . getParameters ( ) [ 0 ] . getType ( ) . getQualifiedSourceName ( ) </a> 0
<a> + " arg)" ; </a> 0
<a> } </a> 0
<a> public boolean isVoidReturn ( ) { </a> 0
<a> return setterMethod . getReturnType ( ) . equals ( JPrimitiveType . VOID ) ; </a> 0
<a> } </a> 0
<a> public String getMethodName ( ) { </a> 0
<a> return setterMethod . getName ( ) ; </a> 0
<a> } </a> 0
<a> public String getReturnType ( ) { </a> 0
<a> return setterMethod . getReturnType ( ) . getQualifiedSourceName ( ) ; </a> 0
<a> } </a> 0
<a> public String getFieldValueCast ( ) { </a> 0
<a> return setterMethod . getParameters ( ) [ 0 ] . getType ( ) . isPrimitive ( ) != null ? </a> 0
<a> "(double)" : "(Object)" ; </a> 0
<a> } </a> 0
<a> public String getFieldJSNIType ( ) { </a> 0
<a> return setterMethod . getParameters ( ) [ 0 ] . getType ( ) . isPrimitive ( ) != null ? </a> 0
<a> "D" : "Ljava/lang/Object;" ; </a> 0
<a> } </a> 0
<a> public String getName ( ) { </a> 0
<a> SType st = setterMethod . getAnnotation ( SType . class ) ; </a> 0
<a> if ( st != null ) { </a> 0
<a> return st . value ( ) ; </a> 0
<a> } </a> 0
<a> return beanize ( setterMethod . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> private String beanize ( String name ) { </a> 0
<a> String prop = name . startsWith ( "set" ) ? name . substring ( 3 ) : name ; </a> 0
<a> return Character . toLowerCase ( prop . charAt ( 0 ) ) + prop . substring ( 1 ) ; </a> 0
<a> } </a> 0
<a> public String getFieldLowestType ( ) { </a> 0
<a> JPrimitiveType type = setterMethod . getParameters ( ) [ 0 ] . getType ( ) </a> 0
<a> . isPrimitive ( ) ; </a> 0
<a> return type != null ? type . getQualifiedSourceName ( ) : "Object" ; </a> 0
<a> } </a> 0
<a> public String getFieldType ( ) { </a> 0
<a> return setterMethod . getParameters ( ) [ 0 ] . getType ( ) . getQualifiedSourceName ( ) ; </a> 0
<a> } </a> 0
<a> public JExportableType getExportableType ( ) { </a> 0
<a> return exportableClassType . getExportableTypeOracle ( ) . findExportableType ( getFieldType ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . plugin . jgroups ; </a> 0
<a> import org . atmosphere . util . AbstractBroadcasterProxy ; </a> 0
<a> import org . jgroups . JChannel ; </a> 0
<a> import org . jgroups . Message ; </a> 0
<a> import org . jgroups . ReceiverAdapter ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . concurrent . CountDownLatch ; </a> 0
<a> public class JGroupsBroadcaster extends AbstractBroadcasterProxy { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( JGroupsBroadcaster . class ) ; </a> 0
<a> public static final String CLUSTER_NAME = "atmosphere-cluster" ; </a> 0
<a> private JChannel jchannel ; </a> 0
<a> private final CountDownLatch ready = new CountDownLatch ( 1 ) ; </a> 0
<a> public JGroupsBroadcaster ( ) { </a> 0
<a> this ( JGroupsBroadcaster . class . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> public JGroupsBroadcaster ( String id ) { </a> 0
<a> super ( id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void incomingBroadcast ( ) { </a> 0
<a> try { </a> 0
<a> logger . info ( "Starting Atmosphere JGroups Clustering support with group name {}" , CLUSTER_NAME ) ; </a> 0
<a> jchannel = new JChannel ( ) ; </a> 0
<a> jchannel . setReceiver ( new ReceiverAdapter ( ) { </a> 0
<a> @ Override </a> 0
<a> public void receive ( final Message message ) { </a> 0
<a> final Object msg = message . getObject ( ) ; </a> 0
<a> if ( msg != null && BroadcastMessage . class . isAssignableFrom ( msg . getClass ( ) ) ) { </a> 0
<a> BroadcastMessage b = BroadcastMessage . class . cast ( msg ) ; </a> 0
<a> if ( b . getTopicId ( ) . equalsIgnoreCase ( getID ( ) ) ) { </a> 0
<a> broadcastReceivedMessage ( b . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> jchannel . connect ( CLUSTER_NAME ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "failed to connect to JGroups channel" , t ) ; </a> 0
<a> } finally { </a> 0
<a> ready . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void outgoingBroadcast ( Object message ) { </a> 0
<a> try { </a> 0
<a> ready . await ( ) ; </a> 0
<a> jchannel . send ( new Message ( null , null , new BroadcastMessage ( getID ( ) , message ) ) ) ; </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> logger . error ( "failed to send messge over Jgroups channel" , e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized void destroy ( ) { </a> 0
<a> super . destroy ( ) ; </a> 0
<a> if ( ! jchannel . isOpen ( ) ) return ; </a> 0
<a> jchannel . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> public static class BroadcastMessage implements Serializable { </a> 0
<a> private final String topicId ; </a> 0
<a> private final Object message ; </a> 0
<a> public BroadcastMessage ( String topicId , Object message ) { </a> 0
<a> this . topicId = topicId ; </a> 0
<a> this . message = message ; </a> 0
<a> } </a> 0
<a> public String getTopicId ( ) { </a> 0
<a> return topicId ; </a> 0
<a> } </a> 0
<a> public Object getMessage ( ) { </a> 0
<a> return message ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . plugin . jgroups ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 1
<a> import org . atmosphere . cpr . ClusterBroadcastFilter ; </a> 0
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 1
<a> import org . jgroups . ChannelException ; </a> 0
<a> import org . jgroups . JChannel ; </a> 0
<a> import org . jgroups . Message ; </a> 0
<a> import org . jgroups . ReceiverAdapter ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 1
<a> public class JGroupsFilter extends ReceiverAdapter implements ClusterBroadcastFilter { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( JGroupsFilter . class ) ; </a> 1
<a> private JChannel jchannel ; </a> 1
<a> private Broadcaster bc ; </a> 0
<a> private final ConcurrentLinkedQueue < Object > receivedMessages = new ConcurrentLinkedQueue < Object > ( ) ; </a> 1
<a> public JGroupsFilter ( ) throws InstantiationException , IllegalAccessException { </a> 0
<a> this ( BroadcasterFactory . getDefault ( ) . get ( DefaultBroadcaster . class , "JGroupFilter" ) ) ; </a> 1
<a> } </a> 1
<a> public JGroupsFilter ( Broadcaster bc ) { </a> 1
<a> this . bc = bc ; </a> 1
<a> } </a> 0
<a> public void init ( ) { </a> 1
<a> try { </a> 1
<a> logger . info ( "Starting Atmosphere JGroups Clustering support with group name {}" , JGroupsBroadcaster . CLUSTER_NAME ) ; </a> 0
<a> jchannel = new JChannel ( ) ; </a> 0
<a> jchannel . setReceiver ( this ) ; </a> 0
<a> jchannel . connect ( JGroupsBroadcaster . CLUSTER_NAME ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 1
<a> logger . warn ( "failed to connect to cluser" , t ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> jchannel . shutdown ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void receive ( final Message message ) { </a> 1
<a> final Object msg = message . getObject ( ) ; </a> 1
<a> if ( message . getSrc ( ) != jchannel . getLocalAddress ( ) ) { </a> 1
<a> if ( msg != null ) { </a> 1
<a> if ( msg != null && JGroupsBroadcaster . BroadcastMessage . class . isAssignableFrom ( msg . getClass ( ) ) ) { </a> 1
<a> receivedMessages . offer ( msg ) ; </a> 1
<a> JGroupsBroadcaster . BroadcastMessage b = JGroupsBroadcaster . BroadcastMessage . class . cast ( msg ) ; </a> 1
<a> if ( b . getTopicId ( ) . equalsIgnoreCase ( bc . getID ( ) ) ) { </a> 1
<a> bc . broadcast ( b . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<a> public BroadcastAction filter ( Object originalMessage , Object message ) { </a> 0
<a> if ( ! receivedMessages . remove ( message ) ) { </a> 0
<a> try { </a> 0
<a> jchannel . send ( new Message ( null , null , new JGroupsBroadcaster . BroadcastMessage ( bc . getID ( ) , message ) ) ) ; </a> 1
<a> } catch ( ChannelException e ) { </a> 1
<a> logger . warn ( "failed to send message" , e ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> return new BroadcastAction ( message ) ; </a> 0
<a> } </a> 0
<a> public Broadcaster getBroadcaster ( ) { </a> 0
<a> return bc ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setUri ( String name ) { </a> 1
<a> bc . setID ( name ) ; </a> 1
<a> } </a> 0
<a> public void setBroadcaster ( Broadcaster bc ) { </a> 1
<a> this . bc = bc ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . plugin . jms ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . ClusterBroadcastFilter ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . jms . Connection ; </a> 0
<a> import javax . jms . ConnectionFactory ; </a> 0
<a> import javax . jms . JMSException ; </a> 0
<a> import javax . jms . Message ; </a> 0
<a> import javax . jms . MessageConsumer ; </a> 0
<a> import javax . jms . MessageListener ; </a> 0
<a> import javax . jms . MessageProducer ; </a> 0
<a> import javax . jms . Session ; </a> 0
<a> import javax . jms . TextMessage ; </a> 0
<a> import javax . jms . Topic ; </a> 0
<a> import javax . naming . Context ; </a> 0
<a> import javax . naming . InitialContext ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> public class JMSFilter implements ClusterBroadcastFilter { </a> 0
<a> private static final String JMS_TOPIC = JMSBroadcaster . class . getName ( ) + ".topic" ; </a> 0
<a> private static final String JNDI_NAMESPACE = JMSBroadcaster . class . getName ( ) + ".JNDINamespace" ; </a> 0
<a> private static final String JNDI_FACTORY_NAME = JMSBroadcaster . class . getName ( ) + ".JNDIConnectionFactoryName" ; </a> 0
<a> private static final String JNDI_TOPIC = JMSBroadcaster . class . getName ( ) + ".JNDITopic" ; </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( JMSFilter . class ) ; </a> 0
<a> private Connection connection ; </a> 0
<a> private Session session ; </a> 0
<a> private MessageConsumer consumer ; </a> 0
<a> private MessageProducer publisher ; </a> 0
<a> private String topicId = "atmosphere" ; </a> 0
<a> private String factoryName = "atmosphereFactory" ; </a> 0
<a> private String namespace = "jms/" ; </a> 0
<a> private String clusterName ; </a> 0
<a> private Broadcaster bc = null ; </a> 0
<a> private final ConcurrentLinkedQueue < String > receivedMessages = </a> 0
<a> new ConcurrentLinkedQueue < String > ( ) ; </a> 0
<a> public JMSFilter ( ) { </a> 0
<a> this ( null ) ; </a> 0
<a> } </a> 0
<a> public JMSFilter ( Broadcaster bc ) { </a> 0
<a> this ( bc , "atmosphere-framework" ) ; </a> 0
<a> } </a> 0
<a> public JMSFilter ( Broadcaster bc , String topicId ) { </a> 0
<a> this . bc = bc ; </a> 0
<a> this . topicId = topicId ; </a> 0
<a> } </a> 0
<a> public void setUri ( String clusterName ) { </a> 0
<a> this . clusterName = clusterName ; </a> 0
<a> } </a> 0
<a> public void init ( ) { </a> 0
<a> try { </a> 0
<a> AtmosphereServlet . AtmosphereConfig config = bc . getBroadcasterConfig ( ) . getAtmosphereConfig ( ) ; </a> 0
<a> if ( config != null ) { </a> 0
<a> if ( config . getInitParameter ( JMS_TOPIC ) != null ) { </a> 0
<a> topicId = config . getInitParameter ( JMS_TOPIC ) ; </a> 0
<a> } </a> 0
<a> if ( config . getInitParameter ( JNDI_NAMESPACE ) != null ) { </a> 0
<a> namespace = config . getInitParameter ( JNDI_NAMESPACE ) ; </a> 0
<a> } </a> 0
<a> if ( config . getInitParameter ( JNDI_FACTORY_NAME ) != null ) { </a> 0
<a> factoryName = config . getInitParameter ( JNDI_FACTORY_NAME ) ; </a> 0
<a> } </a> 0
<a> if ( config . getInitParameter ( JNDI_TOPIC ) != null ) { </a> 0
<a> topicId = config . getInitParameter ( JNDI_TOPIC ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> String id = bc . getID ( ) ; </a> 0
<a> if ( id . startsWith ( "/*" ) ) { </a> 0
<a> id = "atmosphere" ; </a> 0
<a> } </a> 0
<a> logger . info ( String . format ( "Looking up Connection Factory %s" , namespace + factoryName ) ) ; </a> 0
<a> Context ctx = new InitialContext ( ) ; </a> 0
<a> ConnectionFactory connectionFactory = ( ConnectionFactory ) ctx . lookup ( namespace + factoryName ) ; </a> 0
<a> logger . info ( String . format ( "Looking up topic: %s" , topicId ) ) ; </a> 0
<a> Topic topic = ( Topic ) ctx . lookup ( namespace + topicId ) ; </a> 0
<a> connection = connectionFactory . createConnection ( ) ; </a> 0
<a> session = connection . createSession ( false , Session . AUTO_ACKNOWLEDGE ) ; </a> 0
<a> logger . info ( String . format ( "Create customer: %s" , id ) ) ; </a> 0
<a> String selector = String . format ( "BroadcasterId = '%s'" , id ) ; </a> 0
<a> consumer = session . createConsumer ( topic , selector ) ; </a> 0
<a> consumer . setMessageListener ( new MessageListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onMessage ( Message msg ) { </a> 0
<a> try { </a> 0
<a> TextMessage textMessage = ( TextMessage ) msg ; </a> 0
<a> String message = textMessage . getText ( ) ; </a> 0
<a> if ( message != null && bc != null ) { </a> 0
<a> receivedMessages . offer ( message ) ; </a> 0
<a> bc . broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> } catch ( JMSException ex ) { </a> 0
<a> logger . warn ( "" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> publisher = session . createProducer ( topic ) ; </a> 0
<a> connection . start ( ) ; </a> 0
<a> logger . info ( String . format ( "JMS created for topic %s, with filter %s" , topicId , selector ) ) ; </a> 0
<a> } catch ( Throwable ex ) { </a> 0
<a> throw new IllegalStateException ( "Unable to initialize JMSBroadcaster" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public BroadcastAction filter ( Object originalMessage , Object o ) { </a> 0
<a> if ( o instanceof String ) { </a> 0
<a> String message = ( String ) o ; </a> 0
<a> if ( ! receivedMessages . remove ( message ) ) { </a> 0
<a> try { </a> 0
<a> String id = bc . getID ( ) ; </a> 0
<a> if ( id . startsWith ( "/*" ) ) { </a> 0
<a> id = "atmosphere" ; </a> 0
<a> } </a> 0
<a> TextMessage textMessage = session . createTextMessage ( message . toString ( ) ) ; </a> 0
<a> textMessage . setStringProperty ( "BroadcasterId" , id ) ; </a> 0
<a> publisher . send ( textMessage ) ; </a> 0
<a> } catch ( JMSException ex ) { </a> 0
<a> logger . warn ( "failed to publish message" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return new BroadcastAction ( message ) ; </a> 0
<a> } else { </a> 0
<a> return new BroadcastAction ( o ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Broadcaster getBroadcaster ( ) { </a> 0
<a> return bc ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBroadcaster ( Broadcaster bc ) { </a> 0
<a> this . bc = bc ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . plugin . redis ; </a> 0
<a> import org . apache . commons . pool . impl . GenericObjectPool ; </a> 0
<a> import org . atmosphere . util . AbstractBroadcasterProxy ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import redis . clients . jedis . Jedis ; </a> 0
<a> import redis . clients . jedis . JedisException ; </a> 1
<a> import redis . clients . jedis . JedisPool ; </a> 0
<a> import redis . clients . jedis . JedisPubSub ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> import java . net . URI ; </a> 0
<a> public class RedisBroadcaster extends AbstractBroadcasterProxy { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( RedisBroadcaster . class ) ; </a> 0
<a> private static final String REDIS_AUTH = RedisBroadcaster . class . getName ( ) + ".authorization" ; </a> 0
<a> private static final String REDIS_SERVER = RedisBroadcaster . class . getName ( ) + ".server" ; </a> 0
<a> private static final String REDIS_SHARED_POOL = RedisBroadcaster . class . getName ( ) + ".sharedPool" ; </a> 0
<a> private Jedis jedisSubscriber ; </a> 0
<a> private Jedis jedisPublisher ; </a> 0
<a> private URI uri ; </a> 0
<a> private String authToken = null ; </a> 0
<a> private boolean sharedPool = false ; </a> 0
<a> private JedisPool jedisPool ; </a> 0
<a> public RedisBroadcaster ( ) { </a> 0
<a> this ( RedisBroadcaster . class . getSimpleName ( ) , URI . create ( "http://localhost:6379" ) ) ; </a> 0
<a> } </a> 0
<a> public RedisBroadcaster ( String id ) { </a> 0
<a> this ( id , URI . create ( "http://localhost:6379" ) ) ; </a> 0
<a> } </a> 0
<a> public RedisBroadcaster ( URI uri ) { </a> 0
<a> this ( RedisBroadcaster . class . getSimpleName ( ) , uri ) ; </a> 0
<a> } </a> 0
<a> public RedisBroadcaster ( String id , URI uri ) { </a> 0
<a> super ( id ) ; </a> 0
<a> this . uri = uri ; </a> 0
<a> } </a> 0
<a> public String getAuth ( ) { </a> 0
<a> return authToken ; </a> 0
<a> } </a> 0
<a> public void setAuth ( String auth ) { </a> 0
<a> authToken = auth ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void start ( ) { </a> 0
<a> super . start ( ) ; </a> 0
<a> } </a> 0
<a> public synchronized void setUp ( ) { </a> 0
<a> if ( uri == null ) return ; </a> 0
<a> if ( config != null ) { </a> 0
<a> if ( config . getServletConfig ( ) . getInitParameter ( REDIS_AUTH ) != null ) { </a> 0
<a> authToken = config . getServletConfig ( ) . getInitParameter ( REDIS_AUTH ) ; </a> 0
<a> } </a> 0
<a> if ( config . getServletConfig ( ) . getInitParameter ( REDIS_SERVER ) != null ) { </a> 0
<a> uri = URI . create ( config . getServletConfig ( ) . getInitParameter ( REDIS_SERVER ) ) ; </a> 0
<a> } </a> 0
<a> if ( config . getServletConfig ( ) . getInitParameter ( REDIS_SHARED_POOL ) != null ) { </a> 0
<a> sharedPool = Boolean . parseBoolean ( config . getServletConfig ( ) . getInitParameter ( REDIS_SHARED_POOL ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> logger . info ( "{} shared connection pool {}" , getClass ( ) . getName ( ) , sharedPool ) ; </a> 0
<a> if ( sharedPool ) { </a> 0
<a> if ( config . properties ( ) . get ( REDIS_SHARED_POOL ) != null ) { </a> 0
<a> jedisPool = ( JedisPool ) config . properties ( ) . get ( REDIS_SHARED_POOL ) ; </a> 0
<a> } </a> 0
<a> if ( jedisPool == null ) { </a> 0
<a> GenericObjectPool . Config gConfig = new GenericObjectPool . Config ( ) ; </a> 0
<a> gConfig . testOnBorrow = true ; </a> 0
<a> gConfig . testWhileIdle = true ; </a> 0
<a> jedisPool = new JedisPool ( gConfig , uri . getHost ( ) , uri . getPort ( ) ) ; </a> 0
<a> config . properties ( ) . put ( REDIS_SHARED_POOL , jedisPool ) ; </a> 0
<a> } else { </a> 0
<a> if ( jedisPublisher != null ) { </a> 1
<a> jedisPool . returnResource ( jedisPublisher ) ; </a> 1
<a> } </a> 1
<a> if ( jedisSubscriber != null ) { </a> 0
<a> disconnectSubscriber ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> jedisSubscriber = sharedPool ? jedisPool . getResource ( ) : new Jedis ( uri . getHost ( ) , uri . getPort ( ) ) ; </a> 0
<a> try { </a> 0
<a> jedisSubscriber . connect ( ) ; </a> 0
<a> if ( authToken != null ) { </a> 0
<a> jedisSubscriber . auth ( authToken ) ; </a> 0
<a> } </a> 0
<a> jedisSubscriber . flushAll ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> logger . error ( "failed to connect subscriber" , e ) ; </a> 0
<a> try { </a> 0
<a> jedisSubscriber . disconnect ( ) ; </a> 0
<a> } catch ( IOException e1 ) { </a> 0
<a> logger . error ( "failed to disconnect subscriber" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> jedisPublisher = sharedPool ? jedisPool . getResource ( ) : new Jedis ( uri . getHost ( ) , uri . getPort ( ) ) ; </a> 0
<a> try { </a> 0
<a> jedisPublisher . connect ( ) ; </a> 0
<a> if ( authToken != null ) { </a> 0
<a> jedisPublisher . auth ( authToken ) ; </a> 0
<a> } </a> 0
<a> jedisPublisher . flushAll ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> logger . error ( "failed to connect publisher" , e ) ; </a> 0
<a> try { </a> 0
<a> jedisPublisher . disconnect ( ) ; </a> 0
<a> } catch ( IOException e1 ) { </a> 0
<a> logger . error ( "failed to disconnect publisher" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized void setID ( String id ) { </a> 0
<a> super . setID ( id ) ; </a> 0
<a> disconnectPublisher ( ) ; </a> 0
<a> disconnectSubscriber ( ) ; </a> 0
<a> setUp ( ) ; </a> 0
<a> reconfigure ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void destroy ( ) { </a> 0
<a> super . destroy ( ) ; </a> 0
<a> try { </a> 0
<a> disconnectPublisher ( ) ; </a> 0
<a> disconnectSubscriber ( ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Jedis error on close" , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void incomingBroadcast ( ) { </a> 0
<a> logger . info ( "Subscribing to: {}" , getID ( ) ) ; </a> 0
<a> jedisSubscriber . subscribe ( new JedisPubSub ( ) { </a> 0
<a> public void onMessage ( String channel , String message ) { </a> 0
<a> broadcastReceivedMessage ( message ) ; </a> 0
<a> } </a> 0
<a> public void onSubscribe ( String channel , int subscribedChannels ) { </a> 0
<a> logger . debug ( "onSubscribe: {}" , channel ) ; </a> 0
<a> } </a> 0
<a> public void onUnsubscribe ( String channel , int subscribedChannels ) { </a> 0
<a> logger . debug ( "onUnsubscribe: {}" , channel ) ; </a> 0
<a> } </a> 0
<a> public void onPSubscribe ( String pattern , int subscribedChannels ) { </a> 0
<a> logger . debug ( "onPSubscribe: {}" , pattern ) ; </a> 0
<a> } </a> 0
<a> public void onPUnsubscribe ( String pattern , int subscribedChannels ) { </a> 0
<a> logger . debug ( "onPUnsubscribe: {}" , pattern ) ; </a> 0
<a> } </a> 0
<a> public void onPMessage ( String pattern , String channel , String message ) { </a> 0
<a> logger . debug ( "onPMessage: {}" , pattern + " " + channel + " " + message ) ; </a> 1
<a> } </a> 0
<a> } , getID ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void outgoingBroadcast ( Object message ) { </a> 0
<a> synchronized ( jedisPublisher ) { </a> 0
<a> try { </a> 0
<a> jedisPublisher . publish ( getID ( ) , message . toString ( ) ) ; </a> 1
<a> } catch ( JedisException e ) { </a> 0
<a> logger . warn ( "outgoingBroadcast exception, retrying a connection" , e ) ; </a> 0
<a> jedisPublisher = sharedPool ? jedisPool . getResource ( ) : new Jedis ( uri . getHost ( ) , uri . getPort ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void disconnectSubscriber ( ) { </a> 0
<a> if ( jedisSubscriber == null ) return ; </a> 0
<a> synchronized ( jedisSubscriber ) { </a> 0
<a> try { </a> 0
<a> jedisSubscriber . disconnect ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> logger . error ( "failed to disconnect subscriber" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void disconnectPublisher ( ) { </a> 0
<a> if ( jedisPublisher == null ) return ; </a> 0
<a> synchronized ( jedisPublisher ) { </a> 0
<a> try { </a> 0
<a> jedisPublisher . disconnect ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> logger . error ( "failed to disconnect publisher" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . plugin . redis ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . ClusterBroadcastFilter ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import redis . clients . jedis . Jedis ; </a> 0
<a> import redis . clients . jedis . JedisPubSub ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> import java . net . URI ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import java . util . concurrent . ExecutorService ; </a> 0
<a> import java . util . concurrent . Executors ; </a> 0
<a> public class RedisFilter implements ClusterBroadcastFilter { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( RedisFilter . class ) ; </a> 0
<a> private Broadcaster bc ; </a> 0
<a> private final ExecutorService listener = Executors . newSingleThreadExecutor ( ) ; </a> 0
<a> private final ConcurrentLinkedQueue < String > receivedMessages = new ConcurrentLinkedQueue < String > ( ) ; </a> 0
<a> private Jedis jedisSubscriber ; </a> 0
<a> private Jedis jedisPublisher ; </a> 0
<a> private URI uri ; </a> 0
<a> private String auth = "atmosphere" ; </a> 0
<a> public RedisFilter ( ) { </a> 0
<a> this ( RedisFilter . class . getSimpleName ( ) , URI . create ( "http://localhost:6379" ) ) ; </a> 0
<a> } </a> 0
<a> public RedisFilter ( String id ) { </a> 0
<a> this ( id , URI . create ( "http://localhost:6379" ) ) ; </a> 0
<a> } </a> 0
<a> public RedisFilter ( URI uri ) { </a> 0
<a> this ( RedisFilter . class . getSimpleName ( ) , uri ) ; </a> 0
<a> } </a> 0
<a> public RedisFilter ( String id , URI uri ) { </a> 0
<a> this . uri = uri ; </a> 0
<a> } </a> 0
<a> public RedisFilter ( Broadcaster bc , String address ) { </a> 0
<a> this . bc = bc ; </a> 0
<a> uri = URI . create ( address ) ; </a> 0
<a> if ( uri == null ) return ; </a> 0
<a> jedisSubscriber = new Jedis ( uri . getHost ( ) , uri . getPort ( ) ) ; </a> 0
<a> try { </a> 0
<a> jedisSubscriber . connect ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> logger . error ( "failed to connect to subscriber: " + jedisSubscriber , e ) ; </a> 1
<a> } </a> 0
<a> jedisSubscriber . auth ( auth ) ; </a> 1
<a> jedisSubscriber . flushAll ( ) ; </a> 1
<a> jedisPublisher = new Jedis ( uri . getHost ( ) , uri . getPort ( ) ) ; </a> 0
<a> try { </a> 0
<a> jedisPublisher . connect ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> logger . error ( "failed to connect to publisher: " + jedisPublisher , e ) ; </a> 1
<a> } </a> 0
<a> jedisPublisher . auth ( auth ) ; </a> 1
<a> jedisPublisher . flushAll ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setUri ( String address ) { </a> 0
<a> uri = URI . create ( address ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void init ( ) { </a> 0
<a> logger . info ( "Starting Atmosphere Redis Clustering support" ) ; </a> 0
<a> final Broadcaster broadcaster = bc ; </a> 0
<a> listener . submit ( new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> jedisSubscriber . subscribe ( new JedisPubSub ( ) { </a> 0
<a> public void onMessage ( String channel , String message ) { </a> 0
<a> receivedMessages . offer ( message ) ; </a> 0
<a> broadcaster . broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> public void onSubscribe ( String channel , int subscribedChannels ) { </a> 0
<a> logger . debug ( "onSubscribe(): channel: {}" , channel ) ; </a> 0
<a> } </a> 0
<a> public void onUnsubscribe ( String channel , int subscribedChannels ) { </a> 0
<a> logger . debug ( "onUnsubscribe(): channel: {}" , channel ) ; </a> 0
<a> } </a> 0
<a> public void onPSubscribe ( String pattern , int subscribedChannels ) { </a> 0
<a> logger . debug ( "onPSubscribe(): pattern: {}" , pattern ) ; </a> 0
<a> } </a> 0
<a> public void onPUnsubscribe ( String pattern , int subscribedChannels ) { </a> 0
<a> logger . debug ( "onPUnsubscribe(): pattern: {}" , pattern ) ; </a> 0
<a> } </a> 0
<a> public void onPMessage ( String pattern , String channel , String message ) { </a> 0
<a> logger . debug ( "onPMessage: pattern: {}, channel: {}, message: {}" , </a> 0
<a> new Object [ ] { pattern , channel , message } ) ; </a> 0
<a> } </a> 0
<a> } , bc . getID ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void destroy ( ) { </a> 0
<a> listener . shutdownNow ( ) ; </a> 0
<a> try { </a> 0
<a> jedisPublisher . disconnect ( ) ; </a> 0
<a> jedisSubscriber . disconnect ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> logger . error ( "failure encountered during destroy" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public BroadcastFilter . BroadcastAction filter ( Object originalMessage , Object o ) { </a> 0
<a> if ( ! ( receivedMessages . remove ( originalMessage . toString ( ) ) ) ) { </a> 1
<a> jedisPublisher . publish ( bc . getID ( ) , originalMessage . toString ( ) ) ; </a> 1
<a> } </a> 0
<a> return new BroadcastFilter . BroadcastAction ( BroadcastAction . ACTION . CONTINUE , o ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Broadcaster getBroadcaster ( ) { </a> 0
<a> return bc ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBroadcaster ( Broadcaster bc ) { </a> 0
<a> this . bc = bc ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . plugin . xmpp ; </a> 0
<a> import org . atmosphere . util . AbstractBroadcasterProxy ; </a> 0
<a> import org . jivesoftware . smack . Chat ; </a> 0
<a> import org . jivesoftware . smack . ConnectionConfiguration ; </a> 0
<a> import org . jivesoftware . smack . MessageListener ; </a> 0
<a> import org . jivesoftware . smack . SASLAuthentication ; </a> 0
<a> import org . jivesoftware . smack . XMPPConnection ; </a> 0
<a> import org . jivesoftware . smack . XMPPException ; </a> 0
<a> import org . jivesoftware . smack . packet . Message ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import java . net . URI ; </a> 0
<a> public class XMPPBroadcaster extends AbstractBroadcasterProxy { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( XMPPBroadcaster . class ) ; </a> 0
<a> private static final String XMPP_AUTH = XMPPBroadcaster . class . getName ( ) + ".authorization" ; </a> 0
<a> private static final String XMPP_SERVER = XMPPBroadcaster . class . getName ( ) + ".server" ; </a> 0
<a> private static final String XMPP_DEBUG = XMPPBroadcaster . class . getName ( ) + ".debug" ; </a> 0
<a> private URI uri ; </a> 0
<a> private String authToken ; </a> 0
<a> private XMPPConnection xmppConnection ; </a> 0
<a> private Chat channel ; </a> 0
<a> public XMPPBroadcaster ( ) { </a> 0
<a> this ( "atmosphere" , URI . create ( "http://gmail.com" ) ) ; </a> 0
<a> } </a> 0
<a> public XMPPBroadcaster ( String id ) { </a> 0
<a> this ( id , URI . create ( "http://gmail.com" ) ) ; </a> 0
<a> } </a> 0
<a> public XMPPBroadcaster ( URI uri ) { </a> 0
<a> this ( XMPPBroadcaster . class . getSimpleName ( ) , uri ) ; </a> 0
<a> } </a> 0
<a> public XMPPBroadcaster ( String id , URI uri ) { </a> 0
<a> super ( id ) ; </a> 0
<a> this . uri = uri ; </a> 0
<a> } </a> 0
<a> private synchronized void setUp ( ) { </a> 0
<a> if ( uri == null ) return ; </a> 0
<a> try { </a> 0
<a> if ( config != null ) { </a> 0
<a> if ( config . getServletConfig ( ) . getInitParameter ( XMPP_AUTH ) != null ) { </a> 0
<a> authToken = config . getServletConfig ( ) . getInitParameter ( XMPP_AUTH ) ; </a> 0
<a> } else { </a> 0
<a> throw new IllegalStateException ( "No authorization token specified. Please make sure your web.xml contains:" + </a> 0
<a> "\n <init-param>\n" + </a> 0
<a> " <param-name>org.atmosphere.plugin.xmpp.XMPPBroadcaster.authorization</param-name>\n" + </a> 0
<a> " <param-value>principal:password</param-value>\n" + </a> 0
<a> " </init-param>" ) ; </a> 0
<a> } </a> 0
<a> if ( config . getServletConfig ( ) . getInitParameter ( XMPP_SERVER ) != null ) { </a> 0
<a> uri = URI . create ( config . getServletConfig ( ) . getInitParameter ( XMPP_SERVER ) ) ; </a> 0
<a> } </a> 0
<a> if ( config . getServletConfig ( ) . getInitParameter ( XMPP_DEBUG ) != null ) { </a> 0
<a> XMPPConnection . DEBUG_ENABLED = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ConnectionConfiguration config = null ; </a> 0
<a> int port = - 1 ; </a> 0
<a> try { </a> 0
<a> port = uri . getPort ( ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> ; </a> 0
<a> } </a> 0
<a> if ( port == - 1 ) { </a> 0
<a> config = new ConnectionConfiguration ( uri . getHost ( ) ) ; </a> 0
<a> } else { </a> 0
<a> config = new ConnectionConfiguration ( uri . getHost ( ) , port ) ; </a> 0
<a> } </a> 0
<a> xmppConnection = new XMPPConnection ( config ) ; </a> 0
<a> xmppConnection . connect ( ) ; </a> 0
<a> SASLAuthentication . supportSASLMechanism ( "PLAIN" , 0 ) ; </a> 0
<a> String [ ] credentials = authToken . split ( ":" ) ; </a> 0
<a> xmppConnection . login ( credentials [ 0 ] , credentials [ 1 ] , getID ( ) ) ; </a> 0
<a> logger . info ( "Subscribing to: " + getID ( ) ) ; </a> 0
<a> channel = xmppConnection . getChatManager ( ) . createChat ( getID ( ) , new MessageListener ( ) { </a> 0
<a> public void processMessage ( Chat chat , Message message ) { </a> 0
<a> broadcastReceivedMessage ( message . getBody ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> logger . info ( "Connected to: " + getID ( ) ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> throw new RuntimeException ( t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setID ( String id ) { </a> 0
<a> super . setID ( id ) ; </a> 0
<a> setUp ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void destroy ( ) { </a> 0
<a> super . destroy ( ) ; </a> 0
<a> synchronized ( xmppConnection ) { </a> 0
<a> if ( xmppConnection != null ) { </a> 0
<a> xmppConnection . disconnect ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void incomingBroadcast ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void outgoingBroadcast ( Object message ) { </a> 0
<a> if ( message instanceof String ) { </a> 0
<a> try { </a> 0
<a> channel . sendMessage ( message . toString ( ) ) ; </a> 0
<a> } catch ( XMPPException e ) { </a> 0
<a> logger . debug ( "failed to send message on channel" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . annotation ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( { ElementType . METHOD } ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> public @ interface Broadcast { </a> 0
<a> public Class < ? extends BroadcastFilter > [ ] value ( ) default { } ; </a> 0
<a> public boolean resumeOnBroadcast ( ) default false ; </a> 0
<a> public int delay ( ) default - 1 ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . annotation ; </a> 0
<a> import java . lang . annotation . Documented ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( { ElementType . METHOD } ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> @ Documented </a> 0
<a> public @ interface Resume { </a> 0
<a> int value ( ) default 1 ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . annotation ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( { ElementType . METHOD } ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> public @ interface Schedule { </a> 0
<a> public int period ( ) default 60 ; </a> 0
<a> public int waitFor ( ) default 0 ; </a> 0
<a> public boolean resumeOnBroadcast ( ) default false ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . annotation ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import java . lang . annotation . Documented ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> @ Target ( { ElementType . METHOD } ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> @ Documented </a> 0
<a> public @ interface Subscribe { </a> 0
<a> String value ( ) ; </a> 0
<a> public Class < ? extends AtmosphereResourceEventListener > [ ] listeners ( ) default { } ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . annotation ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import java . lang . annotation . Documented ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> @ Target ( { ElementType . METHOD } ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> @ Documented </a> 0
<a> public @ interface Suspend { </a> 0
<a> int period ( ) default - 1 ; </a> 0
<a> TimeUnit timeUnit ( ) default TimeUnit . MILLISECONDS ; </a> 0
<a> enum SCOPE { </a> 0
<a> REQUEST , APPLICATION , VM </a> 0
<a> } </a> 0
<a> SCOPE scope ( ) default SCOPE . APPLICATION ; </a> 0
<a> boolean outputComments ( ) default true ; </a> 0
<a> public boolean resumeOnBroadcast ( ) default false ; </a> 0
<a> public Class < ? extends AtmosphereResourceEventListener > [ ] listeners ( ) default { } ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . jboss . servlet . http ; </a> 0
<a> import javax . servlet . Servlet ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> public interface HttpEventServlet extends Servlet { </a> 0
<a> public void event ( HttpEvent event ) </a> 0
<a> throws IOException , ServletException ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . eclipse . jetty . websocket ; </a> 1
<a> import java . io . IOException ; </a> 1
<a> public interface WebSocket { </a> 1
<a> public final byte LENGTH_FRAME = ( byte ) 0x80 ; </a> 1
<a> public final byte SENTINEL_FRAME = ( byte ) 0x00 ; </a> 1
<a> void onConnect ( Outbound outbound ) ; </a> 1
<a> void onMessage ( byte frame , String data ) ; </a> 1
<a> void onMessage ( byte frame , byte [ ] data , int offset , int length ) ; </a> 1
<a> void onFragment ( boolean more , byte opcode , byte [ ] data , int offset , int length ) ; </a> 1
<a> void onDisconnect ( ) ; </a> 1
<a> public interface Outbound { </a> 1
<a> void sendMessage ( byte frame , String data ) throws IOException ; </a> 1
<a> void sendMessage ( byte frame , byte [ ] data ) throws IOException ; </a> 1
<a> void sendMessage ( byte frame , byte [ ] data , int offset , int length ) throws IOException ; </a> 1
<a> void disconnect ( ) ; </a> 1
<a> boolean isOpen ( ) ; </a> 1
<a> } </a> 1
<a> void onOpen ( Connection connection ) ; </a> 1
<a> void onClose ( int closeCode , String message ) ; </a> 1
<a> interface OnTextMessage extends WebSocket { </a> 1
<a> void onMessage ( String data ) ; </a> 1
<a> } </a> 1
<a> interface OnBinaryMessage extends WebSocket { </a> 1
<a> void onMessage ( byte [ ] data , int offset , int length ) ; </a> 1
<a> } </a> 1
<a> interface OnControl extends WebSocket { </a> 1
<a> boolean onControl ( byte controlCode , byte [ ] data , int offset , int length ) ; </a> 1
<a> } </a> 1
<a> interface OnFrame extends WebSocket { </a> 1
<a> boolean onFrame ( byte flags , byte opcode , byte [ ] data , int offset , int length ) ; </a> 1
<a> void onHandshake ( FrameConnection connection ) ; </a> 1
<a> } </a> 1
<a> public interface Connection { </a> 1
<a> String getProtocol ( ) ; </a> 1
<a> void sendMessage ( String data ) throws IOException ; </a> 1
<a> void sendMessage ( byte [ ] data , int offset , int length ) throws IOException ; </a> 1
<a> void disconnect ( ) ; </a> 1
<a> boolean isOpen ( ) ; </a> 1
<a> void setMaxTextMessageSize ( int size ) ; </a> 1
<a> void setMaxBinaryMessageSize ( int size ) ; </a> 1
<a> int getMaxTextMessageSize ( ) ; </a> 1
<a> int getMaxBinaryMessageSize ( ) ; </a> 1
<a> } </a> 1
<a> public interface FrameConnection extends Connection { </a> 1
<a> boolean isMessageComplete ( byte flags ) ; </a> 1
<a> void close ( int closeCode , String message ) ; </a> 1
<a> byte binaryOpcode ( ) ; </a> 1
<a> byte textOpcode ( ) ; </a> 1
<a> byte continuationOpcode ( ) ; </a> 1
<a> byte finMask ( ) ; </a> 1
<a> boolean isControl ( byte opcode ) ; </a> 1
<a> boolean isText ( byte opcode ) ; </a> 1
<a> boolean isBinary ( byte opcode ) ; </a> 1
<a> boolean isContinuation ( byte opcode ) ; </a> 1
<a> boolean isClose ( byte opcode ) ; </a> 1
<a> boolean isPing ( byte opcode ) ; </a> 1
<a> boolean isPong ( byte opcode ) ; </a> 1
<a> void sendControl ( byte control , byte [ ] data , int offset , int length ) throws IOException ; </a> 1
<a> void sendFrame ( byte flags , byte opcode , byte [ ] data , int offset , int length ) throws IOException ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . eclipse . jetty . websocket ; </a> 1
<a> import org . eclipse . jetty . util . log . Log ; </a> 1
<a> import org . eclipse . jetty . util . log . Logger ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 1
<a> import javax . servlet . http . HttpServletResponse ; </a> 1
<a> import java . io . IOException ; </a> 1
<a> import java . util . HashMap ; </a> 1
<a> import java . util . List ; </a> 1
<a> import java . util . Map ; </a> 1
<a> public class WebSocketFactory { </a> 1
<a> private static final Logger LOG = Log . getLogger ( WebSocketFactory . class ) ; </a> 1
<a> public interface Acceptor { </a> 1
<a> WebSocket doWebSocketConnect ( HttpServletRequest request , String protocol ) ; </a> 1
<a> boolean checkOrigin ( HttpServletRequest request , String origin ) ; </a> 1
<a> } </a> 1
<a> private final Map < String , Class < ? extends Extension > > _extensionClasses = new HashMap < String , Class < ? extends Extension > > ( ) ; </a> 1
<a> { </a> 1
<a> } </a> 1
<a> public WebSocketFactory ( Acceptor acceptor ) { </a> 1
<a> } </a> 1
<a> public WebSocketFactory ( Acceptor acceptor , int bufferSize ) { </a> 1
<a> } </a> 1
<a> public Map < String , Class < ? extends Extension > > getExtensionClassesMap ( ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public long getMaxIdleTime ( ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public void setMaxIdleTime ( int maxIdleTime ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public int getBufferSize ( ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public void setBufferSize ( int bufferSize ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public int getMaxTextMessageSize ( ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public void setMaxTextMessageSize ( int maxTextMessageSize ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public int getMaxBinaryMessageSize ( ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public void setMaxBinaryMessageSize ( int maxBinaryMessageSize ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public void upgrade ( HttpServletRequest request , HttpServletResponse response , WebSocket websocket , String protocol ) </a> 1
<a> throws IOException { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> protected String [ ] parseProtocols ( String protocol ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public boolean acceptWebSocket ( HttpServletRequest request , HttpServletResponse response ) </a> 1
<a> throws IOException { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> public List < Extension > initExtensions ( List < String > requested , int maxDataOpcodes , int maxControlOpcodes , int maxReservedBits ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> private Extension newExtension ( String name ) { </a> 1
<a> throw new UnsupportedOperationException ( "Please remove the atmosphere-compat-jetty from your classpath" ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . eclipse . jetty . websocket ; </a> 1
<a> import javax . servlet . http . HttpServlet ; </a> 1
<a> public abstract class WebSocketServlet extends HttpServlet { </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . apache . catalina ; </a> 0
<a> import javax . servlet . ServletException ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 1
<a> import javax . servlet . http . HttpServletResponse ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> public interface CometEvent { </a> 0
<a> public enum EventType { </a> 0
<a> BEGIN , READ , END , ERROR </a> 0
<a> } </a> 0
<a> public enum EventSubType { </a> 0
<a> TIMEOUT , CLIENT_DISCONNECT , IOEXCEPTION , WEBAPP_RELOAD , SERVER_SHUTDOWN , SESSION_END </a> 0
<a> } </a> 0
<a> public HttpServletRequest getHttpServletRequest ( ) ; </a> 0
<a> public HttpServletResponse getHttpServletResponse ( ) ; </a> 0
<a> public EventType getEventType ( ) ; </a> 0
<a> public EventSubType getEventSubType ( ) ; </a> 0
<a> public void close ( ) throws IOException ; </a> 0
<a> public void setTimeout ( int timeout ) </a> 0
<a> throws IOException , ServletException , UnsupportedOperationException ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . apache . catalina . comet ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> public interface CometEvent { </a> 0
<a> public enum EventType { </a> 0
<a> BEGIN , READ , END , ERROR </a> 0
<a> } </a> 0
<a> public enum EventSubType { </a> 0
<a> TIMEOUT , CLIENT_DISCONNECT , IOEXCEPTION , WEBAPP_RELOAD , SERVER_SHUTDOWN , SESSION_END </a> 0
<a> } </a> 0
<a> public HttpServletRequest getHttpServletRequest ( ) ; </a> 0
<a> public HttpServletResponse getHttpServletResponse ( ) ; </a> 0
<a> public EventType getEventType ( ) ; </a> 0
<a> public EventSubType getEventSubType ( ) ; </a> 0
<a> public void close ( ) throws IOException ; </a> 0
<a> public void setTimeout ( int timeout ) </a> 0
<a> throws IOException , ServletException , UnsupportedOperationException ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . apache . catalina . comet ; </a> 0
<a> import javax . servlet . Servlet ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> public interface CometProcessor extends Servlet { </a> 0
<a> public void event ( CometEvent event ) </a> 0
<a> throws IOException , ServletException ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package weblogic . servlet . http ; </a> 0
<a> import org . eclipse . jetty . websocket . WebSocketServlet ; </a> 1
<a> import javax . servlet . ServletException ; </a> 1
<a> import java . io . IOException ; </a> 1
<a> public abstract class AbstractAsyncServlet extends WebSocketServlet { </a> 1
<a> protected abstract boolean doRequest ( RequestResponseKey rrk ) </a> 1
<a> throws IOException , ServletException ; </a> 1
<a> protected abstract void doResponse ( RequestResponseKey rrk , Object o ) </a> 1
<a> throws IOException , ServletException ; </a> 1
<a> protected abstract void doTimeout ( RequestResponseKey rrk ) </a> 1
<a> throws IOException , ServletException ; </a> 1
<a> public final static void notify ( RequestResponseKey rrk , Object context ) throws IOException { </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cache ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 1
<a> import org . atmosphere . cpr . BroadcasterCache ; </a> 1
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . Serializable ; </a> 1
<a> import java . util . ArrayList ; </a> 1
<a> import java . util . Iterator ; </a> 1
<a> import java . util . List ; </a> 1
<a> import java . util . concurrent . CopyOnWriteArrayList ; </a> 1
<a> import java . util . concurrent . Executors ; </a> 1
<a> import java . util . concurrent . ScheduledExecutorService ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 1
<a> public abstract class BroadcasterCacheBase implements BroadcasterCache < HttpServletRequest , HttpServletResponse > { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( BroadcasterCacheBase . class ) ; </a> 1
<a> protected final List < CachedMessage > queue = new CopyOnWriteArrayList < CachedMessage > ( ) ; </a> 1
<a> protected final ScheduledExecutorService reaper = Executors . newSingleThreadScheduledExecutor ( ) ; </a> 1
<a> protected int maxCachedinMs = 1000 * 5 * 60 ; </a> 1
<a> public BroadcasterCacheBase ( ) { </a> 1
<a> } </a> 1
<a> public final void start ( ) { </a> 1
<a> reaper . scheduleAtFixedRate ( new Runnable ( ) { </a> 1
<a> public void run ( ) { </a> 1
<a> Iterator < CachedMessage > i = queue . iterator ( ) ; </a> 1
<a> CachedMessage message ; </a> 1
<a> while ( i . hasNext ( ) ) { </a> 1
<a> message = i . next ( ) ; </a> 1
<a> logger . debug ( "Message: {}" , message . message ( ) ) ; </a> 0
<a> if ( System . currentTimeMillis ( ) - message . currentTime ( ) > maxCachedinMs ) { </a> 1
<a> logger . debug ( "Pruning: {}" , message . message ( ) ) ; </a> 0
<a> queue . remove ( message ) ; </a> 1
<a> } else { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } , 0 , 60 , TimeUnit . SECONDS ) ; </a> 1
<a> } </a> 1
<a> public final void stop ( ) { </a> 1
<a> reaper . shutdown ( ) ; </a> 1
<a> } </a> 1
<a> public final synchronized void addToCache ( </a> 1
<a> final AtmosphereResource < HttpServletRequest , HttpServletResponse > resource , final Object object ) { </a> 0
<a> logger . debug ( "Adding message for resource: {}, object: {}" , resource , object ) ; </a> 0
<a> CachedMessage cm = new CachedMessage ( object , System . currentTimeMillis ( ) , null ) ; </a> 1
<a> CachedMessage prev = null ; </a> 1
<a> if ( ! queue . isEmpty ( ) ) { </a> 1
<a> prev = queue . get ( queue . size ( ) - 1 ) ; </a> 1
<a> } </a> 1
<a> if ( prev != null ) { </a> 1
<a> prev . next ( cm ) ; </a> 1
<a> } </a> 1
<a> if ( ! queue . contains ( cm ) ) { </a> 1
<a> queue . add ( cm ) ; </a> 1
<a> } </a> 1
<a> if ( prev == null ) { </a> 1
<a> cm = new CachedMessage ( true ) ; </a> 1
<a> } </a> 1
<a> if ( resource != null ) { </a> 0
<a> cache ( resource , cm ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> public abstract void cache ( final AtmosphereResource < HttpServletRequest , HttpServletResponse > r , CachedMessage cm ) ; </a> 0
<a> public abstract CachedMessage retrieveLastMessage ( final AtmosphereResource < HttpServletRequest , HttpServletResponse > r ) ; </a> 0
<a> public final synchronized List < Object > retrieveFromCache ( final AtmosphereResource < HttpServletRequest , HttpServletResponse > r ) { </a> 0
<a> CachedMessage cm = retrieveLastMessage ( r ) ; </a> 1
<a> boolean isNew = false ; </a> 1
<a> if ( cm == null && r . getRequest ( ) . getAttribute ( AtmosphereResourceImpl . PRE_SUSPEND ) != null ) { </a> 1
<a> isNew = true ; </a> 1
<a> } </a> 1
<a> boolean isHead = false ; </a> 1
<a> if ( cm != null && cm . isTail ) cm = null ; </a> 1
<a> if ( cm != null ) { </a> 1
<a> if ( ! queue . contains ( cm ) && ! queue . isEmpty ( ) ) { </a> 1
<a> cm = queue . get ( 0 ) ; </a> 1
<a> isHead = true ; </a> 1
<a> } </a> 1
<a> } else if ( isNew && ! queue . isEmpty ( ) ) { </a> 1
<a> cm = queue . get ( 0 ) ; </a> 1
<a> isHead = true ; </a> 1
<a> } </a> 1
<a> final ArrayList < Object > l = new ArrayList < Object > ( ) ; </a> 1
<a> if ( cm == null ) { </a> 1
<a> return l ; </a> 1
<a> } </a> 1
<a> if ( ! isHead ) </a> 1
<a> cm = cm . next ( ) ; </a> 1
<a> CachedMessage prev = cm ; </a> 1
<a> while ( cm != null ) { </a> 1
<a> l . add ( cm . message ( ) ) ; </a> 1
<a> prev = cm ; </a> 1
<a> cm = cm . next ( ) ; </a> 1
<a> } </a> 1
<a> if ( prev != null ) </a> 1
<a> cache ( r , prev ) ; </a> 1
<a> return l ; </a> 1
<a> } </a> 1
<a> public int getMaxCachedinMs ( ) { </a> 1
<a> return maxCachedinMs ; </a> 1
<a> } </a> 1
<a> public void setMaxCachedinMs ( final int maxCachedinMs ) { </a> 1
<a> this . maxCachedinMs = maxCachedinMs ; </a> 1
<a> } </a> 1
<a> protected static class CachedMessage implements Serializable { </a> 0
<a> public final Object message ; </a> 1
<a> public final long currentTime ; </a> 1
<a> public CachedMessage next ; </a> 1
<a> public final boolean isTail ; </a> 1
<a> public CachedMessage ( boolean isTail ) { </a> 1
<a> this . currentTime = 0L ; </a> 1
<a> this . message = null ; </a> 1
<a> this . next = null ; </a> 1
<a> this . isTail = isTail ; </a> 1
<a> } </a> 1
<a> public CachedMessage ( Object message , long currentTime , CachedMessage next ) { </a> 1
<a> this . currentTime = currentTime ; </a> 1
<a> this . message = message ; </a> 1
<a> this . next = next ; </a> 1
<a> this . isTail = false ; </a> 1
<a> } </a> 1
<a> public Object message ( ) { </a> 1
<a> return message ; </a> 1
<a> } </a> 1
<a> public long currentTime ( ) { </a> 1
<a> return currentTime ; </a> 1
<a> } </a> 1
<a> public CachedMessage next ( ) { </a> 1
<a> return next ; </a> 1
<a> } </a> 1
<a> public CachedMessage next ( CachedMessage next ) { </a> 1
<a> this . next = next ; </a> 1
<a> return next ; </a> 1
<a> } </a> 1
<a> public String toString ( ) { </a> 1
<a> if ( message != null ) { </a> 1
<a> return message . toString ( ) ; </a> 1
<a> } else { </a> 1
<a> return "" ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public boolean isTail ( ) { </a> 1
<a> return isTail ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cache ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . servlet . http . HttpSession ; </a> 0
<a> public class SessionBroadcasterCache extends BroadcasterCacheBase { </a> 1
<a> public SessionBroadcasterCache ( ) { </a> 0
<a> } </a> 0
<a> public void cache ( final AtmosphereResource < HttpServletRequest , HttpServletResponse > r , CachedMessage cm ) { </a> 0
<a> r . getRequest ( ) . getSession ( true ) . setAttribute ( BROADCASTER_CACHE_TRACKER , cm ) ; </a> 1
<a> } </a> 0
<a> public CachedMessage retrieveLastMessage ( final AtmosphereResource < HttpServletRequest , HttpServletResponse > r ) { </a> 0
<a> HttpSession session = r . getRequest ( ) . getSession ( false ) ; </a> 1
<a> if ( session == null ) { </a> 0
<a> session = r . getRequest ( ) . getSession ( true ) ; </a> 1
<a> } </a> 1
<a> return ( CachedMessage ) session . getAttribute ( BROADCASTER_CACHE_TRACKER ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . client ; </a> 0
<a> import org . atmosphere . cpr . PerRequestBroadcastFilter ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . STREAMING_TRANSPORT ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . X_ATMOSPHERE_TRANSPORT ; </a> 0
<a> public class JavascriptClientFilter implements PerRequestBroadcastFilter { </a> 0
<a> private final AtomicInteger uniqueScriptToken = new AtomicInteger ( ) ; </a> 0
<a> @ Override </a> 0
<a> public BroadcastAction filter ( Object originalMessage , Object message ) { </a> 0
<a> return new BroadcastAction ( BroadcastAction . ACTION . CONTINUE , message ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public BroadcastAction filter ( HttpServletRequest request , HttpServletResponse response , Object message ) { </a> 0
<a> String userAgent = request . getHeader ( "User-Agent" ) == null ? "" : request . getHeader ( "User-Agent" ) . toLowerCase ( ) ; </a> 0
<a> String transport = request . getHeader ( X_ATMOSPHERE_TRANSPORT ) == null ? STREAMING_TRANSPORT : request . getHeader ( X_ATMOSPHERE_TRANSPORT ) . toString ( ) ; </a> 0
<a> if ( transport . equals ( STREAMING_TRANSPORT ) && userAgent . startsWith ( "opera" ) ) { </a> 0
<a> StringBuilder sb = new StringBuilder ( "<script id=\"atmosphere_" ) </a> 0
<a> . append ( uniqueScriptToken . getAndIncrement ( ) ) </a> 0
<a> . append ( "\">" ) </a> 0
<a> . append ( "window.parent.$.atmosphere.streamingCallback" ) </a> 0
<a> . append ( "('" ) </a> 0
<a> . append ( message . toString ( ) ) </a> 0
<a> . append ( "');</script>" ) ; </a> 0
<a> message = sb . toString ( ) ; </a> 0
<a> return new BroadcastAction ( BroadcastAction . ACTION . CONTINUE , message ) ; </a> 0
<a> } </a> 0
<a> return new BroadcastAction ( BroadcastAction . ACTION . CONTINUE , message ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import com . sun . grizzly . tcp . Request ; </a> 1
<a> import com . sun . grizzly . websockets . BaseServerWebSocket ; </a> 1
<a> import com . sun . grizzly . websockets . DataFrame ; </a> 1
<a> import com . sun . grizzly . websockets . WebSocketApplication ; </a> 1
<a> import com . sun . grizzly . websockets . WebSocketEngine ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . atmosphere . websocket . WebSocketProcessor ; </a> 1
<a> import org . atmosphere . websocket . WebSocket ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletRequestWrapper ; </a> 1
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . WEBSOCKET_UPGRADE ; </a> 0
<a> public class GlassFishWebSocketSupport extends GrizzlyCometSupport { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( GlassFishWebSocketSupport . class ) ; </a> 0
<a> public GlassFishWebSocketSupport ( AtmosphereConfig config ) { </a> 0
<a> super ( config ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void init ( ServletConfig sc ) throws ServletException { </a> 0
<a> super . init ( sc ) ; </a> 0
<a> WebSocketEngine . getEngine ( ) . register ( sc . getServletContext ( ) . getContextPath ( ) , new GrizzlyApplication ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Action service ( HttpServletRequest request , HttpServletResponse response ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> boolean webSocketEnabled = false ; </a> 0
<a> if ( request . getHeaders ( "Connection" ) != null && request . getHeaders ( "Connection" ) . hasMoreElements ( ) ) { </a> 0
<a> String [ ] e = request . getHeaders ( "Connection" ) . nextElement ( ) . split ( "," ) ; </a> 0
<a> for ( String upgrade : e ) { </a> 0
<a> if ( upgrade . equalsIgnoreCase ( WEBSOCKET_UPGRADE ) ) { </a> 0
<a> webSocketEnabled = true ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! webSocketEnabled ) { </a> 0
<a> return super . service ( request , response ) ; </a> 0
<a> } else { </a> 0
<a> Action action = suspended ( request , response ) ; </a> 1
<a> if ( action . type == Action . TYPE . SUSPEND ) { </a> 0
<a> logger . debug ( "Suspending response: {}" , response ) ; </a> 1
<a> } else if ( action . type == Action . TYPE . RESUME ) { </a> 0
<a> logger . debug ( "Resuming response: {}" , response ) ; </a> 1
<a> } </a> 1
<a> return action ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> public String getContainerName ( ) { </a> 0
<a> return config . getServletConfig ( ) . getServletContext ( ) . getServerInfo ( ) + " with WebSocket enabled." ; </a> 0
<a> } </a> 0
<a> public class GrizzlyApplication extends WebSocketApplication { </a> 1
<a> private WebSocketProcessor webSocketProcessor ; </a> 1
<a> public void onConnect ( com . sun . grizzly . websockets . WebSocket w ) { </a> 0
<a> if ( ! BaseServerWebSocket . class . isAssignableFrom ( w . getClass ( ) ) ) { </a> 1
<a> throw new IllegalStateException ( ) ; </a> 1
<a> } </a> 1
<a> BaseServerWebSocket webSocket = BaseServerWebSocket . class . cast ( w ) ; </a> 1
<a> try { </a> 0
<a> webSocketProcessor = ( WebSocketProcessor ) GrizzlyWebSocket . class . getClassLoader ( ) </a> 1
<a> . loadClass ( config . getServlet ( ) . getWebSocketProcessorClassName ( ) ) </a> 0
<a> . getDeclaredConstructor ( new Class [ ] { AtmosphereServlet . class , WebSocket . class } ) </a> 1
<a> . newInstance ( new Object [ ] { config . getServlet ( ) , new GrizzlyWebSocket ( webSocket ) } ) ; </a> 1
<a> webSocketProcessor . dispatch ( new HttpServletRequestWrapper ( webSocket . getRequest ( ) ) ) ; </a> 1
<a> } catch ( Exception e ) { </a> 1
<a> logger . warn ( "failed to connect to web socket" , e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isApplicationRequest ( Request request ) { </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> public void onMessage ( com . sun . grizzly . websockets . WebSocket webSocket , DataFrame dataFrame ) { </a> 0
<a> webSocketProcessor . parseMessage ( dataFrame . getTextPayload ( ) ) ; </a> 0
<a> } </a> 1
<a> public void onClose ( com . sun . grizzly . websockets . WebSocket webSocket ) { </a> 1
<a> webSocketProcessor . close ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public boolean supportWebSocket ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public class GrizzlyWebSocket implements WebSocket { </a> 0
<a> private final com . sun . grizzly . websockets . WebSocket webSocket ; </a> 0
<a> public GrizzlyWebSocket ( com . sun . grizzly . websockets . WebSocket webSocket ) { </a> 0
<a> this . webSocket = webSocket ; </a> 0
<a> } </a> 0
<a> public void writeError ( int errorCode , String message ) throws IOException { </a> 0
<a> } </a> 0
<a> public void redirect ( String location ) throws IOException { </a> 0
<a> } </a> 0
<a> public void write ( byte frame , String data ) throws IOException { </a> 0
<a> webSocket . send ( data ) ; </a> 0
<a> } </a> 0
<a> public void write ( byte frame , byte [ ] data ) throws IOException { </a> 0
<a> webSocket . send ( new String ( data ) ) ; </a> 0
<a> } </a> 0
<a> public void write ( byte frame , byte [ ] data , int offset , int length ) throws IOException { </a> 0
<a> webSocket . send ( new String ( data , offset , length ) ) ; </a> 0
<a> } </a> 0
<a> public void close ( ) throws IOException { </a> 0
<a> webSocket . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import com . sun . enterprise . web . connector . grizzly . comet . CometContext ; </a> 0
<a> import com . sun . enterprise . web . connector . grizzly . comet . CometEngine ; </a> 0
<a> import com . sun . enterprise . web . connector . grizzly . comet . CometEvent ; </a> 0
<a> import com . sun . enterprise . web . connector . grizzly . comet . CometHandler ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AsynchronousProcessor ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . MAX_INACTIVE ; </a> 0
<a> public class GlassFishv2CometSupport extends AsynchronousProcessor { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( GlassFishv2CometSupport . class ) ; </a> 0
<a> private static final String ATMOSPHERE = "/atmosphere" ; </a> 0
<a> private String atmosphereCtx = "" ; </a> 0
<a> public GlassFishv2CometSupport ( AtmosphereConfig config ) { </a> 0
<a> super ( config ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void init ( ServletConfig sc ) throws ServletException { </a> 0
<a> super . init ( sc ) ; </a> 0
<a> atmosphereCtx = sc . getServletContext ( ) . getContextPath ( ) + ATMOSPHERE ; </a> 0
<a> CometEngine cometEngine = CometEngine . getEngine ( ) ; </a> 0
<a> CometContext context = cometEngine . register ( atmosphereCtx ) ; </a> 0
<a> context . setExpirationDelay ( - 1 ) ; </a> 0
<a> logger . debug ( "Created CometContext for atmosphere context: {}" , atmosphereCtx ) ; </a> 0
<a> } </a> 0
<a> public Action service ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> CometContext ctx = CometEngine . getEngine ( ) . getCometContext ( atmosphereCtx ) ; </a> 0
<a> Action action = suspended ( req , res ) ; </a> 0
<a> if ( action . type == Action . TYPE . SUSPEND ) { </a> 0
<a> logger . debug ( "Suspending response: {}" , res ) ; </a> 1
<a> suspend ( ctx , action , req , res ) ; </a> 0
<a> } else if ( action . type == Action . TYPE . RESUME ) { </a> 0
<a> logger . debug ( "Resuming response: {}" , res ) ; </a> 1
<a> resume ( req , ctx ) ; </a> 0
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> private void suspend ( CometContext ctx , Action action , HttpServletRequest req , </a> 0
<a> HttpServletResponse res ) { </a> 0
<a> VoidCometHandler c = new VoidCometHandler ( req , res ) ; </a> 0
<a> ctx . setExpirationDelay ( action . timeout ) ; </a> 0
<a> ctx . addCometHandler ( c ) ; </a> 0
<a> ctx . addAttribute ( "Time" , System . currentTimeMillis ( ) ) ; </a> 0
<a> req . setAttribute ( ATMOSPHERE , c . hashCode ( ) ) ; </a> 0
<a> if ( supportSession ( ) ) { </a> 1
<a> req . getSession ( ) . setAttribute ( ATMOSPHERE , c . hashCode ( ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> private void resume ( HttpServletRequest req , CometContext ctx ) { </a> 0
<a> if ( req . getAttribute ( ATMOSPHERE ) == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> CometHandler handler = ctx . getCometHandler ( ( Integer ) req . getAttribute ( ATMOSPHERE ) ) ; </a> 0
<a> req . removeAttribute ( ATMOSPHERE ) ; </a> 0
<a> if ( handler == null && supportSession ( ) && req . getSession ( false ) != null ) { </a> 1
<a> handler = ctx . getCometHandler ( ( Integer ) req . getSession ( false ) . getAttribute ( ATMOSPHERE ) ) ; </a> 1
<a> req . getSession ( ) . removeAttribute ( ATMOSPHERE ) ; </a> 1
<a> } </a> 1
<a> if ( handler != null && ( config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) == null </a> 0
<a> || config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) . equalsIgnoreCase ( "false" ) ) ) { </a> 0
<a> ctx . resumeCometHandler ( handler ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void action ( AtmosphereResourceImpl actionEvent ) { </a> 1
<a> super . action ( actionEvent ) ; </a> 1
<a> if ( actionEvent . action ( ) . type == Action . TYPE . RESUME && actionEvent . isInScope ( ) ) { </a> 0
<a> CometContext ctx = CometEngine . getEngine ( ) . getCometContext ( atmosphereCtx ) ; </a> 0
<a> resume ( actionEvent . getRequest ( ) , ctx ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Action cancelled ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> Action action = super . cancelled ( req , res ) ; </a> 0
<a> if ( req . getAttribute ( MAX_INACTIVE ) != null && Long . class . cast ( req . getAttribute ( MAX_INACTIVE ) ) == - 1 ) { </a> 0
<a> resume ( req , CometEngine . getEngine ( ) . getCometContext ( atmosphereCtx ) ) ; </a> 0
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> private class VoidCometHandler implements CometHandler { </a> 0
<a> private final HttpServletRequest req ; </a> 0
<a> private final HttpServletResponse res ; </a> 0
<a> private VoidCometHandler ( HttpServletRequest req , HttpServletResponse res ) { </a> 0
<a> this . req = req ; </a> 0
<a> this . res = res ; </a> 0
<a> } </a> 0
<a> public void attach ( Object o ) { </a> 0
<a> } </a> 0
<a> public void onEvent ( CometEvent ce ) throws IOException { </a> 0
<a> } </a> 0
<a> public void onInitialize ( CometEvent ce ) throws IOException { </a> 0
<a> } </a> 0
<a> public void onTerminate ( CometEvent ce ) throws IOException { </a> 0
<a> } </a> 0
<a> public synchronized void onInterrupt ( CometEvent ce ) throws IOException { </a> 0
<a> long timeStamp = ( Long ) ce . getCometContext ( ) . getAttribute ( "Time" ) ; </a> 0
<a> try { </a> 0
<a> if ( ce . getCometContext ( ) . getExpirationDelay ( ) > 0 </a> 0
<a> && ( System . currentTimeMillis ( ) - timeStamp ) >= ce . getCometContext ( ) . getExpirationDelay ( ) ) { </a> 0
<a> timedout ( req , res ) ; </a> 0
<a> } else { </a> 0
<a> cancelled ( req , res ) ; </a> 0
<a> } </a> 0
<a> } catch ( ServletException ex ) { </a> 0
<a> logger . warn ( "onInterrupt(): encountered exception" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import com . sun . grizzly . comet . CometContext ; </a> 0
<a> import com . sun . grizzly . comet . CometEngine ; </a> 0
<a> import com . sun . grizzly . comet . CometEvent ; </a> 0
<a> import com . sun . grizzly . comet . CometHandler ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AsynchronousProcessor ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . MAX_INACTIVE ; </a> 0
<a> public class GrizzlyCometSupport extends AsynchronousProcessor { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( GrizzlyCometSupport . class ) ; </a> 0
<a> private static final String ATMOSPHERE = "/atmosphere" ; </a> 0
<a> private String atmosphereCtx = "" ; </a> 0
<a> public GrizzlyCometSupport ( AtmosphereConfig config ) { </a> 0
<a> super ( config ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void init ( ServletConfig sc ) throws ServletException { </a> 0
<a> super . init ( sc ) ; </a> 0
<a> atmosphereCtx = sc . getServletContext ( ) . getContextPath ( ) + ATMOSPHERE ; </a> 0
<a> CometEngine cometEngine = CometEngine . getEngine ( ) ; </a> 0
<a> CometContext context = cometEngine . register ( atmosphereCtx ) ; </a> 0
<a> context . setExpirationDelay ( - 1 ) ; </a> 0
<a> logger . debug ( "Created CometContext for atmosphere context: {}" , atmosphereCtx ) ; </a> 0
<a> } </a> 0
<a> public Action service ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> CometContext ctx = CometEngine . getEngine ( ) . getCometContext ( atmosphereCtx ) ; </a> 0
<a> Action action = suspended ( req , res ) ; </a> 0
<a> if ( action . type == Action . TYPE . SUSPEND ) { </a> 0
<a> logger . debug ( "Suspending response: {}" , res ) ; </a> 1
<a> suspend ( ctx , action , req , res ) ; </a> 0
<a> } else if ( action . type == Action . TYPE . RESUME ) { </a> 0
<a> logger . debug ( "Resuming response: {}" , res ) ; </a> 1
<a> resume ( req , ctx ) ; </a> 0
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> private void suspend ( CometContext ctx , Action action , HttpServletRequest req , </a> 0
<a> HttpServletResponse res ) { </a> 0
<a> VoidCometHandler c = new VoidCometHandler ( req , res ) ; </a> 0
<a> ctx . setExpirationDelay ( action . timeout ) ; </a> 0
<a> ctx . addCometHandler ( c ) ; </a> 0
<a> req . setAttribute ( ATMOSPHERE , c . hashCode ( ) ) ; </a> 0
<a> ctx . addAttribute ( "Time" , System . currentTimeMillis ( ) ) ; </a> 0
<a> if ( supportSession ( ) ) { </a> 0
<a> req . getSession ( ) . setAttribute ( ATMOSPHERE , c . hashCode ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void resume ( HttpServletRequest req , CometContext ctx ) { </a> 0
<a> if ( req . getAttribute ( ATMOSPHERE ) == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> CometHandler handler = ctx . getCometHandler ( ( Integer ) req . getAttribute ( ATMOSPHERE ) ) ; </a> 0
<a> req . removeAttribute ( ATMOSPHERE ) ; </a> 0
<a> if ( handler == null && supportSession ( ) && req . getSession ( false ) != null ) { </a> 0
<a> handler = ctx . getCometHandler ( ( Integer ) req . getSession ( false ) . getAttribute ( ATMOSPHERE ) ) ; </a> 0
<a> req . getSession ( ) . removeAttribute ( ATMOSPHERE ) ; </a> 0
<a> } </a> 0
<a> if ( handler != null && ( config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) == null </a> 0
<a> || config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) . equalsIgnoreCase ( "false" ) ) ) { </a> 0
<a> ctx . resumeCometHandler ( handler ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void action ( AtmosphereResourceImpl r ) { </a> 0
<a> super . action ( r ) ; </a> 0
<a> if ( r . action ( ) . type == Action . TYPE . RESUME && r . isInScope ( ) ) { </a> 0
<a> CometContext ctx = CometEngine . getEngine ( ) . getCometContext ( atmosphereCtx ) ; </a> 0
<a> resume ( r . getRequest ( ) , ctx ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Action cancelled ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> Action action = super . cancelled ( req , res ) ; </a> 0
<a> if ( req . getAttribute ( MAX_INACTIVE ) != null && Long . class . cast ( req . getAttribute ( MAX_INACTIVE ) ) == - 1 ) { </a> 0
<a> resume ( req , CometEngine . getEngine ( ) . getCometContext ( atmosphereCtx ) ) ; </a> 0
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> private class VoidCometHandler implements CometHandler { </a> 0
<a> HttpServletRequest req ; </a> 0
<a> HttpServletResponse res ; </a> 0
<a> public VoidCometHandler ( HttpServletRequest req , HttpServletResponse res ) { </a> 0
<a> this . req = req ; </a> 0
<a> this . res = res ; </a> 0
<a> } </a> 0
<a> public void attach ( Object o ) { </a> 0
<a> } </a> 0
<a> public void onEvent ( CometEvent ce ) throws IOException { </a> 0
<a> } </a> 0
<a> public void onInitialize ( CometEvent ce ) throws IOException { </a> 0
<a> } </a> 0
<a> public void onTerminate ( CometEvent ce ) throws IOException { </a> 0
<a> } </a> 0
<a> public synchronized void onInterrupt ( CometEvent ce ) throws IOException { </a> 0
<a> long timeStamp = ( Long ) ce . getCometContext ( ) . getAttribute ( "Time" ) ; </a> 0
<a> try { </a> 0
<a> if ( ce . getCometContext ( ) . getExpirationDelay ( ) > 0 </a> 0
<a> && ( System . currentTimeMillis ( ) - timeStamp ) >= ce . getCometContext ( ) . getExpirationDelay ( ) ) { </a> 0
<a> timedout ( req , res ) ; </a> 0
<a> } else { </a> 0
<a> cancelled ( req , res ) ; </a> 0
<a> } </a> 0
<a> } catch ( ServletException ex ) { </a> 0
<a> logger . warn ( "onInterrupt() encountered exception" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AsynchronousProcessor ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . jboss . servlet . http . HttpEvent ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . MAX_INACTIVE ; </a> 0
<a> public class JBossWebCometSupport extends AsynchronousProcessor { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( JBossWebCometSupport . class ) ; </a> 0
<a> public static final String HTTP_EVENT = "HttpEvent" ; </a> 0
<a> private static final IllegalStateException unableToDetectComet = new IllegalStateException ( unableToDetectComet ( ) ) ; </a> 0
<a> private final ConcurrentLinkedQueue < HttpEvent > resumed = new ConcurrentLinkedQueue < HttpEvent > ( ) ; </a> 1
<a> public JBossWebCometSupport ( AtmosphereConfig config ) { </a> 0
<a> super ( config ) ; </a> 0
<a> } </a> 0
<a> public Action service ( HttpServletRequest req , HttpServletResponse res ) throws IOException , ServletException { </a> 0
<a> HttpEvent event = ( HttpEvent ) req . getAttribute ( HTTP_EVENT ) ; </a> 0
<a> if ( event == null ) { </a> 0
<a> throw unableToDetectComet ; </a> 0
<a> } </a> 0
<a> Action action = null ; </a> 0
<a> if ( event . getType ( ) == HttpEvent . EventType . BEGIN ) { </a> 0
<a> action = suspended ( req , res ) ; </a> 0
<a> if ( action . type == Action . TYPE . SUSPEND ) { </a> 0
<a> logger . debug ( "Suspending response: {}" , res ) ; </a> 1
<a> try { </a> 0
<a> if ( action . timeout != - 1 ) { </a> 0
<a> event . setTimeout ( ( int ) action . timeout ) ; </a> 0
<a> } else { </a> 0
<a> event . setTimeout ( Integer . MAX_VALUE ) ; </a> 0
<a> } </a> 0
<a> } catch ( UnsupportedOperationException ex ) { </a> 0
<a> } </a> 0
<a> } else if ( action . type == Action . TYPE . RESUME ) { </a> 0
<a> logger . debug ( "Resuming response: {}" , res ) ; </a> 1
<a> event . close ( ) ; </a> 1
<a> } else { </a> 0
<a> event . close ( ) ; </a> 1
<a> } </a> 0
<a> } else if ( event . getType ( ) == HttpEvent . EventType . READ ) { </a> 0
<a> } else if ( event . getType ( ) == HttpEvent . EventType . EOF ) { </a> 1
<a> logger . debug ( "Client closed connection: response: {}" , res ) ; </a> 1
<a> if ( ! resumed . remove ( event ) ) { </a> 1
<a> logger . debug ( "Client closed connection: response: {}" , res ) ; </a> 1
<a> action = cancelled ( req , res ) ; </a> 1
<a> } else { </a> 1
<a> logger . debug ( "Cancelling response: {}" , res ) ; </a> 1
<a> } </a> 0
<a> event . close ( ) ; </a> 1
<a> } else if ( event . getType ( ) == HttpEvent . EventType . ERROR ) { </a> 1
<a> event . close ( ) ; </a> 1
<a> } else if ( event . getType ( ) == HttpEvent . EventType . END ) { </a> 1
<a> if ( ! resumed . remove ( event ) ) { </a> 1
<a> logger . debug ( "Client closed connection response: {}" , res ) ; </a> 1
<a> action = cancelled ( req , res ) ; </a> 0
<a> } else { </a> 0
<a> logger . debug ( "Cancelling response: {}" , res ) ; </a> 1
<a> } </a> 0
<a> event . close ( ) ; </a> 1
<a> } else if ( event . getType ( ) == HttpEvent . EventType . TIMEOUT ) { </a> 0
<a> logger . debug ( "Timing out {}" , res ) ; </a> 1
<a> action = timedout ( req , res ) ; </a> 0
<a> event . close ( ) ; </a> 0
<a> } </a> 0
<a> return action ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Action cancelled ( HttpServletRequest req , HttpServletResponse res ) throws IOException , ServletException { </a> 0
<a> Action action = super . cancelled ( req , res ) ; </a> 0
<a> if ( req . getAttribute ( MAX_INACTIVE ) != null && Long . class . cast ( req . getAttribute ( MAX_INACTIVE ) ) == - 1 ) { </a> 0
<a> HttpEvent event = ( HttpEvent ) req . getAttribute ( HTTP_EVENT ) ; </a> 0
<a> if ( event == null ) { </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> resumed . offer ( event ) ; </a> 1
<a> event . close ( ) ; </a> 1
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void action ( AtmosphereResourceImpl actionEvent ) { </a> 1
<a> super . action ( actionEvent ) ; </a> 1
<a> if ( actionEvent . action ( ) . type == Action . TYPE . RESUME && actionEvent . isInScope ( ) ) { </a> 0
<a> try { </a> 1
<a> HttpEvent event = ( HttpEvent ) actionEvent . getRequest ( ) . getAttribute ( HTTP_EVENT ) ; </a> 1
<a> resumed . offer ( event ) ; </a> 1
<a> if ( config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) == null || </a> 0
<a> config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) . equalsIgnoreCase ( "false" ) ) { </a> 0
<a> event . close ( ) ; </a> 1
<a> } </a> 0
<a> } catch ( IOException ex ) { </a> 1
<a> logger . debug ( "" , ex ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> } </a> 0
<a> private static String unableToDetectComet ( ) { </a> 0
<a> StringBuilder sb = new StringBuilder ( ) ; </a> 0
<a> sb . append ( "JBoss failed to detect this is a Comet application because the APR Connector is not enabled. " ) ; </a> 0
<a> sb . append ( "\nMake sure atmosphere-compat-jboss.jar is not under your WEB-INF/lib and " ) ; </a> 0
<a> sb . append ( "\nthere is no context.xml under WEB-INF" ) ; </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AsynchronousProcessor ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . atmosphere . cpr . FrameworkConfig ; </a> 0
<a> import org . eclipse . jetty . continuation . Continuation ; </a> 0
<a> import org . eclipse . jetty . continuation . ContinuationSupport ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> public class Jetty7CometSupport extends AsynchronousProcessor { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( Jetty7CometSupport . class ) ; </a> 0
<a> protected final ConcurrentLinkedQueue < Continuation > resumed = new ConcurrentLinkedQueue < Continuation > ( ) ; </a> 0
<a> public Jetty7CometSupport ( AtmosphereConfig config ) { </a> 0
<a> super ( config ) ; </a> 0
<a> } </a> 0
<a> public Action service ( HttpServletRequest req , HttpServletResponse res ) throws IOException , ServletException { </a> 1
<a> Action action = null ; </a> 0
<a> Continuation c = ContinuationSupport . getContinuation ( req ) ; </a> 0
<a> if ( c . isInitial ( ) ) { </a> 0
<a> action = suspended ( req , res ) ; </a> 0
<a> if ( action . type == Action . TYPE . SUSPEND ) { </a> 1
<a> logger . debug ( "Suspending {}" , res ) ; </a> 1
<a> if ( action . timeout != - 1 ) { </a> 0
<a> c . setTimeout ( action . timeout ) ; </a> 0
<a> } else { </a> 0
<a> c . setTimeout ( Integer . MAX_VALUE ) ; </a> 0
<a> } </a> 0
<a> c . suspend ( ) ; </a> 1
<a> } else if ( action . type == Action . TYPE . RESUME ) { </a> 0
<a> Boolean resumeOnBroadcast = ( Boolean ) req . getAttribute ( ApplicationConfig . RESUME_ON_BROADCAST ) ; </a> 0
<a> if ( resumeOnBroadcast != null && resumeOnBroadcast ) { </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> logger . debug ( "Resume {}" , res ) ; </a> 1
<a> if ( ! resumed . remove ( c ) ) { </a> 0
<a> try { </a> 0
<a> c . complete ( ) ; </a> 0
<a> } catch ( IllegalStateException ex ) { </a> 0
<a> logger . trace ( "Continuation.complete()" , ex ) ; </a> 0
<a> } finally { </a> 0
<a> resumed ( req , res ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else if ( ! c . isInitial ( ) && c . isExpired ( ) ) { </a> 1
<a> timedout ( req , res ) ; </a> 1
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public Action resumed ( HttpServletRequest request , HttpServletResponse response ) </a> 0
<a> throws IOException , ServletException { </a> 1
<a> logger . debug ( "(resumed) invoked:\n HttpServletRequest: {}\n HttpServletResponse: {}" , request , response ) ; </a> 1
<a> AtmosphereResourceImpl r = </a> 1
<a> ( AtmosphereResourceImpl ) request . getAttribute ( FrameworkConfig . ATMOSPHERE_RESOURCE ) ; </a> 0
<a> AtmosphereHandler < HttpServletRequest , HttpServletResponse > atmosphereHandler = </a> 0
<a> ( AtmosphereHandler < HttpServletRequest , HttpServletResponse > ) </a> 0
<a> request . getAttribute ( FrameworkConfig . ATMOSPHERE_HANDLER ) ; </a> 0
<a> atmosphereHandler . onStateChange ( r . getAtmosphereResourceEvent ( ) ) ; </a> 1
<a> return new Action ( Action . TYPE . RESUME ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public void action ( AtmosphereResourceImpl actionEvent ) { </a> 1
<a> super . action ( actionEvent ) ; </a> 1
<a> if ( actionEvent . isInScope ( ) && actionEvent . action ( ) . type == Action . TYPE . RESUME && </a> 1
<a> ( config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) == null || </a> 1
<a> config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) . equalsIgnoreCase ( "false" ) ) ) { </a> 1
<a> Continuation c = ContinuationSupport . getContinuation ( actionEvent . getRequest ( ) ) ; </a> 1
<a> if ( c != null ) { </a> 0
<a> try { </a> 0
<a> c . complete ( ) ; </a> 0
<a> } catch ( IllegalStateException ex ) { </a> 0
<a> logger . trace ( "Continuation.complete() failed" , ex ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> try { </a> 1
<a> actionEvent . getResponse ( ) . flushBuffer ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AsynchronousProcessor ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . mortbay . util . ajax . Continuation ; </a> 0
<a> import org . mortbay . util . ajax . ContinuationSupport ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . MAX_INACTIVE ; </a> 0
<a> public class JettyCometSupport extends AsynchronousProcessor { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( JettyCometSupport . class ) ; </a> 0
<a> private final ConcurrentLinkedQueue < Continuation > resumed = new ConcurrentLinkedQueue < Continuation > ( ) ; </a> 0
<a> public JettyCometSupport ( AtmosphereConfig config ) { </a> 0
<a> super ( config ) ; </a> 0
<a> } </a> 0
<a> public Action service ( HttpServletRequest req , HttpServletResponse response ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> Continuation c = ContinuationSupport . getContinuation ( req , null ) ; </a> 0
<a> Action action = null ; </a> 0
<a> if ( ! c . isResumed ( ) && ! c . isPending ( ) ) { </a> 1
<a> action = suspended ( req , response ) ; </a> 0
<a> if ( action . type == Action . TYPE . SUSPEND ) { </a> 0
<a> logger . debug ( "Suspending response: {}" , response ) ; </a> 1
<a> if ( action . timeout != - 1 ) { </a> 0
<a> c . suspend ( action . timeout ) ; </a> 0
<a> } else { </a> 0
<a> c . suspend ( 0 ) ; </a> 0
<a> } </a> 0
<a> } else if ( action . type == Action . TYPE . RESUME ) { </a> 0
<a> logger . debug ( "Resuming response: {}" , response ) ; </a> 1
<a> if ( ! resumed . remove ( c ) ) { </a> 0
<a> c . reset ( ) ; </a> 0
<a> if ( req . getAttribute ( ApplicationConfig . RESUMED_ON_TIMEOUT ) == null ) { </a> 0
<a> timedout ( req , response ) ; </a> 0
<a> } else { </a> 0
<a> resumed ( req , response ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> logger . debug ( "Resuming response: {}" , response ) ; </a> 1
<a> if ( ! resumed . remove ( c ) ) { </a> 1
<a> c . reset ( ) ; </a> 0
<a> if ( req . getAttribute ( ApplicationConfig . RESUMED_ON_TIMEOUT ) == null ) { </a> 0
<a> timedout ( req , response ) ; </a> 0
<a> } else { </a> 0
<a> resumed ( req , response ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void action ( AtmosphereResourceImpl r ) { </a> 0
<a> super . action ( r ) ; </a> 0
<a> if ( r . action ( ) . type == Action . TYPE . RESUME && r . isInScope ( ) ) { </a> 0
<a> Continuation c = ContinuationSupport . getContinuation ( r . getRequest ( ) , null ) ; </a> 1
<a> resumed . offer ( c ) ; </a> 0
<a> if ( config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) == null </a> 0
<a> || config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) . equalsIgnoreCase ( "false" ) ) { </a> 0
<a> c . resume ( ) ; </a> 0
<a> } else { </a> 0
<a> try { </a> 1
<a> r . getResponse ( ) . flushBuffer ( ) ; </a> 1
<a> } catch ( IOException e ) { </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Action cancelled ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> Action action = super . cancelled ( req , res ) ; </a> 0
<a> if ( req . getAttribute ( MAX_INACTIVE ) != null && Long . class . cast ( req . getAttribute ( MAX_INACTIVE ) ) == - 1 ) { </a> 0
<a> Continuation c = ContinuationSupport . getContinuation ( req , null ) ; </a> 0
<a> if ( c != null ) { </a> 0
<a> c . resume ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AsynchronousProcessor ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . websocket . JettyWebSocketHandler ; </a> 0
<a> import org . atmosphere . websocket . WebSocket ; </a> 0
<a> import org . eclipse . jetty . websocket . WebSocketFactory ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . WEBSOCKET_UPGRADE ; </a> 0
<a> public class JettyWebSocketUtil { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( JettyWebSocketUtil . class ) ; </a> 0
<a> public final static AtmosphereServlet . Action doService ( AsynchronousProcessor cometSupport , </a> 0
<a> HttpServletRequest req , </a> 0
<a> HttpServletResponse res , </a> 0
<a> WebSocketFactory webSocketFactory ) throws IOException , ServletException { </a> 0
<a> boolean webSocketEnabled = false ; </a> 0
<a> if ( req . getHeaders ( "Connection" ) != null && req . getHeaders ( "Connection" ) . hasMoreElements ( ) ) { </a> 0
<a> String [ ] e = req . getHeaders ( "Connection" ) . nextElement ( ) . split ( "," ) ; </a> 1
<a> for ( String upgrade : e ) { </a> 0
<a> if ( upgrade . trim ( ) . equalsIgnoreCase ( WEBSOCKET_UPGRADE ) ) { </a> 0
<a> webSocketEnabled = true ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Boolean b = ( Boolean ) req . getAttribute ( WebSocket . WEBSOCKET_INITIATED ) ; </a> 0
<a> if ( b == null ) b = Boolean . FALSE ; </a> 0
<a> if ( ! webSocketEnabled ) { </a> 1
<a> return null ; </a> 0
<a> } else { </a> 0
<a> if ( webSocketFactory != null && ! b ) { </a> 0
<a> req . setAttribute ( WebSocket . WEBSOCKET_INITIATED , true ) ; </a> 0
<a> webSocketFactory . acceptWebSocket ( req , res ) ; </a> 0
<a> return new AtmosphereServlet . Action ( ) ; </a> 0
<a> } </a> 0
<a> AtmosphereServlet . Action action = cometSupport . suspended ( req , res ) ; </a> 0
<a> if ( action . type == AtmosphereServlet . Action . TYPE . SUSPEND ) { </a> 0
<a> logger . debug ( "Suspending response: {}" , res ) ; </a> 1
<a> } else if ( action . type == AtmosphereServlet . Action . TYPE . RESUME ) { </a> 0
<a> logger . debug ( "Resume response: {}" , res ) ; </a> 1
<a> req . setAttribute ( WebSocket . WEBSOCKET_RESUME , true ) ; </a> 0
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public final static WebSocketFactory getFactory ( final AtmosphereServlet . AtmosphereConfig config ) { </a> 0
<a> WebSocketFactory webSocketFactory = new WebSocketFactory ( new WebSocketFactory . Acceptor ( ) { </a> 0
<a> public boolean checkOrigin ( HttpServletRequest request , String origin ) { </a> 0
<a> logger . debug ( "WebSocket-checkOrigin request {} with origin {}" , request . getRequestURI ( ) , origin ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public org . eclipse . jetty . websocket . WebSocket doWebSocketConnect ( HttpServletRequest request , String protocol ) { </a> 0
<a> logger . debug ( "WebSocket-connect request {} with protocol {}" , request . getRequestURI ( ) , protocol ) ; </a> 0
<a> return new JettyWebSocketHandler ( request , config . getServlet ( ) , config . getServlet ( ) . getWebSocketProcessorClassName ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> int bufferSize = 8192 ; </a> 0
<a> if ( config . getInitParameter ( ApplicationConfig . WEBSOCKET_BUFFER_SIZE ) != null ) { </a> 0
<a> bufferSize = Integer . valueOf ( config . getInitParameter ( ApplicationConfig . WEBSOCKET_BUFFER_SIZE ) ) ; </a> 0
<a> } </a> 0
<a> logger . info ( "WebSocket Buffer side {}" , bufferSize ) ; </a> 0
<a> webSocketFactory . setBufferSize ( bufferSize ) ; </a> 0
<a> int timeOut = 5 * 60000 ; </a> 0
<a> if ( config . getInitParameter ( ApplicationConfig . WEBSOCKET_IDLETIME ) != null ) { </a> 0
<a> timeOut = Integer . valueOf ( config . getInitParameter ( ApplicationConfig . WEBSOCKET_IDLETIME ) ) ; </a> 0
<a> } </a> 0
<a> logger . info ( "WebSocket idle timeout {}" , timeOut ) ; </a> 0
<a> webSocketFactory . setMaxIdleTime ( timeOut ) ; </a> 0
<a> return webSocketFactory ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . atmosphere . websocket . JettyWebSocketHandler ; </a> 0
<a> import org . atmosphere . websocket . WebSocket ; </a> 0
<a> import org . eclipse . jetty . websocket . WebSocketFactory ; </a> 1
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletException ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> public class Servlet30CometSupportWithWebSocket extends Servlet30CometSupport { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( Servlet30CometSupportWithWebSocket . class ) ; </a> 1
<a> private final WebSocketFactory webSocketFactory ; </a> 1
<a> public Servlet30CometSupportWithWebSocket ( final AtmosphereConfig config ) { </a> 1
<a> super ( config ) ; </a> 1
<a> boolean isJetty = config . getServletContext ( ) . getServerInfo ( ) . toLowerCase ( ) . startsWith ( "jetty" ) ; </a> 0
<a> if ( isJetty ) { </a> 1
<a> webSocketFactory = JettyWebSocketUtil . getFactory ( config ) ; </a> 1
<a> } else { </a> 0
<a> webSocketFactory = null ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public Action service ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 1
<a> Action action = JettyWebSocketUtil . doService ( this , req , res , webSocketFactory ) ; </a> 1
<a> return action == null ? super . service ( req , res ) : action ; </a> 1
<a> } </a> 1
<a> public String getContainerName ( ) { </a> 1
<a> return config . getServletConfig ( ) . getServletContext ( ) . getServerInfo ( ) + " with WebSocket enabled." ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean supportWebSocket ( ) { </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import org . apache . catalina . comet . CometEvent ; </a> 0
<a> import org . apache . catalina . comet . CometEvent . EventType ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AsynchronousProcessor ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . MAX_INACTIVE ; </a> 0
<a> public class Tomcat7CometSupport extends AsynchronousProcessor { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( Tomcat7CometSupport . class ) ; </a> 0
<a> public static final String COMET_EVENT = "CometEvent" ; </a> 0
<a> private static final IllegalStateException unableToDetectComet </a> 0
<a> = new IllegalStateException ( unableToDetectComet ( ) ) ; </a> 0
<a> private final ConcurrentLinkedQueue < CometEvent > resumed </a> 0
<a> = new ConcurrentLinkedQueue < CometEvent > ( ) ; </a> 0
<a> public Tomcat7CometSupport ( AtmosphereConfig config ) { </a> 0
<a> super ( config ) ; </a> 0
<a> } </a> 0
<a> public Action service ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> CometEvent event = ( CometEvent ) req . getAttribute ( COMET_EVENT ) ; </a> 0
<a> if ( event == null ) { </a> 0
<a> throw unableToDetectComet ; </a> 0
<a> } </a> 0
<a> Action action = null ; </a> 0
<a> if ( event . getEventType ( ) == EventType . BEGIN ) { </a> 0
<a> action = suspended ( req , res ) ; </a> 0
<a> if ( action . type == Action . TYPE . SUSPEND ) { </a> 0
<a> logger . debug ( "Suspending response: {}" , res ) ; </a> 1
<a> try { </a> 0
<a> if ( action . timeout != - 1 ) { </a> 0
<a> event . setTimeout ( ( int ) action . timeout ) ; </a> 0
<a> } else { </a> 0
<a> event . setTimeout ( Integer . MAX_VALUE ) ; </a> 0
<a> } </a> 0
<a> } catch ( UnsupportedOperationException ex ) { </a> 0
<a> } </a> 0
<a> } else if ( action . type == Action . TYPE . RESUME ) { </a> 0
<a> logger . debug ( "Resuming response: {}" , res ) ; </a> 1
<a> event . close ( ) ; </a> 1
<a> } else { </a> 0
<a> event . close ( ) ; </a> 1
<a> } </a> 0
<a> } else if ( event . getEventType ( ) == EventType . READ ) { </a> 0
<a> } else if ( event . getEventSubType ( ) == CometEvent . EventSubType . CLIENT_DISCONNECT ) { </a> 0
<a> logger . debug ( "Client closed connection: response: {}" , res ) ; </a> 1
<a> if ( ! resumed . remove ( event ) ) { </a> 0
<a> logger . debug ( "Client closed connection: response: {}" , res ) ; </a> 0
<a> action = cancelled ( req , res ) ; </a> 0
<a> } else { </a> 1
<a> logger . debug ( "Cancelling response: {}" , res ) ; </a> 1
<a> } </a> 0
<a> event . close ( ) ; </a> 1
<a> } else if ( event . getEventSubType ( ) == CometEvent . EventSubType . TIMEOUT ) { </a> 0
<a> logger . debug ( "Timing out response: {}" , res ) ; </a> 1
<a> action = timedout ( req , res ) ; </a> 0
<a> event . close ( ) ; </a> 1
<a> } else if ( event . getEventType ( ) == EventType . ERROR ) { </a> 0
<a> event . close ( ) ; </a> 1
<a> } else if ( event . getEventType ( ) == EventType . END ) { </a> 0
<a> if ( ! resumed . remove ( event ) ) { </a> 0
<a> logger . debug ( "Client closed connection: response: {}" , res ) ; </a> 1
<a> action = cancelled ( req , res ) ; </a> 1
<a> } else { </a> 0
<a> logger . debug ( "Cancelling response: {}" , res ) ; </a> 1
<a> } </a> 0
<a> event . close ( ) ; </a> 0
<a> } </a> 0
<a> return action ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void action ( AtmosphereResourceImpl resource ) { </a> 1
<a> super . action ( resource ) ; </a> 1
<a> if ( resource . action ( ) . type == Action . TYPE . RESUME && resource . isInScope ( ) ) { </a> 0
<a> try { </a> 0
<a> CometEvent event = ( CometEvent ) resource . getRequest ( ) . getAttribute ( COMET_EVENT ) ; </a> 1
<a> if ( event == null ) return ; </a> 1
<a> resumed . offer ( event ) ; </a> 0
<a> if ( config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) == null </a> 0
<a> || config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) . equalsIgnoreCase ( "false" ) ) { </a> 0
<a> event . close ( ) ; </a> 1
<a> } </a> 0
<a> } catch ( IOException ex ) { </a> 0
<a> logger . debug ( "action failed" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Action cancelled ( HttpServletRequest req , HttpServletResponse res ) </a> 1
<a> throws IOException , ServletException { </a> 1
<a> Action action = super . cancelled ( req , res ) ; </a> 0
<a> if ( req . getAttribute ( MAX_INACTIVE ) != null && Long . class . cast ( req . getAttribute ( MAX_INACTIVE ) ) == - 1 ) { </a> 0
<a> CometEvent event = ( CometEvent ) req . getAttribute ( COMET_EVENT ) ; </a> 0
<a> if ( event == null ) return action ; </a> 0
<a> resumed . offer ( event ) ; </a> 0
<a> event . close ( ) ; </a> 1
<a> } </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> private static String unableToDetectComet ( ) { </a> 0
<a> StringBuilder sb = new StringBuilder ( ) ; </a> 0
<a> sb . append ( "Tomcat failed to detect this is a Comet application because context.xml " ) ; </a> 0
<a> sb . append ( "is missing or the Http11NioProtocol Connector is not enabled." ) ; </a> 0
<a> sb . append ( "\nIf that's not the case, you can also remove META-INF/context.xml and WEB-INF/lib/atmosphere-compat-tomcat.jar" ) ; </a> 1
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . container ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 1
<a> import org . atmosphere . cpr . AsynchronousProcessor ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import weblogic . servlet . http . AbstractAsyncServlet ; </a> 1
<a> import weblogic . servlet . http . RequestResponseKey ; </a> 1
<a> import javax . servlet . ServletException ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> public class WebLogicCometSupport extends AsynchronousProcessor { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( WebLogicCometSupport . class ) ; </a> 1
<a> public static final String RRK = "RequestResponseKey" ; </a> 1
<a> public WebLogicCometSupport ( AtmosphereConfig config ) { </a> 1
<a> super ( config ) ; </a> 1
<a> } </a> 1
<a> public Action service ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 1
<a> Action action = suspended ( req , res ) ; </a> 1
<a> if ( action . type == Action . TYPE . SUSPEND ) { </a> 1
<a> logger . debug ( "Suspending response: {}" , res ) ; </a> 1
<a> } else if ( action . type == Action . TYPE . RESUME ) { </a> 1
<a> logger . debug ( "Resuming response: {}" , res ) ; </a> 1
<a> Action nextAction = resumed ( req , res ) ; </a> 1
<a> if ( nextAction . type == Action . TYPE . SUSPEND ) { </a> 1
<a> logger . debug ( "Suspending after resuming response: {}" , res ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return action ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void action ( AtmosphereResourceImpl actionEvent ) { </a> 1
<a> super . action ( actionEvent ) ; </a> 1
<a> if ( actionEvent . isInScope ( ) && actionEvent . action ( ) . type == Action . TYPE . RESUME && </a> 1
<a> ( config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) == null </a> 1
<a> || config . getInitParameter ( ApplicationConfig . RESUME_AND_KEEPALIVE ) . equalsIgnoreCase ( "false" ) ) ) { </a> 1
<a> try { </a> 1
<a> RequestResponseKey rrk = ( RequestResponseKey ) actionEvent . getRequest ( ) . getSession ( ) . getAttribute ( RRK ) ; </a> 1
<a> AbstractAsyncServlet . notify ( rrk , null ) ; </a> 1
<a> } catch ( IOException ex ) { </a> 1
<a> logger . debug ( "action failed" , ex ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import org . atmosphere . websocket . WebSocketProcessor ; </a> 0
<a> public interface ApplicationConfig { </a> 0
<a> String PROPERTY_SERVLET_MAPPING = "org.atmosphere.jersey.servlet-mapping" ; </a> 0
<a> String PROPERTY_BLOCKING_COMETSUPPORT = "org.atmosphere.useBlocking" ; </a> 0
<a> String PROPERTY_NATIVE_COMETSUPPORT = "org.atmosphere.useNative" ; </a> 0
<a> String WEBSOCKET_SUPPORT = "org.atmosphere.useWebSocket" ; </a> 0
<a> String PROPERTY_USE_STREAM = "org.atmosphere.useStream" ; </a> 0
<a> String BROADCASTER_FACTORY = ApplicationConfig . class . getPackage ( ) . getName ( ) + ".broadcasterFactory" ; </a> 1
<a> String BROADCASTER_CLASS = ApplicationConfig . class . getPackage ( ) . getName ( ) + ".broadcasterClass" ; </a> 1
<a> String BROADCASTER_CACHE = ApplicationConfig . class . getPackage ( ) . getName ( ) + ".broadcasterCacheClass" ; </a> 1
<a> String PROPERTY_COMET_SUPPORT = ApplicationConfig . class . getPackage ( ) . getName ( ) + ".cometSupport" ; </a> 1
<a> String PROPERTY_SESSION_SUPPORT = ApplicationConfig . class . getPackage ( ) . getName ( ) + ".sessionSupport" ; </a> 1
<a> String RESUME_ON_BROADCAST = "org.atmosphere.resumeOnBroadcast" ; </a> 0
<a> String DEFAULT_NAMED_DISPATCHER = "default" ; </a> 0
<a> String NO_CACHE_HEADERS = ApplicationConfig . class . getPackage ( ) . getName ( ) + ".noCacheHeaders" ; </a> 1
<a> String DROP_ACCESS_CONTROL_ALLOW_ORIGIN_HEADER = ApplicationConfig . class . getPackage ( ) . getName ( ) + ".dropAccessControlAllowOriginHeader" ; </a> 1
<a> String BROADCASTER_LIFECYCLE_POLICY = ApplicationConfig . class . getPackage ( ) . getName ( ) + ".broadcasterLifeCyclePolicy" ; </a> 1
<a> String WEBSOCKET_PROCESSOR = WebSocketProcessor . class . getName ( ) ; </a> 0
<a> String WEBSOCKET_CONTENT_TYPE = "org.atmosphere.websocket.messageContentType" ; </a> 0
<a> String WEBSOCKET_METHOD = "org.atmosphere.websocket.messageMethod" ; </a> 0
<a> String WEBSOCKET_IDLETIME = "org.atmosphere.websocket.maxIdleTime" ; </a> 0
<a> String WEBSOCKET_BUFFER_SIZE = "org.atmosphere.websocket.bufferSize" ; </a> 0
<a> String WEBSOCKET_PATH_DELIMITER = "org.atmosphere.websocket.pathDelimiter" ; </a> 0
<a> String ATMOSPHERE_RESOURCE = AtmosphereResource . class . getName ( ) ; </a> 1
<a> String BROADCAST_FILTER_CLASSES = ApplicationConfig . class . getPackage ( ) . getName ( ) + ".broadcastFilterClasses" ; </a> 1
<a> String RESUME_AND_KEEPALIVE = AtmosphereServlet . class . getName ( ) + ".resumeAndKeepAlive" ; </a> 0
<a> String RESUMED_ON_TIMEOUT = AtmosphereServlet . class . getName ( ) + ".resumedOnTimeout" ; </a> 0
<a> String DISABLE_ONSTATE_EVENT = "org.atmosphere.disableOnStateEvent" ; </a> 0
<a> String MAX_INACTIVE = CometSupport . class . getName ( ) + ".maxInactiveActivity" ; </a> 1
<a> String SUPPORT_TRACKABLE = ApplicationConfig . class . getPackage ( ) . getName ( ) + ".Trackable" ; </a> 1
<a> String ALLOW_QUERYSTRING_AS_REQUEST = ApplicationConfig . class . getPackage ( ) . getName ( ) + ".allowQueryStreamAsPostOrGet" ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereHandlerWrapper ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . Servlet ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . servlet . http . HttpSession ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . Enumeration ; </a> 1
<a> import java . util . HashMap ; </a> 1
<a> import java . util . Map ; </a> 1
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import java . util . concurrent . Executors ; </a> 1
<a> import java . util . concurrent . ScheduledExecutorService ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 1
<a> import static org . atmosphere . cpr . ApplicationConfig . MAX_INACTIVE ; </a> 1
<a> import static org . atmosphere . cpr . HeaderConfig . X_ATMOSPHERE_ERROR ; </a> 0
<a> public abstract class AsynchronousProcessor implements CometSupport < AtmosphereResourceImpl > { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( AsynchronousProcessor . class ) ; </a> 0
<a> protected static final Action timedoutAction = new Action ( Action . TYPE . TIMEOUT ) ; </a> 0
<a> protected static final Action cancelledAction = new Action ( Action . TYPE . CANCELLED ) ; </a> 0
<a> private static final int DEFAULT_SESSION_TIMEOUT = 1800 ; </a> 0
<a> protected final AtmosphereConfig config ; </a> 0
<a> protected final ConcurrentHashMap < HttpServletRequest , AtmosphereResource < HttpServletRequest , HttpServletResponse > > </a> 0
<a> aliveRequests = new ConcurrentHashMap < HttpServletRequest , AtmosphereResource < HttpServletRequest , HttpServletResponse > > ( ) ; </a> 0
<a> private final ScheduledExecutorService closedDetector = Executors . newScheduledThreadPool ( 1 ) ; </a> 1
<a> public AsynchronousProcessor ( AtmosphereConfig config ) { </a> 0
<a> this . config = config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void init ( ServletConfig sc ) throws ServletException { </a> 0
<a> String maxInactive = sc . getInitParameter ( MAX_INACTIVE ) != null ? sc . getInitParameter ( MAX_INACTIVE ) : </a> 1
<a> config . getInitParameter ( MAX_INACTIVE ) ; </a> 1
<a> if ( maxInactive != null ) { </a> 1
<a> final long maxInactiveTime = Long . parseLong ( maxInactive ) ; </a> 1
<a> if ( maxInactiveTime <= 0 ) return ; </a> 1
<a> closedDetector . scheduleAtFixedRate ( new Runnable ( ) { </a> 1
<a> public void run ( ) { </a> 1
<a> for ( HttpServletRequest req : aliveRequests . keySet ( ) ) { </a> 0
<a> long l = ( Long ) req . getAttribute ( MAX_INACTIVE ) ; </a> 1
<a> if ( l > 0 && System . currentTimeMillis ( ) - l > maxInactiveTime ) { </a> 1
<a> try { </a> 1
<a> cancelled ( req , aliveRequests . get ( req ) . getResponse ( ) ) ; </a> 0
<a> req . setAttribute ( MAX_INACTIVE , ( long ) - 1 ) ; </a> 1
<a> } catch ( IOException e ) { </a> 1
<a> } catch ( ServletException e ) { </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } , 0 , 1 , TimeUnit . SECONDS ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> protected boolean supportSession ( ) { </a> 0
<a> return config . isSupportSession ( ) ; </a> 0
<a> } </a> 0
<a> public String getContainerName ( ) { </a> 0
<a> return config . getServletConfig ( ) . getServletContext ( ) . getServerInfo ( ) ; </a> 0
<a> } </a> 0
<a> public Action suspended ( HttpServletRequest request , HttpServletResponse response ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> return action ( request , response ) ; </a> 0
<a> } </a> 0
<a> Action action ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> boolean webSocketEnabled = false ; </a> 0
<a> if ( req . getHeaders ( "Connection" ) != null && req . getHeaders ( "Connection" ) . hasMoreElements ( ) ) { </a> 0
<a> String [ ] e = req . getHeaders ( "Connection" ) . nextElement ( ) . split ( "," ) ; </a> 1
<a> for ( String upgrade : e ) { </a> 0
<a> if ( upgrade . equalsIgnoreCase ( "Upgrade" ) ) { </a> 0
<a> webSocketEnabled = true ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( webSocketEnabled && ! supportWebSocket ( ) ) { </a> 0
<a> res . setStatus ( 501 ) ; </a> 0
<a> res . addHeader ( X_ATMOSPHERE_ERROR , "Websocket protocol not supported" ) ; </a> 0
<a> res . flushBuffer ( ) ; </a> 1
<a> return new Action ( ) ; </a> 1
<a> } </a> 1
<a> if ( config . handlers ( ) . isEmpty ( ) ) { </a> 0
<a> logger . error ( "No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml" ) ; </a> 1
<a> throw new ServletException ( "No AtmosphereHandler found. Make sure you define it inside META-INF/atmosphere.xml" ) ; </a> 1
<a> } </a> 0
<a> if ( supportSession ( ) ) { </a> 0
<a> HttpSession session = req . getSession ( true ) ; </a> 0
<a> if ( session . getMaxInactiveInterval ( ) == DEFAULT_SESSION_TIMEOUT ) { </a> 0
<a> session . setMaxInactiveInterval ( - 1 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> req . setAttribute ( FrameworkConfig . SUPPORT_SESSION , supportSession ( ) ) ; </a> 0
<a> AtmosphereHandlerWrapper handlerWrapper = map ( req ) ; </a> 0
<a> AtmosphereResourceImpl resource = new AtmosphereResourceImpl ( config , handlerWrapper . broadcaster , req , res , this , handlerWrapper . atmosphereHandler ) ; </a> 1
<a> handlerWrapper . broadcaster . getBroadcasterConfig ( ) . setAtmosphereConfig ( config ) ; </a> 0
<a> req . setAttribute ( FrameworkConfig . ATMOSPHERE_RESOURCE , resource ) ; </a> 0
<a> req . setAttribute ( FrameworkConfig . ATMOSPHERE_HANDLER , handlerWrapper . atmosphereHandler ) ; </a> 0
<a> try { </a> 1
<a> handlerWrapper . atmosphereHandler . onRequest ( resource ) ; </a> 0
<a> } catch ( IOException t ) { </a> 0
<a> resource . onThrowable ( t ) ; </a> 0
<a> throw t ; </a> 0
<a> } </a> 0
<a> if ( resource . getAtmosphereResourceEvent ( ) . isSuspended ( ) ) { </a> 1
<a> req . setAttribute ( MAX_INACTIVE , System . currentTimeMillis ( ) ) ; </a> 1
<a> aliveRequests . put ( req , resource ) ; </a> 1
<a> } </a> 1
<a> return resource . action ( ) ; </a> 0
<a> } </a> 0
<a> public void action ( AtmosphereResourceImpl r ) { </a> 1
<a> aliveRequests . remove ( r . getRequest ( ) ) ; </a> 1
<a> } </a> 1
<a> protected AtmosphereHandlerWrapper map ( HttpServletRequest req ) throws ServletException { </a> 0
<a> String path = req . getServletPath ( ) ; </a> 0
<a> if ( path == null || path . length ( ) == 0 ) { </a> 0
<a> path = "/" ; </a> 0
<a> } </a> 0
<a> AtmosphereHandlerWrapper atmosphereHandlerWrapper = config . handlers ( ) . get ( path ) ; </a> 1
<a> if ( atmosphereHandlerWrapper == null ) { </a> 1
<a> if ( ! path . endsWith ( "/" ) ) { </a> 1
<a> path += "/*" ; </a> 1
<a> } else { </a> 1
<a> path += "*" ; </a> 1
<a> } </a> 1
<a> atmosphereHandlerWrapper = config . handlers ( ) . get ( path ) ; </a> 1
<a> if ( atmosphereHandlerWrapper == null ) { </a> 1
<a> atmosphereHandlerWrapper = config . handlers ( ) . get ( "/*" ) ; </a> 1
<a> if ( atmosphereHandlerWrapper == null ) { </a> 1
<a> if ( req . getPathInfo ( ) != null ) { </a> 1
<a> path = req . getServletPath ( ) + req . getPathInfo ( ) ; </a> 1
<a> } </a> 1
<a> atmosphereHandlerWrapper = config . handlers ( ) . get ( path ) ; </a> 1
<a> if ( atmosphereHandlerWrapper == null ) { </a> 1
<a> if ( ! path . endsWith ( "/" ) ) { </a> 1
<a> path += "/*" ; </a> 1
<a> } else { </a> 1
<a> path += "*" ; </a> 1
<a> } </a> 1
<a> atmosphereHandlerWrapper = config . handlers ( ) . get ( path ) ; </a> 1
<a> if ( atmosphereHandlerWrapper == null ) { </a> 1
<a> logger . warn ( "No AtmosphereHandler maps request for {}" , path ) ; </a> 1
<a> for ( String m : config . handlers ( ) . keySet ( ) ) { </a> 1
<a> logger . warn ( "\tAtmosphereHandler registered: {}" , m ) ; </a> 1
<a> } </a> 1
<a> throw new ServletException ( "No AtmosphereHandler maps request for " + path ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> config . getBroadcasterFactory ( ) . add ( atmosphereHandlerWrapper . broadcaster , </a> 1
<a> atmosphereHandlerWrapper . broadcaster . getID ( ) ) ; </a> 1
<a> return atmosphereHandlerWrapper ; </a> 1
<a> } </a> 1
<a> public Action resumed ( HttpServletRequest request , HttpServletResponse response ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> logger . debug ( "(resumed) invoked:\n HttpServletRequest: {}\n HttpServletResponse: {}" , request , response ) ; </a> 1
<a> return action ( request , response ) ; </a> 1
<a> } </a> 0
<a> public Action timedout ( HttpServletRequest request , HttpServletResponse response ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> AtmosphereResourceImpl re ; </a> 1
<a> long l = ( Long ) request . getAttribute ( MAX_INACTIVE ) ; </a> 1
<a> if ( l == - 1 ) { </a> 1
<a> return timedoutAction ; </a> 1
<a> } </a> 0
<a> request . setAttribute ( MAX_INACTIVE , ( long ) - 1 ) ; </a> 1
<a> if ( request == null || response == null ) { </a> 1
<a> logger . warn ( "Invalid Request/Response: {}/{}" , request , response ) ; </a> 1
<a> return timedoutAction ; </a> 1
<a> } </a> 1
<a> re = ( AtmosphereResourceImpl ) request . getAttribute ( FrameworkConfig . ATMOSPHERE_RESOURCE ) ; </a> 1
<a> if ( re != null ) { </a> 0
<a> re . getAtmosphereResourceEvent ( ) . setIsResumedOnTimeout ( true ) ; </a> 1
<a> Broadcaster b = re . getBroadcaster ( ) ; </a> 1
<a> if ( b instanceof DefaultBroadcaster ) { </a> 0
<a> ( ( DefaultBroadcaster ) b ) . broadcastOnResume ( re ) ; </a> 1
<a> } </a> 0
<a> if ( re . getRequest ( ) . getAttribute ( ApplicationConfig . RESUMED_ON_TIMEOUT ) != null ) { </a> 1
<a> re . getAtmosphereResourceEvent ( ) . setIsResumedOnTimeout ( </a> 1
<a> ( Boolean ) re . getRequest ( ) . getAttribute ( ApplicationConfig . RESUMED_ON_TIMEOUT ) ) ; </a> 1
<a> } </a> 0
<a> invokeAtmosphereHandler ( re ) ; </a> 1
<a> } </a> 1
<a> return timedoutAction ; </a> 1
<a> } </a> 1
<a> void invokeAtmosphereHandler ( AtmosphereResourceImpl r ) throws IOException { </a> 1
<a> HttpServletRequest req = r . getRequest ( ) ; </a> 1
<a> HttpServletResponse response = r . getResponse ( ) ; </a> 1
<a> String disableOnEvent = r . getAtmosphereConfig ( ) . getInitParameter ( ApplicationConfig . DISABLE_ONSTATE_EVENT ) ; </a> 0
<a> try { </a> 0
<a> if ( ! r . getResponse ( ) . equals ( response ) ) { </a> 1
<a> logger . warn ( "Invalid response: {}" , response ) ; </a> 1
<a> } else if ( disableOnEvent == null || ! disableOnEvent . equals ( String . valueOf ( true ) ) ) { </a> 1
<a> AtmosphereHandler < HttpServletRequest , HttpServletResponse > atmosphereHandler = </a> 0
<a> ( AtmosphereHandler < HttpServletRequest , HttpServletResponse > ) </a> 0
<a> req . getAttribute ( FrameworkConfig . ATMOSPHERE_HANDLER ) ; </a> 0
<a> atmosphereHandler . onStateChange ( r . getAtmosphereResourceEvent ( ) ) ; </a> 0
<a> } else { </a> 1
<a> r . getResponse ( ) . flushBuffer ( ) ; </a> 1
<a> } </a> 1
<a> } catch ( IOException ex ) { </a> 0
<a> try { </a> 0
<a> r . onThrowable ( ex ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "failed calling onThrowable()" , ex ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 1
<a> try { </a> 1
<a> aliveRequests . remove ( req ) ; </a> 1
<a> r . notifyListeners ( ) ; </a> 1
<a> } finally { </a> 1
<a> destroyResource ( r ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private void destroyResource ( AtmosphereResourceImpl r ) { </a> 1
<a> r . removeEventListeners ( ) ; </a> 0
<a> try { </a> 0
<a> r . getBroadcaster ( ) . removeAtmosphereResource ( r ) ; </a> 1
<a> } catch ( IllegalStateException ex ) { </a> 1
<a> logger . trace ( ex . getMessage ( ) , ex ) ; </a> 1
<a> } </a> 1
<a> if ( BroadcasterFactory . getDefault ( ) != null ) { </a> 0
<a> BroadcasterFactory . getDefault ( ) . removeAllAtmosphereResource ( r ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public Action cancelled ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> AtmosphereResourceImpl re = null ; </a> 1
<a> long l = ( Long ) req . getAttribute ( MAX_INACTIVE ) ; </a> 1
<a> if ( l == - 1 ) { </a> 1
<a> return timedoutAction ; </a> 1
<a> } </a> 1
<a> req . setAttribute ( MAX_INACTIVE , ( long ) - 1 ) ; </a> 1
<a> try { </a> 1
<a> re = ( AtmosphereResourceImpl ) req . getAttribute ( FrameworkConfig . ATMOSPHERE_RESOURCE ) ; </a> 1
<a> if ( re != null ) { </a> 1
<a> re . getAtmosphereResourceEvent ( ) . setCancelled ( true ) ; </a> 1
<a> invokeAtmosphereHandler ( re ) ; </a> 1
<a> re . setIsInScope ( false ) ; </a> 1
<a> } </a> 1
<a> } catch ( Throwable ex ) { </a> 1
<a> logger . debug ( "failed to cancel resource: " + re , ex ) ; </a> 1
<a> } finally { </a> 1
<a> try { </a> 1
<a> aliveRequests . remove ( req ) ; </a> 1
<a> if ( re != null ) { </a> 1
<a> re . notifyListeners ( ) ; </a> 1
<a> } </a> 1
<a> } finally { </a> 1
<a> if ( re != null ) { </a> 1
<a> destroyResource ( re ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<a> return cancelledAction ; </a> 0
<a> } </a> 0
<a> void shutdown ( ) { </a> 1
<a> closedDetector . shutdownNow ( ) ; </a> 1
<a> for ( AtmosphereResource < HttpServletRequest , HttpServletResponse > resource : aliveRequests . values ( ) ) { </a> 0
<a> try { </a> 1
<a> resource . resume ( ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> logger . debug ( "failed on resume: " + resource , t ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public boolean supportWebSocket ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> public interface AtmosphereEventLifecycle { </a> 1
<a> public void addEventListener ( AtmosphereResourceEventListener e ) ; </a> 0
<a> public void removeEventListener ( AtmosphereResourceEventListener e ) ; </a> 0
<a> public void removeEventListeners ( ) ; </a> 0
<a> public void notifyListeners ( AtmosphereResourceEvent e ) ; </a> 0
<a> public void notifyListeners ( ) ; </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import org . atmosphere . container . BlockingIOCometSupport ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . Filter ; </a> 0
<a> import javax . servlet . FilterChain ; </a> 0
<a> import javax . servlet . FilterConfig ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . ServletRequest ; </a> 0
<a> import javax . servlet . ServletResponse ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . Enumeration ; </a> 0
<a> public class AtmosphereFilter implements Filter { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( AtmosphereFilter . class ) ; </a> 0
<a> private final AtmosphereServlet as ; </a> 1
<a> public AtmosphereFilter ( ) { </a> 0
<a> as = new AtmosphereServlet ( true ) ; </a> 1
<a> } </a> 0
<a> public void init ( final FilterConfig filterConfig ) throws ServletException { </a> 0
<a> logger . info ( "AtmosphereServlet running as a Filter" ) ; </a> 0
<a> as . init ( new ServletConfig ( ) { </a> 0
<a> public String getServletName ( ) { </a> 0
<a> return filterConfig . getFilterName ( ) ; </a> 0
<a> } </a> 0
<a> public ServletContext getServletContext ( ) { </a> 0
<a> return filterConfig . getServletContext ( ) ; </a> 0
<a> } </a> 0
<a> public String getInitParameter ( String name ) { </a> 0
<a> return filterConfig . getInitParameter ( name ) ; </a> 0
<a> } </a> 0
<a> public Enumeration < String > getInitParameterNames ( ) { </a> 0
<a> return filterConfig . getInitParameterNames ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> Action a = as . doCometSupport ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; </a> 0
<a> if ( a == null || a . type != Action . TYPE . SUSPEND ) { </a> 0
<a> chain . doFilter ( request , response ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> as . destroy ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> public interface AtmosphereHandler < F , G > { </a> 0
<a> void onRequest ( AtmosphereResource < F , G > resource ) throws IOException ; </a> 0
<a> void onStateChange ( AtmosphereResourceEvent < F , G > event ) throws IOException ; </a> 0
<a> void destroy ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import javax . servlet . ServletInputStream ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletRequestWrapper ; </a> 1
<a> import java . io . BufferedReader ; </a> 0
<a> import java . io . ByteArrayInputStream ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> import java . io . StringReader ; </a> 1
<a> import java . io . UnsupportedEncodingException ; </a> 0
<a> import java . util . ArrayList ; </a> 1
<a> import java . util . Collections ; </a> 1
<a> import java . util . Enumeration ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . X_ATMOSPHERE ; </a> 1
<a> public class AtmosphereRequest extends HttpServletRequestWrapper { </a> 1
<a> private final ByteInputStream bis ; </a> 0
<a> private final BufferedReader br ; </a> 0
<a> private final String pathInfo ; </a> 0
<a> private final Map < String , String > headers ; </a> 1
<a> private final String methodType ; </a> 0
<a> private final String contentType ; </a> 1
<a> private final HttpServletRequest request ; </a> 1
<a> private AtmosphereRequest ( Builder b ) { </a> 1
<a> super ( b . request ) ; </a> 0
<a> pathInfo = b . pathInfo == null ? b . request . getPathInfo ( ) : b . pathInfo ; </a> 1
<a> request = b . request ; </a> 0
<a> headers = b . headers ; </a> 0
<a> if ( b . dataBytes != null ) { </a> 1
<a> bis = new ByteInputStream ( b . dataBytes , b . offset , b . length ) ; </a> 0
<a> try { </a> 0
<a> br = new BufferedReader ( new StringReader ( new String ( b . dataBytes , b . offset , b . length , b . encoding ) ) ) ; </a> 0
<a> } catch ( UnsupportedEncodingException e ) { </a> 1
<a> throw new RuntimeException ( e ) ; </a> 1
<a> } </a> 1
<a> } else if ( b . data != null ) { </a> 0
<a> bis = new ByteInputStream ( b . data . getBytes ( ) , 0 , b . data . getBytes ( ) . length ) ; </a> 0
<a> br = new BufferedReader ( new StringReader ( b . data ) ) ; </a> 0
<a> } else { </a> 0
<a> bis = null ; </a> 0
<a> br = null ; </a> 0
<a> } </a> 1
<a> methodType = b . methodType == null ? b . request . getMethod ( ) : b . methodType ; </a> 0
<a> contentType = b . contentType == null ? b . request . getContentType ( ) : b . contentType ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public String getPathInfo ( ) { </a> 1
<a> return pathInfo ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public String getMethod ( ) { </a> 1
<a> return methodType ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public String getContentType ( ) { </a> 1
<a> return contentType ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public Enumeration getHeaders ( String name ) { </a> 1
<a> ArrayList list = Collections . list ( super . getHeaders ( name ) ) ; </a> 1
<a> if ( name . equalsIgnoreCase ( "content-type" ) ) { </a> 1
<a> list . add ( contentType ) ; </a> 1
<a> } </a> 1
<a> if ( headers . get ( name ) != null ) { </a> 1
<a> list . add ( headers . get ( name ) ) ; </a> 1
<a> } </a> 1
<a> if ( list . size ( ) == 0 && name . startsWith ( X_ATMOSPHERE ) ) { </a> 1
<a> if ( request . getAttribute ( name ) != null ) { </a> 0
<a> list . add ( request . getAttribute ( name ) ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> return Collections . enumeration ( list ) ; </a> 1
<a> } </a> 1
<a> public Enumeration < String > getHeaderNames ( ) { </a> 1
<a> ArrayList list = Collections . list ( super . getHeaderNames ( ) ) ; </a> 1
<a> list . add ( "content-type" ) ; </a> 1
<a> Enumeration e = request . getAttributeNames ( ) ; </a> 0
<a> while ( e . hasMoreElements ( ) ) { </a> 1
<a> String name = e . nextElement ( ) . toString ( ) ; </a> 1
<a> if ( name . startsWith ( X_ATMOSPHERE ) ) { </a> 1
<a> list . add ( name ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> for ( String s : headers . keySet ( ) ) { </a> 0
<a> list . add ( s ) ; </a> 0
<a> } </a> 1
<a> return Collections . enumeration ( list ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public String getHeader ( String s ) { </a> 1
<a> if ( s . equalsIgnoreCase ( "Connection" ) ) { </a> 1
<a> return "keep-alive" ; </a> 1
<a> } else if ( "content-type" . equalsIgnoreCase ( s ) ) { </a> 1
<a> return contentType ; </a> 1
<a> } else { </a> 1
<a> String name = super . getHeader ( s ) ; </a> 1
<a> if ( name == null ) { </a> 1
<a> if ( headers . get ( s ) != null ) { </a> 1
<a> return headers . get ( s ) ; </a> 1
<a> } </a> 1
<a> if ( s . startsWith ( X_ATMOSPHERE ) ) { </a> 0
<a> return ( String ) request . getAttribute ( s ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> return name ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public ServletInputStream getInputStream ( ) throws IOException { </a> 1
<a> return bis == null ? request . getInputStream ( ) : bis ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public BufferedReader getReader ( ) throws IOException { </a> 1
<a> return br == null ? request . getReader ( ) : br ; </a> 0
<a> } </a> 1
<a> private static class ByteInputStream extends ServletInputStream { </a> 0
<a> private final ByteArrayInputStream bis ; </a> 1
<a> public ByteInputStream ( byte [ ] data , int offset , int length ) { </a> 1
<a> this . bis = new ByteArrayInputStream ( data , offset , length ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int read ( ) throws IOException { </a> 1
<a> return bis . read ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public final static class Builder { </a> 1
<a> public HttpServletRequest request ; </a> 0
<a> public String pathInfo ; </a> 0
<a> public byte [ ] dataBytes ; </a> 0
<a> public int offset ; </a> 0
<a> public int length ; </a> 0
<a> public String encoding = "UTF-8" ; </a> 0
<a> public String methodType ; </a> 0
<a> public String contentType ; </a> 0
<a> public String data ; </a> 0
<a> public Map < String , String > headers ; </a> 0
<a> public Builder ( ) { </a> 1
<a> } </a> 1
<a> public Builder headers ( Map < String , String > headers ) { </a> 1
<a> this . headers = headers ; </a> 0
<a> return this ; </a> 1
<a> } </a> 1
<a> public Builder request ( HttpServletRequest request ) { </a> 1
<a> this . request = request ; </a> 1
<a> return this ; </a> 1
<a> } </a> 1
<a> public Builder pathInfo ( String pathInfo ) { </a> 1
<a> this . pathInfo = pathInfo ; </a> 1
<a> return this ; </a> 1
<a> } </a> 1
<a> public Builder body ( byte [ ] dataBytes , int offset , int length ) { </a> 1
<a> this . dataBytes = dataBytes ; </a> 1
<a> this . offset = offset ; </a> 1
<a> this . length = length ; </a> 1
<a> return this ; </a> 1
<a> } </a> 1
<a> public Builder encoding ( String encoding ) { </a> 1
<a> this . encoding = encoding ; </a> 1
<a> return this ; </a> 1
<a> } </a> 1
<a> public Builder method ( String methodType ) { </a> 1
<a> this . methodType = methodType ; </a> 1
<a> return this ; </a> 1
<a> } </a> 1
<a> public Builder contentType ( String contentType ) { </a> 1
<a> this . contentType = contentType ; </a> 1
<a> return this ; </a> 1
<a> } </a> 1
<a> public Builder body ( String data ) { </a> 1
<a> this . data = data ; </a> 1
<a> return this ; </a> 1
<a> } </a> 1
<a> public AtmosphereRequest build ( ) { </a> 1
<a> return new AtmosphereRequest ( this ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> public interface AtmosphereResourceEvent < E , F > { </a> 0
<a> public Object getMessage ( ) ; </a> 0
<a> public void setMessage ( Object o ) ; </a> 0
<a> public boolean isResumedOnTimeout ( ) ; </a> 0
<a> public boolean isCancelled ( ) ; </a> 0
<a> public boolean isSuspended ( ) ; </a> 0
<a> public boolean isResuming ( ) ; </a> 0
<a> public AtmosphereResource < E , F > getResource ( ) ; </a> 0
<a> public void write ( OutputStream os , Object o ) throws IOException ; </a> 0
<a> public Throwable throwable ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> public class AtmosphereResourceEventImpl implements AtmosphereResourceEvent < HttpServletRequest , </a> 0
<a> HttpServletResponse > { </a> 0
<a> private final AtomicBoolean isCancelled = new AtomicBoolean ( false ) ; </a> 0
<a> private final AtomicBoolean isResumedOnTimeout = new AtomicBoolean ( false ) ; </a> 0
<a> private Throwable throwable ; </a> 0
<a> protected Object message ; </a> 0
<a> protected final AtmosphereResourceImpl resource ; </a> 1
<a> public AtmosphereResourceEventImpl ( AtmosphereResourceImpl resource ) { </a> 0
<a> this . resource = resource ; </a> 0
<a> this . throwable = null ; </a> 0
<a> } </a> 0
<a> public AtmosphereResourceEventImpl ( AtmosphereResourceImpl resource , boolean isCancelled , </a> 0
<a> boolean isResumedOnTimeout ) { </a> 0
<a> this . isCancelled . set ( isCancelled ) ; </a> 0
<a> this . isResumedOnTimeout . set ( isResumedOnTimeout ) ; </a> 0
<a> this . resource = resource ; </a> 0
<a> this . throwable = null ; </a> 0
<a> } </a> 0
<a> public AtmosphereResourceEventImpl ( AtmosphereResourceImpl resource , boolean isCancelled , </a> 0
<a> boolean isResumedOnTimeout , </a> 0
<a> Throwable throwable ) { </a> 0
<a> this . isCancelled . set ( isCancelled ) ; </a> 0
<a> this . isResumedOnTimeout . set ( isResumedOnTimeout ) ; </a> 0
<a> this . resource = resource ; </a> 0
<a> this . throwable = throwable ; </a> 0
<a> } </a> 0
<a> public boolean isResuming ( ) { </a> 0
<a> return resource . action ( ) . type == AtmosphereServlet . Action . TYPE . RESUME ; </a> 0
<a> } </a> 0
<a> public boolean isSuspended ( ) { </a> 0
<a> return resource . action ( ) . type == AtmosphereServlet . Action . TYPE . SUSPEND ; </a> 0
<a> } </a> 0
<a> public Object getMessage ( ) { </a> 0
<a> return message ; </a> 0
<a> } </a> 0
<a> public void setMessage ( Object message ) { </a> 0
<a> this . message = message ; </a> 0
<a> } </a> 0
<a> public boolean isResumedOnTimeout ( ) { </a> 0
<a> return isResumedOnTimeout . get ( ) ; </a> 0
<a> } </a> 0
<a> public boolean isCancelled ( ) { </a> 0
<a> return isCancelled . get ( ) ; </a> 0
<a> } </a> 0
<a> protected void setCancelled ( boolean isCancelled ) { </a> 0
<a> this . isCancelled . set ( isCancelled ) ; </a> 0
<a> } </a> 0
<a> protected void setIsResumedOnTimeout ( boolean isResumedOnTimeout ) { </a> 0
<a> this . isResumedOnTimeout . set ( isResumedOnTimeout ) ; </a> 0
<a> } </a> 0
<a> public Throwable throwable ( ) { </a> 0
<a> return throwable ; </a> 0
<a> } </a> 0
<a> public AtmosphereResource < HttpServletRequest , HttpServletResponse > getResource ( ) { </a> 0
<a> return resource ; </a> 0
<a> } </a> 0
<a> public void write ( OutputStream os , Object o ) throws IOException { </a> 0
<a> resource . write ( os , o ) ; </a> 0
<a> } </a> 0
<a> public void setThrowable ( Throwable t ) { </a> 0
<a> this . throwable = throwable ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return "AtmosphereResourceEventImpl{" + "isResuming=" + isResuming ( ) + " isCancelled=" + isCancelled + ", isResumedOnTimeout=" + </a> 0
<a> isResumedOnTimeout + ", message=" + message + ", resource=" + resource + ", throwable=" + throwable + </a> 0
<a> '}' ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public interface AtmosphereResourceEventListener { </a> 0
<a> void onSuspend ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) ; </a> 0
<a> void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) ; </a> 0
<a> void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) ; </a> 0
<a> void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) ; </a> 0
<a> void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet . AtmosphereConfig ; </a> 0
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 1
<a> import javax . servlet . http . HttpServletResponse ; </a> 1
<a> import java . io . IOException ; </a> 1
<a> import java . io . OutputStream ; </a> 0
<a> import java . util . UUID ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . ACCESS_CONTROL_ALLOW_CREDENTIALS ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . ACCESS_CONTROL_ALLOW_ORIGIN ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . CACHE_CONTROL ; </a> 1
<a> import static org . atmosphere . cpr . HeaderConfig . EXPIRES ; </a> 1
<a> import static org . atmosphere . cpr . HeaderConfig . PRAGMA ; </a> 1
<a> import static org . atmosphere . cpr . HeaderConfig . WEBSOCKET_UPGRADE ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . X_ATMOSPHERE_ERROR ; </a> 0
<a> public class AtmosphereResourceImpl implements </a> 0
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > , AtmosphereEventLifecycle { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( AtmosphereResourceImpl . class ) ; </a> 0
<a> public static final String PRE_SUSPEND = AtmosphereResourceImpl . class . getName ( ) + ".preSuspend" ; </a> 0
<a> private final HttpServletRequest req ; </a> 0
<a> private final HttpServletResponse response ; </a> 0
<a> protected final AtmosphereServlet . Action action = new AtmosphereServlet . Action ( ) ; </a> 0
<a> protected Broadcaster broadcaster ; </a> 1
<a> private final AtmosphereConfig config ; </a> 0
<a> protected final CometSupport cometSupport ; </a> 1
<a> private Serializer serializer ; </a> 0
<a> private boolean isInScope = true ; </a> 0
<a> private final AtmosphereResourceEventImpl event ; </a> 0
<a> private final static String beginCompatibleData = createCompatibleStringJunk ( ) ; </a> 0
<a> private boolean useWriter = true ; </a> 0
<a> private final ConcurrentLinkedQueue < AtmosphereResourceEventListener > listeners = </a> 0
<a> new ConcurrentLinkedQueue < AtmosphereResourceEventListener > ( ) ; </a> 0
<a> private final boolean injectCacheHeaders ; </a> 0
<a> private final boolean enableAccessControl ; </a> 0
<a> private final AtomicBoolean isSuspendEvent = new AtomicBoolean ( false ) ; </a> 0
<a> private final AtmosphereHandler atmosphereHandler ; </a> 1
<a> private final boolean writeHeaders ; </a> 0
<a> public AtmosphereResourceImpl ( AtmosphereConfig config , Broadcaster broadcaster , </a> 0
<a> HttpServletRequest req , HttpServletResponse response , </a> 0
<a> CometSupport cometSupport , AtmosphereHandler atmosphereHandler ) { </a> 1
<a> this . req = req ; </a> 0
<a> this . response = response ; </a> 0
<a> this . broadcaster = broadcaster ; </a> 1
<a> this . config = config ; </a> 0
<a> this . cometSupport = cometSupport ; </a> 1
<a> this . atmosphereHandler = atmosphereHandler ; </a> 0
<a> this . event = new AtmosphereResourceEventImpl ( this ) ; </a> 0
<a> String nocache = config . getInitParameter ( ApplicationConfig . NO_CACHE_HEADERS ) ; </a> 1
<a> injectCacheHeaders = nocache != null ? false : true ; </a> 1
<a> String ac = config . getInitParameter ( ApplicationConfig . DROP_ACCESS_CONTROL_ALLOW_ORIGIN_HEADER ) ; </a> 0
<a> enableAccessControl = ac != null ? ! Boolean . parseBoolean ( ac ) : true ; </a> 0
<a> String wh = config . getInitParameter ( FrameworkConfig . WRITE_HEADERS ) ; </a> 0
<a> writeHeaders = wh != null ? Boolean . parseBoolean ( wh ) : true ; </a> 0
<a> req . setAttribute ( ApplicationConfig . NO_CACHE_HEADERS , injectCacheHeaders ) ; </a> 0
<a> req . setAttribute ( ApplicationConfig . DROP_ACCESS_CONTROL_ALLOW_ORIGIN_HEADER , enableAccessControl ) ; </a> 0
<a> } </a> 0
<a> public AtmosphereResourceEventImpl getAtmosphereResourceEvent ( ) { </a> 0
<a> return event ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public AtmosphereHandler getAtmosphereHandler ( ) { </a> 0
<a> return atmosphereHandler ; </a> 0
<a> } </a> 0
<a> public void resume ( ) { </a> 0
<a> if ( ! event . isResuming ( ) && ! event . isResumedOnTimeout ( ) && event . isSuspended ( ) && isInScope ) { </a> 1
<a> action . type = AtmosphereServlet . Action . TYPE . RESUME ; </a> 0
<a> Broadcaster b = getBroadcaster ( ) ; </a> 0
<a> if ( b instanceof DefaultBroadcaster ) { </a> 0
<a> ( ( DefaultBroadcaster ) b ) . broadcastOnResume ( this ) ; </a> 0
<a> } </a> 0
<a> notifyListeners ( ) ; </a> 0
<a> listeners . clear ( ) ; </a> 0
<a> try { </a> 1
<a> broadcaster . removeAtmosphereResource ( this ) ; </a> 1
<a> } catch ( IllegalStateException ex ) { </a> 1
<a> logger . warn ( "Unable to resume" , this ) ; </a> 1
<a> logger . debug ( ex . getMessage ( ) , ex ) ; </a> 1
<a> } </a> 0
<a> if ( BroadcasterFactory . getDefault ( ) != null ) { </a> 1
<a> BroadcasterFactory . getDefault ( ) . removeAllAtmosphereResource ( this ) ; </a> 1
<a> } </a> 0
<a> try { </a> 0
<a> req . setAttribute ( ApplicationConfig . RESUMED_ON_TIMEOUT , Boolean . FALSE ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 1
<a> logger . debug ( "Cannot resume an already resumed/cancelled request" ) ; </a> 0
<a> } </a> 1
<a> if ( req . getAttribute ( PRE_SUSPEND ) == null ) { </a> 0
<a> cometSupport . action ( this ) ; </a> 1
<a> } </a> 0
<a> } else { </a> 0
<a> logger . debug ( "Cannot resume an already resumed/cancelled request" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void suspend ( ) { </a> 1
<a> suspend ( - 1 ) ; </a> 1
<a> } </a> 0
<a> public void suspend ( long timeout ) { </a> 1
<a> suspend ( timeout , true ) ; </a> 1
<a> } </a> 0
<a> public void suspend ( long timeout , TimeUnit timeunit ) { </a> 1
<a> suspend ( timeout , timeunit , true ) ; </a> 1
<a> } </a> 0
<a> public void suspend ( long timeout , TimeUnit timeunit , boolean flushComment ) { </a> 1
<a> long timeoutms = - 1 ; </a> 0
<a> if ( timeunit != null ) { </a> 0
<a> timeoutms = TimeUnit . MILLISECONDS . convert ( timeout , timeunit ) ; </a> 0
<a> } </a> 0
<a> suspend ( timeoutms , true ) ; </a> 1
<a> } </a> 0
<a> public void suspend ( long timeout , boolean flushComment ) { </a> 1
<a> if ( req . getSession ( false ) != null && req . getSession ( ) . getMaxInactiveInterval ( ) != - 1 && req . getSession ( ) . getMaxInactiveInterval ( ) * 1000 < timeout ) { </a> 0
<a> throw new IllegalStateException ( "Cannot suspend a " + </a> 0
<a> "response longer than the session timeout. Increase the value of session-timeout in web.xml" ) ; </a> 0
<a> } </a> 0
<a> if ( req . getAttribute ( DefaultBroadcaster . CACHED ) != null ) { </a> 1
<a> req . removeAttribute ( DefaultBroadcaster . CACHED ) ; </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> if ( ! event . isResumedOnTimeout ( ) ) { </a> 0
<a> if ( req . getHeaders ( "Connection" ) != null && req . getHeaders ( "Connection" ) . hasMoreElements ( ) ) { </a> 0
<a> String [ ] e = req . getHeaders ( "Connection" ) . nextElement ( ) . split ( "," ) ; </a> 1
<a> for ( String upgrade : e ) { </a> 0
<a> if ( upgrade . trim ( ) . equalsIgnoreCase ( WEBSOCKET_UPGRADE ) ) { </a> 0
<a> if ( writeHeaders && ! cometSupport . supportWebSocket ( ) ) { </a> 1
<a> response . addHeader ( X_ATMOSPHERE_ERROR , "Websocket protocol not supported" ) ; </a> 0
<a> } else { </a> 0
<a> flushComment = false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( writeHeaders && injectCacheHeaders ) { </a> 1
<a> response . setHeader ( EXPIRES , "-1" ) ; </a> 1
<a> response . setHeader ( CACHE_CONTROL , "no-store, no-cache, must-revalidate" ) ; </a> 1
<a> response . setHeader ( PRAGMA , "no-cache" ) ; </a> 1
<a> } </a> 1
<a> if ( writeHeaders && enableAccessControl ) { </a> 0
<a> response . setHeader ( ACCESS_CONTROL_ALLOW_ORIGIN , "*" ) ; </a> 1
<a> response . setHeader ( ACCESS_CONTROL_ALLOW_CREDENTIALS , "true" ) ; </a> 0
<a> } </a> 0
<a> if ( flushComment ) { </a> 0
<a> write ( ) ; </a> 1
<a> } </a> 0
<a> req . setAttribute ( PRE_SUSPEND , "true" ) ; </a> 0
<a> action . type = AtmosphereServlet . Action . TYPE . SUSPEND ; </a> 0
<a> action . timeout = timeout ; </a> 0
<a> if ( broadcaster . getScope ( ) == Broadcaster . SCOPE . REQUEST ) { </a> 0
<a> String id = broadcaster . getID ( ) ; </a> 1
<a> Class < ? extends Broadcaster > clazz = broadcaster . getClass ( ) ; </a> 1
<a> broadcaster = BroadcasterFactory . getDefault ( ) . lookup ( clazz , id , false ) ; </a> 1
<a> if ( broadcaster == null || broadcaster . getAtmosphereResources ( ) . size ( ) > 0 ) { </a> 0
<a> broadcaster = BroadcasterFactory . getDefault ( ) . lookup ( clazz , id + "/" + UUID . randomUUID ( ) , true ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> broadcaster . addAtmosphereResource ( this ) ; </a> 0
<a> req . removeAttribute ( PRE_SUSPEND ) ; </a> 0
<a> notifyListeners ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void write ( ) { </a> 1
<a> try { </a> 0
<a> if ( useWriter && ! ( ( Boolean ) req . getAttribute ( ApplicationConfig . PROPERTY_USE_STREAM ) ) ) { </a> 0
<a> try { </a> 0
<a> response . getWriter ( ) ; </a> 0
<a> } catch ( IllegalStateException e ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> response . getWriter ( ) . write ( beginCompatibleData ) ; </a> 1
<a> response . getWriter ( ) . flush ( ) ; </a> 0
<a> } else { </a> 0
<a> try { </a> 0
<a> response . getOutputStream ( ) ; </a> 0
<a> } catch ( IllegalStateException e ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> response . getOutputStream ( ) . write ( beginCompatibleData . getBytes ( ) ) ; </a> 1
<a> response . getOutputStream ( ) . flush ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable ex ) { </a> 0
<a> logger . warn ( "failed to write to response" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public HttpServletRequest getRequest ( ) { </a> 1
<a> if ( ! isInScope ) { </a> 1
<a> throw new IllegalStateException ( "Request object no longer" + " valid. This object has been cancelled" ) ; </a> 0
<a> } </a> 0
<a> return req ; </a> 0
<a> } </a> 0
<a> public HttpServletResponse getResponse ( ) { </a> 1
<a> if ( ! isInScope ) { </a> 1
<a> throw new IllegalStateException ( "Response object no longer valid. This object has been cancelled" ) ; </a> 0
<a> } </a> 0
<a> return response ; </a> 0
<a> } </a> 0
<a> public Broadcaster getBroadcaster ( ) { </a> 0
<a> if ( broadcaster == null ) { </a> 0
<a> throw new IllegalStateException ( "No Broadcaster associated with this AtmosphereResource." ) ; </a> 0
<a> } </a> 0
<a> return broadcaster ; </a> 0
<a> } </a> 0
<a> public void setBroadcaster ( Broadcaster broadcaster ) { </a> 1
<a> this . broadcaster = broadcaster ; </a> 1
<a> if ( broadcaster != null ) { </a> 0
<a> broadcaster . getBroadcasterConfig ( ) . setAtmosphereConfig ( config ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public AtmosphereConfig getAtmosphereConfig ( ) { </a> 0
<a> return config ; </a> 0
<a> } </a> 0
<a> public Action action ( ) { </a> 0
<a> return action ; </a> 0
<a> } </a> 0
<a> protected void setIsInScope ( boolean isInScope ) { </a> 0
<a> this . isInScope = isInScope ; </a> 0
<a> } </a> 0
<a> public boolean isInScope ( ) { </a> 0
<a> return isInScope ; </a> 0
<a> } </a> 0
<a> public void setSerializer ( Serializer s ) { </a> 1
<a> serializer = s ; </a> 0
<a> } </a> 0
<a> public void write ( OutputStream os , Object o ) throws IOException { </a> 1
<a> if ( o == null ) throw new IllegalStateException ( "Object cannot be null" ) ; </a> 0
<a> if ( serializer != null ) { </a> 0
<a> serializer . write ( os , o ) ; </a> 0
<a> } else { </a> 0
<a> response . getOutputStream ( ) . write ( o . toString ( ) . getBytes ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> public Serializer getSerializer ( ) { </a> 0
<a> return serializer ; </a> 0
<a> } </a> 0
<a> public static String createCompatibleStringJunk ( ) { </a> 0
<a> StringBuilder s = new StringBuilder ( ) ; </a> 0
<a> s . append ( "<!-- ----------------------------------------------------------" + </a> 0
<a> "------ http://github.com/Atmosphere ----------------------------" + </a> 0
<a> "-------------------------------------------- -->\n" ) ; </a> 0
<a> s . append ( "<!-- Welcome to the Atmosphere Framework. To work with all the" + </a> 0
<a> " browsers when suspending connection, Atmosphere must output some" + </a> 0
<a> " data to makes WebKit based browser working.-->\n" ) ; </a> 0
<a> for ( int i = 0 ; i < 10 ; i ++ ) { </a> 0
<a> s . append ( "<!-- ----------------------------------------------------------" + </a> 0
<a> "---------------------------------------------------------------" + </a> 0
<a> "-------------------------------------------- -->\n" ) ; </a> 0
<a> } </a> 0
<a> s . append ( "<!-- EOD -->" ) ; </a> 0
<a> return s . toString ( ) ; </a> 0
<a> } </a> 0
<a> public void addEventListener ( AtmosphereResourceEventListener e ) { </a> 0
<a> if ( listeners . contains ( e ) ) return ; </a> 0
<a> listeners . add ( e ) ; </a> 0
<a> } </a> 1
<a> public void removeEventListener ( AtmosphereResourceEventListener e ) { </a> 0
<a> listeners . remove ( e ) ; </a> 0
<a> } </a> 0
<a> public void removeEventListeners ( ) { </a> 0
<a> listeners . clear ( ) ; </a> 0
<a> } </a> 0
<a> public void notifyListeners ( ) { </a> 0
<a> notifyListeners ( event ) ; </a> 0
<a> } </a> 0
<a> public void notifyListeners ( AtmosphereResourceEvent event ) { </a> 0
<a> logger . debug ( "Invoking listener with {}" , event ) ; </a> 0
<a> if ( event . isResuming ( ) || event . isResumedOnTimeout ( ) ) { </a> 0
<a> onResume ( event ) ; </a> 0
<a> } else if ( event . isCancelled ( ) ) { </a> 0
<a> onDisconnect ( event ) ; </a> 0
<a> } else if ( ! isSuspendEvent . getAndSet ( true ) && event . isSuspended ( ) ) { </a> 0
<a> onSuspend ( event ) ; </a> 0
<a> } else if ( event . throwable ( ) != null ) { </a> 0
<a> onThrowable ( event ) ; </a> 0
<a> } else { </a> 0
<a> onBroadcast ( event ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onThrowable ( Throwable t ) { </a> 0
<a> onThrowable ( new AtmosphereResourceEventImpl ( this , false , false , t ) ) ; </a> 0
<a> } </a> 0
<a> void onThrowable ( AtmosphereResourceEvent e ) { </a> 0
<a> AtmosphereHandler < HttpServletRequest , HttpServletResponse > atmosphereHandler = </a> 0
<a> ( AtmosphereHandler < HttpServletRequest , HttpServletResponse > ) </a> 0
<a> req . getAttribute ( FrameworkConfig . ATMOSPHERE_HANDLER ) ; </a> 1
<a> for ( AtmosphereResourceEventListener r : listeners ) { </a> 0
<a> r . onThrowable ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void onSuspend ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > e ) { </a> 0
<a> for ( AtmosphereResourceEventListener r : listeners ) { </a> 0
<a> r . onSuspend ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > e ) { </a> 0
<a> for ( AtmosphereResourceEventListener r : listeners ) { </a> 0
<a> r . onResume ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > e ) { </a> 0
<a> for ( AtmosphereResourceEventListener r : listeners ) { </a> 0
<a> r . onDisconnect ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > e ) { </a> 0
<a> for ( AtmosphereResourceEventListener r : listeners ) { </a> 0
<a> r . onBroadcast ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public ConcurrentLinkedQueue < AtmosphereResourceEventListener > atmosphereResourceEventListener ( ) { </a> 0
<a> return listeners ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public String toString ( ) { </a> 1
<a> return "AtmosphereResourceImpl{" + </a> 0
<a> ", action=" + action + </a> 0
<a> ", broadcaster=" + broadcaster . getClass ( ) . getName ( ) + </a> 0
<a> ", cometSupport=" + cometSupport + </a> 0
<a> ", serializer=" + serializer + </a> 0
<a> ", isInScope=" + isInScope + </a> 0
<a> ", useWriter=" + useWriter + </a> 0
<a> ", listeners=" + listeners + </a> 0
<a> '}' ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 1
<a> import org . apache . catalina . CometEvent ; </a> 0
<a> import org . apache . catalina . CometProcessor ; </a> 0
<a> import org . atmosphere . container . BlockingIOCometSupport ; </a> 0
<a> import org . atmosphere . container . JBossWebCometSupport ; </a> 0
<a> import org . atmosphere . container . Tomcat7CometSupport ; </a> 0
<a> import org . atmosphere . container . TomcatCometSupport ; </a> 0
<a> import org . atmosphere . container . WebLogicCometSupport ; </a> 0
<a> import org . atmosphere . di . InjectorProvider ; </a> 1
<a> import org . atmosphere . di . ServletContextHolder ; </a> 1
<a> import org . atmosphere . di . ServletContextProvider ; </a> 1
<a> import org . atmosphere . handler . ReflectorServletProcessor ; </a> 0
<a> import org . atmosphere . util . AtmosphereConfigReader ; </a> 0
<a> import org . atmosphere . util . AtmosphereConfigReader . Property ; </a> 0
<a> import org . atmosphere . util . IntrospectionUtils ; </a> 0
<a> import org . atmosphere . util . Version ; </a> 0
<a> import org . atmosphere . websocket . JettyWebSocketHandler ; </a> 0
<a> import org . atmosphere . websocket . WebSocket ; </a> 0
<a> import org . atmosphere . websocket . protocol . SimpleHttpProtocol ; </a> 0
<a> import org . jboss . servlet . http . HttpEvent ; </a> 1
<a> import org . jboss . servlet . http . HttpEventServlet ; </a> 1
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import weblogic . servlet . http . AbstractAsyncServlet ; </a> 0
<a> import weblogic . servlet . http . RequestResponseKey ; </a> 0
<a> import javax . servlet . Servlet ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . File ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . lang . reflect . InvocationTargetException ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> import java . net . URISyntaxException ; </a> 0
<a> import java . net . URL ; </a> 0
<a> import java . net . URLClassLoader ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Enumeration ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . BROADCASTER_CACHE ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . BROADCASTER_CLASS ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . BROADCASTER_FACTORY ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . BROADCASTER_LIFECYCLE_POLICY ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . BROADCAST_FILTER_CLASSES ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . DEFAULT_NAMED_DISPATCHER ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . DISABLE_ONSTATE_EVENT ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . PROPERTY_BLOCKING_COMETSUPPORT ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . PROPERTY_COMET_SUPPORT ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . PROPERTY_NATIVE_COMETSUPPORT ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . PROPERTY_SERVLET_MAPPING ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . PROPERTY_SESSION_SUPPORT ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . PROPERTY_USE_STREAM ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . RESUME_AND_KEEPALIVE ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . SUPPORT_TRACKABLE ; </a> 1
<a> import static org . atmosphere . cpr . ApplicationConfig . WEBSOCKET_PROCESSOR ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . WEBSOCKET_SUPPORT ; </a> 0
<a> import static org . atmosphere . cpr . ApplicationConfig . ALLOW_QUERYSTRING_AS_REQUEST ; </a> 1
<a> import static org . atmosphere . cpr . FrameworkConfig . ATMOSPHERE_HANDLER ; </a> 0
<a> import static org . atmosphere . cpr . FrameworkConfig . JERSEY_BROADCASTER ; </a> 0
<a> import static org . atmosphere . cpr . FrameworkConfig . JERSEY_CONTAINER ; </a> 0
<a> import static org . atmosphere . cpr . FrameworkConfig . JGROUPS_BROADCASTER ; </a> 0
<a> import static org . atmosphere . cpr . FrameworkConfig . JMS_BROADCASTER ; </a> 0
<a> import static org . atmosphere . cpr . FrameworkConfig . REDIS_BROADCASTER ; </a> 0
<a> import static org . atmosphere . cpr . FrameworkConfig . WEB_INF_CLASSES ; </a> 0
<a> import static org . atmosphere . cpr . FrameworkConfig . WRITE_HEADERS ; </a> 0
<a> import static org . atmosphere . cpr . FrameworkConfig . XMPP_BROADCASTER ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . ATMOSPHERE_POST_BODY ; </a> 0
<a> public class AtmosphereServlet extends AbstractAsyncServlet implements CometProcessor , HttpEventServlet , ServletContextProvider , org . apache . catalina . comet . CometProcessor { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( AtmosphereServlet . class ) ; </a> 0
<a> private final ArrayList < String > possibleAtmosphereHandlersCandidate = new ArrayList < String > ( ) ; </a> 0
<a> private final HashMap < String , String > initParams = new HashMap < String , String > ( ) ; </a> 0
<a> protected final AtmosphereConfig config = new AtmosphereConfig ( ) ; </a> 0
<a> protected final AtomicBoolean isCometSupportConfigured = new AtomicBoolean ( false ) ; </a> 0
<a> protected final boolean isFilter ; </a> 0
<a> public static String [ ] broadcasterFilters = new String [ 0 ] ; </a> 0
<a> protected final Map < String , AtmosphereHandlerWrapper > atmosphereHandlers = </a> 0
<a> new ConcurrentHashMap < String , AtmosphereHandlerWrapper > ( ) ; </a> 0
<a> private final ConcurrentLinkedQueue < String > broadcasterTypes = new ConcurrentLinkedQueue < String > ( ) ; </a> 0
<a> protected boolean useNativeImplementation = false ; </a> 0
<a> protected boolean useBlockingImplementation = false ; </a> 0
<a> protected boolean useStreamForFlushingComments = false ; </a> 0
<a> protected CometSupport cometSupport ; </a> 0
<a> protected static String broadcasterClassName = DefaultBroadcaster . class . getName ( ) ; </a> 0
<a> protected boolean isCometSupportSpecified = false ; </a> 0
<a> protected boolean isBroadcasterSpecified = false ; </a> 0
<a> protected boolean isSessionSupportSpecified = false ; </a> 0
<a> private BroadcasterFactory broadcasterFactory ; </a> 0
<a> protected String broadcasterFactoryClassName ; </a> 0
<a> protected static String broadcasterCacheClassName ; </a> 0
<a> private boolean webSocketEnabled = false ; </a> 1
<a> private String broadcasterLifeCyclePolicy = "NEVER" ; </a> 0
<a> private String webSocketProcessorClassName = SimpleHttpProtocol . class . getName ( ) ; </a> 0
<a> public static final class AtmosphereHandlerWrapper { </a> 0
<a> public final AtmosphereHandler atmosphereHandler ; </a> 0
<a> public Broadcaster broadcaster ; </a> 0
<a> public AtmosphereHandlerWrapper ( AtmosphereHandler atmosphereHandler ) { </a> 0
<a> this . atmosphereHandler = atmosphereHandler ; </a> 0
<a> try { </a> 0
<a> broadcaster = BroadcasterFactory . getDefault ( ) . get ( ) ; </a> 0
<a> } catch ( Exception t ) { </a> 0
<a> throw new RuntimeException ( t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public AtmosphereHandlerWrapper ( AtmosphereHandler atmosphereHandler , Broadcaster broadcaster ) { </a> 0
<a> this . atmosphereHandler = atmosphereHandler ; </a> 0
<a> this . broadcaster = broadcaster ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return "AtmosphereHandlerWrapper{ atmosphereHandler=" + atmosphereHandler + ", broadcaster=" + </a> 0
<a> broadcaster + " }" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public AtmosphereConfig getAtmosphereConfig ( ) { </a> 1
<a> return config ; </a> 1
<a> } </a> 1
<a> public class AtmosphereConfig { </a> 0
<a> private boolean supportSession = true ; </a> 0
<a> private BroadcasterFactory broadcasterFactory ; </a> 0
<a> private String dispatcherName = DEFAULT_NAMED_DISPATCHER ; </a> 0
<a> private Map < String , Object > properties = new HashMap < String , Object > ( ) ; </a> 0
<a> protected Map < String , AtmosphereHandlerWrapper > handlers ( ) { </a> 0
<a> return AtmosphereServlet . this . atmosphereHandlers ; </a> 0
<a> } </a> 0
<a> public ServletContext getServletContext ( ) { </a> 0
<a> return AtmosphereServlet . this . getServletContext ( ) ; </a> 0
<a> } </a> 0
<a> public String getDispatcherName ( ) { </a> 0
<a> return dispatcherName ; </a> 0
<a> } </a> 0
<a> public void setDispatcherName ( String dispatcherName ) { </a> 0
<a> this . dispatcherName = dispatcherName ; </a> 0
<a> } </a> 0
<a> public String getInitParameter ( String name ) { </a> 0
<a> String s = initParams . get ( name ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> return s ; </a> 0
<a> } </a> 0
<a> return AtmosphereServlet . this . getInitParameter ( name ) ; </a> 0
<a> } </a> 0
<a> public Enumeration getInitParameterNames ( ) { </a> 0
<a> return AtmosphereServlet . this . getInitParameterNames ( ) ; </a> 0
<a> } </a> 0
<a> public ServletConfig getServletConfig ( ) { </a> 0
<a> return AtmosphereServlet . this . getServletConfig ( ) ; </a> 0
<a> } </a> 0
<a> public String getWebServerName ( ) { </a> 0
<a> return AtmosphereServlet . this . cometSupport . getContainerName ( ) ; </a> 0
<a> } </a> 0
<a> public BroadcasterFactory getBroadcasterFactory ( ) { </a> 0
<a> return broadcasterFactory ; </a> 0
<a> } </a> 0
<a> public boolean isSupportSession ( ) { </a> 0
<a> return supportSession ; </a> 0
<a> } </a> 0
<a> public void setSupportSession ( boolean supportSession ) { </a> 0
<a> this . supportSession = supportSession ; </a> 0
<a> } </a> 0
<a> public AtmosphereServlet getServlet ( ) { </a> 0
<a> return AtmosphereServlet . this ; </a> 0
<a> } </a> 0
<a> public Map < String , Object > properties ( ) { </a> 0
<a> return properties ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static class Action { </a> 0
<a> public enum TYPE { </a> 0
<a> SUSPEND , RESUME , TIMEOUT , CANCELLED , KEEP_ALIVED , CREATED </a> 0
<a> } </a> 0
<a> public long timeout = - 1L ; </a> 0
<a> public TYPE type ; </a> 0
<a> public Action ( ) { </a> 0
<a> type = TYPE . CREATED ; </a> 0
<a> } </a> 0
<a> public Action ( TYPE type ) { </a> 0
<a> this . type = type ; </a> 0
<a> } </a> 0
<a> public Action ( TYPE type , long timeout ) { </a> 0
<a> this . timeout = timeout ; </a> 0
<a> this . type = type ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public AtmosphereServlet ( ) { </a> 0
<a> this ( false ) ; </a> 0
<a> } </a> 0
<a> public AtmosphereServlet ( boolean isFilter ) { </a> 0
<a> this . isFilter = isFilter ; </a> 0
<a> readSystemProperties ( ) ; </a> 0
<a> populateBroadcasterType ( ) ; </a> 0
<a> } </a> 0
<a> protected void configureDefaultBroadcasterFactory ( ) { </a> 1
<a> Class < ? extends Broadcaster > b = null ; </a> 1
<a> String defaultBroadcasterClassName = AtmosphereServlet . getDefaultBroadcasterClassName ( ) ; </a> 1
<a> try { </a> 1
<a> ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; </a> 1
<a> b = ( Class < ? extends Broadcaster > ) cl . loadClass ( defaultBroadcasterClassName ) ; </a> 1
<a> } catch ( ClassNotFoundException e ) { </a> 1
<a> logger . error ( "failed to load default broadcaster class name: " + defaultBroadcasterClassName , e ) ; </a> 1
<a> } </a> 1
<a> Class bc = ( b == null ? DefaultBroadcaster . class : b ) ; </a> 1
<a> BroadcasterFactory . setBroadcasterFactory ( new DefaultBroadcasterFactory ( bc , broadcasterLifeCyclePolicy ) , config ) ; </a> 0
<a> } </a> 1
<a> private void populateBroadcasterType ( ) { </a> 0
<a> broadcasterTypes . add ( XMPP_BROADCASTER ) ; </a> 0
<a> broadcasterTypes . add ( REDIS_BROADCASTER ) ; </a> 0
<a> broadcasterTypes . add ( JGROUPS_BROADCASTER ) ; </a> 0
<a> broadcasterTypes . add ( JMS_BROADCASTER ) ; </a> 0
<a> } </a> 0
<a> public void addAtmosphereHandler ( String mapping , AtmosphereHandler h ) { </a> 0
<a> if ( ! mapping . startsWith ( "/" ) ) { </a> 0
<a> mapping = "/" + mapping ; </a> 0
<a> } </a> 0
<a> AtmosphereHandlerWrapper w = new AtmosphereHandlerWrapper ( h ) ; </a> 0
<a> atmosphereHandlers . put ( mapping , w ) ; </a> 0
<a> logger . info ( "Installed AtmosphereHandler {} mapped to context-path: {}" , h . getClass ( ) . getName ( ) , mapping ) ; </a> 0
<a> } </a> 0
<a> public void addAtmosphereHandler ( String mapping , AtmosphereHandler h , String broadcasterId ) { </a> 0
<a> if ( ! mapping . startsWith ( "/" ) ) { </a> 0
<a> mapping = "/" + mapping ; </a> 0
<a> } </a> 0
<a> AtmosphereHandlerWrapper w = new AtmosphereHandlerWrapper ( h ) ; </a> 0
<a> w . broadcaster . setID ( broadcasterId ) ; </a> 0
<a> atmosphereHandlers . put ( mapping , w ) ; </a> 0
<a> logger . info ( "Installed AtmosphereHandler {} mapped to context-path: {}" , h . getClass ( ) . getName ( ) , mapping ) ; </a> 0
<a> } </a> 0
<a> public void addAtmosphereHandler ( String mapping , AtmosphereHandler < HttpServletRequest , HttpServletResponse > h , Broadcaster broadcaster ) { </a> 0
<a> if ( ! mapping . startsWith ( "/" ) ) { </a> 0
<a> mapping = "/" + mapping ; </a> 0
<a> } </a> 0
<a> AtmosphereHandlerWrapper w = new AtmosphereHandlerWrapper ( h , broadcaster ) ; </a> 0
<a> atmosphereHandlers . put ( mapping , w ) ; </a> 0
<a> logger . info ( "Installed AtmosphereHandler {} mapped to context-path: {}" , h . getClass ( ) . getName ( ) , mapping ) ; </a> 0
<a> } </a> 0
<a> public boolean removeAtmosphereHandler ( String mapping ) { </a> 0
<a> return atmosphereHandlers . remove ( mapping ) == null ? false : true ; </a> 0
<a> } </a> 0
<a> public void removeAllAtmosphereHandler ( ) { </a> 0
<a> atmosphereHandlers . clear ( ) ; </a> 0
<a> } </a> 0
<a> public void removeAllInitParams ( ) { </a> 0
<a> initParams . clear ( ) ; </a> 0
<a> } </a> 0
<a> public void addInitParameter ( String name , String value ) { </a> 0
<a> initParams . put ( name , value ) ; </a> 0
<a> } </a> 0
<a> protected void readSystemProperties ( ) { </a> 0
<a> if ( System . getProperty ( PROPERTY_NATIVE_COMETSUPPORT ) != null ) { </a> 0
<a> useNativeImplementation = Boolean </a> 0
<a> . parseBoolean ( System . getProperty ( PROPERTY_NATIVE_COMETSUPPORT ) ) ; </a> 0
<a> isCometSupportSpecified = true ; </a> 0
<a> } </a> 0
<a> if ( System . getProperty ( PROPERTY_BLOCKING_COMETSUPPORT ) != null ) { </a> 0
<a> useBlockingImplementation = Boolean </a> 0
<a> . parseBoolean ( System . getProperty ( PROPERTY_BLOCKING_COMETSUPPORT ) ) ; </a> 0
<a> isCometSupportSpecified = true ; </a> 0
<a> } </a> 0
<a> if ( System . getProperty ( DISABLE_ONSTATE_EVENT ) != null ) { </a> 0
<a> initParams . put ( DISABLE_ONSTATE_EVENT , System . getProperty ( DISABLE_ONSTATE_EVENT ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void init ( final ServletConfig sc ) throws ServletException { </a> 0
<a> try { </a> 0
<a> super . init ( sc ) ; </a> 0
<a> ServletContextHolder . register ( this ) ; </a> 0
<a> ServletConfig scFacade = new ServletConfig ( ) { </a> 0
<a> public String getServletName ( ) { </a> 0
<a> return sc . getServletName ( ) ; </a> 0
<a> } </a> 0
<a> public ServletContext getServletContext ( ) { </a> 0
<a> return sc . getServletContext ( ) ; </a> 0
<a> } </a> 0
<a> public String getInitParameter ( String name ) { </a> 0
<a> String param = sc . getInitParameter ( name ) ; </a> 0
<a> if ( param == null ) { </a> 0
<a> return initParams . get ( name ) ; </a> 0
<a> } </a> 0
<a> return param ; </a> 0
<a> } </a> 0
<a> public Enumeration < String > getInitParameterNames ( ) { </a> 0
<a> return sc . getInitParameterNames ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> doInitParams ( scFacade ) ; </a> 0
<a> configureDefaultBroadcasterFactory ( ) ; </a> 0
<a> doInitParamsForWebSocket ( scFacade ) ; </a> 0
<a> loadConfiguration ( scFacade ) ; </a> 0
<a> autoDetectContainer ( ) ; </a> 0
<a> configureBroadcaster ( sc . getServletContext ( ) ) ; </a> 1
<a> configureWebDotXmlAtmosphereHandler ( sc ) ; </a> 0
<a> cometSupport . init ( scFacade ) ; </a> 0
<a> initAtmosphereHandler ( scFacade ) ; </a> 0
<a> logger . info ( "Using broadcaster class: {}" , broadcasterClassName ) ; </a> 0
<a> logger . info ( "Atmosphere Framework {} started." , Version . getRawVersion ( ) ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . error ( "failed to initialize atmosphere framework" , t ) ; </a> 0
<a> if ( t instanceof ServletException ) { </a> 0
<a> throw ( ServletException ) t ; </a> 0
<a> } </a> 0
<a> throw new ServletException ( t . getCause ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void configureWebDotXmlAtmosphereHandler ( ServletConfig sc ) { </a> 0
<a> String s = sc . getInitParameter ( ATMOSPHERE_HANDLER ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; </a> 0
<a> try { </a> 0
<a> addAtmosphereHandler ( "/*" , ( AtmosphereHandler < ? , ? > ) cl . loadClass ( s ) . newInstance ( ) ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> logger . warn ( "Unable to load WebSocketHandle instance" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void configureBroadcaster ( ServletContext sc ) throws ClassNotFoundException , InstantiationException , IllegalAccessException { </a> 0
<a> if ( broadcasterFactoryClassName != null ) { </a> 0
<a> logger . info ( "Using BroadcasterFactory class: {}" , broadcasterFactoryClassName ) ; </a> 1
<a> broadcasterFactory = ( BroadcasterFactory ) Thread . currentThread ( ) . getContextClassLoader ( ) </a> 0
<a> . loadClass ( broadcasterFactoryClassName ) . newInstance ( ) ; </a> 0
<a> } </a> 0
<a> if ( broadcasterFactory == null ) { </a> 0
<a> Class < ? extends Broadcaster > bc = </a> 0
<a> ( Class < ? extends Broadcaster > ) Thread . currentThread ( ) . getContextClassLoader ( ) </a> 0
<a> . loadClass ( broadcasterClassName ) ; </a> 0
<a> broadcasterFactory = new DefaultBroadcasterFactory ( bc , broadcasterLifeCyclePolicy ) ; </a> 0
<a> } </a> 0
<a> sc . setAttribute ( BroadcasterFactory . class . getName ( ) , broadcasterFactory ) ; </a> 1
<a> config . broadcasterFactory = broadcasterFactory ; </a> 0
<a> BroadcasterFactory . setBroadcasterFactory ( broadcasterFactory , config ) ; </a> 0
<a> InjectorProvider . getInjector ( ) . inject ( broadcasterFactory ) ; </a> 0
<a> Iterator < Entry < String , AtmosphereHandlerWrapper > > i = atmosphereHandlers . entrySet ( ) . iterator ( ) ; </a> 0
<a> AtmosphereHandlerWrapper w ; </a> 0
<a> Entry < String , AtmosphereHandlerWrapper > e ; </a> 0
<a> while ( i . hasNext ( ) ) { </a> 0
<a> e = i . next ( ) ; </a> 0
<a> w = e . getValue ( ) ; </a> 0
<a> BroadcasterConfig broadcasterConfig = new BroadcasterConfig ( broadcasterFilters , config ) ; </a> 0
<a> if ( w . broadcaster == null ) { </a> 0
<a> w . broadcaster = broadcasterFactory . get ( ) ; </a> 1
<a> } else { </a> 0
<a> w . broadcaster . setBroadcasterConfig ( broadcasterConfig ) ; </a> 0
<a> if ( broadcasterCacheClassName != null ) { </a> 0
<a> BroadcasterCache cache = ( BroadcasterCache ) Thread . currentThread ( ) . getContextClassLoader ( ) </a> 0
<a> . loadClass ( broadcasterCacheClassName ) . newInstance ( ) ; </a> 0
<a> InjectorProvider . getInjector ( ) . inject ( cache ) ; </a> 0
<a> broadcasterConfig . setBroadcasterCache ( cache ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> w . broadcaster . setID ( e . getKey ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void doInitParamsForWebSocket ( ServletConfig sc ) { </a> 0
<a> String s = sc . getInitParameter ( WEBSOCKET_SUPPORT ) ; </a> 0
<a> if ( s != null ) { </a> 1
<a> webSocketEnabled = true ; </a> 1
<a> sessionSupport ( false ) ; </a> 0
<a> } </a> 0
<a> s = sc . getInitParameter ( WEBSOCKET_PROCESSOR ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> webSocketProcessorClassName = s ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void doInitParams ( ServletConfig sc ) { </a> 0
<a> String s = sc . getInitParameter ( PROPERTY_NATIVE_COMETSUPPORT ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> useNativeImplementation = Boolean . parseBoolean ( s ) ; </a> 0
<a> if ( useNativeImplementation ) isCometSupportSpecified = true ; </a> 0
<a> } </a> 0
<a> s = sc . getInitParameter ( PROPERTY_BLOCKING_COMETSUPPORT ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> useBlockingImplementation = Boolean . parseBoolean ( s ) ; </a> 0
<a> if ( useBlockingImplementation ) isCometSupportSpecified = true ; </a> 0
<a> } </a> 0
<a> s = sc . getInitParameter ( PROPERTY_USE_STREAM ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> useStreamForFlushingComments = Boolean . parseBoolean ( s ) ; </a> 0
<a> } </a> 0
<a> s = sc . getInitParameter ( PROPERTY_COMET_SUPPORT ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> cometSupport = new DefaultCometSupportResolver ( config ) . newCometSupport ( s ) ; </a> 0
<a> isCometSupportSpecified = true ; </a> 0
<a> } </a> 0
<a> s = sc . getInitParameter ( BROADCASTER_CLASS ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> broadcasterClassName = s ; </a> 0
<a> isBroadcasterSpecified = true ; </a> 0
<a> } </a> 0
<a> s = sc . getInitParameter ( BROADCASTER_CACHE ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> broadcasterCacheClassName = s ; </a> 0
<a> } </a> 0
<a> s = sc . getInitParameter ( PROPERTY_SESSION_SUPPORT ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> config . supportSession = Boolean . valueOf ( s ) ; </a> 0
<a> isSessionSupportSpecified = true ; </a> 0
<a> } </a> 0
<a> s = sc . getInitParameter ( DISABLE_ONSTATE_EVENT ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> initParams . put ( DISABLE_ONSTATE_EVENT , s ) ; </a> 0
<a> } else { </a> 0
<a> initParams . put ( DISABLE_ONSTATE_EVENT , "false" ) ; </a> 0
<a> } </a> 0
<a> s = sc . getInitParameter ( RESUME_AND_KEEPALIVE ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> initParams . put ( RESUME_AND_KEEPALIVE , s ) ; </a> 0
<a> } </a> 0
<a> s = sc . getInitParameter ( BROADCAST_FILTER_CLASSES ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> broadcasterFilters = s . split ( "," ) ; </a> 0
<a> } </a> 0
<a> s = sc . getInitParameter ( BROADCASTER_LIFECYCLE_POLICY ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> broadcasterLifeCyclePolicy = s ; </a> 0
<a> } </a> 0
<a> s = sc . getInitParameter ( BROADCASTER_FACTORY ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> broadcasterFactoryClassName = s ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void loadConfiguration ( ServletConfig sc ) throws ServletException { </a> 0
<a> try { </a> 0
<a> URL url = sc . getServletContext ( ) . getResource ( "/WEB-INF/classes/" ) ; </a> 0
<a> URLClassLoader urlC = new URLClassLoader ( new URL [ ] { url } , </a> 0
<a> Thread . currentThread ( ) . getContextClassLoader ( ) ) ; </a> 0
<a> loadAtmosphereDotXml ( sc . getServletContext ( ) . </a> 0
<a> getResourceAsStream ( "/META-INF/atmosphere.xml" ) , urlC ) ; </a> 0
<a> if ( atmosphereHandlers . size ( ) == 0 ) { </a> 0
<a> autoDetectAtmosphereHandlers ( sc . getServletContext ( ) , urlC ) ; </a> 0
<a> if ( atmosphereHandlers . size ( ) == 0 ) { </a> 0
<a> detectSupportedFramework ( sc ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> throw new ServletException ( t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected boolean detectSupportedFramework ( ServletConfig sc ) throws ClassNotFoundException , IllegalAccessException , </a> 0
<a> InstantiationException , NoSuchMethodException , InvocationTargetException { </a> 0
<a> ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; </a> 0
<a> String broadcasterClassNameTmp = null ; </a> 0
<a> try { </a> 0
<a> cl . loadClass ( JERSEY_CONTAINER ) ; </a> 0
<a> if ( ! isBroadcasterSpecified ) { </a> 0
<a> broadcasterClassNameTmp = lookupDefaultBroadcasterType ( ) ; </a> 0
<a> cl . loadClass ( broadcasterClassNameTmp ) ; </a> 0
<a> } </a> 0
<a> useStreamForFlushingComments = true ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> logger . warn ( "Missing META-INF/atmosphere.xml but found the Jersey runtime. Starting Jersey" ) ; </a> 0
<a> initParams . put ( WRITE_HEADERS , "false" ) ; </a> 0
<a> ReflectorServletProcessor rsp = new ReflectorServletProcessor ( ) ; </a> 0
<a> if ( broadcasterClassNameTmp != null ) broadcasterClassName = broadcasterClassNameTmp ; </a> 0
<a> rsp . setServletClassName ( JERSEY_CONTAINER ) ; </a> 0
<a> sessionSupport ( false ) ; </a> 0
<a> initParams . put ( DISABLE_ONSTATE_EVENT , "true" ) ; </a> 0
<a> String mapping = sc . getInitParameter ( PROPERTY_SERVLET_MAPPING ) ; </a> 0
<a> if ( mapping == null ) { </a> 0
<a> mapping = "/*" ; </a> 0
<a> } </a> 0
<a> Class < ? extends Broadcaster > bc = ( Class < ? extends Broadcaster > ) cl . loadClass ( broadcasterClassName ) ; </a> 0
<a> Broadcaster b = BroadcasterFactory . getDefault ( ) . get ( bc , mapping ) ; </a> 0
<a> addAtmosphereHandler ( mapping , rsp , b ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> protected String lookupDefaultBroadcasterType ( ) { </a> 0
<a> for ( String b : broadcasterTypes ) { </a> 0
<a> try { </a> 0
<a> Class . forName ( b ) ; </a> 0
<a> return b ; </a> 0
<a> } catch ( ClassNotFoundException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return JERSEY_BROADCASTER ; </a> 0
<a> } </a> 0
<a> protected void sessionSupport ( boolean sessionSupport ) { </a> 0
<a> if ( ! isSessionSupportSpecified ) { </a> 0
<a> config . supportSession = sessionSupport ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void initAtmosphereHandler ( ServletConfig sc ) throws ServletException { </a> 0
<a> AtmosphereHandler a ; </a> 0
<a> for ( Entry < String , AtmosphereHandlerWrapper > h : atmosphereHandlers . entrySet ( ) ) { </a> 0
<a> a = h . getValue ( ) . atmosphereHandler ; </a> 1
<a> if ( a instanceof AtmosphereServletProcessor ) { </a> 0
<a> ( ( AtmosphereServletProcessor ) a ) . init ( sc ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void destroy ( ) { </a> 0
<a> if ( cometSupport != null && AsynchronousProcessor . class . isAssignableFrom ( cometSupport . getClass ( ) ) ) { </a> 0
<a> ( ( AsynchronousProcessor ) cometSupport ) . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> for ( Entry < String , AtmosphereHandlerWrapper > entry : atmosphereHandlers . entrySet ( ) ) { </a> 0
<a> AtmosphereHandlerWrapper handlerWrapper = entry . getValue ( ) ; </a> 0
<a> handlerWrapper . atmosphereHandler . destroy ( ) ; </a> 0
<a> Broadcaster broadcaster = handlerWrapper . broadcaster ; </a> 0
<a> if ( broadcaster != null ) { </a> 0
<a> broadcaster . destroy ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> BroadcasterFactory factory = BroadcasterFactory . getDefault ( ) ; </a> 0
<a> if ( factory != null ) { </a> 0
<a> factory . destroy ( ) ; </a> 0
<a> BroadcasterFactory . factory = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void loadAtmosphereDotXml ( InputStream stream , URLClassLoader c ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> if ( stream == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> AtmosphereConfigReader reader = new AtmosphereConfigReader ( stream ) ; </a> 0
<a> Map < String , String > atmosphereHandlerNames = reader . getAtmosphereHandlers ( ) ; </a> 0
<a> Set < Entry < String , String > > entries = atmosphereHandlerNames . entrySet ( ) ; </a> 0
<a> for ( Entry < String , String > entry : entries ) { </a> 0
<a> AtmosphereHandler handler ; </a> 0
<a> String handlerClassName = entry . getValue ( ) ; </a> 0
<a> String handlerPath = entry . getKey ( ) ; </a> 0
<a> try { </a> 0
<a> if ( ! handlerClassName . equals ( ReflectorServletProcessor . class . getName ( ) ) ) { </a> 0
<a> handler = ( AtmosphereHandler ) c . loadClass ( handlerClassName ) . newInstance ( ) ; </a> 0
<a> InjectorProvider . getInjector ( ) . inject ( handler ) ; </a> 0
<a> } else { </a> 0
<a> handler = new ReflectorServletProcessor ( ) ; </a> 0
<a> } </a> 0
<a> logger . info ( "Installed AtmosphereHandler {} mapped to context-path: {}" , handler , handlerPath ) ; </a> 0
<a> AtmosphereHandlerWrapper wrapper = new AtmosphereHandlerWrapper ( handler ) ; </a> 0
<a> atmosphereHandlers . put ( handlerPath , wrapper ) ; </a> 0
<a> boolean isJersey = false ; </a> 0
<a> for ( Property p : reader . getProperty ( handlerPath ) ) { </a> 0
<a> if ( p . value != null && p . value . indexOf ( "jersey" ) != - 1 ) { </a> 0
<a> isJersey = true ; </a> 0
<a> initParams . put ( DISABLE_ONSTATE_EVENT , "true" ) ; </a> 0
<a> useStreamForFlushingComments = true ; </a> 0
<a> broadcasterClassName = lookupDefaultBroadcasterType ( ) ; </a> 0
<a> } </a> 0
<a> IntrospectionUtils . setProperty ( handler , p . name , p . value ) ; </a> 0
<a> } </a> 0
<a> config . supportSession = ! isJersey ; </a> 0
<a> if ( ! reader . supportSession ( ) . equals ( "" ) ) { </a> 0
<a> sessionSupport ( Boolean . valueOf ( reader . supportSession ( ) ) ) ; </a> 0
<a> } </a> 0
<a> for ( Property p : reader . getProperty ( handlerPath ) ) { </a> 0
<a> IntrospectionUtils . addProperty ( handler , p . name , p . value ) ; </a> 0
<a> } </a> 0
<a> String broadcasterClass = reader . getBroadcasterClass ( handlerPath ) ; </a> 0
<a> if ( broadcasterClass != null ) { </a> 0
<a> broadcasterClassName = broadcasterClass ; </a> 0
<a> ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; </a> 0
<a> Class < ? extends Broadcaster > bc = ( Class < ? extends Broadcaster > ) cl . loadClass ( broadcasterClassName ) ; </a> 0
<a> wrapper . broadcaster = BroadcasterFactory . getDefault ( ) . get ( bc , handlerPath ) ; </a> 1
<a> } </a> 0
<a> String bc = reader . getBroadcasterCache ( handlerPath ) ; </a> 0
<a> if ( bc != null ) { </a> 0
<a> broadcasterCacheClassName = bc ; </a> 0
<a> } </a> 0
<a> if ( reader . getCometSupportClass ( ) != null ) { </a> 0
<a> cometSupport = ( CometSupport ) c . loadClass ( reader . getCometSupportClass ( ) ) </a> 0
<a> . getDeclaredConstructor ( new Class [ ] { AtmosphereConfig . class } ) </a> 0
<a> . newInstance ( new Object [ ] { config } ) ; </a> 0
<a> } </a> 0
<a> if ( reader . getBroadcastFilterClasses ( ) != null ) { </a> 0
<a> broadcasterFilters = reader . getBroadcastFilterClasses ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "unable to load AtmosphereHandler class: " + handlerClassName , t ) ; </a> 0
<a> throw new ServletException ( t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void setCometSupport ( CometSupport cometSupport ) { </a> 0
<a> this . cometSupport = cometSupport ; </a> 0
<a> } </a> 0
<a> public CometSupport getCometSupport ( ) { </a> 0
<a> return cometSupport ; </a> 0
<a> } </a> 0
<a> protected CometSupportResolver createCometSupportResolver ( ) { </a> 0
<a> return new DefaultCometSupportResolver ( config ) ; </a> 0
<a> } </a> 0
<a> protected void autoDetectContainer ( ) { </a> 0
<a> if ( getCometSupport ( ) == null ) { </a> 0
<a> setCometSupport ( createCometSupportResolver ( ) </a> 0
<a> . resolve ( useNativeImplementation , useBlockingImplementation , webSocketEnabled ) ) ; </a> 0
<a> } </a> 0
<a> logger . info ( "Atmosphere is using async support: {} running under container: {}" , </a> 0
<a> getCometSupport ( ) . getClass ( ) . getName ( ) , cometSupport . getContainerName ( ) ) ; </a> 0
<a> } </a> 0
<a> protected void autoDetectAtmosphereHandlers ( ServletContext servletContext , URLClassLoader classloader ) </a> 0
<a> throws MalformedURLException , URISyntaxException { </a> 0
<a> logger . info ( "Auto detecting atmosphere handlers in WEB-INF/classes" ) ; </a> 0
<a> String realPath = servletContext . getRealPath ( WEB_INF_CLASSES ) ; </a> 0
<a> if ( realPath == null ) { </a> 0
<a> URL u = servletContext . getResource ( WEB_INF_CLASSES ) ; </a> 0
<a> if ( u == null ) return ; </a> 0
<a> realPath = u . getPath ( ) ; </a> 0
<a> } </a> 0
<a> loadAtmosphereHandlersFromPath ( classloader , realPath ) ; </a> 0
<a> } </a> 0
<a> protected void loadAtmosphereHandlersFromPath ( URLClassLoader classloader , String realPath ) { </a> 0
<a> File file = new File ( realPath ) ; </a> 0
<a> if ( file . isDirectory ( ) ) { </a> 0
<a> getFiles ( file ) ; </a> 0
<a> for ( String className : possibleAtmosphereHandlersCandidate ) { </a> 0
<a> try { </a> 0
<a> className = className . replace ( '\\' , '/' ) ; </a> 0
<a> className = className . replaceFirst ( "^.*/(WEB-INF|target)/(test-)?classes/(.*)\\.class" , "$3" ) . replace ( "/" , "." ) ; </a> 0
<a> Class < ? > clazz = classloader . loadClass ( className ) ; </a> 0
<a> if ( AtmosphereHandler . class . isAssignableFrom ( clazz ) ) { </a> 0
<a> AtmosphereHandler handler = ( AtmosphereHandler ) clazz . newInstance ( ) ; </a> 0
<a> InjectorProvider . getInjector ( ) . inject ( handler ) ; </a> 0
<a> atmosphereHandlers . put ( "/" + handler . getClass ( ) . getSimpleName ( ) , </a> 0
<a> new AtmosphereHandlerWrapper ( handler , null ) ) ; </a> 0
<a> logger . info ( "Installed AtmosphereHandler {} mapped to context-path: {}" , handler , handler . getClass ( ) . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . trace ( "failed to load class as an AtmosphereHandler: " + className , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void getFiles ( File f ) { </a> 0
<a> File [ ] files = f . listFiles ( ) ; </a> 0
<a> for ( File test : files ) { </a> 0
<a> if ( test . isDirectory ( ) ) { </a> 0
<a> getFiles ( test ) ; </a> 0
<a> } else { </a> 0
<a> String clazz = test . getAbsolutePath ( ) ; </a> 0
<a> if ( clazz . endsWith ( ".class" ) ) { </a> 0
<a> possibleAtmosphereHandlersCandidate . add ( clazz ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void doHead ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> doPost ( req , res ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void doOptions ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> doPost ( req , res ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void doTrace ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> doPost ( req , res ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void doDelete ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> doPost ( req , res ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void doPut ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> doPost ( req , res ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void doGet ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> doPost ( req , res ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void doPost ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> doCometSupport ( req , res ) ; </a> 0
<a> } </a> 0
<a> public Action doCometSupport ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> req . setAttribute ( BROADCASTER_FACTORY , broadcasterFactory ) ; </a> 0
<a> req . setAttribute ( PROPERTY_USE_STREAM , useStreamForFlushingComments ) ; </a> 0
<a> req . setAttribute ( BROADCASTER_CLASS , broadcasterClassName ) ; </a> 0
<a> req . setAttribute ( SUPPORT_TRACKABLE , config . getInitParameter ( SUPPORT_TRACKABLE ) ) ; </a> 1
<a> try { </a> 0
<a> if ( config . getInitParameter ( ALLOW_QUERYSTRING_AS_REQUEST ) != null </a> 0
<a> && isIECandidate ( req ) </a> 1
<a> && req . getAttribute ( WebSocket . WEBSOCKET_SUSPEND ) == null ) { </a> 0
<a> Map < String , String > headers = configureQueryStringAsRequest ( req ) ; </a> 0
<a> String body = headers . remove ( ATMOSPHERE_POST_BODY ) ; </a> 0
<a> return cometSupport . service ( new AtmosphereRequest . Builder ( ) </a> 1
<a> . headers ( headers ) </a> 0
<a> . method ( body != null ? "POST" : "GET" ) </a> 1
<a> . body ( body ) </a> 0
<a> . request ( req ) . build ( ) , res ) ; </a> 1
<a> } else { </a> 0
<a> return cometSupport . service ( req , res ) ; </a> 0
<a> } </a> 0
<a> } catch ( IllegalStateException ex ) { </a> 0
<a> logger . warn ( ex . getMessage ( ) , ex ) ; </a> 0
<a> if ( ex . getMessage ( ) != null && ex . getMessage ( ) . startsWith ( "Tomcat failed" ) ) { </a> 0
<a> if ( ! isFilter ) { </a> 0
<a> logger . warn ( "Failed using comet support: {}, error: {}" , cometSupport . getClass ( ) . getName ( ) , </a> 0
<a> ex . getMessage ( ) ) ; </a> 0
<a> logger . warn ( "Using BlockingIOCometSupport." ) ; </a> 0
<a> } </a> 0
<a> cometSupport = new BlockingIOCometSupport ( config ) ; </a> 0
<a> service ( req , res ) ; </a> 0
<a> } else { </a> 0
<a> logger . error ( "AtmosphereServlet exception" , ex ) ; </a> 0
<a> throw ex ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public void event ( CometEvent cometEvent ) throws IOException , ServletException { </a> 1
<a> HttpServletRequest req = cometEvent . getHttpServletRequest ( ) ; </a> 1
<a> HttpServletResponse res = cometEvent . getHttpServletResponse ( ) ; </a> 1
<a> req . setAttribute ( TomcatCometSupport . COMET_EVENT , cometEvent ) ; </a> 1
<a> if ( ! isCometSupportSpecified && ! isCometSupportConfigured . getAndSet ( true ) ) { </a> 0
<a> synchronized ( cometSupport ) { </a> 0
<a> if ( ! cometSupport . getClass ( ) . equals ( TomcatCometSupport . class ) ) { </a> 0
<a> logger . warn ( "TomcatCometSupport is enabled, switching to it" ) ; </a> 1
<a> cometSupport = new TomcatCometSupport ( config ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> doCometSupport ( req , res ) ; </a> 0
<a> } </a> 1
<a> public void event ( org . apache . catalina . comet . CometEvent cometEvent ) throws IOException , ServletException { </a> 1
<a> HttpServletRequest req = cometEvent . getHttpServletRequest ( ) ; </a> 1
<a> HttpServletResponse res = cometEvent . getHttpServletResponse ( ) ; </a> 1
<a> req . setAttribute ( Tomcat7CometSupport . COMET_EVENT , cometEvent ) ; </a> 1
<a> if ( ! isCometSupportSpecified && ! isCometSupportConfigured . getAndSet ( true ) ) { </a> 0
<a> synchronized ( cometSupport ) { </a> 0
<a> if ( ! cometSupport . getClass ( ) . equals ( Tomcat7CometSupport . class ) ) { </a> 0
<a> logger . warn ( "TomcatCometSupport is enabled, switching to it" ) ; </a> 1
<a> cometSupport = new Tomcat7CometSupport ( config ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> doCometSupport ( req , res ) ; </a> 0
<a> } </a> 1
<a> public void event ( HttpEvent httpEvent ) throws IOException , ServletException { </a> 1
<a> HttpServletRequest req = httpEvent . getHttpServletRequest ( ) ; </a> 1
<a> HttpServletResponse res = httpEvent . getHttpServletResponse ( ) ; </a> 1
<a> req . setAttribute ( JBossWebCometSupport . HTTP_EVENT , httpEvent ) ; </a> 1
<a> if ( ! isCometSupportSpecified && ! isCometSupportConfigured . getAndSet ( true ) ) { </a> 0
<a> synchronized ( cometSupport ) { </a> 0
<a> if ( ! cometSupport . getClass ( ) . equals ( JBossWebCometSupport . class ) ) { </a> 0
<a> logger . warn ( "JBossWebCometSupport is enabled, switching to it" ) ; </a> 1
<a> cometSupport = new JBossWebCometSupport ( config ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> doCometSupport ( req , res ) ; </a> 0
<a> } </a> 1
<a> protected boolean doRequest ( RequestResponseKey rrk ) throws IOException , ServletException { </a> 1
<a> try { </a> 1
<a> rrk . getRequest ( ) . getSession ( ) . setAttribute ( WebLogicCometSupport . RRK , rrk ) ; </a> 1
<a> Action action = doCometSupport ( rrk . getRequest ( ) , rrk . getResponse ( ) ) ; </a> 0
<a> if ( action . type == Action . TYPE . SUSPEND ) { </a> 0
<a> if ( action . timeout == - 1 ) { </a> 1
<a> rrk . setTimeout ( Integer . MAX_VALUE ) ; </a> 1
<a> } else { </a> 1
<a> rrk . setTimeout ( ( int ) action . timeout ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return action . type == Action . TYPE . SUSPEND ; </a> 0
<a> } catch ( IllegalStateException ex ) { </a> 1
<a> logger . error ( "AtmosphereServlet.doRequest exception" , ex ) ; </a> 1
<a> throw ex ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> protected void doResponse ( RequestResponseKey rrk , Object context ) </a> 1
<a> throws IOException , ServletException { </a> 1
<a> rrk . getResponse ( ) . flushBuffer ( ) ; </a> 1
<a> } </a> 1
<a> protected void doTimeout ( RequestResponseKey rrk ) throws IOException , ServletException { </a> 1
<a> ( ( AsynchronousProcessor ) cometSupport ) . timedout ( rrk . getRequest ( ) , rrk . getResponse ( ) ) ; </a> 0
<a> } </a> 0
<a> public static String getDefaultBroadcasterClassName ( ) { </a> 0
<a> return broadcasterClassName ; </a> 0
<a> } </a> 0
<a> public static void setDefaultBroadcasterClassName ( String bccn ) { </a> 0
<a> broadcasterClassName = bccn ; </a> 0
<a> } </a> 0
<a> public boolean isUseStreamForFlushingComments ( ) { </a> 0
<a> return useStreamForFlushingComments ; </a> 0
<a> } </a> 0
<a> public void setUseStreamForFlushingComments ( boolean useStreamForFlushingComments ) { </a> 0
<a> this . useStreamForFlushingComments = useStreamForFlushingComments ; </a> 0
<a> } </a> 0
<a> public BroadcasterFactory getBroadcasterFactory ( ) { </a> 0
<a> return broadcasterFactory ; </a> 0
<a> } </a> 0
<a> public AtmosphereServlet setBroadcasterFactory ( final BroadcasterFactory broadcasterFactory ) throws IllegalAccessException , InstantiationException , ClassNotFoundException { </a> 0
<a> this . broadcasterFactory = broadcasterFactory ; </a> 0
<a> configureBroadcaster ( config . getServletContext ( ) ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public String getBroadcasterCacheClassName ( ) { </a> 0
<a> return broadcasterCacheClassName ; </a> 0
<a> } </a> 0
<a> public void setBroadcasterCacheClassName ( String broadcasterCacheClassName ) throws IllegalAccessException , InstantiationException , ClassNotFoundException { </a> 0
<a> this . broadcasterCacheClassName = broadcasterCacheClassName ; </a> 0
<a> configureBroadcaster ( config . getServletContext ( ) ) ; </a> 0
<a> } </a> 0
<a> public void addBroadcasterType ( String broadcasterTypeString ) { </a> 0
<a> broadcasterTypes . add ( broadcasterTypeString ) ; </a> 0
<a> } </a> 0
<a> public String getWebSocketProcessorClassName ( ) { </a> 0
<a> return webSocketProcessorClassName ; </a> 0
<a> } </a> 0
<a> public void setWebSocketProcessorClassName ( String webSocketProcessorClassName ) { </a> 0
<a> this . webSocketProcessorClassName = webSocketProcessorClassName ; </a> 0
<a> } </a> 0
<a> protected Map < String , String > configureQueryStringAsRequest ( HttpServletRequest request ) { </a> 0
<a> Map < String , String > headers = new HashMap < String , String > ( ) ; </a> 0
<a> Enumeration < String > e = request . getParameterNames ( ) ; </a> 0
<a> String s ; </a> 0
<a> while ( e . hasMoreElements ( ) ) { </a> 0
<a> s = e . nextElement ( ) ; </a> 0
<a> headers . put ( s , request . getParameter ( s ) ) ; </a> 0
<a> } </a> 0
<a> return headers ; </a> 0
<a> } </a> 0
<a> protected boolean isIECandidate ( HttpServletRequest request ) { </a> 0
<a> String userAgent = request . getHeader ( "User-Agent" ) ; </a> 1
<a> if ( userAgent == null ) return false ; </a> 1
<a> if ( userAgent . contains ( "MSIE" ) || userAgent . contains ( ".NET" ) ) { </a> 1
<a> String transport = request . getHeader ( HeaderConfig . X_ATMOSPHERE_TRANSPORT ) ; </a> 1
<a> if ( transport != null ) { </a> 1
<a> return false ; </a> 1
<a> } else { </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> public org . eclipse . jetty . websocket . WebSocket doWebSocketConnect ( final HttpServletRequest request , final String protocol ) { </a> 1
<a> logger . info ( "WebSocket upgrade requested" ) ; </a> 0
<a> request . setAttribute ( WebSocket . WEBSOCKET_INITIATED , true ) ; </a> 1
<a> return new JettyWebSocketHandler ( request , this , webSocketProcessorClassName ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import javax . servlet . Servlet ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public interface AtmosphereServletProcessor extends </a> 1
<a> AtmosphereHandler < HttpServletRequest , HttpServletResponse > { </a> 0
<a> void init ( ServletConfig sc ) throws ServletException ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> public interface BroadcastFilter { </a> 0
<a> public class BroadcastAction { </a> 0
<a> private final ACTION a ; </a> 0
<a> private final Object o ; </a> 0
<a> private Object originalMsg ; </a> 0
<a> public enum ACTION { </a> 0
<a> CONTINUE , ABORT </a> 1
<a> } </a> 0
<a> public BroadcastAction ( ACTION a , Object o ) { </a> 0
<a> this . a = a ; </a> 0
<a> this . o = o ; </a> 0
<a> } </a> 0
<a> public BroadcastAction ( Object o ) { </a> 0
<a> this . a = ACTION . CONTINUE ; </a> 0
<a> this . o = o ; </a> 0
<a> } </a> 0
<a> public Object message ( ) { </a> 0
<a> return o ; </a> 0
<a> } </a> 0
<a> public ACTION action ( ) { </a> 0
<a> return a ; </a> 0
<a> } </a> 0
<a> public Object originalMessage ( ) { </a> 0
<a> return originalMsg ; </a> 0
<a> } </a> 0
<a> void setOriginalMsg ( Object originalMsg ) { </a> 0
<a> this . originalMsg = originalMsg ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> BroadcastAction filter ( Object originalMessage , Object message ) ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . concurrent . ExecutorService ; </a> 0
<a> import java . util . concurrent . Future ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public interface Broadcaster extends Trackable { </a> 1
<a> enum SCOPE { </a> 0
<a> REQUEST , APPLICATION , VM </a> 0
<a> } </a> 0
<a> enum POLICY { </a> 0
<a> FIFO , REJECT </a> 0
<a> } </a> 0
<a> void setSuspendPolicy ( long maxSuspended , POLICY policy ) ; </a> 0
<a> < T > Future < T > broadcast ( T o ) ; </a> 1
<a> < T > Future < T > delayBroadcast ( T o ) ; </a> 1
<a> < T > Future < T > delayBroadcast ( T o , long delay , TimeUnit t ) ; </a> 1
<a> < T > Future < T > scheduleFixedBroadcast ( T o , long period , TimeUnit t ) ; </a> 1
<a> < T > Future < T > scheduleFixedBroadcast ( T o , long waitFor , long period , TimeUnit t ) ; </a> 1
<a> < T > Future < T > broadcast ( T o , AtmosphereResource < ? , ? > resource ) ; </a> 0
<a> < T > Future < T > broadcastOnResume ( T o ) ; </a> 1
<a> < T > Future < T > broadcast ( T o , Set < AtmosphereResource < ? , ? > > subset ) ; </a> 0
<a> AtmosphereResource < ? , ? > addAtmosphereResource ( AtmosphereResource < ? , ? > resource ) ; </a> 0
<a> AtmosphereResource < ? , ? > removeAtmosphereResource ( AtmosphereResource < ? , ? > resource ) ; </a> 0
<a> void setBroadcasterConfig ( BroadcasterConfig bc ) ; </a> 0
<a> BroadcasterConfig getBroadcasterConfig ( ) ; </a> 0
<a> void destroy ( ) ; </a> 0
<a> Collection < AtmosphereResource < ? , ? > > getAtmosphereResources ( ) ; </a> 0
<a> void setScope ( SCOPE scope ) ; </a> 0
<a> SCOPE getScope ( ) ; </a> 0
<a> void setID ( String name ) ; </a> 0
<a> String getID ( ) ; </a> 0
<a> void resumeAll ( ) ; </a> 0
<a> public void releaseExternalResources ( ) ; </a> 0
<a> public void setBroadcasterLifeCyclePolicy ( BroadcasterLifeCyclePolicy policy ) ; </a> 0
<a> void addBroadcasterLifeCyclePolicyListener ( BroadcasterLifeCyclePolicyListener b ) ; </a> 0
<a> void removeBroadcasterLifeCyclePolicyListener ( BroadcasterLifeCyclePolicyListener b ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> public abstract class BroadcasterFactory { </a> 1
<a> protected static BroadcasterFactory factory ; </a> 1
<a> protected static AtmosphereServlet . AtmosphereConfig config ; </a> 0
<a> abstract public Broadcaster get ( ) throws IllegalAccessException , InstantiationException ; </a> 0
<a> abstract public Broadcaster get ( Class < ? extends Broadcaster > c , Object id ) throws IllegalAccessException , InstantiationException ; </a> 0
<a> abstract public void destroy ( ) ; </a> 1
<a> abstract public boolean add ( Broadcaster b , Object id ) ; </a> 1
<a> abstract public boolean remove ( Broadcaster b , Object id ) ; </a> 1
<a> abstract public Broadcaster lookup ( Class < ? extends Broadcaster > c , Object id ) ; </a> 0
<a> abstract public Broadcaster lookup ( Class < ? extends Broadcaster > c , Object id , boolean createIfNull ) ; </a> 0
<a> abstract public void removeAllAtmosphereResource ( AtmosphereResource < ? , ? > r ) ; </a> 0
<a> abstract public Collection < Broadcaster > lookupAll ( ) ; </a> 1
<a> public synchronized static BroadcasterFactory getDefault ( ) { </a> 1
<a> return factory ; </a> 1
<a> } </a> 1
<a> static void setBroadcasterFactory ( BroadcasterFactory f , AtmosphereServlet . AtmosphereConfig c ) { </a> 0
<a> factory = f ; </a> 1
<a> config = c ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import java . util . concurrent . CountDownLatch ; </a> 0
<a> import java . util . concurrent . ExecutionException ; </a> 0
<a> import java . util . concurrent . Future ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . TimeoutException ; </a> 0
<a> public class BroadcasterFuture < E > implements Future { </a> 0
<a> private final CountDownLatch latch ; </a> 0
<a> private boolean isCancelled = false ; </a> 0
<a> private boolean isDone = false ; </a> 0
<a> private final E msg ; </a> 0
<a> private final Future < ? > innerFuture ; </a> 1
<a> public BroadcasterFuture ( E msg ) { </a> 1
<a> this ( null , msg ) ; </a> 1
<a> } </a> 0
<a> public BroadcasterFuture ( Future < ? > innerFuture , E msg ) { </a> 1
<a> this . msg = msg ; </a> 0
<a> this . innerFuture = innerFuture ; </a> 0
<a> if ( innerFuture == null ) { </a> 0
<a> latch = new CountDownLatch ( 1 ) ; </a> 1
<a> } else { </a> 0
<a> latch = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean cancel ( boolean b ) { </a> 0
<a> if ( innerFuture != null ) { </a> 0
<a> return innerFuture . cancel ( b ) ; </a> 0
<a> } </a> 0
<a> if ( latch . getCount ( ) == 1 ) { </a> 1
<a> latch . countDown ( ) ; </a> 0
<a> isCancelled = true ; </a> 1
<a> } </a> 0
<a> return isCancelled ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isCancelled ( ) { </a> 0
<a> if ( innerFuture != null ) { </a> 0
<a> return innerFuture . isCancelled ( ) ; </a> 0
<a> } </a> 0
<a> return isCancelled ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDone ( ) { </a> 0
<a> if ( innerFuture != null ) { </a> 0
<a> return innerFuture . isDone ( ) ; </a> 0
<a> } </a> 0
<a> isDone = true ; </a> 0
<a> return isDone ; </a> 0
<a> } </a> 0
<a> public void done ( ) { </a> 1
<a> isDone = true ; </a> 0
<a> if ( latch != null ) { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public E get ( ) throws InterruptedException , ExecutionException { </a> 0
<a> if ( innerFuture != null ) { </a> 0
<a> return ( E ) innerFuture . get ( ) ; </a> 0
<a> } </a> 0
<a> latch . await ( ) ; </a> 0
<a> return msg ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public E get ( long l , TimeUnit tu ) throws InterruptedException , ExecutionException , TimeoutException { </a> 0
<a> if ( innerFuture != null ) { </a> 0
<a> return ( E ) innerFuture . get ( ) ; </a> 0
<a> } </a> 0
<a> latch . await ( l , tu ) ; </a> 0
<a> return msg ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public class BroadcasterLifeCyclePolicy { </a> 0
<a> public enum ATMOSPHERE_RESOURCE_POLICY { </a> 0
<a> IDLE , </a> 0
<a> IDLE_DESTROY , </a> 0
<a> EMPTY , </a> 0
<a> EMPTY_DESTROY , </a> 0
<a> NEVER </a> 0
<a> } </a> 0
<a> private final ATMOSPHERE_RESOURCE_POLICY policy ; </a> 0
<a> private final int time ; </a> 0
<a> private final TimeUnit timeUnit ; </a> 0
<a> private BroadcasterLifeCyclePolicy ( ATMOSPHERE_RESOURCE_POLICY policy , int time , TimeUnit timeUnit ) { </a> 0
<a> this . policy = policy ; </a> 0
<a> this . time = time ; </a> 0
<a> this . timeUnit = timeUnit ; </a> 0
<a> } </a> 0
<a> private BroadcasterLifeCyclePolicy ( ATMOSPHERE_RESOURCE_POLICY policy ) { </a> 0
<a> this . policy = policy ; </a> 0
<a> this . time = - 1 ; </a> 0
<a> this . timeUnit = null ; </a> 0
<a> } </a> 0
<a> public ATMOSPHERE_RESOURCE_POLICY getLifeCyclePolicy ( ) { </a> 0
<a> return policy ; </a> 0
<a> } </a> 0
<a> public TimeUnit getTimeUnit ( ) { </a> 0
<a> return timeUnit ; </a> 0
<a> } </a> 0
<a> public int getTimeout ( ) { </a> 0
<a> return time ; </a> 0
<a> } </a> 0
<a> public static final class Builder { </a> 0
<a> private ATMOSPHERE_RESOURCE_POLICY policy ; </a> 0
<a> private int time ; </a> 0
<a> private TimeUnit timeUnit ; </a> 0
<a> public Builder policy ( ATMOSPHERE_RESOURCE_POLICY policy ) { </a> 0
<a> this . policy = policy ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder idleTimeInMS ( int time ) { </a> 0
<a> timeUnit = TimeUnit . MILLISECONDS ; </a> 0
<a> this . time = time ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder idleTime ( int time , TimeUnit timeUnit ) { </a> 0
<a> this . timeUnit = timeUnit ; </a> 0
<a> this . time = time ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public BroadcasterLifeCyclePolicy build ( ) { </a> 0
<a> return new BroadcasterLifeCyclePolicy ( policy , time , timeUnit ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 1
<a> import org . atmosphere . container . BlockingIOCometSupport ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereServlet . Action ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 1
<a> import javax . servlet . ServletException ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . awt . event . ActionEvent ; </a> 1
<a> import java . io . IOException ; </a> 1
<a> public interface CometSupport < E extends AtmosphereResource > { </a> 1
<a> public String getContainerName ( ) ; </a> 1
<a> public void init ( ServletConfig sc ) throws ServletException ; </a> 1
<a> public Action service ( HttpServletRequest req , HttpServletResponse res ) </a> 0
<a> throws IOException , ServletException ; </a> 1
<a> public void action ( E actionEvent ) ; </a> 1
<a> public boolean supportWebSocket ( ) ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 1
<a> public interface CometSupportResolver { </a> 1
<a> public CometSupport resolve ( final boolean useNativeIfPossible , final boolean defaultToBlocking , </a> 1
<a> final boolean useWebsocketIfPossible ) ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter . BroadcastAction ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterConfig . DefaultBroadcasterCache ; </a> 1
<a> import org . atmosphere . di . InjectorProvider ; </a> 1
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . UUID ; </a> 1
<a> import java . util . concurrent . BlockingQueue ; </a> 0
<a> import java . util . concurrent . Callable ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import java . util . concurrent . Future ; </a> 0
<a> import java . util . concurrent . LinkedBlockingQueue ; </a> 0
<a> import java . util . concurrent . RejectedExecutionException ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> import java . util . concurrent . atomic . AtomicLong ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 1
<a> import static org . atmosphere . cpr . ApplicationConfig . MAX_INACTIVE ; </a> 0
<a> public class DefaultBroadcaster implements Broadcaster { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( DefaultBroadcaster . class ) ; </a> 0
<a> public static final String CACHED = DefaultBroadcaster . class . getName ( ) + ".messagesCached" ; </a> 1
<a> protected final ConcurrentLinkedQueue < AtmosphereResource < ? , ? > > resources = </a> 0
<a> new ConcurrentLinkedQueue < AtmosphereResource < ? , ? > > ( ) ; </a> 0
<a> protected BroadcasterConfig bc ; </a> 0
<a> protected final BlockingQueue < Entry > messages = new LinkedBlockingQueue < Entry > ( ) ; </a> 1
<a> protected final BlockingQueue < AsyncWriteToken > asyncWriteQueue = new LinkedBlockingQueue < AsyncWriteToken > ( ) ; </a> 1
<a> protected final AtomicBoolean started = new AtomicBoolean ( false ) ; </a> 0
<a> protected final AtomicBoolean destroyed = new AtomicBoolean ( false ) ; </a> 0
<a> protected SCOPE scope = SCOPE . APPLICATION ; </a> 0
<a> protected String name = DefaultBroadcaster . class . getSimpleName ( ) ; </a> 0
<a> protected final ConcurrentLinkedQueue < Entry > delayedBroadcast = new ConcurrentLinkedQueue < Entry > ( ) ; </a> 1
<a> protected final ConcurrentLinkedQueue < Entry > broadcastOnResume = new ConcurrentLinkedQueue < Entry > ( ) ; </a> 1
<a> protected final ConcurrentLinkedQueue < BroadcasterLifeCyclePolicyListener > lifeCycleListeners = new ConcurrentLinkedQueue < BroadcasterLifeCyclePolicyListener > ( ) ; </a> 0
<a> protected Future < ? > notifierFuture ; </a> 1
<a> protected Future < ? > asyncWriteFuture ; </a> 1
<a> protected BroadcasterCache broadcasterCache ; </a> 0
<a> private POLICY policy = POLICY . FIFO ; </a> 0
<a> private final AtomicLong maxSuspendResource = new AtomicLong ( - 1 ) ; </a> 1
<a> private final AtomicBoolean requestScoped = new AtomicBoolean ( false ) ; </a> 0
<a> private BroadcasterLifeCyclePolicy lifeCyclePolicy = new BroadcasterLifeCyclePolicy . Builder ( ) </a> 0
<a> . policy ( BroadcasterLifeCyclePolicy . ATMOSPHERE_RESOURCE_POLICY . NEVER ) . build ( ) ; </a> 0
<a> private Future < ? > currentLifecycleTask ; </a> 1
<a> public DefaultBroadcaster ( ) { </a> 0
<a> this ( DefaultBroadcaster . class . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> public DefaultBroadcaster ( String name ) { </a> 0
<a> this . name = name ; </a> 0
<a> broadcasterCache = new DefaultBroadcasterCache ( ) ; </a> 0
<a> bc = new BroadcasterConfig ( AtmosphereServlet . broadcasterFilters , null ) ; </a> 0
<a> setID ( name ) ; </a> 0
<a> } </a> 0
<a> public synchronized void destroy ( ) { </a> 0
<a> if ( destroyed . get ( ) ) return ; </a> 1
<a> if ( currentLifecycleTask != null ) { </a> 1
<a> currentLifecycleTask . cancel ( true ) ; </a> 1
<a> } </a> 1
<a> started . set ( false ) ; </a> 0
<a> destroyed . set ( true ) ; </a> 1
<a> releaseExternalResources ( ) ; </a> 0
<a> if ( notifierFuture != null ) { </a> 1
<a> notifierFuture . cancel ( true ) ; </a> 1
<a> } </a> 1
<a> if ( asyncWriteFuture != null ) { </a> 1
<a> asyncWriteFuture . cancel ( true ) ; </a> 0
<a> } </a> 1
<a> if ( bc != null ) { </a> 0
<a> bc . destroy ( ) ; </a> 0
<a> } </a> 0
<a> if ( broadcasterCache != null ) { </a> 1
<a> broadcasterCache . stop ( ) ; </a> 1
<a> } </a> 1
<a> resources . clear ( ) ; </a> 0
<a> broadcastOnResume . clear ( ) ; </a> 0
<a> messages . clear ( ) ; </a> 0
<a> asyncWriteQueue . clear ( ) ; </a> 1
<a> delayedBroadcast . clear ( ) ; </a> 0
<a> broadcasterCache = null ; </a> 0
<a> if ( BroadcasterFactory . getDefault ( ) != null ) { </a> 0
<a> BroadcasterFactory . getDefault ( ) . remove ( this , name ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public Collection < AtmosphereResource < ? , ? > > getAtmosphereResources ( ) { </a> 0
<a> return Collections . unmodifiableCollection ( resources ) ; </a> 0
<a> } </a> 0
<a> public void setScope ( SCOPE scope ) { </a> 0
<a> this . scope = scope ; </a> 0
<a> if ( scope != SCOPE . REQUEST ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> for ( AtmosphereResource < ? , ? > resource : resources ) { </a> 0
<a> Broadcaster b = BroadcasterFactory . getDefault ( ) </a> 1
<a> . get ( getClass ( ) , getClass ( ) . getSimpleName ( ) + "/" + UUID . randomUUID ( ) ) ; </a> 1
<a> if ( DefaultBroadcaster . class . isAssignableFrom ( this . getClass ( ) ) ) { </a> 0
<a> BroadcasterCache cache = bc . getBroadcasterCache ( ) . getClass ( ) . newInstance ( ) ; </a> 1
<a> InjectorProvider . getInjector ( ) . inject ( cache ) ; </a> 1
<a> DefaultBroadcaster . class . cast ( b ) . broadcasterCache = cache ; </a> 0
<a> } </a> 1
<a> resource . setBroadcaster ( b ) ; </a> 0
<a> if ( resource . getAtmosphereResourceEvent ( ) . isSuspended ( ) ) { </a> 0
<a> b . addAtmosphereResource ( resource ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! resources . isEmpty ( ) ) { </a> 0
<a> destroy ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "failed to set request scope for current resources" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public SCOPE getScope ( ) { </a> 0
<a> return scope ; </a> 0
<a> } </a> 0
<a> public synchronized void setID ( String id ) { </a> 0
<a> if ( id == null ) { </a> 0
<a> id = getClass ( ) . getSimpleName ( ) + "/" + UUID . randomUUID ( ) ; </a> 1
<a> } </a> 0
<a> Broadcaster b = BroadcasterFactory . getDefault ( ) . lookup ( this . getClass ( ) , id ) ; </a> 1
<a> if ( b != null && b . getScope ( ) == SCOPE . REQUEST ) { </a> 0
<a> throw new IllegalStateException ( "Broadcaster ID already assigned to SCOPE.REQUEST. Cannot change the id" ) ; </a> 0
<a> } </a> 0
<a> BroadcasterFactory . getDefault ( ) . remove ( this , name ) ; </a> 1
<a> this . name = id ; </a> 0
<a> BroadcasterFactory . getDefault ( ) . add ( this , name ) ; </a> 1
<a> } </a> 0
<a> public String getID ( ) { </a> 0
<a> return name ; </a> 0
<a> } </a> 0
<a> public void resumeAll ( ) { </a> 0
<a> for ( AtmosphereResource < ? , ? > r : resources ) { </a> 0
<a> r . resume ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void releaseExternalResources ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBroadcasterLifeCyclePolicy ( final BroadcasterLifeCyclePolicy lifeCyclePolicy ) { </a> 0
<a> this . lifeCyclePolicy = lifeCyclePolicy ; </a> 0
<a> if ( currentLifecycleTask != null ) { </a> 1
<a> currentLifecycleTask . cancel ( false ) ; </a> 1
<a> } </a> 1
<a> if ( lifeCyclePolicy . getLifeCyclePolicy ( ) == BroadcasterLifeCyclePolicy . ATMOSPHERE_RESOURCE_POLICY . IDLE </a> 0
<a> || lifeCyclePolicy . getLifeCyclePolicy ( ) == BroadcasterLifeCyclePolicy . ATMOSPHERE_RESOURCE_POLICY . IDLE_DESTROY ) { </a> 0
<a> int time = lifeCyclePolicy . getTimeout ( ) ; </a> 1
<a> if ( time == - 1 ) { </a> 1
<a> throw new IllegalStateException ( "BroadcasterLifeCyclePolicy time is not set" ) ; </a> 1
<a> } </a> 0
<a> final AtomicReference < Future < ? > > ref = new AtomicReference < Future < ? > > ( ) ; </a> 1
<a> currentLifecycleTask = bc . getScheduledExecutorService ( ) . scheduleAtFixedRate ( new Runnable ( ) { </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 1
<a> try { </a> 1
<a> if ( resources . isEmpty ( ) ) { </a> 1
<a> notifyEmptyListener ( ) ; </a> 1
<a> notifyIdleListener ( ) ; </a> 1
<a> if ( lifeCyclePolicy . getLifeCyclePolicy ( ) == BroadcasterLifeCyclePolicy . ATMOSPHERE_RESOURCE_POLICY . IDLE ) { </a> 0
<a> releaseExternalResources ( ) ; </a> 1
<a> logger . debug ( "Applying BroadcasterLifeCyclePolicy IDLE policy" ) ; </a> 0
<a> } else { </a> 0
<a> notifyDestroyListener ( ) ; </a> 0
<a> destroy ( ) ; </a> 0
<a> if ( ref . get ( ) != null ) { </a> 1
<a> currentLifecycleTask . cancel ( true ) ; </a> 1
<a> } </a> 1
<a> logger . debug ( "Applying BroadcasterLifeCyclePolicy IDLE_DESTROY policy" ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> logger . warn ( "Scheduled BroadcasterLifeCyclePolicy exception" , t ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } , time , time , lifeCyclePolicy . getTimeUnit ( ) ) ; </a> 1
<a> ref . set ( currentLifecycleTask ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void addBroadcasterLifeCyclePolicyListener ( BroadcasterLifeCyclePolicyListener b ) { </a> 0
<a> lifeCycleListeners . add ( b ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void removeBroadcasterLifeCyclePolicyListener ( BroadcasterLifeCyclePolicyListener b ) { </a> 0
<a> lifeCycleListeners . remove ( b ) ; </a> 0
<a> } </a> 0
<a> public class Entry { </a> 0
<a> public Object message ; </a> 0
<a> public Object multipleAtmoResources ; </a> 0
<a> public BroadcasterFuture < ? > future ; </a> 1
<a> public boolean writeLocally ; </a> 1
<a> public Object originalMessage ; </a> 1
<a> public Entry ( Object message , Object multipleAtmoResources , BroadcasterFuture < ? > future , Object originalMessage ) { </a> 0
<a> this . message = message ; </a> 0
<a> this . multipleAtmoResources = multipleAtmoResources ; </a> 0
<a> this . future = future ; </a> 1
<a> this . writeLocally = true ; </a> 1
<a> this . originalMessage = originalMessage ; </a> 1
<a> } </a> 0
<a> public Entry ( Object message , Object multipleAtmoResources , BroadcasterFuture < ? > future , boolean writeLocally ) { </a> 0
<a> this . message = message ; </a> 0
<a> this . multipleAtmoResources = multipleAtmoResources ; </a> 0
<a> this . future = future ; </a> 1
<a> this . writeLocally = writeLocally ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String toString ( ) { </a> 1
<a> return "Entry{" + </a> 1
<a> "message=" + message + </a> 1
<a> ", multipleAtmoResources=" + multipleAtmoResources + </a> 0
<a> ", future=" + future + </a> 0
<a> '}' ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected Runnable getBroadcastHandler ( ) { </a> 0
<a> return new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> Entry msg ; </a> 0
<a> while ( started . get ( ) ) { </a> 1
<a> try { </a> 0
<a> msg = messages . take ( ) ; </a> 1
<a> push ( msg ) ; </a> 1
<a> } catch ( Throwable ex ) { </a> 0
<a> if ( ! started . get ( ) ) { </a> 0
<a> logger . trace ( "failed to submit broadcast handler runnable to broadcast executor service on shutdown" , ex ) ; </a> 0
<a> } else { </a> 0
<a> logger . debug ( "failed to submit broadcast handler runnable to broadcast executor service" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } ; </a> 0
<a> } </a> 0
<a> protected void start ( ) { </a> 0
<a> if ( ! started . getAndSet ( true ) ) { </a> 0
<a> broadcasterCache = bc . getBroadcasterCache ( ) ; </a> 1
<a> broadcasterCache . start ( ) ; </a> 1
<a> notifierFuture = bc . getExecutorService ( ) . submit ( getBroadcastHandler ( ) ) ; </a> 1
<a> asyncWriteFuture = bc . getAsyncWriteService ( ) . submit ( getAsyncWriteHandler ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> protected void push ( Entry entry ) { </a> 1
<a> if ( destroyed . get ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> String prevMessage = entry . message . toString ( ) ; </a> 1
<a> if ( ! delayedBroadcast . isEmpty ( ) ) { </a> 1
<a> Iterator < Entry > i = delayedBroadcast . iterator ( ) ; </a> 1
<a> StringBuilder b = new StringBuilder ( ) ; </a> 0
<a> while ( i . hasNext ( ) ) { </a> 1
<a> Entry e = i . next ( ) ; </a> 1
<a> e . future . cancel ( true ) ; </a> 0
<a> try { </a> 0
<a> if ( e . message instanceof String </a> 0
<a> && entry . message instanceof String ) { </a> 1
<a> b . append ( e . message ) ; </a> 0
<a> } else { </a> 0
<a> push ( e ) ; </a> 1
<a> } </a> 0
<a> } finally { </a> 0
<a> i . remove ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( b . length ( ) > 0 ) { </a> 0
<a> entry . message = b . append ( entry . message ) . toString ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> if ( resources . isEmpty ( ) ) { </a> 1
<a> trackBroadcastMessage ( null , entry . message ) ; </a> 1
<a> if ( entry . future != null ) { </a> 1
<a> entry . future . done ( ) ; </a> 1
<a> } </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> Object finalMsg = translate ( entry . message ) ; </a> 1
<a> entry . message = finalMsg ; </a> 1
<a> try { </a> 0
<a> if ( entry . multipleAtmoResources == null ) { </a> 0
<a> for ( AtmosphereResource < ? , ? > r : resources ) { </a> 0
<a> finalMsg = perRequestFilter ( r , entry ) ; </a> 0
<a> if ( entry . writeLocally ) { </a> 1
<a> queueWriteIO ( r , finalMsg , entry ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } else if ( entry . multipleAtmoResources instanceof AtmosphereResource < ? , ? > ) { </a> 0
<a> finalMsg = perRequestFilter ( ( AtmosphereResource < ? , ? > ) entry . multipleAtmoResources , entry ) ; </a> 0
<a> if ( entry . writeLocally ) { </a> 1
<a> queueWriteIO ( ( AtmosphereResource < ? , ? > ) entry . multipleAtmoResources , finalMsg , entry ) ; </a> 0
<a> } </a> 0
<a> } else if ( entry . multipleAtmoResources instanceof Set ) { </a> 0
<a> Set < AtmosphereResource < ? , ? > > sub = ( Set < AtmosphereResource < ? , ? > > ) entry . multipleAtmoResources ; </a> 0
<a> for ( AtmosphereResource < ? , ? > r : sub ) { </a> 0
<a> finalMsg = perRequestFilter ( r , entry ) ; </a> 0
<a> if ( entry . writeLocally ) { </a> 1
<a> queueWriteIO ( r , finalMsg , entry ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> entry . message = prevMessage ; </a> 1
<a> } catch ( InterruptedException ex ) { </a> 0
<a> logger . debug ( ex . getMessage ( ) , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void queueWriteIO ( AtmosphereResource < ? , ? > r , Object finalMsg , Entry entry ) throws InterruptedException { </a> 0
<a> asyncWriteQueue . put ( new AsyncWriteToken ( r , finalMsg , entry . future ) ) ; </a> 1
<a> } </a> 0
<a> protected Object perRequestFilter ( AtmosphereResource < ? , ? > r , Entry msg ) { </a> 0
<a> Object finalMsg = msg . message ; </a> 1
<a> if ( AtmosphereResourceImpl . class . isAssignableFrom ( r . getClass ( ) ) ) { </a> 0
<a> if ( AtmosphereResourceImpl . class . cast ( r ) . isInScope ( ) ) { </a> 0
<a> if ( r . getRequest ( ) instanceof HttpServletRequest && bc . hasPerRequestFilters ( ) ) { </a> 0
<a> Object message = msg . originalMessage ; </a> 1
<a> BroadcastAction a = bc . filter ( ( HttpServletRequest ) r . getRequest ( ) , ( HttpServletResponse ) r . getResponse ( ) , message ) ; </a> 1
<a> if ( a . action ( ) == BroadcastAction . ACTION . ABORT </a> 0
<a> || a . message ( ) != msg . originalMessage ) { </a> 0
<a> finalMsg = a . message ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> trackBroadcastMessage ( r , finalMsg ) ; </a> 0
<a> } else { </a> 0
<a> removeAtmosphereResource ( r ) ; </a> 1
<a> BroadcasterFactory . getDefault ( ) . removeAllAtmosphereResource ( r ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> return finalMsg ; </a> 1
<a> } </a> 0
<a> private Object translate ( Object msg ) { </a> 1
<a> if ( Callable . class . isAssignableFrom ( msg . getClass ( ) ) ) { </a> 0
<a> try { </a> 0
<a> return Callable . class . cast ( msg ) . call ( ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "failed to cast message: " + msg , e ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> return msg ; </a> 0
<a> } </a> 0
<a> protected void executeAsyncWrite ( final AtmosphereResource < ? , ? > resource , final Object msg , final BroadcasterFuture future ) { </a> 1
<a> boolean notifyListeners = true ; </a> 0
<a> try { </a> 0
<a> final AtmosphereResourceEventImpl event = ( AtmosphereResourceEventImpl ) resource . getAtmosphereResourceEvent ( ) ; </a> 1
<a> boolean isVoid = event . isCancelled ( ) || event . isResumedOnTimeout ( ) || event . isResuming ( ) || ! event . isSuspended ( ) ; </a> 0
<a> if ( isVoid ) { </a> 0
<a> logger . debug ( "Resource {} has been already processed" , event ) ; </a> 0
<a> notifyListeners = false ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> event . setMessage ( msg ) ; </a> 1
<a> try { </a> 1
<a> if ( resource . getAtmosphereResourceEvent ( ) != null </a> 0
<a> && ! resource . getAtmosphereResourceEvent ( ) . isCancelled ( ) </a> 0
<a> && HttpServletRequest . class . isAssignableFrom ( resource . getRequest ( ) . getClass ( ) ) ) { </a> 0
<a> HttpServletRequest . class . cast ( resource . getRequest ( ) ) </a> 1
<a> . setAttribute ( MAX_INACTIVE , System . currentTimeMillis ( ) ) ; </a> 0
<a> } </a> 0
<a> } catch ( Exception t ) { </a> 1
<a> logger . warn ( "executeAsyncWrite exception." , t ) ; </a> 0
<a> logger . debug ( "Preventing corruption of a recycled request: resource" + resource , event ) ; </a> 1
<a> removeAtmosphereResource ( resource ) ; </a> 1
<a> BroadcasterFactory . getDefault ( ) . removeAllAtmosphereResource ( resource ) ; </a> 1
<a> event . setCancelled ( true ) ; </a> 0
<a> event . setThrowable ( t ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> broadcast ( resource , event ) ; </a> 1
<a> } finally { </a> 0
<a> if ( notifyListeners && resource instanceof AtmosphereEventLifecycle ) { </a> 0
<a> ( ( AtmosphereEventLifecycle ) resource ) . notifyListeners ( ) ; </a> 0
<a> } </a> 0
<a> if ( future != null ) { </a> 1
<a> future . done ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected Runnable getAsyncWriteHandler ( ) { </a> 1
<a> return new Runnable ( ) { </a> 1
<a> public void run ( ) { </a> 1
<a> AsyncWriteToken token ; </a> 0
<a> try { </a> 1
<a> token = asyncWriteQueue . take ( ) ; </a> 1
<a> bc . getAsyncWriteService ( ) . submit ( this ) ; </a> 1
<a> synchronized ( token . resource ) { </a> 0
<a> if ( AtmosphereResourceImpl . class . cast ( token . resource ) . isInScope ( ) ) { </a> 0
<a> executeAsyncWrite ( token . resource , token . msg , token . future ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Throwable ex ) { </a> 1
<a> if ( ! started . get ( ) ) { </a> 0
<a> logger . trace ( "failed to submit async write task on shutdown" , ex ) ; </a> 0
<a> } else { </a> 1
<a> logger . debug ( "failed to submit async write task" , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> } </a> 1
<a> protected void checkCachedAndPush ( final AtmosphereResource < ? , ? > r , final AtmosphereResourceEvent e ) { </a> 0
<a> retrieveTrackedBroadcast ( r , e ) ; </a> 1
<a> if ( e . getMessage ( ) instanceof List && ! ( ( List ) e . getMessage ( ) ) . isEmpty ( ) ) { </a> 1
<a> HttpServletRequest . class . cast ( r . getRequest ( ) ) . setAttribute ( CACHED , "true" ) ; </a> 0
<a> broadcast ( r , e ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> protected boolean retrieveTrackedBroadcast ( final AtmosphereResource < ? , ? > r , final AtmosphereResourceEvent e ) { </a> 0
<a> List < ? > missedMsg = broadcasterCache . retrieveFromCache ( r ) ; </a> 1
<a> if ( ! missedMsg . isEmpty ( ) ) { </a> 0
<a> e . setMessage ( missedMsg ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> protected void trackBroadcastMessage ( final AtmosphereResource < ? , ? > r , Object msg ) { </a> 0
<a> broadcasterCache . addToCache ( r , msg ) ; </a> 1
<a> } </a> 1
<a> protected void broadcast ( final AtmosphereResource < ? , ? > r , final AtmosphereResourceEvent e ) { </a> 0
<a> try { </a> 1
<a> r . getAtmosphereHandler ( ) . onStateChange ( e ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> onException ( t , r ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> protected void onException ( Throwable t , final AtmosphereResource < ? , ? > r ) { </a> 1
<a> logger . debug ( "onException()" , t ) ; </a> 1
<a> removeAtmosphereResource ( r ) ; </a> 0
<a> final AtmosphereResourceEventImpl event = ( AtmosphereResourceEventImpl ) r . getAtmosphereResourceEvent ( ) ; </a> 0
<a> event . setThrowable ( t ) ; </a> 0
<a> if ( r instanceof AtmosphereEventLifecycle ) { </a> 0
<a> ( ( AtmosphereEventLifecycle ) r ) </a> 0
<a> . notifyListeners ( event ) ; </a> 0
<a> ( ( AtmosphereEventLifecycle ) r ) . removeEventListeners ( ) ; </a> 0
<a> } </a> 0
<a> bc . getAsyncWriteService ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> try { </a> 0
<a> r . resume ( ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Was unable to resume a corrupted AtmosphereResource {}" , r ) ; </a> 1
<a> logger . warn ( "Cause" , t ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setSuspendPolicy ( long maxSuspendResource , POLICY policy ) { </a> 0
<a> this . maxSuspendResource . set ( maxSuspendResource ) ; </a> 0
<a> this . policy = policy ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > Future < T > broadcast ( T msg ) { </a> 1
<a> if ( destroyed . get ( ) ) { </a> 0
<a> logger . error ( "This Broadcaster has been destroyed and cannot be used" ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> start ( ) ; </a> 0
<a> Object newMsg = filter ( msg ) ; </a> 0
<a> if ( newMsg == null ) return null ; </a> 1
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> messages . offer ( new Entry ( newMsg , null , f , msg ) ) ; </a> 1
<a> return f ; </a> 0
<a> } </a> 0
<a> protected Object filter ( Object msg ) { </a> 0
<a> BroadcastAction a = bc . filter ( msg ) ; </a> 0
<a> if ( a . action ( ) == BroadcastAction . ACTION . ABORT || msg == null ) </a> 0
<a> return null ; </a> 0
<a> else </a> 0
<a> return a . message ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > Future < T > broadcast ( T msg , AtmosphereResource < ? , ? > r ) { </a> 0
<a> if ( destroyed . get ( ) ) { </a> 0
<a> logger . error ( "This Broadcaster has been destroyed and cannot be used" ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> start ( ) ; </a> 0
<a> Object newMsg = filter ( msg ) ; </a> 0
<a> if ( newMsg == null ) return null ; </a> 1
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> messages . offer ( new Entry ( newMsg , r , f , msg ) ) ; </a> 1
<a> return f ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > Future < T > broadcastOnResume ( T msg ) { </a> 1
<a> if ( destroyed . get ( ) ) { </a> 0
<a> logger . error ( "This Broadcaster has been destroyed and cannot be used" ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> start ( ) ; </a> 0
<a> Object newMsg = filter ( msg ) ; </a> 0
<a> if ( newMsg == null ) return null ; </a> 1
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> broadcastOnResume . offer ( new Entry ( newMsg , null , f , msg ) ) ; </a> 0
<a> return f ; </a> 0
<a> } </a> 0
<a> protected void broadcastOnResume ( AtmosphereResource < ? , ? > r ) { </a> 0
<a> Iterator < Entry > i = broadcastOnResume . iterator ( ) ; </a> 1
<a> while ( i . hasNext ( ) ) { </a> 1
<a> Entry e = i . next ( ) ; </a> 1
<a> e . multipleAtmoResources = r ; </a> 0
<a> push ( e ) ; </a> 0
<a> } </a> 0
<a> if ( resources . isEmpty ( ) ) { </a> 0
<a> broadcastOnResume . clear ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > Future < T > broadcast ( T msg , Set < AtmosphereResource < ? , ? > > subset ) { </a> 0
<a> if ( destroyed . get ( ) ) { </a> 0
<a> logger . error ( "This Broadcaster has been destroyed and cannot be used" ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> start ( ) ; </a> 0
<a> Object newMsg = filter ( msg ) ; </a> 0
<a> if ( newMsg == null ) return null ; </a> 1
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> messages . offer ( new Entry ( newMsg , subset , f , msg ) ) ; </a> 1
<a> return f ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public AtmosphereResource < ? , ? > addAtmosphereResource ( AtmosphereResource < ? , ? > r ) { </a> 0
<a> if ( destroyed . get ( ) ) { </a> 0
<a> logger . error ( "This Broadcaster has been destroyed and cannot be used" ) ; </a> 0
<a> return r ; </a> 1
<a> } </a> 0
<a> if ( scope == SCOPE . REQUEST && requestScoped . getAndSet ( true ) ) { </a> 0
<a> throw new IllegalStateException ( "Broadcaster " + this </a> 0
<a> + " cannot be used as its scope is set to REQUEST" ) ; </a> 0
<a> } </a> 0
<a> if ( maxSuspendResource . get ( ) > 0 && resources . size ( ) >= maxSuspendResource . get ( ) ) { </a> 0
<a> if ( policy == POLICY . FIFO ) { </a> 0
<a> AtmosphereResource < ? , ? > resource = resources . poll ( ) ; </a> 0
<a> try { </a> 0
<a> logger . warn ( "Too many resource. Forcing resume of {} " , resource ) ; </a> 0
<a> resource . resume ( ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "failed to resume resource {} " , resource , t ) ; </a> 0
<a> } </a> 0
<a> } else if ( policy == POLICY . REJECT ) { </a> 0
<a> throw new RejectedExecutionException ( String . format ( "Maximum suspended AtmosphereResources %s" , maxSuspendResource ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( resources . contains ( r ) ) { </a> 1
<a> return r ; </a> 1
<a> } </a> 0
<a> if ( resources . isEmpty ( ) ) { </a> 1
<a> BroadcasterFactory . getDefault ( ) . add ( this , name ) ; </a> 1
<a> } </a> 1
<a> resources . add ( r ) ; </a> 0
<a> checkCachedAndPush ( r , r . getAtmosphereResourceEvent ( ) ) ; </a> 1
<a> return r ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public AtmosphereResource < ? , ? > removeAtmosphereResource ( AtmosphereResource r ) { </a> 0
<a> if ( destroyed . get ( ) ) { </a> 0
<a> logger . error ( "This Broadcaster has been destroyed and cannot be used" ) ; </a> 0
<a> return r ; </a> 1
<a> } </a> 0
<a> if ( ! resources . contains ( r ) ) { </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> resources . remove ( r ) ; </a> 0
<a> if ( resources . isEmpty ( ) ) { </a> 1
<a> notifyEmptyListener ( ) ; </a> 1
<a> if ( scope != SCOPE . REQUEST && lifeCyclePolicy . getLifeCyclePolicy ( ) == BroadcasterLifeCyclePolicy . ATMOSPHERE_RESOURCE_POLICY . EMPTY ) { </a> 0
<a> releaseExternalResources ( ) ; </a> 1
<a> } else if ( lifeCyclePolicy . getLifeCyclePolicy ( ) == BroadcasterLifeCyclePolicy . ATMOSPHERE_RESOURCE_POLICY . EMPTY_DESTROY ) { </a> 0
<a> notifyDestroyListener ( ) ; </a> 0
<a> BroadcasterFactory . getDefault ( ) . remove ( this , name ) ; </a> 1
<a> destroy ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> return r ; </a> 1
<a> } </a> 0
<a> private void notifyIdleListener ( ) { </a> 0
<a> for ( BroadcasterLifeCyclePolicyListener b : lifeCycleListeners ) { </a> 1
<a> b . onIdle ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private void notifyDestroyListener ( ) { </a> 0
<a> for ( BroadcasterLifeCyclePolicyListener b : lifeCycleListeners ) { </a> 1
<a> b . onDestroy ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private void notifyEmptyListener ( ) { </a> 0
<a> for ( BroadcasterLifeCyclePolicyListener b : lifeCycleListeners ) { </a> 1
<a> b . onEmpty ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public void setBroadcasterConfig ( BroadcasterConfig bc ) { </a> 0
<a> this . bc = bc ; </a> 0
<a> } </a> 0
<a> public BroadcasterConfig getBroadcasterConfig ( ) { </a> 0
<a> return bc ; </a> 0
<a> } </a> 0
<a> public < T > Future < T > delayBroadcast ( T o ) { </a> 1
<a> return delayBroadcast ( o , 0 , null ) ; </a> 0
<a> } </a> 0
<a> public < T > Future < T > delayBroadcast ( final T o , long delay , TimeUnit t ) { </a> 1
<a> if ( destroyed . get ( ) ) { </a> 0
<a> logger . error ( "This Broadcaster has been destroyed and cannot be used" ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> start ( ) ; </a> 0
<a> final Object msg = filter ( o ) ; </a> 0
<a> if ( msg == null ) return null ; </a> 0
<a> final BroadcasterFuture < Object > future = new BroadcasterFuture < Object > ( msg ) ; </a> 1
<a> final Entry e = new Entry ( msg , null , future , o ) ; </a> 0
<a> Future < T > f ; </a> 1
<a> if ( delay > 0 ) { </a> 0
<a> f = bc . getScheduledExecutorService ( ) . schedule ( new Callable < T > ( ) { </a> 1
<a> public T call ( ) throws Exception { </a> 1
<a> delayedBroadcast . remove ( e ) ; </a> 0
<a> if ( Callable . class . isAssignableFrom ( o . getClass ( ) ) ) { </a> 0
<a> try { </a> 0
<a> Object r = Callable . class . cast ( o ) . call ( ) ; </a> 0
<a> final Object msg = filter ( r ) ; </a> 0
<a> if ( msg != null ) { </a> 0
<a> Entry entry = new Entry ( msg , null , null , r ) ; </a> 1
<a> push ( entry ) ; </a> 1
<a> } </a> 0
<a> return ( T ) msg ; </a> 1
<a> } catch ( Exception e1 ) { </a> 0
<a> logger . error ( "" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> final Object msg = filter ( o ) ; </a> 0
<a> final Entry e = new Entry ( msg , null , null , o ) ; </a> 1
<a> push ( e ) ; </a> 0
<a> return ( T ) msg ; </a> 1
<a> } </a> 0
<a> } , delay , t ) ; </a> 0
<a> e . future = new BroadcasterFuture < Object > ( f , msg ) ; </a> 1
<a> } </a> 0
<a> delayedBroadcast . offer ( e ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> public Future < ? > scheduleFixedBroadcast ( final Object o , long period , TimeUnit t ) { </a> 1
<a> return scheduleFixedBroadcast ( o , 0 , period , t ) ; </a> 0
<a> } </a> 0
<a> public Future < ? > scheduleFixedBroadcast ( final Object o , long waitFor , long period , TimeUnit t ) { </a> 1
<a> if ( destroyed . get ( ) ) { </a> 0
<a> logger . error ( "This Broadcaster has been destroyed and cannot be used" ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> start ( ) ; </a> 0
<a> if ( period == 0 || t == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> start ( ) ; </a> 0
<a> final Object msg = filter ( o ) ; </a> 0
<a> if ( msg == null ) return null ; </a> 0
<a> return bc . getScheduledExecutorService ( ) . scheduleWithFixedDelay ( new Runnable ( ) { </a> 1
<a> public void run ( ) { </a> 0
<a> if ( Callable . class . isAssignableFrom ( o . getClass ( ) ) ) { </a> 0
<a> try { </a> 0
<a> Object r = Callable . class . cast ( o ) . call ( ) ; </a> 0
<a> final Object msg = filter ( r ) ; </a> 0
<a> if ( msg != null ) { </a> 0
<a> Entry entry = new Entry ( msg , null , null , r ) ; </a> 1
<a> push ( entry ) ; </a> 1
<a> } </a> 0
<a> return ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> final Object msg = filter ( o ) ; </a> 0
<a> final Entry e = new Entry ( msg , null , null , o ) ; </a> 1
<a> push ( e ) ; </a> 0
<a> } </a> 0
<a> } , waitFor , period , t ) ; </a> 0
<a> } </a> 0
<a> public String toString ( ) { </a> 0
<a> return new StringBuilder ( this . getClass ( ) . getName ( ) ) . append ( "@" ) . append ( this . hashCode ( ) ) . append ( "\n" ) </a> 0
<a> . append ( "\tName: " ) . append ( name ) . append ( "\n" ) </a> 0
<a> . append ( "\tScope: " ) . append ( scope ) . append ( "\n" ) </a> 0
<a> . append ( "\tBroasdcasterCache " ) . append ( broadcasterCache ) . append ( "\n" ) </a> 0
<a> . append ( "\tAtmosphereResource: " ) . append ( resources . size ( ) ) . append ( "\n" ) </a> 0
<a> . toString ( ) ; </a> 0
<a> } </a> 0
<a> private static class AsyncWriteToken { </a> 0
<a> final AtmosphereResource < ? , ? > resource ; </a> 1
<a> final Object msg ; </a> 1
<a> final BroadcasterFuture future ; </a> 1
<a> public AsyncWriteToken ( AtmosphereResource < ? , ? > resource , Object msg , BroadcasterFuture future ) { </a> 1
<a> this . resource = resource ; </a> 0
<a> this . msg = msg ; </a> 0
<a> this . future = future ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import org . atmosphere . di . InjectorProvider ; </a> 1
<a> import org . atmosphere . util . AbstractBroadcasterProxy ; </a> 1
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . Enumeration ; </a> 0
<a> import java . util . UUID ; </a> 1
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 0
<a> import static org . atmosphere . cpr . BroadcasterLifeCyclePolicy . ATMOSPHERE_RESOURCE_POLICY . EMPTY ; </a> 1
<a> import static org . atmosphere . cpr . BroadcasterLifeCyclePolicy . ATMOSPHERE_RESOURCE_POLICY . EMPTY_DESTROY ; </a> 1
<a> import static org . atmosphere . cpr . BroadcasterLifeCyclePolicy . ATMOSPHERE_RESOURCE_POLICY . IDLE ; </a> 1
<a> import static org . atmosphere . cpr . BroadcasterLifeCyclePolicy . ATMOSPHERE_RESOURCE_POLICY . IDLE_DESTROY ; </a> 1
<a> import static org . atmosphere . cpr . BroadcasterLifeCyclePolicy . ATMOSPHERE_RESOURCE_POLICY . NEVER ; </a> 0
<a> public class DefaultBroadcasterFactory extends BroadcasterFactory { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( DefaultBroadcasterFactory . class ) ; </a> 0
<a> private final ConcurrentHashMap < Object , Broadcaster > store </a> 1
<a> = new ConcurrentHashMap < Object , Broadcaster > ( ) ; </a> 1
<a> private final Class < ? extends Broadcaster > clazz ; </a> 1
<a> private BroadcasterLifeCyclePolicy policy = </a> 0
<a> new BroadcasterLifeCyclePolicy . Builder ( ) . policy ( NEVER ) . build ( ) ; </a> 0
<a> protected DefaultBroadcasterFactory ( Class < ? extends Broadcaster > clazz , String broadcasterLifeCyclePolicy ) { </a> 0
<a> this . clazz = clazz ; </a> 0
<a> if ( factory == null ) { </a> 0
<a> this . factory = this ; </a> 1
<a> } </a> 0
<a> configure ( broadcasterLifeCyclePolicy ) ; </a> 0
<a> } </a> 0
<a> private void configure ( String broadcasterLifeCyclePolicy ) { </a> 0
<a> if ( EMPTY . name ( ) . equalsIgnoreCase ( broadcasterLifeCyclePolicy ) ) { </a> 0
<a> policy = new BroadcasterLifeCyclePolicy . Builder ( ) . policy ( EMPTY ) . build ( ) ; </a> 0
<a> } else if ( EMPTY_DESTROY . name ( ) . equalsIgnoreCase ( broadcasterLifeCyclePolicy ) ) { </a> 0
<a> policy = new BroadcasterLifeCyclePolicy . Builder ( ) . policy ( EMPTY_DESTROY ) . build ( ) ; </a> 0
<a> } else if ( IDLE . name ( ) . equalsIgnoreCase ( broadcasterLifeCyclePolicy ) ) { </a> 0
<a> policy = new BroadcasterLifeCyclePolicy . Builder ( ) . policy ( IDLE ) . idleTimeInMS ( 5 * 60 * 100 ) . build ( ) ; </a> 0
<a> } else if ( IDLE_DESTROY . name ( ) . equalsIgnoreCase ( broadcasterLifeCyclePolicy ) ) { </a> 0
<a> policy = new BroadcasterLifeCyclePolicy . Builder ( ) . policy ( IDLE_DESTROY ) . idleTimeInMS ( 5 * 60 * 100 ) . build ( ) ; </a> 0
<a> } else if ( NEVER . name ( ) . equalsIgnoreCase ( broadcasterLifeCyclePolicy ) ) { </a> 0
<a> policy = new BroadcasterLifeCyclePolicy . Builder ( ) . policy ( NEVER ) . build ( ) ; </a> 0
<a> } else { </a> 0
<a> logger . warn ( "Unsupported BroadcasterLifeCyclePolicy policy {}" , broadcasterLifeCyclePolicy ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public synchronized final Broadcaster get ( ) throws IllegalAccessException , InstantiationException { </a> 0
<a> Broadcaster b = clazz . newInstance ( ) ; </a> 0
<a> InjectorProvider . getInjector ( ) . inject ( b ) ; </a> 0
<a> if ( AbstractBroadcasterProxy . class . isAssignableFrom ( b . getClass ( ) ) ) { </a> 0
<a> AbstractBroadcasterProxy . class . cast ( b ) . configure ( config ) ; </a> 0
<a> } </a> 0
<a> b . setBroadcasterConfig ( new BroadcasterConfig ( AtmosphereServlet . broadcasterFilters , config ) ) ; </a> 0
<a> b . setID ( clazz . getSimpleName ( ) + "-" + UUID . randomUUID ( ) ) ; </a> 0
<a> b . setBroadcasterLifeCyclePolicy ( policy ) ; </a> 0
<a> store . put ( b . getID ( ) , b ) ; </a> 0
<a> return b ; </a> 0
<a> } </a> 0
<a> public synchronized final Broadcaster get ( Class < ? extends Broadcaster > c , Object id ) throws IllegalAccessException , InstantiationException { </a> 0
<a> if ( id == null ) throw new NullPointerException ( "id is null" ) ; </a> 1
<a> if ( c == null ) throw new NullPointerException ( "Class is null" ) ; </a> 1
<a> if ( getBroadcaster ( id ) != null ) </a> 1
<a> throw new IllegalStateException ( "Broadcaster already existing. Use BroadcasterFactory.lookup instead" ) ; </a> 1
<a> Broadcaster b = c . newInstance ( ) ; </a> 0
<a> InjectorProvider . getInjector ( ) . inject ( b ) ; </a> 0
<a> if ( AbstractBroadcasterProxy . class . isAssignableFrom ( b . getClass ( ) ) ) { </a> 0
<a> AbstractBroadcasterProxy . class . cast ( b ) . configure ( config ) ; </a> 0
<a> } </a> 1
<a> b . setBroadcasterConfig ( new BroadcasterConfig ( AtmosphereServlet . broadcasterFilters , config ) ) ; </a> 0
<a> b . setID ( id . toString ( ) ) ; </a> 0
<a> b . setBroadcasterLifeCyclePolicy ( policy ) ; </a> 0
<a> store . put ( id , b ) ; </a> 1
<a> return b ; </a> 0
<a> } </a> 0
<a> private Broadcaster getBroadcaster ( Object name ) { </a> 1
<a> return store . get ( name ) ; </a> 1
<a> } </a> 0
<a> public boolean add ( Broadcaster b , Object id ) { </a> 0
<a> return ( store . put ( id , b ) == null ) ; </a> 0
<a> } </a> 0
<a> public boolean remove ( Broadcaster b , Object id ) { </a> 0
<a> return ( store . remove ( id ) != null ) ; </a> 0
<a> } </a> 0
<a> public final Broadcaster lookup ( Class < ? extends Broadcaster > c , Object id ) { </a> 0
<a> return lookup ( c , id , false ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Broadcaster lookup ( Class < ? extends Broadcaster > c , Object id , boolean createIfNull ) { </a> 0
<a> Broadcaster b = getBroadcaster ( id ) ; </a> 1
<a> if ( b != null && ! c . isAssignableFrom ( b . getClass ( ) ) ) { </a> 0
<a> String msg = "Invalid lookup class " + c . getName ( ) + ". Cached class is: " + b . getClass ( ) . getName ( ) ; </a> 0
<a> logger . debug ( "{}" , msg ) ; </a> 1
<a> throw new IllegalStateException ( msg ) ; </a> 0
<a> } </a> 0
<a> if ( b == null && createIfNull ) { </a> 1
<a> try { </a> 0
<a> b = get ( c , id ) ; </a> 1
<a> } catch ( IllegalAccessException e ) { </a> 0
<a> throw new IllegalStateException ( e ) ; </a> 0
<a> } catch ( InstantiationException e ) { </a> 0
<a> throw new IllegalStateException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return b ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void removeAllAtmosphereResource ( AtmosphereResource < ? , ? > r ) { </a> 0
<a> try { </a> 0
<a> synchronized ( r ) { </a> 0
<a> if ( store . size ( ) > 0 ) { </a> 0
<a> for ( Broadcaster b : lookupAll ( ) ) { </a> 0
<a> try { </a> 0
<a> b . removeAtmosphereResource ( r ) ; </a> 0
<a> } catch ( IllegalStateException ex ) { </a> 0
<a> logger . trace ( ex . getMessage ( ) , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> logger . warn ( ex . getMessage ( ) , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Collection < Broadcaster > lookupAll ( ) { </a> 0
<a> return Collections . unmodifiableCollection ( store . values ( ) ) ; </a> 0
<a> } </a> 0
<a> public synchronized void destroy ( ) { </a> 0
<a> Enumeration < Broadcaster > e = store . elements ( ) ; </a> 0
<a> while ( e . hasMoreElements ( ) ) { </a> 0
<a> e . nextElement ( ) . destroy ( ) ; </a> 0
<a> } </a> 0
<a> store . clear ( ) ; </a> 0
<a> factory = null ; </a> 1
<a> } </a> 0
<a> public static BroadcasterFactory buildAndReplaceDefaultfactory ( Class < ? extends Broadcaster > clazz , AtmosphereServlet . AtmosphereConfig c ) </a> 0
<a> throws InstantiationException , IllegalAccessException { </a> 1
<a> factory = new DefaultBroadcasterFactory ( clazz , "NEVER" ) ; </a> 0
<a> config = c ; </a> 0
<a> return factory ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> public interface FrameworkConfig { </a> 0
<a> String JERSEY_BROADCASTER = "org.atmosphere.jersey.JerseyBroadcaster" ; </a> 0
<a> String REDIS_BROADCASTER = "org.atmosphere.plugin.redis.RedisBroadcaster" ; </a> 0
<a> String JMS_BROADCASTER = "org.atmosphere.plugin.jms.JMSBroadcaster" ; </a> 0
<a> String JGROUPS_BROADCASTER = "org.atmosphere.plugin.jgroups.JGroupsBroadcaster" ; </a> 0
<a> String XMPP_BROADCASTER = "org.atmosphere.plugin.xmpp.XMPPBroadcaster" ; </a> 0
<a> String JERSEY_CONTAINER = "com.sun.jersey.spi.container.servlet.ServletContainer" ; </a> 0
<a> String WEB_INF_CLASSES = "/WEB-INF/classes/" ; </a> 0
<a> String ATMOSPHERE_SERVLET = AtmosphereServlet . class . getName ( ) ; </a> 0
<a> String ATMOSPHERE_RESOURCE = AtmosphereResource . class . getName ( ) ; </a> 0
<a> String SUPPORT_SESSION = AsynchronousProcessor . class . getName ( ) + ".supportSession" ; </a> 0
<a> String ATMOSPHERE_HANDLER = AtmosphereHandler . class . getName ( ) ; </a> 0
<a> String CONTAINER_RESPONSE = "org.atmosphere.jersey.containerResponse" ; </a> 0
<a> String WRITE_HEADERS = AtmosphereResource . class . getName ( ) + "." + "writeHeader" ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> public interface HeaderConfig { </a> 0
<a> String X_ATMOSPHERE_FIRSTLONGPOLLING_DONE = "X-Atmosphere-first-long-polling-done" ; </a> 0
<a> String X_ATMOSPHERE_TRANSPORT = "X-Atmosphere-Transport" ; </a> 0
<a> String LONG_POLLING_TRANSPORT = "long-polling" ; </a> 0
<a> String STREAMING_TRANSPORT = "streaming" ; </a> 0
<a> String WEBSOCKET_TRANSPORT = "websocket" ; </a> 0
<a> String X_ATMOSPHERE_ERROR = "X-Atmosphere-error" ; </a> 0
<a> String X_ATMOSPHERE_TRACKING_ID = "X-Atmosphere-tracking-id" ; </a> 0
<a> String X_ATMOSPHERE_FRAMEWORK = "X-Atmosphere-Framework" ; </a> 0
<a> String X_CACHE_DATE = "X-Cache-Date" ; </a> 0
<a> String X_ATMOSPHERE = "X-Atmosphere" ; </a> 0
<a> String X_ATMOSPHERE_TRACKMESSAGESIZE = "X-Atmosphere-TrackMessageSize" ; </a> 0
<a> String ACCESS_CONTROL_ALLOW_ORIGIN = "Access-Control-Allow-Origin" ; </a> 0
<a> String ACCESS_CONTROL_ALLOW_CREDENTIALS = "Access-Control-Allow-Credentials" ; </a> 0
<a> String PRAGMA = "Pragma" ; </a> 0
<a> String CACHE_CONTROL = "Cache-Control" ; </a> 0
<a> String EXPIRES = "Expires" ; </a> 0
<a> String WEBSOCKET_UPGRADE = "Upgrade" ; </a> 0
<a> String ATMOSPHERE_POST_BODY = "X-Atmosphere-Post-Body" ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import org . atmosphere . handler . ReflectorServletProcessor ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> public class MeteorServlet extends AtmosphereServlet { </a> 0
<a> private final static String SERVLET_CLASS = "org.atmosphere.servlet" ; </a> 1
<a> private final static String FILTER_CLASS = "org.atmosphere.filter" ; </a> 1
<a> private final static String MAPPING = "org.atmosphere.mapping" ; </a> 1
<a> private final static String FILTER_NAME = "org.atmosphere.filter.name" ; </a> 1
<a> @ Override </a> 0
<a> protected void loadConfiguration ( ServletConfig sc ) throws ServletException { </a> 0
<a> String servletClass = sc . getInitParameter ( SERVLET_CLASS ) ; </a> 0
<a> String mapping = sc . getInitParameter ( MAPPING ) ; </a> 0
<a> String filterClass = sc . getInitParameter ( FILTER_CLASS ) ; </a> 0
<a> String filterName = sc . getInitParameter ( FILTER_NAME ) ; </a> 0
<a> ReflectorServletProcessor r = new ReflectorServletProcessor ( ) ; </a> 0
<a> r . setServletClassName ( servletClass ) ; </a> 0
<a> r . setFilterClassName ( filterClass ) ; </a> 0
<a> r . setFilterName ( filterName ) ; </a> 0
<a> if ( mapping == null ) { </a> 0
<a> mapping = "/*" ; </a> 0
<a> } </a> 0
<a> addAtmosphereHandler ( mapping , r ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public void destroy ( ) { </a> 0
<a> super . destroy ( ) ; </a> 0
<a> Meteor . destroy ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public interface PerRequestBroadcastFilter extends BroadcastFilter { </a> 0
<a> BroadcastAction filter ( HttpServletRequest request , HttpServletResponse response , Object message ) ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . cpr ; </a> 0
<a> public interface Trackable { </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . di ; </a> 0
<a> public interface Injector { </a> 1
<a> void inject ( Object o ) ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . di ; </a> 0
<a> import java . util . NoSuchElementException ; </a> 1
<a> import java . util . ServiceLoader ; </a> 1
<a> public final class InjectorProvider { </a> 1
<a> private InjectorProvider ( ) { </a> 1
<a> } </a> 1
<a> public static Injector getInjector ( ) { </a> 1
<a> return LazyProvider . INJECTOR ; </a> 1
<a> } </a> 1
<a> private static final class LazyProvider { </a> 1
<a> private static final Injector INJECTOR ; </a> 1
<a> static { </a> 1
<a> Injector injector = new NoopInjector ( ) ; </a> 1
<a> try { </a> 1
<a> injector = ServiceLoader . load ( Injector . class ) . iterator ( ) . next ( ) ; </a> 1
<a> } catch ( NoSuchElementException e ) { </a> 1
<a> } </a> 1
<a> INJECTOR = injector ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . di ; </a> 0
<a> final class NoopInjector implements Injector { </a> 1
<a> public void inject ( Object o ) { </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . di ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 1
<a> public interface ServletContextProvider { </a> 1
<a> ServletContext getServletContext ( ) ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . handler ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServletProcessor ; </a> 0
<a> import org . atmosphere . cpr . FrameworkConfig ; </a> 0
<a> import org . atmosphere . util . AtmosphereFilterChain ; </a> 0
<a> import org . atmosphere . util . FilterConfigImpl ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . Filter ; </a> 0
<a> import javax . servlet . FilterChain ; </a> 0
<a> import javax . servlet . Servlet ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . ServletRequest ; </a> 0
<a> import javax . servlet . ServletResponse ; </a> 0
<a> import javax . servlet . http . HttpServlet ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . MalformedURLException ; </a> 1
<a> import java . net . URL ; </a> 0
<a> import java . net . URLClassLoader ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Enumeration ; </a> 0
<a> public class ReflectorServletProcessor extends AbstractReflectorAtmosphereHandler </a> 0
<a> implements AtmosphereServletProcessor { </a> 0
<a> private final static String APPLICATION_NAME = "applicationClassName" ; </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( ReflectorServletProcessor . class ) ; </a> 0
<a> private String servletClassName ; </a> 0
<a> private final ArrayList < String > filtersClass = new ArrayList < String > ( ) ; </a> 0
<a> private final FilterChainServletWrapper wrapper = new FilterChainServletWrapper ( ) ; </a> 0
<a> private final AtmosphereFilterChain filterChain = new AtmosphereFilterChain ( ) ; </a> 0
<a> private Servlet servlet ; </a> 0
<a> private String filterName ; </a> 0
<a> public ReflectorServletProcessor ( ) { </a> 0
<a> } </a> 0
<a> void loadWebApplication ( ServletConfig sc ) throws MalformedURLException , </a> 1
<a> InstantiationException , IllegalAccessException , ClassNotFoundException { </a> 1
<a> URL url = sc . getServletContext ( ) . getResource ( "/WEB-INF/lib/" ) ; </a> 0
<a> URLClassLoader urlC = new URLClassLoader ( new URL [ ] { url } , </a> 0
<a> Thread . currentThread ( ) . getContextClassLoader ( ) ) ; </a> 0
<a> if ( getServletClassName ( ) != null && servlet == null ) { </a> 0
<a> try { </a> 0
<a> servlet = ( Servlet ) urlC . loadClass ( getServletClassName ( ) ) . newInstance ( ) ; </a> 0
<a> } catch ( NullPointerException ex ) { </a> 0
<a> servlet = ( Servlet ) Thread . currentThread ( ) . getContextClassLoader ( ) </a> 1
<a> . loadClass ( servletClassName ) . newInstance ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> logger . info ( "Installing Servlet {}" , servletClassName ) ; </a> 0
<a> filterChain . setServlet ( sc , servlet ) ; </a> 1
<a> Filter f ; </a> 0
<a> for ( String fClass : filtersClass ) { </a> 0
<a> try { </a> 1
<a> f = ( Filter ) urlC . loadClass ( fClass ) . newInstance ( ) ; </a> 1
<a> } catch ( NullPointerException ex ) { </a> 1
<a> f = ( Filter ) Thread . currentThread ( ) . getContextClassLoader ( ) </a> 1
<a> . loadClass ( fClass ) . newInstance ( ) ; </a> 1
<a> } </a> 1
<a> FilterConfigImpl fc = new FilterConfigImpl ( sc ) ; </a> 0
<a> fc . setFilter ( f ) ; </a> 0
<a> if ( filterName == null ) { </a> 0
<a> if ( sc . getInitParameter ( APPLICATION_NAME ) != null ) { </a> 0
<a> filterName = sc . getInitParameter ( APPLICATION_NAME ) ; </a> 0
<a> } else { </a> 0
<a> filterName = f . getClass ( ) . getSimpleName ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> fc . setFilterName ( filterName ) ; </a> 0
<a> filterChain . addFilter ( fc ) ; </a> 0
<a> logger . info ( "Installing Filter {}" , filterName ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > r ) </a> 0
<a> throws IOException { </a> 0
<a> r . getRequest ( ) . setAttribute ( FrameworkConfig . ATMOSPHERE_RESOURCE , r ) ; </a> 0
<a> r . getRequest ( ) . setAttribute ( FrameworkConfig . ATMOSPHERE_HANDLER , this ) ; </a> 0
<a> try { </a> 0
<a> wrapper . service ( r . getRequest ( ) , r . getResponse ( ) ) ; </a> 0
<a> } catch ( Throwable ex ) { </a> 0
<a> logger . error ( "onRequest()" , ex ) ; </a> 0
<a> throw new RuntimeException ( ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void init ( ServletConfig sc ) throws ServletException { </a> 1
<a> try { </a> 0
<a> loadWebApplication ( sc ) ; </a> 1
<a> } catch ( Exception ex ) { </a> 0
<a> throw new ServletException ( ex ) ; </a> 0
<a> } </a> 0
<a> wrapper . init ( sc ) ; </a> 1
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> if ( filterChain != null ) { </a> 0
<a> filterChain . destroy ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public String getServletClass ( ) { </a> 0
<a> return servletClassName ; </a> 0
<a> } </a> 0
<a> public void setServletClass ( String servletClass ) { </a> 0
<a> this . servletClassName = servletClass ; </a> 0
<a> } </a> 0
<a> public String getServletClassName ( ) { </a> 0
<a> return servletClassName ; </a> 0
<a> } </a> 0
<a> public void setServletClassName ( String servletClass ) { </a> 0
<a> this . servletClassName = servletClass ; </a> 0
<a> } </a> 0
<a> public void setFilterClassName ( String filterClass ) { </a> 0
<a> if ( filterClass == null ) return ; </a> 0
<a> filtersClass . add ( filterClass ) ; </a> 0
<a> } </a> 0
<a> public Servlet getServlet ( ) { </a> 0
<a> return servlet ; </a> 0
<a> } </a> 0
<a> public void setServlet ( Servlet servlet ) { </a> 0
<a> this . servlet = servlet ; </a> 0
<a> } </a> 0
<a> public void setFilterName ( String filterName ) { </a> 0
<a> this . filterName = filterName ; </a> 0
<a> } </a> 0
<a> private class FilterChainServletWrapper extends HttpServlet { </a> 0
<a> @ Override </a> 0
<a> public void destroy ( ) { </a> 0
<a> filterChain . destroy ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String getInitParameter ( String name ) { </a> 0
<a> return getServletConfig ( ) . getInitParameter ( name ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Enumeration getInitParameterNames ( ) { </a> 0
<a> return getServletConfig ( ) . getInitParameterNames ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ServletConfig getServletConfig ( ) { </a> 0
<a> return filterChain . getServletConfig ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ServletContext getServletContext ( ) { </a> 0
<a> return getServletConfig ( ) . getServletContext ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String getServletInfo ( ) { </a> 0
<a> return filterChain . getServlet ( ) . getServletInfo ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void init ( ServletConfig sc ) throws ServletException { </a> 0
<a> filterChain . init ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void init ( ) throws ServletException { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void log ( String msg ) { </a> 0
<a> getServletContext ( ) . log ( getServletName ( ) + ": " + msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void log ( String message , Throwable t ) { </a> 0
<a> getServletContext ( ) . log ( getServletName ( ) + ": " + message , t ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void service ( ServletRequest req , ServletResponse res ) </a> 0
<a> throws ServletException , IOException { </a> 0
<a> filterChain . invokeFilterChain ( req , res ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String getServletName ( ) { </a> 0
<a> return filterChain . getServletConfig ( ) . getServletName ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . handler ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterCache ; </a> 0
<a> import org . atmosphere . websocket . WebSocketHttpServletResponse ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> public class SimpleWebSocketAtmosphereHandler extends AbstractReflectorAtmosphereHandler { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( SimpleWebSocketAtmosphereHandler . class ) ; </a> 0
<a> @ Override </a> 0
<a> public final void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > r ) throws IOException { </a> 0
<a> if ( ! r . getResponse ( ) . getClass ( ) . isAssignableFrom ( WebSocketHttpServletResponse . class ) ) { </a> 0
<a> try { </a> 0
<a> r . getAtmosphereConfig ( ) . getServletContext ( ) </a> 0
<a> . getNamedDispatcher ( r . getAtmosphereConfig ( ) . getDispatcherName ( ) ) </a> 0
<a> . forward ( r . getRequest ( ) , r . getResponse ( ) ) ; </a> 0
<a> } catch ( ServletException e ) { </a> 0
<a> IOException ie = new IOException ( ) ; </a> 0
<a> ie . initCause ( e ) ; </a> 0
<a> throw ie ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> upgrade ( r ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void upgrade ( AtmosphereResource < HttpServletRequest , HttpServletResponse > resource ) throws IOException { </a> 0
<a> logger . debug ( "Suspending request: {}" , resource . getRequest ( ) ) ; </a> 0
<a> resource . suspend ( - 1 , false ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void destroy ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . util ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFuture ; </a> 0
<a> import org . atmosphere . cpr . FrameworkConfig ; </a> 0
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import java . lang . reflect . Method ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . concurrent . Future ; </a> 0
<a> public abstract class AbstractBroadcasterProxy extends DefaultBroadcaster { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( AbstractBroadcasterProxy . class ) ; </a> 0
<a> private Method jerseyBroadcast ; </a> 0
<a> protected AtmosphereServlet . AtmosphereConfig config ; </a> 0
<a> public AbstractBroadcasterProxy ( ) { </a> 0
<a> this ( AbstractBroadcasterProxy . class . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> public AbstractBroadcasterProxy ( String id ) { </a> 0
<a> super ( id ) ; </a> 0
<a> start ( ) ; </a> 0
<a> } </a> 0
<a> public void configure ( AtmosphereServlet . AtmosphereConfig config ) { </a> 0
<a> this . config = config ; </a> 0
<a> } </a> 0
<a> abstract public void incomingBroadcast ( ) ; </a> 0
<a> abstract public void outgoingBroadcast ( Object message ) ; </a> 0
<a> @ Override </a> 0
<a> protected Runnable getBroadcastHandler ( ) { </a> 0
<a> return new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> incomingBroadcast ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> protected void reconfigure ( ) { </a> 0
<a> if ( notifierFuture != null ) { </a> 0
<a> notifierFuture . cancel ( true ) ; </a> 0
<a> } </a> 0
<a> notifierFuture = bc . getExecutorService ( ) . submit ( getBroadcastHandler ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void broadcast ( final AtmosphereResource < ? , ? > r , final AtmosphereResourceEvent e ) { </a> 0
<a> if ( r . getRequest ( ) instanceof HttpServletRequest ) { </a> 0
<a> if ( ( ( HttpServletRequest ) r . getRequest ( ) ) . getAttribute ( FrameworkConfig . CONTAINER_RESPONSE ) != null ) { </a> 1
<a> try { </a> 0
<a> if ( jerseyBroadcast == null ) { </a> 0
<a> Class jerseyBroadcasterUtil = Class . forName ( "org.atmosphere.jersey.util.JerseyBroadcasterUtil" ) ; </a> 0
<a> jerseyBroadcast = jerseyBroadcasterUtil . getMethod ( "broadcast" , new Class [ ] { AtmosphereResource . class , AtmosphereResourceEvent . class } ) ; </a> 0
<a> } </a> 0
<a> jerseyBroadcast . invoke ( null , new Object [ ] { r , e } ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> super . broadcast ( r , e ) ; </a> 1
<a> } </a> 0
<a> } else { </a> 0
<a> super . broadcast ( r , e ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void broadcastReceivedMessage ( Object message ) { </a> 0
<a> try { </a> 0
<a> Object newMsg = filter ( message ) ; </a> 0
<a> push ( new Entry ( newMsg , null , new BroadcasterFuture < Object > ( newMsg ) , message ) ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> logger . error ( "failed to push message: " + message , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > Future < T > broadcast ( T msg ) { </a> 1
<a> Object newMsg = filter ( msg ) ; </a> 1
<a> if ( newMsg == null ) return null ; </a> 1
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> try { </a> 0
<a> outgoingBroadcast ( msg ) ; </a> 0
<a> push ( new Entry ( newMsg , null , f , false ) ) ; </a> 0
<a> } finally { </a> 0
<a> f . done ( ) ; </a> 1
<a> } </a> 0
<a> return f ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > Future < T > broadcast ( T msg , AtmosphereResource < ? , ? > r ) { </a> 0
<a> Object newMsg = filter ( msg ) ; </a> 1
<a> if ( newMsg == null ) return null ; </a> 1
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> try { </a> 0
<a> outgoingBroadcast ( msg ) ; </a> 0
<a> push ( new Entry ( newMsg , r , f , false ) ) ; </a> 1
<a> } finally { </a> 0
<a> f . done ( ) ; </a> 1
<a> } </a> 0
<a> return f ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > Future < T > broadcast ( T msg , Set < AtmosphereResource < ? , ? > > subset ) { </a> 0
<a> Object newMsg = filter ( msg ) ; </a> 1
<a> if ( newMsg == null ) return null ; </a> 1
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> try { </a> 0
<a> outgoingBroadcast ( msg ) ; </a> 0
<a> push ( new Entry ( newMsg , subset , f , false ) ) ; </a> 1
<a> } finally { </a> 0
<a> f . done ( ) ; </a> 1
<a> } </a> 0
<a> return f ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . util ; </a> 0
<a> import javax . servlet . Filter ; </a> 0
<a> import javax . servlet . FilterChain ; </a> 0
<a> import javax . servlet . Servlet ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . ServletRequest ; </a> 0
<a> import javax . servlet . ServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> public final class AtmosphereFilterChain implements FilterChain { </a> 0
<a> public static final int INCREMENT = 20 ; </a> 0
<a> private FilterConfigImpl [ ] filters = new FilterConfigImpl [ 20 ] ; </a> 0
<a> private int n = 0 ; </a> 0
<a> private Servlet servlet = null ; </a> 0
<a> private ServletConfig configImpl ; </a> 0
<a> public AtmosphereFilterChain ( ) { </a> 0
<a> } </a> 0
<a> public void init ( ) throws ServletException { </a> 0
<a> for ( FilterConfigImpl f : filters ) { </a> 0
<a> if ( f != null ) { </a> 0
<a> f . getFilter ( ) . init ( f ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( servlet != null ) { </a> 0
<a> servlet . init ( configImpl ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void invokeFilterChain ( ServletRequest request , ServletResponse response ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> request . setAttribute ( "pos" , new AtomicInteger ( 0 ) ) ; </a> 0
<a> doFilter ( request , response ) ; </a> 0
<a> } </a> 0
<a> public void doFilter ( ServletRequest request , ServletResponse response ) </a> 0
<a> throws IOException , ServletException { </a> 0
<a> AtomicInteger pos = ( ( AtomicInteger ) request . getAttribute ( "pos" ) ) ; </a> 0
<a> if ( pos . get ( ) < n ) { </a> 0
<a> FilterConfigImpl filterConfig = filters [ pos . getAndIncrement ( ) ] ; </a> 0
<a> Filter filter = null ; </a> 0
<a> try { </a> 0
<a> filter = filterConfig . getFilter ( ) ; </a> 0
<a> filter . doFilter ( request , response , this ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( ServletException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( RuntimeException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> throw new ServletException ( "Throwable" , e ) ; </a> 0
<a> } </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> if ( servlet != null ) { </a> 0
<a> servlet . service ( request , response ) ; </a> 0
<a> } </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( ServletException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( RuntimeException e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> throw new ServletException ( "Throwable" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void addFilter ( FilterConfigImpl filterConfig ) { </a> 0
<a> if ( filterConfig . getFilter ( ) == null ) { </a> 0
<a> throw new NullPointerException ( "Filter is null" ) ; </a> 0
<a> } </a> 0
<a> if ( n == filters . length ) { </a> 0
<a> FilterConfigImpl [ ] newFilters = </a> 0
<a> new FilterConfigImpl [ n + INCREMENT ] ; </a> 0
<a> System . arraycopy ( filters , 0 , newFilters , 0 , n ) ; </a> 0
<a> filters = newFilters ; </a> 0
<a> } </a> 0
<a> filters [ n ++ ] = filterConfig ; </a> 0
<a> } </a> 0
<a> public void setServlet ( ServletConfig configImpl , Servlet servlet ) { </a> 0
<a> this . configImpl = configImpl ; </a> 0
<a> this . servlet = servlet ; </a> 0
<a> } </a> 0
<a> public FilterConfigImpl getFilter ( int i ) { </a> 0
<a> return filters [ i ] ; </a> 0
<a> } </a> 0
<a> public Servlet getServlet ( ) { </a> 0
<a> return servlet ; </a> 0
<a> } </a> 0
<a> public ServletConfig getServletConfig ( ) { </a> 0
<a> return configImpl ; </a> 0
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> if ( n > 0 && filters != null ) { </a> 0
<a> for ( int i = 0 ; i < filters . length ; i ++ ) { </a> 0
<a> if ( filters [ i ] != null ) { </a> 0
<a> filters [ i ] . recycle ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> filters = null ; </a> 0
<a> } </a> 0
<a> if ( servlet != null ) { </a> 0
<a> servlet . destroy ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . util ; </a> 0
<a> import javax . servlet . Filter ; </a> 0
<a> import javax . servlet . FilterConfig ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import java . util . Enumeration ; </a> 0
<a> public final class FilterConfigImpl implements FilterConfig { </a> 0
<a> private final ServletConfig sc ; </a> 0
<a> private Filter filter = null ; </a> 0
<a> private String filterName ; </a> 0
<a> public FilterConfigImpl ( ServletConfig sc ) { </a> 0
<a> this . sc = sc ; </a> 0
<a> } </a> 0
<a> public String getInitParameter ( String name ) { </a> 0
<a> return sc . getInitParameter ( name ) ; </a> 0
<a> } </a> 0
<a> public String getFilterName ( ) { </a> 0
<a> return filterName ; </a> 0
<a> } </a> 0
<a> public Enumeration getInitParameterNames ( ) { </a> 0
<a> return sc . getInitParameterNames ( ) ; </a> 0
<a> } </a> 0
<a> public ServletContext getServletContext ( ) { </a> 0
<a> return sc . getServletContext ( ) ; </a> 0
<a> } </a> 0
<a> public Filter getFilter ( ) { </a> 0
<a> return filter ; </a> 0
<a> } </a> 0
<a> public void recycle ( ) { </a> 0
<a> if ( this . filter != null ) { </a> 0
<a> filter . destroy ( ) ; </a> 0
<a> } </a> 0
<a> this . filter = null ; </a> 0
<a> } </a> 0
<a> public void setFilter ( Filter filter ) { </a> 0
<a> this . filter = filter ; </a> 0
<a> } </a> 0
<a> public void setFilterName ( String filterName ) { </a> 0
<a> this . filterName = filterName ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . util ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterConfig ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFuture ; </a> 0
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . concurrent . Future ; </a> 0
<a> public class SimpleBroadcaster extends DefaultBroadcaster { </a> 0
<a> public SimpleBroadcaster ( ) { </a> 0
<a> this ( SimpleBroadcaster . class . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> public SimpleBroadcaster ( String id ) { </a> 0
<a> super ( id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBroadcasterConfig ( BroadcasterConfig bc ) { </a> 0
<a> this . bc = bc ; </a> 0
<a> bc . setExecutorService ( null , false ) . setAsyncWriteService ( null , false ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > Future < T > broadcast ( T msg ) { </a> 1
<a> Object newMsg = filter ( msg ) ; </a> 0
<a> if ( newMsg == null ) return null ; </a> 0
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> f . done ( ) ; </a> 1
<a> push ( new Entry ( newMsg , null , f , msg ) ) ; </a> 0
<a> return f ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > Future < T > broadcast ( T msg , AtmosphereResource < ? , ? > r ) { </a> 0
<a> Object newMsg = filter ( msg ) ; </a> 0
<a> if ( newMsg == null ) return null ; </a> 0
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> f . done ( ) ; </a> 1
<a> push ( new Entry ( newMsg , r , f , msg ) ) ; </a> 1
<a> return f ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > Future < T > broadcast ( T msg , Set < AtmosphereResource < ? , ? > > subset ) { </a> 0
<a> Object newMsg = filter ( msg ) ; </a> 0
<a> if ( newMsg == null ) return null ; </a> 0
<a> BroadcasterFuture < Object > f = new BroadcasterFuture < Object > ( newMsg ) ; </a> 1
<a> f . done ( ) ; </a> 1
<a> push ( new Entry ( newMsg , subset , f , msg ) ) ; </a> 1
<a> return f ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void queueWriteIO ( AtmosphereResource < ? , ? > r , Object finalMsg , Entry entry ) throws InterruptedException { </a> 0
<a> synchronized ( r ) { </a> 1
<a> executeAsyncWrite ( r , finalMsg , entry . future ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . util ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter . BroadcastAction . ACTION ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 0
<a> public class StringFilterAggregator implements BroadcastFilter { </a> 0
<a> private final int maxBufferedString ; </a> 0
<a> private final AtomicReference < StringBuilder > bufferedMessage = new AtomicReference < StringBuilder > ( new StringBuilder ( ) ) ; </a> 0
<a> public StringFilterAggregator ( ) { </a> 0
<a> maxBufferedString = 256 ; </a> 0
<a> } </a> 0
<a> public StringFilterAggregator ( int maxBufferedString ) { </a> 0
<a> this . maxBufferedString = maxBufferedString ; </a> 0
<a> } </a> 0
<a> public BroadcastAction filter ( Object originalMessage , Object message ) { </a> 1
<a> if ( message instanceof String ) { </a> 0
<a> bufferedMessage . get ( ) . append ( message ) ; </a> 0
<a> if ( bufferedMessage . get ( ) . length ( ) < maxBufferedString ) { </a> 0
<a> return new BroadcastAction ( ACTION . ABORT , message ) ; </a> 0
<a> } else { </a> 0
<a> message = bufferedMessage . toString ( ) ; </a> 0
<a> bufferedMessage . get ( ) . delete ( 0 , bufferedMessage . get ( ) . length ( ) ) ; </a> 0
<a> return new BroadcastAction ( ACTION . CONTINUE , message ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> return new BroadcastAction ( message ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . util ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . util . Properties ; </a> 0
<a> import java . util . regex . Matcher ; </a> 0
<a> import java . util . regex . Pattern ; </a> 0
<a> public class Version { </a> 0
<a> private static final Pattern versionPattern = Pattern . compile ( "((\\d+)\\.(\\d+)\\.(\\d+)){1}(.+)?" ) ; </a> 0
<a> private static final String dotedVersion ; </a> 0
<a> private static final int major ; </a> 0
<a> private static final int minor ; </a> 0
<a> private static final int micro ; </a> 0
<a> private static final String version ; </a> 0
<a> public static void main ( String [ ] args ) { </a> 0
<a> System . out . println ( Version . getDotedVersion ( ) ) ; </a> 0
<a> } </a> 0
<a> static { </a> 0
<a> Properties prop = new Properties ( ) ; </a> 0
<a> InputStream s = null ; </a> 0
<a> try { </a> 0
<a> s = Version . class . getResourceAsStream ( "version.properties" ) ; </a> 0
<a> prop . load ( s ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } finally { </a> 0
<a> if ( s != null ) { </a> 0
<a> try { </a> 0
<a> s . close ( ) ; </a> 0
<a> } catch ( IOException ex ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> version = prop . getProperty ( "atmosphere.version" ) ; </a> 0
<a> Matcher matcher = versionPattern . matcher ( version ) ; </a> 0
<a> if ( matcher . matches ( ) ) { </a> 0
<a> dotedVersion = matcher . group ( 1 ) ; </a> 0
<a> major = Integer . parseInt ( matcher . group ( 2 ) ) ; </a> 0
<a> minor = Integer . parseInt ( matcher . group ( 3 ) ) ; </a> 0
<a> micro = Integer . parseInt ( matcher . group ( 4 ) ) ; </a> 0
<a> } else { </a> 0
<a> dotedVersion = "no.version" ; </a> 0
<a> major = - 1 ; </a> 0
<a> minor = - 1 ; </a> 0
<a> micro = - 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static String getRawVersion ( ) { </a> 0
<a> return version ; </a> 0
<a> } </a> 0
<a> public static String getDotedVersion ( ) { </a> 0
<a> return dotedVersion ; </a> 0
<a> } </a> 0
<a> public static int getMajorVersion ( ) { </a> 0
<a> return major ; </a> 0
<a> } </a> 0
<a> public static int getMinorVersion ( ) { </a> 0
<a> return minor ; </a> 0
<a> } </a> 0
<a> public static int getMicroVersion ( ) { </a> 0
<a> return micro ; </a> 0
<a> } </a> 0
<a> public static boolean equalVersion ( int major , int minor ) { </a> 0
<a> return minor == Version . minor && major == Version . major ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . util ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 1
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import org . w3c . dom . Document ; </a> 0
<a> import org . w3c . dom . Element ; </a> 0
<a> import org . w3c . dom . Node ; </a> 0
<a> import org . w3c . dom . NodeList ; </a> 0
<a> import org . xml . sax . SAXException ; </a> 0
<a> import javax . xml . parsers . DocumentBuilderFactory ; </a> 0
<a> import javax . xml . parsers . ParserConfigurationException ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> public class WebDotXmlReader { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( WebDotXmlReader . class ) ; </a> 0
<a> private static final String ATMOSPHERE_SERVLET = AtmosphereServlet . class . getName ( ) ; </a> 0
<a> private final ArrayList < String > mappings = new ArrayList < String > ( ) ; </a> 0
<a> public WebDotXmlReader ( InputStream stream ) { </a> 0
<a> DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; </a> 0
<a> try { </a> 0
<a> parse ( factory . newDocumentBuilder ( ) . parse ( stream ) ) ; </a> 0
<a> } catch ( SAXException e ) { </a> 0
<a> logger . error ( e . getMessage ( ) , e ) ; </a> 0
<a> throw new RuntimeException ( e ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . error ( e . getMessage ( ) , e ) ; </a> 0
<a> throw new RuntimeException ( e ) ; </a> 0
<a> } catch ( ParserConfigurationException e ) { </a> 0
<a> logger . error ( e . getMessage ( ) , e ) ; </a> 0
<a> throw new RuntimeException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void parse ( Document document ) { </a> 0
<a> Element element = document . getDocumentElement ( ) ; </a> 0
<a> NodeList servlets = element . getElementsByTagName ( "servlet" ) ; </a> 0
<a> String atmosphereServletName = null ; </a> 0
<a> for ( int i = 0 ; i < servlets . getLength ( ) ; i ++ ) { </a> 0
<a> Node m = servlets . item ( i ) ; </a> 0
<a> NodeList list = m . getChildNodes ( ) ; </a> 0
<a> for ( int j = 0 ; j < list . getLength ( ) ; j ++ ) { </a> 0
<a> Node n = list . item ( j ) ; </a> 0
<a> if ( n . getNodeName ( ) . equals ( "servlet-name" ) ) { </a> 0
<a> atmosphereServletName = n . getFirstChild ( ) . getNodeValue ( ) ; </a> 0
<a> } </a> 0
<a> if ( n . getNodeName ( ) . equals ( "servlet-class" ) ) { </a> 0
<a> if ( n . getFirstChild ( ) . getNodeValue ( ) . equals ( ATMOSPHERE_SERVLET ) ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> NodeList servletMappings = element . getElementsByTagName ( "servlet-mapping" ) ; </a> 0
<a> for ( int i = 0 ; i < servletMappings . getLength ( ) ; i ++ ) { </a> 0
<a> Node m = servletMappings . item ( i ) ; </a> 0
<a> NodeList list = m . getChildNodes ( ) ; </a> 0
<a> String urlMapping = null ; </a> 0
<a> String servletName = null ; </a> 0
<a> for ( int j = 0 ; j < list . getLength ( ) ; j ++ ) { </a> 0
<a> Node n = list . item ( j ) ; </a> 0
<a> if ( n . getNodeName ( ) . equals ( "servlet-name" ) ) { </a> 0
<a> servletName = n . getFirstChild ( ) . getNodeValue ( ) ; </a> 0
<a> if ( ! servletName . equals ( atmosphereServletName ) ) { </a> 0
<a> servletName = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( n . getNodeName ( ) . equals ( "url-pattern" ) ) { </a> 0
<a> urlMapping = n . getFirstChild ( ) . getNodeValue ( ) ; </a> 0
<a> } </a> 0
<a> if ( servletName != null && urlMapping != null ) { </a> 0
<a> mappings . add ( urlMapping ) ; </a> 0
<a> servletName = null ; </a> 0
<a> urlMapping = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public ArrayList < String > getMappings ( ) { </a> 0
<a> return mappings ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . websocket ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . cpr . FrameworkConfig ; </a> 0
<a> import org . atmosphere . websocket . container . Jetty8WebSocket ; </a> 0
<a> import org . atmosphere . websocket . container . JettyWebSocket ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletRequestWrapper ; </a> 0
<a> import java . io . UnsupportedEncodingException ; </a> 0
<a> import static org . atmosphere . websocket . WebSocketEventListener . WebSocketEvent . TYPE . * ; </a> 1
<a> public class JettyWebSocketHandler implements org . eclipse . jetty . websocket . WebSocket , org . eclipse . jetty . websocket . WebSocket . OnFrame , org . eclipse . jetty . websocket . WebSocket . OnBinaryMessage , org . eclipse . jetty . websocket . WebSocket . OnTextMessage , org . eclipse . jetty . websocket . WebSocket . OnControl { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( JettyWebSocketHandler . class ) ; </a> 0
<a> private WebSocketProcessor webSocketProcessor ; </a> 0
<a> private final HttpServletRequest request ; </a> 1
<a> private final AtmosphereServlet atmosphereServlet ; </a> 0
<a> private final String webSocketProcessorClassName ; </a> 0
<a> public JettyWebSocketHandler ( HttpServletRequest request , AtmosphereServlet atmosphereServlet , final String webSocketProcessorClassName ) { </a> 0
<a> this . request = new JettyRequestFix ( request , request . getServletPath ( ) , request . getContextPath ( ) , request . getPathInfo ( ) , request . getRequestURI ( ) ) ; </a> 1
<a> this . atmosphereServlet = atmosphereServlet ; </a> 0
<a> this . webSocketProcessorClassName = webSocketProcessorClassName ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onConnect ( org . eclipse . jetty . websocket . WebSocket . Outbound outbound ) { </a> 1
<a> logger . debug ( "WebSocket.onConnect (outbound)" ) ; </a> 1
<a> try { </a> 1
<a> webSocketProcessor = ( WebSocketProcessor ) JettyWebSocketHandler . class . getClassLoader ( ) </a> 0
<a> . loadClass ( webSocketProcessorClassName ) </a> 0
<a> . getDeclaredConstructor ( new Class [ ] { AtmosphereServlet . class , WebSocket . class } ) </a> 0
<a> . newInstance ( new Object [ ] { atmosphereServlet , new JettyWebSocket ( outbound ) } ) ; </a> 0
<a> webSocketProcessor . dispatch ( request ) ; </a> 0
<a> } catch ( Exception e ) { </a> 1
<a> logger . warn ( "failed to connect to web socket" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onMessage ( byte frame , String data ) { </a> 1
<a> logger . debug ( "WebSocket.onMessage (frame/string)" ) ; </a> 0
<a> webSocketProcessor . parseMessage ( data ) ; </a> 0
<a> webSocketProcessor . notifyListener ( new WebSocketEventListener . WebSocketEvent ( data , MESSAGE , webSocketProcessor . webSocketSupport ( ) ) ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void onMessage ( byte frame , byte [ ] data , int offset , int length ) { </a> 1
<a> logger . debug ( "WebSocket.onMessage (frame)" ) ; </a> 0
<a> webSocketProcessor . parseMessage ( new String ( data , offset , length ) ) ; </a> 0
<a> try { </a> 1
<a> webSocketProcessor . notifyListener ( new WebSocketEventListener . WebSocketEvent ( new String ( data , offset , length , "UTF-8" ) , MESSAGE , webSocketProcessor . webSocketSupport ( ) ) ) ; </a> 0
<a> } catch ( UnsupportedEncodingException e ) { </a> 1
<a> logger . warn ( "UnsupportedEncodingException" , e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void onFragment ( boolean more , byte opcode , byte [ ] data , int offset , int length ) { </a> 1
<a> logger . debug ( "WebSocket.onFragment" ) ; </a> 0
<a> webSocketProcessor . parseMessage ( new String ( data , offset , length ) ) ; </a> 0
<a> try { </a> 1
<a> webSocketProcessor . notifyListener ( new WebSocketEventListener . WebSocketEvent ( new String ( data , offset , length , "UTF-8" ) , MESSAGE , webSocketProcessor . webSocketSupport ( ) ) ) ; </a> 0
<a> } catch ( UnsupportedEncodingException e ) { </a> 1
<a> logger . warn ( "UnsupportedEncodingException" , e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void onDisconnect ( ) { </a> 1
<a> logger . debug ( "WebSocket.onDisconnect" ) ; </a> 0
<a> webSocketProcessor . close ( ) ; </a> 0
<a> webSocketProcessor . notifyListener ( new WebSocketEventListener . WebSocketEvent ( "" , DISCONNECT , webSocketProcessor . webSocketSupport ( ) ) ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void onMessage ( byte [ ] data , int offset , int length ) { </a> 0
<a> logger . debug ( "WebSocket.onMessage (bytes)" ) ; </a> 0
<a> webSocketProcessor . parseMessage ( data , offset , length ) ; </a> 0
<a> try { </a> 1
<a> webSocketProcessor . notifyListener ( new WebSocketEventListener . WebSocketEvent ( new String ( data , offset , length , "UTF-8" ) , MESSAGE , webSocketProcessor . webSocketSupport ( ) ) ) ; </a> 0
<a> } catch ( UnsupportedEncodingException e ) { </a> 1
<a> logger . warn ( "UnsupportedEncodingException" , e ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean onControl ( byte controlCode , byte [ ] data , int offset , int length ) { </a> 0
<a> logger . debug ( "WebSocket.onControl." ) ; </a> 0
<a> webSocketProcessor . parseMessage ( data , offset , length ) ; </a> 0
<a> try { </a> 0
<a> webSocketProcessor . notifyListener ( new WebSocketEventListener . WebSocketEvent ( new String ( data , offset , length , "UTF-8" ) , CONTROL , webSocketProcessor . webSocketSupport ( ) ) ) ; </a> 0
<a> } catch ( UnsupportedEncodingException e ) { </a> 0
<a> logger . warn ( "UnsupportedEncodingException" , e ) ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean onFrame ( byte flags , byte opcode , byte [ ] data , int offset , int length ) { </a> 0
<a> logger . debug ( "WebSocket.onFrame." ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onHandshake ( org . eclipse . jetty . websocket . WebSocket . FrameConnection connection ) { </a> 0
<a> logger . debug ( "WebSocket.onHandshake" ) ; </a> 0
<a> try { </a> 0
<a> webSocketProcessor = ( WebSocketProcessor ) JettyWebSocketHandler . class . getClassLoader ( ) </a> 0
<a> . loadClass ( webSocketProcessorClassName ) </a> 0
<a> . getDeclaredConstructor ( new Class [ ] { AtmosphereServlet . class , WebSocket . class } ) </a> 0
<a> . newInstance ( new Object [ ] { atmosphereServlet , new Jetty8WebSocket ( connection ) } ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . warn ( "failed to connect to web socket" , e ) ; </a> 0
<a> } </a> 0
<a> webSocketProcessor . notifyListener ( new WebSocketEventListener . WebSocketEvent ( "" , HANDSHAKE , webSocketProcessor . webSocketSupport ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onMessage ( String data ) { </a> 0
<a> logger . debug ( "WebSocket.onMessage" ) ; </a> 0
<a> webSocketProcessor . parseMessage ( data ) ; </a> 0
<a> webSocketProcessor . notifyListener ( new WebSocketEventListener . WebSocketEvent ( data , MESSAGE , webSocketProcessor . webSocketSupport ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onOpen ( org . eclipse . jetty . websocket . WebSocket . Connection connection ) { </a> 0
<a> logger . debug ( "WebSocket.onOpen." ) ; </a> 0
<a> try { </a> 0
<a> webSocketProcessor = ( WebSocketProcessor ) JettyWebSocketHandler . class . getClassLoader ( ) </a> 0
<a> . loadClass ( webSocketProcessorClassName ) </a> 0
<a> . getDeclaredConstructor ( new Class [ ] { AtmosphereServlet . class , WebSocket . class } ) </a> 0
<a> . newInstance ( new Object [ ] { atmosphereServlet , new Jetty8WebSocket ( connection ) } ) ; </a> 0
<a> webSocketProcessor . dispatch ( request ) ; </a> 0
<a> webSocketProcessor . notifyListener ( new WebSocketEventListener . WebSocketEvent ( "" , CONNECT , webSocketProcessor . webSocketSupport ( ) ) ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . warn ( "failed to connect to web socket" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onClose ( int closeCode , String message ) { </a> 0
<a> logger . debug ( "WebSocket.OnClose." ) ; </a> 0
<a> webSocketProcessor . notifyListener ( new WebSocketEventListener . WebSocketEvent ( "" , CLOSE , webSocketProcessor . webSocketSupport ( ) ) ) ; </a> 0
<a> AtmosphereResource < ? , ? > r = ( AtmosphereResource < ? , ? > ) request . getAttribute ( FrameworkConfig . ATMOSPHERE_RESOURCE ) ; </a> 0
<a> if ( r != null ) { </a> 0
<a> r . getBroadcaster ( ) . removeAtmosphereResource ( r ) ; </a> 0
<a> } </a> 0
<a> webSocketProcessor . close ( ) ; </a> 0
<a> } </a> 0
<a> private static class JettyRequestFix extends HttpServletRequestWrapper { </a> 1
<a> private final String contextPath ; </a> 1
<a> private final String servletPath ; </a> 1
<a> private final String pathInfo ; </a> 1
<a> private final String requestUri ; </a> 1
<a> public JettyRequestFix ( HttpServletRequest request , String servletPath , String contextPath , String pathInfo , String requestUri ) { </a> 1
<a> super ( request ) ; </a> 1
<a> this . servletPath = servletPath ; </a> 1
<a> this . contextPath = contextPath ; </a> 1
<a> this . pathInfo = pathInfo ; </a> 1
<a> this . requestUri = requestUri ; </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> public String getContextPath ( ) { </a> 1
<a> return contextPath ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getServletPath ( ) { </a> 1
<a> return servletPath ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getPathInfo ( ) { </a> 1
<a> return pathInfo ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getRequestURI ( ) { </a> 1
<a> return requestUri ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . websocket ; </a> 0
<a> import org . atmosphere . cpr . CometSupport ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> public interface WebSocket { </a> 0
<a> public final static String WEBSOCKET_INITIATED = WebSocket . class . getName ( ) + ".initiated" ; </a> 0
<a> public final static String WEBSOCKET_SUSPEND = WebSocket . class . getName ( ) + ".suspend" ; </a> 0
<a> public final static String WEBSOCKET_RESUME = WebSocket . class . getName ( ) + ".resume" ; </a> 0
<a> void writeError ( int errorCode , String message ) throws IOException ; </a> 0
<a> void redirect ( String location ) throws IOException ; </a> 0
<a> void write ( byte frame , String data ) throws IOException ; </a> 0
<a> void write ( byte frame , byte [ ] data ) throws IOException ; </a> 0
<a> void write ( byte frame , byte [ ] data , int offset , int length ) throws IOException ; </a> 0
<a> void close ( ) throws IOException ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . websocket ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> public interface WebSocketEventListener extends AtmosphereResourceEventListener { </a> 0
<a> void onHandshake ( WebSocketEvent event ) ; </a> 0
<a> void onMessage ( WebSocketEvent event ) ; </a> 0
<a> void onClose ( WebSocketEvent event ) ; </a> 0
<a> void onControl ( WebSocketEvent event ) ; </a> 0
<a> void onDisconnect ( WebSocketEvent event ) ; </a> 0
<a> void onConnect ( WebSocketEvent event ) ; </a> 0
<a> public class WebSocketEvent { </a> 1
<a> public enum TYPE { CONNECT , HANDSHAKE , CLOSE , MESSAGE , CONTROL , DISCONNECT } </a> 1
<a> private final String message ; </a> 1
<a> private final TYPE type ; </a> 0
<a> private final WebSocket webSocket ; </a> 0
<a> public WebSocketEvent ( String message , TYPE type , WebSocket webSocket ) { </a> 1
<a> this . message = message ; </a> 0
<a> this . type = type ; </a> 0
<a> this . webSocket = webSocket ; </a> 0
<a> } </a> 0
<a> public String message ( ) { </a> 1
<a> return message ; </a> 0
<a> } </a> 0
<a> public WebSocket webSocket ( ) { </a> 0
<a> return webSocket ; </a> 0
<a> } </a> 0
<a> public TYPE type ( ) { </a> 0
<a> return type ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return "WebSocketEvent{" + </a> 0
<a> "message='" + message + '\'' + </a> 0
<a> ", type=" + type + </a> 0
<a> ", webSocket=" + webSocket + </a> 0
<a> '}' ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . websocket ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public class WebSocketEventListenerBase implements WebSocketEventListener { </a> 0
<a> private final static Logger logger = LoggerFactory . getLogger ( WebSocketEventListenerBase . class ) ; </a> 0
<a> @ Override </a> 0
<a> public void onHandshake ( WebSocketEvent event ) { </a> 0
<a> logger . trace ( "" , event ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onMessage ( WebSocketEvent event ) { </a> 0
<a> logger . trace ( "" , event ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onClose ( WebSocketEvent event ) { </a> 0
<a> logger . trace ( "" , event ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onControl ( WebSocketEvent event ) { </a> 0
<a> logger . trace ( "" , event ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDisconnect ( WebSocketEvent event ) { </a> 0
<a> logger . trace ( "" , event ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onConnect ( WebSocketEvent event ) { </a> 0
<a> logger . trace ( "" , event ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onSuspend ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . trace ( "" , event ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . trace ( "" , event ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . trace ( "" , event ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . trace ( "" , event ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . trace ( "" , event ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . websocket ; </a> 0
<a> import javax . servlet . ServletOutputStream ; </a> 0
<a> import javax . servlet . ServletResponse ; </a> 0
<a> import javax . servlet . http . Cookie ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . servlet . http . HttpServletResponseWrapper ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> import java . io . PrintWriter ; </a> 0
<a> import java . util . ArrayList ; </a> 1
<a> import java . util . Collection ; </a> 0
<a> import java . util . Collections ; </a> 1
<a> import java . util . HashMap ; </a> 1
<a> import java . util . Locale ; </a> 0
<a> public class WebSocketHttpServletResponse < A extends WebSocket > extends HttpServletResponseWrapper { </a> 0
<a> private final ArrayList < Cookie > cookies = new ArrayList < Cookie > ( ) ; </a> 0
<a> private final HashMap < String , String > headers = new HashMap < String , String > ( ) ; </a> 0
<a> private final A webSocketSupport ; </a> 0
<a> private int status = 200 ; </a> 1
<a> private String statusMessage = "" ; </a> 0
<a> private String charSet = "UTF-8" ; </a> 1
<a> private byte frame ; </a> 0
<a> private long contentLength = - 1 ; </a> 1
<a> private String contentType = "txt/html" ; </a> 0
<a> private boolean isCommited = false ; </a> 1
<a> private Locale locale ; </a> 1
<a> public WebSocketHttpServletResponse ( A webSocketSupport ) { </a> 0
<a> super ( new HttpServletResponse ( ) { </a> 0
<a> public void addCookie ( Cookie cookie ) { </a> 0
<a> } </a> 0
<a> public boolean containsHeader ( String name ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> public String encodeURL ( String url ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public String encodeRedirectURL ( String url ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public String encodeUrl ( String url ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public String encodeRedirectUrl ( String url ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public void sendError ( int sc , String msg ) throws IOException { </a> 0
<a> } </a> 0
<a> public void sendError ( int sc ) throws IOException { </a> 0
<a> } </a> 0
<a> public void sendRedirect ( String location ) throws IOException { </a> 0
<a> } </a> 0
<a> public void setDateHeader ( String name , long date ) { </a> 0
<a> } </a> 0
<a> public void addDateHeader ( String name , long date ) { </a> 0
<a> } </a> 0
<a> public void setHeader ( String name , String value ) { </a> 0
<a> } </a> 0
<a> public void addHeader ( String name , String value ) { </a> 0
<a> } </a> 0
<a> public void setIntHeader ( String name , int value ) { </a> 0
<a> } </a> 0
<a> public void addIntHeader ( String name , int value ) { </a> 0
<a> } </a> 0
<a> public void setStatus ( int sc ) { </a> 0
<a> } </a> 0
<a> public void setStatus ( int sc , String sm ) { </a> 0
<a> } </a> 0
<a> public int getStatus ( ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> public String getHeader ( String name ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public Collection < String > getHeaders ( String name ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public Collection < String > getHeaderNames ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public String getCharacterEncoding ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public String getContentType ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public ServletOutputStream getOutputStream ( ) throws IOException { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public PrintWriter getWriter ( ) throws IOException { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public void setCharacterEncoding ( String charset ) { </a> 0
<a> } </a> 0
<a> public void setContentLength ( int len ) { </a> 0
<a> } </a> 0
<a> public void setContentType ( String type ) { </a> 0
<a> } </a> 0
<a> public void setBufferSize ( int size ) { </a> 0
<a> } </a> 0
<a> public int getBufferSize ( ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> public void flushBuffer ( ) throws IOException { </a> 0
<a> } </a> 0
<a> public void resetBuffer ( ) { </a> 0
<a> } </a> 0
<a> public boolean isCommitted ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> public void reset ( ) { </a> 0
<a> } </a> 0
<a> public void setLocale ( Locale loc ) { </a> 0
<a> } </a> 1
<a> public Locale getLocale ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> this . webSocketSupport = webSocketSupport ; </a> 0
<a> } </a> 1
<a> public void addCookie ( Cookie cookie ) { </a> 1
<a> cookies . add ( cookie ) ; </a> 1
<a> } </a> 1
<a> public boolean containsHeader ( String name ) { </a> 1
<a> return headers . get ( name ) == null ? false : true ; </a> 0
<a> } </a> 1
<a> public String encodeURL ( String url ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> public String encodeRedirectURL ( String url ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> public String encodeUrl ( String url ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> public String encodeRedirectUrl ( String url ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> public void sendError ( int sc , String msg ) throws IOException { </a> 1
<a> webSocketSupport . writeError ( sc , msg ) ; </a> 0
<a> } </a> 1
<a> public void sendError ( int sc ) throws IOException { </a> 1
<a> webSocketSupport . writeError ( sc , "" ) ; </a> 0
<a> } </a> 1
<a> public void sendRedirect ( String location ) throws IOException { </a> 1
<a> webSocketSupport . redirect ( location ) ; </a> 0
<a> } </a> 1
<a> public void setDateHeader ( String name , long date ) { </a> 1
<a> headers . put ( name , String . valueOf ( date ) ) ; </a> 1
<a> } </a> 1
<a> public void addDateHeader ( String name , long date ) { </a> 1
<a> headers . put ( name , String . valueOf ( date ) ) ; </a> 1
<a> } </a> 1
<a> public void setHeader ( String name , String value ) { </a> 1
<a> headers . put ( name , value ) ; </a> 1
<a> } </a> 1
<a> public void addHeader ( String name , String value ) { </a> 1
<a> headers . put ( name , value ) ; </a> 1
<a> } </a> 1
<a> public void setIntHeader ( String name , int value ) { </a> 1
<a> headers . put ( name , String . valueOf ( value ) ) ; </a> 1
<a> } </a> 1
<a> public void addIntHeader ( String name , int value ) { </a> 1
<a> headers . put ( name , String . valueOf ( value ) ) ; </a> 1
<a> } </a> 1
<a> public void setStatus ( int status ) { </a> 1
<a> this . status = status ; </a> 1
<a> } </a> 1
<a> public void setStatus ( int status , String statusMessage ) { </a> 1
<a> this . statusMessage = statusMessage ; </a> 1
<a> this . status = status ; </a> 1
<a> } </a> 1
<a> public int getStatus ( ) { </a> 1
<a> return status ; </a> 1
<a> } </a> 1
<a> public String getHeader ( String name ) { </a> 1
<a> return headers . get ( name ) ; </a> 1
<a> } </a> 1
<a> public Collection < String > getHeaders ( String name ) { </a> 1
<a> ArrayList < String > s = new ArrayList < String > ( ) ; </a> 1
<a> s . add ( headers . get ( name ) ) ; </a> 1
<a> return Collections . unmodifiableList ( s ) ; </a> 1
<a> } </a> 1
<a> public Collection < String > getHeaderNames ( ) { </a> 1
<a> return Collections . unmodifiableSet ( headers . keySet ( ) ) ; </a> 1
<a> } </a> 1
<a> public void setCharacterEncoding ( String charset ) { </a> 0
<a> this . charSet = charSet ; </a> 1
<a> } </a> 1
<a> public String getCharacterEncoding ( ) { </a> 1
<a> return charSet ; </a> 1
<a> } </a> 1
<a> public ServletOutputStream getOutputStream ( ) throws IOException { </a> 1
<a> return new ServletOutputStream ( ) { </a> 1
<a> public void write ( int i ) throws java . io . IOException { </a> 1
<a> webSocketSupport . write ( frame , new byte [ ] { ( byte ) i } ) ; </a> 0
<a> } </a> 1
<a> public void write ( byte [ ] bytes ) throws java . io . IOException { </a> 1
<a> webSocketSupport . write ( frame , bytes ) ; </a> 0
<a> } </a> 1
<a> public void write ( byte [ ] bytes , int start , int offset ) throws java . io . IOException { </a> 1
<a> webSocketSupport . write ( frame , bytes , start , offset ) ; </a> 0
<a> } </a> 1
<a> } ; </a> 1
<a> } </a> 1
<a> public PrintWriter getWriter ( ) throws IOException { </a> 1
<a> return new PrintWriter ( getOutputStream ( ) ) { </a> 1
<a> public void write ( char [ ] chars , int offset , int lenght ) { </a> 1
<a> try { </a> 0
<a> webSocketSupport . write ( frame , new String ( chars , offset , lenght ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> throw new RuntimeException ( e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public void write ( char [ ] chars ) { </a> 1
<a> try { </a> 1
<a> webSocketSupport . write ( frame , new String ( chars ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> throw new RuntimeException ( e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public void write ( String s , int offset , int lenght ) { </a> 1
<a> try { </a> 1
<a> webSocketSupport . write ( frame , new String ( s . substring ( offset , lenght ) ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> throw new RuntimeException ( e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public void write ( java . lang . String s ) { </a> 0
<a> try { </a> 1
<a> webSocketSupport . write ( frame , new String ( s ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> throw new RuntimeException ( e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> } </a> 1
<a> public void setContentLength ( int len ) { </a> 1
<a> contentLength = len ; </a> 1
<a> } </a> 1
<a> public void setContentType ( String contentType ) { </a> 1
<a> this . contentType = contentType ; </a> 1
<a> } </a> 1
<a> public String getContentType ( ) { </a> 1
<a> return contentType ; </a> 1
<a> } </a> 1
<a> public void setBufferSize ( int size ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> public int getBufferSize ( ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> public void flushBuffer ( ) throws IOException { </a> 1
<a> } </a> 1
<a> public boolean isCommitted ( ) { </a> 1
<a> return isCommited ; </a> 1
<a> } </a> 1
<a> public void reset ( ) { </a> 1
<a> } </a> 1
<a> public void resetBuffer ( ) { </a> 1
<a> } </a> 1
<a> public void setLocale ( Locale locale ) { </a> 1
<a> this . locale = locale ; </a> 1
<a> } </a> 1
<a> public Locale getLocale ( ) { </a> 1
<a> return locale ; </a> 1
<a> } </a> 1
<a> public boolean isWrapperFor ( ServletResponse wrapped ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 1
<a> public boolean isWrapperFor ( Class wrappedType ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> public A getWebSocketSupport ( ) { </a> 0
<a> return webSocketSupport ; </a> 0
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . websocket ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereRequest ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceEventImpl ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . cpr . FrameworkConfig ; </a> 1
<a> import org . atmosphere . cpr . HeaderConfig ; </a> 1
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . Serializable ; </a> 1
<a> import java . util . Enumeration ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 1
<a> public abstract class WebSocketProcessor implements Serializable { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( WebSocketProcessor . class ) ; </a> 1
<a> private final AtmosphereServlet atmosphereServlet ; </a> 0
<a> private final WebSocket webSocket ; </a> 1
<a> private final AtomicBoolean loggedMsg = new AtomicBoolean ( false ) ; </a> 1
<a> private AtmosphereResource < HttpServletRequest , HttpServletResponse > resource ; </a> 0
<a> private AtmosphereHandler handler ; </a> 1
<a> public WebSocketProcessor ( AtmosphereServlet atmosphereServlet , WebSocket webSocket ) { </a> 0
<a> this . webSocket = webSocket ; </a> 1
<a> this . atmosphereServlet = atmosphereServlet ; </a> 0
<a> } </a> 1
<a> public final void dispatch ( final HttpServletRequest request ) throws IOException { </a> 0
<a> if ( ! loggedMsg . getAndSet ( true ) ) { </a> 1
<a> logger . info ( "Atmosphere detected WebSocket: {}" , webSocket . getClass ( ) . getName ( ) ) ; </a> 0
<a> } </a> 1
<a> WebSocketHttpServletResponse wsr = new WebSocketHttpServletResponse < WebSocket > ( webSocket ) ; </a> 0
<a> AtmosphereRequest r = new AtmosphereRequest . Builder ( ) </a> 0
<a> . request ( request ) </a> 0
<a> . headers ( configureHeader ( request ) ) </a> 0
<a> . build ( ) ; </a> 0
<a> request . setAttribute ( WebSocket . WEBSOCKET_SUSPEND , true ) ; </a> 1
<a> dispatch ( r , wsr ) ; </a> 0
<a> resource = ( AtmosphereResource ) request . getAttribute ( FrameworkConfig . ATMOSPHERE_RESOURCE ) ; </a> 1
<a> handler = ( AtmosphereHandler ) request . getAttribute ( FrameworkConfig . ATMOSPHERE_HANDLER ) ; </a> 1
<a> if ( resource == null || ! resource . getAtmosphereResourceEvent ( ) . isSuspended ( ) ) { </a> 0
<a> logger . error ( "No AtmosphereResource has been suspended. The WebSocket will be closed." ) ; </a> 0
<a> webSocket . close ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> protected final void dispatch ( final HttpServletRequest request , final HttpServletResponse response ) { </a> 0
<a> try { </a> 1
<a> atmosphereServlet . doCometSupport ( request , response ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . info ( "failed invoking atmosphere servlet doCometSupport()" , e ) ; </a> 0
<a> } catch ( ServletException e ) { </a> 0
<a> logger . info ( "failed invoking atmosphere servlet doCometSupport()" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public AtmosphereResource resource ( ) { </a> 1
<a> return resource ; </a> 0
<a> } </a> 1
<a> public HttpServletRequest request ( ) { </a> 0
<a> return resource . getRequest ( ) ; </a> 1
<a> } </a> 1
<a> public WebSocket webSocketSupport ( ) { </a> 0
<a> return webSocket ; </a> 1
<a> } </a> 1
<a> abstract public void parseMessage ( String data ) ; </a> 0
<a> abstract public void parseMessage ( byte [ ] data , int offset , int length ) ; </a> 0
<a> public void close ( ) { </a> 0
<a> try { </a> 1
<a> if ( handler != null && resource != null ) { </a> 1
<a> handler . onStateChange ( new AtmosphereResourceEventImpl ( ( AtmosphereResourceImpl ) resource , false , true ) ) ; </a> 1
<a> } </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> if ( AtmosphereResourceImpl . class . isAssignableFrom ( resource . getClass ( ) ) ) { </a> 0
<a> AtmosphereResourceImpl . class . cast ( resource ) . onThrowable ( e ) ; </a> 0
<a> } </a> 0
<a> logger . info ( "Failed invoking atmosphere handler onStateChange()" , e ) ; </a> 0
<a> } </a> 0
<a> if ( resource != null ) { </a> 1
<a> resource . getBroadcaster ( ) . removeAtmosphereResource ( resource ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public String toString ( ) { </a> 1
<a> return "WebSocketProcessor{ handler=" + handler + ", resource=" + resource + ", webSocket=" + </a> 1
<a> webSocket + " }" ; </a> 0
<a> } </a> 1
<a> public void notifyListener ( WebSocketEventListener . WebSocketEvent event ) { </a> 1
<a> if ( resource == null ) return ; </a> 1
<a> AtmosphereResourceImpl r = AtmosphereResourceImpl . class . cast ( resource ) ; </a> 1
<a> for ( AtmosphereResourceEventListener l : r . atmosphereResourceEventListener ( ) ) { </a> 1
<a> if ( WebSocketEventListener . class . isAssignableFrom ( l . getClass ( ) ) ) { </a> 1
<a> switch ( event . type ( ) ) { </a> 1
<a> case CONNECT : </a> 1
<a> WebSocketEventListener . class . cast ( l ) . onConnect ( event ) ; </a> 1
<a> break ; </a> 1
<a> case DISCONNECT : </a> 1
<a> WebSocketEventListener . class . cast ( l ) . onDisconnect ( event ) ; </a> 1
<a> break ; </a> 1
<a> case CONTROL : </a> 1
<a> WebSocketEventListener . class . cast ( l ) . onControl ( event ) ; </a> 1
<a> break ; </a> 1
<a> case MESSAGE : </a> 1
<a> WebSocketEventListener . class . cast ( l ) . onMessage ( event ) ; </a> 1
<a> break ; </a> 1
<a> case HANDSHAKE : </a> 1
<a> WebSocketEventListener . class . cast ( l ) . onHandshake ( event ) ; </a> 1
<a> break ; </a> 1
<a> case CLOSE : </a> 1
<a> WebSocketEventListener . class . cast ( l ) . onClose ( event ) ; </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> protected Map < String , String > configureHeader ( HttpServletRequest request ) { </a> 0
<a> Map < String , String > headers = new HashMap < String , String > ( ) ; </a> 0
<a> Enumeration < String > e = request . getParameterNames ( ) ; </a> 1
<a> String s ; </a> 1
<a> while ( e . hasMoreElements ( ) ) { </a> 1
<a> s = e . nextElement ( ) ; </a> 1
<a> headers . put ( s , request . getParameter ( s ) ) ; </a> 0
<a> } </a> 0
<a> headers . put ( HeaderConfig . X_ATMOSPHERE_TRANSPORT , HeaderConfig . WEBSOCKET_TRANSPORT ) ; </a> 0
<a> return headers ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . websocket . container ; </a> 0
<a> import org . atmosphere . websocket . WebSocket ; </a> 0
<a> import org . eclipse . jetty . websocket . WebSocket . Connection ; </a> 0
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> public class Jetty8WebSocket implements WebSocket { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( Jetty8WebSocket . class ) ; </a> 1
<a> private final Connection connection ; </a> 0
<a> public Jetty8WebSocket ( Connection connection ) { </a> 1
<a> this . connection = connection ; </a> 0
<a> } </a> 0
<a> public void writeError ( int errorCode , String message ) throws IOException { </a> 1
<a> } </a> 0
<a> public void redirect ( String location ) throws IOException { </a> 1
<a> } </a> 0
<a> public void write ( byte frame , String data ) throws IOException { </a> 0
<a> if ( ! connection . isOpen ( ) ) throw new IOException ( "Connection closed" ) ; </a> 0
<a> logger . debug ( "WebSocket.write()" ) ; </a> 0
<a> connection . sendMessage ( data ) ; </a> 1
<a> } </a> 1
<a> public void write ( byte frame , byte [ ] data ) throws IOException { </a> 0
<a> if ( ! connection . isOpen ( ) ) throw new IOException ( "Connection closed" ) ; </a> 0
<a> logger . debug ( "WebSocket.write()" ) ; </a> 0
<a> connection . sendMessage ( data , 0 , data . length ) ; </a> 1
<a> } </a> 1
<a> public void write ( byte frame , byte [ ] data , int offset , int length ) throws IOException { </a> 0
<a> if ( ! connection . isOpen ( ) ) throw new IOException ( "Connection closed" ) ; </a> 0
<a> logger . debug ( "WebSocket.write()" ) ; </a> 0
<a> connection . sendMessage ( new String ( data , offset , length , "UTF-8" ) ) ; </a> 1
<a> } </a> 1
<a> public void close ( ) throws IOException { </a> 1
<a> logger . debug ( "WebSocket.close()" ) ; </a> 0
<a> connection . disconnect ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . websocket . container ; </a> 0
<a> import org . atmosphere . websocket . WebSocket ; </a> 0
<a> import org . eclipse . jetty . websocket . WebSocket . Outbound ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> public class JettyWebSocket implements WebSocket { </a> 0
<a> private final Outbound outbound ; </a> 0
<a> private AtomicBoolean webSocketLatencyCheck = new AtomicBoolean ( false ) ; </a> 0
<a> public JettyWebSocket ( Outbound outbound ) { </a> 1
<a> this . outbound = outbound ; </a> 0
<a> } </a> 0
<a> public void writeError ( int errorCode , String message ) throws IOException { </a> 1
<a> } </a> 0
<a> public void redirect ( String location ) throws IOException { </a> 1
<a> } </a> 0
<a> public void write ( byte frame , String data ) throws IOException { </a> 0
<a> if ( ! outbound . isOpen ( ) ) throw new IOException ( "Connection closed" ) ; </a> 0
<a> outbound . sendMessage ( frame , data ) ; </a> 1
<a> } </a> 1
<a> public void write ( byte frame , byte [ ] data ) throws IOException { </a> 0
<a> if ( ! outbound . isOpen ( ) ) throw new IOException ( "Connection closed" ) ; </a> 0
<a> outbound . sendMessage ( frame , data , 0 , data . length ) ; </a> 1
<a> } </a> 0
<a> public void write ( byte frame , byte [ ] data , int offset , int length ) throws IOException { </a> 0
<a> if ( ! outbound . isOpen ( ) ) throw new IOException ( "Connection closed" ) ; </a> 0
<a> outbound . sendMessage ( frame , data , offset , length ) ; </a> 1
<a> } </a> 1
<a> public void close ( ) throws IOException { </a> 1
<a> outbound . disconnect ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . websocket . protocol ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . websocket . WebSocketProcessor ; </a> 0
<a> import org . atmosphere . websocket . WebSocket ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> public class EchoProtocol extends WebSocketProcessor { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( AtmosphereServlet . class ) ; </a> 0
<a> public EchoProtocol ( AtmosphereServlet atmosphereServlet , WebSocket webSocket ) { </a> 0
<a> super ( atmosphereServlet , webSocket ) ; </a> 0
<a> } </a> 0
<a> public void parseMessage ( String data ) { </a> 0
<a> logger . trace ( "broadcast String" ) ; </a> 0
<a> resource ( ) . getBroadcaster ( ) . broadcast ( data ) ; </a> 0
<a> } </a> 0
<a> public void parseMessage ( byte [ ] data , int offset , int length ) { </a> 0
<a> logger . trace ( "broadcast byte" ) ; </a> 0
<a> byte [ ] b = new byte [ length ] ; </a> 0
<a> System . arraycopy ( data , offset , b , 0 , length ) ; </a> 0
<a> resource ( ) . getBroadcaster ( ) . broadcast ( b ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . websocket . protocol ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereRequest ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . websocket . WebSocket ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereRequest ; </a> 0
<a> import org . atmosphere . websocket . WebSocketHttpServletResponse ; </a> 0
<a> import org . atmosphere . websocket . WebSocketProcessor ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> public class SimpleHttpProtocol extends WebSocketProcessor implements Serializable { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( AtmosphereServlet . class ) ; </a> 0
<a> private final String contentType ; </a> 0
<a> private final String methodType ; </a> 0
<a> private final String delimiter ; </a> 0
<a> public SimpleHttpProtocol ( AtmosphereServlet atmosphereServlet , WebSocket webSocket ) { </a> 0
<a> super ( atmosphereServlet , webSocket ) ; </a> 0
<a> String contentType = atmosphereServlet . getAtmosphereConfig ( ) . getInitParameter ( ApplicationConfig . WEBSOCKET_CONTENT_TYPE ) ; </a> 0
<a> if ( contentType == null ) { </a> 0
<a> contentType = "text/html" ; </a> 1
<a> } </a> 0
<a> this . contentType = contentType ; </a> 0
<a> String methodType = atmosphereServlet . getAtmosphereConfig ( ) . getInitParameter ( ApplicationConfig . WEBSOCKET_METHOD ) ; </a> 0
<a> if ( methodType == null ) { </a> 0
<a> methodType = "POST" ; </a> 0
<a> } </a> 0
<a> this . methodType = methodType ; </a> 0
<a> String delimiter = atmosphereServlet . getAtmosphereConfig ( ) . getInitParameter ( ApplicationConfig . WEBSOCKET_PATH_DELIMITER ) ; </a> 0
<a> if ( delimiter == null ) { </a> 0
<a> delimiter = "@@" ; </a> 0
<a> } </a> 0
<a> this . delimiter = delimiter ; </a> 0
<a> } </a> 0
<a> public void parseMessage ( String d ) { </a> 0
<a> String pathInfo = request ( ) . getPathInfo ( ) ; </a> 0
<a> if ( d . startsWith ( delimiter ) ) { </a> 0
<a> String [ ] token = d . split ( delimiter ) ; </a> 1
<a> pathInfo = token [ 1 ] ; </a> 1
<a> d = token [ 2 ] ; </a> 1
<a> } </a> 0
<a> AtmosphereRequest r = new AtmosphereRequest . Builder ( ) </a> 0
<a> . request ( request ( ) ) </a> 0
<a> . method ( methodType ) </a> 1
<a> . contentType ( contentType ) </a> 1
<a> . body ( d ) </a> 1
<a> . pathInfo ( pathInfo ) </a> 1
<a> . headers ( configureHeader ( request ( ) ) ) </a> 0
<a> . build ( ) ; </a> 1
<a> dispatch ( r , new WebSocketHttpServletResponse < WebSocket > ( webSocketSupport ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void parseMessage ( byte [ ] d , final int offset , final int length ) { </a> 0
<a> try { </a> 0
<a> String pathInfo = request ( ) . getPathInfo ( ) ; </a> 0
<a> if ( d [ 0 ] == ( byte ) delimiter . charAt ( 0 ) && d [ 1 ] == ( byte ) delimiter . charAt ( 0 ) ) { </a> 0
<a> final String s = new String ( d , offset , length , "UTF-8" ) ; </a> 0
<a> String [ ] token = s . split ( delimiter ) ; </a> 0
<a> pathInfo = token [ 1 ] ; </a> 0
<a> d = token [ 2 ] . getBytes ( "UTF-8" ) ; </a> 0
<a> } </a> 0
<a> AtmosphereRequest r = new AtmosphereRequest . Builder ( ) </a> 0
<a> . request ( request ( ) ) </a> 0
<a> . method ( methodType ) </a> 0
<a> . contentType ( contentType ) </a> 0
<a> . body ( d , offset , length ) </a> 0
<a> . pathInfo ( pathInfo ) </a> 0
<a> . headers ( configureHeader ( request ( ) ) ) </a> 0
<a> . build ( ) ; </a> 0
<a> dispatch ( r , new WebSocketHttpServletResponse < WebSocket > ( webSocketSupport ( ) ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . warn ( e . getMessage ( ) , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . atmosphere . tests ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public abstract class AbstractHttpAtmosphereHandler implements AtmosphereHandler < HttpServletRequest , HttpServletResponse > { </a> 0
<a> @ Override </a> 1
<a> public void destroy ( ) { </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . tests ; </a> 0
<a> import com . ning . http . client . AsyncCompletionHandler ; </a> 0
<a> import com . ning . http . client . AsyncHttpClient ; </a> 0
<a> import com . ning . http . client . Response ; </a> 0
<a> import org . atmosphere . cache . HeaderBroadcasterCache ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 1
<a> import org . atmosphere . cpr . BroadcastFilter ; </a> 1
<a> import org . atmosphere . cpr . Broadcaster ; </a> 1
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 1
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 1
<a> import org . atmosphere . cpr . HeaderConfig ; </a> 1
<a> import org . atmosphere . util . StringFilterAggregator ; </a> 1
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import org . testng . annotations . AfterMethod ; </a> 0
<a> import org . testng . annotations . BeforeMethod ; </a> 0
<a> import org . testng . annotations . Test ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> import java . io . PrintWriter ; </a> 1
<a> import java . net . ServerSocket ; </a> 1
<a> import java . util . List ; </a> 0
<a> import java . util . concurrent . CountDownLatch ; </a> 0
<a> import java . util . concurrent . ExecutionException ; </a> 0
<a> import java . util . concurrent . Future ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 1
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 1
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 1
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 1
<a> import static org . testng . Assert . assertEquals ; </a> 0
<a> import static org . testng . Assert . assertFalse ; </a> 0
<a> import static org . testng . Assert . assertNotNull ; </a> 0
<a> import static org . testng . Assert . assertTrue ; </a> 0
<a> import static org . testng . Assert . fail ; </a> 0
<a> public abstract class BaseTest { </a> 1
<a> protected static final Logger logger = LoggerFactory . getLogger ( BaseTest . class ) ; </a> 1
<a> protected AtmosphereServlet atmoServlet ; </a> 1
<a> protected final static String ROOT = "/*" ; </a> 1
<a> protected String urlTarget ; </a> 1
<a> public static class TestHelper { </a> 0
<a> public static int getEnvVariable ( final String varName , int defaultValue ) { </a> 0
<a> if ( null == varName ) { </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> String varValue = System . getenv ( varName ) ; </a> 0
<a> if ( null != varValue ) { </a> 0
<a> try { </a> 0
<a> return Integer . parseInt ( varValue ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected int findFreePort ( ) throws IOException { </a> 1
<a> ServerSocket socket = null ; </a> 1
<a> try { </a> 1
<a> socket = new ServerSocket ( 0 ) ; </a> 1
<a> return socket . getLocalPort ( ) ; </a> 1
<a> } finally { </a> 1
<a> if ( socket != null ) { </a> 1
<a> socket . close ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ BeforeMethod ( alwaysRun = true ) </a> 1
<a> abstract public void startServer ( ) throws Exception ; </a> 1
<a> abstract public void configureCometSupport ( ) ; </a> 1
<a> @ AfterMethod ( alwaysRun = true ) </a> 1
<a> abstract public void unsetAtmosphereHandler ( ) throws Exception ; </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testSuspendTimeout ( ) { </a> 1
<a> logger . info ( "{}: running test: testSuspendTimeout" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 1
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> private long currentTime ; </a> 1
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> currentTime = System . currentTimeMillis ( ) ; </a> 0
<a> event . suspend ( 5000 , false ) ; </a> 1
<a> } </a> 1
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> try { </a> 0
<a> event . getResource ( ) . getResponse ( ) . getOutputStream ( ) . write ( "resume" . getBytes ( ) ) ; </a> 0
<a> assertTrue ( event . isResumedOnTimeout ( ) ) ; </a> 0
<a> long time = System . currentTimeMillis ( ) - currentTime ; </a> 0
<a> if ( time > 5000 && time < 15000 ) { </a> 0
<a> assertTrue ( true ) ; </a> 0
<a> } else { </a> 0
<a> assertFalse ( false ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> String resume = r . getResponseBody ( ) ; </a> 0
<a> assertEquals ( resume , "resume" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 1
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testSuspendWithCommentsTimeout ( ) { </a> 1
<a> logger . info ( "{}: running test: testSuspendWithCommentsTimeout" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 1
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> private long currentTime ; </a> 1
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> currentTime = System . currentTimeMillis ( ) ; </a> 0
<a> event . suspend ( 5000 ) ; </a> 0
<a> } </a> 0
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> try { </a> 0
<a> assertTrue ( event . isResumedOnTimeout ( ) ) ; </a> 0
<a> long time = System . currentTimeMillis ( ) - currentTime ; </a> 0
<a> if ( time > 5000 && time < 15000 ) { </a> 0
<a> assertTrue ( true ) ; </a> 0
<a> } else { </a> 0
<a> assertFalse ( false ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> String resume = r . getResponseBody ( ) ; </a> 0
<a> assertEquals ( resume , AtmosphereResourceImpl . createCompatibleStringJunk ( ) ) ; </a> 0
<a> } catch ( Exception e ) { </a> 1
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = false ) </a> 1
<a> public void testProgrammaticDisconnection ( ) { </a> 1
<a> logger . info ( "{}: running test: testProgrammaticDisconnection" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 1
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> private long currentTime ; </a> 1
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> currentTime = System . currentTimeMillis ( ) ; </a> 1
<a> event . suspend ( ) ; </a> 1
<a> } </a> 1
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> try { </a> 0
<a> assertTrue ( event . isCancelled ( ) ) ; </a> 0
<a> long time = System . currentTimeMillis ( ) - currentTime ; </a> 0
<a> if ( time > 20000 && time < 25000 ) { </a> 0
<a> assertTrue ( true ) ; </a> 0
<a> } else { </a> 0
<a> assertFalse ( false ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> if ( latch . getCount ( ) != 0 ) { </a> 0
<a> fail ( "timedout" ) ; </a> 0
<a> } </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testProgrammaticResume ( ) { </a> 1
<a> logger . info ( "{}: running test: testProgrammaticResume" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 2 ) ; </a> 1
<a> final CountDownLatch suspended = new CountDownLatch ( 1 ) ; </a> 1
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> AtomicBoolean b = new AtomicBoolean ( false ) ; </a> 1
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > suspendedEvent ; </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( ! b . getAndSet ( true ) ) { </a> 0
<a> try { </a> 0
<a> suspendedEvent = event ; </a> 0
<a> event . suspend ( ) ; </a> 0
<a> } finally { </a> 1
<a> suspended . countDown ( ) ; </a> 1
<a> } </a> 1
<a> } else { </a> 0
<a> suspendedEvent . getResponse ( ) . flushBuffer ( ) ; </a> 0
<a> suspendedEvent . resume ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> try { </a> 0
<a> assertTrue ( event . isResuming ( ) ) ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( new AsyncCompletionHandler < String > ( ) { </a> 0
<a> @ Override </a> 0
<a> public String onCompleted ( Response response ) throws Exception { </a> 0
<a> try { </a> 1
<a> assertEquals ( response . getResponseBody ( ) , </a> 1
<a> AtmosphereResourceImpl . createCompatibleStringJunk ( ) ) ; </a> 0
<a> } finally { </a> 1
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 1
<a> return null ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> suspended . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testResumeOnBroadcast ( ) { </a> 1
<a> logger . info ( "{}: running test: testResumeOnBroadcast" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 2 ) ; </a> 1
<a> final CountDownLatch suspended = new CountDownLatch ( 1 ) ; </a> 1
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> AtomicBoolean b = new AtomicBoolean ( false ) ; </a> 1
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( ! b . getAndSet ( true ) ) { </a> 0
<a> try { </a> 0
<a> event . suspend ( ) ; </a> 0
<a> } finally { </a> 0
<a> suspended . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> event . getBroadcaster ( ) . broadcast ( "foo" ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isResuming ( ) ) { </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> try { </a> 1
<a> assertFalse ( event . isCancelled ( ) ) ; </a> 0
<a> assertNotNull ( event . getMessage ( ) ) ; </a> 0
<a> assertEquals ( event . getMessage ( ) , "foo" ) ; </a> 0
<a> event . getResource ( ) . getResponse ( ) . flushBuffer ( ) ; </a> 0
<a> event . getResource ( ) . resume ( ) ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( new AsyncCompletionHandler < String > ( ) { </a> 0
<a> @ Override </a> 0
<a> public String onCompleted ( Response response ) throws Exception { </a> 0
<a> try { </a> 1
<a> assertEquals ( response . getResponseBody ( ) , </a> 1
<a> AtmosphereResourceImpl . createCompatibleStringJunk ( ) ) ; </a> 0
<a> } finally { </a> 1
<a> latch . countDown ( ) ; </a> 1
<a> } </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> suspended . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testDelayBroadcast ( ) { </a> 1
<a> logger . info ( "{}: running test: testDelayBroadcast" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 2 ) ; </a> 0
<a> final CountDownLatch suspended = new CountDownLatch ( 1 ) ; </a> 0
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> AtomicBoolean b = new AtomicBoolean ( false ) ; </a> 0
<a> private long currentTime ; </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( ! b . getAndSet ( true ) ) { </a> 0
<a> try { </a> 0
<a> event . suspend ( ) ; </a> 0
<a> } finally { </a> 0
<a> suspended . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> currentTime = System . currentTimeMillis ( ) ; </a> 0
<a> event . getBroadcaster ( ) . delayBroadcast ( "foo" , 5 , TimeUnit . SECONDS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isResuming ( ) ) { </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> try { </a> 0
<a> long time = System . currentTimeMillis ( ) - currentTime ; </a> 0
<a> if ( time > 5000 && time < 6000 ) { </a> 0
<a> assertTrue ( true ) ; </a> 0
<a> } else { </a> 0
<a> assertFalse ( false ) ; </a> 0
<a> } </a> 0
<a> assertFalse ( event . isCancelled ( ) ) ; </a> 0
<a> assertNotNull ( event . getMessage ( ) ) ; </a> 0
<a> assertEquals ( event . getMessage ( ) , "foo" ) ; </a> 0
<a> event . getResource ( ) . getResponse ( ) . flushBuffer ( ) ; </a> 0
<a> event . getResource ( ) . resume ( ) ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( new AsyncCompletionHandler < String > ( ) { </a> 0
<a> @ Override </a> 0
<a> public String onCompleted ( Response response ) throws Exception { </a> 0
<a> try { </a> 1
<a> assertEquals ( response . getResponseBody ( ) , </a> 1
<a> AtmosphereResourceImpl . createCompatibleStringJunk ( ) ) ; </a> 0
<a> } finally { </a> 1
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 1
<a> return null ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> suspended . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> assertNotNull ( r ) ; </a> 1
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 1
<a> } catch ( Exception e ) { </a> 1
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testDelayNextBroadcast ( ) { </a> 1
<a> logger . info ( "{}: running test: testDelayNextBroadcast" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 2 ) ; </a> 1
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> AtomicBoolean b = new AtomicBoolean ( false ) ; </a> 1
<a> AtomicInteger count = new AtomicInteger ( 0 ) ; </a> 1
<a> private long currentTime ; </a> 1
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( ! b . getAndSet ( true ) ) { </a> 1
<a> event . suspend ( - 1 , false ) ; </a> 1
<a> } else { </a> 1
<a> currentTime = System . currentTimeMillis ( ) ; </a> 1
<a> if ( count . get ( ) < 4 ) { </a> 1
<a> event . getBroadcaster ( ) . delayBroadcast ( "message-" + count . getAndIncrement ( ) + " " ) ; </a> 1
<a> } else { </a> 1
<a> event . getBroadcaster ( ) . broadcast ( "message-final" ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isResuming ( ) ) { </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> try { </a> 1
<a> event . getResource ( ) . getResponse ( ) . getWriter ( ) . write ( ( String ) event . getMessage ( ) ) ; </a> 1
<a> event . getResource ( ) . getResponse ( ) . flushBuffer ( ) ; </a> 1
<a> event . getResource ( ) . resume ( ) ; </a> 1
<a> } catch ( Exception ex ) { </a> 1
<a> logger . error ( "failure resuming resource" , ex ) ; </a> 1
<a> } finally { </a> 1
<a> latch . countDown ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 1
<a> try { </a> 1
<a> Future < Response > f = c . prepareGet ( urlTarget ) . execute ( ) ; </a> 1
<a> latch . await ( 5 , TimeUnit . SECONDS ) ; </a> 1
<a> c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 1
<a> c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 1
<a> c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 1
<a> c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 1
<a> Response r = f . get ( 10 , TimeUnit . SECONDS ) ; </a> 1
<a> assertNotNull ( r ) ; </a> 1
<a> assertEquals ( r . getResponseBody ( ) , "message-0 message-1 message-2 message-3 message-final" ) ; </a> 1
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 1
<a> } catch ( Exception e ) { </a> 1
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testScheduleBroadcast ( ) { </a> 1
<a> logger . info ( "{}: running test: testScheduleBroadcast" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 2 ) ; </a> 0
<a> final CountDownLatch suspended = new CountDownLatch ( 1 ) ; </a> 0
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> AtomicBoolean b = new AtomicBoolean ( false ) ; </a> 0
<a> private long currentTime ; </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( ! b . getAndSet ( true ) ) { </a> 0
<a> try { </a> 0
<a> event . suspend ( ) ; </a> 0
<a> } finally { </a> 0
<a> suspended . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> currentTime = System . currentTimeMillis ( ) ; </a> 0
<a> event . getBroadcaster ( ) . scheduleFixedBroadcast ( "foo" , 0 , 5 , TimeUnit . SECONDS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isResuming ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> long time = System . currentTimeMillis ( ) - currentTime ; </a> 0
<a> if ( time > 5000 && time < 6000 ) { </a> 0
<a> assertTrue ( true ) ; </a> 0
<a> } else { </a> 0
<a> assertFalse ( false ) ; </a> 0
<a> } </a> 0
<a> assertFalse ( event . isCancelled ( ) ) ; </a> 0
<a> assertNotNull ( event . getMessage ( ) ) ; </a> 0
<a> assertEquals ( event . getMessage ( ) , "foo" ) ; </a> 0
<a> event . getResource ( ) . getResponse ( ) . flushBuffer ( ) ; </a> 0
<a> event . getResource ( ) . resume ( ) ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( new AsyncCompletionHandler < String > ( ) { </a> 0
<a> @ Override </a> 0
<a> public String onCompleted ( Response response ) throws Exception { </a> 0
<a> try { </a> 1
<a> assertEquals ( response . getResponseBody ( ) , </a> 1
<a> AtmosphereResourceImpl . createCompatibleStringJunk ( ) ) ; </a> 0
<a> } finally { </a> 1
<a> latch . countDown ( ) ; </a> 1
<a> } </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> suspended . await ( 20 , TimeUnit . SECONDS ) ; </a> 1
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 1
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 1
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testDelayScheduleBroadcast ( ) { </a> 1
<a> logger . info ( "{}: running test: testDelayScheduleBroadcast" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 2 ) ; </a> 0
<a> final CountDownLatch suspended = new CountDownLatch ( 1 ) ; </a> 0
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> AtomicBoolean b = new AtomicBoolean ( false ) ; </a> 0
<a> private long currentTime ; </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( ! b . getAndSet ( true ) ) { </a> 0
<a> try { </a> 0
<a> event . suspend ( ) ; </a> 0
<a> } finally { </a> 0
<a> suspended . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> currentTime = System . currentTimeMillis ( ) ; </a> 0
<a> event . getBroadcaster ( ) . scheduleFixedBroadcast ( "foo" , 10 , 5 , TimeUnit . SECONDS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isResuming ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> long time = System . currentTimeMillis ( ) - currentTime ; </a> 0
<a> if ( time > 15000 && time < 20000 ) { </a> 0
<a> assertTrue ( true ) ; </a> 0
<a> } else { </a> 0
<a> assertFalse ( false ) ; </a> 0
<a> } </a> 0
<a> assertFalse ( event . isCancelled ( ) ) ; </a> 0
<a> assertNotNull ( event . getMessage ( ) ) ; </a> 0
<a> assertEquals ( event . getMessage ( ) , "foo" ) ; </a> 0
<a> event . getResource ( ) . getResponse ( ) . flushBuffer ( ) ; </a> 0
<a> event . getResource ( ) . resume ( ) ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 1
<a> try { </a> 1
<a> c . prepareGet ( urlTarget ) . execute ( new AsyncCompletionHandler < String > ( ) { </a> 0
<a> @ Override </a> 0
<a> public String onCompleted ( Response response ) throws Exception { </a> 0
<a> try { </a> 1
<a> assertEquals ( response . getResponseBody ( ) , </a> 1
<a> AtmosphereResourceImpl . createCompatibleStringJunk ( ) ) ; </a> 0
<a> } finally { </a> 1
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 1
<a> return null ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> suspended . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> assertNotNull ( r ) ; </a> 1
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 1
<a> } catch ( Exception e ) { </a> 1
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testBroadcastFilter ( ) { </a> 1
<a> logger . info ( "{}: running test: testBroadcastFilter" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 2 ) ; </a> 0
<a> final CountDownLatch suspended = new CountDownLatch ( 1 ) ; </a> 0
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> AtomicBoolean b = new AtomicBoolean ( false ) ; </a> 1
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( ! b . getAndSet ( true ) ) { </a> 0
<a> try { </a> 0
<a> event . suspend ( ) ; </a> 0
<a> } finally { </a> 0
<a> suspended . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> event . getBroadcaster ( ) . getBroadcasterConfig ( ) . addFilter ( new BroadcastFilter ( ) { </a> 0
<a> public BroadcastAction filter ( Object o , Object message ) { </a> 1
<a> return new BroadcastAction ( BroadcastAction . ACTION . CONTINUE , "boo" + message ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> event . getBroadcaster ( ) . broadcast ( "foo" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isResuming ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> assertFalse ( event . isCancelled ( ) ) ; </a> 0
<a> assertNotNull ( event . getMessage ( ) ) ; </a> 0
<a> assertEquals ( event . getMessage ( ) , "boofoo" ) ; </a> 0
<a> event . getResource ( ) . getResponse ( ) . flushBuffer ( ) ; </a> 0
<a> event . getResource ( ) . resume ( ) ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( new AsyncCompletionHandler < String > ( ) { </a> 0
<a> @ Override </a> 0
<a> public String onCompleted ( Response response ) throws Exception { </a> 0
<a> try { </a> 1
<a> assertEquals ( response . getResponseBody ( ) , </a> 1
<a> AtmosphereResourceImpl . createCompatibleStringJunk ( ) ) ; </a> 0
<a> } finally { </a> 1
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 1
<a> return null ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> suspended . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testAggregateFilter ( ) { </a> 1
<a> logger . info ( "{}: running test: testAggregateFilter" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 2 ) ; </a> 0
<a> final CountDownLatch suspended = new CountDownLatch ( 1 ) ; </a> 0
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> AtomicBoolean b = new AtomicBoolean ( false ) ; </a> 1
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( ! b . getAndSet ( true ) ) { </a> 0
<a> StringFilterAggregator a = new StringFilterAggregator ( 25 ) ; </a> 0
<a> event . getBroadcaster ( ) . getBroadcasterConfig ( ) . addFilter ( a ) ; </a> 0
<a> try { </a> 0
<a> event . suspend ( ) ; </a> 0
<a> } finally { </a> 1
<a> suspended . countDown ( ) ; </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> event . getBroadcaster ( ) . broadcast ( "12345678910" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isResuming ( ) ) { </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> assertFalse ( event . isCancelled ( ) ) ; </a> 0
<a> assertNotNull ( event . getMessage ( ) ) ; </a> 0
<a> assertEquals ( event . getMessage ( ) , "123456789101234567891012345678910" ) ; </a> 0
<a> event . getResource ( ) . getResponse ( ) . flushBuffer ( ) ; </a> 0
<a> event . getResource ( ) . resume ( ) ; </a> 0
<a> latch . countDown ( ) ; </a> 1
<a> } </a> 1
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( new AsyncCompletionHandler < String > ( ) { </a> 0
<a> @ Override </a> 0
<a> public String onCompleted ( Response response ) throws Exception { </a> 0
<a> try { </a> 1
<a> assertEquals ( response . getResponseBody ( ) , </a> 1
<a> AtmosphereResourceImpl . createCompatibleStringJunk ( ) ) ; </a> 0
<a> } finally { </a> 1
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 1
<a> return null ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> suspended . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> assertNotNull ( r ) ; </a> 1
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 1
<a> } catch ( Exception e ) { </a> 1
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testHeaderBroadcasterCache ( ) throws IllegalAccessException , ClassNotFoundException , InstantiationException { </a> 1
<a> logger . info ( "{}: running test: testHeaderBroadcasterCache" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> atmoServlet . setBroadcasterCacheClassName ( HeaderBroadcasterCache . class . getName ( ) ) ; </a> 0
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> try { </a> 1
<a> if ( event . getRequest ( ) . getHeader ( HeaderConfig . X_CACHE_DATE ) != null ) { </a> 1
<a> event . suspend ( - 1 , false ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> event . getBroadcaster ( ) . broadcast ( "12345678910" ) . get ( ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> logger . error ( "" , e ) ; </a> 1
<a> } catch ( ExecutionException e ) { </a> 1
<a> logger . error ( "" , e ) ; </a> 1
<a> } </a> 1
<a> event . getResponse ( ) . flushBuffer ( ) ; </a> 1
<a> } </a> 1
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isResuming ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> assertFalse ( event . isCancelled ( ) ) ; </a> 0
<a> assertNotNull ( event . getMessage ( ) ) ; </a> 0
<a> if ( List . class . isAssignableFrom ( event . getMessage ( ) . getClass ( ) ) ) { </a> 0
<a> for ( String m : ( List < String > ) event . getMessage ( ) ) { </a> 0
<a> event . getResource ( ) . getResponse ( ) . getOutputStream ( ) . write ( m . getBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> event . getResource ( ) . getResponse ( ) . flushBuffer ( ) ; </a> 0
<a> event . getResource ( ) . resume ( ) ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . addHeader ( HeaderConfig . X_CACHE_DATE , String . valueOf ( t1 ) ) . execute ( new AsyncCompletionHandler < Response > ( ) { </a> 1
<a> @ Override </a> 0
<a> public Response onCompleted ( Response r ) throws Exception { </a> 0
<a> try { </a> 0
<a> return r ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> assertEquals ( r . getResponseBody ( ) , "1234567891012345678910" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testSuspendRejectPolicy ( ) { </a> 1
<a> logger . info ( "{}: running test: testSuspendTimeout" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 1
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> private long currentTime ; </a> 1
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> currentTime = System . currentTimeMillis ( ) ; </a> 1
<a> event . getBroadcaster ( ) . setSuspendPolicy ( 1 , Broadcaster . POLICY . REJECT ) ; </a> 1
<a> event . suspend ( 5000 , false ) ; </a> 0
<a> } </a> 0
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> try { </a> 0
<a> event . getResource ( ) . getResponse ( ) . getOutputStream ( ) . write ( "resume" . getBytes ( ) ) ; </a> 0
<a> assertTrue ( event . isResumedOnTimeout ( ) ) ; </a> 0
<a> long time = System . currentTimeMillis ( ) - currentTime ; </a> 0
<a> if ( time > 5000 && time < 15000 ) { </a> 0
<a> assertTrue ( true ) ; </a> 0
<a> } else { </a> 0
<a> assertFalse ( false ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> String resume = r . getResponseBody ( ) ; </a> 0
<a> assertEquals ( resume , "resume" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testBroadcastOnResume ( ) { </a> 1
<a> logger . info ( "{}: running test: testScheduleBroadcast" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 2 ) ; </a> 1
<a> final CountDownLatch suspended = new CountDownLatch ( 1 ) ; </a> 1
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> AtomicBoolean b = new AtomicBoolean ( false ) ; </a> 0
<a> private long currentTime ; </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( ! b . getAndSet ( true ) ) { </a> 1
<a> try { </a> 1
<a> event . suspend ( ) ; </a> 1
<a> event . getBroadcaster ( ) . broadcastOnResume ( "broadcastOnResume" ) ; </a> 1
<a> } finally { </a> 0
<a> suspended . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } </a> 1
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isResuming ( ) ) { </a> 1
<a> assertFalse ( event . isCancelled ( ) ) ; </a> 1
<a> assertNotNull ( event . getMessage ( ) ) ; </a> 1
<a> assertEquals ( event . getMessage ( ) , "broadcastOnResume" ) ; </a> 1
<a> event . getResource ( ) . getResponse ( ) . flushBuffer ( ) ; </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> try { </a> 1
<a> event . getResource ( ) . resume ( ) ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( new AsyncCompletionHandler < String > ( ) { </a> 0
<a> @ Override </a> 0
<a> public String onCompleted ( Response response ) throws Exception { </a> 0
<a> try { </a> 1
<a> assertEquals ( response . getResponseBody ( ) , </a> 1
<a> AtmosphereResourceImpl . createCompatibleStringJunk ( ) ) ; </a> 0
<a> } finally { </a> 1
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 1
<a> return null ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> suspended . await ( 20 , TimeUnit . SECONDS ) ; </a> 1
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 1
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testBroadcastOnResumeMsg ( ) { </a> 1
<a> logger . info ( "{}: running test: testBroadcastOnResumeMsg" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 2 ) ; </a> 1
<a> final CountDownLatch suspended = new CountDownLatch ( 1 ) ; </a> 1
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> AtomicBoolean b = new AtomicBoolean ( false ) ; </a> 0
<a> private long currentTime ; </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( ! b . getAndSet ( true ) ) { </a> 1
<a> try { </a> 1
<a> event . suspend ( ) ; </a> 1
<a> event . getBroadcaster ( ) . broadcastOnResume ( "broadcastOnResume" ) ; </a> 1
<a> } finally { </a> 0
<a> suspended . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> event . resume ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isResuming ( ) ) { </a> 1
<a> assertNotNull ( event . getMessage ( ) ) ; </a> 1
<a> assertEquals ( event . getMessage ( ) , "broadcastOnResume" ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> c . prepareGet ( urlTarget ) . execute ( new AsyncCompletionHandler < String > ( ) { </a> 0
<a> @ Override </a> 0
<a> public String onCompleted ( Response response ) throws Exception { </a> 0
<a> try { </a> 1
<a> assertEquals ( response . getResponseBody ( ) , </a> 1
<a> AtmosphereResourceImpl . createCompatibleStringJunk ( ) ) ; </a> 0
<a> } finally { </a> 1
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 1
<a> return null ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> suspended . await ( 10 , TimeUnit . SECONDS ) ; </a> 1
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( ) ; </a> 1
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testBroadcastFactoryNewBroadcasterTimeout ( ) { </a> 1
<a> logger . info ( "{}: running test: testBroadcastFactoryTimeout" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 2 ) ; </a> 1
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> private long currentTime ; </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> currentTime = System . currentTimeMillis ( ) ; </a> 1
<a> event . suspend ( 5000 , false ) ; </a> 1
<a> try { </a> 1
<a> Broadcaster b = BroadcasterFactory . getDefault ( ) . lookup ( DefaultBroadcaster . class , "ExternalBroadcaster" , true ) ; </a> 1
<a> b . addAtmosphereResource ( event ) ; </a> 1
<a> b . broadcast ( "Outer broadcast" ) . get ( ) ; </a> 1
<a> event . getBroadcaster ( ) . broadcast ( "Inner broadcast" ) . get ( ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> e . printStackTrace ( ) ; </a> 1
<a> } catch ( ExecutionException e ) { </a> 1
<a> e . printStackTrace ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isResuming ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 1
<a> event . getResource ( ) . getResponse ( ) . getWriter ( ) . write ( event . getMessage ( ) . toString ( ) ) ; </a> 1
<a> } finally { </a> 1
<a> latch . countDown ( ) ; </a> 1
<a> if ( latch . getCount ( ) == 0 ) { </a> 1
<a> event . getResource ( ) . resume ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> Future < Response > f = c . prepareGet ( urlTarget ) . execute ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> Response r = f . get ( ) ; </a> 1
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> String resume = r . getResponseBody ( ) ; </a> 0
<a> assertEquals ( resume , "Outer broadcastInner broadcast" ) ; </a> 1
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 60000 , enabled = true ) </a> 1
<a> public void testConcurrentBroadcast ( ) { </a> 1
<a> logger . info ( "{}: running test: testConcurrentBroadcast" , getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> final AtomicInteger broadcastCount = new AtomicInteger ( 0 ) ; </a> 1
<a> final AtomicReference < Response > response = new AtomicReference < Response > ( ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 1
<a> final CountDownLatch suspendedLatch = new CountDownLatch ( 1 ) ; </a> 1
<a> atmoServlet . addAtmosphereHandler ( ROOT , new AbstractHttpAtmosphereHandler ( ) { </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . getRequest ( ) . getHeader ( "yo" ) != null ) { </a> 1
<a> try { </a> 1
<a> event . suspend ( - 1 , false ) ; </a> 1
<a> suspendedLatch . countDown ( ) ; </a> 1
<a> } finally { </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> event . getBroadcaster ( ) . broadcast ( "Message-1 " ) ; </a> 1
<a> event . getBroadcaster ( ) . broadcast ( "Message-2 " ) ; </a> 1
<a> event . getBroadcaster ( ) . broadcast ( "Message-3 " ) ; </a> 1
<a> event . getBroadcaster ( ) . broadcast ( "Message-4" ) ; </a> 1
<a> logger . info ( event . getResponse ( ) . toString ( ) ) ; </a> 1
<a> event . getResponse ( ) . getOutputStream ( ) . write ( "OK" . getBytes ( ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isResuming ( ) ) { </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> PrintWriter writer = event . getResource ( ) . getResponse ( ) . getWriter ( ) ; </a> 1
<a> writer . write ( event . getMessage ( ) . toString ( ) ) ; </a> 1
<a> writer . flush ( ) ; </a> 1
<a> try { </a> 1
<a> broadcastCount . incrementAndGet ( ) ; </a> 1
<a> } finally { </a> 1
<a> if ( broadcastCount . get ( ) == 4 ) { </a> 1
<a> event . getResource ( ) . resume ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , new RecyclableBroadcaster ( "suspend" ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> c . prepareGet ( urlTarget ) . addHeader ( "yo" , "yo" ) . execute ( new AsyncCompletionHandler < Object > ( ) { </a> 1
<a> @ Override </a> 1
<a> public Object onCompleted ( Response r ) throws Exception { </a> 1
<a> response . set ( r ) ; </a> 1
<a> latch . countDown ( ) ; </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> suspendedLatch . await ( 10 , TimeUnit . SECONDS ) ; </a> 1
<a> c . prepareGet ( urlTarget ) . execute ( ) ; </a> 1
<a> latch . await ( 10 , TimeUnit . SECONDS ) ; </a> 1
<a> assertNotNull ( response . get ( ) ) ; </a> 1
<a> assertEquals ( response . get ( ) . getStatusCode ( ) , 200 ) ; </a> 1
<a> assertEquals ( response . get ( ) . getResponseBody ( ) , "Message-1 Message-2 Message-3 Message-4" ) ; </a> 1
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } finally { </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> package org . atmosphere . tests ; </a> 0
<a> import com . ning . http . client . AsyncCompletionHandler ; </a> 1
<a> import com . ning . http . client . AsyncHttpClient ; </a> 1
<a> import com . ning . http . client . Response ; </a> 1
<a> import org . atmosphere . container . JettyCometSupport ; </a> 1
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 1
<a> import org . atmosphere . cpr . Broadcaster ; </a> 1
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 1
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 1
<a> import org . atmosphere . cpr . Meteor ; </a> 1
<a> import org . atmosphere . cpr . MeteorServlet ; </a> 1
<a> import org . mortbay . jetty . Server ; </a> 1
<a> import org . mortbay . jetty . servlet . Context ; </a> 1
<a> import org . mortbay . jetty . servlet . ServletHolder ; </a> 1
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import org . testng . annotations . AfterMethod ; </a> 1
<a> import org . testng . annotations . BeforeMethod ; </a> 1
<a> import org . testng . annotations . Test ; </a> 1
<a> import javax . servlet . http . HttpServlet ; </a> 1
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . ServerSocket ; </a> 1
<a> import java . util . concurrent . CountDownLatch ; </a> 1
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 1
<a> import static org . testng . Assert . assertEquals ; </a> 1
<a> import static org . testng . Assert . assertFalse ; </a> 1
<a> import static org . testng . Assert . assertNotNull ; </a> 1
<a> import static org . testng . Assert . assertTrue ; </a> 1
<a> import static org . testng . Assert . fail ; </a> 1
<a> public class BroadcasterScopeTest { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( BroadcasterScopeTest . class ) ; </a> 1
<a> protected MeteorServlet atmoServlet ; </a> 1
<a> protected final static String ROOT = "/*" ; </a> 1
<a> protected String urlTarget ; </a> 1
<a> protected Server server ; </a> 1
<a> protected Context root ; </a> 1
<a> private static CountDownLatch servletLatch ; </a> 1
<a> private static final AtomicReference < String > broadcasterId = new AtomicReference < String > ( ) ; </a> 1
<a> public static class TestHelper { </a> 1
<a> public static int getEnvVariable ( final String varName , int defaultValue ) { </a> 1
<a> if ( null == varName ) { </a> 1
<a> return defaultValue ; </a> 1
<a> } </a> 1
<a> String varValue = System . getenv ( varName ) ; </a> 1
<a> if ( null != varValue ) { </a> 1
<a> try { </a> 1
<a> return Integer . parseInt ( varValue ) ; </a> 1
<a> } catch ( NumberFormatException e ) { </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return defaultValue ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> protected int findFreePort ( ) throws IOException { </a> 1
<a> ServerSocket socket = null ; </a> 1
<a> try { </a> 1
<a> socket = new ServerSocket ( 0 ) ; </a> 1
<a> return socket . getLocalPort ( ) ; </a> 1
<a> } finally { </a> 1
<a> if ( socket != null ) { </a> 1
<a> socket . close ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public static class Meteor1 extends HttpServlet { </a> 1
<a> @ Override </a> 1
<a> public void doGet ( HttpServletRequest req , HttpServletResponse res ) throws IOException { </a> 1
<a> final Meteor m = Meteor . build ( req ) ; </a> 1
<a> m . getBroadcaster ( ) . setScope ( Broadcaster . SCOPE . REQUEST ) ; </a> 1
<a> req . getSession ( ) . setAttribute ( "meteor" , m ) ; </a> 1
<a> m . suspend ( 5000 , false ) ; </a> 1
<a> broadcasterId . set ( m . getBroadcaster ( ) . getID ( ) ) ; </a> 1
<a> res . getOutputStream ( ) . write ( "resume" . getBytes ( ) ) ; </a> 1
<a> m . addListener ( new AtmosphereResourceEventListener ( ) { </a> 1
<a> @ Override </a> 1
<a> public void onSuspend ( final AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> event . getResource ( ) . getRequest ( ) . setAttribute ( ApplicationConfig . RESUME_ON_BROADCAST , "true" ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> } </a> 1
<a> } ) ; </a> 1
<a> if ( servletLatch != null ) { </a> 1
<a> servletLatch . countDown ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ BeforeMethod ( alwaysRun = true ) </a> 1
<a> public void startServer ( ) throws Exception { </a> 1
<a> int port = BaseTest . TestHelper . getEnvVariable ( "ATMOSPHERE_HTTP_PORT" , findFreePort ( ) ) ; </a> 1
<a> urlTarget = "http://127.0.0.1:" + port + "/invoke" ; </a> 1
<a> server = new Server ( port ) ; </a> 1
<a> root = new Context ( server , "/" , Context . SESSIONS ) ; </a> 1
<a> atmoServlet = new MeteorServlet ( ) ; </a> 1
<a> atmoServlet . addInitParameter ( "org.atmosphere.servlet" , Meteor1 . class . getName ( ) ) ; </a> 0
<a> configureCometSupport ( ) ; </a> 1
<a> root . addServlet ( new ServletHolder ( atmoServlet ) , ROOT ) ; </a> 1
<a> server . start ( ) ; </a> 1
<a> } </a> 1
<a> public void configureCometSupport ( ) { </a> 1
<a> atmoServlet . setCometSupport ( new JettyCometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 1
<a> @ AfterMethod ( alwaysRun = true ) </a> 1
<a> public void unsetAtmosphereHandler ( ) throws Exception { </a> 1
<a> atmoServlet . destroy ( ) ; </a> 0
<a> server . stop ( ) ; </a> 1
<a> server = null ; </a> 1
<a> } </a> 1
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 1
<a> public void testBroadcasterScope ( ) { </a> 1
<a> logger . info ( "Running testBroadcasterScope" ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 1
<a> final CountDownLatch latch2 = new CountDownLatch ( 1 ) ; </a> 1
<a> servletLatch = new CountDownLatch ( 1 ) ; </a> 1
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 1
<a> Broadcaster b = null ; </a> 1
<a> try { </a> 1
<a> long currentTime = System . currentTimeMillis ( ) ; </a> 1
<a> final AtomicReference < Response > r = new AtomicReference ( ) ; </a> 1
<a> c . prepareGet ( urlTarget ) . execute ( new AsyncCompletionHandler < Response > ( ) { </a> 1
<a> @ Override </a> 1
<a> public Response onCompleted ( Response response ) throws Exception { </a> 1
<a> r . set ( response ) ; </a> 1
<a> latch . countDown ( ) ; </a> 1
<a> return response ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> servletLatch . await ( ) ; </a> 1
<a> String id = broadcasterId . get ( ) ; </a> 1
<a> b = BroadcasterFactory . getDefault ( ) . lookup ( DefaultBroadcaster . class , id ) ; </a> 1
<a> assertNotNull ( b ) ; </a> 1
<a> b . broadcast ( "resume" ) . get ( ) ; </a> 1
<a> try { </a> 1
<a> latch . await ( ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> long time = System . currentTimeMillis ( ) - currentTime ; </a> 1
<a> if ( time < 5000 ) { </a> 1
<a> assertTrue ( true ) ; </a> 1
<a> } else { </a> 1
<a> assertFalse ( false ) ; </a> 1
<a> } </a> 1
<a> assertNotNull ( r . get ( ) ) ; </a> 1
<a> assertEquals ( r . get ( ) . getStatusCode ( ) , 200 ) ; </a> 1
<a> String resume = r . get ( ) . getResponseBody ( ) ; </a> 1
<a> assertEquals ( resume , "resumeresume" ) ; </a> 1
<a> c . prepareGet ( urlTarget ) . execute ( new AsyncCompletionHandler < Response > ( ) { </a> 1
<a> @ Override </a> 1
<a> public Response onCompleted ( Response response ) throws Exception { </a> 1
<a> r . set ( response ) ; </a> 1
<a> latch2 . countDown ( ) ; </a> 1
<a> return response ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> try { </a> 1
<a> latch2 . await ( ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> assertFalse ( id . equals ( broadcasterId . get ( ) ) ) ; </a> 1
<a> } catch ( Exception e ) { </a> 1
<a> logger . error ( "test failed" , e ) ; </a> 1
<a> fail ( e . getMessage ( ) ) ; </a> 1
<a> } finally { </a> 1
<a> if ( b != null ) b . destroy ( ) ; </a> 1
<a> } </a> 1
<a> c . close ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . tests ; </a> 0
<a> import com . sun . grizzly . comet . CometAsyncFilter ; </a> 1
<a> import com . sun . grizzly . http . embed . GrizzlyWebServer ; </a> 1
<a> import com . sun . grizzly . http . servlet . ServletAdapter ; </a> 1
<a> import org . atmosphere . container . GrizzlyCometSupport ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . testng . annotations . AfterMethod ; </a> 0
<a> import org . testng . annotations . BeforeMethod ; </a> 0
<a> public class GrizzlyCometSupportTest extends BaseTest { </a> 1
<a> protected GrizzlyWebServer ws ; </a> 1
<a> @ BeforeMethod ( alwaysRun = true ) </a> 0
<a> public void startServer ( ) throws Exception { </a> 1
<a> int port = TestHelper . getEnvVariable ( "ATMOSPHERE_HTTP_PORT" , findFreePort ( ) ) ; </a> 1
<a> urlTarget = "http://127.0.0.1:" + port + "/invoke" ; </a> 0
<a> ws = new GrizzlyWebServer ( port ) ; </a> 1
<a> ServletAdapter sa = new ServletAdapter ( ) ; </a> 1
<a> sa . setProperty ( "load-on-startup" , 0 ) ; </a> 1
<a> ws . addAsyncFilter ( new CometAsyncFilter ( ) ) ; </a> 1
<a> atmoServlet = new AtmosphereServlet ( ) ; </a> 0
<a> sa . setServletInstance ( atmoServlet ) ; </a> 1
<a> configureCometSupport ( ) ; </a> 1
<a> ws . addGrizzlyAdapter ( sa , new String [ ] { ROOT } ) ; </a> 1
<a> ws . start ( ) ; </a> 1
<a> } </a> 1
<a> public void configureCometSupport ( ) { </a> 1
<a> atmoServlet . setCometSupport ( new GrizzlyCometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ AfterMethod ( alwaysRun = true ) </a> 0
<a> public void unsetAtmosphereHandler ( ) throws Exception { </a> 0
<a> atmoServlet . destroy ( ) ; </a> 0
<a> ws . stop ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . tests ; </a> 0
<a> import org . atmosphere . container . Jetty7CometSupport ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 1
<a> import org . eclipse . jetty . server . Server ; </a> 1
<a> import org . eclipse . jetty . servlet . ServletContextHandler ; </a> 1
<a> import org . eclipse . jetty . servlet . ServletHolder ; </a> 1
<a> import org . testng . annotations . AfterMethod ; </a> 0
<a> import org . testng . annotations . BeforeMethod ; </a> 0
<a> public class Jetty7CometSupportTest extends BaseTest { </a> 1
<a> protected Server server ; </a> 1
<a> @ BeforeMethod ( alwaysRun = true ) </a> 1
<a> public void startServer ( ) throws Exception { </a> 1
<a> int port = TestHelper . getEnvVariable ( "ATMOSPHERE_HTTP_PORT" , findFreePort ( ) ) ; </a> 1
<a> urlTarget = "http://127.0.0.1:" + port + "/invoke" ; </a> 0
<a> server = new Server ( port ) ; </a> 0
<a> ServletContextHandler context = new ServletContextHandler ( ServletContextHandler . SESSIONS ) ; </a> 1
<a> context . setContextPath ( "/" ) ; </a> 1
<a> server . setHandler ( context ) ; </a> 1
<a> atmoServlet = new AtmosphereServlet ( ) ; </a> 1
<a> configureCometSupport ( ) ; </a> 1
<a> context . addServlet ( new ServletHolder ( atmoServlet ) , "/" ) ; </a> 1
<a> server . start ( ) ; </a> 1
<a> } </a> 1
<a> public void configureCometSupport ( ) { </a> 1
<a> atmoServlet . setCometSupport ( new Jetty7CometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ AfterMethod ( alwaysRun = true ) </a> 0
<a> public void unsetAtmosphereHandler ( ) throws Exception { </a> 0
<a> atmoServlet . destroy ( ) ; </a> 0
<a> server . stop ( ) ; </a> 1
<a> server = null ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . tests ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterConfig ; </a> 0
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 0
<a> public class RecyclableBroadcaster extends DefaultBroadcaster { </a> 0
<a> public RecyclableBroadcaster ( ) { </a> 0
<a> super ( ) ; </a> 0
<a> } </a> 0
<a> public RecyclableBroadcaster ( String name ) { </a> 0
<a> super ( name ) ; </a> 0
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> broadcasterCache = new BroadcasterConfig . DefaultBroadcasterCache ( ) ; </a> 0
<a> setScope ( Broadcaster . SCOPE . APPLICATION ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . tests ; </a> 0
<a> import org . apache . catalina . Context ; </a> 1
<a> import org . apache . catalina . Engine ; </a> 1
<a> import org . apache . catalina . Host ; </a> 1
<a> import org . apache . catalina . LifecycleException ; </a> 1
<a> import org . apache . catalina . Wrapper ; </a> 1
<a> import org . apache . catalina . connector . Connector ; </a> 1
<a> import org . apache . catalina . startup . Embedded ; </a> 1
<a> import org . apache . coyote . http11 . Http11NioProtocol ; </a> 1
<a> import org . atmosphere . container . TomcatCometSupport ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 1
<a> import org . testng . annotations . AfterMethod ; </a> 1
<a> import org . testng . annotations . BeforeMethod ; </a> 1
<a> import javax . servlet . ServletConfig ; </a> 1
<a> import javax . servlet . ServletException ; </a> 1
<a> import java . io . File ; </a> 1
<a> public class TomcatCometSupportTest extends BaseTest { </a> 1
<a> protected Embedded embedded ; </a> 1
<a> public static class TomcatAtmosphereServlet extends AtmosphereServlet { </a> 1
<a> public void init ( final ServletConfig sc ) throws ServletException { </a> 1
<a> cometSupport = new TomcatCometSupport ( getAtmosphereConfig ( ) ) ; </a> 0
<a> super . init ( sc ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ BeforeMethod ( alwaysRun = true ) </a> 1
<a> public void startServer ( ) throws Exception { </a> 1
<a> System . setProperty ( "org.atmosphere.useNative" , "true" ) ; </a> 1
<a> int port = TestHelper . getEnvVariable ( "ATMOSPHERE_HTTP_PORT" , findFreePort ( ) ) ; </a> 1
<a> urlTarget = "http://127.0.0.1:" + port + "/invoke" ; </a> 1
<a> embedded = new Embedded ( ) ; </a> 1
<a> String path = new File ( "." ) . getAbsolutePath ( ) ; </a> 1
<a> embedded . setCatalinaHome ( path ) ; </a> 1
<a> Engine engine = embedded . createEngine ( ) ; </a> 1
<a> engine . setDefaultHost ( "127.0.0.1" ) ; </a> 1
<a> Host host = embedded . createHost ( "127.0.0.1" , path ) ; </a> 1
<a> engine . addChild ( host ) ; </a> 1
<a> Context c = embedded . createContext ( "/" , path ) ; </a> 1
<a> c . setReloadable ( false ) ; </a> 1
<a> Wrapper w = c . createWrapper ( ) ; </a> 1
<a> w . addMapping ( "/*" ) ; </a> 1
<a> w . setServletClass ( TomcatAtmosphereServlet . class . getName ( ) ) ; </a> 1
<a> w . setLoadOnStartup ( 0 ) ; </a> 1
<a> c . addChild ( w ) ; </a> 1
<a> host . addChild ( c ) ; </a> 1
<a> Connector connector = embedded . createConnector ( "127.0.0.1" , port , Http11NioProtocol . class . getName ( ) ) ; </a> 1
<a> connector . setContainer ( host ) ; </a> 1
<a> embedded . addEngine ( engine ) ; </a> 1
<a> embedded . addConnector ( connector ) ; </a> 1
<a> embedded . start ( ) ; </a> 1
<a> atmoServlet = ( AtmosphereServlet ) w . getServlet ( ) ; </a> 1
<a> } </a> 1
<a> public void configureCometSupport ( ) { </a> 1
<a> } </a> 1
<a> @ AfterMethod ( alwaysRun = true ) </a> 1
<a> public void unsetAtmosphereHandler ( ) { </a> 1
<a> try { </a> 1
<a> embedded . stop ( ) ; </a> 1
<a> } catch ( LifecycleException ignored ) { </a> 1
<a> logger . info ( "server stop failed" , ignored ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey ; </a> 0
<a> import com . sun . jersey . api . JResponseAsResponse ; </a> 0
<a> import com . sun . jersey . api . model . AbstractMethod ; </a> 0
<a> import com . sun . jersey . spi . container . ContainerRequest ; </a> 0
<a> import com . sun . jersey . spi . container . ContainerRequestFilter ; </a> 0
<a> import com . sun . jersey . spi . container . ContainerResponse ; </a> 0
<a> import com . sun . jersey . spi . container . ContainerResponseFilter ; </a> 0
<a> import com . sun . jersey . spi . container . ResourceFilter ; </a> 0
<a> import com . sun . jersey . spi . container . ResourceFilterFactory ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . annotation . Cluster ; </a> 0
<a> import org . atmosphere . annotation . Publish ; </a> 0
<a> import org . atmosphere . annotation . Resume ; </a> 0
<a> import org . atmosphere . annotation . Schedule ; </a> 0
<a> import org . atmosphere . annotation . Subscribe ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereEventLifecycle ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterConfig ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import org . atmosphere . cpr . ClusterBroadcastFilter ; </a> 0
<a> import org . atmosphere . cpr . FrameworkConfig ; </a> 0
<a> import org . atmosphere . cpr . HeaderConfig ; </a> 0
<a> import org . atmosphere . cpr . Trackable ; </a> 1
<a> import org . atmosphere . di . InjectorProvider ; </a> 1
<a> import org . atmosphere . websocket . WebSocket ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . ws . rs . WebApplicationException ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import javax . ws . rs . core . HttpHeaders ; </a> 0
<a> import javax . ws . rs . core . MediaType ; </a> 0
<a> import javax . ws . rs . core . UriInfo ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . lang . annotation . Annotation ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Enumeration ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . LinkedList ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . UUID ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 0
<a> import java . util . concurrent . ExecutionException ; </a> 1
<a> import java . util . concurrent . Future ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . ACCESS_CONTROL_ALLOW_CREDENTIALS ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . ACCESS_CONTROL_ALLOW_ORIGIN ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . CACHE_CONTROL ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . EXPIRES ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . LONG_POLLING_TRANSPORT ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . PRAGMA ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . WEBSOCKET_UPGRADE ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . X_ATMOSPHERE_ERROR ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . X_ATMOSPHERE_TRACKING_ID ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . X_ATMOSPHERE_TRANSPORT ; </a> 0
<a> public class AtmosphereFilter implements ResourceFilterFactory { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( AtmosphereFilter . class ) ; </a> 0
<a> public final static String SUSPENDED_RESOURCE = AtmosphereFilter . class . getName ( ) + ".suspendedResource" ; </a> 0
<a> public final static String RESUME_UUID = AtmosphereFilter . class . getName ( ) + ".uuid" ; </a> 0
<a> public final static String RESUME_CANDIDATES = AtmosphereFilter . class . getName ( ) + ".resumeCandidates" ; </a> 0
<a> public final static String INJECTED_BROADCASTER = AtmosphereFilter . class . getName ( ) + "injectedBroadcaster" ; </a> 0
<a> public final static String INJECTED_TRACKABLE = AtmosphereFilter . class . getName ( ) + "injectedTrackable" ; </a> 0
<a> public final static String CONTAINER_RESPONSE = FrameworkConfig . CONTAINER_RESPONSE ; </a> 0
<a> enum Action { </a> 0
<a> SUSPEND , RESUME , BROADCAST , SUSPEND_RESUME , </a> 0
<a> SCHEDULE_RESUME , RESUME_ON_BROADCAST , NONE , SCHEDULE , SUSPEND_RESPONSE , </a> 0
<a> SUSPEND_TRACKABLE , SUBSCRIBE , SUBSCRIBE_TRACKABLE , PUBLISH </a> 1
<a> } </a> 0
<a> private @ Context HttpServletRequest servletReq ; </a> 0
<a> private </a> 0
<a> @ Context </a> 0
<a> UriInfo uriInfo ; </a> 0
<a> private final ConcurrentHashMap < String , AtmosphereResource < HttpServletRequest , HttpServletResponse > > resumeCandidates = </a> 0
<a> new ConcurrentHashMap < String , AtmosphereResource < HttpServletRequest , HttpServletResponse > > ( ) ; </a> 0
<a> private class Filter implements ResourceFilter , ContainerResponseFilter { </a> 0
<a> private final Action action ; </a> 0
<a> private final long timeout ; </a> 0
<a> private final int waitFor ; </a> 0
<a> private final Suspend . SCOPE scope ; </a> 0
<a> private final Class < BroadcastFilter > [ ] filters ; </a> 0
<a> private Class < ? extends AtmosphereResourceEventListener > [ ] listeners = null ; </a> 0
<a> private final boolean outputComments ; </a> 0
<a> private final ArrayList < ClusterBroadcastFilter > clusters </a> 0
<a> = new ArrayList < ClusterBroadcastFilter > ( ) ; </a> 0
<a> private final String topic ; </a> 0
<a> protected Filter ( Action action ) { </a> 0
<a> this ( action , - 1 ) ; </a> 0
<a> } </a> 0
<a> protected Filter ( Action action , long timeout ) { </a> 0
<a> this ( action , timeout , 0 ) ; </a> 0
<a> } </a> 0
<a> protected Filter ( Action action , long timeout , int waitFor ) { </a> 0
<a> this ( action , timeout , waitFor , Suspend . SCOPE . APPLICATION ) ; </a> 0
<a> } </a> 0
<a> protected Filter ( Action action , long timeout , int waitFor , Suspend . SCOPE scope ) { </a> 0
<a> this ( action , timeout , waitFor , scope , true ) ; </a> 0
<a> } </a> 0
<a> protected Filter ( Action action , long timeout , int waitFor , Suspend . SCOPE scope , boolean outputComments ) { </a> 0
<a> this ( action , timeout , waitFor , scope , outputComments , null , null ) ; </a> 0
<a> } </a> 0
<a> protected Filter ( Action action , long timeout , int waitFor , Suspend . SCOPE scope , boolean outputComments , Class < BroadcastFilter > [ ] filters , String topic ) { </a> 0
<a> this . action = action ; </a> 0
<a> this . timeout = timeout ; </a> 0
<a> this . scope = scope ; </a> 0
<a> this . outputComments = outputComments ; </a> 0
<a> this . waitFor = waitFor ; </a> 0
<a> this . filters = filters ; </a> 0
<a> this . topic = topic ; </a> 0
<a> } </a> 0
<a> public ContainerRequestFilter getRequestFilter ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public ContainerResponseFilter getResponseFilter ( ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> boolean resumeOnBroadcast ( ContainerRequest request , boolean resumeOnBroadcast ) { </a> 1
<a> String transport = request . getHeaderValue ( X_ATMOSPHERE_TRANSPORT ) ; </a> 1
<a> if ( transport != null && transport . equals ( LONG_POLLING_TRANSPORT ) ) { </a> 1
<a> return true ; </a> 0
<a> } </a> 0
<a> return resumeOnBroadcast ; </a> 0
<a> } </a> 0
<a> boolean outputJunk ( ContainerRequest request , boolean outputJunk ) { </a> 1
<a> boolean webSocketEnabled = false ; </a> 0
<a> if ( servletReq . getHeaders ( "Connection" ) != null && servletReq . getHeaders ( "Connection" ) . hasMoreElements ( ) ) { </a> 0
<a> String [ ] e = ( ( Enumeration < String > ) servletReq . getHeaders ( "Connection" ) ) . nextElement ( ) . split ( "," ) ; </a> 0
<a> for ( String upgrade : e ) { </a> 0
<a> if ( upgrade . trim ( ) . equalsIgnoreCase ( WEBSOCKET_UPGRADE ) ) { </a> 0
<a> webSocketEnabled = true ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> String transport = request . getHeaderValue ( X_ATMOSPHERE_TRANSPORT ) ; </a> 1
<a> if ( webSocketEnabled ) { </a> 0
<a> return false ; </a> 1
<a> } else if ( transport != null && transport . equals ( LONG_POLLING_TRANSPORT ) ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 0
<a> return outputJunk ; </a> 0
<a> } </a> 0
<a> public ContainerResponse filter ( ContainerRequest request , ContainerResponse response ) { </a> 1
<a> if ( response . getMappedThrowable ( ) != null ) { </a> 0
<a> return response ; </a> 0
<a> } </a> 0
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > r = </a> 0
<a> ( AtmosphereResource < HttpServletRequest , HttpServletResponse > ) servletReq </a> 0
<a> . getAttribute ( FrameworkConfig . ATMOSPHERE_RESOURCE ) ; </a> 0
<a> boolean sessionSupported = ( Boolean ) servletReq . getAttribute ( FrameworkConfig . SUPPORT_SESSION ) ; </a> 1
<a> switch ( action ) { </a> 1
<a> case SUSPEND_RESPONSE : </a> 0
<a> SuspendResponse < ? > s = SuspendResponse . class . cast ( JResponseAsResponse . class . cast ( response . getResponse ( ) ) . getJResponse ( ) ) ; </a> 0
<a> boolean outputJunk = outputJunk ( request , s . outputComments ( ) ) ; </a> 1
<a> boolean resumeOnBroadcast = resumeOnBroadcast ( request , s . resumeOnBroadcast ( ) ) ; </a> 1
<a> for ( AtmosphereResourceEventListener el : s . listeners ( ) ) { </a> 0
<a> if ( r instanceof AtmosphereEventLifecycle ) { </a> 1
<a> ( ( AtmosphereEventLifecycle ) r ) . addEventListener ( el ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> Broadcaster bc = s . broadcaster ( ) ; </a> 0
<a> if ( bc == null && s . scope ( ) != Suspend . SCOPE . REQUEST ) { </a> 0
<a> bc = ( Broadcaster ) servletReq . getAttribute ( INJECTED_BROADCASTER ) ; </a> 0
<a> } </a> 0
<a> boolean supportTrackable = servletReq . getAttribute ( ApplicationConfig . SUPPORT_TRACKABLE ) != null ; </a> 1
<a> boolean isTracked = response . getEntity ( ) != null ? TrackableResource . class . isAssignableFrom ( response . getEntity ( ) . getClass ( ) ) : supportTrackable ; </a> 1
<a> TrackableResource < ? extends Trackable > trackableResource = null ; </a> 1
<a> if ( isTracked ) { </a> 1
<a> trackableResource = preTrack ( request , response ) ; </a> 1
<a> } </a> 1
<a> suspend ( sessionSupported , resumeOnBroadcast , outputJunk , </a> 1
<a> translateTimeUnit ( s . period ( ) . value ( ) , s . period ( ) . timeUnit ( ) ) , request , response , bc , r , s . scope ( ) ) ; </a> 0
<a> if ( isTracked && trackableResource != null ) { </a> 1
<a> postTrack ( trackableResource , r ) ; </a> 1
<a> } </a> 1
<a> break ; </a> 0
<a> case SUBSCRIBE_TRACKABLE : </a> 0
<a> case SUBSCRIBE : </a> 0
<a> case SUSPEND : </a> 0
<a> case SUSPEND_TRACKABLE : </a> 0
<a> case SUSPEND_RESUME : </a> 0
<a> outputJunk = outputJunk ( request , outputComments ) ; </a> 1
<a> resumeOnBroadcast = resumeOnBroadcast ( request , ( action == Action . SUSPEND_RESUME ) ) ; </a> 1
<a> for ( Class < ? extends AtmosphereResourceEventListener > listener : listeners ) { </a> 0
<a> try { </a> 0
<a> AtmosphereResourceEventListener el = listener . newInstance ( ) ; </a> 0
<a> InjectorProvider . getInjector ( ) . inject ( el ) ; </a> 1
<a> if ( r instanceof AtmosphereEventLifecycle ) { </a> 1
<a> ( ( AtmosphereEventLifecycle ) r ) . addEventListener ( el ) ; </a> 1
<a> } </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> throw new WebApplicationException ( </a> 0
<a> new IllegalStateException ( "Invalid AtmosphereResourceEventListener " + listener , t ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Broadcaster broadcaster = ( Broadcaster ) servletReq . getAttribute ( INJECTED_BROADCASTER ) ; </a> 0
<a> if ( action == Action . SUBSCRIBE ) { </a> 0
<a> Class < Broadcaster > c = null ; </a> 0
<a> try { </a> 0
<a> c = ( Class < Broadcaster > ) Class . forName ( ( String ) servletReq . getAttribute ( ApplicationConfig . BROADCASTER_CLASS ) ) ; </a> 1
<a> } catch ( Throwable e ) { </a> 1
<a> throw new IllegalStateException ( e . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> broadcaster = BroadcasterFactory . getDefault ( ) . lookup ( c , topic , true ) ; </a> 1
<a> } </a> 1
<a> supportTrackable = servletReq . getAttribute ( ApplicationConfig . SUPPORT_TRACKABLE ) != null ; </a> 1
<a> isTracked = response . getEntity ( ) != null ? TrackableResource . class . isAssignableFrom ( response . getEntity ( ) . getClass ( ) ) : supportTrackable ; </a> 1
<a> if ( isTracked ) { </a> 1
<a> trackableResource = preTrack ( request , response ) ; </a> 1
<a> } else { </a> 1
<a> trackableResource = null ; </a> 1
<a> } </a> 1
<a> suspend ( sessionSupported , resumeOnBroadcast , outputJunk , timeout , request , response , </a> 1
<a> broadcaster , r , scope ) ; </a> 0
<a> if ( isTracked && trackableResource != null ) { </a> 1
<a> postTrack ( trackableResource , r ) ; </a> 1
<a> } </a> 1
<a> break ; </a> 0
<a> case RESUME : </a> 0
<a> if ( response . getEntity ( ) != null ) { </a> 0
<a> try { </a> 0
<a> response . write ( ) ; </a> 0
<a> } catch ( IOException ex ) { </a> 0
<a> throw new WebApplicationException ( ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( sessionSupported ) { </a> 0
<a> r = ( AtmosphereResource ) servletReq . getSession ( ) . getAttribute ( SUSPENDED_RESOURCE ) ; </a> 0
<a> } else { </a> 0
<a> String path = response . getContainerRequest ( ) . getPath ( ) ; </a> 0
<a> r = resumeCandidates . remove ( path . substring ( path . lastIndexOf ( "/" ) + 1 ) ) ; </a> 0
<a> } </a> 0
<a> if ( r != null ) { </a> 0
<a> resume ( r ) ; </a> 0
<a> } else { </a> 0
<a> throw new WebApplicationException ( </a> 0
<a> new IllegalStateException ( "Unable to retrieve suspended Response. " + </a> 0
<a> "Either session-support is not enabled in atmosphere.xml or the" + </a> 0
<a> "path used to resume is invalid." ) ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> case BROADCAST : </a> 0
<a> case PUBLISH : </a> 0
<a> case RESUME_ON_BROADCAST : </a> 0
<a> AtmosphereResource ar = ( AtmosphereResource ) servletReq . getAttribute ( SUSPENDED_RESOURCE ) ; </a> 0
<a> if ( ar != null ) { </a> 0
<a> r = ar ; </a> 0
<a> } </a> 0
<a> if ( action == Action . PUBLISH ) { </a> 0
<a> Class < Broadcaster > c = null ; </a> 0
<a> try { </a> 0
<a> c = ( Class < Broadcaster > ) Class . forName ( ( String ) servletReq . getAttribute ( ApplicationConfig . BROADCASTER_CLASS ) ) ; </a> 1
<a> } catch ( Throwable e ) { </a> 0
<a> throw new IllegalStateException ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> r . setBroadcaster ( BroadcasterFactory . getDefault ( ) . lookup ( c , topic , true ) ) ; </a> 1
<a> } </a> 0
<a> broadcast ( response , r , timeout ) ; </a> 0
<a> break ; </a> 0
<a> case SCHEDULE : </a> 0
<a> case SCHEDULE_RESUME : </a> 0
<a> Object o = response . getEntity ( ) ; </a> 0
<a> Broadcaster b = r . getBroadcaster ( ) ; </a> 0
<a> if ( response . getEntity ( ) instanceof Broadcastable ) { </a> 0
<a> b = ( ( Broadcastable ) response . getEntity ( ) ) . getBroadcaster ( ) ; </a> 0
<a> o = ( ( Broadcastable ) response . getEntity ( ) ) . getMessage ( ) ; </a> 0
<a> response . setEntity ( ( ( Broadcastable ) response . getEntity ( ) ) . getResponseMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( response . getEntity ( ) != null ) { </a> 0
<a> try { </a> 0
<a> response . write ( ) ; </a> 0
<a> } catch ( IOException ex ) { </a> 0
<a> throw new WebApplicationException ( ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( action == Action . SCHEDULE_RESUME ) { </a> 0
<a> configureResumeOnBroadcast ( b ) ; </a> 0
<a> } </a> 0
<a> b . scheduleFixedBroadcast ( o , waitFor , timeout , TimeUnit . SECONDS ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> return response ; </a> 0
<a> } </a> 0
<a> TrackableResource preTrack ( ContainerRequest request , ContainerResponse response ) { </a> 1
<a> TrackableResource < ? extends Trackable > trackableResource = TrackableResource . class . cast ( response . getEntity ( ) ) ; </a> 1
<a> if ( trackableResource == null ) { </a> 1
<a> trackableResource = new TrackableResource < AtmosphereResource > ( AtmosphereResource . class , servletReq . getHeader ( X_ATMOSPHERE_TRACKING_ID ) , "" ) ; </a> 1
<a> } else { </a> 1
<a> response . setEntity ( trackableResource . entity ( ) ) ; </a> 1
<a> } </a> 1
<a> String trackableUUID = request . getHeaderValue ( X_ATMOSPHERE_TRACKING_ID ) ; </a> 0
<a> if ( trackableUUID == null && trackableResource . trackingID ( ) != null ) { </a> 0
<a> trackableUUID = trackableResource . trackingID ( ) ; </a> 0
<a> } else if ( trackableUUID == null ) { </a> 0
<a> trackableUUID = UUID . randomUUID ( ) . toString ( ) ; </a> 0
<a> } </a> 0
<a> trackableResource . setTrackingID ( trackableUUID ) ; </a> 0
<a> TrackableSession . getDefault ( ) . track ( trackableResource ) ; </a> 0
<a> response . getHttpHeaders ( ) . putSingle ( X_ATMOSPHERE_TRACKING_ID , trackableResource . trackingID ( ) ) ; </a> 0
<a> servletReq . setAttribute ( X_ATMOSPHERE_TRACKING_ID , trackableResource . trackingID ( ) ) ; </a> 0
<a> return trackableResource ; </a> 1
<a> } </a> 1
<a> void postTrack ( TrackableResource trackableResource , AtmosphereResource r ) { </a> 1
<a> boolean isAresource = AtmosphereResource . class . isAssignableFrom ( trackableResource . type ( ) ) ? true : false ; </a> 0
<a> trackableResource . setResource ( isAresource ? r : r . getBroadcaster ( ) ) ; </a> 0
<a> } </a> 0
<a> void configureHeaders ( ContainerResponse response ) throws IOException { </a> 0
<a> boolean webSocketSupported = servletReq . getAttribute ( WebSocket . WEBSOCKET_SUSPEND ) != null ; </a> 0
<a> if ( servletReq . getHeaders ( "Connection" ) != null && servletReq . getHeaders ( "Connection" ) . hasMoreElements ( ) ) { </a> 0
<a> String [ ] e = ( ( Enumeration < String > ) servletReq . getHeaders ( "Connection" ) ) . nextElement ( ) . split ( "," ) ; </a> 0
<a> for ( String upgrade : e ) { </a> 0
<a> if ( upgrade != null && upgrade . equalsIgnoreCase ( WEBSOCKET_UPGRADE ) ) { </a> 0
<a> if ( ! webSocketSupported ) { </a> 0
<a> response . getHttpHeaders ( ) . putSingle ( X_ATMOSPHERE_ERROR , "Websocket protocol not supported" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean injectCacheHeaders = ( Boolean ) servletReq . getAttribute ( ApplicationConfig . NO_CACHE_HEADERS ) ; </a> 1
<a> boolean enableAccessControl = ( Boolean ) servletReq . getAttribute ( ApplicationConfig . DROP_ACCESS_CONTROL_ALLOW_ORIGIN_HEADER ) ; </a> 1
<a> if ( injectCacheHeaders ) { </a> 0
<a> response . getHttpHeaders ( ) . putSingle ( EXPIRES , "-1" ) ; </a> 0
<a> response . getHttpHeaders ( ) . putSingle ( CACHE_CONTROL , "no-store, no-cache, must-revalidate" ) ; </a> 0
<a> response . getHttpHeaders ( ) . putSingle ( PRAGMA , "no-cache" ) ; </a> 0
<a> } </a> 0
<a> if ( enableAccessControl ) { </a> 0
<a> response . getHttpHeaders ( ) . putSingle ( ACCESS_CONTROL_ALLOW_ORIGIN , "*" ) ; </a> 0
<a> response . getHttpHeaders ( ) . putSingle ( ACCESS_CONTROL_ALLOW_CREDENTIALS , "true" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void configureResumeOnBroadcast ( Broadcaster b ) { </a> 0
<a> Iterator < AtmosphereResource < ? , ? > > i = b . getAtmosphereResources ( ) . iterator ( ) ; </a> 0
<a> while ( i . hasNext ( ) ) { </a> 0
<a> HttpServletRequest r = ( HttpServletRequest ) i . next ( ) . getRequest ( ) ; </a> 0
<a> r . setAttribute ( ApplicationConfig . RESUME_ON_BROADCAST , true ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> void configureFilter ( Broadcaster bc ) { </a> 0
<a> if ( bc == null ) throw new WebApplicationException ( new IllegalStateException ( "Broadcaster cannot be null" ) ) ; </a> 0
<a> BroadcasterConfig c = bc . getBroadcasterConfig ( ) ; </a> 0
<a> if ( c . hasFilters ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> for ( ClusterBroadcastFilter cbf : clusters ) { </a> 0
<a> cbf . setBroadcaster ( bc ) ; </a> 0
<a> c . addFilter ( cbf ) ; </a> 0
<a> } </a> 0
<a> BroadcastFilter f = null ; </a> 0
<a> if ( filters != null ) { </a> 0
<a> for ( Class < BroadcastFilter > filter : filters ) { </a> 0
<a> try { </a> 0
<a> f = filter . newInstance ( ) ; </a> 0
<a> InjectorProvider . getInjector ( ) . inject ( f ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Invalid @BroadcastFilter: " + filter , t ) ; </a> 0
<a> } </a> 0
<a> c . addFilter ( f ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void setListeners ( Class < ? extends AtmosphereResourceEventListener > [ ] listeners ) { </a> 0
<a> this . listeners = listeners ; </a> 0
<a> } </a> 0
<a> void broadcast ( ContainerResponse r , AtmosphereResource ar , long delay ) { </a> 0
<a> Object o = r . getEntity ( ) ; </a> 0
<a> Broadcaster b = ar . getBroadcaster ( ) ; </a> 0
<a> Object msg = o ; </a> 0
<a> String returnMsg = null ; </a> 0
<a> if ( o instanceof Broadcastable ) { </a> 0
<a> if ( ( ( Broadcastable ) o ) . getBroadcaster ( ) != null ) { </a> 0
<a> b = ( ( Broadcastable ) o ) . getBroadcaster ( ) ; </a> 0
<a> } </a> 0
<a> msg = ( ( Broadcastable ) o ) . getMessage ( ) ; </a> 0
<a> returnMsg = ( ( Broadcastable ) o ) . getResponseMessage ( ) . toString ( ) ; </a> 0
<a> } </a> 0
<a> if ( action == Action . RESUME_ON_BROADCAST ) { </a> 0
<a> configureResumeOnBroadcast ( b ) ; </a> 0
<a> } </a> 0
<a> if ( o != null ) { </a> 0
<a> addFilter ( b ) ; </a> 0
<a> try { </a> 1
<a> r . setEntity ( msg ) ; </a> 0
<a> if ( msg == null ) return ; </a> 0
<a> if ( delay == - 1 ) { </a> 0
<a> Future < Object > f = b . broadcast ( msg ) ; </a> 1
<a> if ( f == null ) return ; </a> 1
<a> Object t = f . get ( ) ; </a> 1
<a> if ( o instanceof Broadcastable ) { </a> 0
<a> r . setEntity ( returnMsg ) ; </a> 0
<a> } </a> 0
<a> } else if ( delay == 0 ) { </a> 0
<a> b . delayBroadcast ( msg ) ; </a> 0
<a> } else { </a> 0
<a> b . delayBroadcast ( msg , delay , TimeUnit . SECONDS ) ; </a> 0
<a> } </a> 0
<a> } catch ( InterruptedException ex ) { </a> 1
<a> logger . error ( "broadcast interrupted" , ex ) ; </a> 1
<a> } catch ( ExecutionException ex ) { </a> 1
<a> logger . error ( "execution exception during broadcast" , ex ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> void addFilter ( Broadcaster bc ) { </a> 0
<a> configureFilter ( bc ) ; </a> 0
<a> } </a> 0
<a> void resume ( AtmosphereResource resource ) { </a> 0
<a> resource . resume ( ) ; </a> 0
<a> } </a> 0
<a> void addCluster ( ClusterBroadcastFilter f ) { </a> 0
<a> clusters . add ( f ) ; </a> 0
<a> } </a> 0
<a> void suspend ( boolean sessionSupported , </a> 1
<a> boolean resumeOnBroadcast , </a> 1
<a> boolean comments , </a> 0
<a> long timeout , </a> 0
<a> ContainerRequest request , </a> 0
<a> ContainerResponse response , </a> 0
<a> Broadcaster bc , </a> 0
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > r , </a> 0
<a> Suspend . SCOPE localScope ) { </a> 0
<a> if ( response . getStatus ( ) == 204 ) { </a> 0
<a> response . setStatus ( 200 ) ; </a> 0
<a> } </a> 0
<a> BroadcasterFactory broadcasterFactory = ( BroadcasterFactory ) servletReq </a> 1
<a> . getAttribute ( ApplicationConfig . BROADCASTER_FACTORY ) ; </a> 1
<a> if ( ! sessionSupported && ! resumeOnBroadcast && response . getHttpHeaders ( ) . getFirst ( "Location" ) == null ) { </a> 1
<a> String uuid = UUID . randomUUID ( ) . toString ( ) ; </a> 0
<a> response . getHttpHeaders ( ) . putSingle ( </a> 0
<a> HttpHeaders . LOCATION , </a> 0
<a> uriInfo . getAbsolutePathBuilder ( ) . path ( uuid ) . build ( "" ) ) ; </a> 0
<a> resumeCandidates . put ( uuid , r ) ; </a> 0
<a> servletReq . setAttribute ( RESUME_UUID , uuid ) ; </a> 0
<a> servletReq . setAttribute ( RESUME_CANDIDATES , resumeCandidates ) ; </a> 0
<a> } </a> 0
<a> if ( bc == null && localScope != Suspend . SCOPE . REQUEST ) { </a> 0
<a> bc = r . getBroadcaster ( ) ; </a> 0
<a> } </a> 0
<a> if ( sessionSupported && localScope != Suspend . SCOPE . REQUEST && servletReq . getSession ( ) . getAttribute ( SUSPENDED_RESOURCE ) != null ) { </a> 0
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > cached = </a> 0
<a> ( AtmosphereResource ) servletReq . getSession ( ) . getAttribute ( SUSPENDED_RESOURCE ) ; </a> 0
<a> bc = cached . getBroadcaster ( ) ; </a> 0
<a> try { </a> 0
<a> bc . removeAtmosphereResource ( cached ) ; </a> 0
<a> } catch ( IllegalStateException ex ) { </a> 0
<a> logger . trace ( ex . getMessage ( ) , ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( response . getEntity ( ) instanceof Broadcastable ) { </a> 1
<a> Broadcastable b = ( Broadcastable ) response . getEntity ( ) ; </a> 0
<a> bc = b . getBroadcaster ( ) ; </a> 0
<a> response . setEntity ( b . getResponseMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( ( localScope == Suspend . SCOPE . REQUEST ) && bc == null ) { </a> 0
<a> if ( bc == null ) { </a> 0
<a> try { </a> 0
<a> String id = UUID . randomUUID ( ) . toString ( ) ; </a> 0
<a> Class < Broadcaster > c = null ; </a> 0
<a> try { </a> 0
<a> c = ( Class < Broadcaster > ) Class . forName ( ( String ) servletReq . getAttribute ( ApplicationConfig . BROADCASTER_CLASS ) ) ; </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> throw new IllegalStateException ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> bc = broadcasterFactory . get ( c , id ) ; </a> 0
<a> bc . setScope ( Broadcaster . SCOPE . REQUEST ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> logger . error ( "failed to instantiate broadcaster with factory: " + broadcasterFactory , ex ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> bc . setScope ( Broadcaster . SCOPE . REQUEST ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> configureFilter ( bc ) ; </a> 1
<a> r . setBroadcaster ( bc ) ; </a> 0
<a> if ( sessionSupported ) { </a> 0
<a> servletReq . getSession ( ) . setAttribute ( SUSPENDED_RESOURCE , r ) ; </a> 0
<a> servletReq . getSession ( ) . setAttribute ( FrameworkConfig . CONTAINER_RESPONSE , response ) ; </a> 0
<a> } </a> 0
<a> servletReq . setAttribute ( SUSPENDED_RESOURCE , r ) ; </a> 0
<a> servletReq . setAttribute ( FrameworkConfig . CONTAINER_RESPONSE , response ) ; </a> 0
<a> logger . debug ( "Linking HttpServletRequest {} with ContainerResponse {}" , servletReq , response ) ; </a> 0
<a> if ( resumeOnBroadcast ) { </a> 1
<a> servletReq . setAttribute ( ApplicationConfig . RESUME_ON_BROADCAST , new Boolean ( true ) ) ; </a> 1
<a> } </a> 1
<a> try { </a> 0
<a> MediaType contentType = response . getMediaType ( ) ; </a> 0
<a> if ( contentType == null && response . getEntity ( ) != null ) { </a> 0
<a> LinkedList < MediaType > l = new LinkedList < MediaType > ( ) ; </a> 0
<a> l . add ( request . getAcceptableMediaType ( new LinkedList < MediaType > ( ) ) ) ; </a> 0
<a> contentType = response . getMessageBodyWorkers ( ) . getMessageBodyWriterMediaType ( </a> 0
<a> response . getEntity ( ) . getClass ( ) , </a> 0
<a> response . getEntityType ( ) , </a> 0
<a> response . getAnnotations ( ) , </a> 0
<a> l ) ; </a> 0
<a> if ( contentType == null || </a> 0
<a> contentType . isWildcardType ( ) || contentType . isWildcardSubtype ( ) ) </a> 0
<a> contentType = MediaType . APPLICATION_OCTET_STREAM_TYPE ; </a> 0
<a> } </a> 0
<a> Object entity = response . getEntity ( ) ; </a> 0
<a> if ( entity != null ) { </a> 0
<a> r . getResponse ( ) . setContentType ( contentType != null ? </a> 0
<a> contentType . toString ( ) : "text/html; charset=ISO-8859-1" ) ; </a> 1
<a> } </a> 0
<a> configureHeaders ( response ) ; </a> 0
<a> if ( comments && ! resumeOnBroadcast ) { </a> 0
<a> response . setEntity ( AtmosphereResourceImpl . createCompatibleStringJunk ( ) ) ; </a> 0
<a> response . write ( ) ; </a> 0
<a> } </a> 0
<a> if ( entity != null ) { </a> 1
<a> response . setEntity ( entity ) ; </a> 0
<a> response . write ( ) ; </a> 1
<a> } </a> 0
<a> r . suspend ( timeout , false ) ; </a> 0
<a> } catch ( IOException ex ) { </a> 0
<a> throw new WebApplicationException ( ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public List < ResourceFilter > create ( AbstractMethod am ) { </a> 0
<a> LinkedList < ResourceFilter > list = new LinkedList < ResourceFilter > ( ) ; </a> 0
<a> Filter f ; </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> for ( Annotation annotation : am . getAnnotations ( ) ) { </a> 0
<a> logger . debug ( "AtmosphereFilter processing annotation: {}" , annotation ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( am . getMethod ( ) == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( SuspendResponse . class . isAssignableFrom ( am . getMethod ( ) . getReturnType ( ) ) ) { </a> 0
<a> list . addLast ( new Filter ( Action . SUSPEND_RESPONSE ) ) ; </a> 0
<a> return list ; </a> 0
<a> } </a> 0
<a> if ( am . isAnnotationPresent ( Broadcast . class ) ) { </a> 0
<a> int delay = am . getAnnotation ( Broadcast . class ) . delay ( ) ; </a> 0
<a> Class [ ] suspendTimeout = am . getAnnotation ( Broadcast . class ) . value ( ) ; </a> 1
<a> if ( am . getAnnotation ( Broadcast . class ) . resumeOnBroadcast ( ) ) { </a> 0
<a> f = new Filter ( Action . RESUME_ON_BROADCAST , delay , 0 , Suspend . SCOPE . APPLICATION , true , suspendTimeout , null ) ; </a> 1
<a> } else { </a> 0
<a> f = new Filter ( Action . BROADCAST , delay , 0 , Suspend . SCOPE . APPLICATION , true , suspendTimeout , null ) ; </a> 1
<a> } </a> 0
<a> list . addLast ( f ) ; </a> 0
<a> if ( am . isAnnotationPresent ( Cluster . class ) ) { </a> 0
<a> suspendTimeout = am . getAnnotation ( Cluster . class ) . value ( ) ; </a> 1
<a> for ( Class < ClusterBroadcastFilter > c : suspendTimeout ) { </a> 1
<a> try { </a> 0
<a> ClusterBroadcastFilter cbf = c . newInstance ( ) ; </a> 0
<a> InjectorProvider . getInjector ( ) . inject ( cbf ) ; </a> 1
<a> cbf . setUri ( am . getAnnotation ( Cluster . class ) . name ( ) ) ; </a> 0
<a> f . addCluster ( cbf ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Invalid ClusterBroadcastFilter" , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( am . isAnnotationPresent ( Suspend . class ) ) { </a> 0
<a> long suspendTimeout = am . getAnnotation ( Suspend . class ) . period ( ) ; </a> 0
<a> TimeUnit tu = am . getAnnotation ( Suspend . class ) . timeUnit ( ) ; </a> 0
<a> suspendTimeout = translateTimeUnit ( suspendTimeout , tu ) ; </a> 0
<a> Suspend . SCOPE scope = am . getAnnotation ( Suspend . class ) . scope ( ) ; </a> 0
<a> boolean outputComments = am . getAnnotation ( Suspend . class ) . outputComments ( ) ; </a> 0
<a> boolean trackable = false ; </a> 1
<a> if ( TrackableResource . class . isAssignableFrom ( am . getMethod ( ) . getReturnType ( ) ) ) { </a> 1
<a> trackable = true ; </a> 1
<a> } </a> 1
<a> if ( am . getAnnotation ( Suspend . class ) . resumeOnBroadcast ( ) ) { </a> 0
<a> f = new Filter ( trackable ? Action . SUSPEND_TRACKABLE : Action . SUSPEND_RESUME , suspendTimeout , 0 , scope , outputComments ) ; </a> 1
<a> } else { </a> 0
<a> f = new Filter ( trackable ? Action . SUSPEND_TRACKABLE : Action . SUSPEND , suspendTimeout , 0 , scope , outputComments ) ; </a> 1
<a> } </a> 0
<a> f . setListeners ( am . getAnnotation ( Suspend . class ) . listeners ( ) ) ; </a> 0
<a> list . addFirst ( f ) ; </a> 0
<a> } </a> 0
<a> if ( am . isAnnotationPresent ( Subscribe . class ) ) { </a> 0
<a> boolean trackable = false ; </a> 0
<a> if ( TrackableResource . class . isAssignableFrom ( am . getMethod ( ) . getReturnType ( ) ) ) { </a> 0
<a> trackable = true ; </a> 0
<a> } </a> 0
<a> f = new Filter ( trackable ? Action . SUBSCRIBE_TRACKABLE : Action . SUBSCRIBE , 30000 , - 1 , Suspend . SCOPE . APPLICATION , </a> 1
<a> false , null , am . getAnnotation ( Subscribe . class ) . value ( ) ) ; </a> 0
<a> f . setListeners ( am . getAnnotation ( Subscribe . class ) . listeners ( ) ) ; </a> 0
<a> list . addFirst ( f ) ; </a> 0
<a> } </a> 0
<a> if ( am . isAnnotationPresent ( Publish . class ) ) { </a> 0
<a> f = new Filter ( Action . PUBLISH , - 1 , - 1 , Suspend . SCOPE . APPLICATION , </a> 0
<a> false , null , am . getAnnotation ( Publish . class ) . value ( ) ) ; </a> 0
<a> list . addFirst ( f ) ; </a> 0
<a> } </a> 0
<a> if ( am . isAnnotationPresent ( Resume . class ) ) { </a> 0
<a> int suspendTimeout = am . getAnnotation ( Resume . class ) . value ( ) ; </a> 0
<a> list . addFirst ( new Filter ( Action . RESUME , suspendTimeout ) ) ; </a> 0
<a> } </a> 0
<a> if ( am . isAnnotationPresent ( Schedule . class ) ) { </a> 0
<a> int period = am . getAnnotation ( Schedule . class ) . period ( ) ; </a> 0
<a> int waitFor = am . getAnnotation ( Schedule . class ) . waitFor ( ) ; </a> 0
<a> if ( am . getAnnotation ( Schedule . class ) . resumeOnBroadcast ( ) ) { </a> 0
<a> list . addFirst ( new Filter ( Action . SCHEDULE_RESUME , period , waitFor ) ) ; </a> 0
<a> } else { </a> 0
<a> list . addFirst ( new Filter ( Action . SCHEDULE , period , waitFor ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return list . size ( ) > 0 ? list : null ; </a> 1
<a> } </a> 0
<a> private long translateTimeUnit ( long period , TimeUnit tu ) { </a> 0
<a> if ( period == - 1 ) return period ; </a> 0
<a> switch ( tu ) { </a> 0
<a> case SECONDS : </a> 0
<a> return TimeUnit . MILLISECONDS . convert ( period , TimeUnit . SECONDS ) ; </a> 0
<a> case MINUTES : </a> 0
<a> return TimeUnit . MILLISECONDS . convert ( period , TimeUnit . MINUTES ) ; </a> 0
<a> case HOURS : </a> 0
<a> return TimeUnit . MILLISECONDS . convert ( period , TimeUnit . HOURS ) ; </a> 0
<a> case DAYS : </a> 0
<a> return TimeUnit . MILLISECONDS . convert ( period , TimeUnit . DAYS ) ; </a> 0
<a> case MILLISECONDS : </a> 0
<a> return period ; </a> 0
<a> case MICROSECONDS : </a> 0
<a> return TimeUnit . MILLISECONDS . convert ( period , TimeUnit . MICROSECONDS ) ; </a> 0
<a> case NANOSECONDS : </a> 0
<a> return TimeUnit . MILLISECONDS . convert ( period , TimeUnit . NANOSECONDS ) ; </a> 0
<a> } </a> 0
<a> return period ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey ; </a> 0
<a> import com . sun . jersey . spi . StringReader ; </a> 0
<a> import com . sun . jersey . spi . StringReaderProvider ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 1
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import org . atmosphere . cpr . FrameworkConfig ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . ws . rs . WebApplicationException ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import java . lang . annotation . Annotation ; </a> 0
<a> import java . lang . reflect . Type ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . X_ATMOSPHERE_TRACKING_ID ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . X_ATMOSPHERE_TRANSPORT ; </a> 0
<a> import static org . atmosphere . cpr . FrameworkConfig . ATMOSPHERE_RESOURCE ; </a> 1
<a> public class AtmosphereProviders { </a> 0
<a> public static class BroadcasterProvider implements StringReaderProvider { </a> 0
<a> @ Context </a> 0
<a> HttpServletRequest req ; </a> 0
<a> @ Override </a> 1
<a> public StringReader getStringReader ( Class type , Type genericType , Annotation [ ] annotations ) { </a> 1
<a> if ( Broadcaster . class . isAssignableFrom ( type ) ) { </a> 0
<a> return new BroadcasterStringReader ( ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 1
<a> @ StringReader . ValidateDefaultValue ( false ) </a> 1
<a> public class BroadcasterStringReader implements StringReader { </a> 0
<a> @ Override </a> 0
<a> public Object fromString ( String topic ) { </a> 0
<a> Broadcaster broadcaster ; </a> 0
<a> try { </a> 0
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > r = </a> 0
<a> ( AtmosphereResource < HttpServletRequest , HttpServletResponse > ) </a> 0
<a> req . getAttribute ( FrameworkConfig . ATMOSPHERE_RESOURCE ) ; </a> 0
<a> BroadcasterFactory bp = ( BroadcasterFactory ) </a> 1
<a> req . getAttribute ( ApplicationConfig . BROADCASTER_FACTORY ) ; </a> 1
<a> broadcaster = bp . lookup ( r . getBroadcaster ( ) . getClass ( ) , topic , true ) ; </a> 1
<a> } catch ( Throwable ex ) { </a> 1
<a> throw new WebApplicationException ( ex ) ; </a> 1
<a> } </a> 1
<a> req . setAttribute ( AtmosphereFilter . INJECTED_BROADCASTER , broadcaster ) ; </a> 0
<a> return broadcaster ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static class TrackableResourceProvider implements StringReaderProvider { </a> 1
<a> @ Context </a> 1
<a> HttpServletRequest req ; </a> 1
<a> @ Override </a> 0
<a> public StringReader getStringReader ( Class type , Type genericType , Annotation [ ] annotations ) { </a> 0
<a> if ( TrackableResource . class . isAssignableFrom ( type ) ) { </a> 1
<a> return new TrackableResourceStringReader ( ) ; </a> 1
<a> } </a> 1
<a> return null ; </a> 1
<a> } </a> 0
<a> @ StringReader . ValidateDefaultValue ( false ) </a> 0
<a> public class TrackableResourceStringReader implements StringReader { </a> 1
<a> @ Override </a> 1
<a> public Object fromString ( String topic ) { </a> 1
<a> TrackableResource < AtmosphereResourceImpl > trackableResource = null ; </a> 1
<a> try { </a> 1
<a> String trackingId = req . getHeader ( X_ATMOSPHERE_TRACKING_ID ) ; </a> 1
<a> if ( trackingId == null ) { </a> 1
<a> trackingId = ( String ) req . getAttribute ( X_ATMOSPHERE_TRACKING_ID ) ; </a> 1
<a> } </a> 1
<a> if ( trackingId != null ) { </a> 1
<a> trackableResource = ( TrackableResource < AtmosphereResourceImpl > ) TrackableSession . getDefault ( ) . lookup ( trackingId ) ; </a> 1
<a> if ( req . getAttribute ( ApplicationConfig . SUPPORT_TRACKABLE ) != null ) { </a> 1
<a> AtmosphereResource < ? , ? > r = ( AtmosphereResource < ? , ? > ) req . getAttribute ( ATMOSPHERE_RESOURCE ) ; </a> 0
<a> if ( trackableResource == null && r != null && r . getAtmosphereResourceEvent ( ) . isSuspended ( ) ) { </a> 0
<a> trackableResource = new TrackableResource < AtmosphereResourceImpl > ( AtmosphereResourceImpl . class , trackingId , "" ) ; </a> 1
<a> trackableResource . setResource ( r ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> req . setAttribute ( AtmosphereFilter . INJECTED_TRACKABLE , trackableResource ) ; </a> 1
<a> } </a> 1
<a> } catch ( Throwable ex ) { </a> 0
<a> throw new WebApplicationException ( ex ) ; </a> 0
<a> } </a> 0
<a> return trackableResource ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> public class Broadcastable { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( Broadcastable . class ) ; </a> 0
<a> private final Object message ; </a> 0
<a> private final Broadcaster b ; </a> 0
<a> private final Object callerMessage ; </a> 0
<a> public Broadcastable ( Broadcaster b ) { </a> 0
<a> this . b = b ; </a> 0
<a> message = "" ; </a> 0
<a> callerMessage = "" ; </a> 0
<a> } </a> 0
<a> public Broadcastable ( Object message , Broadcaster b ) { </a> 0
<a> this . b = b ; </a> 0
<a> this . message = message ; </a> 0
<a> callerMessage = message ; </a> 0
<a> } </a> 0
<a> public Broadcastable ( Object message , Object callerMessage , Broadcaster b ) { </a> 0
<a> this . b = b ; </a> 0
<a> this . message = message ; </a> 0
<a> this . callerMessage = callerMessage ; </a> 0
<a> } </a> 0
<a> public Object broadcast ( ) { </a> 0
<a> try { </a> 0
<a> return b . broadcast ( message ) . get ( ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> logger . error ( "failed to broadcast message: " + message , ex ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public Object getMessage ( ) { </a> 0
<a> return message ; </a> 0
<a> } </a> 0
<a> public Broadcaster getBroadcaster ( ) { </a> 0
<a> return b ; </a> 0
<a> } </a> 0
<a> public Object getResponseMessage ( ) { </a> 0
<a> return callerMessage ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey ; </a> 0
<a> import com . sun . jersey . core . spi . component . ComponentContext ; </a> 0
<a> import com . sun . jersey . core . spi . component . ComponentScope ; </a> 0
<a> import com . sun . jersey . spi . inject . Injectable ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import java . lang . reflect . InvocationHandler ; </a> 0
<a> import java . lang . reflect . Method ; </a> 0
<a> import java . lang . reflect . Proxy ; </a> 0
<a> import java . lang . reflect . Type ; </a> 0
<a> abstract class BroadcasterInjector extends BaseInjectableProvider { </a> 0
<a> boolean isValidType ( Type t ) { </a> 0
<a> return ( t instanceof Class ) && Broadcaster . class . isAssignableFrom ( ( Class ) t ) ; </a> 0
<a> } </a> 0
<a> public static final class PerRequest extends BroadcasterInjector { </a> 0
<a> @ Override </a> 0
<a> public ComponentScope getScope ( ) { </a> 0
<a> return ComponentScope . PerRequest ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Injectable getInjectable ( ComponentContext ic , Context a , Type t ) { </a> 0
<a> if ( ! isValidType ( t ) ) </a> 0
<a> return null ; </a> 0
<a> return new Injectable < Broadcaster > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Broadcaster getValue ( ) { </a> 0
<a> return getAtmosphereResource ( Broadcaster . class , true ) . getBroadcaster ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final class Singleton extends BroadcasterInjector { </a> 0
<a> @ Override </a> 0
<a> public ComponentScope getScope ( ) { </a> 0
<a> return ComponentScope . Singleton ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Injectable getInjectable ( ComponentContext ic , Context a , Type t ) { </a> 0
<a> if ( ! isValidType ( t ) ) </a> 0
<a> return null ; </a> 0
<a> return new Injectable < Broadcaster > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Broadcaster getValue ( ) { </a> 0
<a> return ( Broadcaster ) Proxy . newProxyInstance ( this . getClass ( ) . getClassLoader ( ) , </a> 0
<a> new Class [ ] { Broadcaster . class } , </a> 0
<a> new InvocationHandler ( ) { </a> 0
<a> @ Override </a> 0
<a> public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { </a> 0
<a> return method . invoke ( getAtmosphereResource ( Broadcaster . class , true ) . getBroadcaster ( ) , </a> 0
<a> args ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey ; </a> 0
<a> import com . sun . jersey . spi . container . ContainerResponse ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 0
<a> import org . atmosphere . jersey . util . JerseyBroadcasterUtil ; </a> 0
<a> public class JerseyBroadcaster extends DefaultBroadcaster { </a> 0
<a> public JerseyBroadcaster ( ) { </a> 0
<a> super ( ) ; </a> 0
<a> setID ( JerseyBroadcaster . class . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> public JerseyBroadcaster ( String id ) { </a> 0
<a> super ( id ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> protected void broadcast ( final AtmosphereResource < ? , ? > r , final AtmosphereResourceEvent e ) { </a> 0
<a> JerseyBroadcasterUtil . broadcast ( r , e ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey ; </a> 0
<a> import com . sun . jersey . api . JResponse ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public class SuspendResponse < E > extends JResponse { </a> 0
<a> private final TimeSpan suspendTimeout ; </a> 0
<a> private final Suspend . SCOPE scope ; </a> 0
<a> private final boolean outputComments ; </a> 0
<a> private final boolean resumeOnBroadcast ; </a> 0
<a> private final Collection < AtmosphereResourceEventListener > listeners ; </a> 0
<a> private final Broadcaster broadcaster ; </a> 0
<a> protected SuspendResponse ( SuspendResponseBuilder < E > b ) { </a> 0
<a> super ( b ) ; </a> 0
<a> this . suspendTimeout = b . suspendTimeout ; </a> 0
<a> this . scope = b . scope ; </a> 0
<a> this . outputComments = b . outputComments ; </a> 0
<a> this . resumeOnBroadcast = b . resumeOnBroadcast ; </a> 0
<a> this . listeners = b . listeners ; </a> 0
<a> this . broadcaster = b . broadcaster ; </a> 0
<a> } </a> 0
<a> public Suspend . SCOPE scope ( ) { </a> 0
<a> return scope ; </a> 0
<a> } </a> 0
<a> public TimeSpan period ( ) { </a> 0
<a> return suspendTimeout ; </a> 0
<a> } </a> 0
<a> public boolean outputComments ( ) { </a> 0
<a> return outputComments ; </a> 0
<a> } </a> 0
<a> public boolean resumeOnBroadcast ( ) { </a> 0
<a> return resumeOnBroadcast ; </a> 0
<a> } </a> 0
<a> public Broadcaster broadcaster ( ) { </a> 0
<a> return broadcaster ; </a> 0
<a> } </a> 0
<a> public Collection < AtmosphereResourceEventListener > listeners ( ) { </a> 0
<a> return Collections . unmodifiableCollection ( listeners ) ; </a> 0
<a> } </a> 0
<a> public static class SuspendResponseBuilder < E > extends AJResponseBuilder < E , SuspendResponseBuilder < E > > { </a> 0
<a> protected TimeSpan suspendTimeout = new TimeSpan ( - 1 , TimeUnit . MILLISECONDS ) ; </a> 0
<a> protected Suspend . SCOPE scope = Suspend . SCOPE . APPLICATION ; </a> 0
<a> protected boolean outputComments = true ; </a> 0
<a> protected boolean resumeOnBroadcast = false ; </a> 0
<a> protected final Collection < AtmosphereResourceEventListener > listeners </a> 0
<a> = new ArrayList < AtmosphereResourceEventListener > ( ) ; </a> 0
<a> private Broadcaster broadcaster ; </a> 0
<a> public SuspendResponseBuilder ( ) { </a> 0
<a> } </a> 0
<a> public SuspendResponseBuilder ( SuspendResponseBuilder < E > that ) { </a> 0
<a> super ( that ) ; </a> 0
<a> } </a> 0
<a> public SuspendResponseBuilder < E > scope ( Suspend . SCOPE scope ) { </a> 0
<a> this . scope = scope ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public SuspendResponseBuilder < E > period ( int suspendTimeout , TimeUnit timeUnit ) { </a> 0
<a> this . suspendTimeout = new TimeSpan ( suspendTimeout , timeUnit ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public SuspendResponseBuilder < E > outputComments ( boolean outputComments ) { </a> 0
<a> this . outputComments = outputComments ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public SuspendResponseBuilder < E > resumeOnBroadcast ( boolean resumeOnBroadcast ) { </a> 0
<a> this . resumeOnBroadcast = resumeOnBroadcast ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public SuspendResponseBuilder < E > broadcaster ( Broadcaster broadcaster ) { </a> 0
<a> this . broadcaster = broadcaster ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public SuspendResponseBuilder < E > addListener ( AtmosphereResourceEventListener e ) { </a> 0
<a> listeners . add ( e ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public SuspendResponse < E > build ( ) { </a> 0
<a> SuspendResponse < E > r = new SuspendResponse < E > ( this ) ; </a> 0
<a> reset ( ) ; </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static class TimeSpan { </a> 0
<a> private final TimeUnit timeUnit ; </a> 0
<a> private final int period ; </a> 0
<a> public TimeSpan ( int period , TimeUnit timeUnit ) { </a> 0
<a> this . period = period ; </a> 0
<a> this . timeUnit = timeUnit ; </a> 0
<a> } </a> 0
<a> public int value ( ) { </a> 0
<a> return period ; </a> 0
<a> } </a> 0
<a> public TimeUnit timeUnit ( ) { </a> 0
<a> return timeUnit ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey ; </a> 0
<a> import org . atmosphere . cpr . Trackable ; </a> 1
<a> import org . slf4j . Logger ; </a> 1
<a> import org . slf4j . LoggerFactory ; </a> 1
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import java . util . concurrent . CountDownLatch ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 1
<a> public class TrackableSession { </a> 1
<a> private static final Logger logger = LoggerFactory . getLogger ( TrackableSession . class ) ; </a> 1
<a> private final static TrackableSession factory = new TrackableSession ( ) ; </a> 1
<a> private final ConcurrentHashMap < String , TrackableResource > factoryCache = new ConcurrentHashMap < String , TrackableResource > ( ) ; </a> 1
<a> private final ConcurrentHashMap < String , CountDownLatch > pendingLock = new ConcurrentHashMap < String , CountDownLatch > ( ) ; </a> 1
<a> private TrackableSession ( ) { </a> 1
<a> } </a> 1
<a> public static TrackableSession getDefault ( ) { </a> 1
<a> return factory ; </a> 1
<a> } </a> 1
<a> public void track ( TrackableResource < ? extends Trackable > trackableResource ) { </a> 1
<a> logger . debug ( "Tracking {}" , trackableResource . trackingID ( ) ) ; </a> 0
<a> factoryCache . put ( trackableResource . trackingID ( ) , trackableResource ) ; </a> 1
<a> CountDownLatch latch = pendingLock . remove ( trackableResource . trackingID ( ) ) ; </a> 1
<a> if ( latch != null ) { </a> 1
<a> latch . countDown ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public TrackableResource < ? extends Trackable > lookup ( String trackingID ) { </a> 1
<a> return factoryCache . get ( trackingID ) ; </a> 1
<a> } </a> 1
<a> public TrackableResource < ? extends Trackable > lookupAndWait ( String trackingID ) { </a> 1
<a> logger . debug ( "Lookup trackinID {}" , trackingID ) ; </a> 1
<a> TrackableResource < ? extends Trackable > r = factoryCache . get ( trackingID ) ; </a> 1
<a> if ( r == null ) { </a> 1
<a> CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 1
<a> pendingLock . put ( trackingID , latch ) ; </a> 1
<a> try { </a> 1
<a> if ( ! latch . await ( 5 , TimeUnit . SECONDS ) ) { </a> 1
<a> } </a> 1
<a> pendingLock . remove ( trackingID ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> logger . trace ( "" , e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return factoryCache . get ( trackingID ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> package org . atmosphere . jersey . util ; </a> 0
<a> import com . sun . jersey . spi . container . ContainerResponse ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereEventLifecycle ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceEventImpl ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 1
<a> import org . atmosphere . cpr . FrameworkConfig ; </a> 0
<a> import org . atmosphere . jersey . AtmosphereFilter ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . ws . rs . core . HttpHeaders ; </a> 0
<a> import javax . ws . rs . core . MediaType ; </a> 1
<a> import javax . ws . rs . core . Response ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> import java . util . List ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 0
<a> public final class JerseyBroadcasterUtil { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( JerseyBroadcasterUtil . class ) ; </a> 0
<a> public final static void broadcast ( final AtmosphereResource < ? , ? > r , final AtmosphereResourceEvent e ) { </a> 1
<a> HttpServletRequest request = ( HttpServletRequest ) r . getRequest ( ) ; </a> 0
<a> try { </a> 1
<a> ContainerResponse cr = ( ContainerResponse ) request . getAttribute ( FrameworkConfig . CONTAINER_RESPONSE ) ; </a> 1
<a> if ( cr == null ) { </a> 0
<a> logger . debug ( "Retrieving HttpServletRequest {} with ContainerResponse {}" , request , cr ) ; </a> 0
<a> logger . error ( "Unexpected state. ContainerResponse cannot be null. The connection hasn't been suspended yet" ) ; </a> 0
<a> r . getBroadcaster ( ) . removeAtmosphereResource ( r ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> MediaType m = ( MediaType ) cr . getHttpHeaders ( ) . getFirst ( HttpHeaders . CONTENT_TYPE ) ; </a> 0
<a> if ( e . getMessage ( ) instanceof Response ) { </a> 0
<a> cr . setResponse ( ( Response ) e . getMessage ( ) ) ; </a> 0
<a> cr . getHttpHeaders ( ) . add ( HttpHeaders . CONTENT_TYPE , m ) ; </a> 0
<a> cr . write ( ) ; </a> 0
<a> cr . getOutputStream ( ) . flush ( ) ; </a> 0
<a> } else if ( e . getMessage ( ) instanceof List ) { </a> 0
<a> for ( Object msg : ( List < Object > ) e . getMessage ( ) ) { </a> 0
<a> cr . setResponse ( Response . ok ( msg ) . build ( ) ) ; </a> 0
<a> cr . getHttpHeaders ( ) . add ( HttpHeaders . CONTENT_TYPE , m ) ; </a> 0
<a> cr . write ( ) ; </a> 0
<a> cr . getOutputStream ( ) . flush ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> cr . setResponse ( Response . ok ( e . getMessage ( ) ) . build ( ) ) ; </a> 0
<a> cr . getHttpHeaders ( ) . add ( HttpHeaders . CONTENT_TYPE , m ) ; </a> 0
<a> cr . write ( ) ; </a> 0
<a> cr . getOutputStream ( ) . flush ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> onException ( t , r ) ; </a> 0
<a> } finally { </a> 0
<a> Boolean resumeOnBroadcast = ( Boolean ) request . getAttribute ( ApplicationConfig . RESUME_ON_BROADCAST ) ; </a> 0
<a> if ( resumeOnBroadcast != null && resumeOnBroadcast ) { </a> 1
<a> String uuid = ( String ) request . getAttribute ( AtmosphereFilter . RESUME_UUID ) ; </a> 0
<a> if ( uuid != null ) { </a> 0
<a> if ( request . getAttribute ( AtmosphereFilter . RESUME_CANDIDATES ) != null ) { </a> 0
<a> ( ( ConcurrentHashMap < String , AtmosphereResource < ? , ? > > ) request . getAttribute ( AtmosphereFilter . RESUME_CANDIDATES ) ) . remove ( uuid ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> r . resume ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } </a> 0
<a> final static void onException ( Throwable t , AtmosphereResource < ? , ? > r ) { </a> 0
<a> try { </a> 0
<a> logger . debug ( "onException()" , t ) ; </a> 0
<a> if ( t instanceof IOException && r instanceof AtmosphereEventLifecycle ) { </a> 0
<a> ( ( AtmosphereEventLifecycle ) r ) . notifyListeners ( new AtmosphereResourceEventImpl ( ( AtmosphereResourceImpl ) r , true , false ) ) ; </a> 0
<a> ( ( AtmosphereEventLifecycle ) r ) . removeEventListeners ( ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> try { </a> 0
<a> r . getBroadcaster ( ) . removeAtmosphereResource ( r ) ; </a> 0
<a> } catch ( IllegalStateException ex ) { </a> 0
<a> logger . trace ( ex . getMessage ( ) , ex ) ; </a> 0
<a> } </a> 0
<a> BroadcasterFactory . getDefault ( ) . removeAllAtmosphereResource ( r ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . util ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . util . SimpleBroadcaster ; </a> 0
<a> public class JerseySimpleBroadcaster extends SimpleBroadcaster { </a> 0
<a> public JerseySimpleBroadcaster ( ) { </a> 0
<a> super ( ) ; </a> 0
<a> setID ( SimpleBroadcaster . class . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> public JerseySimpleBroadcaster ( String id ) { </a> 0
<a> super ( id ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> protected void broadcast ( final AtmosphereResource < ? , ? > r , final AtmosphereResourceEvent e ) { </a> 0
<a> JerseyBroadcasterUtil . broadcast ( r , e ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import com . sun . grizzly . comet . CometAsyncFilter ; </a> 0
<a> import com . sun . grizzly . http . embed . GrizzlyWebServer ; </a> 0
<a> import com . sun . grizzly . http . servlet . ServletAdapter ; </a> 0
<a> import org . atmosphere . container . GrizzlyCometSupport ; </a> 0
<a> public abstract class BaseGrizzyTest extends BaseTest { </a> 0
<a> protected GrizzlyWebServer ws ; </a> 0
<a> protected ServletAdapter sa ; </a> 0
<a> @ Override </a> 0
<a> public void configureCometSupport ( ) { </a> 0
<a> atmoServlet . setCometSupport ( new GrizzlyCometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void startServer ( ) throws Exception { </a> 0
<a> ws = new GrizzlyWebServer ( port ) ; </a> 0
<a> sa = new ServletAdapter ( ) ; </a> 0
<a> ws . addAsyncFilter ( new CometAsyncFilter ( ) ) ; </a> 0
<a> sa . setServletInstance ( atmoServlet ) ; </a> 0
<a> ws . addGrizzlyAdapter ( sa , new String [ ] { ROOT } ) ; </a> 0
<a> ws . start ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void stopServer ( ) throws Exception { </a> 0
<a> ws . stop ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import com . ning . http . client . AsyncCompletionHandler ; </a> 0
<a> import com . ning . http . client . AsyncHandler ; </a> 0
<a> import com . ning . http . client . AsyncHttpClient ; </a> 0
<a> import com . ning . http . client . HttpResponseBodyPart ; </a> 0
<a> import com . ning . http . client . HttpResponseHeaders ; </a> 0
<a> import com . ning . http . client . HttpResponseStatus ; </a> 0
<a> import com . ning . http . client . Response ; </a> 0
<a> import org . atmosphere . cache . HeaderBroadcasterCache ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceImpl ; </a> 0
<a> import org . atmosphere . cpr . HeaderConfig ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import org . testng . annotations . Test ; </a> 0
<a> import java . util . concurrent . CountDownLatch ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 0
<a> import static org . testng . Assert . assertEquals ; </a> 0
<a> import static org . testng . Assert . assertNotNull ; </a> 0
<a> import static org . testng . Assert . assertTrue ; </a> 0
<a> import static org . testng . Assert . fail ; </a> 0
<a> public abstract class BasePubSubTest extends BaseTest { </a> 0
<a> protected static final Logger logger = LoggerFactory . getLogger ( BasePubSubTest . class ) ; </a> 0
<a> String getUrlTarget ( int port ) { </a> 0
<a> return "http://127.0.0.1:" + port + "/invoke" ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testSuspendTimeout ( ) { </a> 0
<a> logger . info ( "{}: running test: testSuspendTimeout" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( 10 , TimeUnit . SECONDS ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> String resume = r . getResponseBody ( ) ; </a> 0
<a> assertEquals ( resume , "resume" ) ; </a> 0
<a> long current = System . currentTimeMillis ( ) - t1 ; </a> 0
<a> assertTrue ( current > 5000 && current < 10000 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testSuspendWithCommentsTimeout ( ) { </a> 0
<a> logger . info ( "{}: running test: testSuspendWithCommentsTimeout" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> Response r = c . prepareGet ( urlTarget + "/withComments" ) . execute ( ) . get ( 10 , TimeUnit . SECONDS ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> String resume = r . getResponseBody ( ) ; </a> 0
<a> String [ ] ct = r . getContentType ( ) . toLowerCase ( ) . split ( ";" ) ; </a> 0
<a> assertEquals ( ct [ 0 ] . trim ( ) , "text/plain" ) ; </a> 0
<a> assertEquals ( ct [ 1 ] . trim ( ) , "charset=iso-8859-1" ) ; </a> 1
<a> assertEquals ( resume , AtmosphereResourceImpl . createCompatibleStringJunk ( ) ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = false ) </a> 0
<a> public void testProgrammaticDisconnection ( ) { </a> 0
<a> logger . info ( "{}: running test: testProgrammaticDisconnection" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> try { </a> 0
<a> Response r = c . prepareGet ( urlTarget + "/forever" ) . execute ( ) . get ( 30 , TimeUnit . SECONDS ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> } </a> 0
<a> long current = System . currentTimeMillis ( ) - t1 ; </a> 0
<a> assertTrue ( current > 20000 && current < 25000 ) ; </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testProgrammaticResume ( ) { </a> 0
<a> logger . info ( "{}: running test: testProgrammaticResume" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> final AtomicReference < String > location = new AtomicReference < String > ( ) ; </a> 0
<a> final AtomicReference < String > response = new AtomicReference < String > ( "" ) ; </a> 0
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> final CountDownLatch locationLatch = new CountDownLatch ( 1 ) ; </a> 0
<a> try { </a> 0
<a> c . prepareGet ( urlTarget + "/suspendAndResume" ) . execute ( new AsyncHandler < String > ( ) { </a> 0
<a> public void onThrowable ( Throwable throwable ) { </a> 0
<a> fail ( "onThrowable" , throwable ) ; </a> 0
<a> } </a> 0
<a> public STATE onBodyPartReceived ( HttpResponseBodyPart bp ) throws Exception { </a> 0
<a> logger . info ( "body part byte string: {}" , new String ( bp . getBodyPartBytes ( ) ) ) ; </a> 0
<a> response . set ( response . get ( ) + new String ( bp . getBodyPartBytes ( ) ) ) ; </a> 0
<a> locationLatch . countDown ( ) ; </a> 0
<a> return STATE . CONTINUE ; </a> 0
<a> } </a> 0
<a> public STATE onStatusReceived ( HttpResponseStatus hs ) throws Exception { </a> 0
<a> return STATE . CONTINUE ; </a> 0
<a> } </a> 0
<a> public STATE onHeadersReceived ( HttpResponseHeaders rh ) throws Exception { </a> 0
<a> location . set ( rh . getHeaders ( ) . getFirstValue ( "Location" ) ) ; </a> 0
<a> return STATE . CONTINUE ; </a> 0
<a> } </a> 0
<a> public String onCompleted ( ) throws Exception { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> locationLatch . await ( 5 , TimeUnit . SECONDS ) ; </a> 0
<a> Response r = c . prepareGet ( location . get ( ) ) . execute ( ) . get ( 10 , TimeUnit . SECONDS ) ; </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> assertEquals ( response . get ( ) , "suspendresume" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testResumeOnBroadcastUsingBroadcasterFactory ( ) { </a> 0
<a> logger . info ( "{}: running test: testResumeOnBroadcast" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> try { </a> 0
<a> Response r = c . prepareGet ( urlTarget + "/subscribeAndUsingExternalThread" ) . execute ( ) . get ( ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> long current = System . currentTimeMillis ( ) - t1 ; </a> 0
<a> assertTrue ( current > 5000 && current < 10000 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testDelayBroadcast ( ) { </a> 0
<a> logger . info ( "{}: running test: testDelayBroadcast" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> final AtomicReference < Response > response = new AtomicReference < Response > ( ) ; </a> 0
<a> c . prepareGet ( urlTarget + "/forever" ) . execute ( new AsyncCompletionHandler < Response > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Response onCompleted ( Response r ) throws Exception { </a> 0
<a> try { </a> 0
<a> response . set ( r ) ; </a> 0
<a> return r ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Thread . sleep ( 2500 ) ; </a> 0
<a> c . preparePost ( urlTarget + "/delay" ) . addParameter ( "message" , "foo" ) . execute ( ) . get ( ) ; </a> 0
<a> c . preparePost ( urlTarget + "/publishAndResume" ) . addParameter ( "message" , "bar" ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> Response r = response . get ( ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getResponseBody ( ) , AtmosphereResourceImpl . createCompatibleStringJunk ( ) + "foo\nbar\n" ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testDelayNextBroadcast ( ) { </a> 0
<a> logger . info ( "{}: running test: testDelayNextBroadcast" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> final AtomicReference < Response > response = new AtomicReference < Response > ( ) ; </a> 0
<a> c . prepareGet ( urlTarget + "/forever" ) . execute ( new AsyncCompletionHandler < Response > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Response onCompleted ( Response r ) throws Exception { </a> 0
<a> try { </a> 0
<a> response . set ( r ) ; </a> 0
<a> return r ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Thread . sleep ( 2500 ) ; </a> 0
<a> c . preparePost ( urlTarget + "/delay" ) . addParameter ( "message" , "foo" ) . execute ( ) . get ( ) ; </a> 0
<a> c . preparePost ( urlTarget + "/delayAndResume" ) . addParameter ( "message" , "bar" ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> Response r = response . get ( ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getResponseBody ( ) , AtmosphereResourceImpl . createCompatibleStringJunk ( ) + "foo\nbar\n" ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> long current = System . currentTimeMillis ( ) - t1 ; </a> 0
<a> assertTrue ( current > 5000 && current < 10000 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testScheduleBroadcast ( ) { </a> 0
<a> logger . info ( "{}: running test: testScheduleBroadcast" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> final AtomicReference < Response > response = new AtomicReference < Response > ( ) ; </a> 0
<a> c . prepareGet ( urlTarget + "/foreverWithoutComments" ) . execute ( new AsyncCompletionHandler < Response > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Response onCompleted ( Response r ) throws Exception { </a> 0
<a> try { </a> 0
<a> response . set ( r ) ; </a> 0
<a> return r ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Thread . sleep ( 2500 ) ; </a> 0
<a> c . preparePost ( urlTarget + "/scheduleAndResume" ) . addParameter ( "message" , "foo" ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> Response r = response . get ( ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> assertEquals ( r . getResponseBody ( ) , "foo\n" ) ; </a> 0
<a> long current = System . currentTimeMillis ( ) - t1 ; </a> 0
<a> assertTrue ( current > 5000 && current < 10000 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testBroadcastFilter ( ) { </a> 0
<a> logger . info ( "{}: running test: testBroadcastFilter" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> final AtomicReference < Response > response = new AtomicReference < Response > ( ) ; </a> 0
<a> c . prepareGet ( urlTarget + "/foreverWithoutComments" ) . execute ( new AsyncCompletionHandler < Response > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Response onCompleted ( Response r ) throws Exception { </a> 0
<a> try { </a> 0
<a> response . set ( r ) ; </a> 0
<a> return r ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Thread . sleep ( 2500 ) ; </a> 0
<a> c . preparePost ( urlTarget + "/filter" ) . addParameter ( "message" , "<script>foo</script>" ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> Response r = response . get ( ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> assertEquals ( r . getResponseBody ( ) , "&lt;script&gt;foo&lt;/script&gt;<br />" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testAggregateFilter ( ) { </a> 0
<a> logger . info ( "{}: running test: testAggregateFilter" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> final AtomicReference < Response > response = new AtomicReference < Response > ( ) ; </a> 0
<a> c . prepareGet ( urlTarget + "/foreverWithoutComments" ) . execute ( new AsyncCompletionHandler < Response > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Response onCompleted ( Response r ) throws Exception { </a> 0
<a> try { </a> 0
<a> response . set ( r ) ; </a> 0
<a> return r ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Thread . sleep ( 2500 ) ; </a> 0
<a> for ( int i = 0 ; i < 10 ; i ++ ) { </a> 0
<a> c . preparePost ( urlTarget + "/aggregate" ) . addParameter ( "message" , </a> 0
<a> "==================================================" ) . execute ( ) . get ( 5 , TimeUnit . SECONDS ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> Response r = response . get ( ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> assertEquals ( r . getResponseBody ( ) , "==================================================\n" + </a> 0
<a> "==================================================\n" + </a> 0
<a> "==================================================\n" + </a> 0
<a> "==================================================\n" + </a> 0
<a> "==================================================\n" + </a> 0
<a> "==================================================\n" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testHeaderBroadcasterCache ( ) throws IllegalAccessException , ClassNotFoundException , InstantiationException { </a> 0
<a> logger . info ( "{}: running test: testHeaderBroadcasterCache" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> atmoServlet . setBroadcasterCacheClassName ( HeaderBroadcasterCache . class . getName ( ) ) ; </a> 0
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> c . preparePost ( urlTarget ) . addParameter ( "message" , "cacheme" ) . execute ( ) . get ( ) ; </a> 0
<a> c . preparePost ( urlTarget ) . addParameter ( "message" , "cachememe" ) . execute ( ) . get ( ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget + "/subscribeAndResume" ) . addHeader ( HeaderConfig . X_CACHE_DATE , String . valueOf ( t1 ) ) . execute ( new AsyncCompletionHandler < Response > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Response onCompleted ( Response r ) throws Exception { </a> 0
<a> try { </a> 0
<a> return r ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> assertEquals ( r . getResponseBody ( ) , "cacheme\ncachememe\n" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testProgrammaticDelayBroadcast ( ) { </a> 0
<a> logger . info ( "{}: running test: testDelayBroadcast" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> final AtomicReference < Response > response = new AtomicReference < Response > ( ) ; </a> 0
<a> c . prepareGet ( urlTarget + "/forever" ) . execute ( new AsyncCompletionHandler < Response > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Response onCompleted ( Response r ) throws Exception { </a> 0
<a> try { </a> 0
<a> response . set ( r ) ; </a> 0
<a> return r ; </a> 0
<a> } finally { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Thread . sleep ( 2500 ) ; </a> 0
<a> c . preparePost ( urlTarget + "/programmaticDelayBroadcast" ) . addParameter ( "message" , "foo" ) . execute ( ) . get ( ) ; </a> 0
<a> c . preparePost ( urlTarget + "/publishAndResume" ) . addParameter ( "message" , "bar" ) . execute ( ) . get ( ) ; </a> 0
<a> try { </a> 0
<a> latch . await ( 20 , TimeUnit . SECONDS ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> Response r = response . get ( ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getResponseBody ( ) , AtmosphereResourceImpl . createCompatibleStringJunk ( ) + "foobar\n" ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import org . testng . annotations . AfterMethod ; </a> 0
<a> import org . testng . annotations . BeforeMethod ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . ServerSocket ; </a> 0
<a> public abstract class BaseTest { </a> 0
<a> protected static final Logger logger = LoggerFactory . getLogger ( BaseTest . class ) ; </a> 0
<a> protected static final String ROOT = "/*" ; </a> 0
<a> protected AtmosphereServlet atmoServlet ; </a> 0
<a> public String urlTarget ; </a> 0
<a> public int port ; </a> 0
<a> abstract public void configureCometSupport ( ) ; </a> 0
<a> abstract public void startServer ( ) throws Exception ; </a> 0
<a> abstract public void stopServer ( ) throws Exception ; </a> 0
<a> public static class TestHelper { </a> 0
<a> public static int getEnvVariable ( final String varName , int defaultValue ) { </a> 0
<a> if ( null == varName ) { </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> String varValue = System . getenv ( varName ) ; </a> 0
<a> if ( null != varValue ) { </a> 0
<a> try { </a> 0
<a> return Integer . parseInt ( varValue ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected int findFreePort ( ) throws IOException { </a> 0
<a> ServerSocket socket = null ; </a> 0
<a> try { </a> 0
<a> socket = new ServerSocket ( 0 ) ; </a> 0
<a> return socket . getLocalPort ( ) ; </a> 0
<a> } finally { </a> 0
<a> if ( socket != null ) { </a> 0
<a> socket . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ BeforeMethod ( alwaysRun = true ) </a> 0
<a> public void setUpGlobal ( ) throws Exception { </a> 0
<a> port = TestHelper . getEnvVariable ( "ATMOSPHERE_HTTP_PORT" , findFreePort ( ) ) ; </a> 0
<a> urlTarget = getUrlTarget ( port ) ; </a> 0
<a> atmoServlet = new AtmosphereServlet ( ) ; </a> 0
<a> atmoServlet . addInitParameter ( "com.sun.jersey.config.property.packages" , this . getClass ( ) . getPackage ( ) . getName ( ) ) ; </a> 0
<a> atmoServlet . addInitParameter ( "org.atmosphere.cpr.broadcasterClass" , RecyclableBroadcaster . class . getName ( ) ) ; </a> 0
<a> configureCometSupport ( ) ; </a> 0
<a> startServer ( ) ; </a> 0
<a> } </a> 0
<a> abstract String getUrlTarget ( int port ) ; </a> 0
<a> @ AfterMethod ( alwaysRun = true ) </a> 0
<a> public void unsetAtmosphereHandler ( ) throws Exception { </a> 0
<a> if ( atmoServlet != null ) atmoServlet . destroy ( ) ; </a> 0
<a> stopServer ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . annotation . Resume ; </a> 0
<a> import org . atmosphere . annotation . Schedule ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import org . atmosphere . jersey . Broadcastable ; </a> 0
<a> import org . atmosphere . jersey . JerseyBroadcaster ; </a> 0
<a> import org . atmosphere . jersey . SuspendResponse ; </a> 0
<a> import org . atmosphere . util . StringFilterAggregator ; </a> 0
<a> import org . atmosphere . util . XSSHtmlFilter ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import java . util . concurrent . ExecutionException ; </a> 0
<a> import java . util . concurrent . Executors ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> @ Path ( "/builder/{topic}" ) </a> 0
<a> @ Produces ( "text/plain;charset=ISO-8859-1" ) </a> 0
<a> public class BuilderPubSubTest { </a> 0
<a> private </a> 0
<a> @ PathParam ( "topic" ) </a> 0
<a> Broadcaster broadcaster ; </a> 0
<a> @ GET </a> 0
<a> public SuspendResponse < String > suspendUsingAPI ( ) { </a> 0
<a> SuspendResponse < String > r = new SuspendResponse . SuspendResponseBuilder < String > ( ) </a> 0
<a> . entity ( "resume" ) </a> 0
<a> . broadcaster ( broadcaster ) </a> 0
<a> . outputComments ( false ) </a> 0
<a> . resumeOnBroadcast ( true ) </a> 0
<a> . period ( 5 , TimeUnit . SECONDS ) </a> 0
<a> . build ( ) ; </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "scope" ) </a> 0
<a> public SuspendResponse < String > suspendScopeRequestWithAPI ( @ PathParam ( "topic" ) Broadcaster b ) throws ExecutionException , InterruptedException { </a> 0
<a> SuspendResponse < String > r = new SuspendResponse . SuspendResponseBuilder < String > ( ) </a> 0
<a> . entity ( "bar" ) </a> 0
<a> . broadcaster ( broadcaster ) </a> 0
<a> . scope ( Suspend . SCOPE . REQUEST ) </a> 0
<a> . outputComments ( false ) </a> 0
<a> . resumeOnBroadcast ( true ) </a> 0
<a> . period ( 5 , TimeUnit . SECONDS ) </a> 0
<a> . build ( ) ; </a> 0
<a> b . broadcast ( "foo" ) . get ( ) ; </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "withComments" ) </a> 0
<a> public SuspendResponse < String > subscribeWithCommentsWithAPI ( ) { </a> 0
<a> SuspendResponse < String > r = new SuspendResponse . SuspendResponseBuilder < String > ( ) </a> 0
<a> . broadcaster ( broadcaster ) </a> 0
<a> . outputComments ( true ) </a> 0
<a> . period ( 5 , TimeUnit . SECONDS ) </a> 0
<a> . build ( ) ; </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "forever" ) </a> 0
<a> public SuspendResponse < String > suspendForeverWithAPI ( ) { </a> 0
<a> SuspendResponse < String > r = new SuspendResponse . SuspendResponseBuilder < String > ( ) </a> 0
<a> . broadcaster ( broadcaster ) </a> 0
<a> . outputComments ( true ) </a> 0
<a> . entity ( "" ) </a> 0
<a> . build ( ) ; </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "foreverWithoutComments" ) </a> 0
<a> public SuspendResponse < String > suspendForeverWithoutCommentsWithAPI ( ) { </a> 0
<a> SuspendResponse < String > r = new SuspendResponse . SuspendResponseBuilder < String > ( ) </a> 0
<a> . broadcaster ( broadcaster ) </a> 0
<a> . outputComments ( false ) </a> 0
<a> . entity ( "" ) </a> 0
<a> . build ( ) ; </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "subscribeAndUsingExternalThread" ) </a> 0
<a> public SuspendResponse < String > subscribeAndResumeUsingExternalThreadWithAPI ( final @ PathParam ( "topic" ) String topic ) { </a> 0
<a> Executors . newSingleThreadExecutor ( ) . submit ( new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 5000 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> BroadcasterFactory . getDefault ( ) . lookup ( JerseyBroadcaster . class , topic ) . broadcast ( "Echo: " + topic ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> SuspendResponse < String > r = new SuspendResponse . SuspendResponseBuilder < String > ( ) </a> 0
<a> . broadcaster ( broadcaster ) </a> 0
<a> . resumeOnBroadcast ( true ) </a> 0
<a> . entity ( "foo" ) </a> 0
<a> . build ( ) ; </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "suspendAndResume" ) </a> 0
<a> @ Suspend ( outputComments = false ) </a> 0
<a> public SuspendResponse < String > suspendWithAPI ( ) { </a> 0
<a> SuspendResponse < String > r = new SuspendResponse . SuspendResponseBuilder < String > ( ) </a> 0
<a> . outputComments ( false ) </a> 0
<a> . entity ( "suspend" ) </a> 0
<a> . build ( ) ; </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "subscribeAndResume" ) </a> 0
<a> public SuspendResponse < String > subscribeAndResumeWithAPI ( ) { </a> 0
<a> SuspendResponse < String > r = new SuspendResponse . SuspendResponseBuilder < String > ( ) </a> 0
<a> . outputComments ( false ) </a> 0
<a> . resumeOnBroadcast ( true ) </a> 0
<a> . build ( ) ; </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Resume </a> 0
<a> @ Path ( "suspendAndResume/{uuid}" ) </a> 0
<a> public String resume ( ) throws ExecutionException , InterruptedException { </a> 0
<a> broadcaster . broadcast ( "resume" ) . get ( ) ; </a> 0
<a> return "resumed" ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Broadcast </a> 0
<a> public Broadcastable publish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "publishAndResume" ) </a> 0
<a> @ Broadcast ( resumeOnBroadcast = true ) </a> 0
<a> public Broadcastable publishAndResume ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "filter" ) </a> 0
<a> @ Broadcast ( resumeOnBroadcast = true , value = { XSSHtmlFilter . class } ) </a> 1
<a> public Broadcastable filter ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "aggregate" ) </a> 0
<a> @ Broadcast ( resumeOnBroadcast = true , value = { StringFilterAggregator . class } ) </a> 1
<a> public Broadcastable aggregate ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 5 , resumeOnBroadcast = true , waitFor = 5 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "scheduleAndResume" ) </a> 0
<a> public Broadcastable scheduleAndResume ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 10 , waitFor = 5 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "delaySchedule" ) </a> 0
<a> public Broadcastable delaySchedule ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 5 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "schedule" ) </a> 0
<a> public Broadcastable schedule ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Broadcast ( delay = 0 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "delay" ) </a> 0
<a> public Broadcastable delayPublish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Broadcast ( delay = 5 , resumeOnBroadcast = true ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "delayAndResume" ) </a> 0
<a> public Broadcastable delayPublishAndResume ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "programmaticDelayBroadcast" ) </a> 0
<a> public String manualDelayBroadcast ( @ FormParam ( "message" ) String message ) { </a> 0
<a> broadcaster . delayBroadcast ( message ) ; </a> 0
<a> return message ; </a> 0
<a> } </a> 0
<a> Broadcastable broadcast ( String m ) { </a> 0
<a> return new Broadcastable ( m + "\n" , broadcaster ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "204" ) </a> 0
<a> public SuspendResponse < String > suspend204 ( ) { </a> 0
<a> SuspendResponse < String > r = new SuspendResponse . SuspendResponseBuilder < String > ( ) </a> 0
<a> . broadcaster ( broadcaster ) </a> 0
<a> . outputComments ( false ) </a> 0
<a> . resumeOnBroadcast ( true ) </a> 0
<a> . period ( 5 , TimeUnit . SECONDS ) </a> 0
<a> . build ( ) ; </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import com . ning . http . client . AsyncHttpClient ; </a> 0
<a> import com . ning . http . client . Response ; </a> 0
<a> import org . atmosphere . container . BlockingIOCometSupport ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . testng . annotations . BeforeMethod ; </a> 0
<a> import org . testng . annotations . Test ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import static org . testng . Assert . assertEquals ; </a> 0
<a> import static org . testng . Assert . assertNotNull ; </a> 0
<a> import static org . testng . Assert . assertTrue ; </a> 0
<a> import static org . testng . Assert . fail ; </a> 0
<a> public class BuilderResponseTest extends BlockingIOJerseyTest { </a> 0
<a> @ Override </a> 0
<a> public void configureCometSupport ( ) { </a> 0
<a> atmoServlet . setCometSupport ( new BlockingIOCometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> @ BeforeMethod ( alwaysRun = true ) </a> 0
<a> public void setUpGlobal ( ) throws Exception { </a> 0
<a> port = TestHelper . getEnvVariable ( "ATMOSPHERE_HTTP_PORT" , findFreePort ( ) ) ; </a> 0
<a> urlTarget = "http://127.0.0.1:" + port + "/builder/invoke" ; </a> 0
<a> atmoServlet = new AtmosphereServlet ( ) ; </a> 0
<a> atmoServlet . addInitParameter ( "com.sun.jersey.config.property.packages" , this . getClass ( ) . getPackage ( ) . getName ( ) ) ; </a> 0
<a> configureCometSupport ( ) ; </a> 0
<a> startServer ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void test200WithNoContent ( ) { </a> 0
<a> logger . info ( "{}: running test: test200WithNoContent" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> urlTarget = "http://127.0.0.1:" + port + "/builder/invoke/204" ; </a> 0
<a> try { </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( 10 , TimeUnit . SECONDS ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> String resume = r . getResponseBody ( ) ; </a> 0
<a> long current = System . currentTimeMillis ( ) - t1 ; </a> 0
<a> assertTrue ( current > 5000 && current < 10000 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import com . ning . http . client . AsyncCompletionHandler ; </a> 0
<a> import com . ning . http . client . AsyncHttpClient ; </a> 0
<a> import com . ning . http . client . Response ; </a> 0
<a> import com . sun . grizzly . comet . CometAsyncFilter ; </a> 0
<a> import com . sun . grizzly . http . embed . GrizzlyWebServer ; </a> 0
<a> import com . sun . grizzly . http . servlet . ServletAdapter ; </a> 0
<a> import org . atmosphere . cache . HeaderBroadcasterCache ; </a> 0
<a> import org . atmosphere . container . GrizzlyCometSupport ; </a> 0
<a> import org . testng . annotations . Test ; </a> 0
<a> import java . util . concurrent . CountDownLatch ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import static org . testng . Assert . assertEquals ; </a> 0
<a> import static org . testng . Assert . assertNotNull ; </a> 0
<a> import static org . testng . Assert . fail ; </a> 0
<a> public class GrizzlyJerseyTest extends BasePubSubTest { </a> 0
<a> protected GrizzlyWebServer ws ; </a> 0
<a> protected ServletAdapter sa ; </a> 0
<a> @ Override </a> 0
<a> public void configureCometSupport ( ) { </a> 0
<a> atmoServlet . setCometSupport ( new GrizzlyCometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void startServer ( ) throws Exception { </a> 0
<a> ws = new GrizzlyWebServer ( port ) ; </a> 0
<a> sa = new ServletAdapter ( ) ; </a> 0
<a> ws . addAsyncFilter ( new CometAsyncFilter ( ) ) ; </a> 0
<a> sa . setServletInstance ( atmoServlet ) ; </a> 0
<a> ws . addGrizzlyAdapter ( sa , new String [ ] { ROOT } ) ; </a> 0
<a> ws . start ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void stopServer ( ) throws Exception { </a> 0
<a> ws . stop ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = false ) </a> 0
<a> public void testHeaderBroadcasterCache ( ) throws IllegalAccessException , ClassNotFoundException , InstantiationException { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import org . atmosphere . container . JettyCometSupport ; </a> 0
<a> import org . mortbay . jetty . Connector ; </a> 0
<a> import org . mortbay . jetty . Server ; </a> 0
<a> import org . mortbay . jetty . nio . SelectChannelConnector ; </a> 0
<a> import org . mortbay . jetty . servlet . Context ; </a> 0
<a> import org . mortbay . jetty . servlet . ServletHolder ; </a> 0
<a> public class Jetty6JerseyTest extends BlockingIOJerseyTest { </a> 0
<a> @ Override </a> 0
<a> public void startServer ( ) throws Exception { </a> 0
<a> server = new Server ( port ) ; </a> 0
<a> root = new Context ( server , "/" , Context . SESSIONS ) ; </a> 0
<a> root . addServlet ( new ServletHolder ( atmoServlet ) , ROOT ) ; </a> 0
<a> Connector listener = new SelectChannelConnector ( ) ; </a> 0
<a> listener . setHost ( "127.0.0.1" ) ; </a> 0
<a> listener . setPort ( TestHelper . getEnvVariable ( "ATMOSPHERE_HTTP_PORT" , findFreePort ( ) ) ) ; </a> 0
<a> server . addConnector ( listener ) ; </a> 0
<a> server . start ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void configureCometSupport ( ) { </a> 0
<a> atmoServlet . setCometSupport ( new JettyCometSupport ( atmoServlet . getAtmosphereConfig ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> @ Path ( "/perrequest" ) </a> 0
<a> @ Produces ( "text/plain;charset=ISO-8859-1" ) </a> 0
<a> public class PerRequestResource { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( PerRequestResource . class ) ; </a> 0
<a> @ Context </a> 0
<a> Broadcaster broadcaster ; </a> 0
<a> @ Context </a> 0
<a> BroadcasterFactory broadcasterFactory ; </a> 0
<a> @ Context </a> 0
<a> AtmosphereResource < HttpServletRequest , HttpServletResponse > resource ; </a> 0
<a> @ GET </a> 0
<a> @ Suspend ( period = 5000 , outputComments = false ) </a> 0
<a> public String subscribe ( ) { </a> 0
<a> logger . info ( "broadcaster: {}" , broadcaster ) ; </a> 0
<a> logger . info ( "factory: {}" , broadcasterFactory ) ; </a> 0
<a> logger . info ( "resource: {}" , resource ) ; </a> 0
<a> return "perrequest" ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Broadcast </a> 0
<a> public String publish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return message ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import com . ning . http . client . AsyncHttpClient ; </a> 0
<a> import com . ning . http . client . Response ; </a> 0
<a> import org . testng . annotations . Test ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import static org . testng . Assert . assertEquals ; </a> 0
<a> import static org . testng . Assert . assertNotNull ; </a> 0
<a> import static org . testng . Assert . assertTrue ; </a> 0
<a> import static org . testng . Assert . fail ; </a> 0
<a> public class PerRequestResourceTest extends BaseGrizzyTest { </a> 0
<a> String getUrlTarget ( int port ) { </a> 0
<a> return "http://127.0.0.1:" + port + "/perrequest" ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testPerRequestSuspendTimeout ( ) { </a> 0
<a> logger . info ( "{}: running test: testPerRequestSuspendTimeout" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( 10 , TimeUnit . SECONDS ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> String resume = r . getResponseBody ( ) ; </a> 0
<a> assertEquals ( resume , "perrequest" ) ; </a> 0
<a> long current = System . currentTimeMillis ( ) - t1 ; </a> 0
<a> assertTrue ( current > 5000 && current < 10000 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . annotation . Resume ; </a> 0
<a> import org . atmosphere . annotation . Schedule ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import org . atmosphere . jersey . Broadcastable ; </a> 0
<a> import org . atmosphere . jersey . JerseyBroadcaster ; </a> 0
<a> import org . atmosphere . util . StringFilterAggregator ; </a> 0
<a> import org . atmosphere . util . XSSHtmlFilter ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import java . util . concurrent . ExecutionException ; </a> 0
<a> import java . util . concurrent . Executors ; </a> 0
<a> @ Path ( "/{topic}" ) </a> 0
<a> @ Produces ( "text/plain;charset=ISO-8859-1" ) </a> 0
<a> public class PubSubTest { </a> 0
<a> private </a> 0
<a> @ PathParam ( "topic" ) </a> 0
<a> Broadcaster broadcaster ; </a> 0
<a> private final static int count = 0 ; </a> 0
<a> @ GET </a> 0
<a> @ Path ( "scope" ) </a> 0
<a> @ Suspend ( period = 5000 , outputComments = false , scope = Suspend . SCOPE . REQUEST , resumeOnBroadcast = true ) </a> 0
<a> public Broadcastable suspendScopeRequest ( @ PathParam ( "topic" ) Broadcaster b ) throws ExecutionException , InterruptedException { </a> 0
<a> b . broadcast ( "foo" ) . get ( ) ; </a> 0
<a> return new Broadcastable ( "bar" , b ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Suspend ( period = 5000 , outputComments = false ) </a> 0
<a> public Broadcastable subscribe ( ) { </a> 0
<a> return new Broadcastable ( "resume" , broadcaster ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "withComments" ) </a> 0
<a> @ Suspend ( period = 5000 , outputComments = true ) </a> 0
<a> public Broadcastable subscribeWithComments ( ) { </a> 0
<a> return new Broadcastable ( broadcaster ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "forever" ) </a> 0
<a> @ Suspend ( outputComments = true ) </a> 0
<a> public Broadcastable suspendForever ( ) { </a> 0
<a> return new Broadcastable ( broadcaster ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "foreverWithoutComments" ) </a> 0
<a> @ Suspend ( outputComments = false ) </a> 0
<a> public Broadcastable suspendForeverWithoutComments ( ) { </a> 0
<a> return new Broadcastable ( broadcaster ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "subscribeAndUsingExternalThread" ) </a> 0
<a> @ Suspend ( resumeOnBroadcast = true ) </a> 0
<a> public String subscribeAndResumeUsingExternalThread ( final @ PathParam ( "topic" ) String topic ) { </a> 0
<a> Executors . newSingleThreadExecutor ( ) . submit ( new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 5000 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> BroadcasterFactory . getDefault ( ) . lookup ( JerseyBroadcaster . class , topic ) . broadcast ( "Echo: " + topic ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> return "foo" ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "suspendAndResume" ) </a> 0
<a> @ Suspend ( outputComments = false ) </a> 0
<a> public String suspend ( ) { </a> 0
<a> return "suspend" ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Suspend ( resumeOnBroadcast = true , outputComments = false ) </a> 0
<a> @ Path ( "subscribeAndResume" ) </a> 0
<a> public Broadcastable subscribeAndResume ( ) { </a> 0
<a> return new Broadcastable ( broadcaster ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Resume </a> 0
<a> @ Path ( "suspendAndResume/{uuid}" ) </a> 0
<a> public String resume ( ) throws ExecutionException , InterruptedException { </a> 0
<a> broadcaster . broadcast ( "resume" ) . get ( ) ; </a> 0
<a> return "resumed" ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Broadcast </a> 0
<a> public Broadcastable publish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "publishAndResume" ) </a> 0
<a> @ Broadcast ( resumeOnBroadcast = true ) </a> 0
<a> public Broadcastable publishAndResume ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "filter" ) </a> 0
<a> @ Broadcast ( resumeOnBroadcast = true , value = { XSSHtmlFilter . class } ) </a> 0
<a> public Broadcastable filter ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "aggregate" ) </a> 0
<a> @ Broadcast ( resumeOnBroadcast = true , value = { StringFilterAggregator . class } ) </a> 0
<a> public Broadcastable aggregate ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 5 , resumeOnBroadcast = true , waitFor = 5 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "scheduleAndResume" ) </a> 0
<a> public Broadcastable scheduleAndResume ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 10 , waitFor = 5 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "delaySchedule" ) </a> 0
<a> public Broadcastable delaySchedule ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 5 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "schedule" ) </a> 0
<a> public Broadcastable schedule ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Broadcast ( delay = 0 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "delay" ) </a> 0
<a> public Broadcastable delayPublish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Broadcast ( delay = 5 , resumeOnBroadcast = true ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "delayAndResume" ) </a> 0
<a> public Broadcastable delayPublishAndResume ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "programmaticDelayBroadcast" ) </a> 0
<a> public String manualDelayBroadcast ( @ FormParam ( "message" ) String message ) { </a> 0
<a> broadcaster . delayBroadcast ( message ) ; </a> 0
<a> return message ; </a> 0
<a> } </a> 0
<a> Broadcastable broadcast ( String m ) { </a> 0
<a> return new Broadcastable ( m + "\n" , broadcaster ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterConfig ; </a> 0
<a> import org . atmosphere . jersey . JerseyBroadcaster ; </a> 0
<a> public class RecyclableBroadcaster extends JerseyBroadcaster { </a> 0
<a> public RecyclableBroadcaster ( ) { </a> 0
<a> super ( ) ; </a> 0
<a> } </a> 0
<a> public RecyclableBroadcaster ( String name ) { </a> 0
<a> super ( name ) ; </a> 0
<a> } </a> 1
<a> public void destroy ( ) { </a> 0
<a> broadcasterCache = new BroadcasterConfig . DefaultBroadcasterCache ( ) ; </a> 1
<a> setScope ( SCOPE . APPLICATION ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import com . ning . http . client . AsyncHttpClient ; </a> 0
<a> import com . ning . http . client . Response ; </a> 0
<a> import org . testng . annotations . Test ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import static org . testng . Assert . assertEquals ; </a> 0
<a> import static org . testng . Assert . assertNotNull ; </a> 0
<a> import static org . testng . Assert . assertTrue ; </a> 0
<a> import static org . testng . Assert . fail ; </a> 0
<a> public class SingletonResourceTest extends BaseGrizzyTest { </a> 0
<a> String getUrlTarget ( int port ) { </a> 0
<a> return "http://127.0.0.1:" + port + "/singleton" ; </a> 0
<a> } </a> 0
<a> @ Test ( timeOut = 20000 , enabled = true ) </a> 0
<a> public void testSingletonSuspendTimeout ( ) { </a> 0
<a> logger . info ( "{}: running test: testSingletonSuspendTimeout" , getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> AsyncHttpClient c = new AsyncHttpClient ( ) ; </a> 0
<a> try { </a> 0
<a> long t1 = System . currentTimeMillis ( ) ; </a> 0
<a> Response r = c . prepareGet ( urlTarget ) . execute ( ) . get ( 10 , TimeUnit . SECONDS ) ; </a> 0
<a> assertNotNull ( r ) ; </a> 0
<a> assertEquals ( r . getStatusCode ( ) , 200 ) ; </a> 0
<a> String resume = r . getResponseBody ( ) ; </a> 0
<a> assertEquals ( resume , "singleton" ) ; </a> 0
<a> long current = System . currentTimeMillis ( ) - t1 ; </a> 0
<a> assertTrue ( current > 5000 && current < 10000 ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . error ( "test failed" , e ) ; </a> 0
<a> fail ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> c . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . jersey . tests ; </a> 0
<a> import org . apache . catalina . Context ; </a> 0
<a> import org . apache . catalina . Engine ; </a> 0
<a> import org . apache . catalina . Host ; </a> 0
<a> import org . apache . catalina . Wrapper ; </a> 0
<a> import org . apache . catalina . connector . Connector ; </a> 0
<a> import org . apache . catalina . startup . Embedded ; </a> 0
<a> import org . apache . coyote . http11 . Http11NioProtocol ; </a> 0
<a> import org . atmosphere . container . TomcatCometSupport ; </a> 0
<a> import org . atmosphere . cpr . ApplicationConfig ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 0
<a> import org . atmosphere . cpr . CometSupport ; </a> 0
<a> import org . testng . annotations . BeforeMethod ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import java . io . File ; </a> 0
<a> public class TomcatJerseyTest extends BasePubSubTest { </a> 0
<a> protected Embedded embedded ; </a> 0
<a> public static class TomcatAtmosphereServlet extends AtmosphereServlet { </a> 0
<a> public void init ( final ServletConfig sc ) throws ServletException { </a> 0
<a> addInitParameter ( ApplicationConfig . MAX_INACTIVE , "20000" ) ; </a> 0
<a> addInitParameter ( "com.sun.jersey.config.property.packages" , this . getClass ( ) . getPackage ( ) . getName ( ) ) ; </a> 0
<a> addInitParameter ( "org.atmosphere.cpr.broadcasterClass" , RecyclableBroadcaster . class . getName ( ) ) ; </a> 0
<a> cometSupport = new TomcatCometSupport ( getAtmosphereConfig ( ) ) ; </a> 0
<a> super . init ( sc ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ BeforeMethod ( alwaysRun = true ) </a> 0
<a> public void setUpGlobal ( ) throws Exception { </a> 0
<a> System . setProperty ( "org.atmosphere.useNative" , "true" ) ; </a> 0
<a> port = TestHelper . getEnvVariable ( "ATMOSPHERE_HTTP_PORT" , findFreePort ( ) ) ; </a> 0
<a> urlTarget = "http://127.0.0.1:" + port + "/invoke" ; </a> 0
<a> configureCometSupport ( ) ; </a> 0
<a> startServer ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void startServer ( ) throws Exception { </a> 0
<a> embedded = new Embedded ( ) ; </a> 0
<a> String path = new File ( "." ) . getAbsolutePath ( ) ; </a> 0
<a> embedded . setCatalinaHome ( path ) ; </a> 0
<a> Engine engine = embedded . createEngine ( ) ; </a> 0
<a> engine . setDefaultHost ( "127.0.0.1" ) ; </a> 0
<a> Host host = embedded . createHost ( "127.0.0.1" , path ) ; </a> 0
<a> engine . addChild ( host ) ; </a> 0
<a> Context c = embedded . createContext ( "/" , path ) ; </a> 0
<a> c . setReloadable ( false ) ; </a> 0
<a> Wrapper w = c . createWrapper ( ) ; </a> 0
<a> w . addMapping ( "/*" ) ; </a> 0
<a> w . setServletClass ( TomcatAtmosphereServlet . class . getName ( ) ) ; </a> 0
<a> w . setLoadOnStartup ( 0 ) ; </a> 0
<a> c . addChild ( w ) ; </a> 0
<a> host . addChild ( c ) ; </a> 0
<a> Connector connector = embedded . createConnector ( "127.0.0.1" , port , Http11NioProtocol . class . getName ( ) ) ; </a> 0
<a> connector . setContainer ( host ) ; </a> 0
<a> embedded . addEngine ( engine ) ; </a> 0
<a> embedded . addConnector ( connector ) ; </a> 0
<a> embedded . start ( ) ; </a> 0
<a> atmoServlet = ( AtmosphereServlet ) w . getServlet ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void configureCometSupport ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void stopServer ( ) throws Exception { </a> 0
<a> if ( atmoServlet != null ) atmoServlet . destroy ( ) ; </a> 0
<a> embedded . stop ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . jersey . devoxx . samples . ee6 . atmosphere ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import org . atmosphere . jersey . Broadcastable ; </a> 0
<a> import org . atmosphere . jersey . JerseyBroadcaster ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . annotation . PostConstruct ; </a> 0
<a> import javax . annotation . Resource ; </a> 0
<a> import javax . ejb . Stateless ; </a> 0
<a> import javax . ejb . Timeout ; </a> 0
<a> import javax . ejb . Timer ; </a> 0
<a> import javax . ejb . TimerConfig ; </a> 0
<a> import javax . ejb . TimerService ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . concurrent . Semaphore ; </a> 0
<a> @ Path ( "timer" ) </a> 0
<a> @ Stateless </a> 0
<a> public class TimerResource { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( TimerResource . class ) ; </a> 0
<a> private </a> 0
<a> @ Resource </a> 0
<a> TimerService ts ; </a> 0
<a> private </a> 0
<a> @ Context </a> 0
<a> BroadcasterFactory bf ; </a> 0
<a> private Semaphore started = new Semaphore ( 1 ) ; </a> 0
<a> private Semaphore stopped = new Semaphore ( 1 ) ; </a> 0
<a> private Broadcaster tb ; </a> 0
<a> private Timer t ; </a> 0
<a> private </a> 0
<a> @ PostConstruct </a> 0
<a> void postConstruct ( ) { </a> 0
<a> stopped . tryAcquire ( ) ; </a> 0
<a> } </a> 0
<a> private Broadcaster getTimerBroadcaster ( ) { </a> 0
<a> return bf . lookup ( JerseyBroadcaster . class , "timer" , true ) ; </a> 0
<a> } </a> 0
<a> @ Suspend </a> 0
<a> @ GET </a> 0
<a> public Broadcastable get ( ) { </a> 0
<a> return new Broadcastable ( getTimerBroadcaster ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Path ( "start" ) </a> 0
<a> @ POST </a> 0
<a> public void start ( ) { </a> 0
<a> if ( started . tryAcquire ( ) ) { </a> 0
<a> tb = getTimerBroadcaster ( ) ; </a> 0
<a> t = ts . createIntervalTimer ( 1000 , 1000 , new TimerConfig ( "timer" , false ) ) ; </a> 0
<a> stopped . release ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Timeout </a> 0
<a> public void timeout ( Timer timer ) { </a> 0
<a> logger . info ( "{}: {}" , getClass ( ) . getName ( ) , new Date ( ) ) ; </a> 0
<a> tb . broadcast ( new Date ( ) . toString ( ) + "\n" ) ; </a> 0
<a> } </a> 0
<a> @ Path ( "stop" ) </a> 0
<a> @ POST </a> 0
<a> public void stop ( ) { </a> 0
<a> if ( stopped . tryAcquire ( ) ) { </a> 0
<a> t . cancel ( ) ; </a> 0
<a> tb = null ; </a> 0
<a> t = null ; </a> 0
<a> started . release ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Path ( "hardstop" ) </a> 0
<a> @ POST </a> 0
<a> public void hardstop ( ) { </a> 0
<a> stop ( ) ; </a> 0
<a> getTimerBroadcaster ( ) . resumeAll ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import org . atmosphere . annotation . Publish ; </a> 0
<a> import org . atmosphere . annotation . Subscribe ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> @ Path ( "/" ) </a> 0
<a> @ Produces ( "text/plain;charset=ISO-8859-1" ) </a> 0
<a> public class TypedChannel { </a> 0
<a> @ GET </a> 0
<a> @ Subscribe ( "channel" ) </a> 0
<a> public String handshake ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Publish ( "channel" ) </a> 0
<a> public String onMessage ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return message ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . commons . jersey ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . annotation . Schedule ; </a> 1
<a> import org . atmosphere . annotation . Suspend ; </a> 1
<a> import org . atmosphere . util . XSSHtmlFilter ; </a> 1
<a> import javax . ws . rs . Consumes ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import javax . ws . rs . WebApplicationException ; </a> 0
<a> import javax . ws . rs . core . MultivaluedMap ; </a> 0
<a> @ Path ( "/chat" ) </a> 1
<a> @ Produces ( "text/html;charset=ISO-8859-1" ) </a> 0
<a> public class ResourceChat { </a> 0
<a> @ Suspend </a> 0
<a> @ GET </a> 0
<a> public String suspend ( ) { </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> @ Broadcast ( { XSSHtmlFilter . class , JsonpFilter . class } ) </a> 0
<a> @ Consumes ( "application/x-www-form-urlencoded" ) </a> 0
<a> @ POST </a> 0
<a> public String publishMessage ( MultivaluedMap < String , String > form ) { </a> 0
<a> String action = form . getFirst ( "action" ) ; </a> 0
<a> String name = form . getFirst ( "name" ) ; </a> 0
<a> if ( "login" . equals ( action ) ) { </a> 0
<a> return ( "System Message" + "__" + name + " has joined." ) ; </a> 0
<a> } else if ( "post" . equals ( action ) ) { </a> 0
<a> return name + "__" + form . getFirst ( "message" ) ; </a> 0
<a> } else { </a> 0
<a> throw new WebApplicationException ( 422 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 30 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "/ping" ) </a> 0
<a> public String pingSuspendedClients ( ) { </a> 0
<a> return "Atmosphere__ping" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . guice ; </a> 0
<a> import com . google . inject . Guice ; </a> 0
<a> import com . google . inject . Injector ; </a> 0
<a> import com . google . inject . servlet . GuiceServletContextListener ; </a> 0
<a> public class GuiceChatConfig extends GuiceServletContextListener { </a> 0
<a> @ Override </a> 0
<a> protected Injector getInjector ( ) { </a> 0
<a> return Guice . createInjector ( new GuiceChatModule ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . chat ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 1
<a> import org . atmosphere . cpr . AtmosphereServlet ; </a> 1
<a> import org . atmosphere . cpr . Broadcaster ; </a> 1
<a> import org . atmosphere . plugin . jgroups . JGroupsFilter ; </a> 0
<a> import org . atmosphere . util . XSSHtmlFilter ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . concurrent . ExecutionException ; </a> 0
<a> import java . util . concurrent . Future ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> public class ChatAtmosphereHandler implements AtmosphereHandler < HttpServletRequest , HttpServletResponse > { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( ChatAtmosphereHandler . class ) ; </a> 0
<a> private final static String BEGIN_SCRIPT_TAG = "<script type='text/javascript'>\n" ; </a> 0
<a> private final static String END_SCRIPT_TAG = "</script>\n" ; </a> 0
<a> private final static long serialVersionUID = - 2919167206889576860L ; </a> 0
<a> private final static String CLUSTER = "org.atmosphere.useCluster" ; </a> 0
<a> private AtomicBoolean filterAdded = new AtomicBoolean ( false ) ; </a> 0
<a> public ChatAtmosphereHandler ( ) { </a> 0
<a> } </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , </a> 0
<a> HttpServletResponse > event ) throws IOException { </a> 0
<a> HttpServletRequest req = event . getRequest ( ) ; </a> 0
<a> HttpServletResponse res = event . getResponse ( ) ; </a> 0
<a> res . setContentType ( "text/html;charset=ISO-8859-1" ) ; </a> 0
<a> if ( req . getMethod ( ) . equalsIgnoreCase ( "GET" ) ) { </a> 1
<a> event . suspend ( ) ; </a> 0
<a> Broadcaster bc = event . getBroadcaster ( ) ; </a> 0
<a> String clusterType = event . getAtmosphereConfig ( ) . getInitParameter ( CLUSTER ) ; </a> 0
<a> if ( ! filterAdded . getAndSet ( true ) && clusterType != null ) { </a> 0
<a> if ( clusterType . equals ( "jgroups" ) ) { </a> 0
<a> event . getAtmosphereConfig ( ) . getServletContext ( ) . log ( "JGroupsFilter enabled" ) ; </a> 0
<a> bc . getBroadcasterConfig ( ) . addFilter ( </a> 0
<a> new JGroupsFilter ( bc ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> bc . getBroadcasterConfig ( ) . addFilter ( new XSSHtmlFilter ( ) ) ; </a> 0
<a> Future < String > f = bc . broadcast ( event . getAtmosphereConfig ( ) . getWebServerName ( ) </a> 0
<a> + "**has suspended a connection from " </a> 0
<a> + req . getRemoteAddr ( ) ) ; </a> 0
<a> try { </a> 0
<a> f . get ( ) ; </a> 0
<a> } catch ( InterruptedException ex ) { </a> 0
<a> logger . error ( "" , ex ) ; </a> 0
<a> } catch ( ExecutionException ex ) { </a> 0
<a> logger . error ( "" , ex ) ; </a> 0
<a> } </a> 1
<a> bc . scheduleFixedBroadcast ( req . getRemoteAddr ( ) + "**is still listening" , 30 , TimeUnit . SECONDS ) ; </a> 0
<a> bc . delayBroadcast ( "Delayed Chat message" ) ; </a> 0
<a> } else if ( req . getMethod ( ) . equalsIgnoreCase ( "POST" ) ) { </a> 0
<a> String action = req . getParameterValues ( "action" ) [ 0 ] ; </a> 0
<a> String name = req . getParameterValues ( "name" ) [ 0 ] ; </a> 0
<a> if ( "login" . equals ( action ) ) { </a> 0
<a> req . getSession ( ) . setAttribute ( "name" , name ) ; </a> 0
<a> event . getBroadcaster ( ) . broadcast ( "System Message from " </a> 0
<a> + event . getAtmosphereConfig ( ) . getWebServerName ( ) + "**" + name + " has joined." ) ; </a> 0
<a> } else if ( "post" . equals ( action ) ) { </a> 0
<a> String message = req . getParameterValues ( "message" ) [ 0 ] ; </a> 0
<a> event . getBroadcaster ( ) . broadcast ( name + "**" + message ) ; </a> 0
<a> } else { </a> 0
<a> res . setStatus ( 422 ) ; </a> 0
<a> } </a> 0
<a> res . getWriter ( ) . write ( "success" ) ; </a> 0
<a> res . getWriter ( ) . flush ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , </a> 0
<a> HttpServletResponse > event ) throws IOException { </a> 0
<a> HttpServletRequest req = event . getResource ( ) . getRequest ( ) ; </a> 0
<a> HttpServletResponse res = event . getResource ( ) . getResponse ( ) ; </a> 0
<a> if ( event . getMessage ( ) == null ) return ; </a> 0
<a> String e = event . getMessage ( ) . toString ( ) ; </a> 0
<a> String name = e ; </a> 0
<a> String message = "" ; </a> 0
<a> if ( e . indexOf ( "**" ) > 0 ) { </a> 0
<a> name = e . substring ( 0 , e . indexOf ( "**" ) ) ; </a> 0
<a> message = e . substring ( e . indexOf ( "**" ) + 2 ) ; </a> 0
<a> } </a> 0
<a> String msg = BEGIN_SCRIPT_TAG + toJsonp ( name , message ) + END_SCRIPT_TAG ; </a> 0
<a> if ( event . isCancelled ( ) ) { </a> 0
<a> event . getResource ( ) . getBroadcaster ( ) </a> 0
<a> . broadcast ( req . getSession ( ) . getAttribute ( "name" ) + " has left" ) ; </a> 0
<a> } else if ( event . isResuming ( ) || event . isResumedOnTimeout ( ) ) { </a> 0
<a> String script = "<script>window.parent.app.listen();\n</script>" ; </a> 0
<a> res . getWriter ( ) . write ( script ) ; </a> 0
<a> } else { </a> 0
<a> res . getWriter ( ) . write ( msg ) ; </a> 0
<a> } </a> 0
<a> res . getWriter ( ) . flush ( ) ; </a> 0
<a> } </a> 0
<a> private String toJsonp ( String name , String message ) { </a> 0
<a> return "window.parent.app.update({ name: \"" + name + "\", message: \"" </a> 0
<a> + message + "\" });\n" ; </a> 0
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . commons . jersey ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter ; </a> 0
<a> public class JsonpFilter implements BroadcastFilter { </a> 0
<a> private static final String BEGIN_SCRIPT_TAG = "<script type='text/javascript'>\n" ; </a> 0
<a> private static final String END_SCRIPT_TAG = "</script>\n" ; </a> 0
<a> public BroadcastAction filter ( Object originalMessage , Object o ) { </a> 0
<a> if ( o instanceof String ) { </a> 0
<a> String m = ( String ) o ; </a> 0
<a> String name = m ; </a> 0
<a> String message = "" ; </a> 0
<a> if ( m . indexOf ( "__" ) > 0 ) { </a> 0
<a> name = m . substring ( 0 , m . indexOf ( "__" ) ) ; </a> 0
<a> message = m . substring ( m . indexOf ( "__" ) + 2 ) ; </a> 0
<a> } </a> 0
<a> return new BroadcastAction ( BEGIN_SCRIPT_TAG + "window.parent.app.update({ name: \"" </a> 0
<a> + name + "\", message: \"" + message + "\" });\n" + END_SCRIPT_TAG ) ; </a> 0
<a> } else { </a> 0
<a> return new BroadcastAction ( o ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . counter ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . PrintWriter ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> public class CounterLongPollingAtmosphereHandler implements AtmosphereHandler < HttpServletRequest , HttpServletResponse > { </a> 0
<a> private final AtomicInteger currentCount = new AtomicInteger ( 0 ) ; </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > resource ) throws IOException { </a> 0
<a> HttpServletRequest req = resource . getRequest ( ) ; </a> 0
<a> if ( req . getMethod ( ) . equals ( "GET" ) ) { </a> 0
<a> resource . suspend ( - 1 , false ) ; </a> 0
<a> } else { </a> 0
<a> if ( req . getParameter ( "stop" ) . equalsIgnoreCase ( "true" ) ) { </a> 0
<a> resource . getBroadcaster ( ) . broadcast ( "" ) ; </a> 0
<a> } else if ( req . getParameter ( "current_count" ) != null ) { </a> 0
<a> Integer i = Integer . valueOf ( req . getParameter ( "current_count" ) ) ; </a> 0
<a> if ( i > currentCount . get ( ) ) { </a> 0
<a> currentCount . set ( i ) ; </a> 0
<a> } </a> 0
<a> resource . getBroadcaster ( ) . broadcast ( i > currentCount . get ( ) ? i : currentCount . get ( ) ) ; </a> 0
<a> } </a> 0
<a> PrintWriter writer = resource . getResponse ( ) . getWriter ( ) ; </a> 0
<a> writer . write ( "success" ) ; </a> 0
<a> writer . flush ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , </a> 0
<a> HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isCancelled ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> int count = 0 ; </a> 0
<a> if ( event . getMessage ( ) instanceof Integer ) { </a> 0
<a> count = ( ( Integer ) event . getMessage ( ) ) . intValue ( ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> event . getResource ( ) . getResponse ( ) . addHeader ( "X-JSON" , "{\"counter\":" + count + " }" ) ; </a> 0
<a> PrintWriter writer = event . getResource ( ) . getResponse ( ) . getWriter ( ) ; </a> 0
<a> writer . write ( "success" ) ; </a> 0
<a> writer . flush ( ) ; </a> 0
<a> } finally { </a> 0
<a> if ( ! event . isResumedOnTimeout ( ) ) { </a> 0
<a> event . getResource ( ) . resume ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . di . guice ; </a> 0
<a> import com . google . inject . Inject ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public class EventsLogger implements AtmosphereResourceEventListener { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( EventsLogger . class ) ; </a> 0
<a> @ Inject </a> 0
<a> private Service service ; </a> 0
<a> public void onSuspend ( final AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> if ( service == null ) { </a> 0
<a> throw new AssertionError ( ) ; </a> 0
<a> } </a> 0
<a> logger . info ( "[{}] onSuspend: {}:{}" , </a> 0
<a> new Object [ ] { Thread . currentThread ( ) . getName ( ) , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) } ) ; </a> 0
<a> } </a> 0
<a> public void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> if ( service == null ) { </a> 0
<a> throw new AssertionError ( ) ; </a> 0
<a> } </a> 0
<a> logger . info ( "[{}] onResume: {}:{}" , </a> 0
<a> new Object [ ] { Thread . currentThread ( ) . getName ( ) , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) } ) ; </a> 0
<a> } </a> 0
<a> public void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> if ( service == null ) { </a> 0
<a> throw new AssertionError ( ) ; </a> 0
<a> } </a> 0
<a> logger . info ( "[{}] onDisconnect: {}:{}" , </a> 0
<a> new Object [ ] { Thread . currentThread ( ) . getName ( ) , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) } ) ; </a> 0
<a> } </a> 0
<a> public void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> if ( service == null ) { </a> 0
<a> throw new AssertionError ( ) ; </a> 0
<a> } </a> 0
<a> logger . info ( "[{}] onBroadcast: {}:{}" , </a> 0
<a> new Object [ ] { Thread . currentThread ( ) . getName ( ) , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) } ) ; </a> 0
<a> } </a> 0
<a> public void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> if ( service == null ) { </a> 0
<a> throw new AssertionError ( ) ; </a> 0
<a> } </a> 0
<a> logger . info ( "[{}] onThrowable: " + event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) + ":" + </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) , event . throwable ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . di . guice ; </a> 0
<a> final class Service { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package start ; </a> 0
<a> import org . eclipse . jetty . server . Connector ; </a> 0
<a> import org . eclipse . jetty . server . Server ; </a> 0
<a> import org . eclipse . jetty . server . handler . ContextHandlerCollection ; </a> 0
<a> import org . eclipse . jetty . server . handler . DefaultHandler ; </a> 0
<a> import org . eclipse . jetty . server . handler . HandlerCollection ; </a> 0
<a> import org . eclipse . jetty . server . nio . SelectChannelConnector ; </a> 0
<a> import org . eclipse . jetty . webapp . WebAppContext ; </a> 0
<a> public class Start { </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> Server server = new Server ( ) ; </a> 0
<a> SelectChannelConnector connector = new SelectChannelConnector ( ) ; </a> 0
<a> connector . setMaxIdleTime ( 1000 * 60 * 60 ) ; </a> 0
<a> connector . setSoLingerTime ( - 1 ) ; </a> 0
<a> connector . setPort ( 8080 ) ; </a> 0
<a> server . setConnectors ( new Connector [ ] { connector } ) ; </a> 0
<a> WebAppContext webapp = new WebAppContext ( "src/main/webapp" , "/" ) ; </a> 0
<a> HandlerCollection contexts = new ContextHandlerCollection ( ) ; </a> 0
<a> contexts . addHandler ( webapp ) ; </a> 0
<a> contexts . addHandler ( new DefaultHandler ( ) ) ; </a> 0
<a> server . setHandler ( contexts ) ; </a> 0
<a> try { </a> 0
<a> System . out . println ( ">>> STARTING EMBEDDED JETTY SERVER, PRESS ANY KEY TO STOP" ) ; </a> 0
<a> server . start ( ) ; </a> 0
<a> System . in . read ( ) ; </a> 0
<a> System . out . println ( ">>> STOPPING EMBEDDED JETTY SERVER" ) ; </a> 0
<a> server . stop ( ) ; </a> 0
<a> server . join ( ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> System . exit ( 100 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . flickr ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> public class FlickrAtmosphereHandler implements AtmosphereHandler < HttpServletRequest , HttpServletResponse > { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( FlickrAtmosphereHandler . class ) ; </a> 0
<a> private int counter ; </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , </a> 0
<a> HttpServletResponse > event ) throws IOException { </a> 0
<a> HttpServletRequest req = event . getRequest ( ) ; </a> 0
<a> HttpServletResponse res = event . getResponse ( ) ; </a> 0
<a> logger . info ( "onEvent: {}" , req . getRequestURI ( ) ) ; </a> 0
<a> String [ ] actionValues = req . getParameterValues ( "action" ) ; </a> 0
<a> if ( actionValues != null && actionValues [ 0 ] != null ) { </a> 0
<a> String action = req . getParameterValues ( "action" ) [ 0 ] ; </a> 0
<a> if ( "post" . equals ( action ) ) { </a> 0
<a> String message = req . getParameterValues ( "message" ) [ 0 ] ; </a> 0
<a> String callback = req . getParameterValues ( "callback" ) [ 0 ] ; </a> 0
<a> if ( callback == null ) { </a> 0
<a> callback = "alert" ; </a> 0
<a> } </a> 0
<a> event . getBroadcaster ( ) . broadcast ( "<script id='comet_" + counter ++ + "'>" </a> 0
<a> + "window.parent." </a> 0
<a> + callback + "(" + message + ");</script>" ) ; </a> 0
<a> res . getWriter ( ) . write ( "ok" ) ; </a> 0
<a> res . getWriter ( ) . flush ( ) ; </a> 0
<a> } else if ( "start" . equals ( action ) ) { </a> 0
<a> res . setContentType ( "text/html;charset=ISO-8859-1" ) ; </a> 0
<a> res . addHeader ( "Cache-Control" , "private" ) ; </a> 0
<a> res . addHeader ( "Pragma" , "no-cache" ) ; </a> 0
<a> String callback = req . getParameterValues ( "callback" ) [ 0 ] ; </a> 0
<a> if ( callback == null ) { </a> 0
<a> callback = "alert" ; </a> 0
<a> } </a> 0
<a> event . suspend ( ) ; </a> 0
<a> String message = "{ message : 'Welcome'}" ; </a> 0
<a> res . getWriter ( ) . write ( "<script id='comet_" + counter ++ + "'>" </a> 0
<a> + "window.parent." </a> 0
<a> + callback + "(" + message + ");</script>" ) ; </a> 0
<a> res . getWriter ( ) . write ( "<html><head><title>Atmosphere Flickr " + </a> 0
<a> "Demo</title></head><body bgcolor=\"#FFFFFF\">" ) ; </a> 0
<a> res . getWriter ( ) . flush ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onStateChange ( AtmosphereResourceEvent < HttpServletRequest , </a> 0
<a> HttpServletResponse > event ) throws IOException { </a> 0
<a> HttpServletResponse res = event . getResource ( ) . getResponse ( ) ; </a> 0
<a> if ( event . isResuming ( ) ) { </a> 0
<a> res . getWriter ( ) . write ( "Atmosphere Sample closed<br/>" ) ; </a> 0
<a> res . getWriter ( ) . write ( "</body></html>" ) ; </a> 0
<a> } else { </a> 0
<a> res . getWriter ( ) . write ( event . getMessage ( ) . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> res . getWriter ( ) . flush ( ) ; </a> 0
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . client ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> public class Event implements Serializable { </a> 0
<a> private long code ; </a> 0
<a> private String data ; </a> 0
<a> public Event ( ) { </a> 0
<a> } </a> 0
<a> public Event ( long code , String data ) { </a> 0
<a> this . code = code ; </a> 0
<a> this . data = data ; </a> 0
<a> } </a> 0
<a> public long getCode ( ) { </a> 0
<a> return code ; </a> 0
<a> } </a> 0
<a> public void setCode ( long code ) { </a> 0
<a> this . code = code ; </a> 0
<a> } </a> 0
<a> public String getData ( ) { </a> 0
<a> return data ; </a> 0
<a> } </a> 0
<a> public void setData ( String data ) { </a> 0
<a> this . data = data ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getCode ( ) + ": " + getData ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . client ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereGWTSerializer ; </a> 0
<a> import org . atmosphere . gwt . client . SerialTypes ; </a> 0
<a> @ SerialTypes ( value = { Event . class } ) </a> 0
<a> public abstract class EventSerializer extends AtmosphereGWTSerializer { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . client ; </a> 0
<a> import com . google . gwt . core . client . EntryPoint ; </a> 0
<a> import com . google . gwt . core . client . GWT ; </a> 0
<a> import com . google . gwt . core . client . Scheduler ; </a> 1
<a> import com . google . gwt . core . client . Scheduler . ScheduledCommand ; </a> 1
<a> import com . google . gwt . dom . client . Document ; </a> 1
<a> import com . google . gwt . event . dom . client . ClickEvent ; </a> 0
<a> import com . google . gwt . event . dom . client . ClickHandler ; </a> 0
<a> import com . google . gwt . user . client . rpc . AsyncCallback ; </a> 0
<a> import com . google . gwt . user . client . rpc . StatusCodeException ; </a> 0
<a> import com . google . gwt . user . client . ui . Button ; </a> 0
<a> import com . google . gwt . user . client . ui . RootPanel ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereClient ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereGWTSerializer ; </a> 0
<a> import org . atmosphere . gwt . client . AtmosphereListener ; </a> 0
<a> import org . atmosphere . gwt . client . extra . Window ; </a> 0
<a> import org . atmosphere . gwt . client . extra . WindowFeatures ; </a> 0
<a> import org . atmosphere . gwt . client . extra . WindowSocket ; </a> 0
<a> import java . io . Serializable ; </a> 1
<a> import java . util . List ; </a> 0
<a> import java . util . logging . Level ; </a> 0
<a> import java . util . logging . Logger ; </a> 0
<a> public class GWTDemo implements EntryPoint { </a> 0
<a> PollAsync polling = GWT . create ( Poll . class ) ; </a> 0
<a> AtmosphereClient client ; </a> 0
<a> Logger logger = Logger . getLogger ( getClass ( ) . getName ( ) ) ; </a> 0
<a> Window screen ; </a> 0
<a> @ Override </a> 0
<a> public void onModuleLoad ( ) { </a> 0
<a> Button button = new Button ( "Broadcast" ) ; </a> 0
<a> button . addClickHandler ( new ClickHandler ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( ClickEvent event ) { </a> 0
<a> sendMessage ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Button post = new Button ( "Post" ) ; </a> 0
<a> post . addClickHandler ( new ClickHandler ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( ClickEvent event ) { </a> 0
<a> client . post ( new Event ( count ++ , "This was send using the post mechanism" ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Button pollButton = new Button ( "Poll" ) ; </a> 0
<a> pollButton . addClickHandler ( new ClickHandler ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( ClickEvent event ) { </a> 0
<a> polling . pollDelayed ( 3000 , new AsyncCallback < Event > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onFailure ( Throwable caught ) { </a> 0
<a> GWT . log ( "Failed to poll" , caught ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onSuccess ( Event result ) { </a> 0
<a> Info . display ( "Polling message received: " + result . getCode ( ) , result . getData ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Button wnd = new Button ( "Open Window" ) ; </a> 0
<a> wnd . addClickHandler ( new ClickHandler ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( ClickEvent event ) { </a> 0
<a> Scheduler . get ( ) . scheduleDeferred ( new ScheduledCommand ( ) { </a> 0
<a> @ Override </a> 0
<a> public void execute ( ) { </a> 0
<a> screen = Window . current ( ) . open ( Document . get ( ) . getURL ( ) , "child" , new WindowFeatures ( ) . setStatus ( true ) . setResizable ( true ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Button sendWindow = new Button ( "Send to window" ) ; </a> 0
<a> sendWindow . addClickHandler ( new ClickHandler ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( ClickEvent event ) { </a> 0
<a> if ( screen != null ) { </a> 0
<a> WindowSocket . post ( screen , "wsock" , "Hello Child!" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> WindowSocket socket = new WindowSocket ( ) ; </a> 0
<a> socket . addHandler ( new WindowSocket . MessageHandler ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onMessage ( String message ) { </a> 0
<a> Info . display ( "Received through window socket" , message ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> socket . bind ( "wsock" ) ; </a> 0
<a> RootPanel . get ( "buttons" ) . add ( button ) ; </a> 0
<a> RootPanel . get ( "buttons" ) . add ( post ) ; </a> 0
<a> RootPanel . get ( "buttons" ) . add ( pollButton ) ; </a> 0
<a> RootPanel . get ( "buttons" ) . add ( wnd ) ; </a> 0
<a> RootPanel . get ( "buttons" ) . add ( sendWindow ) ; </a> 0
<a> initialize ( ) ; </a> 0
<a> Button killbutton = new Button ( "Stop" ) ; </a> 0
<a> killbutton . addClickHandler ( new ClickHandler ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( ClickEvent event ) { </a> 0
<a> client . stop ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> RootPanel . get ( "buttons" ) . add ( killbutton ) ; </a> 0
<a> } </a> 0
<a> private class MyCometListener implements AtmosphereListener { </a> 0
<a> @ Override </a> 0
<a> public void onConnected ( int heartbeat , int connectionID ) { </a> 0
<a> GWT . log ( "comet.connected [" + heartbeat + ", " + connectionID + "]" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onBeforeDisconnected ( ) { </a> 0
<a> logger . log ( Level . INFO , "comet.beforeDisconnected" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDisconnected ( ) { </a> 0
<a> GWT . log ( "comet.disconnected" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onError ( Throwable exception , boolean connected ) { </a> 0
<a> int statuscode = - 1 ; </a> 0
<a> if ( exception instanceof StatusCodeException ) { </a> 0
<a> statuscode = ( ( StatusCodeException ) exception ) . getStatusCode ( ) ; </a> 0
<a> } </a> 0
<a> GWT . log ( "comet.error [connected=" + connected + "] (" + statuscode + ")" , exception ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onHeartbeat ( ) { </a> 0
<a> GWT . log ( "comet.heartbeat [" + client . getConnectionID ( ) + "]" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onRefresh ( ) { </a> 0
<a> GWT . log ( "comet.refresh [" + client . getConnectionID ( ) + "]" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onMessage ( List < ? extends Serializable > messages ) { </a> 0
<a> StringBuilder result = new StringBuilder ( ) ; </a> 0
<a> for ( Serializable obj : messages ) { </a> 0
<a> result . append ( obj . toString ( ) ) . append ( "<br/>" ) ; </a> 0
<a> } </a> 0
<a> logger . log ( Level . INFO , "comet.message [" + client . getConnectionID ( ) + "] " + result . toString ( ) ) ; </a> 0
<a> Info . display ( "[" + client . getConnectionID ( ) + "] Received " + messages . size ( ) + " messages" , result . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ; </a> 0
<a> public void initialize ( ) { </a> 0
<a> MyCometListener cometListener = new MyCometListener ( ) ; </a> 0
<a> AtmosphereGWTSerializer serializer = GWT . create ( EventSerializer . class ) ; </a> 0
<a> client = new AtmosphereClient ( GWT . getModuleBaseURL ( ) + "gwtComet" , serializer , cometListener ) ; </a> 0
<a> client . start ( ) ; </a> 0
<a> } </a> 0
<a> static int count = 0 ; </a> 0
<a> public void sendMessage ( ) { </a> 0
<a> client . broadcast ( new Event ( count ++ , "Button clicked!" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . client ; </a> 0
<a> import com . google . gwt . core . client . GWT ; </a> 0
<a> import com . google . gwt . uibinder . client . UiBinder ; </a> 0
<a> import com . google . gwt . uibinder . client . UiField ; </a> 0
<a> import com . google . gwt . user . client . Timer ; </a> 0
<a> import com . google . gwt . user . client . Window ; </a> 0
<a> import com . google . gwt . user . client . ui . Composite ; </a> 0
<a> import com . google . gwt . user . client . ui . Label ; </a> 0
<a> import com . google . gwt . user . client . ui . PopupPanel ; </a> 0
<a> import com . google . gwt . user . client . ui . Widget ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> public class Info extends PopupPanel { </a> 0
<a> public static void display ( String title , String message ) { </a> 0
<a> final Info info = new Info ( title , message ) ; </a> 0
<a> info . show ( ) ; </a> 0
<a> Timer t = new Timer ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> info . hide ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> t . schedule ( 4000 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void show ( ) { </a> 0
<a> super . show ( ) ; </a> 0
<a> slots . add ( level , this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void hide ( ) { </a> 0
<a> super . hide ( ) ; </a> 0
<a> slots . set ( level , null ) ; </a> 0
<a> } </a> 0
<a> protected Info ( String title , String message ) { </a> 0
<a> add ( new InfoWidget ( title , message ) ) ; </a> 0
<a> setWidth ( "300px" ) ; </a> 0
<a> setHeight ( "50px" ) ; </a> 0
<a> int root_width = Window . getClientWidth ( ) ; </a> 0
<a> int root_height = Window . getClientHeight ( ) ; </a> 0
<a> level = findAvailableLevel ( ) ; </a> 0
<a> int left = root_width - 320 ; </a> 0
<a> int top = root_height - 80 - ( level * 60 ) ; </a> 0
<a> setPopupPosition ( left , top ) ; </a> 0
<a> } </a> 0
<a> private static ArrayList < Info > slots = new ArrayList < Info > ( ) ; </a> 0
<a> private int level ; </a> 0
<a> private static int findAvailableLevel ( ) { </a> 0
<a> int size = slots . size ( ) ; </a> 0
<a> for ( int i = 0 ; i < size ; i ++ ) { </a> 0
<a> if ( slots . get ( i ) == null ) { </a> 0
<a> return i ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return size ; </a> 0
<a> } </a> 0
<a> public static class InfoWidget extends Composite { </a> 0
<a> MyUiBinder binder = GWT . create ( MyUiBinder . class ) ; </a> 0
<a> interface MyUiBinder extends UiBinder < Widget , InfoWidget > { </a> 0
<a> } </a> 0
<a> @ UiField </a> 0
<a> Label title ; </a> 0
<a> @ UiField </a> 0
<a> Label message ; </a> 1
<a> private InfoWidget ( String title , String message ) { </a> 0
<a> initWidget ( binder . createAndBindUi ( this ) ) ; </a> 0
<a> this . title . setText ( title ) ; </a> 0
<a> this . message . setText ( message ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . client ; </a> 0
<a> import com . google . gwt . user . client . rpc . RemoteService ; </a> 0
<a> import com . google . gwt . user . client . rpc . RemoteServiceRelativePath ; </a> 0
<a> @ RemoteServiceRelativePath ( "gwtPoll" ) </a> 0
<a> public interface Poll extends RemoteService { </a> 0
<a> public Event pollDelayed ( int milli ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . client ; </a> 0
<a> import com . google . gwt . user . client . rpc . AsyncCallback ; </a> 0
<a> public interface PollAsync { </a> 0
<a> public void pollDelayed ( int milli , AsyncCallback < Event > callback ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . server ; </a> 0
<a> import org . atmosphere . gwt . server . AtmosphereGwtHandler ; </a> 0
<a> import org . atmosphere . gwt . server . GwtAtmosphereResource ; </a> 0
<a> import javax . servlet . ServletConfig ; </a> 0
<a> import javax . servlet . ServletException ; </a> 0
<a> import javax . servlet . http . HttpSession ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . logging . Level ; </a> 0
<a> import java . util . logging . Logger ; </a> 0
<a> public class AtmosphereHandler extends AtmosphereGwtHandler { </a> 0
<a> @ Override </a> 0
<a> public void init ( ServletConfig servletConfig ) throws ServletException { </a> 0
<a> super . init ( servletConfig ) ; </a> 0
<a> Logger . getLogger ( "" ) . setLevel ( Level . INFO ) ; </a> 0
<a> Logger . getLogger ( "gwtcomettest" ) . setLevel ( Level . ALL ) ; </a> 1
<a> Logger . getLogger ( "" ) . getHandlers ( ) [ 0 ] . setLevel ( Level . ALL ) ; </a> 0
<a> logger . trace ( "Updated logging levels" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int doComet ( GwtAtmosphereResource resource ) throws ServletException , IOException { </a> 0
<a> resource . getBroadcaster ( ) . setID ( "GWT_COMET" ) ; </a> 0
<a> HttpSession session = resource . getAtmosphereResource ( ) . getRequest ( ) . getSession ( false ) ; </a> 0
<a> if ( session != null ) { </a> 0
<a> logger . debug ( "Got session with id: " + session . getId ( ) ) ; </a> 0
<a> logger . debug ( "Time attribute: " + session . getAttribute ( "time" ) ) ; </a> 0
<a> } else { </a> 0
<a> logger . warn ( "No session" ) ; </a> 0
<a> } </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( "Url: " + resource . getAtmosphereResource ( ) . getRequest ( ) . getRequestURL ( ) </a> 0
<a> + "?" + resource . getAtmosphereResource ( ) . getRequest ( ) . getQueryString ( ) ) ; </a> 0
<a> } </a> 0
<a> return NO_TIMEOUT ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void cometTerminated ( GwtAtmosphereResource cometResponse , boolean serverInitiated ) { </a> 0
<a> super . cometTerminated ( cometResponse , serverInitiated ) ; </a> 0
<a> logger . debug ( "Comet disconnected" ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public class EventsLogger implements AtmosphereResourceEventListener { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( EventsLogger . class ) ; </a> 0
<a> public EventsLogger ( ) { </a> 0
<a> } </a> 0
<a> public void onSuspend ( final AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onSuspend(): {}:{}" , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onResume(): {}:{}" , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onDisconnect(): {}:{}" , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onBroadcast(): {}" , event . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . warn ( "onThrowable(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import javax . ws . rs . core . PathSegment ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> @ Path ( "/" ) </a> 0
<a> @ Produces ( "text/html" ) </a> 0
<a> public class FileResource { </a> 0
<a> private </a> 0
<a> @ Context </a> 0
<a> ServletContext sc ; </a> 0
<a> @ Path ( "/jquery/{id}" ) </a> 0
<a> @ GET </a> 0
<a> public InputStream getJQuery ( @ PathParam ( "id" ) PathSegment ps ) { </a> 0
<a> return sc . getResourceAsStream ( "/jquery/" + ps . getPath ( ) ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> public InputStream getIndex ( ) { </a> 0
<a> return sc . getResourceAsStream ( "/index.html" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . jersey . Broadcastable ; </a> 0
<a> import org . atmosphere . jersey . SuspendResponse ; </a> 0
<a> import org . atmosphere . plugin . redis . RedisBroadcaster ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> @ Path ( "/pubsub/{topic}" ) </a> 0
<a> @ Produces ( "text/html;charset=ISO-8859-1" ) </a> 0
<a> public class RedisPubSub { </a> 0
<a> private </a> 0
<a> @ PathParam ( "topic" ) </a> 0
<a> RedisBroadcaster topic ; </a> 0
<a> @ GET </a> 0
<a> public SuspendResponse < String > subscribe ( ) { </a> 0
<a> return new SuspendResponse . SuspendResponseBuilder < String > ( ) </a> 0
<a> . broadcaster ( topic ) </a> 0
<a> . outputComments ( true ) </a> 0
<a> . addListener ( new EventsLogger ( ) ) </a> 0
<a> . build ( ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Broadcast </a> 0
<a> public Broadcastable publish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return new Broadcastable ( message , "" , topic ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import javax . ws . rs . core . PathSegment ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> @ Path ( "/" ) </a> 0
<a> @ Produces ( "text/html" ) </a> 0
<a> public class FileResource { </a> 0
<a> private </a> 0
<a> @ Context </a> 0
<a> ServletContext sc ; </a> 0
<a> @ Path ( "/jquery/{id}" ) </a> 0
<a> @ GET </a> 0
<a> public InputStream getJQuery ( @ PathParam ( "id" ) PathSegment ps ) { </a> 0
<a> return sc . getResourceAsStream ( "/jquery/" + ps . getPath ( ) ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> public InputStream getIndex ( ) { </a> 0
<a> return sc . getResourceAsStream ( "/index.html" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . jersey . Broadcastable ; </a> 0
<a> import org . atmosphere . jersey . SuspendResponse ; </a> 0
<a> import org . atmosphere . plugin . xmpp . XMPPBroadcaster ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> @ Path ( "/pubsub/{topic}" ) </a> 0
<a> @ Produces ( "text/html;charset=ISO-8859-1" ) </a> 0
<a> public class XMPPPubSub { </a> 0
<a> private </a> 0
<a> @ PathParam ( "topic" ) </a> 0
<a> XMPPBroadcaster topic ; </a> 0
<a> @ GET </a> 0
<a> public SuspendResponse < String > subscribe ( ) { </a> 0
<a> return new SuspendResponse . SuspendResponseBuilder < String > ( ) </a> 0
<a> . broadcaster ( topic ) </a> 0
<a> . outputComments ( true ) </a> 0
<a> . addListener ( new EventsLogger ( ) ) </a> 0
<a> . build ( ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Broadcast </a> 0
<a> public Broadcastable publish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return new Broadcastable ( message , "" , topic ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import org . atmosphere . websocket . WebSocketEventListener ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public class EventsLogger implements WebSocketEventListener { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( EventsLogger . class ) ; </a> 0
<a> public EventsLogger ( ) { </a> 0
<a> } </a> 0
<a> public void onSuspend ( final AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onSuspend(): {}:{}" , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onResume(): {}:{}" , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onDisconnect(): {}:{}" , event . getResource ( ) . getRequest ( ) . getRemoteAddr ( ) , </a> 0
<a> event . getResource ( ) . getRequest ( ) . getRemotePort ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onBroadcast(): {}" , event . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> public void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . warn ( "onThrowable(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> public void onHandshake ( WebSocketEvent event ) { </a> 0
<a> logger . info ( "onHandshake(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> public void onMessage ( WebSocketEvent event ) { </a> 0
<a> logger . info ( "onMessage(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> public void onClose ( WebSocketEvent event ) { </a> 0
<a> logger . info ( "onClose(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> public void onControl ( WebSocketEvent event ) { </a> 0
<a> logger . info ( "onControl(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> public void onDisconnect ( WebSocketEvent event ) { </a> 0
<a> logger . info ( "onDisconnect(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> public void onConnect ( WebSocketEvent event ) { </a> 0
<a> logger . info ( "onConnect(): {}" , event ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import javax . ws . rs . core . PathSegment ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> @ Path ( "/" ) </a> 0
<a> @ Produces ( "text/html" ) </a> 0
<a> public class FileResource { </a> 0
<a> private </a> 0
<a> @ Context </a> 0
<a> ServletContext sc ; </a> 0
<a> @ Path ( "/jquery/{id}" ) </a> 0
<a> @ GET </a> 0
<a> public InputStream getJQuery ( @ PathParam ( "id" ) PathSegment ps ) { </a> 0
<a> return sc . getResourceAsStream ( "/jquery/" + ps . getPath ( ) ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> public InputStream getIndex ( ) { </a> 0
<a> return sc . getResourceAsStream ( "/index.html" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . jersey . Broadcastable ; </a> 0
<a> import org . atmosphere . jersey . SuspendResponse ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> @ Path ( "/pubsub/{topic}" ) </a> 0
<a> @ Produces ( "text/html;charset=ISO-8859-1" ) </a> 0
<a> public class JQueryPubSub { </a> 0
<a> private </a> 0
<a> @ PathParam ( "topic" ) </a> 0
<a> Broadcaster topic ; </a> 0
<a> @ GET </a> 0
<a> public SuspendResponse < String > subscribe ( ) { </a> 0
<a> return new SuspendResponse . SuspendResponseBuilder < String > ( ) </a> 0
<a> . broadcaster ( topic ) </a> 0
<a> . outputComments ( true ) </a> 0
<a> . addListener ( new EventsLogger ( ) ) </a> 0
<a> . build ( ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Broadcast </a> 0
<a> public Broadcastable publish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return new Broadcastable ( message , "" , topic ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . chat ; </a> 0
<a> import org . atmosphere . commons . jersey . JsonpFilter ; </a> 1
<a> import org . atmosphere . commons . util . EventsLogger ; </a> 1
<a> import org . atmosphere . cpr . BroadcastFilter ; </a> 0
<a> import org . atmosphere . cpr . Meteor ; </a> 0
<a> import org . atmosphere . util . XSSHtmlFilter ; </a> 0
<a> import javax . servlet . http . HttpServlet ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . LinkedList ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class MeteorChat extends HttpServlet { </a> 0
<a> private final static long serialVersionUID = - 2919167206889576860L ; </a> 0
<a> private final List < BroadcastFilter > list ; </a> 0
<a> public MeteorChat ( ) { </a> 0
<a> list = new LinkedList < BroadcastFilter > ( ) ; </a> 0
<a> list . add ( new XSSHtmlFilter ( ) ) ; </a> 0
<a> list . add ( new JsonpFilter ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void doGet ( HttpServletRequest req , HttpServletResponse res ) throws IOException { </a> 0
<a> Meteor m = Meteor . build ( req , list , null ) ; </a> 0
<a> m . addListener ( new EventsLogger ( ) ) ; </a> 0
<a> req . getSession ( ) . setAttribute ( "meteor" , m ) ; </a> 0
<a> res . setContentType ( "text/html;charset=ISO-8859-1" ) ; </a> 0
<a> m . suspend ( - 1 ) ; </a> 0
<a> m . broadcast ( req . getServerName ( ) + "__has suspended a connection from " + req . getRemoteAddr ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void doPost ( HttpServletRequest req , HttpServletResponse res ) throws IOException { </a> 0
<a> Meteor m = ( Meteor ) req . getSession ( ) . getAttribute ( "meteor" ) ; </a> 0
<a> res . setCharacterEncoding ( "UTF-8" ) ; </a> 0
<a> String action = req . getParameterValues ( "action" ) [ 0 ] ; </a> 0
<a> String name = req . getParameterValues ( "name" ) [ 0 ] ; </a> 0
<a> if ( "login" . equals ( action ) ) { </a> 0
<a> req . getSession ( ) . setAttribute ( "name" , name ) ; </a> 0
<a> m . broadcast ( "System Message from " + req . getServerName ( ) + "__" + name + " has joined." ) ; </a> 0
<a> res . getWriter ( ) . write ( "success" ) ; </a> 0
<a> res . getWriter ( ) . flush ( ) ; </a> 0
<a> } else if ( "post" . equals ( action ) ) { </a> 0
<a> String message = req . getParameterValues ( "message" ) [ 0 ] ; </a> 0
<a> m . broadcast ( name + "__" + message ) ; </a> 0
<a> res . getWriter ( ) . write ( "success" ) ; </a> 0
<a> res . getWriter ( ) . flush ( ) ; </a> 0
<a> } else { </a> 0
<a> res . setStatus ( 422 ) ; </a> 0
<a> res . getWriter ( ) . write ( "success" ) ; </a> 0
<a> res . getWriter ( ) . flush ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public class EventsLogger implements AtmosphereResourceEventListener { </a> 0
<a> public EventsLogger ( ) { </a> 0
<a> } </a> 0
<a> public void onSuspend ( final AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> System . out . println ( "onResume: " + event ) ; </a> 1
<a> } </a> 0
<a> public void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> System . out . println ( "onResume: " + event ) ; </a> 0
<a> } </a> 0
<a> public void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> System . out . println ( "onDisconnect: " + event ) ; </a> 0
<a> } </a> 0
<a> public void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> System . out . println ( "onBroadcast: " + event ) ; </a> 0
<a> } </a> 0
<a> public void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> event . throwable ( ) . printStackTrace ( System . err ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . annotation . Schedule ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . BroadcasterFactory ; </a> 0
<a> import org . atmosphere . jersey . Broadcastable ; </a> 0
<a> import org . atmosphere . jersey . JerseyBroadcaster ; </a> 0
<a> import org . atmosphere . util . StringFilterAggregator ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . annotation . PreDestroy ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import java . util . concurrent . Executors ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> @ Path ( "/{topic}" ) </a> 0
<a> @ Produces ( "text/plain;charset=ISO-8859-1" ) </a> 0
<a> public class PubSub { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( PubSub . class ) ; </a> 0
<a> @ PreDestroy </a> 0
<a> public void destroy ( ) { </a> 0
<a> logger . info ( "Testing the @PreDestroy" ) ; </a> 0
<a> } </a> 0
<a> private </a> 0
<a> @ PathParam ( "topic" ) </a> 0
<a> Broadcaster topic ; </a> 0
<a> @ GET </a> 0
<a> @ Suspend ( listeners = { EventsLogger . class } ) </a> 0
<a> public Broadcastable subscribe ( ) { </a> 0
<a> return new Broadcastable ( topic ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "subscribeAndUsingExternalThread" ) </a> 0
<a> @ Suspend ( resumeOnBroadcast = true , listeners = { EventsLogger . class } ) </a> 0
<a> public String subscribeAndResumeUsingExternalThread ( final @ PathParam ( "topic" ) String topic ) { </a> 0
<a> Executors . newSingleThreadExecutor ( ) . submit ( new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 5000 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> BroadcasterFactory . getDefault ( ) . lookup ( JerseyBroadcaster . class , topic ) . broadcast ( "\nEcho: " + topic ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> return "foo" ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Suspend ( resumeOnBroadcast = true , listeners = { EventsLogger . class } ) </a> 0
<a> @ Path ( "subscribeAndResume" ) </a> 0
<a> public Broadcastable subscribeAndResume ( ) { </a> 0
<a> return new Broadcastable ( topic ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Produces ( "application/xml" ) </a> 0
<a> @ Broadcast </a> 0
<a> public Broadcastable publishWithXML ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return new Broadcastable ( new JAXBBean ( message ) , topic ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Broadcast </a> 0
<a> public Broadcastable publish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Broadcast ( value = { StringFilterAggregator . class } ) </a> 1
<a> @ Path ( "aggregate" ) </a> 0
<a> public Broadcastable aggregate ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 5 , resumeOnBroadcast = true ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "scheduleAndResume" ) </a> 0
<a> public Broadcastable scheduleAndResume ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 10 , waitFor = 5 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "delaySchedule" ) </a> 0
<a> public Broadcastable delaySchedule ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 5 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "schedule" ) </a> 0
<a> public Broadcastable schedule ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Broadcast ( delay = 5 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "delay" ) </a> 0
<a> public Broadcastable delayPublish ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Broadcast ( delay = 5 , resumeOnBroadcast = true ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "delayAndResume" ) </a> 0
<a> public Broadcastable delayPublishAndResume ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ Path ( "buffer" ) </a> 0
<a> @ POST </a> 0
<a> @ Broadcast ( delay = 0 ) </a> 0
<a> public Broadcastable buffer ( @ FormParam ( "message" ) String message ) { </a> 0
<a> return broadcast ( message ) ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "broadcast" ) </a> 0
<a> public String manualDelayBroadcast ( @ FormParam ( "message" ) String message ) { </a> 0
<a> topic . delayBroadcast ( message , 10 , TimeUnit . SECONDS ) ; </a> 0
<a> return message ; </a> 0
<a> } </a> 0
<a> Broadcastable broadcast ( String m ) { </a> 0
<a> return new Broadcastable ( m + "\n" , topic ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . pubsub ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . jersey . JerseyBroadcaster ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> public class PubSubBroadcaster extends JerseyBroadcaster { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( PubSubBroadcaster . class ) ; </a> 0
<a> private final AtomicBoolean isSet = new AtomicBoolean ( false ) ; </a> 0
<a> public PubSubBroadcaster ( ) { </a> 0
<a> } </a> 0
<a> public PubSubBroadcaster ( String id ) { </a> 0
<a> super ( id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void broadcast ( final AtmosphereResource r , final AtmosphereResourceEvent e ) { </a> 1
<a> if ( ! isSet . getAndSet ( true ) ) { </a> 0
<a> logger . info ( "This is just an example that demonstrate " + </a> 0
<a> "how a Broadcaster can be customized using atmosphere.xml or by " + </a> 0
<a> "defining it inside web.xml" ) ; </a> 0
<a> } </a> 0
<a> super . broadcast ( r , e ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . commons . jersey ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 1
<a> import org . atmosphere . annotation . Schedule ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 1
<a> import org . atmosphere . util . XSSHtmlFilter ; </a> 0
<a> import javax . ws . rs . Consumes ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import javax . ws . rs . WebApplicationException ; </a> 0
<a> import javax . ws . rs . core . MultivaluedMap ; </a> 0
<a> @ Path ( "/chat" ) </a> 0
<a> @ Produces ( "text/html;charset=ISO-8859-1" ) </a> 0
<a> public class ResourceChat { </a> 0
<a> @ Suspend </a> 0
<a> @ GET </a> 0
<a> public String suspend ( ) { </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> @ Broadcast ( { XSSHtmlFilter . class , JsonpFilter . class } ) </a> 0
<a> @ Consumes ( "application/x-www-form-urlencoded" ) </a> 0
<a> @ POST </a> 0
<a> public String publishMessage ( MultivaluedMap < String , String > form ) { </a> 0
<a> String action = form . getFirst ( "action" ) ; </a> 0
<a> String name = form . getFirst ( "name" ) ; </a> 0
<a> if ( "login" . equals ( action ) ) { </a> 0
<a> return ( "System Message" + "__" + name + " has joined." ) ; </a> 0
<a> } else if ( "post" . equals ( action ) ) { </a> 0
<a> return name + "__" + form . getFirst ( "message" ) ; </a> 0
<a> } else { </a> 0
<a> throw new WebApplicationException ( 422 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Schedule ( period = 30 ) </a> 0
<a> @ POST </a> 0
<a> @ Path ( "/ping" ) </a> 0
<a> public String pingSuspendedClients ( ) { </a> 0
<a> return "Atmosphere__ping" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . chat . resources ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . annotation . Cluster ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . commons . jersey . JsonpFilter ; </a> 0
<a> import org . atmosphere . plugin . jgroups . JGroupsFilter ; </a> 0
<a> import org . atmosphere . util . XSSHtmlFilter ; </a> 0
<a> import javax . ws . rs . Consumes ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import javax . ws . rs . WebApplicationException ; </a> 0
<a> import javax . ws . rs . core . MultivaluedMap ; </a> 0
<a> @ Path ( "/chat" ) </a> 0
<a> public class ResourceChat { </a> 0
<a> @ Suspend </a> 0
<a> @ GET </a> 0
<a> @ Produces ( "text/html;charset=ISO-8859-1" ) </a> 0
<a> public String suspend ( ) { </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> @ Broadcast ( { XSSHtmlFilter . class , JsonpFilter . class } ) </a> 0
<a> @ Consumes ( "application/x-www-form-urlencoded" ) </a> 0
<a> @ POST </a> 0
<a> @ Produces ( "text/html" ) </a> 0
<a> @ Cluster ( </a> 0
<a> name = "chat" , </a> 0
<a> value = JGroupsFilter . class </a> 0
<a> ) </a> 0
<a> public String publishMessage ( MultivaluedMap < String , String > form ) { </a> 0
<a> String action = form . getFirst ( "action" ) ; </a> 0
<a> String name = form . getFirst ( "name" ) ; </a> 0
<a> if ( "login" . equals ( action ) ) { </a> 0
<a> return ( "System Message" + "__" + name + " has joined." ) ; </a> 0
<a> } else if ( "post" . equals ( action ) ) { </a> 0
<a> return name + "__" + form . getFirst ( "message" ) ; </a> 0
<a> } else { </a> 0
<a> throw new WebApplicationException ( 422 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . rest . counter ; </a> 0
<a> import com . sun . jersey . spi . resource . Singleton ; </a> 0
<a> import org . atmosphere . annotation . Broadcast ; </a> 0
<a> import org . atmosphere . annotation . Resume ; </a> 0
<a> import org . atmosphere . annotation . Suspend ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> @ Path ( "{counter}" ) </a> 0
<a> @ Singleton </a> 0
<a> public class RestLongPolling { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( RestLongPolling . class ) ; </a> 0
<a> private final AtomicInteger counter = new AtomicInteger ( ) ; </a> 0
<a> @ Suspend </a> 0
<a> @ GET </a> 0
<a> @ Produces ( "text/html;charset=ISO-8859-1" ) </a> 0
<a> public String suspend ( ) { </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> @ POST </a> 0
<a> @ Path ( "{counter}" ) </a> 0
<a> @ Broadcast ( resumeOnBroadcast = true ) </a> 0
<a> public String increment ( @ PathParam ( "counter" ) String count ) { </a> 0
<a> logger . info ( "Broadcasting and resuming: {}" , count ) ; </a> 0
<a> counter . incrementAndGet ( ) ; </a> 0
<a> return counter . toString ( ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "/{uuid}" ) </a> 0
<a> @ Resume </a> 0
<a> public String resume ( ) { </a> 0
<a> logger . info ( "Resuming" ) ; </a> 0
<a> return "Resumed" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . twitter ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . jersey . JerseyBroadcaster ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> public class TwitterBroadcaster extends JerseyBroadcaster { </a> 0
<a> public TwitterBroadcaster ( ) { </a> 0
<a> } </a> 0
<a> private AtmosphereResourceEvent event ; </a> 0
<a> public void setUserAtmosphereEvent ( AtmosphereResourceEvent event ) { </a> 0
<a> this . event = event ; </a> 0
<a> } </a> 0
<a> public AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > getUserAtmosphereEvent ( ) { </a> 0
<a> return event ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public AtmosphereResource < ? , ? > addAtmosphereResource ( AtmosphereResource < ? , ? > r ) { </a> 0
<a> if ( getAtmosphereResources ( ) . size ( ) == 0 ) { </a> 0
<a> event = r . getAtmosphereResourceEvent ( ) ; </a> 0
<a> } </a> 0
<a> return super . addAtmosphereResource ( r ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . twitter ; </a> 0
<a> import org . atmosphere . samples . twitter . UsersState . UserStateData ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . ws . rs . Consumes ; </a> 0
<a> import javax . ws . rs . DELETE ; </a> 0
<a> import javax . ws . rs . FormParam ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . POST ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . WebApplicationException ; </a> 0
<a> import javax . ws . rs . core . MediaType ; </a> 0
<a> public class UserResource { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( UserResource . class ) ; </a> 0
<a> private final UsersState us ; </a> 0
<a> private String user ; </a> 0
<a> private UserStateData usd ; </a> 0
<a> public UserResource ( UsersState us , String name , UserStateData usd ) { </a> 0
<a> this . us = us ; </a> 0
<a> this . user = name ; </a> 0
<a> this . usd = usd ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> public String get ( ) { </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> @ DELETE </a> 0
<a> public void delete ( ) { </a> 0
<a> us . remove ( user ) ; </a> 0
<a> } </a> 0
<a> @ Path ( "messages" ) </a> 0
<a> @ POST </a> 0
<a> public void post ( String message ) { </a> 0
<a> logger . info ( "MESSAGE: {}" , message ) ; </a> 0
<a> } </a> 0
<a> @ Path ( "follows" ) </a> 0
<a> @ POST </a> 0
<a> @ Consumes ( MediaType . APPLICATION_FORM_URLENCODED ) </a> 0
<a> public void follow ( @ FormParam ( "follower" ) String follower ) { </a> 0
<a> UserStateData followerState = us . get ( follower ) ; </a> 0
<a> if ( followerState == null ) { </a> 0
<a> throw new WebApplicationException ( 404 ) ; </a> 0
<a> } </a> 0
<a> followerState . bc . addAtmosphereResource ( us . get ( user ) . bc . getUserAtmosphereEvent ( ) . getResource ( ) ) ; </a> 0
<a> followerState . bc . broadcast ( user + " is now follow you " , </a> 0
<a> followerState . bc . getUserAtmosphereEvent ( ) . getResource ( ) ) ; </a> 0
<a> logger . info ( "{} is following {}" , user , follower ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . twitter ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class UsersState { </a> 0
<a> private Map < String , UserStateData > map = new HashMap < String , UserStateData > ( ) ; </a> 0
<a> public static class UserStateData { </a> 0
<a> public final TwitterBroadcaster bc ; </a> 0
<a> public UserStateData ( TwitterBroadcaster bc ) { </a> 0
<a> this . bc = bc ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public synchronized UserStateData get ( String name ) { </a> 0
<a> return map . get ( name ) ; </a> 0
<a> } </a> 0
<a> public synchronized UserStateData create ( String user , TwitterBroadcaster bc ) { </a> 0
<a> UserStateData usd = get ( user ) ; </a> 0
<a> if ( usd != null ) </a> 0
<a> return null ; </a> 0
<a> usd = new UserStateData ( bc ) ; </a> 0
<a> map . put ( user , usd ) ; </a> 0
<a> return usd ; </a> 0
<a> } </a> 0
<a> public synchronized boolean remove ( String user ) { </a> 0
<a> return map . remove ( user ) != null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package app ; </a> 0
<a> import org . apache . log4j . Logger ; </a> 0
<a> import org . apache . struts . action . ActionForm ; </a> 0
<a> import org . apache . struts . action . ActionForward ; </a> 0
<a> import org . apache . struts . action . ActionMapping ; </a> 0
<a> import org . apache . struts . actions . DispatchAction ; </a> 0
<a> import org . atmosphere . cpr . BroadcastFilter ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . cpr . DefaultBroadcaster ; </a> 0
<a> import org . atmosphere . cpr . Meteor ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . util . LinkedList ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class SimpleAction extends DispatchAction { </a> 0
<a> public static final Logger logger = Logger . getLogger ( SimpleAction . class ) ; </a> 0
<a> private final List < BroadcastFilter > list ; </a> 0
<a> private final Broadcaster b = new DefaultBroadcaster ( "Struts" ) ; </a> 0
<a> public SimpleAction ( ) { </a> 0
<a> list = new LinkedList < BroadcastFilter > ( ) ; </a> 0
<a> } </a> 0
<a> public ActionForward unspecified ( ActionMapping mapping , ActionForm _form , HttpServletRequest req , HttpServletResponse res ) throws Exception { </a> 0
<a> logger . error ( "IN ACTION" ) ; </a> 0
<a> return mapping . findForward ( "success" ) ; </a> 0
<a> } </a> 0
<a> public ActionForward echo ( ActionMapping mapping , ActionForm _form , HttpServletRequest req , HttpServletResponse res ) throws Exception { </a> 0
<a> logger . info ( "BEGIN SimpleAction.echo()" ) ; </a> 0
<a> String value = req . getParameter ( "value" ) ; </a> 0
<a> res . getWriter ( ) . print ( "{message: 'Server says: " + value + "'}" ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public ActionForward openCometChannel ( ActionMapping mapping , ActionForm _form , HttpServletRequest req , HttpServletResponse res ) throws Exception { </a> 0
<a> logger . info ( "BEGIN SimpleAction.openCometChannel()" ) ; </a> 0
<a> Meteor m = Meteor . build ( req , list , null ) ; </a> 0
<a> m . setBroadcaster ( b ) ; </a> 0
<a> req . getSession ( ) . setAttribute ( "meteor" , m ) ; </a> 0
<a> m . suspend ( - 1 ) ; </a> 0
<a> m . broadcast ( req . getServerName ( ) </a> 0
<a> + "__has suspended a connection from " + req . getRemoteAddr ( ) ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public ActionForward sendCometMsg ( ActionMapping mapping , ActionForm _form , HttpServletRequest req , HttpServletResponse res ) throws Exception { </a> 0
<a> logger . info ( "BEGIN SimpleAction.sendCometMsg()" ) ; </a> 0
<a> Meteor m = ( Meteor ) req . getSession ( ) . getAttribute ( "meteor" ) ; </a> 0
<a> logger . info ( "meteor: " + m ) ; </a> 0
<a> res . setCharacterEncoding ( "UTF-8" ) ; </a> 0
<a> String value = req . getParameter ( "value" ) ; </a> 0
<a> logger . debug ( "value: " + value ) ; </a> 0
<a> m . broadcast ( "<script>parent.cometMsg('Broadcast: " + value + "');</script>" ) ; </a> 0
<a> res . getWriter ( ) . write ( "{message:'success'}" ) ; </a> 0
<a> res . getWriter ( ) . flush ( ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . tictactoe ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereHandler ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResource ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . PrintWriter ; </a> 0
<a> public class TTTHandler implements AtmosphereHandler < HttpServletRequest , HttpServletResponse > { </a> 0
<a> private static TTTGame game = new TTTGame ( ) ; </a> 0
<a> public void onRequest ( AtmosphereResource < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> HttpServletRequest req = event . getRequest ( ) ; </a> 0
<a> HttpServletResponse res = event . getResponse ( ) ; </a> 0
<a> res . setContentType ( "text/html" ) ; </a> 0
<a> res . addHeader ( "Cache-Control" , "private" ) ; </a> 0
<a> res . addHeader ( "Pragma" , "no-cache" ) ; </a> 0
<a> if ( req . getMethod ( ) . equalsIgnoreCase ( "GET" ) ) { </a> 0
<a> event . suspend ( ) ; </a> 0
<a> } else if ( req . getMethod ( ) . equalsIgnoreCase ( "POST" ) ) { </a> 0
<a> synchronized ( game ) { </a> 0
<a> int cell = - 1 ; </a> 0
<a> String cellStr = req . getParameter ( "cell" ) ; </a> 0
<a> PrintWriter writer = res . getWriter ( ) ; </a> 0
<a> writer . println ( "cell is '" + cellStr + "'" ) ; </a> 0
<a> if ( cellStr == null ) { </a> 0
<a> writer . println ( "error - cell not set" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> cell = Integer . parseInt ( cellStr ) ; </a> 0
<a> } catch ( NumberFormatException nfe ) { </a> 0
<a> writer . println ( "error - cellStr not an int: " + cellStr ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( ! game . turn ( cell ) ) { </a> 0
<a> writer . println ( "warning - invalid move" ) ; </a> 0
<a> } </a> 0
<a> writer . println ( game . getJSON ( ) ) ; </a> 0
<a> Broadcaster bc = event . getBroadcaster ( ) ; </a> 0
<a> String response = game . getJSON ( ) ; </a> 0
<a> bc . broadcast ( response ) ; </a> 0
<a> writer . flush ( ) ; </a> 0
<a> if ( game . win ( ) != - 1 ) { </a> 0
<a> game = new TTTGame ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onStateChange ( </a> 0
<a> AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) throws IOException { </a> 0
<a> if ( event . isCancelled ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( ! event . isResumedOnTimeout ( ) ) { </a> 0
<a> String response = ( String ) event . getMessage ( ) ; </a> 0
<a> response = "<script type='text/javascript'>parent.chImg(" + response + ")</script>\n" ; </a> 0
<a> PrintWriter writer = event . getResource ( ) . getResponse ( ) . getWriter ( ) ; </a> 0
<a> writer . write ( response ) ; </a> 0
<a> writer . flush ( ) ; </a> 0
<a> event . getResource ( ) . resume ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . twitter ; </a> 0
<a> import javax . servlet . ServletContext ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import javax . ws . rs . core . Context ; </a> 0
<a> import javax . ws . rs . core . PathSegment ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> @ Path ( "/" ) </a> 0
<a> @ Produces ( "text/html" ) </a> 0
<a> public class FileResource { </a> 0
<a> private </a> 0
<a> @ Context </a> 0
<a> ServletContext sc ; </a> 0
<a> @ Path ( "/jquery/{id}" ) </a> 0
<a> @ GET </a> 0
<a> public InputStream getJQuery ( @ PathParam ( "id" ) PathSegment ps ) { </a> 0
<a> return sc . getResourceAsStream ( "/jquery/" + ps . getPath ( ) ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> public InputStream getIndex ( ) { </a> 0
<a> return sc . getResourceAsStream ( "/index.html" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . twitter ; </a> 0
<a> import com . ning . http . client . AsyncCompletionHandler ; </a> 0
<a> import com . ning . http . client . AsyncHttpClient ; </a> 0
<a> import com . ning . http . client . Response ; </a> 0
<a> import com . sun . jersey . spi . resource . Singleton ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . Broadcaster ; </a> 0
<a> import org . atmosphere . jersey . SuspendResponse ; </a> 0
<a> import org . codehaus . jettison . json . JSONObject ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import javax . ws . rs . GET ; </a> 0
<a> import javax . ws . rs . Path ; </a> 0
<a> import javax . ws . rs . PathParam ; </a> 0
<a> import javax . ws . rs . Produces ; </a> 0
<a> import javax . ws . rs . WebApplicationException ; </a> 0
<a> import java . util . concurrent . Callable ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 0
<a> import java . util . concurrent . CountDownLatch ; </a> 0
<a> import java . util . concurrent . Future ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 0
<a> @ Path ( "/search/{tagid}" ) </a> 0
<a> @ Produces ( "text/html;charset=ISO-8859-1" ) </a> 0
<a> @ Singleton </a> 0
<a> public class TwitterFeed { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( TwitterFeed . class ) ; </a> 0
<a> private final AsyncHttpClient asyncClient = new AsyncHttpClient ( ) ; </a> 0
<a> private final ConcurrentHashMap < String , Future < ? > > futures = new ConcurrentHashMap < String , Future < ? > > ( ) ; </a> 0
<a> private final CountDownLatch suspendLatch = new CountDownLatch ( 1 ) ; </a> 0
<a> @ GET </a> 0
<a> public SuspendResponse < String > search ( final @ PathParam ( "tagid" ) Broadcaster feed , </a> 0
<a> final @ PathParam ( "tagid" ) String tagid ) { </a> 0
<a> if ( tagid . isEmpty ( ) ) { </a> 0
<a> throw new WebApplicationException ( ) ; </a> 0
<a> } </a> 0
<a> if ( feed . getAtmosphereResources ( ) . size ( ) == 0 ) { </a> 0
<a> final Future < ? > future = feed . scheduleFixedBroadcast ( new Callable < String > ( ) { </a> 0
<a> private final AtomicReference < String > refreshUrl = new AtomicReference < String > ( "" ) ; </a> 0
<a> public String call ( ) throws Exception { </a> 0
<a> String query = null ; </a> 0
<a> if ( ! refreshUrl . get ( ) . isEmpty ( ) ) { </a> 0
<a> query = refreshUrl . get ( ) ; </a> 0
<a> } else { </a> 0
<a> query = "?q=" + tagid ; </a> 0
<a> } </a> 0
<a> suspendLatch . await ( ) ; </a> 0
<a> asyncClient . prepareGet ( "http://search.twitter.com/search.json" + query ) . execute ( </a> 0
<a> new AsyncCompletionHandler < Object > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Object onCompleted ( Response response ) throws Exception { </a> 0
<a> String s = response . getResponseBody ( ) ; </a> 0
<a> if ( response . getStatusCode ( ) != 200 ) { </a> 0
<a> feed . resumeAll ( ) ; </a> 0
<a> feed . destroy ( ) ; </a> 0
<a> logger . info ( "Twitter Search API unavaileble\n{}" , s ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> JSONObject json = new JSONObject ( s ) ; </a> 0
<a> refreshUrl . set ( json . getString ( "refresh_url" ) ) ; </a> 0
<a> if ( json . getJSONArray ( "results" ) . length ( ) > 1 ) { </a> 0
<a> feed . broadcast ( s ) . get ( ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } , 1 , TimeUnit . SECONDS ) ; </a> 1
<a> futures . put ( tagid , future ) ; </a> 0
<a> } </a> 0
<a> return new SuspendResponse . SuspendResponseBuilder < String > ( ) . broadcaster ( feed ) . outputComments ( true ) </a> 0
<a> . addListener ( new EventsLogger ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onSuspend ( </a> 0
<a> final AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> super . onSuspend ( event ) ; </a> 0
<a> suspendLatch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } ) . build ( ) ; </a> 0
<a> } </a> 0
<a> @ GET </a> 0
<a> @ Path ( "stop" ) </a> 0
<a> public String stopSearch ( final @ PathParam ( "tagid" ) Broadcaster feed , </a> 0
<a> final @ PathParam ( "tagid" ) String tagid ) { </a> 0
<a> feed . resumeAll ( ) ; </a> 0
<a> futures . get ( tagid ) . cancel ( true ) ; </a> 0
<a> logger . info ( "Stopping real time update for {}" , tagid ) ; </a> 0
<a> return "DONE" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . wicket ; </a> 0
<a> import org . apache . wicket . markup . html . basic . Label ; </a> 0
<a> import org . apache . wicket . markup . html . link . BookmarkablePageLink ; </a> 0
<a> import org . apache . wicket . markup . html . panel . Panel ; </a> 0
<a> import org . apache . wicket . model . AbstractReadOnlyModel ; </a> 0
<a> import java . util . Date ; </a> 0
<a> public class ClockPanel extends Panel { </a> 0
<a> public ClockPanel ( String id ) { </a> 0
<a> super ( id ) ; </a> 0
<a> add ( new BookmarkablePageLink < PushPage > ( "cometStart" , PushPage . class ) ) ; </a> 0
<a> add ( new Label ( "clock" , new AbstractReadOnlyModel < String > ( ) { </a> 0
<a> @ Override </a> 0
<a> public String getObject ( ) { </a> 0
<a> return new Date ( ) . toString ( ) ; </a> 0
<a> } </a> 0
<a> } ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . wicket ; </a> 0
<a> import org . apache . wicket . PageParameters ; </a> 0
<a> import org . apache . wicket . markup . html . WebPage ; </a> 0
<a> import org . apache . wicket . markup . html . basic . Label ; </a> 0
<a> public class HomePage extends WebPage { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> public HomePage ( final PageParameters parameters ) { </a> 0
<a> add ( new Label ( "message" , "This clock updates the time using Atmosphere Meteor PUSH framework" ) ) ; </a> 0
<a> add ( new ClockPanel ( "clockPanel" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package org . atmosphere . samples . wicket ; </a> 0
<a> import org . apache . wicket . markup . html . WebPage ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEvent ; </a> 0
<a> import org . atmosphere . cpr . AtmosphereResourceEventListener ; </a> 0
<a> import org . atmosphere . cpr . Meteor ; </a> 0
<a> import org . slf4j . Logger ; </a> 0
<a> import org . slf4j . LoggerFactory ; </a> 0
<a> import javax . servlet . http . HttpServletRequest ; </a> 0
<a> import javax . servlet . http . HttpServletResponse ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . concurrent . Callable ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . X_ATMOSPHERE_TRANSPORT ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . LONG_POLLING_TRANSPORT ; </a> 0
<a> import static org . atmosphere . cpr . HeaderConfig . WEBSOCKET_TRANSPORT ; </a> 0
<a> public class PushPage extends WebPage implements AtmosphereResourceEventListener { </a> 0
<a> private static final Logger logger = LoggerFactory . getLogger ( PushPage . class ) ; </a> 0
<a> private final AtomicBoolean scheduleStarted = new AtomicBoolean ( false ) ; </a> 0
<a> public PushPage ( ) { </a> 0
<a> HttpServletRequest req = getWebRequestCycle ( ) . getWebRequest ( ) . getHttpServletRequest ( ) ; </a> 0
<a> Meteor meteor = Meteor . build ( req ) ; </a> 0
<a> if ( ! scheduleStarted . getAndSet ( true ) ) { </a> 0
<a> meteor . schedule ( new Callable < String > ( ) { </a> 0
<a> public String call ( ) { </a> 0
<a> String s = new Date ( ) . toString ( ) ; </a> 0
<a> return s ; </a> 0
<a> } </a> 0
<a> } , 1 ) ; </a> 0
<a> } </a> 0
<a> meteor . addListener ( this ) ; </a> 0
<a> String transport = req . getHeader ( X_ATMOSPHERE_TRANSPORT ) ; </a> 0
<a> meteor . suspend ( - 1 , ! ( transport != null && transport . equalsIgnoreCase ( LONG_POLLING_TRANSPORT ) ) ) ; </a> 0
<a> } </a> 0
<a> public void onBroadcast ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onBroadcast(): {}" , event . getMessage ( ) ) ; </a> 0
<a> String transport = event . getResource ( ) . getRequest ( ) . getHeader ( X_ATMOSPHERE_TRANSPORT ) ; </a> 0
<a> if ( transport != null && transport . equalsIgnoreCase ( LONG_POLLING_TRANSPORT ) ) { </a> 0
<a> Meteor meteor = Meteor . lookup ( event . getResource ( ) . getRequest ( ) ) ; </a> 0
<a> meteor . removeListener ( this ) ; </a> 0
<a> meteor . resume ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onSuspend ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> String transport = event . getResource ( ) . getRequest ( ) . getHeader ( X_ATMOSPHERE_TRANSPORT ) ; </a> 0
<a> HttpServletRequest req = event . getResource ( ) . getRequest ( ) ; </a> 0
<a> logger . info ( "Suspending the %s response from ip {}:{}" , </a> 0
<a> new Object [ ] { transport == null ? WEBSOCKET_TRANSPORT : transport , req . getRemoteAddr ( ) , req . getRemotePort ( ) } ) ; </a> 0
<a> } </a> 0
<a> public void onResume ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> String transport = event . getResource ( ) . getRequest ( ) . getHeader ( X_ATMOSPHERE_TRANSPORT ) ; </a> 0
<a> HttpServletRequest req = event . getResource ( ) . getRequest ( ) ; </a> 0
<a> logger . info ( "Resuming the {} response from ip {}:{}" , </a> 0
<a> new Object [ ] { transport == null ? WEBSOCKET_TRANSPORT : transport , req . getRemoteAddr ( ) , req . getRemotePort ( ) } ) ; </a> 0
<a> } </a> 0
<a> public void onDisconnect ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> String transport = event . getResource ( ) . getRequest ( ) . getHeader ( X_ATMOSPHERE_TRANSPORT ) ; </a> 0
<a> HttpServletRequest req = event . getResource ( ) . getRequest ( ) ; </a> 0
<a> logger . info ( "{} connection dropped from ip {}:{}" , </a> 0
<a> new Object [ ] { transport == null ? WEBSOCKET_TRANSPORT : transport , req . getRemoteAddr ( ) , req . getRemotePort ( ) } ) ; </a> 0
<a> } </a> 0
<a> public void onThrowable ( AtmosphereResourceEvent < HttpServletRequest , HttpServletResponse > event ) { </a> 0
<a> logger . info ( "onThrowable()" , event . throwable ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . atmosphere . samples . test ; </a> 0
<a> import org . mortbay . jetty . Connector ; </a> 0
<a> import org . mortbay . jetty . Server ; </a> 0
<a> import org . mortbay . jetty . bio . SocketConnector ; </a> 0
<a> import org . mortbay . jetty . webapp . WebAppContext ; </a> 0
<a> public class Start { </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> Server server = new Server ( ) ; </a> 0
<a> SocketConnector connector = new SocketConnector ( ) ; </a> 0
<a> connector . setMaxIdleTime ( 1000 * 60 * 60 ) ; </a> 0
<a> connector . setSoLingerTime ( - 1 ) ; </a> 0
<a> connector . setPort ( 8080 ) ; </a> 0
<a> server . setConnectors ( new Connector [ ] { connector } ) ; </a> 0
<a> WebAppContext bb = new WebAppContext ( ) ; </a> 0
<a> bb . setServer ( server ) ; </a> 0
<a> bb . setContextPath ( "/" ) ; </a> 0
<a> bb . setWar ( "src/main/webapp" ) ; </a> 0
<a> server . addHandler ( bb ) ; </a> 0
<a> try { </a> 0
<a> System . out . println ( ">>> STARTING EMBEDDED JETTY SERVER, PRESS ANY KEY TO STOP" ) ; </a> 0
<a> server . start ( ) ; </a> 0
<a> System . in . read ( ) ; </a> 0
<a> System . out . println ( ">>> STOPPING EMBEDDED JETTY SERVER" ) ; </a> 0
<a> server . stop ( ) ; </a> 0
<a> server . join ( ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> System . exit ( 100 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> package org . atmosphere . samples . test ; </a> 0
<a> import junit . framework . TestCase ; </a> 0
<a> import org . apache . wicket . util . tester . WicketTester ; </a> 0
<a> import org . atmosphere . samples . wicket . HomePage ; </a> 0
<a> import org . atmosphere . samples . wicket . WicketPushApplication ; </a> 0
<a> public class TestHomePage extends TestCase { </a> 0
<a> private WicketTester tester ; </a> 0
<a> @ Override </a> 0
<a> public void setUp ( ) throws InstantiationException , IllegalAccessException { </a> 0
<a> tester = new WicketTester ( new WicketPushApplication ( ) ) ; </a> 0
<a> } </a> 0
<a> public void testRenderMyPage ( ) { </a> 0
<a> tester . startPage ( HomePage . class ) ; </a> 0
<a> tester . assertRenderedPage ( HomePage . class ) ; </a> 0
<a> tester . assertLabel ( "message" , "This clock updates the time using Atmosphere Meteor PUSH framework" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . sdk ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> public class StatusActivity extends Activity </a> 0
<a> { </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) </a> 0
<a> { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . main ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . annotation . SuppressLint ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import com . facebook . internal . Validate ; </a> 0
<a> import java . io . InvalidObjectException ; </a> 0
<a> import java . io . ObjectInputStream ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . List ; </a> 0
<a> public final class AccessToken implements Serializable { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> static final String ACCESS_TOKEN_KEY = "access_token" ; </a> 0
<a> static final String EXPIRES_IN_KEY = "expires_in" ; </a> 0
<a> private static final Date MIN_DATE = new Date ( Long . MIN_VALUE ) ; </a> 0
<a> private static final Date MAX_DATE = new Date ( Long . MAX_VALUE ) ; </a> 0
<a> private static final Date DEFAULT_EXPIRATION_TIME = MAX_DATE ; </a> 0
<a> private static final Date DEFAULT_LAST_REFRESH_TIME = new Date ( ) ; </a> 0
<a> private static final AccessTokenSource DEFAULT_ACCESS_TOKEN_SOURCE = AccessTokenSource . FACEBOOK_APPLICATION_WEB ; </a> 0
<a> private static final Date ALREADY_EXPIRED_EXPIRATION_TIME = MIN_DATE ; </a> 0
<a> private final Date expires ; </a> 0
<a> private final List < String > permissions ; </a> 0
<a> private final String token ; </a> 0
<a> private final AccessTokenSource source ; </a> 0
<a> private final Date lastRefresh ; </a> 0
<a> AccessToken ( String token , Date expires , List < String > permissions , AccessTokenSource source , Date lastRefresh ) { </a> 0
<a> if ( permissions == null ) { </a> 0
<a> permissions = Collections . emptyList ( ) ; </a> 0
<a> } </a> 0
<a> this . expires = expires ; </a> 0
<a> this . permissions = Collections . unmodifiableList ( permissions ) ; </a> 0
<a> this . token = token ; </a> 0
<a> this . source = source ; </a> 0
<a> this . lastRefresh = lastRefresh ; </a> 0
<a> } </a> 0
<a> public String getToken ( ) { </a> 0
<a> return this . token ; </a> 0
<a> } </a> 0
<a> public Date getExpires ( ) { </a> 0
<a> return this . expires ; </a> 0
<a> } </a> 0
<a> public List < String > getPermissions ( ) { </a> 0
<a> return this . permissions ; </a> 0
<a> } </a> 0
<a> public AccessTokenSource getSource ( ) { </a> 0
<a> return source ; </a> 0
<a> } </a> 0
<a> public Date getLastRefresh ( ) { </a> 0
<a> return this . lastRefresh ; </a> 0
<a> } </a> 0
<a> public static AccessToken createFromExistingAccessToken ( String accessToken , Date expirationTime , </a> 0
<a> Date lastRefreshTime , AccessTokenSource accessTokenSource , List < String > permissions ) { </a> 0
<a> if ( expirationTime == null ) { </a> 0
<a> expirationTime = DEFAULT_EXPIRATION_TIME ; </a> 0
<a> } </a> 0
<a> if ( lastRefreshTime == null ) { </a> 0
<a> lastRefreshTime = DEFAULT_LAST_REFRESH_TIME ; </a> 0
<a> } </a> 0
<a> if ( accessTokenSource == null ) { </a> 0
<a> accessTokenSource = DEFAULT_ACCESS_TOKEN_SOURCE ; </a> 0
<a> } </a> 0
<a> return new AccessToken ( accessToken , expirationTime , permissions , accessTokenSource , lastRefreshTime ) ; </a> 0
<a> } </a> 0
<a> public static AccessToken createFromNativeLinkingIntent ( Intent intent ) { </a> 0
<a> Validate . notNull ( intent , "intent" ) ; </a> 0
<a> if ( intent . getExtras ( ) == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return createFromBundle ( null , intent . getExtras ( ) , AccessTokenSource . FACEBOOK_APPLICATION_WEB , new Date ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder builder = new StringBuilder ( ) ; </a> 0
<a> builder . append ( "{AccessToken" ) ; </a> 0
<a> builder . append ( " token:" ) . append ( tokenToString ( ) ) ; </a> 0
<a> appendPermissions ( builder ) ; </a> 0
<a> builder . append ( "}" ) ; </a> 0
<a> return builder . toString ( ) ; </a> 0
<a> } </a> 0
<a> static AccessToken createEmptyToken ( List < String > permissions ) { </a> 0
<a> return new AccessToken ( "" , ALREADY_EXPIRED_EXPIRATION_TIME , permissions , AccessTokenSource . NONE , </a> 0
<a> DEFAULT_LAST_REFRESH_TIME ) ; </a> 0
<a> } </a> 0
<a> static AccessToken createFromString ( String token , List < String > permissions , AccessTokenSource source ) { </a> 0
<a> return new AccessToken ( token , DEFAULT_EXPIRATION_TIME , permissions , source , DEFAULT_LAST_REFRESH_TIME ) ; </a> 0
<a> } </a> 0
<a> static AccessToken createFromNativeLogin ( Bundle bundle , AccessTokenSource source ) { </a> 0
<a> Date expires = getBundleLongAsDate ( </a> 0
<a> bundle , NativeProtocol . EXTRA_EXPIRES_SECONDS_SINCE_EPOCH , new Date ( 0 ) ) ; </a> 0
<a> ArrayList < String > permissions = bundle . getStringArrayList ( NativeProtocol . EXTRA_PERMISSIONS ) ; </a> 0
<a> String token = bundle . getString ( NativeProtocol . EXTRA_ACCESS_TOKEN ) ; </a> 0
<a> return createNew ( permissions , token , expires , source ) ; </a> 0
<a> } </a> 0
<a> static AccessToken createFromWebBundle ( List < String > requestedPermissions , Bundle bundle , AccessTokenSource source ) { </a> 0
<a> Date expires = getBundleLongAsDate ( bundle , EXPIRES_IN_KEY , new Date ( ) ) ; </a> 0
<a> String token = bundle . getString ( ACCESS_TOKEN_KEY ) ; </a> 0
<a> return createNew ( requestedPermissions , token , expires , source ) ; </a> 0
<a> } </a> 0
<a> @ SuppressLint ( "FieldGetter" ) </a> 0
<a> static AccessToken createFromRefresh ( AccessToken current , Bundle bundle ) { </a> 0
<a> assert ( current . source == AccessTokenSource . FACEBOOK_APPLICATION_WEB || </a> 0
<a> current . source == AccessTokenSource . FACEBOOK_APPLICATION_NATIVE || </a> 0
<a> current . source == AccessTokenSource . FACEBOOK_APPLICATION_SERVICE ) ; </a> 0
<a> Date expires = getBundleLongAsDate ( bundle , EXPIRES_IN_KEY , new Date ( 0 ) ) ; </a> 0
<a> String token = bundle . getString ( ACCESS_TOKEN_KEY ) ; </a> 0
<a> return createNew ( current . getPermissions ( ) , token , expires , current . source ) ; </a> 0
<a> } </a> 0
<a> static AccessToken createFromTokenWithRefreshedPermissions ( AccessToken token , List < String > permissions ) { </a> 0
<a> return new AccessToken ( token . token , token . expires , permissions , token . source , token . lastRefresh ) ; </a> 0
<a> } </a> 0
<a> private static AccessToken createNew ( </a> 0
<a> List < String > requestedPermissions , String accessToken , Date expires , AccessTokenSource source ) { </a> 0
<a> if ( Utility . isNullOrEmpty ( accessToken ) || ( expires == null ) ) { </a> 0
<a> return createEmptyToken ( requestedPermissions ) ; </a> 0
<a> } else { </a> 0
<a> return new AccessToken ( accessToken , expires , requestedPermissions , source , new Date ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static AccessToken createFromCache ( Bundle bundle ) { </a> 0
<a> List < String > originalPermissions = bundle . getStringArrayList ( TokenCachingStrategy . PERMISSIONS_KEY ) ; </a> 0
<a> List < String > permissions ; </a> 0
<a> if ( originalPermissions == null ) { </a> 0
<a> permissions = Collections . emptyList ( ) ; </a> 0
<a> } else { </a> 0
<a> permissions = Collections . unmodifiableList ( new ArrayList < String > ( originalPermissions ) ) ; </a> 0
<a> } </a> 0
<a> return new AccessToken ( bundle . getString ( TokenCachingStrategy . TOKEN_KEY ) , TokenCachingStrategy . getDate ( bundle , </a> 0
<a> TokenCachingStrategy . EXPIRATION_DATE_KEY ) , permissions , TokenCachingStrategy . getSource ( bundle ) , </a> 0
<a> TokenCachingStrategy . getDate ( bundle , TokenCachingStrategy . LAST_REFRESH_DATE_KEY ) ) ; </a> 0
<a> } </a> 0
<a> Bundle toCacheBundle ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putString ( TokenCachingStrategy . TOKEN_KEY , this . token ) ; </a> 0
<a> TokenCachingStrategy . putDate ( bundle , TokenCachingStrategy . EXPIRATION_DATE_KEY , expires ) ; </a> 0
<a> bundle . putStringArrayList ( TokenCachingStrategy . PERMISSIONS_KEY , new ArrayList < String > ( permissions ) ) ; </a> 0
<a> bundle . putSerializable ( TokenCachingStrategy . TOKEN_SOURCE_KEY , source ) ; </a> 0
<a> TokenCachingStrategy . putDate ( bundle , TokenCachingStrategy . LAST_REFRESH_DATE_KEY , lastRefresh ) ; </a> 0
<a> return bundle ; </a> 0
<a> } </a> 0
<a> boolean isInvalid ( ) { </a> 0
<a> return Utility . isNullOrEmpty ( this . token ) || new Date ( ) . after ( this . expires ) ; </a> 0
<a> } </a> 0
<a> private static AccessToken createFromBundle ( List < String > requestedPermissions , Bundle bundle , </a> 0
<a> AccessTokenSource source , </a> 0
<a> Date expirationBase ) { </a> 0
<a> String token = bundle . getString ( ACCESS_TOKEN_KEY ) ; </a> 0
<a> Date expires = getBundleLongAsDate ( bundle , EXPIRES_IN_KEY , expirationBase ) ; </a> 0
<a> if ( Utility . isNullOrEmpty ( token ) || ( expires == null ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return new AccessToken ( token , expires , requestedPermissions , source , new Date ( ) ) ; </a> 0
<a> } </a> 0
<a> private String tokenToString ( ) { </a> 0
<a> if ( this . token == null ) { </a> 0
<a> return "null" ; </a> 0
<a> } else if ( Settings . isLoggingBehaviorEnabled ( LoggingBehavior . INCLUDE_ACCESS_TOKENS ) ) { </a> 0
<a> return this . token ; </a> 0
<a> } else { </a> 0
<a> return "ACCESS_TOKEN_REMOVED" ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void appendPermissions ( StringBuilder builder ) { </a> 0
<a> builder . append ( " permissions:" ) ; </a> 0
<a> if ( this . permissions == null ) { </a> 0
<a> builder . append ( "null" ) ; </a> 0
<a> } else { </a> 0
<a> builder . append ( "[" ) ; </a> 0
<a> builder . append ( TextUtils . join ( ", " , permissions ) ) ; </a> 0
<a> builder . append ( "]" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class SerializationProxyV1 implements Serializable { </a> 0
<a> private static final long serialVersionUID = - 2488473066578201069L ; </a> 0
<a> private final Date expires ; </a> 0
<a> private final List < String > permissions ; </a> 0
<a> private final String token ; </a> 0
<a> private final AccessTokenSource source ; </a> 0
<a> private final Date lastRefresh ; </a> 0
<a> private SerializationProxyV1 ( String token , Date expires , </a> 0
<a> List < String > permissions , AccessTokenSource source , Date lastRefresh ) { </a> 0
<a> this . expires = expires ; </a> 0
<a> this . permissions = permissions ; </a> 0
<a> this . token = token ; </a> 0
<a> this . source = source ; </a> 0
<a> this . lastRefresh = lastRefresh ; </a> 0
<a> } </a> 0
<a> private Object readResolve ( ) { </a> 0
<a> return new AccessToken ( token , expires , permissions , source , lastRefresh ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private Object writeReplace ( ) { </a> 0
<a> return new SerializationProxyV1 ( token , expires , permissions , source , lastRefresh ) ; </a> 0
<a> } </a> 0
<a> private void readObject ( ObjectInputStream stream ) throws InvalidObjectException { </a> 0
<a> throw new InvalidObjectException ( "Cannot readObject, serialization proxy required" ) ; </a> 0
<a> } </a> 0
<a> private static Date getBundleLongAsDate ( Bundle bundle , String key , Date dateBase ) { </a> 0
<a> if ( bundle == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> long secondsFromBase = Long . MIN_VALUE ; </a> 0
<a> Object secondsObject = bundle . get ( key ) ; </a> 0
<a> if ( secondsObject instanceof Long ) { </a> 0
<a> secondsFromBase = ( Long ) secondsObject ; </a> 0
<a> } else if ( secondsObject instanceof String ) { </a> 0
<a> try { </a> 0
<a> secondsFromBase = Long . parseLong ( ( String ) secondsObject ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( secondsFromBase == 0 ) { </a> 0
<a> return new Date ( Long . MAX_VALUE ) ; </a> 0
<a> } else { </a> 0
<a> return new Date ( dateBase . getTime ( ) + ( secondsFromBase * 1000L ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> public enum AccessTokenSource { </a> 0
<a> NONE ( false ) , </a> 0
<a> FACEBOOK_APPLICATION_WEB ( true ) , </a> 0
<a> FACEBOOK_APPLICATION_NATIVE ( true ) , </a> 0
<a> FACEBOOK_APPLICATION_SERVICE ( true ) , </a> 0
<a> WEB_VIEW ( false ) , </a> 0
<a> TEST_USER ( true ) ; </a> 0
<a> private final boolean canExtendToken ; </a> 0
<a> AccessTokenSource ( boolean canExtendToken ) { </a> 0
<a> this . canExtendToken = canExtendToken ; </a> 0
<a> } </a> 0
<a> boolean canExtendToken ( ) { </a> 0
<a> return canExtendToken ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . Manifest ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . ActivityNotFoundException ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . content . pm . PackageManager ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import android . webkit . CookieSyncManager ; </a> 0
<a> import com . facebook . android . R ; </a> 0
<a> import com . facebook . internal . ServerProtocol ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import com . facebook . model . GraphMultiResult ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import com . facebook . model . GraphObjectList ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import com . facebook . widget . WebDialog ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> class AuthorizationClient implements Serializable { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> List < AuthHandler > handlersToTry ; </a> 0
<a> AuthHandler currentHandler ; </a> 0
<a> transient Context context ; </a> 0
<a> transient StartActivityDelegate startActivityDelegate ; </a> 0
<a> transient OnCompletedListener onCompletedListener ; </a> 0
<a> transient BackgroundProcessingListener backgroundProcessingListener ; </a> 0
<a> transient boolean checkedInternetPermission ; </a> 0
<a> AuthorizationRequest pendingRequest ; </a> 0
<a> interface OnCompletedListener { </a> 0
<a> void onCompleted ( Result result ) ; </a> 0
<a> } </a> 0
<a> interface BackgroundProcessingListener { </a> 0
<a> void onBackgroundProcessingStarted ( ) ; </a> 0
<a> void onBackgroundProcessingStopped ( ) ; </a> 0
<a> } </a> 0
<a> interface StartActivityDelegate { </a> 0
<a> public void startActivityForResult ( Intent intent , int requestCode ) ; </a> 0
<a> public Activity getActivityContext ( ) ; </a> 0
<a> } </a> 0
<a> void setContext ( final Context context ) { </a> 0
<a> this . context = context ; </a> 0
<a> startActivityDelegate = null ; </a> 0
<a> } </a> 0
<a> void setContext ( final Activity activity ) { </a> 0
<a> this . context = activity ; </a> 0
<a> startActivityDelegate = new StartActivityDelegate ( ) { </a> 0
<a> @ Override </a> 0
<a> public void startActivityForResult ( Intent intent , int requestCode ) { </a> 0
<a> activity . startActivityForResult ( intent , requestCode ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Activity getActivityContext ( ) { </a> 0
<a> return activity ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> void startOrContinueAuth ( AuthorizationRequest request ) { </a> 0
<a> if ( getInProgress ( ) ) { </a> 0
<a> continueAuth ( ) ; </a> 0
<a> } else { </a> 0
<a> authorize ( request ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void authorize ( AuthorizationRequest request ) { </a> 0
<a> if ( request == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( pendingRequest != null ) { </a> 0
<a> throw new FacebookException ( "Attempted to authorize while a request is pending." ) ; </a> 0
<a> } </a> 0
<a> if ( request . needsNewTokenValidation ( ) && ! checkInternetPermission ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> pendingRequest = request ; </a> 0
<a> handlersToTry = getHandlerTypes ( request ) ; </a> 0
<a> tryNextHandler ( ) ; </a> 0
<a> } </a> 0
<a> void continueAuth ( ) { </a> 0
<a> if ( pendingRequest == null || currentHandler == null ) { </a> 0
<a> throw new FacebookException ( "Attempted to continue authorization without a pending request." ) ; </a> 0
<a> } </a> 0
<a> if ( currentHandler . needsRestart ( ) ) { </a> 0
<a> currentHandler . cancel ( ) ; </a> 0
<a> tryCurrentHandler ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean getInProgress ( ) { </a> 0
<a> return pendingRequest != null && currentHandler != null ; </a> 0
<a> } </a> 0
<a> void cancelCurrentHandler ( ) { </a> 0
<a> if ( currentHandler != null ) { </a> 0
<a> currentHandler . cancel ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> if ( requestCode == pendingRequest . getRequestCode ( ) ) { </a> 0
<a> return currentHandler . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private List < AuthHandler > getHandlerTypes ( AuthorizationRequest request ) { </a> 0
<a> ArrayList < AuthHandler > handlers = new ArrayList < AuthHandler > ( ) ; </a> 0
<a> final SessionLoginBehavior behavior = request . getLoginBehavior ( ) ; </a> 0
<a> if ( behavior . allowsKatanaAuth ( ) ) { </a> 0
<a> if ( ! request . isLegacy ( ) ) { </a> 0
<a> handlers . add ( new GetTokenAuthHandler ( ) ) ; </a> 0
<a> handlers . add ( new KatanaLoginDialogAuthHandler ( ) ) ; </a> 0
<a> } </a> 0
<a> handlers . add ( new KatanaProxyAuthHandler ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( behavior . allowsWebViewAuth ( ) ) { </a> 0
<a> handlers . add ( new WebViewAuthHandler ( ) ) ; </a> 0
<a> } </a> 0
<a> return handlers ; </a> 0
<a> } </a> 0
<a> boolean checkInternetPermission ( ) { </a> 0
<a> if ( checkedInternetPermission ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> int permissionCheck = checkPermission ( Manifest . permission . INTERNET ) ; </a> 0
<a> if ( permissionCheck != PackageManager . PERMISSION_GRANTED ) { </a> 0
<a> String errorType = context . getString ( R . string . com_facebook_internet_permission_error_title ) ; </a> 0
<a> String errorDescription = context . getString ( R . string . com_facebook_internet_permission_error_message ) ; </a> 0
<a> complete ( Result . createErrorResult ( errorType , errorDescription ) ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> checkedInternetPermission = true ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> void tryNextHandler ( ) { </a> 0
<a> while ( handlersToTry != null && ! handlersToTry . isEmpty ( ) ) { </a> 0
<a> currentHandler = handlersToTry . remove ( 0 ) ; </a> 0
<a> boolean started = tryCurrentHandler ( ) ; </a> 0
<a> if ( started ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( pendingRequest != null ) { </a> 0
<a> completeWithFailure ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void completeWithFailure ( ) { </a> 0
<a> complete ( Result . createErrorResult ( "Login attempt failed." , null ) ) ; </a> 0
<a> } </a> 0
<a> boolean tryCurrentHandler ( ) { </a> 0
<a> if ( currentHandler . needsInternetPermission ( ) && ! checkInternetPermission ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return currentHandler . tryAuthorize ( pendingRequest ) ; </a> 0
<a> } </a> 0
<a> void completeAndValidate ( Result outcome ) { </a> 0
<a> if ( outcome . token != null && pendingRequest . needsNewTokenValidation ( ) ) { </a> 0
<a> validateSameFbidAndFinish ( outcome ) ; </a> 0
<a> } else { </a> 0
<a> complete ( outcome ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void complete ( Result outcome ) { </a> 0
<a> handlersToTry = null ; </a> 0
<a> currentHandler = null ; </a> 0
<a> pendingRequest = null ; </a> 0
<a> notifyOnCompleteListener ( outcome ) ; </a> 0
<a> } </a> 0
<a> OnCompletedListener getOnCompletedListener ( ) { </a> 0
<a> return onCompletedListener ; </a> 0
<a> } </a> 0
<a> void setOnCompletedListener ( OnCompletedListener onCompletedListener ) { </a> 0
<a> this . onCompletedListener = onCompletedListener ; </a> 0
<a> } </a> 0
<a> BackgroundProcessingListener getBackgroundProcessingListener ( ) { </a> 0
<a> return backgroundProcessingListener ; </a> 0
<a> } </a> 0
<a> void setBackgroundProcessingListener ( BackgroundProcessingListener backgroundProcessingListener ) { </a> 0
<a> this . backgroundProcessingListener = backgroundProcessingListener ; </a> 0
<a> } </a> 0
<a> StartActivityDelegate getStartActivityDelegate ( ) { </a> 0
<a> if ( startActivityDelegate != null ) { </a> 0
<a> return startActivityDelegate ; </a> 0
<a> } else if ( pendingRequest != null ) { </a> 0
<a> return new StartActivityDelegate ( ) { </a> 0
<a> @ Override </a> 0
<a> public void startActivityForResult ( Intent intent , int requestCode ) { </a> 0
<a> pendingRequest . getStartActivityDelegate ( ) . startActivityForResult ( intent , requestCode ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Activity getActivityContext ( ) { </a> 0
<a> return pendingRequest . getStartActivityDelegate ( ) . getActivityContext ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> int checkPermission ( String permission ) { </a> 0
<a> return context . checkCallingOrSelfPermission ( permission ) ; </a> 0
<a> } </a> 0
<a> void validateSameFbidAndFinish ( Result pendingResult ) { </a> 0
<a> if ( pendingResult . token == null ) { </a> 0
<a> throw new FacebookException ( "Can't validate without a token" ) ; </a> 0
<a> } </a> 0
<a> RequestBatch batch = createReauthValidationBatch ( pendingResult ) ; </a> 0
<a> notifyBackgroundProcessingStart ( ) ; </a> 0
<a> batch . executeAsync ( ) ; </a> 0
<a> } </a> 0
<a> RequestBatch createReauthValidationBatch ( final Result pendingResult ) { </a> 0
<a> final ArrayList < String > fbids = new ArrayList < String > ( ) ; </a> 0
<a> final ArrayList < String > tokenPermissions = new ArrayList < String > ( ) ; </a> 0
<a> final String newToken = pendingResult . token . getToken ( ) ; </a> 0
<a> Request . Callback meCallback = new Request . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> try { </a> 0
<a> GraphUser user = response . getGraphObjectAs ( GraphUser . class ) ; </a> 0
<a> if ( user != null ) { </a> 0
<a> fbids . add ( user . getId ( ) ) ; </a> 0
<a> } </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> String validateSameFbidAsToken = pendingRequest . getPreviousAccessToken ( ) ; </a> 0
<a> Request requestCurrentTokenMe = createGetProfileIdRequest ( validateSameFbidAsToken ) ; </a> 0
<a> requestCurrentTokenMe . setCallback ( meCallback ) ; </a> 0
<a> Request requestNewTokenMe = createGetProfileIdRequest ( newToken ) ; </a> 0
<a> requestNewTokenMe . setCallback ( meCallback ) ; </a> 0
<a> Request requestCurrentTokenPermissions = createGetPermissionsRequest ( validateSameFbidAsToken ) ; </a> 0
<a> requestCurrentTokenPermissions . setCallback ( new Request . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> try { </a> 0
<a> GraphMultiResult result = response . getGraphObjectAs ( GraphMultiResult . class ) ; </a> 0
<a> if ( result != null ) { </a> 0
<a> GraphObjectList < GraphObject > data = result . getData ( ) ; </a> 0
<a> if ( data != null && data . size ( ) == 1 ) { </a> 0
<a> GraphObject permissions = data . get ( 0 ) ; </a> 0
<a> tokenPermissions . addAll ( permissions . asMap ( ) . keySet ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> RequestBatch batch = new RequestBatch ( requestCurrentTokenMe , requestNewTokenMe , </a> 0
<a> requestCurrentTokenPermissions ) ; </a> 0
<a> batch . setBatchApplicationId ( pendingRequest . getApplicationId ( ) ) ; </a> 0
<a> batch . addCallback ( new RequestBatch . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onBatchCompleted ( RequestBatch batch ) { </a> 0
<a> try { </a> 0
<a> Result result = null ; </a> 0
<a> if ( fbids . size ( ) == 2 && fbids . get ( 0 ) != null && fbids . get ( 1 ) != null && </a> 0
<a> fbids . get ( 0 ) . equals ( fbids . get ( 1 ) ) ) { </a> 0
<a> AccessToken tokenWithPermissions = AccessToken </a> 0
<a> . createFromTokenWithRefreshedPermissions ( pendingResult . token , </a> 0
<a> tokenPermissions ) ; </a> 0
<a> result = Result . createTokenResult ( tokenWithPermissions ) ; </a> 0
<a> } else { </a> 0
<a> result = Result </a> 0
<a> . createErrorResult ( "User logged in as different Facebook user." , null ) ; </a> 0
<a> } </a> 0
<a> complete ( result ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> complete ( Result . createErrorResult ( "Caught exception" , ex . getMessage ( ) ) ) ; </a> 0
<a> } finally { </a> 0
<a> notifyBackgroundProcessingStop ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> return batch ; </a> 0
<a> } </a> 0
<a> Request createGetPermissionsRequest ( String accessToken ) { </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> parameters . putString ( "fields" , "id" ) ; </a> 0
<a> parameters . putString ( "access_token" , accessToken ) ; </a> 0
<a> return new Request ( null , "me/permissions" , parameters , HttpMethod . GET , null ) ; </a> 0
<a> } </a> 0
<a> Request createGetProfileIdRequest ( String accessToken ) { </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> parameters . putString ( "fields" , "id" ) ; </a> 0
<a> parameters . putString ( "access_token" , accessToken ) ; </a> 0
<a> return new Request ( null , "me" , parameters , HttpMethod . GET , null ) ; </a> 0
<a> } </a> 0
<a> private void notifyOnCompleteListener ( Result outcome ) { </a> 0
<a> if ( onCompletedListener != null ) { </a> 0
<a> onCompletedListener . onCompleted ( outcome ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void notifyBackgroundProcessingStart ( ) { </a> 0
<a> if ( backgroundProcessingListener != null ) { </a> 0
<a> backgroundProcessingListener . onBackgroundProcessingStarted ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void notifyBackgroundProcessingStop ( ) { </a> 0
<a> if ( backgroundProcessingListener != null ) { </a> 0
<a> backgroundProcessingListener . onBackgroundProcessingStopped ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> abstract class AuthHandler implements Serializable { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> abstract boolean tryAuthorize ( AuthorizationRequest request ) ; </a> 0
<a> boolean onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> boolean needsRestart ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> boolean needsInternetPermission ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> void cancel ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> class WebViewAuthHandler extends AuthHandler { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> private transient WebDialog loginDialog ; </a> 0
<a> @ Override </a> 0
<a> boolean needsRestart ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> boolean needsInternetPermission ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void cancel ( ) { </a> 0
<a> if ( loginDialog != null ) { </a> 0
<a> loginDialog . dismiss ( ) ; </a> 0
<a> loginDialog = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> boolean tryAuthorize ( final AuthorizationRequest request ) { </a> 0
<a> String applicationId = request . getApplicationId ( ) ; </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> if ( ! Utility . isNullOrEmpty ( request . getPermissions ( ) ) ) { </a> 0
<a> parameters . putString ( ServerProtocol . DIALOG_PARAM_SCOPE , TextUtils . join ( "," , request . getPermissions ( ) ) ) ; </a> 0
<a> } </a> 0
<a> Utility . clearFacebookCookies ( context ) ; </a> 0
<a> WebDialog . OnCompleteListener listener = new WebDialog . OnCompleteListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( Bundle values , FacebookException error ) { </a> 0
<a> onWebDialogComplete ( request , values , error ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> WebDialog . Builder builder = </a> 0
<a> new AuthDialogBuilder ( getStartActivityDelegate ( ) . getActivityContext ( ) , applicationId , parameters ) </a> 0
<a> . setOnCompleteListener ( listener ) ; </a> 0
<a> loginDialog = builder . build ( ) ; </a> 0
<a> loginDialog . show ( ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> void onWebDialogComplete ( AuthorizationRequest request , Bundle values , </a> 0
<a> FacebookException error ) { </a> 0
<a> Result outcome ; </a> 0
<a> if ( values != null ) { </a> 0
<a> CookieSyncManager syncManager = CookieSyncManager . createInstance ( context ) ; </a> 0
<a> syncManager . sync ( ) ; </a> 0
<a> AccessToken token = AccessToken </a> 1
<a> . createFromWebBundle ( request . getPermissions ( ) , values , AccessTokenSource . WEB_VIEW ) ; </a> 1
<a> outcome = Result . createTokenResult ( token ) ; </a> 1
<a> } else { </a> 0
<a> if ( error instanceof FacebookOperationCanceledException ) { </a> 0
<a> outcome = Result . createCancelResult ( "User canceled log in." ) ; </a> 0
<a> } else { </a> 0
<a> outcome = Result . createErrorResult ( error . getMessage ( ) , null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> completeAndValidate ( outcome ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> class GetTokenAuthHandler extends AuthHandler { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> private transient GetTokenClient getTokenClient ; </a> 0
<a> @ Override </a> 0
<a> void cancel ( ) { </a> 0
<a> if ( getTokenClient != null ) { </a> 0
<a> getTokenClient . cancel ( ) ; </a> 0
<a> getTokenClient = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean tryAuthorize ( final AuthorizationRequest request ) { </a> 0
<a> getTokenClient = new GetTokenClient ( context , request . getApplicationId ( ) ) ; </a> 0
<a> if ( ! getTokenClient . start ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> notifyBackgroundProcessingStart ( ) ; </a> 0
<a> GetTokenClient . CompletedListener callback = new GetTokenClient . CompletedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void completed ( Bundle result ) { </a> 0
<a> getTokenCompleted ( request , result ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> getTokenClient . setCompletedListener ( callback ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> void getTokenCompleted ( AuthorizationRequest request , Bundle result ) { </a> 0
<a> getTokenClient = null ; </a> 0
<a> notifyBackgroundProcessingStop ( ) ; </a> 0
<a> if ( result != null ) { </a> 0
<a> ArrayList < String > currentPermissions = result . getStringArrayList ( NativeProtocol . EXTRA_PERMISSIONS ) ; </a> 0
<a> List < String > permissions = request . getPermissions ( ) ; </a> 0
<a> if ( ( currentPermissions != null ) && </a> 0
<a> ( ( permissions == null ) || currentPermissions . containsAll ( permissions ) ) ) { </a> 0
<a> AccessToken token = AccessToken </a> 0
<a> . createFromNativeLogin ( result , AccessTokenSource . FACEBOOK_APPLICATION_SERVICE ) ; </a> 0
<a> Result outcome = Result . createTokenResult ( token ) ; </a> 0
<a> completeAndValidate ( outcome ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> ArrayList < String > newPermissions = new ArrayList < String > ( ) ; </a> 0
<a> for ( String permission : permissions ) { </a> 0
<a> if ( ! currentPermissions . contains ( permission ) ) { </a> 0
<a> newPermissions . add ( permission ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> request . setPermissions ( newPermissions ) ; </a> 0
<a> } </a> 0
<a> tryNextHandler ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> abstract class KatanaAuthHandler extends AuthHandler { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> protected boolean tryIntent ( Intent intent , int requestCode ) { </a> 0
<a> if ( intent == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> getStartActivityDelegate ( ) . startActivityForResult ( intent , requestCode ) ; </a> 0
<a> } catch ( ActivityNotFoundException e ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> class KatanaLoginDialogAuthHandler extends KatanaAuthHandler { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> @ Override </a> 0
<a> boolean tryAuthorize ( AuthorizationRequest request ) { </a> 0
<a> Intent intent = NativeProtocol . createLoginDialog20121101Intent ( context , request . getApplicationId ( ) , </a> 0
<a> new ArrayList < String > ( request . getPermissions ( ) ) , </a> 0
<a> request . getDefaultAudience ( ) . getNativeProtocolAudience ( ) ) ; </a> 0
<a> return tryIntent ( intent , request . getRequestCode ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> boolean onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> if ( NativeProtocol . isServiceDisabledResult20121101 ( data ) ) { </a> 1
<a> tryNextHandler ( ) ; </a> 1
<a> } else { </a> 1
<a> Result outcome = null ; </a> 1
<a> if ( resultCode == Activity . RESULT_CANCELED ) { </a> 1
<a> outcome = Result . createCancelResult ( </a> 0
<a> data . getStringExtra ( NativeProtocol . STATUS_ERROR_DESCRIPTION ) ) ; </a> 0
<a> } else if ( resultCode != Activity . RESULT_OK ) { </a> 0
<a> outcome = Result </a> 1
<a> . createErrorResult ( "Unexpected resultCode from authorization." , null ) ; </a> 1
<a> } else { </a> 0
<a> outcome = handleResultOk ( data ) ; </a> 0
<a> } </a> 0
<a> if ( outcome != null ) { </a> 0
<a> completeAndValidate ( outcome ) ; </a> 0
<a> } else { </a> 0
<a> tryNextHandler ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> return true ; </a> 0
<a> } </a> 0
<a> private Result handleResultOk ( Intent data ) { </a> 0
<a> Bundle extras = data . getExtras ( ) ; </a> 0
<a> String errorType = extras . getString ( NativeProtocol . STATUS_ERROR_TYPE ) ; </a> 0
<a> if ( errorType == null ) { </a> 0
<a> return Result . createTokenResult ( </a> 0
<a> AccessToken . createFromNativeLogin ( extras , AccessTokenSource . FACEBOOK_APPLICATION_NATIVE ) ) ; </a> 0
<a> } else if ( NativeProtocol . ERROR_SERVICE_DISABLED . equals ( errorType ) ) { </a> 0
<a> return null ; </a> 0
<a> } else if ( NativeProtocol . ERROR_USER_CANCELED . equals ( errorType ) ) { </a> 0
<a> return Result . createCancelResult ( null ) ; </a> 0
<a> } else { </a> 0
<a> return Result . createErrorResult ( errorType , extras . getString ( "error_description" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> class KatanaProxyAuthHandler extends KatanaAuthHandler { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> @ Override </a> 0
<a> boolean tryAuthorize ( AuthorizationRequest request ) { </a> 0
<a> Intent intent = NativeProtocol . createProxyAuthIntent ( context , </a> 0
<a> request . getApplicationId ( ) , request . getPermissions ( ) ) ; </a> 0
<a> return tryIntent ( intent , request . getRequestCode ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> boolean onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> Result outcome = null ; </a> 1
<a> if ( resultCode == Activity . RESULT_CANCELED ) { </a> 1
<a> outcome = Result . createCancelResult ( data . getStringExtra ( "error" ) ) ; </a> 0
<a> } else if ( resultCode != Activity . RESULT_OK ) { </a> 0
<a> outcome = Result . createErrorResult ( "Unexpected resultCode from authorization." , null ) ; </a> 0
<a> } else { </a> 0
<a> outcome = handleResultOk ( data ) ; </a> 0
<a> } </a> 0
<a> if ( outcome != null ) { </a> 0
<a> completeAndValidate ( outcome ) ; </a> 0
<a> } else { </a> 0
<a> tryNextHandler ( ) ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> private Result handleResultOk ( Intent data ) { </a> 0
<a> Bundle extras = data . getExtras ( ) ; </a> 0
<a> String error = extras . getString ( "error" ) ; </a> 0
<a> if ( error == null ) { </a> 0
<a> error = extras . getString ( "error_type" ) ; </a> 0
<a> } </a> 0
<a> if ( error == null ) { </a> 0
<a> AccessToken token = AccessToken . createFromWebBundle ( pendingRequest . getPermissions ( ) , extras , </a> 0
<a> AccessTokenSource . FACEBOOK_APPLICATION_WEB ) ; </a> 0
<a> return Result . createTokenResult ( token ) ; </a> 0
<a> } else if ( ServerProtocol . errorsProxyAuthDisabled . contains ( error ) ) { </a> 0
<a> return null ; </a> 0
<a> } else if ( ServerProtocol . errorsUserCanceled . contains ( error ) ) { </a> 0
<a> return Result . createCancelResult ( null ) ; </a> 0
<a> } else { </a> 0
<a> return Result . createErrorResult ( error , extras . getString ( "error_description" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static class AuthDialogBuilder extends WebDialog . Builder { </a> 0
<a> private static final String OAUTH_DIALOG = "oauth" ; </a> 0
<a> static final String REDIRECT_URI = "fbconnect://success" ; </a> 0
<a> public AuthDialogBuilder ( Context context , String applicationId , Bundle parameters ) { </a> 0
<a> super ( context , applicationId , OAUTH_DIALOG , parameters ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public WebDialog build ( ) { </a> 0
<a> Bundle parameters = getParameters ( ) ; </a> 0
<a> parameters . putString ( ServerProtocol . DIALOG_PARAM_REDIRECT_URI , REDIRECT_URI ) ; </a> 0
<a> parameters . putString ( ServerProtocol . DIALOG_PARAM_CLIENT_ID , getApplicationId ( ) ) ; </a> 0
<a> return new WebDialog ( getContext ( ) , OAUTH_DIALOG , parameters , getTheme ( ) , getListener ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static class AuthorizationRequest implements Serializable { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> private transient final StartActivityDelegate startActivityDelegate ; </a> 0
<a> private SessionLoginBehavior loginBehavior ; </a> 0
<a> private int requestCode ; </a> 0
<a> private boolean isLegacy = false ; </a> 0
<a> private List < String > permissions ; </a> 0
<a> private SessionDefaultAudience defaultAudience ; </a> 0
<a> private String applicationId ; </a> 0
<a> private String previousAccessToken ; </a> 0
<a> AuthorizationRequest ( SessionLoginBehavior loginBehavior , int requestCode , boolean isLegacy , </a> 0
<a> List < String > permissions , SessionDefaultAudience defaultAudience , String applicationId , </a> 0
<a> String validateSameFbidAsToken , StartActivityDelegate startActivityDelegate ) { </a> 0
<a> this . loginBehavior = loginBehavior ; </a> 0
<a> this . requestCode = requestCode ; </a> 0
<a> this . isLegacy = isLegacy ; </a> 0
<a> this . permissions = permissions ; </a> 0
<a> this . defaultAudience = defaultAudience ; </a> 0
<a> this . applicationId = applicationId ; </a> 0
<a> this . previousAccessToken = validateSameFbidAsToken ; </a> 0
<a> this . startActivityDelegate = startActivityDelegate ; </a> 0
<a> } </a> 0
<a> StartActivityDelegate getStartActivityDelegate ( ) { </a> 0
<a> return startActivityDelegate ; </a> 0
<a> } </a> 0
<a> List < String > getPermissions ( ) { </a> 0
<a> return permissions ; </a> 0
<a> } </a> 0
<a> void setPermissions ( List < String > permissions ) { </a> 0
<a> this . permissions = permissions ; </a> 0
<a> } </a> 0
<a> SessionLoginBehavior getLoginBehavior ( ) { </a> 0
<a> return loginBehavior ; </a> 0
<a> } </a> 0
<a> int getRequestCode ( ) { </a> 0
<a> return requestCode ; </a> 0
<a> } </a> 0
<a> SessionDefaultAudience getDefaultAudience ( ) { </a> 0
<a> return defaultAudience ; </a> 0
<a> } </a> 0
<a> String getApplicationId ( ) { </a> 0
<a> return applicationId ; </a> 0
<a> } </a> 0
<a> boolean isLegacy ( ) { </a> 0
<a> return isLegacy ; </a> 0
<a> } </a> 0
<a> void setIsLegacy ( boolean isLegacy ) { </a> 0
<a> this . isLegacy = isLegacy ; </a> 0
<a> } </a> 0
<a> String getPreviousAccessToken ( ) { </a> 0
<a> return previousAccessToken ; </a> 0
<a> } </a> 0
<a> boolean needsNewTokenValidation ( ) { </a> 0
<a> return previousAccessToken != null && ! isLegacy ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static class Result implements Serializable { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> enum Code { </a> 0
<a> SUCCESS , </a> 0
<a> CANCEL , </a> 0
<a> ERROR </a> 0
<a> } </a> 0
<a> final Code code ; </a> 0
<a> final AccessToken token ; </a> 0
<a> final String errorMessage ; </a> 0
<a> private Result ( Code code , AccessToken token , String errorMessage ) { </a> 0
<a> this . token = token ; </a> 0
<a> this . errorMessage = errorMessage ; </a> 0
<a> this . code = code ; </a> 0
<a> } </a> 0
<a> static Result createTokenResult ( AccessToken token ) { </a> 0
<a> return new Result ( Code . SUCCESS , token , null ) ; </a> 0
<a> } </a> 0
<a> static Result createCancelResult ( String message ) { </a> 0
<a> return new Result ( Code . CANCEL , null , message ) ; </a> 0
<a> } </a> 0
<a> static Result createErrorResult ( String errorType , String errorDescription ) { </a> 0
<a> String message = errorType ; </a> 0
<a> if ( errorDescription != null ) { </a> 0
<a> message += ": " + errorDescription ; </a> 0
<a> } </a> 0
<a> return new Result ( Code . ERROR , null , message ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> public class FacebookDialogException extends FacebookException { </a> 0
<a> static final long serialVersionUID = 1 ; </a> 0
<a> private int errorCode ; </a> 0
<a> private String failingUrl ; </a> 0
<a> public FacebookDialogException ( String message , int errorCode , String failingUrl ) { </a> 0
<a> super ( message ) ; </a> 0
<a> this . errorCode = errorCode ; </a> 0
<a> this . failingUrl = failingUrl ; </a> 0
<a> } </a> 0
<a> public int getErrorCode ( ) { </a> 0
<a> return errorCode ; </a> 0
<a> } </a> 0
<a> public String getFailingUrl ( ) { </a> 0
<a> return failingUrl ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> public class FacebookException extends RuntimeException { </a> 0
<a> static final long serialVersionUID = 1 ; </a> 0
<a> public FacebookException ( ) { </a> 0
<a> super ( ) ; </a> 0
<a> } </a> 0
<a> public FacebookException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public FacebookException ( String message , Throwable throwable ) { </a> 0
<a> super ( message , throwable ) ; </a> 0
<a> } </a> 0
<a> public FacebookException ( Throwable throwable ) { </a> 0
<a> super ( throwable ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> public class FacebookGraphObjectException extends FacebookException { </a> 0
<a> static final long serialVersionUID = 1 ; </a> 0
<a> public FacebookGraphObjectException ( ) { </a> 0
<a> super ( ) ; </a> 0
<a> } </a> 0
<a> public FacebookGraphObjectException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public FacebookGraphObjectException ( String message , Throwable throwable ) { </a> 0
<a> super ( message , throwable ) ; </a> 0
<a> } </a> 0
<a> public FacebookGraphObjectException ( Throwable throwable ) { </a> 0
<a> super ( throwable ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> public class FacebookOperationCanceledException extends FacebookException { </a> 0
<a> static final long serialVersionUID = 1 ; </a> 0
<a> public FacebookOperationCanceledException ( ) { </a> 0
<a> super ( ) ; </a> 0
<a> } </a> 0
<a> public FacebookOperationCanceledException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public FacebookOperationCanceledException ( String message , Throwable throwable ) { </a> 0
<a> super ( message , throwable ) ; </a> 0
<a> } </a> 0
<a> public FacebookOperationCanceledException ( Throwable throwable ) { </a> 0
<a> super ( throwable ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import com . facebook . android . R ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . net . HttpURLConnection ; </a> 0
<a> public final class FacebookRequestError { </a> 0
<a> public static final int INVALID_ERROR_CODE = - 1 ; </a> 0
<a> public static final int INVALID_HTTP_STATUS_CODE = - 1 ; </a> 0
<a> private static final int INVALID_MESSAGE_ID = 0 ; </a> 0
<a> private static final String CODE_KEY = "code" ; </a> 0
<a> private static final String BODY_KEY = "body" ; </a> 0
<a> private static final String ERROR_KEY = "error" ; </a> 0
<a> private static final String ERROR_TYPE_FIELD_KEY = "type" ; </a> 0
<a> private static final String ERROR_CODE_FIELD_KEY = "code" ; </a> 0
<a> private static final String ERROR_MESSAGE_FIELD_KEY = "message" ; </a> 0
<a> private static final String ERROR_CODE_KEY = "error_code" ; </a> 0
<a> private static final String ERROR_SUB_CODE_KEY = "error_subcode" ; </a> 0
<a> private static final String ERROR_MSG_KEY = "error_msg" ; </a> 0
<a> private static final String ERROR_REASON_KEY = "error_reason" ; </a> 0
<a> private static class Range { </a> 0
<a> private final int start , end ; </a> 0
<a> private Range ( int start , int end ) { </a> 0
<a> this . start = start ; </a> 0
<a> this . end = end ; </a> 0
<a> } </a> 0
<a> boolean contains ( int value ) { </a> 0
<a> return start <= value && value <= end ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static final int EC_UNKNOWN_ERROR = 1 ; </a> 0
<a> private static final int EC_SERVICE_UNAVAILABLE = 2 ; </a> 0
<a> private static final int EC_APP_TOO_MANY_CALLS = 4 ; </a> 0
<a> private static final int EC_USER_TOO_MANY_CALLS = 17 ; </a> 0
<a> private static final int EC_PERMISSION_DENIED = 10 ; </a> 0
<a> private static final int EC_INVALID_SESSION = 102 ; </a> 0
<a> private static final int EC_INVALID_TOKEN = 190 ; </a> 0
<a> private static final Range EC_RANGE_PERMISSION = new Range ( 200 , 299 ) ; </a> 0
<a> private static final int EC_APP_NOT_INSTALLED = 458 ; </a> 0
<a> private static final int EC_USER_CHECKPOINTED = 459 ; </a> 0
<a> private static final int EC_PASSWORD_CHANGED = 460 ; </a> 0
<a> private static final int EC_UNCONFIRMED_USER = 464 ; </a> 0
<a> private static final Range HTTP_RANGE_SUCCESS = new Range ( 200 , 299 ) ; </a> 0
<a> private static final Range HTTP_RANGE_CLIENT_ERROR = new Range ( 400 , 499 ) ; </a> 0
<a> private static final Range HTTP_RANGE_SERVER_ERROR = new Range ( 500 , 599 ) ; </a> 0
<a> private final int userActionMessageId ; </a> 0
<a> private final boolean shouldNotifyUser ; </a> 0
<a> private final Category category ; </a> 0
<a> private final int requestStatusCode ; </a> 0
<a> private final int errorCode ; </a> 0
<a> private final int subErrorCode ; </a> 0
<a> private final String errorType ; </a> 0
<a> private final String errorMessage ; </a> 0
<a> private final JSONObject requestResult ; </a> 0
<a> private final JSONObject requestResultBody ; </a> 0
<a> private final Object batchRequestResult ; </a> 0
<a> private final HttpURLConnection connection ; </a> 0
<a> private final FacebookException exception ; </a> 0
<a> private FacebookRequestError ( int requestStatusCode , int errorCode , </a> 0
<a> int subErrorCode , String errorType , String errorMessage , JSONObject requestResultBody , </a> 0
<a> JSONObject requestResult , Object batchRequestResult , HttpURLConnection connection , </a> 0
<a> FacebookException exception ) { </a> 0
<a> this . requestStatusCode = requestStatusCode ; </a> 0
<a> this . errorCode = errorCode ; </a> 0
<a> this . subErrorCode = subErrorCode ; </a> 0
<a> this . errorType = errorType ; </a> 0
<a> this . errorMessage = errorMessage ; </a> 0
<a> this . requestResultBody = requestResultBody ; </a> 0
<a> this . requestResult = requestResult ; </a> 0
<a> this . batchRequestResult = batchRequestResult ; </a> 0
<a> this . connection = connection ; </a> 0
<a> boolean isLocalException = false ; </a> 0
<a> if ( exception != null ) { </a> 0
<a> this . exception = exception ; </a> 0
<a> isLocalException = true ; </a> 0
<a> } else { </a> 0
<a> this . exception = new FacebookServiceException ( this , errorMessage ) ; </a> 0
<a> } </a> 0
<a> Category errorCategory = null ; </a> 0
<a> int messageId = INVALID_MESSAGE_ID ; </a> 0
<a> boolean shouldNotify = false ; </a> 0
<a> if ( isLocalException ) { </a> 0
<a> errorCategory = Category . CLIENT ; </a> 0
<a> messageId = INVALID_MESSAGE_ID ; </a> 0
<a> } else { </a> 0
<a> if ( errorCode == EC_UNKNOWN_ERROR || errorCode == EC_SERVICE_UNAVAILABLE ) { </a> 0
<a> errorCategory = Category . SERVER ; </a> 0
<a> } else if ( errorCode == EC_APP_TOO_MANY_CALLS || errorCode == EC_USER_TOO_MANY_CALLS ) { </a> 0
<a> errorCategory = Category . THROTTLING ; </a> 0
<a> } else if ( errorCode == EC_PERMISSION_DENIED || EC_RANGE_PERMISSION . contains ( errorCode ) ) { </a> 0
<a> errorCategory = Category . PERMISSION ; </a> 0
<a> messageId = R . string . com_facebook_requesterror_permissions ; </a> 0
<a> } else if ( errorCode == EC_INVALID_SESSION || errorCode == EC_INVALID_TOKEN ) { </a> 0
<a> if ( subErrorCode == EC_USER_CHECKPOINTED || subErrorCode == EC_UNCONFIRMED_USER ) { </a> 0
<a> errorCategory = Category . AUTHENTICATION_RETRY ; </a> 0
<a> messageId = R . string . com_facebook_requesterror_web_login ; </a> 0
<a> shouldNotify = true ; </a> 0
<a> } else { </a> 0
<a> errorCategory = Category . AUTHENTICATION_REOPEN_SESSION ; </a> 0
<a> if ( subErrorCode == EC_APP_NOT_INSTALLED ) { </a> 1
<a> messageId = R . string . com_facebook_requesterror_relogin ; </a> 0
<a> } else if ( subErrorCode == EC_PASSWORD_CHANGED ) { </a> 0
<a> messageId = R . string . com_facebook_requesterror_password_changed ; </a> 0
<a> } else { </a> 0
<a> messageId = R . string . com_facebook_requesterror_reconnect ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( errorCategory == null ) { </a> 0
<a> if ( HTTP_RANGE_CLIENT_ERROR . contains ( requestStatusCode ) ) { </a> 0
<a> errorCategory = Category . BAD_REQUEST ; </a> 0
<a> } else if ( HTTP_RANGE_SERVER_ERROR . contains ( requestStatusCode ) ) { </a> 0
<a> errorCategory = Category . SERVER ; </a> 0
<a> } else { </a> 0
<a> errorCategory = Category . OTHER ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> this . category = errorCategory ; </a> 0
<a> this . userActionMessageId = messageId ; </a> 0
<a> this . shouldNotifyUser = shouldNotify ; </a> 0
<a> } </a> 0
<a> private FacebookRequestError ( int requestStatusCode , int errorCode , </a> 0
<a> int subErrorCode , String errorType , String errorMessage , JSONObject requestResultBody , </a> 0
<a> JSONObject requestResult , Object batchRequestResult , HttpURLConnection connection ) { </a> 0
<a> this ( requestStatusCode , errorCode , subErrorCode , errorType , errorMessage , </a> 0
<a> requestResultBody , requestResult , batchRequestResult , connection , null ) ; </a> 0
<a> } </a> 0
<a> FacebookRequestError ( HttpURLConnection connection , Exception exception ) { </a> 0
<a> this ( INVALID_HTTP_STATUS_CODE , INVALID_ERROR_CODE , INVALID_ERROR_CODE , </a> 0
<a> null , null , null , null , null , connection , </a> 0
<a> ( exception instanceof FacebookException ) ? </a> 0
<a> ( FacebookException ) exception : new FacebookException ( exception ) ) ; </a> 0
<a> } </a> 0
<a> public FacebookRequestError ( int errorCode , String errorType , String errorMessage ) { </a> 0
<a> this ( INVALID_HTTP_STATUS_CODE , errorCode , INVALID_ERROR_CODE , errorType , errorMessage , </a> 0
<a> null , null , null , null , null ) ; </a> 0
<a> } </a> 0
<a> public int getUserActionMessageId ( ) { </a> 0
<a> return userActionMessageId ; </a> 0
<a> } </a> 0
<a> public boolean shouldNotifyUser ( ) { </a> 0
<a> return shouldNotifyUser ; </a> 0
<a> } </a> 0
<a> public Category getCategory ( ) { </a> 0
<a> return category ; </a> 0
<a> } </a> 0
<a> public int getRequestStatusCode ( ) { </a> 0
<a> return requestStatusCode ; </a> 0
<a> } </a> 0
<a> public int getErrorCode ( ) { </a> 0
<a> return errorCode ; </a> 0
<a> } </a> 0
<a> public int getSubErrorCode ( ) { </a> 0
<a> return subErrorCode ; </a> 0
<a> } </a> 0
<a> public String getErrorType ( ) { </a> 0
<a> return errorType ; </a> 0
<a> } </a> 0
<a> public String getErrorMessage ( ) { </a> 0
<a> if ( errorMessage != null ) { </a> 0
<a> return errorMessage ; </a> 0
<a> } else { </a> 0
<a> return exception . getLocalizedMessage ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public JSONObject getRequestResultBody ( ) { </a> 0
<a> return requestResultBody ; </a> 0
<a> } </a> 0
<a> public JSONObject getRequestResult ( ) { </a> 0
<a> return requestResult ; </a> 0
<a> } </a> 0
<a> public Object getBatchRequestResult ( ) { </a> 0
<a> return batchRequestResult ; </a> 0
<a> } </a> 0
<a> public HttpURLConnection getConnection ( ) { </a> 0
<a> return connection ; </a> 0
<a> } </a> 0
<a> public FacebookException getException ( ) { </a> 0
<a> return exception ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return new StringBuilder ( "{HttpStatus: " ) </a> 0
<a> . append ( requestStatusCode ) </a> 0
<a> . append ( ", errorCode: " ) </a> 0
<a> . append ( errorCode ) </a> 0
<a> . append ( ", errorType: " ) </a> 0
<a> . append ( errorType ) </a> 0
<a> . append ( ", errorMessage: " ) </a> 0
<a> . append ( errorMessage ) </a> 0
<a> . append ( "}" ) </a> 0
<a> . toString ( ) ; </a> 0
<a> } </a> 0
<a> static FacebookRequestError checkResponseAndCreateError ( JSONObject singleResult , </a> 0
<a> Object batchResult , HttpURLConnection connection ) { </a> 0
<a> try { </a> 0
<a> if ( singleResult . has ( CODE_KEY ) ) { </a> 0
<a> int responseCode = singleResult . getInt ( CODE_KEY ) ; </a> 0
<a> Object body = Utility . getStringPropertyAsJSON ( singleResult , BODY_KEY , </a> 0
<a> Response . NON_JSON_RESPONSE_PROPERTY ) ; </a> 0
<a> if ( body != null && body instanceof JSONObject ) { </a> 0
<a> JSONObject jsonBody = ( JSONObject ) body ; </a> 0
<a> String errorType = null ; </a> 0
<a> String errorMessage = null ; </a> 0
<a> int errorCode = INVALID_ERROR_CODE ; </a> 0
<a> int errorSubCode = INVALID_ERROR_CODE ; </a> 0
<a> boolean hasError = false ; </a> 0
<a> if ( jsonBody . has ( ERROR_KEY ) ) { </a> 0
<a> JSONObject error = ( JSONObject ) Utility . getStringPropertyAsJSON ( jsonBody , ERROR_KEY , null ) ; </a> 0
<a> errorType = error . optString ( ERROR_TYPE_FIELD_KEY , null ) ; </a> 0
<a> errorMessage = error . optString ( ERROR_MESSAGE_FIELD_KEY , null ) ; </a> 0
<a> errorCode = error . optInt ( ERROR_CODE_FIELD_KEY , INVALID_ERROR_CODE ) ; </a> 0
<a> errorSubCode = error . optInt ( ERROR_SUB_CODE_KEY , INVALID_ERROR_CODE ) ; </a> 0
<a> hasError = true ; </a> 0
<a> } else if ( jsonBody . has ( ERROR_CODE_KEY ) || jsonBody . has ( ERROR_MSG_KEY ) </a> 0
<a> || jsonBody . has ( ERROR_REASON_KEY ) ) { </a> 0
<a> errorType = jsonBody . optString ( ERROR_REASON_KEY , null ) ; </a> 0
<a> errorMessage = jsonBody . optString ( ERROR_MSG_KEY , null ) ; </a> 0
<a> errorCode = jsonBody . optInt ( ERROR_CODE_KEY , INVALID_ERROR_CODE ) ; </a> 0
<a> errorSubCode = jsonBody . optInt ( ERROR_SUB_CODE_KEY , INVALID_ERROR_CODE ) ; </a> 0
<a> hasError = true ; </a> 0
<a> } </a> 0
<a> if ( hasError ) { </a> 0
<a> return new FacebookRequestError ( responseCode , errorCode , errorSubCode , </a> 0
<a> errorType , errorMessage , jsonBody , singleResult , batchResult , connection ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! HTTP_RANGE_SUCCESS . contains ( responseCode ) ) { </a> 0
<a> return new FacebookRequestError ( responseCode , INVALID_ERROR_CODE , </a> 0
<a> INVALID_ERROR_CODE , null , null , </a> 0
<a> singleResult . has ( BODY_KEY ) ? </a> 0
<a> ( JSONObject ) Utility . getStringPropertyAsJSON ( </a> 0
<a> singleResult , BODY_KEY , Response . NON_JSON_RESPONSE_PROPERTY ) : null , </a> 0
<a> singleResult , batchResult , connection ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public enum Category { </a> 0
<a> AUTHENTICATION_RETRY , </a> 0
<a> AUTHENTICATION_REOPEN_SESSION , </a> 0
<a> PERMISSION , </a> 0
<a> SERVER , </a> 0
<a> THROTTLING , </a> 0
<a> OTHER , </a> 0
<a> BAD_REQUEST , </a> 0
<a> CLIENT </a> 0
<a> } ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> final class FacebookSdkVersion { </a> 0
<a> public static final String BUILD = "3.0.0" ; </a> 0
<a> public static final String MIGRATION_BUNDLE = "fbsdk:20121026" ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . content . ComponentName ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . content . ServiceConnection ; </a> 0
<a> import android . os . * ; </a> 0
<a> final class GetTokenClient implements ServiceConnection { </a> 0
<a> final Context context ; </a> 0
<a> final String applicationId ; </a> 0
<a> final Handler handler ; </a> 0
<a> CompletedListener listener ; </a> 0
<a> boolean running ; </a> 0
<a> Messenger sender ; </a> 0
<a> GetTokenClient ( Context context , String applicationId ) { </a> 0
<a> Context applicationContext = context . getApplicationContext ( ) ; </a> 0
<a> this . context = ( applicationContext != null ) ? applicationContext : context ; </a> 0
<a> this . applicationId = applicationId ; </a> 0
<a> handler = new Handler ( ) { </a> 0
<a> @ Override </a> 0
<a> public void handleMessage ( Message message ) { </a> 0
<a> GetTokenClient . this . handleMessage ( message ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> void setCompletedListener ( CompletedListener listener ) { </a> 0
<a> this . listener = listener ; </a> 0
<a> } </a> 0
<a> boolean start ( ) { </a> 0
<a> Intent intent = new Intent ( NativeProtocol . INTENT_ACTION_PLATFORM_SERVICE ) ; </a> 0
<a> intent . addCategory ( Intent . CATEGORY_DEFAULT ) ; </a> 0
<a> intent = NativeProtocol . validateKatanaServiceIntent ( context , intent ) ; </a> 0
<a> if ( intent == null ) { </a> 0
<a> callback ( null ) ; </a> 0
<a> return false ; </a> 0
<a> } else { </a> 0
<a> running = true ; </a> 0
<a> context . bindService ( intent , this , Context . BIND_AUTO_CREATE ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void cancel ( ) { </a> 0
<a> running = false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onServiceConnected ( ComponentName name , IBinder service ) { </a> 0
<a> sender = new Messenger ( service ) ; </a> 0
<a> getToken ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onServiceDisconnected ( ComponentName name ) { </a> 0
<a> sender = null ; </a> 0
<a> context . unbindService ( this ) ; </a> 0
<a> callback ( null ) ; </a> 0
<a> } </a> 0
<a> private void getToken ( ) { </a> 0
<a> Bundle data = new Bundle ( ) ; </a> 0
<a> data . putString ( NativeProtocol . EXTRA_APPLICATION_ID , applicationId ) ; </a> 0
<a> Message request = Message . obtain ( null , NativeProtocol . MESSAGE_GET_ACCESS_TOKEN_REQUEST ) ; </a> 0
<a> request . arg1 = NativeProtocol . PROTOCOL_VERSION_20121101 ; </a> 0
<a> request . setData ( data ) ; </a> 0
<a> request . replyTo = new Messenger ( handler ) ; </a> 0
<a> try { </a> 0
<a> sender . send ( request ) ; </a> 0
<a> } catch ( RemoteException e ) { </a> 0
<a> callback ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void handleMessage ( Message message ) { </a> 0
<a> if ( message . what == NativeProtocol . MESSAGE_GET_ACCESS_TOKEN_REPLY ) { </a> 0
<a> Bundle extras = message . getData ( ) ; </a> 0
<a> String errorType = extras . getString ( NativeProtocol . STATUS_ERROR_TYPE ) ; </a> 0
<a> if ( errorType != null ) { </a> 0
<a> callback ( null ) ; </a> 0
<a> } else { </a> 0
<a> callback ( extras ) ; </a> 0
<a> } </a> 0
<a> context . unbindService ( this ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void callback ( Bundle result ) { </a> 0
<a> if ( ! running ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> running = false ; </a> 0
<a> CompletedListener callback = listener ; </a> 0
<a> if ( callback != null ) { </a> 0
<a> callback . completed ( result ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> interface CompletedListener { </a> 0
<a> void completed ( Bundle result ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> public enum HttpMethod { </a> 0
<a> GET , </a> 0
<a> POST , </a> 0
<a> DELETE , </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> public class LegacyHelper { </a> 0
<a> @ Deprecated </a> 0
<a> public static void extendTokenCompleted ( Session session , Bundle bundle ) { </a> 0
<a> session . extendTokenCompleted ( bundle ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> public enum LoggingBehavior { </a> 0
<a> REQUESTS , </a> 0
<a> INCLUDE_ACCESS_TOKENS , </a> 0
<a> INCLUDE_RAW_RESPONSES , </a> 0
<a> CACHE </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . view . View ; </a> 0
<a> import com . facebook . android . R ; </a> 0
<a> public class LoginActivity extends Activity { </a> 0
<a> static final String RESULT_KEY = "com.facebook.LoginActivity:Result" ; </a> 0
<a> private static final String NULL_CALLING_PKG_ERROR_MSG = </a> 0
<a> "Cannot call LoginActivity with a null calling package. " + </a> 0
<a> "This can occur if the launchMode of the caller is singleInstance." ; </a> 0
<a> private static final String SAVED_CALLING_PKG_KEY = "callingPackage" ; </a> 0
<a> private static final String SAVED_AUTH_CLIENT = "authorizationClient" ; </a> 0
<a> private static final String EXTRA_REQUEST = "request" ; </a> 0
<a> private String callingPackage ; </a> 0
<a> private AuthorizationClient authorizationClient ; </a> 0
<a> private AuthorizationClient . AuthorizationRequest request ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . com_facebook_login_activity_layout ) ; </a> 0
<a> if ( savedInstanceState != null ) { </a> 0
<a> callingPackage = savedInstanceState . getString ( SAVED_CALLING_PKG_KEY ) ; </a> 0
<a> authorizationClient = ( AuthorizationClient ) savedInstanceState . getSerializable ( SAVED_AUTH_CLIENT ) ; </a> 0
<a> } else { </a> 0
<a> callingPackage = getCallingPackage ( ) ; </a> 0
<a> authorizationClient = new AuthorizationClient ( ) ; </a> 0
<a> request = ( AuthorizationClient . AuthorizationRequest ) getIntent ( ) . getSerializableExtra ( EXTRA_REQUEST ) ; </a> 0
<a> } </a> 0
<a> authorizationClient . setContext ( this ) ; </a> 0
<a> authorizationClient . setOnCompletedListener ( new AuthorizationClient . OnCompletedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( AuthorizationClient . Result outcome ) { </a> 0
<a> onAuthClientCompleted ( outcome ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> authorizationClient . setBackgroundProcessingListener ( new AuthorizationClient . BackgroundProcessingListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onBackgroundProcessingStarted ( ) { </a> 0
<a> findViewById ( R . id . com_facebook_login_activity_progress_bar ) . setVisibility ( View . VISIBLE ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onBackgroundProcessingStopped ( ) { </a> 0
<a> findViewById ( R . id . com_facebook_login_activity_progress_bar ) . setVisibility ( View . GONE ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private void onAuthClientCompleted ( AuthorizationClient . Result outcome ) { </a> 0
<a> request = null ; </a> 0
<a> int resultCode = ( outcome . code == AuthorizationClient . Result . Code . CANCEL ) ? </a> 0
<a> RESULT_CANCELED : RESULT_OK ; </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putSerializable ( RESULT_KEY , outcome ) ; </a> 0
<a> Intent resultIntent = new Intent ( ) ; </a> 0
<a> resultIntent . putExtras ( bundle ) ; </a> 0
<a> setResult ( resultCode , resultIntent ) ; </a> 0
<a> finish ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onResume ( ) { </a> 0
<a> super . onResume ( ) ; </a> 0
<a> if ( callingPackage == null ) { </a> 0
<a> throw new FacebookException ( NULL_CALLING_PKG_ERROR_MSG ) ; </a> 0
<a> } </a> 0
<a> authorizationClient . startOrContinueAuth ( request ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onPause ( ) { </a> 0
<a> super . onPause ( ) ; </a> 0
<a> authorizationClient . cancelCurrentHandler ( ) ; </a> 0
<a> findViewById ( R . id . com_facebook_login_activity_progress_bar ) . setVisibility ( View . GONE ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onSaveInstanceState ( Bundle outState ) { </a> 0
<a> super . onSaveInstanceState ( outState ) ; </a> 0
<a> outState . putString ( SAVED_CALLING_PKG_KEY , callingPackage ) ; </a> 0
<a> outState . putSerializable ( SAVED_AUTH_CLIENT , authorizationClient ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> authorizationClient . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> static Bundle populateIntentExtras ( AuthorizationClient . AuthorizationRequest request ) { </a> 0
<a> Bundle extras = new Bundle ( ) ; </a> 0
<a> extras . putSerializable ( EXTRA_REQUEST , request ) ; </a> 0
<a> return extras ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . content . pm . PackageInfo ; </a> 0
<a> import android . content . pm . PackageManager ; </a> 0
<a> import android . content . pm . ResolveInfo ; </a> 0
<a> import android . content . pm . Signature ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> final class NativeProtocol { </a> 0
<a> static final String KATANA_PACKAGE = "com.facebook.katana" ; </a> 0
<a> static final String KATANA_PROXY_AUTH_ACTIVITY = "com.facebook.katana.ProxyAuth" ; </a> 0
<a> static final String KATANA_TOKEN_REFRESH_ACTIVITY = "com.facebook.katana.platform.TokenRefreshService" ; </a> 0
<a> static final String KATANA_SIGNATURE = </a> 0
<a> "30820268308201d102044a9c4610300d06092a864886f70d0101040500307a310" </a> 0
<a> + "b3009060355040613025553310b30090603550408130243413112301006035504" </a> 0
<a> + "07130950616c6f20416c746f31183016060355040a130f46616365626f6f6b204" </a> 0
<a> + "d6f62696c653111300f060355040b130846616365626f6f6b311d301b06035504" </a> 0
<a> + "03131446616365626f6f6b20436f72706f726174696f6e3020170d30393038333" </a> 0
<a> + "13231353231365a180f32303530303932353231353231365a307a310b30090603" </a> 0
<a> + "55040613025553310b30090603550408130243413112301006035504071309506" </a> 0
<a> + "16c6f20416c746f31183016060355040a130f46616365626f6f6b204d6f62696c" </a> 0
<a> + "653111300f060355040b130846616365626f6f6b311d301b06035504031314466" </a> 0
<a> + "16365626f6f6b20436f72706f726174696f6e30819f300d06092a864886f70d01" </a> 0
<a> + "0101050003818d0030818902818100c207d51df8eb8c97d93ba0c8c1002c928fa" </a> 0
<a> + "b00dc1b42fca5e66e99cc3023ed2d214d822bc59e8e35ddcf5f44c7ae8ade50d7" </a> 0
<a> + "e0c434f500e6c131f4a2834f987fc46406115de2018ebbb0d5a3c261bd97581cc" </a> 0
<a> + "fef76afc7135a6d59e8855ecd7eacc8f8737e794c60a761c536b72b11fac8e603" </a> 0
<a> + "f5da1a2d54aa103b8a13c0dbc10203010001300d06092a864886f70d010104050" </a> 0
<a> + "0038181005ee9be8bcbb250648d3b741290a82a1c9dc2e76a0af2f2228f1d9f9c" </a> 0
<a> + "4007529c446a70175c5a900d5141812866db46be6559e2141616483998211f4a6" </a> 0
<a> + "73149fb2232a10d247663b26a9031e15f84bc1c74d141ff98a02d76f85b2c8ab2" </a> 0
<a> + "571b6469b232d8e768a7f7ca04f7abe4a775615916c07940656b58717457b42bd" </a> 0
<a> + "928a2" ; </a> 0
<a> private static final String BASIC_INFO = "basic_info" ; </a> 0
<a> public static final String KATANA_PROXY_AUTH_PERMISSIONS_KEY = "scope" ; </a> 0
<a> public static final String KATANA_PROXY_AUTH_APP_ID_KEY = "client_id" ; </a> 0
<a> static final boolean validateSignature ( Context context , String packageName ) { </a> 0
<a> PackageInfo packageInfo = null ; </a> 0
<a> try { </a> 0
<a> packageInfo = context . getPackageManager ( ) . getPackageInfo ( packageName , </a> 0
<a> PackageManager . GET_SIGNATURES ) ; </a> 0
<a> } catch ( PackageManager . NameNotFoundException e ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> for ( Signature signature : packageInfo . signatures ) { </a> 0
<a> if ( signature . toCharsString ( ) . equals ( KATANA_SIGNATURE ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> static Intent validateKatanaActivityIntent ( Context context , Intent intent ) { </a> 0
<a> if ( intent == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> ResolveInfo resolveInfo = context . getPackageManager ( ) . resolveActivity ( intent , 0 ) ; </a> 0
<a> if ( resolveInfo == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( ! validateSignature ( context , resolveInfo . activityInfo . packageName ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return intent ; </a> 0
<a> } </a> 0
<a> static Intent validateKatanaServiceIntent ( Context context , Intent intent ) { </a> 0
<a> if ( intent == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> ResolveInfo resolveInfo = context . getPackageManager ( ) . resolveService ( intent , 0 ) ; </a> 0
<a> if ( resolveInfo == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( ! validateSignature ( context , resolveInfo . serviceInfo . packageName ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return intent ; </a> 0
<a> } </a> 0
<a> static Intent createProxyAuthIntent ( Context context , String applicationId , List < String > permissions ) { </a> 0
<a> Intent intent = new Intent ( ) </a> 0
<a> . setClassName ( KATANA_PACKAGE , KATANA_PROXY_AUTH_ACTIVITY ) </a> 0
<a> . putExtra ( KATANA_PROXY_AUTH_APP_ID_KEY , applicationId ) ; </a> 0
<a> if ( ! Utility . isNullOrEmpty ( permissions ) ) { </a> 0
<a> intent . putExtra ( KATANA_PROXY_AUTH_PERMISSIONS_KEY , TextUtils . join ( "," , permissions ) ) ; </a> 0
<a> } </a> 0
<a> return validateKatanaActivityIntent ( context , intent ) ; </a> 0
<a> } </a> 0
<a> static Intent createTokenRefreshIntent ( Context context ) { </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . setClassName ( KATANA_PACKAGE , KATANA_TOKEN_REFRESH_ACTIVITY ) ; </a> 0
<a> return validateKatanaServiceIntent ( context , intent ) ; </a> 0
<a> } </a> 0
<a> static final String INTENT_ACTION_PLATFORM_ACTIVITY = "com.facebook.platform.PLATFORM_ACTIVITY" ; </a> 0
<a> static final String INTENT_ACTION_PLATFORM_SERVICE = "com.facebook.platform.PLATFORM_SERVICE" ; </a> 0
<a> static final int PROTOCOL_VERSION_20121101 = 20121101 ; </a> 0
<a> static final String EXTRA_PROTOCOL_VERSION = "com.facebook.platform.protocol.PROTOCOL_VERSION" ; </a> 0
<a> static final String EXTRA_PROTOCOL_ACTION = "com.facebook.platform.protocol.PROTOCOL_ACTION" ; </a> 0
<a> static final int MESSAGE_GET_ACCESS_TOKEN_REQUEST = 0x10000 ; </a> 0
<a> static final int MESSAGE_GET_ACCESS_TOKEN_REPLY = 0x10001 ; </a> 0
<a> static final String ACTION_LOGIN_DIALOG = "com.facebook.platform.action.request.LOGIN_DIALOG" ; </a> 0
<a> static final String ACTION_LOGIN_DIALOG_REPLY = </a> 0
<a> "com.facebook.platform.action.reply.LOGIN_DIALOG" ; </a> 0
<a> static final String EXTRA_PERMISSIONS = "com.facebook.platform.extra.PERMISSIONS" ; </a> 0
<a> static final String EXTRA_WRITE_PRIVACY = "com.facebook.platform.extra.WRITE_PRIVACY" ; </a> 0
<a> static final String EXTRA_APPLICATION_ID = "com.facebook.platform.extra.APPLICATION_ID" ; </a> 0
<a> static final String EXTRA_ACCESS_TOKEN = "com.facebook.platform.extra.ACCESS_TOKEN" ; </a> 0
<a> static final String EXTRA_EXPIRES_SECONDS_SINCE_EPOCH = </a> 0
<a> "com.facebook.platform.extra.EXPIRES_SECONDS_SINCE_EPOCH" ; </a> 0
<a> static final String STATUS_ERROR_TYPE = "com.facebook.platform.status.ERROR_TYPE" ; </a> 0
<a> static final String STATUS_ERROR_DESCRIPTION = </a> 0
<a> "com.facebook.platform.status.ERROR_DESCRIPTION" ; </a> 0
<a> static final String STATUS_ERROR_CODE = "com.facebook.platform.status.ERROR_CODE" ; </a> 0
<a> static final String STATUS_ERROR_SUBCODE = "com.facebook.platform.status.ERROR_SUBCODE" ; </a> 0
<a> static final String STATUS_ERROR_JSON = "com.facebook.platform.status.ERROR_JSON" ; </a> 0
<a> static final String ERROR_UNKNOWN_ERROR = "UnknownError" ; </a> 0
<a> static final String ERROR_PROTOCOL_ERROR = "ProtocolError" ; </a> 0
<a> static final String ERROR_USER_CANCELED = "UserCanceled" ; </a> 0
<a> static final String ERROR_APPLICATION_ERROR = "ApplicationError" ; </a> 0
<a> static final String ERROR_NETWORK_ERROR = "NetworkError" ; </a> 0
<a> static final String ERROR_PERMISSION_DENIED = "PermissionDenied" ; </a> 0
<a> static final String ERROR_SERVICE_DISABLED = "ServiceDisabled" ; </a> 0
<a> static final String AUDIENCE_ME = "SELF" ; </a> 0
<a> static final String AUDIENCE_FRIENDS = "ALL_FRIENDS" ; </a> 0
<a> static final String AUDIENCE_EVERYONE = "EVERYONE" ; </a> 0
<a> static Intent createLoginDialog20121101Intent ( Context context , String applicationId , ArrayList < String > permissions , </a> 0
<a> String audience ) { </a> 0
<a> Intent intent = new Intent ( ) </a> 0
<a> . setAction ( INTENT_ACTION_PLATFORM_ACTIVITY ) </a> 0
<a> . addCategory ( Intent . CATEGORY_DEFAULT ) </a> 0
<a> . putExtra ( EXTRA_PROTOCOL_VERSION , PROTOCOL_VERSION_20121101 ) </a> 0
<a> . putExtra ( EXTRA_PROTOCOL_ACTION , ACTION_LOGIN_DIALOG ) </a> 0
<a> . putExtra ( EXTRA_APPLICATION_ID , applicationId ) </a> 0
<a> . putStringArrayListExtra ( EXTRA_PERMISSIONS , ensureDefaultPermissions ( permissions ) ) </a> 0
<a> . putExtra ( EXTRA_WRITE_PRIVACY , ensureDefaultAudience ( audience ) ) ; </a> 0
<a> return validateKatanaActivityIntent ( context , intent ) ; </a> 0
<a> } </a> 0
<a> private static String ensureDefaultAudience ( String audience ) { </a> 0
<a> if ( Utility . isNullOrEmpty ( audience ) ) { </a> 0
<a> return AUDIENCE_ME ; </a> 0
<a> } else { </a> 0
<a> return audience ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static ArrayList < String > ensureDefaultPermissions ( ArrayList < String > permissions ) { </a> 0
<a> ArrayList < String > updated ; </a> 0
<a> if ( Utility . isNullOrEmpty ( permissions ) ) { </a> 0
<a> updated = new ArrayList < String > ( ) ; </a> 0
<a> } else { </a> 0
<a> for ( String permission : permissions ) { </a> 0
<a> if ( Session . isPublishPermission ( permission ) || BASIC_INFO . equals ( permission ) ) { </a> 0
<a> return permissions ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> updated = new ArrayList < String > ( permissions ) ; </a> 0
<a> } </a> 0
<a> updated . add ( BASIC_INFO ) ; </a> 0
<a> return updated ; </a> 0
<a> } </a> 0
<a> static boolean isServiceDisabledResult20121101 ( Intent data ) { </a> 0
<a> int protocolVersion = data . getIntExtra ( EXTRA_PROTOCOL_VERSION , 0 ) ; </a> 0
<a> String errorType = data . getStringExtra ( STATUS_ERROR_TYPE ) ; </a> 0
<a> return ( ( PROTOCOL_VERSION_20121101 == protocolVersion ) && ERROR_SERVICE_DISABLED . equals ( errorType ) ) ; </a> 0
<a> } </a> 0
<a> static AccessTokenSource getAccessTokenSourceFromNative ( Bundle extras ) { </a> 0
<a> long expected = PROTOCOL_VERSION_20121101 ; </a> 0
<a> long actual = extras . getInt ( EXTRA_PROTOCOL_VERSION , 0 ) ; </a> 0
<a> if ( expected == actual ) { </a> 0
<a> return AccessTokenSource . FACEBOOK_APPLICATION_NATIVE ; </a> 0
<a> } else { </a> 0
<a> return AccessTokenSource . FACEBOOK_APPLICATION_WEB ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> public class NonCachingTokenCachingStrategy extends TokenCachingStrategy { </a> 0
<a> @ Override </a> 0
<a> public Bundle load ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void save ( Bundle bundle ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clear ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . location . Location ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . os . ParcelFileDescriptor ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import android . util . Pair ; </a> 0
<a> import com . facebook . internal . ServerProtocol ; </a> 0
<a> import com . facebook . model . * ; </a> 0
<a> import com . facebook . internal . Logger ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import com . facebook . internal . Validate ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . io . * ; </a> 0
<a> import java . net . HttpURLConnection ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> import java . net . URL ; </a> 0
<a> import java . net . URLEncoder ; </a> 0
<a> import java . text . SimpleDateFormat ; </a> 0
<a> import java . util . * ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> public class Request { </a> 0
<a> public static final int MAXIMUM_BATCH_SIZE = 50 ; </a> 0
<a> private static final String ME = "me" ; </a> 0
<a> private static final String MY_FRIENDS = "me/friends" ; </a> 0
<a> private static final String MY_PHOTOS = "me/photos" ; </a> 0
<a> private static final String MY_VIDEOS = "me/videos" ; </a> 0
<a> private static final String SEARCH = "search" ; </a> 0
<a> private static final String MY_FEED = "me/feed" ; </a> 0
<a> private static final String USER_AGENT_BASE = "FBAndroidSDK" ; </a> 0
<a> private static final String USER_AGENT_HEADER = "User-Agent" ; </a> 0
<a> private static final String CONTENT_TYPE_HEADER = "Content-Type" ; </a> 0
<a> private static final String PICTURE_PARAM = "picture" ; </a> 0
<a> private static final String FORMAT_PARAM = "format" ; </a> 0
<a> private static final String FORMAT_JSON = "json" ; </a> 0
<a> private static final String SDK_PARAM = "sdk" ; </a> 0
<a> private static final String SDK_ANDROID = "android" ; </a> 0
<a> private static final String ACCESS_TOKEN_PARAM = "access_token" ; </a> 0
<a> private static final String BATCH_ENTRY_NAME_PARAM = "name" ; </a> 0
<a> private static final String BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM = "omit_response_on_success" ; </a> 0
<a> private static final String BATCH_ENTRY_DEPENDS_ON_PARAM = "depends_on" ; </a> 0
<a> private static final String BATCH_APP_ID_PARAM = "batch_app_id" ; </a> 0
<a> private static final String BATCH_RELATIVE_URL_PARAM = "relative_url" ; </a> 0
<a> private static final String BATCH_BODY_PARAM = "body" ; </a> 0
<a> private static final String BATCH_METHOD_PARAM = "method" ; </a> 0
<a> private static final String BATCH_PARAM = "batch" ; </a> 0
<a> private static final String ATTACHMENT_FILENAME_PREFIX = "file" ; </a> 0
<a> private static final String ATTACHED_FILES_PARAM = "attached_files" ; </a> 0
<a> private static final String MIGRATION_BUNDLE_PARAM = "migration_bundle" ; </a> 0
<a> private static final String ISO_8601_FORMAT_STRING = "yyyy-MM-dd'T'HH:mm:ssZ" ; </a> 0
<a> private static final String MIME_BOUNDARY = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f" ; </a> 0
<a> private static String defaultBatchApplicationId ; </a> 0
<a> private Session session ; </a> 0
<a> private HttpMethod httpMethod ; </a> 0
<a> private String graphPath ; </a> 0
<a> private GraphObject graphObject ; </a> 0
<a> private String restMethod ; </a> 0
<a> private String batchEntryName ; </a> 0
<a> private String batchEntryDependsOn ; </a> 0
<a> private boolean batchEntryOmitResultOnSuccess = true ; </a> 0
<a> private Bundle parameters ; </a> 0
<a> private Callback callback ; </a> 0
<a> private String overriddenURL ; </a> 0
<a> public Request ( ) { </a> 0
<a> this ( null , null , null , null , null ) ; </a> 0
<a> } </a> 0
<a> public Request ( Session session , String graphPath ) { </a> 0
<a> this ( session , graphPath , null , null , null ) ; </a> 0
<a> } </a> 0
<a> public Request ( Session session , String graphPath , Bundle parameters , HttpMethod httpMethod ) { </a> 0
<a> this ( session , graphPath , parameters , httpMethod , null ) ; </a> 0
<a> } </a> 0
<a> public Request ( Session session , String graphPath , Bundle parameters , HttpMethod httpMethod , Callback callback ) { </a> 0
<a> this . session = session ; </a> 0
<a> this . graphPath = graphPath ; </a> 0
<a> this . callback = callback ; </a> 0
<a> setHttpMethod ( httpMethod ) ; </a> 0
<a> if ( parameters != null ) { </a> 0
<a> this . parameters = new Bundle ( parameters ) ; </a> 0
<a> } else { </a> 0
<a> this . parameters = new Bundle ( ) ; </a> 0
<a> } </a> 0
<a> if ( ! this . parameters . containsKey ( MIGRATION_BUNDLE_PARAM ) ) { </a> 0
<a> this . parameters . putString ( MIGRATION_BUNDLE_PARAM , FacebookSdkVersion . MIGRATION_BUNDLE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Request ( Session session , URL overriddenURL ) { </a> 0
<a> this . session = session ; </a> 0
<a> this . overriddenURL = overriddenURL . toString ( ) ; </a> 0
<a> setHttpMethod ( HttpMethod . GET ) ; </a> 0
<a> this . parameters = new Bundle ( ) ; </a> 0
<a> } </a> 0
<a> public static Request newPostRequest ( Session session , String graphPath , GraphObject graphObject , Callback callback ) { </a> 0
<a> Request request = new Request ( session , graphPath , null , HttpMethod . POST , callback ) ; </a> 0
<a> request . setGraphObject ( graphObject ) ; </a> 0
<a> return request ; </a> 0
<a> } </a> 0
<a> public static Request newRestRequest ( Session session , String restMethod , Bundle parameters , HttpMethod httpMethod ) { </a> 0
<a> Request request = new Request ( session , null , parameters , httpMethod ) ; </a> 0
<a> request . setRestMethod ( restMethod ) ; </a> 0
<a> return request ; </a> 0
<a> } </a> 0
<a> public static Request newMeRequest ( Session session , final GraphUserCallback callback ) { </a> 0
<a> Callback wrapper = new Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> if ( callback != null ) { </a> 0
<a> callback . onCompleted ( response . getGraphObjectAs ( GraphUser . class ) , response ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> return new Request ( session , ME , null , null , wrapper ) ; </a> 0
<a> } </a> 0
<a> public static Request newMyFriendsRequest ( Session session , final GraphUserListCallback callback ) { </a> 0
<a> Callback wrapper = new Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> if ( callback != null ) { </a> 0
<a> callback . onCompleted ( typedListFromResponse ( response , GraphUser . class ) , response ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> return new Request ( session , MY_FRIENDS , null , null , wrapper ) ; </a> 0
<a> } </a> 0
<a> public static Request newUploadPhotoRequest ( Session session , Bitmap image , Callback callback ) { </a> 0
<a> Bundle parameters = new Bundle ( 1 ) ; </a> 0
<a> parameters . putParcelable ( PICTURE_PARAM , image ) ; </a> 0
<a> return new Request ( session , MY_PHOTOS , parameters , HttpMethod . POST , callback ) ; </a> 0
<a> } </a> 0
<a> public static Request newUploadPhotoRequest ( Session session , File file , </a> 0
<a> Callback callback ) throws FileNotFoundException { </a> 0
<a> ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; </a> 0
<a> Bundle parameters = new Bundle ( 1 ) ; </a> 0
<a> parameters . putParcelable ( PICTURE_PARAM , descriptor ) ; </a> 0
<a> return new Request ( session , MY_PHOTOS , parameters , HttpMethod . POST , callback ) ; </a> 0
<a> } </a> 0
<a> public static Request newUploadVideoRequest ( Session session , File file , </a> 0
<a> Callback callback ) throws FileNotFoundException { </a> 0
<a> ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; </a> 0
<a> Bundle parameters = new Bundle ( 1 ) ; </a> 0
<a> parameters . putParcelable ( file . getName ( ) , descriptor ) ; </a> 0
<a> return new Request ( session , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; </a> 0
<a> } </a> 0
<a> public static Request newGraphPathRequest ( Session session , String graphPath , Callback callback ) { </a> 0
<a> return new Request ( session , graphPath , null , null , callback ) ; </a> 0
<a> } </a> 0
<a> public static Request newPlacesSearchRequest ( Session session , Location location , int radiusInMeters , </a> 0
<a> int resultsLimit , String searchText , final GraphPlaceListCallback callback ) { </a> 0
<a> if ( location == null && Utility . isNullOrEmpty ( searchText ) ) { </a> 0
<a> throw new FacebookException ( "Either location or searchText must be specified." ) ; </a> 0
<a> } </a> 0
<a> Bundle parameters = new Bundle ( 5 ) ; </a> 0
<a> parameters . putString ( "type" , "place" ) ; </a> 0
<a> parameters . putInt ( "limit" , resultsLimit ) ; </a> 0
<a> if ( location != null ) { </a> 0
<a> parameters . putString ( "center" , </a> 0
<a> String . format ( Locale . US , "%f,%f" , location . getLatitude ( ) , location . getLongitude ( ) ) ) ; </a> 0
<a> parameters . putInt ( "distance" , radiusInMeters ) ; </a> 0
<a> } </a> 0
<a> if ( ! Utility . isNullOrEmpty ( searchText ) ) { </a> 0
<a> parameters . putString ( "q" , searchText ) ; </a> 0
<a> } </a> 0
<a> Callback wrapper = new Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> if ( callback != null ) { </a> 0
<a> callback . onCompleted ( typedListFromResponse ( response , GraphPlace . class ) , response ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> return new Request ( session , SEARCH , parameters , HttpMethod . GET , wrapper ) ; </a> 0
<a> } </a> 0
<a> public static Request newStatusUpdateRequest ( Session session , String message , Callback callback ) { </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> parameters . putString ( "message" , message ) ; </a> 0
<a> return new Request ( session , MY_FEED , parameters , HttpMethod . POST , callback ) ; </a> 0
<a> } </a> 0
<a> public final GraphObject getGraphObject ( ) { </a> 0
<a> return this . graphObject ; </a> 0
<a> } </a> 0
<a> public final void setGraphObject ( GraphObject graphObject ) { </a> 0
<a> this . graphObject = graphObject ; </a> 0
<a> } </a> 0
<a> public final String getGraphPath ( ) { </a> 0
<a> return this . graphPath ; </a> 0
<a> } </a> 0
<a> public final void setGraphPath ( String graphPath ) { </a> 0
<a> this . graphPath = graphPath ; </a> 0
<a> } </a> 0
<a> public final HttpMethod getHttpMethod ( ) { </a> 0
<a> return this . httpMethod ; </a> 0
<a> } </a> 0
<a> public final void setHttpMethod ( HttpMethod httpMethod ) { </a> 0
<a> if ( overriddenURL != null && httpMethod != HttpMethod . GET ) { </a> 0
<a> throw new FacebookException ( "Can't change HTTP method on request with overridden URL." ) ; </a> 0
<a> } </a> 0
<a> this . httpMethod = ( httpMethod != null ) ? httpMethod : HttpMethod . GET ; </a> 0
<a> } </a> 0
<a> public final Bundle getParameters ( ) { </a> 0
<a> return this . parameters ; </a> 0
<a> } </a> 0
<a> public final void setParameters ( Bundle parameters ) { </a> 0
<a> this . parameters = parameters ; </a> 0
<a> } </a> 0
<a> public final String getRestMethod ( ) { </a> 0
<a> return this . restMethod ; </a> 0
<a> } </a> 0
<a> public final void setRestMethod ( String restMethod ) { </a> 0
<a> this . restMethod = restMethod ; </a> 0
<a> } </a> 0
<a> public final Session getSession ( ) { </a> 0
<a> return this . session ; </a> 0
<a> } </a> 0
<a> public final void setSession ( Session session ) { </a> 0
<a> this . session = session ; </a> 0
<a> } </a> 0
<a> public final String getBatchEntryName ( ) { </a> 0
<a> return this . batchEntryName ; </a> 0
<a> } </a> 0
<a> public final void setBatchEntryName ( String batchEntryName ) { </a> 0
<a> this . batchEntryName = batchEntryName ; </a> 0
<a> } </a> 0
<a> public final String getBatchEntryDependsOn ( ) { </a> 0
<a> return this . batchEntryDependsOn ; </a> 0
<a> } </a> 0
<a> public final void setBatchEntryDependsOn ( String batchEntryDependsOn ) { </a> 0
<a> this . batchEntryDependsOn = batchEntryDependsOn ; </a> 0
<a> } </a> 0
<a> public final boolean getBatchEntryOmitResultOnSuccess ( ) { </a> 0
<a> return this . batchEntryOmitResultOnSuccess ; </a> 0
<a> } </a> 0
<a> public final void setBatchEntryOmitResultOnSuccess ( boolean batchEntryOmitResultOnSuccess ) { </a> 0
<a> this . batchEntryOmitResultOnSuccess = batchEntryOmitResultOnSuccess ; </a> 0
<a> } </a> 0
<a> public static final String getDefaultBatchApplicationId ( ) { </a> 0
<a> return Request . defaultBatchApplicationId ; </a> 0
<a> } </a> 0
<a> public static final void setDefaultBatchApplicationId ( String applicationId ) { </a> 0
<a> Request . defaultBatchApplicationId = applicationId ; </a> 0
<a> } </a> 0
<a> public final Callback getCallback ( ) { </a> 0
<a> return callback ; </a> 0
<a> } </a> 0
<a> public final void setCallback ( Callback callback ) { </a> 0
<a> this . callback = callback ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executePostRequestAsync ( Session session , String graphPath , GraphObject graphObject , </a> 0
<a> Callback callback ) { </a> 0
<a> return newPostRequest ( session , graphPath , graphObject , callback ) . executeAsync ( ) ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executeRestRequestAsync ( Session session , String restMethod , Bundle parameters , </a> 0
<a> HttpMethod httpMethod ) { </a> 0
<a> return newRestRequest ( session , restMethod , parameters , httpMethod ) . executeAsync ( ) ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executeMeRequestAsync ( Session session , GraphUserCallback callback ) { </a> 0
<a> return newMeRequest ( session , callback ) . executeAsync ( ) ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executeMyFriendsRequestAsync ( Session session , GraphUserListCallback callback ) { </a> 0
<a> return newMyFriendsRequest ( session , callback ) . executeAsync ( ) ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executeUploadPhotoRequestAsync ( Session session , Bitmap image , Callback callback ) { </a> 0
<a> return newUploadPhotoRequest ( session , image , callback ) . executeAsync ( ) ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executeUploadPhotoRequestAsync ( Session session , File file , </a> 0
<a> Callback callback ) throws FileNotFoundException { </a> 0
<a> return newUploadPhotoRequest ( session , file , callback ) . executeAsync ( ) ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executeGraphPathRequestAsync ( Session session , String graphPath , Callback callback ) { </a> 0
<a> return newGraphPathRequest ( session , graphPath , callback ) . executeAsync ( ) ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executePlacesSearchRequestAsync ( Session session , Location location , int radiusInMeters , </a> 0
<a> int resultsLimit , String searchText , GraphPlaceListCallback callback ) { </a> 0
<a> return newPlacesSearchRequest ( session , location , radiusInMeters , resultsLimit , searchText , callback ) . executeAsync ( ) ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executeStatusUpdateRequestAsync ( Session session , String message , Callback callback ) { </a> 0
<a> return newStatusUpdateRequest ( session , message , callback ) . executeAsync ( ) ; </a> 0
<a> } </a> 0
<a> public final Response executeAndWait ( ) { </a> 0
<a> return Request . executeAndWait ( this ) ; </a> 0
<a> } </a> 0
<a> public final RequestAsyncTask executeAsync ( ) { </a> 0
<a> return Request . executeBatchAsync ( this ) ; </a> 0
<a> } </a> 0
<a> public static HttpURLConnection toHttpConnection ( Request ... requests ) { </a> 0
<a> return toHttpConnection ( Arrays . asList ( requests ) ) ; </a> 0
<a> } </a> 0
<a> public static HttpURLConnection toHttpConnection ( Collection < Request > requests ) { </a> 0
<a> Validate . notEmptyAndContainsNoNulls ( requests , "requests" ) ; </a> 0
<a> return toHttpConnection ( new RequestBatch ( requests ) ) ; </a> 0
<a> } </a> 0
<a> public static HttpURLConnection toHttpConnection ( RequestBatch requests ) { </a> 0
<a> for ( Request request : requests ) { </a> 0
<a> request . validate ( ) ; </a> 0
<a> } </a> 0
<a> URL url = null ; </a> 0
<a> try { </a> 0
<a> if ( requests . size ( ) == 1 ) { </a> 0
<a> Request request = requests . get ( 0 ) ; </a> 0
<a> url = new URL ( request . getUrlForSingleRequest ( ) ) ; </a> 0
<a> } else { </a> 0
<a> url = new URL ( ServerProtocol . GRAPH_URL ) ; </a> 0
<a> } </a> 0
<a> } catch ( MalformedURLException e ) { </a> 0
<a> throw new FacebookException ( "could not construct URL for request" , e ) ; </a> 0
<a> } </a> 0
<a> HttpURLConnection connection ; </a> 0
<a> try { </a> 0
<a> connection = createConnection ( url ) ; </a> 0
<a> serializeToUrlConnection ( requests , connection ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new FacebookException ( "could not construct request body" , e ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> throw new FacebookException ( "could not construct request body" , e ) ; </a> 0
<a> } </a> 0
<a> return connection ; </a> 0
<a> } </a> 0
<a> public static Response executeAndWait ( Request request ) { </a> 0
<a> List < Response > responses = executeBatchAndWait ( request ) ; </a> 0
<a> if ( responses == null || responses . size ( ) != 1 ) { </a> 0
<a> throw new FacebookException ( "invalid state: expected a single response" ) ; </a> 0
<a> } </a> 0
<a> return responses . get ( 0 ) ; </a> 0
<a> } </a> 0
<a> public static List < Response > executeBatchAndWait ( Request ... requests ) { </a> 0
<a> Validate . notNull ( requests , "requests" ) ; </a> 0
<a> return executeBatchAndWait ( Arrays . asList ( requests ) ) ; </a> 0
<a> } </a> 0
<a> public static List < Response > executeBatchAndWait ( Collection < Request > requests ) { </a> 0
<a> return executeBatchAndWait ( new RequestBatch ( requests ) ) ; </a> 0
<a> } </a> 0
<a> public static List < Response > executeBatchAndWait ( RequestBatch requests ) { </a> 0
<a> Validate . notEmptyAndContainsNoNulls ( requests , "requests" ) ; </a> 0
<a> HttpURLConnection connection = null ; </a> 0
<a> try { </a> 0
<a> connection = toHttpConnection ( requests ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> List < Response > responses = Response . constructErrorResponses ( requests . getRequests ( ) , null , new FacebookException ( ex ) ) ; </a> 0
<a> runCallbacks ( requests , responses ) ; </a> 0
<a> return responses ; </a> 0
<a> } </a> 0
<a> List < Response > responses = executeConnectionAndWait ( connection , requests ) ; </a> 0
<a> return responses ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executeBatchAsync ( Request ... requests ) { </a> 0
<a> Validate . notNull ( requests , "requests" ) ; </a> 0
<a> return executeBatchAsync ( Arrays . asList ( requests ) ) ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executeBatchAsync ( Collection < Request > requests ) { </a> 0
<a> return executeBatchAsync ( new RequestBatch ( requests ) ) ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executeBatchAsync ( RequestBatch requests ) { </a> 0
<a> Validate . notEmptyAndContainsNoNulls ( requests , "requests" ) ; </a> 0
<a> RequestAsyncTask asyncTask = new RequestAsyncTask ( requests ) ; </a> 0
<a> asyncTask . executeOnSettingsExecutor ( ) ; </a> 0
<a> return asyncTask ; </a> 0
<a> } </a> 0
<a> public static List < Response > executeConnectionAndWait ( HttpURLConnection connection , Collection < Request > requests ) { </a> 0
<a> return executeConnectionAndWait ( connection , new RequestBatch ( requests ) ) ; </a> 0
<a> } </a> 0
<a> public static List < Response > executeConnectionAndWait ( HttpURLConnection connection , RequestBatch requests ) { </a> 0
<a> List < Response > responses = Response . fromHttpConnection ( connection , requests ) ; </a> 0
<a> Utility . disconnectQuietly ( connection ) ; </a> 0
<a> int numRequests = requests . size ( ) ; </a> 0
<a> if ( numRequests != responses . size ( ) ) { </a> 0
<a> throw new FacebookException ( String . format ( "Received %d responses while expecting %d" , responses . size ( ) , </a> 0
<a> numRequests ) ) ; </a> 0
<a> } </a> 0
<a> runCallbacks ( requests , responses ) ; </a> 0
<a> HashSet < Session > sessions = new HashSet < Session > ( ) ; </a> 0
<a> for ( Request request : requests ) { </a> 0
<a> if ( request . session != null ) { </a> 0
<a> sessions . add ( request . session ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( Session session : sessions ) { </a> 0
<a> session . extendAccessTokenIfNeeded ( ) ; </a> 0
<a> } </a> 0
<a> return responses ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executeConnectionAsync ( HttpURLConnection connection , RequestBatch requests ) { </a> 0
<a> return executeConnectionAsync ( null , connection , requests ) ; </a> 0
<a> } </a> 0
<a> public static RequestAsyncTask executeConnectionAsync ( Handler callbackHandler , HttpURLConnection connection , </a> 0
<a> RequestBatch requests ) { </a> 0
<a> Validate . notNull ( connection , "connection" ) ; </a> 0
<a> RequestAsyncTask asyncTask = new RequestAsyncTask ( connection , requests ) ; </a> 0
<a> requests . setCallbackHandler ( callbackHandler ) ; </a> 0
<a> asyncTask . executeOnSettingsExecutor ( ) ; </a> 0
<a> return asyncTask ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return new StringBuilder ( ) . append ( "{Request: " ) . append ( " session: " ) . append ( session ) . append ( ", graphPath: " ) </a> 0
<a> . append ( graphPath ) . append ( ", graphObject: " ) . append ( graphObject ) . append ( ", restMethod: " ) </a> 0
<a> . append ( restMethod ) . append ( ", httpMethod: " ) . append ( httpMethod ) . append ( ", parameters: " ) </a> 0
<a> . append ( parameters ) . append ( "}" ) . toString ( ) ; </a> 0
<a> } </a> 0
<a> static void runCallbacks ( final RequestBatch requests , List < Response > responses ) { </a> 0
<a> int numRequests = requests . size ( ) ; </a> 0
<a> final ArrayList < Pair < Callback , Response > > callbacks = new ArrayList < Pair < Callback , Response > > ( ) ; </a> 0
<a> for ( int i = 0 ; i < numRequests ; ++ i ) { </a> 0
<a> Request request = requests . get ( i ) ; </a> 0
<a> if ( request . callback != null ) { </a> 0
<a> callbacks . add ( new Pair < Callback , Response > ( request . callback , responses . get ( i ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( callbacks . size ( ) > 0 ) { </a> 0
<a> Runnable runnable = new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> for ( Pair < Callback , Response > pair : callbacks ) { </a> 0
<a> pair . first . onCompleted ( pair . second ) ; </a> 0
<a> } </a> 0
<a> List < RequestBatch . Callback > batchCallbacks = requests . getCallbacks ( ) ; </a> 0
<a> for ( RequestBatch . Callback batchCallback : batchCallbacks ) { </a> 0
<a> batchCallback . onBatchCompleted ( requests ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> Handler callbackHandler = requests . getCallbackHandler ( ) ; </a> 0
<a> if ( callbackHandler == null ) { </a> 0
<a> runnable . run ( ) ; </a> 0
<a> } else { </a> 0
<a> callbackHandler . post ( runnable ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static HttpURLConnection createConnection ( URL url ) throws IOException { </a> 0
<a> HttpURLConnection connection ; </a> 0
<a> connection = ( HttpURLConnection ) url . openConnection ( ) ; </a> 0
<a> connection . setRequestProperty ( USER_AGENT_HEADER , getUserAgent ( ) ) ; </a> 0
<a> connection . setRequestProperty ( CONTENT_TYPE_HEADER , getMimeContentType ( ) ) ; </a> 0
<a> connection . setChunkedStreamingMode ( 0 ) ; </a> 0
<a> return connection ; </a> 0
<a> } </a> 0
<a> private void addCommonParameters ( ) { </a> 0
<a> if ( this . session != null ) { </a> 0
<a> if ( ! this . session . isOpened ( ) ) { </a> 0
<a> throw new FacebookException ( "Session provided to a Request in un-opened state." ) ; </a> 0
<a> } else if ( ! this . parameters . containsKey ( ACCESS_TOKEN_PARAM ) ) { </a> 0
<a> String accessToken = this . session . getAccessToken ( ) ; </a> 0
<a> Logger . registerAccessToken ( accessToken ) ; </a> 0
<a> this . parameters . putString ( ACCESS_TOKEN_PARAM , accessToken ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> this . parameters . putString ( SDK_PARAM , SDK_ANDROID ) ; </a> 0
<a> this . parameters . putString ( FORMAT_PARAM , FORMAT_JSON ) ; </a> 0
<a> } </a> 0
<a> private String appendParametersToBaseUrl ( String baseUrl ) { </a> 0
<a> Uri . Builder uriBuilder = new Uri . Builder ( ) . encodedPath ( baseUrl ) ; </a> 0
<a> Set < String > keys = this . parameters . keySet ( ) ; </a> 0
<a> for ( String key : keys ) { </a> 0
<a> Object value = this . parameters . get ( key ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> value = "" ; </a> 0
<a> } </a> 0
<a> if ( isSupportedParameterType ( value ) ) { </a> 0
<a> value = parameterToString ( value ) ; </a> 0
<a> } else { </a> 0
<a> if ( httpMethod == HttpMethod . GET ) { </a> 0
<a> throw new IllegalArgumentException ( String . format ( "Unsupported parameter type for GET request: %s" , </a> 0
<a> value . getClass ( ) . getSimpleName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> uriBuilder . appendQueryParameter ( key , value . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> return uriBuilder . toString ( ) ; </a> 0
<a> } </a> 0
<a> final String getUrlForBatchedRequest ( ) { </a> 0
<a> if ( overriddenURL != null ) { </a> 0
<a> throw new FacebookException ( "Can't override URL for a batch request" ) ; </a> 0
<a> } </a> 0
<a> String baseUrl ; </a> 0
<a> if ( this . restMethod != null ) { </a> 0
<a> baseUrl = ServerProtocol . BATCHED_REST_METHOD_URL_BASE + this . restMethod ; </a> 0
<a> } else { </a> 0
<a> baseUrl = this . graphPath ; </a> 0
<a> } </a> 0
<a> addCommonParameters ( ) ; </a> 0
<a> return appendParametersToBaseUrl ( baseUrl ) ; </a> 0
<a> } </a> 0
<a> final String getUrlForSingleRequest ( ) { </a> 0
<a> if ( overriddenURL != null ) { </a> 0
<a> return overriddenURL . toString ( ) ; </a> 0
<a> } </a> 0
<a> String baseUrl ; </a> 0
<a> if ( this . restMethod != null ) { </a> 0
<a> baseUrl = ServerProtocol . REST_URL_BASE + this . restMethod ; </a> 0
<a> } else { </a> 0
<a> baseUrl = ServerProtocol . GRAPH_URL_BASE + this . graphPath ; </a> 0
<a> } </a> 0
<a> addCommonParameters ( ) ; </a> 0
<a> return appendParametersToBaseUrl ( baseUrl ) ; </a> 0
<a> } </a> 0
<a> private void serializeToBatch ( JSONArray batch , Bundle attachments ) throws JSONException , IOException { </a> 0
<a> JSONObject batchEntry = new JSONObject ( ) ; </a> 0
<a> if ( this . batchEntryName != null ) { </a> 0
<a> batchEntry . put ( BATCH_ENTRY_NAME_PARAM , this . batchEntryName ) ; </a> 0
<a> batchEntry . put ( BATCH_ENTRY_OMIT_RESPONSE_ON_SUCCESS_PARAM , this . batchEntryOmitResultOnSuccess ) ; </a> 0
<a> } </a> 0
<a> if ( this . batchEntryDependsOn != null ) { </a> 0
<a> batchEntry . put ( BATCH_ENTRY_DEPENDS_ON_PARAM , this . batchEntryDependsOn ) ; </a> 0
<a> } </a> 0
<a> String relativeURL = getUrlForBatchedRequest ( ) ; </a> 0
<a> batchEntry . put ( BATCH_RELATIVE_URL_PARAM , relativeURL ) ; </a> 0
<a> batchEntry . put ( BATCH_METHOD_PARAM , httpMethod ) ; </a> 0
<a> if ( this . session != null ) { </a> 0
<a> String accessToken = this . session . getAccessToken ( ) ; </a> 0
<a> Logger . registerAccessToken ( accessToken ) ; </a> 0
<a> } </a> 0
<a> ArrayList < String > attachmentNames = new ArrayList < String > ( ) ; </a> 0
<a> Set < String > keys = this . parameters . keySet ( ) ; </a> 0
<a> for ( String key : keys ) { </a> 0
<a> Object value = this . parameters . get ( key ) ; </a> 0
<a> if ( isSupportedAttachmentType ( value ) ) { </a> 0
<a> String name = String . format ( "%s%d" , ATTACHMENT_FILENAME_PREFIX , attachments . size ( ) ) ; </a> 0
<a> attachmentNames . add ( name ) ; </a> 0
<a> Utility . putObjectInBundle ( attachments , name , value ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! attachmentNames . isEmpty ( ) ) { </a> 0
<a> String attachmentNamesString = TextUtils . join ( "," , attachmentNames ) ; </a> 0
<a> batchEntry . put ( ATTACHED_FILES_PARAM , attachmentNamesString ) ; </a> 0
<a> } </a> 0
<a> if ( this . graphObject != null ) { </a> 0
<a> final ArrayList < String > keysAndValues = new ArrayList < String > ( ) ; </a> 0
<a> processGraphObject ( this . graphObject , relativeURL , new KeyValueSerializer ( ) { </a> 0
<a> @ Override </a> 0
<a> public void writeString ( String key , String value ) throws IOException { </a> 0
<a> keysAndValues . add ( String . format ( "%s=%s" , key , URLEncoder . encode ( value , "UTF-8" ) ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> String bodyValue = TextUtils . join ( "&" , keysAndValues ) ; </a> 0
<a> batchEntry . put ( BATCH_BODY_PARAM , bodyValue ) ; </a> 0
<a> } </a> 0
<a> batch . put ( batchEntry ) ; </a> 0
<a> } </a> 0
<a> private void validate ( ) { </a> 0
<a> if ( graphPath != null && restMethod != null ) { </a> 0
<a> throw new IllegalArgumentException ( "Only one of a graph path or REST method may be specified per request." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> final static void serializeToUrlConnection ( RequestBatch requests , HttpURLConnection connection ) </a> 0
<a> throws IOException , JSONException { </a> 0
<a> Logger logger = new Logger ( LoggingBehavior . REQUESTS , "Request" ) ; </a> 0
<a> int numRequests = requests . size ( ) ; </a> 0
<a> HttpMethod connectionHttpMethod = ( numRequests == 1 ) ? requests . get ( 0 ) . httpMethod : HttpMethod . POST ; </a> 0
<a> connection . setRequestMethod ( connectionHttpMethod . name ( ) ) ; </a> 0
<a> URL url = connection . getURL ( ) ; </a> 0
<a> logger . append ( "Request:\n" ) ; </a> 0
<a> logger . appendKeyValue ( "Id" , requests . getId ( ) ) ; </a> 0
<a> logger . appendKeyValue ( "URL" , url ) ; </a> 0
<a> logger . appendKeyValue ( "Method" , connection . getRequestMethod ( ) ) ; </a> 0
<a> logger . appendKeyValue ( "User-Agent" , connection . getRequestProperty ( "User-Agent" ) ) ; </a> 0
<a> logger . appendKeyValue ( "Content-Type" , connection . getRequestProperty ( "Content-Type" ) ) ; </a> 0
<a> connection . setConnectTimeout ( requests . getTimeout ( ) ) ; </a> 0
<a> connection . setReadTimeout ( requests . getTimeout ( ) ) ; </a> 0
<a> boolean isPost = ( connectionHttpMethod == HttpMethod . POST ) ; </a> 0
<a> if ( ! isPost ) { </a> 0
<a> logger . log ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> connection . setDoOutput ( true ) ; </a> 0
<a> BufferedOutputStream outputStream = new BufferedOutputStream ( connection . getOutputStream ( ) ) ; </a> 0
<a> try { </a> 0
<a> Serializer serializer = new Serializer ( outputStream , logger ) ; </a> 0
<a> if ( numRequests == 1 ) { </a> 0
<a> Request request = requests . get ( 0 ) ; </a> 0
<a> logger . append ( " Parameters:\n" ) ; </a> 0
<a> serializeParameters ( request . parameters , serializer ) ; </a> 0
<a> logger . append ( " Attachments:\n" ) ; </a> 0
<a> serializeAttachments ( request . parameters , serializer ) ; </a> 0
<a> if ( request . graphObject != null ) { </a> 0
<a> processGraphObject ( request . graphObject , url . getPath ( ) , serializer ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> String batchAppID = getBatchAppId ( requests ) ; </a> 0
<a> if ( Utility . isNullOrEmpty ( batchAppID ) ) { </a> 0
<a> throw new FacebookException ( "At least one request in a batch must have an open Session, or a " </a> 0
<a> + "default app ID must be specified." ) ; </a> 0
<a> } </a> 0
<a> serializer . writeString ( BATCH_APP_ID_PARAM , batchAppID ) ; </a> 0
<a> Bundle attachments = new Bundle ( ) ; </a> 0
<a> serializeRequestsAsJSON ( serializer , requests , attachments ) ; </a> 0
<a> logger . append ( " Attachments:\n" ) ; </a> 0
<a> serializeAttachments ( attachments , serializer ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> outputStream . close ( ) ; </a> 0
<a> } </a> 0
<a> logger . log ( ) ; </a> 0
<a> } </a> 0
<a> private static void processGraphObject ( GraphObject graphObject , String path , KeyValueSerializer serializer ) </a> 0
<a> throws IOException { </a> 0
<a> boolean isOGAction = false ; </a> 0
<a> if ( path . startsWith ( "me/" ) || path . startsWith ( "/me/" ) ) { </a> 0
<a> int colonLocation = path . indexOf ( ":" ) ; </a> 0
<a> int questionMarkLocation = path . indexOf ( "?" ) ; </a> 0
<a> isOGAction = colonLocation > 3 && ( questionMarkLocation == - 1 || colonLocation < questionMarkLocation ) ; </a> 0
<a> } </a> 0
<a> Set < Entry < String , Object > > entries = graphObject . asMap ( ) . entrySet ( ) ; </a> 0
<a> for ( Entry < String , Object > entry : entries ) { </a> 0
<a> boolean passByValue = isOGAction && entry . getKey ( ) . equalsIgnoreCase ( "image" ) ; </a> 0
<a> processGraphObjectProperty ( entry . getKey ( ) , entry . getValue ( ) , serializer , passByValue ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void processGraphObjectProperty ( String key , Object value , KeyValueSerializer serializer , </a> 0
<a> boolean passByValue ) throws IOException { </a> 0
<a> Class < ? > valueClass = value . getClass ( ) ; </a> 0
<a> if ( GraphObject . class . isAssignableFrom ( valueClass ) ) { </a> 0
<a> value = ( ( GraphObject ) value ) . getInnerJSONObject ( ) ; </a> 0
<a> valueClass = value . getClass ( ) ; </a> 0
<a> } else if ( GraphObjectList . class . isAssignableFrom ( valueClass ) ) { </a> 0
<a> value = ( ( GraphObjectList < ? > ) value ) . getInnerJSONArray ( ) ; </a> 0
<a> valueClass = value . getClass ( ) ; </a> 0
<a> } </a> 0
<a> if ( JSONObject . class . isAssignableFrom ( valueClass ) ) { </a> 0
<a> JSONObject jsonObject = ( JSONObject ) value ; </a> 0
<a> if ( passByValue ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> Iterator < String > keys = jsonObject . keys ( ) ; </a> 0
<a> while ( keys . hasNext ( ) ) { </a> 0
<a> String propertyName = keys . next ( ) ; </a> 0
<a> String subKey = String . format ( "%s[%s]" , key , propertyName ) ; </a> 0
<a> processGraphObjectProperty ( subKey , jsonObject . opt ( propertyName ) , serializer , passByValue ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( jsonObject . has ( "id" ) ) { </a> 0
<a> processGraphObjectProperty ( key , jsonObject . optString ( "id" ) , serializer , passByValue ) ; </a> 0
<a> } else if ( jsonObject . has ( "url" ) ) { </a> 0
<a> processGraphObjectProperty ( key , jsonObject . optString ( "url" ) , serializer , passByValue ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else if ( JSONArray . class . isAssignableFrom ( valueClass ) ) { </a> 0
<a> JSONArray jsonArray = ( JSONArray ) value ; </a> 0
<a> int length = jsonArray . length ( ) ; </a> 0
<a> for ( int i = 0 ; i < length ; ++ i ) { </a> 0
<a> String subKey = String . format ( "%s[%d]" , key , i ) ; </a> 0
<a> processGraphObjectProperty ( subKey , jsonArray . opt ( i ) , serializer , passByValue ) ; </a> 0
<a> } </a> 0
<a> } else if ( String . class . isAssignableFrom ( valueClass ) || </a> 0
<a> Number . class . isAssignableFrom ( valueClass ) || </a> 0
<a> Boolean . class . isAssignableFrom ( valueClass ) ) { </a> 0
<a> serializer . writeString ( key , value . toString ( ) ) ; </a> 0
<a> } else if ( Date . class . isAssignableFrom ( valueClass ) ) { </a> 0
<a> Date date = ( Date ) value ; </a> 0
<a> final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat ( ISO_8601_FORMAT_STRING , Locale . US ) ; </a> 0
<a> serializer . writeString ( key , iso8601DateFormat . format ( date ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void serializeParameters ( Bundle bundle , Serializer serializer ) throws IOException { </a> 0
<a> Set < String > keys = bundle . keySet ( ) ; </a> 0
<a> for ( String key : keys ) { </a> 0
<a> Object value = bundle . get ( key ) ; </a> 0
<a> if ( isSupportedParameterType ( value ) ) { </a> 0
<a> serializer . writeObject ( key , value ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void serializeAttachments ( Bundle bundle , Serializer serializer ) throws IOException { </a> 0
<a> Set < String > keys = bundle . keySet ( ) ; </a> 0
<a> for ( String key : keys ) { </a> 0
<a> Object value = bundle . get ( key ) ; </a> 0
<a> if ( isSupportedAttachmentType ( value ) ) { </a> 0
<a> serializer . writeObject ( key , value ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void serializeRequestsAsJSON ( Serializer serializer , Collection < Request > requests , Bundle attachments ) </a> 0
<a> throws JSONException , IOException { </a> 0
<a> JSONArray batch = new JSONArray ( ) ; </a> 0
<a> for ( Request request : requests ) { </a> 0
<a> request . serializeToBatch ( batch , attachments ) ; </a> 0
<a> } </a> 0
<a> String batchAsString = batch . toString ( ) ; </a> 0
<a> serializer . writeString ( BATCH_PARAM , batchAsString ) ; </a> 0
<a> } </a> 0
<a> private static String getMimeContentType ( ) { </a> 0
<a> return String . format ( "multipart/form-data; boundary=%s" , MIME_BOUNDARY ) ; </a> 0
<a> } </a> 0
<a> private static volatile String userAgent ; </a> 0
<a> private static String getUserAgent ( ) { </a> 0
<a> if ( userAgent == null ) { </a> 0
<a> userAgent = String . format ( "%s.%s" , USER_AGENT_BASE , FacebookSdkVersion . BUILD ) ; </a> 0
<a> } </a> 0
<a> return userAgent ; </a> 0
<a> } </a> 0
<a> private static String getBatchAppId ( RequestBatch batch ) { </a> 0
<a> if ( ! Utility . isNullOrEmpty ( batch . getBatchApplicationId ( ) ) ) { </a> 0
<a> return batch . getBatchApplicationId ( ) ; </a> 0
<a> } </a> 0
<a> for ( Request request : batch ) { </a> 0
<a> Session session = request . session ; </a> 0
<a> if ( session != null ) { </a> 0
<a> return session . getApplicationId ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return Request . defaultBatchApplicationId ; </a> 0
<a> } </a> 0
<a> private static < T extends GraphObject > List < T > typedListFromResponse ( Response response , Class < T > clazz ) { </a> 0
<a> GraphMultiResult multiResult = response . getGraphObjectAs ( GraphMultiResult . class ) ; </a> 0
<a> if ( multiResult == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> GraphObjectList < GraphObject > data = multiResult . getData ( ) ; </a> 0
<a> if ( data == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return data . castToListOf ( clazz ) ; </a> 0
<a> } </a> 0
<a> private static boolean isSupportedAttachmentType ( Object value ) { </a> 0
<a> return value instanceof Bitmap || value instanceof byte [ ] || value instanceof ParcelFileDescriptor ; </a> 0
<a> } </a> 0
<a> private static boolean isSupportedParameterType ( Object value ) { </a> 0
<a> return value instanceof String || value instanceof Boolean || value instanceof Number || </a> 0
<a> value instanceof Date ; </a> 0
<a> } </a> 0
<a> private static String parameterToString ( Object value ) { </a> 0
<a> if ( value instanceof String ) { </a> 0
<a> return ( String ) value ; </a> 0
<a> } else if ( value instanceof Boolean || value instanceof Number ) { </a> 0
<a> return value . toString ( ) ; </a> 0
<a> } else if ( value instanceof Date ) { </a> 0
<a> final SimpleDateFormat iso8601DateFormat = new SimpleDateFormat ( ISO_8601_FORMAT_STRING , Locale . US ) ; </a> 0
<a> return iso8601DateFormat . format ( value ) ; </a> 0
<a> } </a> 0
<a> throw new IllegalArgumentException ( "Unsupported parameter type." ) ; </a> 0
<a> } </a> 0
<a> private interface KeyValueSerializer { </a> 0
<a> void writeString ( String key , String value ) throws IOException ; </a> 0
<a> } </a> 0
<a> private static class Serializer implements KeyValueSerializer { </a> 0
<a> private final BufferedOutputStream outputStream ; </a> 0
<a> private final Logger logger ; </a> 0
<a> private boolean firstWrite = true ; </a> 0
<a> public Serializer ( BufferedOutputStream outputStream , Logger logger ) { </a> 0
<a> this . outputStream = outputStream ; </a> 0
<a> this . logger = logger ; </a> 0
<a> } </a> 0
<a> public void writeObject ( String key , Object value ) throws IOException { </a> 0
<a> if ( isSupportedParameterType ( value ) ) { </a> 0
<a> writeString ( key , parameterToString ( value ) ) ; </a> 0
<a> } else if ( value instanceof Bitmap ) { </a> 0
<a> writeBitmap ( key , ( Bitmap ) value ) ; </a> 0
<a> } else if ( value instanceof byte [ ] ) { </a> 0
<a> writeBytes ( key , ( byte [ ] ) value ) ; </a> 0
<a> } else if ( value instanceof ParcelFileDescriptor ) { </a> 0
<a> writeFile ( key , ( ParcelFileDescriptor ) value ) ; </a> 0
<a> } else { </a> 0
<a> throw new IllegalArgumentException ( "value is not a supported type: String, Bitmap, byte[]" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void writeString ( String key , String value ) throws IOException { </a> 0
<a> writeContentDisposition ( key , null , null ) ; </a> 0
<a> writeLine ( "%s" , value ) ; </a> 0
<a> writeRecordBoundary ( ) ; </a> 0
<a> if ( logger != null ) { </a> 0
<a> logger . appendKeyValue ( " " + key , value ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void writeBitmap ( String key , Bitmap bitmap ) throws IOException { </a> 0
<a> writeContentDisposition ( key , key , "image/png" ) ; </a> 0
<a> bitmap . compress ( Bitmap . CompressFormat . PNG , 100 , outputStream ) ; </a> 0
<a> writeLine ( "" ) ; </a> 0
<a> writeRecordBoundary ( ) ; </a> 0
<a> logger . appendKeyValue ( " " + key , "<Image>" ) ; </a> 0
<a> } </a> 0
<a> public void writeBytes ( String key , byte [ ] bytes ) throws IOException { </a> 0
<a> writeContentDisposition ( key , key , "content/unknown" ) ; </a> 0
<a> this . outputStream . write ( bytes ) ; </a> 0
<a> writeLine ( "" ) ; </a> 0
<a> writeRecordBoundary ( ) ; </a> 0
<a> logger . appendKeyValue ( " " + key , String . format ( "<Data: %d>" , bytes . length ) ) ; </a> 0
<a> } </a> 0
<a> public void writeFile ( String key , ParcelFileDescriptor descriptor ) throws IOException { </a> 0
<a> writeContentDisposition ( key , key , "content/unknown" ) ; </a> 0
<a> ParcelFileDescriptor . AutoCloseInputStream inputStream = null ; </a> 0
<a> BufferedInputStream bufferedInputStream = null ; </a> 0
<a> int totalBytes = 0 ; </a> 0
<a> try { </a> 0
<a> inputStream = new ParcelFileDescriptor . AutoCloseInputStream ( descriptor ) ; </a> 0
<a> bufferedInputStream = new BufferedInputStream ( inputStream ) ; </a> 0
<a> byte [ ] buffer = new byte [ 8192 ] ; </a> 0
<a> int bytesRead ; </a> 0
<a> while ( ( bytesRead = bufferedInputStream . read ( buffer ) ) != - 1 ) { </a> 0
<a> this . outputStream . write ( buffer , 0 , bytesRead ) ; </a> 0
<a> totalBytes += bytesRead ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> if ( bufferedInputStream != null ) { </a> 0
<a> bufferedInputStream . close ( ) ; </a> 0
<a> } </a> 0
<a> if ( inputStream != null ) { </a> 0
<a> inputStream . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> writeLine ( "" ) ; </a> 0
<a> writeRecordBoundary ( ) ; </a> 0
<a> logger . appendKeyValue ( " " + key , String . format ( "<Data: %d>" , totalBytes ) ) ; </a> 0
<a> } </a> 0
<a> public void writeRecordBoundary ( ) throws IOException { </a> 0
<a> writeLine ( "--%s" , MIME_BOUNDARY ) ; </a> 0
<a> } </a> 0
<a> public void writeContentDisposition ( String name , String filename , String contentType ) throws IOException { </a> 0
<a> write ( "Content-Disposition: form-data; name=\"%s\"" , name ) ; </a> 0
<a> if ( filename != null ) { </a> 0
<a> write ( "; filename=\"%s\"" , filename ) ; </a> 0
<a> } </a> 0
<a> writeLine ( "" ) ; </a> 0
<a> if ( contentType != null ) { </a> 0
<a> writeLine ( "%s: %s" , CONTENT_TYPE_HEADER , contentType ) ; </a> 0
<a> } </a> 0
<a> writeLine ( "" ) ; </a> 0
<a> } </a> 0
<a> public void write ( String format , Object ... args ) throws IOException { </a> 0
<a> if ( firstWrite ) { </a> 0
<a> this . outputStream . write ( "--" . getBytes ( ) ) ; </a> 0
<a> this . outputStream . write ( MIME_BOUNDARY . getBytes ( ) ) ; </a> 0
<a> this . outputStream . write ( "\r\n" . getBytes ( ) ) ; </a> 0
<a> firstWrite = false ; </a> 0
<a> } </a> 0
<a> this . outputStream . write ( String . format ( format , args ) . getBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> public void writeLine ( String format , Object ... args ) throws IOException { </a> 0
<a> write ( format , args ) ; </a> 0
<a> write ( "\r\n" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public interface Callback { </a> 0
<a> void onCompleted ( Response response ) ; </a> 0
<a> } </a> 0
<a> public interface GraphUserCallback { </a> 0
<a> void onCompleted ( GraphUser user , Response response ) ; </a> 0
<a> } </a> 0
<a> public interface GraphUserListCallback { </a> 0
<a> void onCompleted ( List < GraphUser > users , Response response ) ; </a> 0
<a> } </a> 0
<a> public interface GraphPlaceListCallback { </a> 0
<a> void onCompleted ( List < GraphPlace > places , Response response ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . annotation . TargetApi ; </a> 0
<a> import android . os . AsyncTask ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import java . lang . reflect . InvocationTargetException ; </a> 0
<a> import java . lang . reflect . Method ; </a> 0
<a> import java . net . HttpURLConnection ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . concurrent . Executor ; </a> 0
<a> @ TargetApi ( 3 ) </a> 0
<a> public class RequestAsyncTask extends AsyncTask < Void , Void , List < Response > > { </a> 0
<a> private static final String TAG = RequestAsyncTask . class . getCanonicalName ( ) ; </a> 0
<a> private static Method executeOnExecutorMethod ; </a> 0
<a> private final HttpURLConnection connection ; </a> 0
<a> private final RequestBatch requests ; </a> 0
<a> private Exception exception ; </a> 0
<a> static { </a> 0
<a> for ( Method method : AsyncTask . class . getMethods ( ) ) { </a> 0
<a> if ( "executeOnExecutor" . equals ( method . getName ( ) ) ) { </a> 0
<a> Class < ? > [ ] parameters = method . getParameterTypes ( ) ; </a> 0
<a> if ( ( parameters . length == 2 ) && ( parameters [ 0 ] == Executor . class ) && parameters [ 1 ] . isArray ( ) ) { </a> 0
<a> executeOnExecutorMethod = method ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public RequestAsyncTask ( Request ... requests ) { </a> 0
<a> this ( null , new RequestBatch ( requests ) ) ; </a> 0
<a> } </a> 0
<a> public RequestAsyncTask ( Collection < Request > requests ) { </a> 0
<a> this ( null , new RequestBatch ( requests ) ) ; </a> 0
<a> } </a> 0
<a> public RequestAsyncTask ( RequestBatch requests ) { </a> 0
<a> this ( null , requests ) ; </a> 0
<a> } </a> 0
<a> public RequestAsyncTask ( HttpURLConnection connection , Request ... requests ) { </a> 0
<a> this ( connection , new RequestBatch ( requests ) ) ; </a> 0
<a> } </a> 0
<a> public RequestAsyncTask ( HttpURLConnection connection , Collection < Request > requests ) { </a> 0
<a> this ( connection , new RequestBatch ( requests ) ) ; </a> 0
<a> } </a> 0
<a> public RequestAsyncTask ( HttpURLConnection connection , RequestBatch requests ) { </a> 0
<a> this . requests = requests ; </a> 0
<a> this . connection = connection ; </a> 0
<a> } </a> 0
<a> protected final Exception getException ( ) { </a> 0
<a> return exception ; </a> 0
<a> } </a> 0
<a> protected final RequestBatch getRequests ( ) { </a> 0
<a> return requests ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return new StringBuilder ( ) . append ( "{RequestAsyncTask: " ) . append ( " connection: " ) . append ( connection ) </a> 0
<a> . append ( ", requests: " ) . append ( requests ) . append ( "}" ) . toString ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onPreExecute ( ) { </a> 0
<a> super . onPreExecute ( ) ; </a> 0
<a> if ( requests . getCallbackHandler ( ) == null ) { </a> 0
<a> requests . setCallbackHandler ( new Handler ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onPostExecute ( List < Response > result ) { </a> 0
<a> super . onPostExecute ( result ) ; </a> 0
<a> if ( exception != null ) { </a> 0
<a> Log . d ( TAG , String . format ( "onPostExecute: exception encountered during request: %s" , exception . getMessage ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected List < Response > doInBackground ( Void ... params ) { </a> 0
<a> try { </a> 0
<a> if ( connection == null ) { </a> 0
<a> return requests . executeAndWait ( ) ; </a> 0
<a> } else { </a> 0
<a> return Request . executeConnectionAndWait ( connection , requests ) ; </a> 0
<a> } </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> exception = e ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> RequestAsyncTask executeOnSettingsExecutor ( ) { </a> 0
<a> try { </a> 0
<a> if ( executeOnExecutorMethod != null ) { </a> 0
<a> executeOnExecutorMethod . invoke ( this , Settings . getExecutor ( ) , null ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } catch ( InvocationTargetException e ) { </a> 0
<a> } catch ( IllegalAccessException e ) { </a> 0
<a> } </a> 0
<a> this . execute ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import java . util . * ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> public class RequestBatch extends AbstractList < Request > { </a> 0
<a> private static AtomicInteger idGenerator = new AtomicInteger ( ) ; </a> 0
<a> private Handler callbackHandler ; </a> 0
<a> private List < Request > requests = new ArrayList < Request > ( ) ; </a> 0
<a> private int timeoutInMilliseconds = 0 ; </a> 0
<a> private final String id = Integer . valueOf ( idGenerator . incrementAndGet ( ) ) . toString ( ) ; </a> 0
<a> private List < Callback > callbacks = new ArrayList < Callback > ( ) ; </a> 0
<a> private String batchApplicationId ; </a> 0
<a> public RequestBatch ( ) { </a> 0
<a> this . requests = new ArrayList < Request > ( ) ; </a> 0
<a> } </a> 0
<a> public RequestBatch ( Collection < Request > requests ) { </a> 0
<a> this . requests = new ArrayList < Request > ( requests ) ; </a> 0
<a> } </a> 0
<a> public RequestBatch ( Request ... requests ) { </a> 0
<a> this . requests = Arrays . asList ( requests ) ; </a> 0
<a> } </a> 0
<a> public RequestBatch ( RequestBatch requests ) { </a> 0
<a> this . requests = new ArrayList < Request > ( requests ) ; </a> 0
<a> this . callbackHandler = requests . callbackHandler ; </a> 0
<a> this . timeoutInMilliseconds = requests . timeoutInMilliseconds ; </a> 0
<a> this . callbacks = new ArrayList < Callback > ( requests . callbacks ) ; </a> 0
<a> } </a> 0
<a> public int getTimeout ( ) { </a> 0
<a> return timeoutInMilliseconds ; </a> 0
<a> } </a> 0
<a> public void setTimeout ( int timeoutInMilliseconds ) { </a> 0
<a> if ( timeoutInMilliseconds < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "Argument timeoutInMilliseconds must be >= 0." ) ; </a> 0
<a> } </a> 0
<a> this . timeoutInMilliseconds = timeoutInMilliseconds ; </a> 0
<a> } </a> 0
<a> public void addCallback ( Callback callback ) { </a> 0
<a> if ( ! callbacks . contains ( callback ) ) { </a> 0
<a> callbacks . add ( callback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void removeCallback ( Callback callback ) { </a> 0
<a> callbacks . remove ( callback ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final boolean add ( Request request ) { </a> 0
<a> return requests . add ( request ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void add ( int location , Request request ) { </a> 0
<a> requests . add ( location , request ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void clear ( ) { </a> 0
<a> requests . clear ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final Request get ( int i ) { </a> 0
<a> return requests . get ( i ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final Request remove ( int location ) { </a> 0
<a> return requests . remove ( location ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final Request set ( int location , Request request ) { </a> 0
<a> return requests . set ( location , request ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final int size ( ) { </a> 0
<a> return requests . size ( ) ; </a> 0
<a> } </a> 0
<a> final String getId ( ) { </a> 0
<a> return id ; </a> 0
<a> } </a> 0
<a> final Handler getCallbackHandler ( ) { </a> 0
<a> return callbackHandler ; </a> 0
<a> } </a> 0
<a> final void setCallbackHandler ( Handler callbackHandler ) { </a> 0
<a> this . callbackHandler = callbackHandler ; </a> 0
<a> } </a> 0
<a> final List < Request > getRequests ( ) { </a> 0
<a> return requests ; </a> 0
<a> } </a> 0
<a> final List < Callback > getCallbacks ( ) { </a> 0
<a> return callbacks ; </a> 0
<a> } </a> 0
<a> final String getBatchApplicationId ( ) { </a> 0
<a> return batchApplicationId ; </a> 0
<a> } </a> 0
<a> final void setBatchApplicationId ( String batchApplicationId ) { </a> 0
<a> this . batchApplicationId = batchApplicationId ; </a> 0
<a> } </a> 0
<a> public final List < Response > executeAndWait ( ) { </a> 0
<a> return executeAndWaitImpl ( ) ; </a> 0
<a> } </a> 0
<a> public final RequestAsyncTask executeAsync ( ) { </a> 0
<a> return executeAsyncImpl ( ) ; </a> 0
<a> } </a> 0
<a> public interface Callback { </a> 0
<a> void onBatchCompleted ( RequestBatch batch ) ; </a> 0
<a> } </a> 0
<a> List < Response > executeAndWaitImpl ( ) { </a> 0
<a> return Request . executeBatchAndWait ( this ) ; </a> 0
<a> } </a> 0
<a> RequestAsyncTask executeAsyncImpl ( ) { </a> 0
<a> return Request . executeBatchAsync ( this ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import com . facebook . internal . * ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import com . facebook . model . GraphObjectList ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import org . json . JSONTokener ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . net . HttpURLConnection ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> import java . net . URL ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class Response { </a> 0
<a> private final HttpURLConnection connection ; </a> 0
<a> private final GraphObject graphObject ; </a> 0
<a> private final GraphObjectList < GraphObject > graphObjectList ; </a> 0
<a> private final boolean isFromCache ; </a> 0
<a> private final FacebookRequestError error ; </a> 0
<a> private final Request request ; </a> 0
<a> public static final String NON_JSON_RESPONSE_PROPERTY = "FACEBOOK_NON_JSON_RESULT" ; </a> 0
<a> private static final int INVALID_SESSION_FACEBOOK_ERROR_CODE = 190 ; </a> 0
<a> private static final String CODE_KEY = "code" ; </a> 0
<a> private static final String BODY_KEY = "body" ; </a> 0
<a> private static final String RESPONSE_LOG_TAG = "Response" ; </a> 0
<a> private static final String RESPONSE_CACHE_TAG = "ResponseCache" ; </a> 0
<a> private static FileLruCache responseCache ; </a> 0
<a> Response ( Request request , HttpURLConnection connection , GraphObject graphObject , boolean isFromCache ) { </a> 0
<a> this . request = request ; </a> 0
<a> this . connection = connection ; </a> 0
<a> this . graphObject = graphObject ; </a> 0
<a> this . graphObjectList = null ; </a> 0
<a> this . isFromCache = isFromCache ; </a> 0
<a> this . error = null ; </a> 0
<a> } </a> 0
<a> Response ( Request request , HttpURLConnection connection , GraphObjectList < GraphObject > graphObjects , </a> 0
<a> boolean isFromCache ) { </a> 0
<a> this . request = request ; </a> 0
<a> this . connection = connection ; </a> 0
<a> this . graphObject = null ; </a> 0
<a> this . graphObjectList = graphObjects ; </a> 0
<a> this . isFromCache = isFromCache ; </a> 0
<a> this . error = null ; </a> 0
<a> } </a> 0
<a> Response ( Request request , HttpURLConnection connection , FacebookRequestError error ) { </a> 0
<a> this . request = request ; </a> 0
<a> this . connection = connection ; </a> 0
<a> this . graphObject = null ; </a> 0
<a> this . graphObjectList = null ; </a> 0
<a> this . isFromCache = false ; </a> 0
<a> this . error = error ; </a> 0
<a> } </a> 0
<a> public final FacebookRequestError getError ( ) { </a> 0
<a> return error ; </a> 0
<a> } </a> 0
<a> public final GraphObject getGraphObject ( ) { </a> 0
<a> return graphObject ; </a> 0
<a> } </a> 0
<a> public final < T extends GraphObject > T getGraphObjectAs ( Class < T > graphObjectClass ) { </a> 0
<a> if ( graphObject == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( graphObjectClass == null ) { </a> 0
<a> throw new NullPointerException ( "Must pass in a valid interface that extends GraphObject" ) ; </a> 0
<a> } </a> 0
<a> return graphObject . cast ( graphObjectClass ) ; </a> 0
<a> } </a> 0
<a> public final GraphObjectList < GraphObject > getGraphObjectList ( ) { </a> 0
<a> return graphObjectList ; </a> 0
<a> } </a> 0
<a> public final < T extends GraphObject > GraphObjectList < T > getGraphObjectListAs ( Class < T > graphObjectClass ) { </a> 0
<a> if ( graphObjectList == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return graphObjectList . castToListOf ( graphObjectClass ) ; </a> 0
<a> } </a> 0
<a> public final HttpURLConnection getConnection ( ) { </a> 0
<a> return connection ; </a> 0
<a> } </a> 0
<a> public Request getRequest ( ) { </a> 0
<a> return request ; </a> 0
<a> } </a> 0
<a> public enum PagingDirection { </a> 0
<a> NEXT , </a> 0
<a> PREVIOUS </a> 0
<a> } </a> 0
<a> public Request getRequestForPagedResults ( PagingDirection direction ) { </a> 0
<a> String link = null ; </a> 0
<a> if ( graphObject != null ) { </a> 0
<a> PagedResults pagedResults = graphObject . cast ( PagedResults . class ) ; </a> 0
<a> PagingInfo pagingInfo = pagedResults . getPaging ( ) ; </a> 0
<a> if ( pagingInfo != null ) { </a> 0
<a> if ( direction == PagingDirection . NEXT ) { </a> 0
<a> link = pagingInfo . getNext ( ) ; </a> 0
<a> } else { </a> 0
<a> link = pagingInfo . getPrevious ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( Utility . isNullOrEmpty ( link ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( link != null && link . equals ( request . getUrlForSingleRequest ( ) ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> Request pagingRequest ; </a> 0
<a> try { </a> 0
<a> pagingRequest = new Request ( request . getSession ( ) , new URL ( link ) ) ; </a> 0
<a> } catch ( MalformedURLException e ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return pagingRequest ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> String responseCode ; </a> 0
<a> try { </a> 0
<a> responseCode = String . format ( "%d" , ( connection != null ) ? connection . getResponseCode ( ) : 200 ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> responseCode = "unknown" ; </a> 0
<a> } </a> 0
<a> return new StringBuilder ( ) . append ( "{Response: " ) . append ( " responseCode: " ) . append ( responseCode ) </a> 0
<a> . append ( ", graphObject: " ) . append ( graphObject ) . append ( ", error: " ) . append ( error ) </a> 0
<a> . append ( ", isFromCache:" ) . append ( isFromCache ) . append ( "}" ) </a> 0
<a> . toString ( ) ; </a> 0
<a> } </a> 0
<a> public final boolean getIsFromCache ( ) { </a> 0
<a> return isFromCache ; </a> 0
<a> } </a> 0
<a> static FileLruCache getResponseCache ( ) { </a> 0
<a> if ( responseCache == null ) { </a> 0
<a> Context applicationContext = Session . getStaticContext ( ) ; </a> 0
<a> if ( applicationContext != null ) { </a> 0
<a> responseCache = new FileLruCache ( applicationContext , RESPONSE_CACHE_TAG , new FileLruCache . Limits ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return responseCache ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "resource" ) </a> 0
<a> static List < Response > fromHttpConnection ( HttpURLConnection connection , RequestBatch requests ) { </a> 0
<a> InputStream stream = null ; </a> 0
<a> FileLruCache cache = null ; </a> 0
<a> String cacheKey = null ; </a> 0
<a> if ( requests instanceof CacheableRequestBatch ) { </a> 0
<a> CacheableRequestBatch cacheableRequestBatch = ( CacheableRequestBatch ) requests ; </a> 0
<a> cache = getResponseCache ( ) ; </a> 0
<a> cacheKey = cacheableRequestBatch . getCacheKeyOverride ( ) ; </a> 0
<a> if ( Utility . isNullOrEmpty ( cacheKey ) ) { </a> 0
<a> if ( requests . size ( ) == 1 ) { </a> 0
<a> cacheKey = requests . get ( 0 ) . getUrlForSingleRequest ( ) ; </a> 0
<a> } else { </a> 0
<a> Logger . log ( LoggingBehavior . REQUESTS , RESPONSE_CACHE_TAG , </a> 0
<a> "Not using cache for cacheable request because no key was specified" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! cacheableRequestBatch . getForceRoundTrip ( ) && cache != null && ! Utility . isNullOrEmpty ( cacheKey ) ) { </a> 0
<a> try { </a> 0
<a> stream = cache . get ( cacheKey ) ; </a> 0
<a> if ( stream != null ) { </a> 0
<a> return createResponsesFromStream ( stream , null , requests , true ) ; </a> 0
<a> } </a> 0
<a> } catch ( FacebookException exception ) { </a> 0
<a> } catch ( JSONException exception ) { </a> 0
<a> } catch ( IOException exception ) { </a> 0
<a> } finally { </a> 0
<a> Utility . closeQuietly ( stream ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> if ( connection . getResponseCode ( ) >= 400 ) { </a> 0
<a> stream = connection . getErrorStream ( ) ; </a> 0
<a> } else { </a> 0
<a> stream = connection . getInputStream ( ) ; </a> 0
<a> if ( ( cache != null ) && ( cacheKey != null ) && ( stream != null ) ) { </a> 0
<a> InputStream interceptStream = cache . interceptAndPut ( cacheKey , stream ) ; </a> 0
<a> if ( interceptStream != null ) { </a> 0
<a> stream = interceptStream ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return createResponsesFromStream ( stream , connection , requests , false ) ; </a> 0
<a> } catch ( FacebookException facebookException ) { </a> 0
<a> Logger . log ( LoggingBehavior . REQUESTS , RESPONSE_LOG_TAG , "Response <Error>: %s" , facebookException ) ; </a> 0
<a> return constructErrorResponses ( requests , connection , facebookException ) ; </a> 0
<a> } catch ( JSONException exception ) { </a> 0
<a> Logger . log ( LoggingBehavior . REQUESTS , RESPONSE_LOG_TAG , "Response <Error>: %s" , exception ) ; </a> 0
<a> return constructErrorResponses ( requests , connection , new FacebookException ( exception ) ) ; </a> 0
<a> } catch ( IOException exception ) { </a> 0
<a> Logger . log ( LoggingBehavior . REQUESTS , RESPONSE_LOG_TAG , "Response <Error>: %s" , exception ) ; </a> 0
<a> return constructErrorResponses ( requests , connection , new FacebookException ( exception ) ) ; </a> 0
<a> } finally { </a> 0
<a> Utility . closeQuietly ( stream ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static List < Response > createResponsesFromStream ( InputStream stream , HttpURLConnection connection , </a> 0
<a> RequestBatch requests , boolean isFromCache ) throws FacebookException , JSONException , IOException { </a> 0
<a> String responseString = Utility . readStreamToString ( stream ) ; </a> 0
<a> Logger . log ( LoggingBehavior . INCLUDE_RAW_RESPONSES , RESPONSE_LOG_TAG , </a> 0
<a> "Response (raw)\n Size: %d\n Response:\n%s\n" , responseString . length ( ) , </a> 0
<a> responseString ) ; </a> 0
<a> JSONTokener tokener = new JSONTokener ( responseString ) ; </a> 0
<a> Object resultObject = tokener . nextValue ( ) ; </a> 0
<a> List < Response > responses = createResponsesFromObject ( connection , requests , resultObject , isFromCache ) ; </a> 0
<a> Logger . log ( LoggingBehavior . REQUESTS , RESPONSE_LOG_TAG , "Response\n Id: %s\n Size: %d\n Responses:\n%s\n" , </a> 0
<a> requests . getId ( ) , responseString . length ( ) , responses ) ; </a> 0
<a> return responses ; </a> 0
<a> } </a> 0
<a> private static List < Response > createResponsesFromObject ( HttpURLConnection connection , List < Request > requests , </a> 0
<a> Object object , boolean isFromCache ) throws FacebookException , JSONException { </a> 0
<a> assert ( connection != null ) || isFromCache ; </a> 0
<a> int numRequests = requests . size ( ) ; </a> 0
<a> List < Response > responses = new ArrayList < Response > ( numRequests ) ; </a> 0
<a> Object originalResult = object ; </a> 0
<a> if ( numRequests == 1 ) { </a> 0
<a> Request request = requests . get ( 0 ) ; </a> 0
<a> try { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( BODY_KEY , object ) ; </a> 0
<a> int responseCode = ( connection != null ) ? connection . getResponseCode ( ) : 200 ; </a> 0
<a> jsonObject . put ( CODE_KEY , responseCode ) ; </a> 0
<a> JSONArray jsonArray = new JSONArray ( ) ; </a> 0
<a> jsonArray . put ( jsonObject ) ; </a> 0
<a> object = jsonArray ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> responses . add ( new Response ( request , connection , new FacebookRequestError ( connection , e ) ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> responses . add ( new Response ( request , connection , new FacebookRequestError ( connection , e ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! ( object instanceof JSONArray ) || ( ( JSONArray ) object ) . length ( ) != numRequests ) { </a> 0
<a> FacebookException exception = new FacebookException ( "Unexpected number of results" ) ; </a> 0
<a> throw exception ; </a> 0
<a> } </a> 0
<a> JSONArray jsonArray = ( JSONArray ) object ; </a> 0
<a> for ( int i = 0 ; i < jsonArray . length ( ) ; ++ i ) { </a> 0
<a> Request request = requests . get ( i ) ; </a> 0
<a> try { </a> 0
<a> Object obj = jsonArray . get ( i ) ; </a> 0
<a> responses . add ( createResponseFromObject ( request , connection , obj , isFromCache , originalResult ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> responses . add ( new Response ( request , connection , new FacebookRequestError ( connection , e ) ) ) ; </a> 0
<a> } catch ( FacebookException e ) { </a> 0
<a> responses . add ( new Response ( request , connection , new FacebookRequestError ( connection , e ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return responses ; </a> 0
<a> } </a> 0
<a> private static Response createResponseFromObject ( Request request , HttpURLConnection connection , Object object , </a> 0
<a> boolean isFromCache , Object originalResult ) throws JSONException { </a> 0
<a> if ( object instanceof JSONObject ) { </a> 0
<a> JSONObject jsonObject = ( JSONObject ) object ; </a> 0
<a> FacebookRequestError error = </a> 0
<a> FacebookRequestError . checkResponseAndCreateError ( jsonObject , originalResult , connection ) ; </a> 0
<a> if ( error != null ) { </a> 0
<a> if ( error . getErrorCode ( ) == INVALID_SESSION_FACEBOOK_ERROR_CODE ) { </a> 0
<a> Session session = request . getSession ( ) ; </a> 0
<a> if ( session != null ) { </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return new Response ( request , connection , error ) ; </a> 0
<a> } </a> 0
<a> Object body = Utility . getStringPropertyAsJSON ( jsonObject , BODY_KEY , NON_JSON_RESPONSE_PROPERTY ) ; </a> 0
<a> if ( body instanceof JSONObject ) { </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( ( JSONObject ) body ) ; </a> 0
<a> return new Response ( request , connection , graphObject , isFromCache ) ; </a> 0
<a> } else if ( body instanceof JSONArray ) { </a> 0
<a> GraphObjectList < GraphObject > graphObjectList = GraphObject . Factory . createList ( </a> 0
<a> ( JSONArray ) body , GraphObject . class ) ; </a> 0
<a> return new Response ( request , connection , graphObjectList , isFromCache ) ; </a> 0
<a> } </a> 0
<a> object = JSONObject . NULL ; </a> 0
<a> } </a> 0
<a> if ( object == JSONObject . NULL ) { </a> 0
<a> return new Response ( request , connection , ( GraphObject ) null , isFromCache ) ; </a> 0
<a> } else { </a> 0
<a> throw new FacebookException ( "Got unexpected object type in response, class: " </a> 0
<a> + object . getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static List < Response > constructErrorResponses ( List < Request > requests , HttpURLConnection connection , </a> 0
<a> FacebookException error ) { </a> 0
<a> int count = requests . size ( ) ; </a> 0
<a> List < Response > responses = new ArrayList < Response > ( count ) ; </a> 0
<a> for ( int i = 0 ; i < count ; ++ i ) { </a> 0
<a> Response response = new Response ( requests . get ( i ) , connection , new FacebookRequestError ( connection , error ) ) ; </a> 0
<a> responses . add ( response ) ; </a> 0
<a> } </a> 0
<a> return responses ; </a> 0
<a> } </a> 0
<a> interface PagingInfo extends GraphObject { </a> 0
<a> String getNext ( ) ; </a> 0
<a> String getPrevious ( ) ; </a> 0
<a> } </a> 0
<a> interface PagedResults extends GraphObject { </a> 0
<a> GraphObjectList < GraphObject > getData ( ) ; </a> 0
<a> PagingInfo getPaging ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . * ; </a> 0
<a> import android . content . pm . ResolveInfo ; </a> 0
<a> import android . os . * ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . support . v4 . content . LocalBroadcastManager ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import com . facebook . internal . SessionAuthorizationType ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import com . facebook . internal . Validate ; </a> 0
<a> import java . io . * ; </a> 0
<a> import java . lang . ref . WeakReference ; </a> 0
<a> import java . util . * ; </a> 0
<a> public class Session implements Serializable { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> public static final String TAG = Session . class . getCanonicalName ( ) ; </a> 0
<a> public static final int DEFAULT_AUTHORIZE_ACTIVITY_CODE = 0xface ; </a> 0
<a> public static final String WEB_VIEW_ERROR_CODE_KEY = "com.facebook.sdk.WebViewErrorCode" ; </a> 0
<a> public static final String WEB_VIEW_FAILING_URL_KEY = "com.facebook.sdk.FailingUrl" ; </a> 0
<a> public static final String ACTION_ACTIVE_SESSION_SET = "com.facebook.sdk.ACTIVE_SESSION_SET" ; </a> 0
<a> public static final String ACTION_ACTIVE_SESSION_UNSET = "com.facebook.sdk.ACTIVE_SESSION_UNSET" ; </a> 0
<a> public static final String ACTION_ACTIVE_SESSION_OPENED = "com.facebook.sdk.ACTIVE_SESSION_OPENED" ; </a> 0
<a> public static final String ACTION_ACTIVE_SESSION_CLOSED = "com.facebook.sdk.ACTIVE_SESSION_CLOSED" ; </a> 0
<a> public static final String APPLICATION_ID_PROPERTY = "com.facebook.sdk.ApplicationId" ; </a> 0
<a> private static final Object STATIC_LOCK = new Object ( ) ; </a> 0
<a> private static Session activeSession ; </a> 0
<a> private static volatile Context staticContext ; </a> 0
<a> private static final int TOKEN_EXTEND_THRESHOLD_SECONDS = 24 * 60 * 60 ; </a> 0
<a> private static final int TOKEN_EXTEND_RETRY_SECONDS = 60 * 60 ; </a> 0
<a> private static final String SESSION_BUNDLE_SAVE_KEY = "com.facebook.sdk.Session.saveSessionKey" ; </a> 0
<a> private static final String AUTH_BUNDLE_SAVE_KEY = "com.facebook.sdk.Session.authBundleKey" ; </a> 0
<a> private static final String PUBLISH_PERMISSION_PREFIX = "publish" ; </a> 0
<a> private static final String MANAGE_PERMISSION_PREFIX = "manage" ; </a> 0
<a> @ SuppressWarnings ( "serial" ) </a> 0
<a> private static final Set < String > OTHER_PUBLISH_PERMISSIONS = new HashSet < String > ( ) { { </a> 0
<a> add ( "ads_management" ) ; </a> 0
<a> add ( "create_event" ) ; </a> 0
<a> add ( "rsvp_event" ) ; </a> 0
<a> } } ; </a> 0
<a> private String applicationId ; </a> 0
<a> private SessionState state ; </a> 0
<a> private AccessToken tokenInfo ; </a> 0
<a> private Date lastAttemptedTokenExtendDate = new Date ( 0 ) ; </a> 0
<a> private AuthorizationRequest pendingRequest ; </a> 0
<a> private AuthorizationClient authorizationClient ; </a> 0
<a> private volatile Bundle authorizationBundle ; </a> 0
<a> private final List < StatusCallback > callbacks ; </a> 0
<a> private Handler handler ; </a> 0
<a> private AutoPublishAsyncTask autoPublishAsyncTask ; </a> 0
<a> private final Object lock = new Object ( ) ; </a> 0
<a> private TokenCachingStrategy tokenCachingStrategy ; </a> 0
<a> private volatile TokenRefreshRequest currentTokenRefreshRequest ; </a> 0
<a> private static class SerializationProxyV1 implements Serializable { </a> 0
<a> private static final long serialVersionUID = 7663436173185080063L ; </a> 0
<a> private final String applicationId ; </a> 0
<a> private final SessionState state ; </a> 0
<a> private final AccessToken tokenInfo ; </a> 0
<a> private final Date lastAttemptedTokenExtendDate ; </a> 0
<a> private final boolean shouldAutoPublish ; </a> 0
<a> private final AuthorizationRequest pendingRequest ; </a> 0
<a> SerializationProxyV1 ( String applicationId , SessionState state , </a> 0
<a> AccessToken tokenInfo , Date lastAttemptedTokenExtendDate , </a> 0
<a> boolean shouldAutoPublish , AuthorizationRequest pendingRequest ) { </a> 0
<a> this . applicationId = applicationId ; </a> 0
<a> this . state = state ; </a> 0
<a> this . tokenInfo = tokenInfo ; </a> 0
<a> this . lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate ; </a> 0
<a> this . shouldAutoPublish = shouldAutoPublish ; </a> 0
<a> this . pendingRequest = pendingRequest ; </a> 0
<a> } </a> 0
<a> private Object readResolve ( ) { </a> 0
<a> return new Session ( applicationId , state , tokenInfo , </a> 0
<a> lastAttemptedTokenExtendDate , shouldAutoPublish , pendingRequest ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private Session ( String applicationId , SessionState state , </a> 0
<a> AccessToken tokenInfo , Date lastAttemptedTokenExtendDate , </a> 0
<a> boolean shouldAutoPublish , AuthorizationRequest pendingRequest ) { </a> 0
<a> this . applicationId = applicationId ; </a> 0
<a> this . state = state ; </a> 0
<a> this . tokenInfo = tokenInfo ; </a> 0
<a> this . lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate ; </a> 0
<a> this . pendingRequest = pendingRequest ; </a> 0
<a> handler = new Handler ( Looper . getMainLooper ( ) ) ; </a> 0
<a> currentTokenRefreshRequest = null ; </a> 0
<a> tokenCachingStrategy = null ; </a> 0
<a> callbacks = new ArrayList < StatusCallback > ( ) ; </a> 0
<a> } </a> 0
<a> public Session ( Context currentContext ) { </a> 0
<a> this ( currentContext , null , null , true ) ; </a> 0
<a> } </a> 0
<a> Session ( Context context , String applicationId , TokenCachingStrategy tokenCachingStrategy ) { </a> 0
<a> this ( context , applicationId , tokenCachingStrategy , true ) ; </a> 0
<a> } </a> 0
<a> Session ( Context context , String applicationId , TokenCachingStrategy tokenCachingStrategy , </a> 0
<a> boolean loadTokenFromCache ) { </a> 0
<a> if ( ( context != null ) && ( applicationId == null ) ) { </a> 0
<a> applicationId = Utility . getMetadataApplicationId ( context ) ; </a> 0
<a> } </a> 0
<a> Validate . notNull ( applicationId , "applicationId" ) ; </a> 0
<a> initializeStaticContext ( context ) ; </a> 0
<a> if ( tokenCachingStrategy == null ) { </a> 0
<a> tokenCachingStrategy = new SharedPreferencesTokenCachingStrategy ( staticContext ) ; </a> 0
<a> } </a> 0
<a> this . applicationId = applicationId ; </a> 0
<a> this . tokenCachingStrategy = tokenCachingStrategy ; </a> 0
<a> this . state = SessionState . CREATED ; </a> 0
<a> this . pendingRequest = null ; </a> 0
<a> this . callbacks = new ArrayList < StatusCallback > ( ) ; </a> 0
<a> this . handler = new Handler ( Looper . getMainLooper ( ) ) ; </a> 0
<a> Bundle tokenState = loadTokenFromCache ? tokenCachingStrategy . load ( ) : null ; </a> 0
<a> if ( TokenCachingStrategy . hasTokenInformation ( tokenState ) ) { </a> 0
<a> Date cachedExpirationDate = TokenCachingStrategy </a> 0
<a> . getDate ( tokenState , TokenCachingStrategy . EXPIRATION_DATE_KEY ) ; </a> 0
<a> Date now = new Date ( ) ; </a> 0
<a> if ( ( cachedExpirationDate == null ) || cachedExpirationDate . before ( now ) ) { </a> 0
<a> tokenCachingStrategy . clear ( ) ; </a> 0
<a> this . tokenInfo = AccessToken . createEmptyToken ( Collections . < String > emptyList ( ) ) ; </a> 0
<a> } else { </a> 0
<a> this . tokenInfo = AccessToken . createFromCache ( tokenState ) ; </a> 0
<a> this . state = SessionState . CREATED_TOKEN_LOADED ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> this . tokenInfo = AccessToken . createEmptyToken ( Collections . < String > emptyList ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public final Bundle getAuthorizationBundle ( ) { </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> return this . authorizationBundle ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public final boolean isOpened ( ) { </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> return this . state . isOpened ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public final boolean isClosed ( ) { </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> return this . state . isClosed ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public final SessionState getState ( ) { </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> return this . state ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public final String getApplicationId ( ) { </a> 0
<a> return this . applicationId ; </a> 0
<a> } </a> 0
<a> public final String getAccessToken ( ) { </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> return ( this . tokenInfo == null ) ? null : this . tokenInfo . getToken ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public final Date getExpirationDate ( ) { </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> return ( this . tokenInfo == null ) ? null : this . tokenInfo . getExpires ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public final List < String > getPermissions ( ) { </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> return ( this . tokenInfo == null ) ? null : this . tokenInfo . getPermissions ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public final void openForRead ( OpenRequest openRequest ) { </a> 0
<a> open ( openRequest , SessionAuthorizationType . READ ) ; </a> 0
<a> } </a> 0
<a> public final void openForPublish ( OpenRequest openRequest ) { </a> 0
<a> open ( openRequest , SessionAuthorizationType . PUBLISH ) ; </a> 0
<a> } </a> 0
<a> public final void open ( AccessToken accessToken , StatusCallback callback ) { </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> if ( pendingRequest != null ) { </a> 0
<a> throw new UnsupportedOperationException ( </a> 0
<a> "Session: an attempt was made to open a session that has a pending request." ) ; </a> 0
<a> } </a> 0
<a> if ( state != SessionState . CREATED && state != SessionState . CREATED_TOKEN_LOADED ) { </a> 0
<a> throw new UnsupportedOperationException ( </a> 0
<a> "Session: an attempt was made to open an already opened session." ) ; </a> 0
<a> } </a> 0
<a> if ( callback != null ) { </a> 0
<a> addCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> this . tokenInfo = accessToken ; </a> 0
<a> if ( this . tokenCachingStrategy != null ) { </a> 0
<a> this . tokenCachingStrategy . save ( accessToken . toCacheBundle ( ) ) ; </a> 0
<a> } </a> 0
<a> final SessionState oldState = state ; </a> 0
<a> state = SessionState . OPENED ; </a> 0
<a> this . postStateChange ( oldState , state , null ) ; </a> 0
<a> } </a> 0
<a> autoPublishAsync ( ) ; </a> 0
<a> } </a> 0
<a> public final void requestNewReadPermissions ( NewPermissionsRequest newPermissionsRequest ) { </a> 0
<a> requestNewPermissions ( newPermissionsRequest , SessionAuthorizationType . READ ) ; </a> 0
<a> } </a> 0
<a> public final void requestNewPublishPermissions ( NewPermissionsRequest newPermissionsRequest ) { </a> 0
<a> requestNewPermissions ( newPermissionsRequest , SessionAuthorizationType . PUBLISH ) ; </a> 0
<a> } </a> 0
<a> public final boolean onActivityResult ( Activity currentActivity , int requestCode , int resultCode , Intent data ) { </a> 0
<a> Validate . notNull ( currentActivity , "currentActivity" ) ; </a> 0
<a> initializeStaticContext ( currentActivity ) ; </a> 0
<a> synchronized ( lock ) { </a> 0
<a> if ( pendingRequest == null || ( requestCode != pendingRequest . getRequestCode ( ) ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> AccessToken newToken = null ; </a> 0
<a> Exception exception = null ; </a> 0
<a> if ( data != null ) { </a> 0
<a> AuthorizationClient . Result result = ( AuthorizationClient . Result ) data . getSerializableExtra ( </a> 0
<a> LoginActivity . RESULT_KEY ) ; </a> 0
<a> if ( result != null ) { </a> 0
<a> handleAuthorizationResult ( resultCode , result ) ; </a> 0
<a> return true ; </a> 0
<a> } else if ( authorizationClient != null ) { </a> 0
<a> authorizationClient . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } else if ( resultCode == Activity . RESULT_CANCELED ) { </a> 0
<a> exception = new FacebookOperationCanceledException ( "User canceled operation." ) ; </a> 0
<a> } </a> 0
<a> finishAuthOrReauth ( newToken , exception ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "incomplete-switch" ) </a> 0
<a> public final void close ( ) { </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> final SessionState oldState = this . state ; </a> 0
<a> switch ( this . state ) { </a> 0
<a> case CREATED : </a> 0
<a> case OPENING : </a> 0
<a> this . state = SessionState . CLOSED_LOGIN_FAILED ; </a> 0
<a> postStateChange ( oldState , this . state , new FacebookException ( </a> 0
<a> "Log in attempt aborted." ) ) ; </a> 0
<a> break ; </a> 0
<a> case CREATED_TOKEN_LOADED : </a> 0
<a> case OPENED : </a> 0
<a> case OPENED_TOKEN_UPDATED : </a> 0
<a> this . state = SessionState . CLOSED ; </a> 0
<a> postStateChange ( oldState , this . state , null ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public final void closeAndClearTokenInformation ( ) { </a> 0
<a> if ( this . tokenCachingStrategy != null ) { </a> 0
<a> this . tokenCachingStrategy . clear ( ) ; </a> 0
<a> } </a> 0
<a> Utility . clearFacebookCookies ( staticContext ) ; </a> 0
<a> close ( ) ; </a> 0
<a> } </a> 0
<a> public final void addCallback ( StatusCallback callback ) { </a> 0
<a> synchronized ( callbacks ) { </a> 0
<a> if ( callback != null && ! callbacks . contains ( callback ) ) { </a> 0
<a> callbacks . add ( callback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public final void removeCallback ( StatusCallback callback ) { </a> 0
<a> synchronized ( callbacks ) { </a> 0
<a> callbacks . remove ( callback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return new StringBuilder ( ) . append ( "{Session" ) . append ( " state:" ) . append ( this . state ) . append ( ", token:" ) </a> 0
<a> . append ( ( this . tokenInfo == null ) ? "null" : this . tokenInfo ) . append ( ", appId:" ) </a> 0
<a> . append ( ( this . applicationId == null ) ? "null" : this . applicationId ) . append ( "}" ) . toString ( ) ; </a> 0
<a> } </a> 0
<a> void extendTokenCompleted ( Bundle bundle ) { </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> final SessionState oldState = this . state ; </a> 0
<a> switch ( this . state ) { </a> 0
<a> case OPENED : </a> 0
<a> this . state = SessionState . OPENED_TOKEN_UPDATED ; </a> 0
<a> postStateChange ( oldState , this . state , null ) ; </a> 0
<a> break ; </a> 0
<a> case OPENED_TOKEN_UPDATED : </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> Log . d ( TAG , "refreshToken ignored in state " + this . state ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> this . tokenInfo = AccessToken . createFromRefresh ( this . tokenInfo , bundle ) ; </a> 0
<a> if ( this . tokenCachingStrategy != null ) { </a> 0
<a> this . tokenCachingStrategy . save ( this . tokenInfo . toCacheBundle ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private Object writeReplace ( ) { </a> 0
<a> return new SerializationProxyV1 ( applicationId , state , tokenInfo , </a> 0
<a> lastAttemptedTokenExtendDate , false , pendingRequest ) ; </a> 0
<a> } </a> 0
<a> private void readObject ( ObjectInputStream stream ) throws InvalidObjectException { </a> 0
<a> throw new InvalidObjectException ( "Cannot readObject, serialization proxy required" ) ; </a> 0
<a> } </a> 0
<a> public static final void saveSession ( Session session , Bundle bundle ) { </a> 0
<a> if ( bundle != null && session != null && ! bundle . containsKey ( SESSION_BUNDLE_SAVE_KEY ) ) { </a> 0
<a> ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; </a> 0
<a> try { </a> 0
<a> new ObjectOutputStream ( outputStream ) . writeObject ( session ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new FacebookException ( "Unable to save session." , e ) ; </a> 0
<a> } </a> 0
<a> bundle . putByteArray ( SESSION_BUNDLE_SAVE_KEY , outputStream . toByteArray ( ) ) ; </a> 0
<a> bundle . putBundle ( AUTH_BUNDLE_SAVE_KEY , session . authorizationBundle ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final Session restoreSession ( </a> 0
<a> Context context , TokenCachingStrategy cachingStrategy , StatusCallback callback , Bundle bundle ) { </a> 0
<a> if ( bundle == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> byte [ ] data = bundle . getByteArray ( SESSION_BUNDLE_SAVE_KEY ) ; </a> 0
<a> if ( data != null ) { </a> 0
<a> ByteArrayInputStream is = new ByteArrayInputStream ( data ) ; </a> 0
<a> try { </a> 0
<a> Session session = ( Session ) ( new ObjectInputStream ( is ) ) . readObject ( ) ; </a> 0
<a> initializeStaticContext ( context ) ; </a> 0
<a> if ( cachingStrategy != null ) { </a> 0
<a> session . tokenCachingStrategy = cachingStrategy ; </a> 0
<a> } else { </a> 0
<a> session . tokenCachingStrategy = new SharedPreferencesTokenCachingStrategy ( context ) ; </a> 0
<a> } </a> 0
<a> if ( callback != null ) { </a> 0
<a> session . addCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> session . authorizationBundle = bundle . getBundle ( AUTH_BUNDLE_SAVE_KEY ) ; </a> 0
<a> return session ; </a> 0
<a> } catch ( ClassNotFoundException e ) { </a> 0
<a> Log . w ( TAG , "Unable to restore session" , e ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> Log . w ( TAG , "Unable to restore session." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public static final Session getActiveSession ( ) { </a> 0
<a> synchronized ( Session . STATIC_LOCK ) { </a> 0
<a> return Session . activeSession ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final void setActiveSession ( Session session ) { </a> 0
<a> synchronized ( Session . STATIC_LOCK ) { </a> 0
<a> if ( session != Session . activeSession ) { </a> 0
<a> Session oldSession = Session . activeSession ; </a> 0
<a> if ( oldSession != null ) { </a> 0
<a> oldSession . close ( ) ; </a> 0
<a> } </a> 0
<a> Session . activeSession = session ; </a> 0
<a> if ( oldSession != null ) { </a> 0
<a> postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_UNSET ) ; </a> 0
<a> } </a> 0
<a> if ( session != null ) { </a> 0
<a> postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_SET ) ; </a> 0
<a> if ( session . isOpened ( ) ) { </a> 0
<a> postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_OPENED ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static Session openActiveSessionFromCache ( Context context ) { </a> 0
<a> return openActiveSession ( context , false , null ) ; </a> 0
<a> } </a> 0
<a> public static Session openActiveSession ( Activity activity , boolean allowLoginUI , </a> 0
<a> StatusCallback callback ) { </a> 0
<a> return openActiveSession ( activity , allowLoginUI , new OpenRequest ( activity ) . setCallback ( callback ) ) ; </a> 0
<a> } </a> 0
<a> public static Session openActiveSession ( Context context , Fragment fragment , </a> 0
<a> boolean allowLoginUI , StatusCallback callback ) { </a> 0
<a> return openActiveSession ( context , allowLoginUI , new OpenRequest ( fragment ) . setCallback ( callback ) ) ; </a> 0
<a> } </a> 0
<a> public static Session openActiveSessionWithAccessToken ( Context context , AccessToken accessToken , </a> 0
<a> StatusCallback callback ) { </a> 0
<a> Session session = new Session ( context , null , null , false ) ; </a> 0
<a> setActiveSession ( session ) ; </a> 0
<a> session . open ( accessToken , callback ) ; </a> 0
<a> return session ; </a> 0
<a> } </a> 0
<a> private static Session openActiveSession ( Context context , boolean allowLoginUI , OpenRequest openRequest ) { </a> 0
<a> Session session = new Builder ( context ) . build ( ) ; </a> 0
<a> if ( SessionState . CREATED_TOKEN_LOADED . equals ( session . getState ( ) ) || allowLoginUI ) { </a> 0
<a> setActiveSession ( session ) ; </a> 0
<a> session . openForRead ( openRequest ) ; </a> 0
<a> return session ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> static Context getStaticContext ( ) { </a> 0
<a> return staticContext ; </a> 0
<a> } </a> 0
<a> static void initializeStaticContext ( Context currentContext ) { </a> 0
<a> if ( ( currentContext != null ) && ( staticContext == null ) ) { </a> 0
<a> Context applicationContext = currentContext . getApplicationContext ( ) ; </a> 0
<a> staticContext = ( applicationContext != null ) ? applicationContext : currentContext ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void authorize ( AuthorizationRequest request ) { </a> 0
<a> boolean started = false ; </a> 0
<a> request . setApplicationId ( applicationId ) ; </a> 0
<a> autoPublishAsync ( ) ; </a> 0
<a> started = tryLoginActivity ( request ) ; </a> 0
<a> if ( ! started && request . isLegacy ) { </a> 0
<a> started = tryLegacyAuth ( request ) ; </a> 0
<a> } </a> 0
<a> if ( ! started ) { </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> final SessionState oldState = this . state ; </a> 0
<a> switch ( this . state ) { </a> 0
<a> case CLOSED : </a> 0
<a> case CLOSED_LOGIN_FAILED : </a> 0
<a> return ; </a> 0
<a> default : </a> 0
<a> this . state = SessionState . CLOSED_LOGIN_FAILED ; </a> 0
<a> postStateChange ( oldState , this . state , new FacebookException ( "Log in attempt failed." ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void open ( OpenRequest openRequest , SessionAuthorizationType authType ) { </a> 0
<a> validatePermissions ( openRequest , authType ) ; </a> 0
<a> validateLoginBehavior ( openRequest ) ; </a> 0
<a> SessionState newState ; </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> if ( pendingRequest != null ) { </a> 0
<a> postStateChange ( state , state , new UnsupportedOperationException ( </a> 0
<a> "Session: an attempt was made to open a session that has a pending request." ) ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> final SessionState oldState = this . state ; </a> 0
<a> switch ( this . state ) { </a> 0
<a> case CREATED : </a> 0
<a> this . state = newState = SessionState . OPENING ; </a> 0
<a> if ( openRequest == null ) { </a> 0
<a> throw new IllegalArgumentException ( "openRequest cannot be null when opening a new Session" ) ; </a> 0
<a> } </a> 0
<a> pendingRequest = openRequest ; </a> 0
<a> break ; </a> 0
<a> case CREATED_TOKEN_LOADED : </a> 0
<a> if ( openRequest != null && ! Utility . isNullOrEmpty ( openRequest . getPermissions ( ) ) ) { </a> 0
<a> if ( ! Utility . isSubset ( openRequest . getPermissions ( ) , getPermissions ( ) ) ) { </a> 0
<a> pendingRequest = openRequest ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( pendingRequest == null ) { </a> 0
<a> this . state = newState = SessionState . OPENED ; </a> 0
<a> } else { </a> 0
<a> this . state = newState = SessionState . OPENING ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new UnsupportedOperationException ( </a> 0
<a> "Session: an attempt was made to open an already opened session." ) ; </a> 0
<a> } </a> 0
<a> if ( openRequest != null ) { </a> 0
<a> addCallback ( openRequest . getCallback ( ) ) ; </a> 0
<a> } </a> 0
<a> this . postStateChange ( oldState , newState , null ) ; </a> 0
<a> } </a> 0
<a> if ( newState == SessionState . OPENING ) { </a> 0
<a> authorize ( openRequest ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void requestNewPermissions ( NewPermissionsRequest newPermissionsRequest , SessionAuthorizationType authType ) { </a> 0
<a> validatePermissions ( newPermissionsRequest , authType ) ; </a> 0
<a> validateLoginBehavior ( newPermissionsRequest ) ; </a> 0
<a> if ( newPermissionsRequest != null ) { </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> if ( pendingRequest != null ) { </a> 0
<a> throw new UnsupportedOperationException ( </a> 0
<a> "Session: an attempt was made to request new permissions for a session that has a pending request." ) ; </a> 0
<a> } </a> 0
<a> switch ( this . state ) { </a> 0
<a> case OPENED : </a> 0
<a> case OPENED_TOKEN_UPDATED : </a> 0
<a> pendingRequest = newPermissionsRequest ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new UnsupportedOperationException ( </a> 0
<a> "Session: an attempt was made to request new permissions for a session that is not currently open." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> newPermissionsRequest . setValidateSameFbidAsToken ( getAccessToken ( ) ) ; </a> 0
<a> authorize ( newPermissionsRequest ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void validateLoginBehavior ( AuthorizationRequest request ) { </a> 0
<a> if ( request != null && ! request . isLegacy ) { </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . setClass ( getStaticContext ( ) , LoginActivity . class ) ; </a> 0
<a> if ( ! resolveIntent ( intent ) ) { </a> 0
<a> throw new FacebookException ( String . format ( </a> 0
<a> "Cannot use SessionLoginBehavior %s when %s is not declared as an activity in AndroidManifest.xml" , </a> 0
<a> request . getLoginBehavior ( ) , LoginActivity . class . getName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void validatePermissions ( AuthorizationRequest request , SessionAuthorizationType authType ) { </a> 0
<a> if ( request == null || Utility . isNullOrEmpty ( request . getPermissions ( ) ) ) { </a> 0
<a> if ( SessionAuthorizationType . PUBLISH . equals ( authType ) ) { </a> 0
<a> throw new FacebookException ( "Cannot request publish or manage authorization with no permissions." ) ; </a> 0
<a> } </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> for ( String permission : request . getPermissions ( ) ) { </a> 0
<a> if ( isPublishPermission ( permission ) ) { </a> 0
<a> if ( SessionAuthorizationType . READ . equals ( authType ) ) { </a> 0
<a> throw new FacebookException ( </a> 0
<a> String . format ( </a> 0
<a> "Cannot pass a publish or manage permission (%s) to a request for read authorization" , </a> 0
<a> permission ) ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( SessionAuthorizationType . PUBLISH . equals ( authType ) ) { </a> 0
<a> Log . w ( TAG , </a> 0
<a> String . format ( </a> 0
<a> "Should not pass a read permission (%s) to a request for publish or manage authorization" , </a> 0
<a> permission ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static boolean isPublishPermission ( String permission ) { </a> 0
<a> return permission != null && </a> 0
<a> ( permission . startsWith ( PUBLISH_PERMISSION_PREFIX ) || </a> 0
<a> permission . startsWith ( MANAGE_PERMISSION_PREFIX ) || </a> 0
<a> OTHER_PUBLISH_PERMISSIONS . contains ( permission ) ) ; </a> 0
<a> } </a> 0
<a> private void handleAuthorizationResult ( int resultCode , AuthorizationClient . Result result ) { </a> 0
<a> AccessToken newToken = null ; </a> 0
<a> Exception exception = null ; </a> 0
<a> if ( resultCode == Activity . RESULT_OK ) { </a> 0
<a> if ( result . code == AuthorizationClient . Result . Code . SUCCESS ) { </a> 0
<a> newToken = result . token ; </a> 0
<a> } else { </a> 0
<a> exception = new FacebookAuthorizationException ( result . errorMessage ) ; </a> 0
<a> } </a> 0
<a> } else if ( resultCode == Activity . RESULT_CANCELED ) { </a> 0
<a> exception = new FacebookOperationCanceledException ( result . errorMessage ) ; </a> 0
<a> } </a> 0
<a> authorizationClient = null ; </a> 0
<a> finishAuthOrReauth ( newToken , exception ) ; </a> 0
<a> } </a> 0
<a> private boolean tryLoginActivity ( AuthorizationRequest request ) { </a> 0
<a> Intent intent = getLoginActivityIntent ( request ) ; </a> 0
<a> if ( ! resolveIntent ( intent ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> request . getStartActivityDelegate ( ) . startActivityForResult ( intent , request . getRequestCode ( ) ) ; </a> 0
<a> } catch ( ActivityNotFoundException e ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> private boolean resolveIntent ( Intent intent ) { </a> 0
<a> ResolveInfo resolveInfo = getStaticContext ( ) . getPackageManager ( ) . resolveActivity ( intent , 0 ) ; </a> 0
<a> if ( resolveInfo == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> private Intent getLoginActivityIntent ( AuthorizationRequest request ) { </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . setClass ( getStaticContext ( ) , LoginActivity . class ) ; </a> 0
<a> intent . setAction ( request . getLoginBehavior ( ) . toString ( ) ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest authClientRequest = request . getAuthorizationClientRequest ( ) ; </a> 0
<a> Bundle extras = LoginActivity . populateIntentExtras ( authClientRequest ) ; </a> 0
<a> intent . putExtras ( extras ) ; </a> 0
<a> return intent ; </a> 0
<a> } </a> 0
<a> private boolean tryLegacyAuth ( final AuthorizationRequest request ) { </a> 0
<a> authorizationClient = new AuthorizationClient ( ) ; </a> 0
<a> authorizationClient . setOnCompletedListener ( new AuthorizationClient . OnCompletedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( AuthorizationClient . Result result ) { </a> 0
<a> handleAuthorizationResult ( Activity . RESULT_OK , result ) ; </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> authorizationClient . setContext ( getStaticContext ( ) ) ; </a> 0
<a> authorizationClient . startOrContinueAuth ( request . getAuthorizationClientRequest ( ) ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "incomplete-switch" ) </a> 0
<a> void finishAuthOrReauth ( AccessToken newToken , Exception exception ) { </a> 0
<a> if ( ( newToken != null ) && newToken . isInvalid ( ) ) { </a> 0
<a> newToken = null ; </a> 0
<a> exception = new FacebookException ( "Invalid access token." ) ; </a> 0
<a> } </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> switch ( this . state ) { </a> 0
<a> case OPENING : </a> 0
<a> finishAuthorization ( newToken , exception ) ; </a> 0
<a> break ; </a> 0
<a> case OPENED : </a> 0
<a> case OPENED_TOKEN_UPDATED : </a> 0
<a> finishReauthorization ( newToken , exception ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void finishAuthorization ( AccessToken newToken , Exception exception ) { </a> 0
<a> final SessionState oldState = state ; </a> 0
<a> if ( newToken != null ) { </a> 0
<a> tokenInfo = newToken ; </a> 0
<a> saveTokenToCache ( newToken ) ; </a> 0
<a> state = SessionState . OPENED ; </a> 0
<a> } else if ( exception != null ) { </a> 0
<a> state = SessionState . CLOSED_LOGIN_FAILED ; </a> 0
<a> } </a> 0
<a> pendingRequest = null ; </a> 0
<a> postStateChange ( oldState , state , exception ) ; </a> 0
<a> } </a> 0
<a> private void finishReauthorization ( final AccessToken newToken , Exception exception ) { </a> 0
<a> final SessionState oldState = state ; </a> 0
<a> if ( newToken != null ) { </a> 0
<a> tokenInfo = newToken ; </a> 0
<a> saveTokenToCache ( newToken ) ; </a> 0
<a> state = SessionState . OPENED_TOKEN_UPDATED ; </a> 0
<a> } </a> 0
<a> pendingRequest = null ; </a> 0
<a> postStateChange ( oldState , state , exception ) ; </a> 0
<a> } </a> 0
<a> private void saveTokenToCache ( AccessToken newToken ) { </a> 0
<a> if ( newToken != null && tokenCachingStrategy != null ) { </a> 0
<a> tokenCachingStrategy . save ( newToken . toCacheBundle ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void postStateChange ( final SessionState oldState , final SessionState newState , final Exception exception ) { </a> 0
<a> if ( oldState == newState && exception == null ) { </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> if ( newState . isClosed ( ) ) { </a> 0
<a> this . tokenInfo = AccessToken . createEmptyToken ( Collections . < String > emptyList ( ) ) ; </a> 0
<a> } </a> 0
<a> synchronized ( callbacks ) { </a> 0
<a> Runnable runCallbacks = new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> for ( final StatusCallback callback : callbacks ) { </a> 0
<a> Runnable closure = new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> callback . call ( Session . this , newState , exception ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> runWithHandlerOrExecutor ( handler , closure ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> runWithHandlerOrExecutor ( handler , runCallbacks ) ; </a> 0
<a> } </a> 0
<a> if ( this == Session . activeSession ) { </a> 0
<a> if ( oldState . isOpened ( ) != newState . isOpened ( ) ) { </a> 0
<a> if ( newState . isOpened ( ) ) { </a> 0
<a> postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_OPENED ) ; </a> 0
<a> } else { </a> 0
<a> postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_CLOSED ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static void postActiveSessionAction ( String action ) { </a> 0
<a> final Intent intent = new Intent ( action ) ; </a> 0
<a> LocalBroadcastManager . getInstance ( getStaticContext ( ) ) . sendBroadcast ( intent ) ; </a> 0
<a> } </a> 0
<a> private static void runWithHandlerOrExecutor ( Handler handler , Runnable runnable ) { </a> 0
<a> if ( handler != null ) { </a> 0
<a> handler . post ( runnable ) ; </a> 0
<a> } else { </a> 0
<a> Settings . getExecutor ( ) . execute ( runnable ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void extendAccessTokenIfNeeded ( ) { </a> 0
<a> if ( shouldExtendAccessToken ( ) ) { </a> 0
<a> extendAccessToken ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void extendAccessToken ( ) { </a> 0
<a> TokenRefreshRequest newTokenRefreshRequest = null ; </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> if ( currentTokenRefreshRequest == null ) { </a> 0
<a> newTokenRefreshRequest = new TokenRefreshRequest ( ) ; </a> 0
<a> currentTokenRefreshRequest = newTokenRefreshRequest ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( newTokenRefreshRequest != null ) { </a> 0
<a> newTokenRefreshRequest . bind ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean shouldExtendAccessToken ( ) { </a> 0
<a> if ( currentTokenRefreshRequest != null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> boolean result = false ; </a> 0
<a> Date now = new Date ( ) ; </a> 0
<a> if ( state . isOpened ( ) && tokenInfo . getSource ( ) . canExtendToken ( ) </a> 0
<a> && now . getTime ( ) - lastAttemptedTokenExtendDate . getTime ( ) > TOKEN_EXTEND_RETRY_SECONDS * 1000 </a> 0
<a> && now . getTime ( ) - tokenInfo . getLastRefresh ( ) . getTime ( ) > TOKEN_EXTEND_THRESHOLD_SECONDS * 1000 ) { </a> 0
<a> result = true ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> AccessToken getTokenInfo ( ) { </a> 0
<a> return tokenInfo ; </a> 0
<a> } </a> 0
<a> void setTokenInfo ( AccessToken tokenInfo ) { </a> 0
<a> this . tokenInfo = tokenInfo ; </a> 0
<a> } </a> 0
<a> Date getLastAttemptedTokenExtendDate ( ) { </a> 0
<a> return lastAttemptedTokenExtendDate ; </a> 0
<a> } </a> 0
<a> void setLastAttemptedTokenExtendDate ( Date lastAttemptedTokenExtendDate ) { </a> 0
<a> this . lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate ; </a> 0
<a> } </a> 0
<a> void setCurrentTokenRefreshRequest ( TokenRefreshRequest request ) { </a> 0
<a> this . currentTokenRefreshRequest = request ; </a> 0
<a> } </a> 0
<a> class TokenRefreshRequest implements ServiceConnection { </a> 0
<a> final Messenger messageReceiver = new Messenger ( </a> 0
<a> new TokenRefreshRequestHandler ( Session . this , this ) ) ; </a> 0
<a> Messenger messageSender = null ; </a> 0
<a> public void bind ( ) { </a> 0
<a> Intent intent = NativeProtocol . createTokenRefreshIntent ( getStaticContext ( ) ) ; </a> 0
<a> if ( intent != null </a> 0
<a> && staticContext . bindService ( intent , new TokenRefreshRequest ( ) , Context . BIND_AUTO_CREATE ) ) { </a> 0
<a> setLastAttemptedTokenExtendDate ( new Date ( ) ) ; </a> 0
<a> } else { </a> 0
<a> cleanup ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onServiceConnected ( ComponentName className , IBinder service ) { </a> 0
<a> messageSender = new Messenger ( service ) ; </a> 0
<a> refreshToken ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onServiceDisconnected ( ComponentName arg ) { </a> 0
<a> cleanup ( ) ; </a> 0
<a> staticContext . unbindService ( TokenRefreshRequest . this ) ; </a> 0
<a> } </a> 0
<a> private void cleanup ( ) { </a> 0
<a> if ( currentTokenRefreshRequest == this ) { </a> 0
<a> currentTokenRefreshRequest = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void refreshToken ( ) { </a> 0
<a> Bundle requestData = new Bundle ( ) ; </a> 0
<a> requestData . putString ( AccessToken . ACCESS_TOKEN_KEY , getTokenInfo ( ) . getToken ( ) ) ; </a> 0
<a> Message request = Message . obtain ( ) ; </a> 0
<a> request . setData ( requestData ) ; </a> 0
<a> request . replyTo = messageReceiver ; </a> 0
<a> try { </a> 0
<a> messageSender . send ( request ) ; </a> 0
<a> } catch ( RemoteException e ) { </a> 0
<a> cleanup ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static class TokenRefreshRequestHandler extends Handler { </a> 0
<a> private WeakReference < Session > sessionWeakReference ; </a> 0
<a> private WeakReference < TokenRefreshRequest > refreshRequestWeakReference ; </a> 0
<a> TokenRefreshRequestHandler ( Session session , TokenRefreshRequest refreshRequest ) { </a> 0
<a> super ( Looper . getMainLooper ( ) ) ; </a> 0
<a> sessionWeakReference = new WeakReference < Session > ( session ) ; </a> 0
<a> refreshRequestWeakReference = new WeakReference < TokenRefreshRequest > ( refreshRequest ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void handleMessage ( Message msg ) { </a> 0
<a> String token = msg . getData ( ) . getString ( AccessToken . ACCESS_TOKEN_KEY ) ; </a> 0
<a> Session session = sessionWeakReference . get ( ) ; </a> 0
<a> if ( session != null && token != null ) { </a> 0
<a> session . extendTokenCompleted ( msg . getData ( ) ) ; </a> 0
<a> } </a> 0
<a> TokenRefreshRequest request = refreshRequestWeakReference . get ( ) ; </a> 0
<a> if ( request != null ) { </a> 0
<a> staticContext . unbindService ( request ) ; </a> 0
<a> request . cleanup ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public interface StatusCallback { </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object otherObj ) { </a> 0
<a> if ( ! ( otherObj instanceof Session ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> Session other = ( Session ) otherObj ; </a> 0
<a> return areEqual ( other . applicationId , applicationId ) && </a> 0
<a> areEqual ( other . authorizationBundle , authorizationBundle ) && </a> 0
<a> areEqual ( other . state , state ) && </a> 0
<a> areEqual ( other . getExpirationDate ( ) , getExpirationDate ( ) ) ; </a> 0
<a> } </a> 0
<a> private static boolean areEqual ( Object a , Object b ) { </a> 0
<a> if ( a == null ) { </a> 0
<a> return b == null ; </a> 0
<a> } else { </a> 0
<a> return a . equals ( b ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final class Builder { </a> 0
<a> private final Context context ; </a> 0
<a> private String applicationId ; </a> 0
<a> private TokenCachingStrategy tokenCachingStrategy ; </a> 0
<a> public Builder ( Context context ) { </a> 0
<a> this . context = context ; </a> 0
<a> } </a> 0
<a> public Builder setApplicationId ( final String applicationId ) { </a> 0
<a> this . applicationId = applicationId ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder setTokenCachingStrategy ( final TokenCachingStrategy tokenCachingStrategy ) { </a> 0
<a> this . tokenCachingStrategy = tokenCachingStrategy ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Session build ( ) { </a> 0
<a> return new Session ( context , applicationId , tokenCachingStrategy ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> interface StartActivityDelegate { </a> 0
<a> public void startActivityForResult ( Intent intent , int requestCode ) ; </a> 0
<a> public Activity getActivityContext ( ) ; </a> 0
<a> } </a> 0
<a> private void autoPublishAsync ( ) { </a> 0
<a> AutoPublishAsyncTask asyncTask = null ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( autoPublishAsyncTask == null && Settings . getShouldAutoPublishInstall ( ) ) { </a> 0
<a> String applicationId = Session . this . applicationId ; </a> 0
<a> if ( applicationId != null ) { </a> 0
<a> asyncTask = autoPublishAsyncTask = new AutoPublishAsyncTask ( applicationId , staticContext ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( asyncTask != null ) { </a> 0
<a> asyncTask . execute ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class AutoPublishAsyncTask extends AsyncTask < Void , Void , Void > { </a> 0
<a> private final String mApplicationId ; </a> 0
<a> private final Context mApplicationContext ; </a> 0
<a> public AutoPublishAsyncTask ( String applicationId , Context context ) { </a> 0
<a> mApplicationId = applicationId ; </a> 0
<a> mApplicationContext = context . getApplicationContext ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected Void doInBackground ( Void ... voids ) { </a> 0
<a> try { </a> 0
<a> Settings . publishInstallAndWait ( mApplicationContext , mApplicationId ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> Utility . logd ( "Facebook-publish" , e . getMessage ( ) ) ; </a> 1
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onPostExecute ( Void result ) { </a> 0
<a> synchronized ( Session . this ) { </a> 0
<a> autoPublishAsyncTask = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static class AuthorizationRequest implements Serializable { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> private final StartActivityDelegate startActivityDelegate ; </a> 0
<a> private SessionLoginBehavior loginBehavior = SessionLoginBehavior . SSO_WITH_FALLBACK ; </a> 0
<a> private int requestCode = DEFAULT_AUTHORIZE_ACTIVITY_CODE ; </a> 0
<a> private StatusCallback statusCallback ; </a> 0
<a> private boolean isLegacy = false ; </a> 0
<a> private List < String > permissions = Collections . emptyList ( ) ; </a> 0
<a> private SessionDefaultAudience defaultAudience = SessionDefaultAudience . FRIENDS ; </a> 0
<a> private String applicationId ; </a> 0
<a> private String validateSameFbidAsToken ; </a> 0
<a> AuthorizationRequest ( final Activity activity ) { </a> 0
<a> startActivityDelegate = new StartActivityDelegate ( ) { </a> 0
<a> @ Override </a> 0
<a> public void startActivityForResult ( Intent intent , int requestCode ) { </a> 0
<a> activity . startActivityForResult ( intent , requestCode ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Activity getActivityContext ( ) { </a> 0
<a> return activity ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> AuthorizationRequest ( final Fragment fragment ) { </a> 0
<a> startActivityDelegate = new StartActivityDelegate ( ) { </a> 0
<a> @ Override </a> 0
<a> public void startActivityForResult ( Intent intent , int requestCode ) { </a> 0
<a> fragment . startActivityForResult ( intent , requestCode ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Activity getActivityContext ( ) { </a> 0
<a> return fragment . getActivity ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> private AuthorizationRequest ( SessionLoginBehavior loginBehavior , int requestCode , </a> 0
<a> List < String > permissions , String defaultAudience , boolean isLegacy , String applicationId , </a> 0
<a> String validateSameFbidAsToken ) { </a> 0
<a> startActivityDelegate = new StartActivityDelegate ( ) { </a> 0
<a> @ Override </a> 0
<a> public void startActivityForResult ( Intent intent , int requestCode ) { </a> 0
<a> throw new UnsupportedOperationException ( </a> 0
<a> "Cannot create an AuthorizationRequest without a valid Activity or Fragment" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Activity getActivityContext ( ) { </a> 0
<a> throw new UnsupportedOperationException ( </a> 0
<a> "Cannot create an AuthorizationRequest without a valid Activity or Fragment" ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> this . loginBehavior = loginBehavior ; </a> 0
<a> this . requestCode = requestCode ; </a> 0
<a> this . permissions = permissions ; </a> 0
<a> this . defaultAudience = SessionDefaultAudience . valueOf ( defaultAudience ) ; </a> 0
<a> this . isLegacy = isLegacy ; </a> 0
<a> this . applicationId = applicationId ; </a> 0
<a> this . validateSameFbidAsToken = validateSameFbidAsToken ; </a> 0
<a> } </a> 0
<a> public void setIsLegacy ( boolean isLegacy ) { </a> 0
<a> this . isLegacy = isLegacy ; </a> 0
<a> } </a> 0
<a> boolean isLegacy ( ) { </a> 0
<a> return isLegacy ; </a> 0
<a> } </a> 0
<a> AuthorizationRequest setCallback ( StatusCallback statusCallback ) { </a> 0
<a> this . statusCallback = statusCallback ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> StatusCallback getCallback ( ) { </a> 0
<a> return statusCallback ; </a> 0
<a> } </a> 0
<a> AuthorizationRequest setLoginBehavior ( SessionLoginBehavior loginBehavior ) { </a> 0
<a> if ( loginBehavior != null ) { </a> 0
<a> this . loginBehavior = loginBehavior ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> SessionLoginBehavior getLoginBehavior ( ) { </a> 0
<a> return loginBehavior ; </a> 0
<a> } </a> 0
<a> AuthorizationRequest setRequestCode ( int requestCode ) { </a> 0
<a> if ( requestCode >= 0 ) { </a> 0
<a> this . requestCode = requestCode ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> int getRequestCode ( ) { </a> 0
<a> return requestCode ; </a> 0
<a> } </a> 0
<a> AuthorizationRequest setPermissions ( List < String > permissions ) { </a> 0
<a> if ( permissions != null ) { </a> 0
<a> this . permissions = permissions ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> List < String > getPermissions ( ) { </a> 0
<a> return permissions ; </a> 0
<a> } </a> 0
<a> AuthorizationRequest setDefaultAudience ( SessionDefaultAudience defaultAudience ) { </a> 0
<a> if ( defaultAudience != null ) { </a> 0
<a> this . defaultAudience = defaultAudience ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> SessionDefaultAudience getDefaultAudience ( ) { </a> 0
<a> return defaultAudience ; </a> 0
<a> } </a> 0
<a> StartActivityDelegate getStartActivityDelegate ( ) { </a> 0
<a> return startActivityDelegate ; </a> 0
<a> } </a> 0
<a> String getApplicationId ( ) { </a> 0
<a> return applicationId ; </a> 0
<a> } </a> 0
<a> void setApplicationId ( String applicationId ) { </a> 0
<a> this . applicationId = applicationId ; </a> 0
<a> } </a> 0
<a> String getValidateSameFbidAsToken ( ) { </a> 0
<a> return validateSameFbidAsToken ; </a> 0
<a> } </a> 0
<a> void setValidateSameFbidAsToken ( String validateSameFbidAsToken ) { </a> 0
<a> this . validateSameFbidAsToken = validateSameFbidAsToken ; </a> 0
<a> } </a> 0
<a> AuthorizationClient . AuthorizationRequest getAuthorizationClientRequest ( ) { </a> 0
<a> AuthorizationClient . StartActivityDelegate delegate = new AuthorizationClient . StartActivityDelegate ( ) { </a> 0
<a> @ Override </a> 0
<a> public void startActivityForResult ( Intent intent , int requestCode ) { </a> 0
<a> startActivityDelegate . startActivityForResult ( intent , requestCode ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Activity getActivityContext ( ) { </a> 0
<a> return startActivityDelegate . getActivityContext ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> return new AuthorizationClient . AuthorizationRequest ( loginBehavior , requestCode , isLegacy , </a> 0
<a> permissions , defaultAudience , applicationId , validateSameFbidAsToken , delegate ) ; </a> 0
<a> } </a> 0
<a> Object writeReplace ( ) { </a> 0
<a> return new AuthRequestSerializationProxyV1 ( </a> 0
<a> loginBehavior , requestCode , permissions , defaultAudience . name ( ) , isLegacy , applicationId , validateSameFbidAsToken ) ; </a> 0
<a> } </a> 0
<a> void readObject ( ObjectInputStream stream ) throws InvalidObjectException { </a> 0
<a> throw new InvalidObjectException ( "Cannot readObject, serialization proxy required" ) ; </a> 0
<a> } </a> 0
<a> private static class AuthRequestSerializationProxyV1 implements Serializable { </a> 0
<a> private static final long serialVersionUID = - 8748347685113614927L ; </a> 0
<a> private final SessionLoginBehavior loginBehavior ; </a> 0
<a> private final int requestCode ; </a> 0
<a> private boolean isLegacy ; </a> 0
<a> private final List < String > permissions ; </a> 0
<a> private final String defaultAudience ; </a> 0
<a> private final String applicationId ; </a> 0
<a> private final String validateSameFbidAsToken ; </a> 0
<a> private AuthRequestSerializationProxyV1 ( SessionLoginBehavior loginBehavior , </a> 0
<a> int requestCode , List < String > permissions , String defaultAudience , boolean isLegacy , </a> 0
<a> String applicationId , String validateSameFbidAsToken ) { </a> 0
<a> this . loginBehavior = loginBehavior ; </a> 0
<a> this . requestCode = requestCode ; </a> 0
<a> this . permissions = permissions ; </a> 0
<a> this . defaultAudience = defaultAudience ; </a> 0
<a> this . isLegacy = isLegacy ; </a> 0
<a> this . applicationId = applicationId ; </a> 0
<a> this . validateSameFbidAsToken = validateSameFbidAsToken ; </a> 0
<a> } </a> 0
<a> private Object readResolve ( ) { </a> 0
<a> return new AuthorizationRequest ( loginBehavior , requestCode , permissions , defaultAudience , isLegacy , </a> 0
<a> applicationId , validateSameFbidAsToken ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final class OpenRequest extends AuthorizationRequest { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> public OpenRequest ( Activity activity ) { </a> 0
<a> super ( activity ) ; </a> 0
<a> } </a> 0
<a> public OpenRequest ( Fragment fragment ) { </a> 0
<a> super ( fragment ) ; </a> 0
<a> } </a> 0
<a> public final OpenRequest setCallback ( StatusCallback statusCallback ) { </a> 0
<a> super . setCallback ( statusCallback ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public final OpenRequest setLoginBehavior ( SessionLoginBehavior loginBehavior ) { </a> 0
<a> super . setLoginBehavior ( loginBehavior ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public final OpenRequest setRequestCode ( int requestCode ) { </a> 0
<a> super . setRequestCode ( requestCode ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public final OpenRequest setPermissions ( List < String > permissions ) { </a> 0
<a> super . setPermissions ( permissions ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public final OpenRequest setDefaultAudience ( SessionDefaultAudience defaultAudience ) { </a> 0
<a> super . setDefaultAudience ( defaultAudience ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final class NewPermissionsRequest extends AuthorizationRequest { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> public NewPermissionsRequest ( Activity activity , List < String > permissions ) { </a> 0
<a> super ( activity ) ; </a> 0
<a> setPermissions ( permissions ) ; </a> 0
<a> } </a> 0
<a> public NewPermissionsRequest ( Fragment fragment , List < String > permissions ) { </a> 0
<a> super ( fragment ) ; </a> 0
<a> setPermissions ( permissions ) ; </a> 0
<a> } </a> 0
<a> public final NewPermissionsRequest setCallback ( StatusCallback statusCallback ) { </a> 0
<a> super . setCallback ( statusCallback ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public final NewPermissionsRequest setLoginBehavior ( SessionLoginBehavior loginBehavior ) { </a> 0
<a> super . setLoginBehavior ( loginBehavior ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public final NewPermissionsRequest setRequestCode ( int requestCode ) { </a> 0
<a> super . setRequestCode ( requestCode ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public final NewPermissionsRequest setDefaultAudience ( SessionDefaultAudience defaultAudience ) { </a> 0
<a> super . setDefaultAudience ( defaultAudience ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> public enum SessionLoginBehavior { </a> 0
<a> SSO_WITH_FALLBACK ( true , true ) , </a> 0
<a> SSO_ONLY ( true , false ) , </a> 0
<a> SUPPRESS_SSO ( false , true ) ; </a> 0
<a> private final boolean allowsKatanaAuth ; </a> 0
<a> private final boolean allowsWebViewAuth ; </a> 0
<a> private SessionLoginBehavior ( boolean allowsKatanaAuth , boolean allowsWebViewAuth ) { </a> 0
<a> this . allowsKatanaAuth = allowsKatanaAuth ; </a> 0
<a> this . allowsWebViewAuth = allowsWebViewAuth ; </a> 0
<a> } </a> 0
<a> boolean allowsKatanaAuth ( ) { </a> 0
<a> return allowsKatanaAuth ; </a> 0
<a> } </a> 0
<a> boolean allowsWebViewAuth ( ) { </a> 0
<a> return allowsWebViewAuth ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> public enum SessionState { </a> 0
<a> CREATED ( Category . CREATED_CATEGORY ) , </a> 0
<a> CREATED_TOKEN_LOADED ( Category . CREATED_CATEGORY ) , </a> 0
<a> OPENING ( Category . CREATED_CATEGORY ) , </a> 0
<a> OPENED ( Category . OPENED_CATEGORY ) , </a> 0
<a> OPENED_TOKEN_UPDATED ( Category . OPENED_CATEGORY ) , </a> 0
<a> CLOSED_LOGIN_FAILED ( Category . CLOSED_CATEGORY ) , </a> 0
<a> CLOSED ( Category . CLOSED_CATEGORY ) ; </a> 0
<a> private final Category category ; </a> 0
<a> SessionState ( Category category ) { </a> 0
<a> this . category = category ; </a> 0
<a> } </a> 0
<a> public boolean isOpened ( ) { </a> 0
<a> return this . category == Category . OPENED_CATEGORY ; </a> 0
<a> } </a> 0
<a> public boolean isClosed ( ) { </a> 0
<a> return this . category == Category . CLOSED_CATEGORY ; </a> 0
<a> } </a> 0
<a> private enum Category { </a> 0
<a> CREATED_CATEGORY , OPENED_CATEGORY , CLOSED_CATEGORY </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . content . ContentResolver ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . SharedPreferences ; </a> 0
<a> import android . database . Cursor ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . os . AsyncTask ; </a> 0
<a> import android . os . Bundle ; </a> 1
<a> import com . facebook . android . BuildConfig ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import com . facebook . internal . Validate ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import java . lang . reflect . Field ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . HashSet ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . concurrent . * ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> public final class Settings { </a> 0
<a> private static final HashSet < LoggingBehavior > loggingBehaviors = new HashSet < LoggingBehavior > ( ) ; </a> 1
<a> private static volatile Executor executor ; </a> 0
<a> private static volatile boolean shouldAutoPublishInstall ; </a> 0
<a> private static final int DEFAULT_CORE_POOL_SIZE = 5 ; </a> 0
<a> private static final int DEFAULT_MAXIMUM_POOL_SIZE = 128 ; </a> 0
<a> private static final int DEFAULT_KEEP_ALIVE = 1 ; </a> 0
<a> private static final Object LOCK = new Object ( ) ; </a> 0
<a> private static final Uri ATTRIBUTION_ID_CONTENT_URI = </a> 0
<a> Uri . parse ( "content://com.facebook.katana.provider.AttributionIdProvider" ) ; </a> 0
<a> private static final String ATTRIBUTION_ID_COLUMN_NAME = "aid" ; </a> 0
<a> private static final String ATTRIBUTION_PREFERENCES = "com.facebook.sdk.attributionTracking" ; </a> 0
<a> private static final String PUBLISH_ACTIVITY_PATH = "%s/activities" ; </a> 0
<a> private static final String MOBILE_INSTALL_EVENT = "MOBILE_APP_INSTALL" ; </a> 0
<a> private static final String SUPPORTS_ATTRIBUTION = "supports_attribution" ; </a> 1
<a> private static final String APPLICATION_FIELDS = "fields" ; </a> 1
<a> private static final String ANALYTICS_EVENT = "event" ; </a> 0
<a> private static final String ATTRIBUTION_KEY = "attribution" ; </a> 1
<a> private static final BlockingQueue < Runnable > DEFAULT_WORK_QUEUE = new LinkedBlockingQueue < Runnable > ( 10 ) ; </a> 0
<a> private static final ThreadFactory DEFAULT_THREAD_FACTORY = new ThreadFactory ( ) { </a> 0
<a> private final AtomicInteger counter = new AtomicInteger ( 0 ) ; </a> 0
<a> public Thread newThread ( Runnable runnable ) { </a> 0
<a> return new Thread ( runnable , "FacebookSdk #" + counter . incrementAndGet ( ) ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> public static final Set < LoggingBehavior > getLoggingBehaviors ( ) { </a> 0
<a> synchronized ( loggingBehaviors ) { </a> 0
<a> return Collections . unmodifiableSet ( new HashSet < LoggingBehavior > ( loggingBehaviors ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final void addLoggingBehavior ( LoggingBehavior behavior ) { </a> 0
<a> synchronized ( loggingBehaviors ) { </a> 0
<a> loggingBehaviors . add ( behavior ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final void removeLoggingBehavior ( LoggingBehavior behavior ) { </a> 0
<a> synchronized ( loggingBehaviors ) { </a> 0
<a> loggingBehaviors . remove ( behavior ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final void clearLoggingBehaviors ( ) { </a> 0
<a> synchronized ( loggingBehaviors ) { </a> 0
<a> loggingBehaviors . clear ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final boolean isLoggingBehaviorEnabled ( LoggingBehavior behavior ) { </a> 0
<a> synchronized ( loggingBehaviors ) { </a> 0
<a> return BuildConfig . DEBUG && loggingBehaviors . contains ( behavior ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static Executor getExecutor ( ) { </a> 0
<a> synchronized ( LOCK ) { </a> 0
<a> if ( Settings . executor == null ) { </a> 0
<a> Executor executor = getAsyncTaskExecutor ( ) ; </a> 0
<a> if ( executor == null ) { </a> 0
<a> executor = new ThreadPoolExecutor ( DEFAULT_CORE_POOL_SIZE , DEFAULT_MAXIMUM_POOL_SIZE , </a> 0
<a> DEFAULT_KEEP_ALIVE , TimeUnit . SECONDS , DEFAULT_WORK_QUEUE , DEFAULT_THREAD_FACTORY ) ; </a> 0
<a> } </a> 0
<a> Settings . executor = executor ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return Settings . executor ; </a> 0
<a> } </a> 0
<a> public static void setExecutor ( Executor executor ) { </a> 0
<a> Validate . notNull ( executor , "executor" ) ; </a> 0
<a> synchronized ( LOCK ) { </a> 0
<a> Settings . executor = executor ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static Executor getAsyncTaskExecutor ( ) { </a> 0
<a> Field executorField = null ; </a> 0
<a> try { </a> 0
<a> executorField = AsyncTask . class . getField ( "THREAD_POOL_EXECUTOR" ) ; </a> 0
<a> } catch ( NoSuchFieldException e ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( executorField == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> Object executorObject = null ; </a> 0
<a> try { </a> 0
<a> executorObject = executorField . get ( null ) ; </a> 0
<a> } catch ( IllegalAccessException e ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( executorObject == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( ! ( executorObject instanceof Executor ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return ( Executor ) executorObject ; </a> 0
<a> } </a> 0
<a> public static void publishInstallAsync ( final Context context , final String applicationId ) { </a> 0
<a> final Context applicationContext = context . getApplicationContext ( ) ; </a> 0
<a> Settings . getExecutor ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> Settings . publishInstallAndWait ( applicationContext , applicationId ) ; </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> public static void setShouldAutoPublishInstall ( boolean shouldAutoPublishInstall ) { </a> 0
<a> Settings . shouldAutoPublishInstall = shouldAutoPublishInstall ; </a> 0
<a> } </a> 0
<a> public static boolean getShouldAutoPublishInstall ( ) { </a> 0
<a> return shouldAutoPublishInstall ; </a> 0
<a> } </a> 0
<a> public static boolean publishInstallAndWait ( final Context context , final String applicationId ) { </a> 0
<a> try { </a> 0
<a> if ( applicationId == null ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 0
<a> String attributionId = Settings . getAttributionId ( context . getContentResolver ( ) ) ; </a> 0
<a> SharedPreferences preferences = context . getSharedPreferences ( ATTRIBUTION_PREFERENCES , Context . MODE_PRIVATE ) ; </a> 0
<a> String pingKey = applicationId + "ping" ; </a> 0
<a> long lastPing = preferences . getLong ( pingKey , 0 ) ; </a> 0
<a> if ( lastPing == 0 && attributionId != null ) { </a> 0
<a> Bundle supportsAttributionParams = new Bundle ( ) ; </a> 0
<a> supportsAttributionParams . putString ( APPLICATION_FIELDS , SUPPORTS_ATTRIBUTION ) ; </a> 0
<a> Request pingRequest = Request . newGraphPathRequest ( null , applicationId , null ) ; </a> 1
<a> pingRequest . setParameters ( supportsAttributionParams ) ; </a> 1
<a> GraphObject supportResponse = pingRequest . executeAndWait ( ) . getGraphObject ( ) ; </a> 1
<a> Object doesSupportAttribution = supportResponse . getProperty ( SUPPORTS_ATTRIBUTION ) ; </a> 1
<a> if ( ! ( doesSupportAttribution instanceof Boolean ) ) { </a> 0
<a> throw new JSONException ( String . format ( </a> 0
<a> "%s contains %s instead of a Boolean" , SUPPORTS_ATTRIBUTION , doesSupportAttribution ) ) ; </a> 0
<a> } </a> 0
<a> if ( ( Boolean ) doesSupportAttribution ) { </a> 1
<a> GraphObject publishParams = GraphObject . Factory . create ( ) ; </a> 0
<a> publishParams . setProperty ( ANALYTICS_EVENT , MOBILE_INSTALL_EVENT ) ; </a> 0
<a> publishParams . setProperty ( ATTRIBUTION_KEY , attributionId ) ; </a> 1
<a> String publishUrl = String . format ( PUBLISH_ACTIVITY_PATH , applicationId ) ; </a> 0
<a> Request publishRequest = Request . newPostRequest ( null , publishUrl , publishParams , null ) ; </a> 1
<a> publishRequest . executeAndWait ( ) ; </a> 1
<a> SharedPreferences . Editor editor = preferences . edit ( ) ; </a> 0
<a> lastPing = System . currentTimeMillis ( ) ; </a> 0
<a> editor . putLong ( pingKey , lastPing ) ; </a> 0
<a> editor . commit ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> return lastPing != 0 ; </a> 1
<a> } catch ( Exception e ) { </a> 0
<a> Utility . logd ( "Facebook-publish" , e . getMessage ( ) ) ; </a> 1
<a> } </a> 0
<a> return false ; </a> 1
<a> } </a> 0
<a> public static String getAttributionId ( ContentResolver contentResolver ) { </a> 0
<a> String [ ] projection = { ATTRIBUTION_ID_COLUMN_NAME } ; </a> 0
<a> Cursor c = contentResolver . query ( ATTRIBUTION_ID_CONTENT_URI , projection , null , null , null ) ; </a> 1
<a> if ( c == null || ! c . moveToFirst ( ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> String attributionId = c . getString ( c . getColumnIndex ( ATTRIBUTION_ID_COLUMN_NAME ) ) ; </a> 0
<a> c . close ( ) ; </a> 1
<a> return attributionId ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . SharedPreferences ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import com . facebook . internal . Logger ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import com . facebook . internal . Validate ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class SharedPreferencesTokenCachingStrategy extends TokenCachingStrategy { </a> 0
<a> private static final String DEFAULT_CACHE_KEY = "com.facebook.SharedPreferencesTokenCachingStrategy.DEFAULT_KEY" ; </a> 0
<a> private static final String TAG = SharedPreferencesTokenCachingStrategy . class . getSimpleName ( ) ; </a> 0
<a> private static final String JSON_VALUE_TYPE = "valueType" ; </a> 0
<a> private static final String JSON_VALUE = "value" ; </a> 0
<a> private static final String JSON_VALUE_ENUM_TYPE = "enumType" ; </a> 0
<a> private static final String TYPE_BOOLEAN = "bool" ; </a> 0
<a> private static final String TYPE_BOOLEAN_ARRAY = "bool[]" ; </a> 0
<a> private static final String TYPE_BYTE = "byte" ; </a> 0
<a> private static final String TYPE_BYTE_ARRAY = "byte[]" ; </a> 0
<a> private static final String TYPE_SHORT = "short" ; </a> 0
<a> private static final String TYPE_SHORT_ARRAY = "short[]" ; </a> 0
<a> private static final String TYPE_INTEGER = "int" ; </a> 0
<a> private static final String TYPE_INTEGER_ARRAY = "int[]" ; </a> 0
<a> private static final String TYPE_LONG = "long" ; </a> 0
<a> private static final String TYPE_LONG_ARRAY = "long[]" ; </a> 0
<a> private static final String TYPE_FLOAT = "float" ; </a> 0
<a> private static final String TYPE_FLOAT_ARRAY = "float[]" ; </a> 0
<a> private static final String TYPE_DOUBLE = "double" ; </a> 0
<a> private static final String TYPE_DOUBLE_ARRAY = "double[]" ; </a> 0
<a> private static final String TYPE_CHAR = "char" ; </a> 0
<a> private static final String TYPE_CHAR_ARRAY = "char[]" ; </a> 0
<a> private static final String TYPE_STRING = "string" ; </a> 0
<a> private static final String TYPE_STRING_LIST = "stringList" ; </a> 0
<a> private static final String TYPE_ENUM = "enum" ; </a> 0
<a> private String cacheKey ; </a> 0
<a> private SharedPreferences cache ; </a> 0
<a> public SharedPreferencesTokenCachingStrategy ( Context context ) { </a> 0
<a> this ( context , null ) ; </a> 0
<a> } </a> 0
<a> public SharedPreferencesTokenCachingStrategy ( Context context , String cacheKey ) { </a> 0
<a> Validate . notNull ( context , "context" ) ; </a> 0
<a> this . cacheKey = Utility . isNullOrEmpty ( cacheKey ) ? DEFAULT_CACHE_KEY : cacheKey ; </a> 0
<a> Context applicationContext = context . getApplicationContext ( ) ; </a> 0
<a> context = applicationContext != null ? applicationContext : context ; </a> 0
<a> this . cache = context . getSharedPreferences ( </a> 0
<a> this . cacheKey , </a> 0
<a> Context . MODE_PRIVATE ) ; </a> 0
<a> } </a> 0
<a> public Bundle load ( ) { </a> 0
<a> Bundle settings = new Bundle ( ) ; </a> 0
<a> Map < String , ? > allCachedEntries = cache . getAll ( ) ; </a> 0
<a> for ( String key : allCachedEntries . keySet ( ) ) { </a> 0
<a> try { </a> 0
<a> deserializeKey ( key , settings ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , </a> 0
<a> "Error reading cached value for key: '" + key + "' -- " + e ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return settings ; </a> 0
<a> } </a> 0
<a> public void save ( Bundle bundle ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> SharedPreferences . Editor editor = cache . edit ( ) ; </a> 0
<a> for ( String key : bundle . keySet ( ) ) { </a> 0
<a> try { </a> 0
<a> serializeKey ( key , bundle , editor ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , "Error processing value for key: '" + key + "' -- " + e ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean successfulCommit = editor . commit ( ) ; </a> 0
<a> if ( ! successfulCommit ) { </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , "SharedPreferences.Editor.commit() was not successful" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void clear ( ) { </a> 0
<a> cache . edit ( ) . clear ( ) . commit ( ) ; </a> 0
<a> } </a> 0
<a> private void serializeKey ( String key , Bundle bundle , SharedPreferences . Editor editor ) </a> 0
<a> throws JSONException { </a> 0
<a> Object value = bundle . get ( key ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> String supportedType = null ; </a> 0
<a> JSONArray jsonArray = null ; </a> 0
<a> JSONObject json = new JSONObject ( ) ; </a> 0
<a> if ( value instanceof Byte ) { </a> 0
<a> supportedType = TYPE_BYTE ; </a> 0
<a> json . put ( JSON_VALUE , ( ( Byte ) value ) . intValue ( ) ) ; </a> 0
<a> } else if ( value instanceof Short ) { </a> 0
<a> supportedType = TYPE_SHORT ; </a> 0
<a> json . put ( JSON_VALUE , ( ( Short ) value ) . intValue ( ) ) ; </a> 0
<a> } else if ( value instanceof Integer ) { </a> 0
<a> supportedType = TYPE_INTEGER ; </a> 0
<a> json . put ( JSON_VALUE , ( ( Integer ) value ) . intValue ( ) ) ; </a> 0
<a> } else if ( value instanceof Long ) { </a> 0
<a> supportedType = TYPE_LONG ; </a> 0
<a> json . put ( JSON_VALUE , ( ( Long ) value ) . longValue ( ) ) ; </a> 0
<a> } else if ( value instanceof Float ) { </a> 0
<a> supportedType = TYPE_FLOAT ; </a> 0
<a> json . put ( JSON_VALUE , ( ( Float ) value ) . doubleValue ( ) ) ; </a> 0
<a> } else if ( value instanceof Double ) { </a> 0
<a> supportedType = TYPE_DOUBLE ; </a> 0
<a> json . put ( JSON_VALUE , ( ( Double ) value ) . doubleValue ( ) ) ; </a> 0
<a> } else if ( value instanceof Boolean ) { </a> 0
<a> supportedType = TYPE_BOOLEAN ; </a> 0
<a> json . put ( JSON_VALUE , ( ( Boolean ) value ) . booleanValue ( ) ) ; </a> 0
<a> } else if ( value instanceof Character ) { </a> 0
<a> supportedType = TYPE_CHAR ; </a> 0
<a> json . put ( JSON_VALUE , value . toString ( ) ) ; </a> 0
<a> } else if ( value instanceof String ) { </a> 0
<a> supportedType = TYPE_STRING ; </a> 0
<a> json . put ( JSON_VALUE , ( String ) value ) ; </a> 0
<a> } else if ( value instanceof Enum < ? > ) { </a> 0
<a> supportedType = TYPE_ENUM ; </a> 0
<a> json . put ( JSON_VALUE , value . toString ( ) ) ; </a> 0
<a> json . put ( JSON_VALUE_ENUM_TYPE , value . getClass ( ) . getName ( ) ) ; </a> 0
<a> } else { </a> 0
<a> jsonArray = new JSONArray ( ) ; </a> 0
<a> if ( value instanceof byte [ ] ) { </a> 0
<a> supportedType = TYPE_BYTE_ARRAY ; </a> 0
<a> for ( byte v : ( byte [ ] ) value ) { </a> 0
<a> jsonArray . put ( ( int ) v ) ; </a> 0
<a> } </a> 0
<a> } else if ( value instanceof short [ ] ) { </a> 0
<a> supportedType = TYPE_SHORT_ARRAY ; </a> 0
<a> for ( short v : ( short [ ] ) value ) { </a> 0
<a> jsonArray . put ( ( int ) v ) ; </a> 0
<a> } </a> 0
<a> } else if ( value instanceof int [ ] ) { </a> 0
<a> supportedType = TYPE_INTEGER_ARRAY ; </a> 0
<a> for ( int v : ( int [ ] ) value ) { </a> 0
<a> jsonArray . put ( v ) ; </a> 0
<a> } </a> 0
<a> } else if ( value instanceof long [ ] ) { </a> 0
<a> supportedType = TYPE_LONG_ARRAY ; </a> 0
<a> for ( long v : ( long [ ] ) value ) { </a> 0
<a> jsonArray . put ( v ) ; </a> 0
<a> } </a> 0
<a> } else if ( value instanceof float [ ] ) { </a> 0
<a> supportedType = TYPE_FLOAT_ARRAY ; </a> 0
<a> for ( float v : ( float [ ] ) value ) { </a> 0
<a> jsonArray . put ( ( double ) v ) ; </a> 0
<a> } </a> 0
<a> } else if ( value instanceof double [ ] ) { </a> 0
<a> supportedType = TYPE_DOUBLE_ARRAY ; </a> 0
<a> for ( double v : ( double [ ] ) value ) { </a> 0
<a> jsonArray . put ( v ) ; </a> 0
<a> } </a> 0
<a> } else if ( value instanceof boolean [ ] ) { </a> 0
<a> supportedType = TYPE_BOOLEAN_ARRAY ; </a> 0
<a> for ( boolean v : ( boolean [ ] ) value ) { </a> 0
<a> jsonArray . put ( v ) ; </a> 0
<a> } </a> 0
<a> } else if ( value instanceof char [ ] ) { </a> 0
<a> supportedType = TYPE_CHAR_ARRAY ; </a> 0
<a> for ( char v : ( char [ ] ) value ) { </a> 0
<a> jsonArray . put ( String . valueOf ( v ) ) ; </a> 0
<a> } </a> 0
<a> } else if ( value instanceof List < ? > ) { </a> 0
<a> supportedType = TYPE_STRING_LIST ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> List < String > stringList = ( List < String > ) value ; </a> 0
<a> for ( String v : stringList ) { </a> 0
<a> jsonArray . put ( ( v == null ) ? JSONObject . NULL : v ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> jsonArray = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( supportedType != null ) { </a> 0
<a> json . put ( JSON_VALUE_TYPE , supportedType ) ; </a> 0
<a> if ( jsonArray != null ) { </a> 0
<a> json . putOpt ( JSON_VALUE , jsonArray ) ; </a> 0
<a> } </a> 0
<a> String jsonString = json . toString ( ) ; </a> 0
<a> editor . putString ( key , jsonString ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void deserializeKey ( String key , Bundle bundle ) </a> 0
<a> throws JSONException { </a> 0
<a> String jsonString = cache . getString ( key , "{}" ) ; </a> 0
<a> JSONObject json = new JSONObject ( jsonString ) ; </a> 0
<a> String valueType = json . getString ( JSON_VALUE_TYPE ) ; </a> 0
<a> if ( valueType . equals ( TYPE_BOOLEAN ) ) { </a> 0
<a> bundle . putBoolean ( key , json . getBoolean ( JSON_VALUE ) ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_BOOLEAN_ARRAY ) ) { </a> 0
<a> JSONArray jsonArray = json . getJSONArray ( JSON_VALUE ) ; </a> 0
<a> boolean [ ] array = new boolean [ jsonArray . length ( ) ] ; </a> 0
<a> for ( int i = 0 ; i < array . length ; i ++ ) { </a> 0
<a> array [ i ] = jsonArray . getBoolean ( i ) ; </a> 0
<a> } </a> 0
<a> bundle . putBooleanArray ( key , array ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_BYTE ) ) { </a> 0
<a> bundle . putByte ( key , ( byte ) json . getInt ( JSON_VALUE ) ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_BYTE_ARRAY ) ) { </a> 0
<a> JSONArray jsonArray = json . getJSONArray ( JSON_VALUE ) ; </a> 0
<a> byte [ ] array = new byte [ jsonArray . length ( ) ] ; </a> 0
<a> for ( int i = 0 ; i < array . length ; i ++ ) { </a> 0
<a> array [ i ] = ( byte ) jsonArray . getInt ( i ) ; </a> 0
<a> } </a> 0
<a> bundle . putByteArray ( key , array ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_SHORT ) ) { </a> 0
<a> bundle . putShort ( key , ( short ) json . getInt ( JSON_VALUE ) ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_SHORT_ARRAY ) ) { </a> 0
<a> JSONArray jsonArray = json . getJSONArray ( JSON_VALUE ) ; </a> 0
<a> short [ ] array = new short [ jsonArray . length ( ) ] ; </a> 0
<a> for ( int i = 0 ; i < array . length ; i ++ ) { </a> 0
<a> array [ i ] = ( short ) jsonArray . getInt ( i ) ; </a> 0
<a> } </a> 0
<a> bundle . putShortArray ( key , array ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_INTEGER ) ) { </a> 0
<a> bundle . putInt ( key , json . getInt ( JSON_VALUE ) ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_INTEGER_ARRAY ) ) { </a> 0
<a> JSONArray jsonArray = json . getJSONArray ( JSON_VALUE ) ; </a> 0
<a> int [ ] array = new int [ jsonArray . length ( ) ] ; </a> 0
<a> for ( int i = 0 ; i < array . length ; i ++ ) { </a> 0
<a> array [ i ] = jsonArray . getInt ( i ) ; </a> 0
<a> } </a> 0
<a> bundle . putIntArray ( key , array ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_LONG ) ) { </a> 0
<a> bundle . putLong ( key , json . getLong ( JSON_VALUE ) ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_LONG_ARRAY ) ) { </a> 0
<a> JSONArray jsonArray = json . getJSONArray ( JSON_VALUE ) ; </a> 0
<a> long [ ] array = new long [ jsonArray . length ( ) ] ; </a> 0
<a> for ( int i = 0 ; i < array . length ; i ++ ) { </a> 0
<a> array [ i ] = jsonArray . getLong ( i ) ; </a> 0
<a> } </a> 0
<a> bundle . putLongArray ( key , array ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_FLOAT ) ) { </a> 0
<a> bundle . putFloat ( key , ( float ) json . getDouble ( JSON_VALUE ) ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_FLOAT_ARRAY ) ) { </a> 0
<a> JSONArray jsonArray = json . getJSONArray ( JSON_VALUE ) ; </a> 0
<a> float [ ] array = new float [ jsonArray . length ( ) ] ; </a> 0
<a> for ( int i = 0 ; i < array . length ; i ++ ) { </a> 0
<a> array [ i ] = ( float ) jsonArray . getDouble ( i ) ; </a> 0
<a> } </a> 0
<a> bundle . putFloatArray ( key , array ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_DOUBLE ) ) { </a> 0
<a> bundle . putDouble ( key , json . getDouble ( JSON_VALUE ) ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_DOUBLE_ARRAY ) ) { </a> 0
<a> JSONArray jsonArray = json . getJSONArray ( JSON_VALUE ) ; </a> 0
<a> double [ ] array = new double [ jsonArray . length ( ) ] ; </a> 0
<a> for ( int i = 0 ; i < array . length ; i ++ ) { </a> 0
<a> array [ i ] = jsonArray . getDouble ( i ) ; </a> 0
<a> } </a> 0
<a> bundle . putDoubleArray ( key , array ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_CHAR ) ) { </a> 0
<a> String charString = json . getString ( JSON_VALUE ) ; </a> 0
<a> if ( charString != null && charString . length ( ) == 1 ) { </a> 0
<a> bundle . putChar ( key , charString . charAt ( 0 ) ) ; </a> 0
<a> } </a> 0
<a> } else if ( valueType . equals ( TYPE_CHAR_ARRAY ) ) { </a> 0
<a> JSONArray jsonArray = json . getJSONArray ( JSON_VALUE ) ; </a> 0
<a> char [ ] array = new char [ jsonArray . length ( ) ] ; </a> 0
<a> for ( int i = 0 ; i < array . length ; i ++ ) { </a> 0
<a> String charString = jsonArray . getString ( i ) ; </a> 0
<a> if ( charString != null && charString . length ( ) == 1 ) { </a> 0
<a> array [ i ] = charString . charAt ( 0 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> bundle . putCharArray ( key , array ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_STRING ) ) { </a> 0
<a> bundle . putString ( key , json . getString ( JSON_VALUE ) ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_STRING_LIST ) ) { </a> 0
<a> JSONArray jsonArray = json . getJSONArray ( JSON_VALUE ) ; </a> 0
<a> int numStrings = jsonArray . length ( ) ; </a> 0
<a> ArrayList < String > stringList = new ArrayList < String > ( numStrings ) ; </a> 0
<a> for ( int i = 0 ; i < numStrings ; i ++ ) { </a> 0
<a> Object jsonStringValue = jsonArray . get ( i ) ; </a> 0
<a> stringList . add ( i , jsonStringValue == JSONObject . NULL ? null : ( String ) jsonStringValue ) ; </a> 0
<a> } </a> 0
<a> bundle . putStringArrayList ( key , stringList ) ; </a> 0
<a> } else if ( valueType . equals ( TYPE_ENUM ) ) { </a> 0
<a> try { </a> 0
<a> String enumType = json . getString ( JSON_VALUE_ENUM_TYPE ) ; </a> 0
<a> @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) </a> 0
<a> Class < ? extends Enum > enumClass = ( Class < ? extends Enum > ) Class . forName ( enumType ) ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> Enum < ? > enumValue = Enum . valueOf ( enumClass , json . getString ( JSON_VALUE ) ) ; </a> 0
<a> bundle . putSerializable ( key , enumValue ) ; </a> 0
<a> } catch ( ClassNotFoundException e ) { </a> 0
<a> } catch ( IllegalArgumentException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import com . facebook . internal . Validate ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . List ; </a> 0
<a> public abstract class TokenCachingStrategy { </a> 0
<a> public static final String TOKEN_KEY = "com.facebook.TokenCachingStrategy.Token" ; </a> 0
<a> public static final String EXPIRATION_DATE_KEY = "com.facebook.TokenCachingStrategy.ExpirationDate" ; </a> 0
<a> public static final String LAST_REFRESH_DATE_KEY = "com.facebook.TokenCachingStrategy.LastRefreshDate" ; </a> 0
<a> public static final String USER_FBID_KEY = "com.facebook.TokenCachingStrategy.UserFBID" ; </a> 0
<a> public static final String TOKEN_SOURCE_KEY = "com.facebook.TokenCachingStrategy.AccessTokenSource" ; </a> 0
<a> public static final String PERMISSIONS_KEY = "com.facebook.TokenCachingStrategy.Permissions" ; </a> 0
<a> private static final long INVALID_BUNDLE_MILLISECONDS = Long . MIN_VALUE ; </a> 0
<a> private static final String IS_SSO_KEY = "com.facebook.TokenCachingStrategy.IsSSO" ; </a> 0
<a> public abstract Bundle load ( ) ; </a> 0
<a> public abstract void save ( Bundle bundle ) ; </a> 0
<a> public abstract void clear ( ) ; </a> 0
<a> public static boolean hasTokenInformation ( Bundle bundle ) { </a> 0
<a> if ( bundle == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> String token = bundle . getString ( TOKEN_KEY ) ; </a> 0
<a> if ( ( token == null ) || ( token . length ( ) == 0 ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> long expiresMilliseconds = bundle . getLong ( EXPIRATION_DATE_KEY , 0L ) ; </a> 0
<a> if ( expiresMilliseconds == 0L ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public static String getToken ( Bundle bundle ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> return bundle . getString ( TOKEN_KEY ) ; </a> 0
<a> } </a> 0
<a> public static void putToken ( Bundle bundle , String value ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> Validate . notNull ( value , "value" ) ; </a> 0
<a> bundle . putString ( TOKEN_KEY , value ) ; </a> 0
<a> } </a> 0
<a> public static Date getExpirationDate ( Bundle bundle ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> return getDate ( bundle , EXPIRATION_DATE_KEY ) ; </a> 0
<a> } </a> 0
<a> public static void putExpirationDate ( Bundle bundle , Date value ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> Validate . notNull ( value , "value" ) ; </a> 0
<a> putDate ( bundle , EXPIRATION_DATE_KEY , value ) ; </a> 0
<a> } </a> 0
<a> public static long getExpirationMilliseconds ( Bundle bundle ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> return bundle . getLong ( EXPIRATION_DATE_KEY ) ; </a> 0
<a> } </a> 0
<a> public static void putExpirationMilliseconds ( Bundle bundle , long value ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> bundle . putLong ( EXPIRATION_DATE_KEY , value ) ; </a> 0
<a> } </a> 0
<a> public static List < String > getPermissions ( Bundle bundle ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> return bundle . getStringArrayList ( PERMISSIONS_KEY ) ; </a> 0
<a> } </a> 0
<a> public static void putPermissions ( Bundle bundle , List < String > value ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> Validate . notNull ( value , "value" ) ; </a> 0
<a> ArrayList < String > arrayList ; </a> 0
<a> if ( value instanceof ArrayList < ? > ) { </a> 0
<a> arrayList = ( ArrayList < String > ) value ; </a> 0
<a> } else { </a> 0
<a> arrayList = new ArrayList < String > ( value ) ; </a> 0
<a> } </a> 0
<a> bundle . putStringArrayList ( PERMISSIONS_KEY , arrayList ) ; </a> 0
<a> } </a> 0
<a> public static AccessTokenSource getSource ( Bundle bundle ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> if ( bundle . containsKey ( TokenCachingStrategy . TOKEN_SOURCE_KEY ) ) { </a> 0
<a> return ( AccessTokenSource ) bundle . getSerializable ( TokenCachingStrategy . TOKEN_SOURCE_KEY ) ; </a> 0
<a> } else { </a> 0
<a> boolean isSSO = bundle . getBoolean ( TokenCachingStrategy . IS_SSO_KEY ) ; </a> 0
<a> return isSSO ? AccessTokenSource . FACEBOOK_APPLICATION_WEB : AccessTokenSource . WEB_VIEW ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void putSource ( Bundle bundle , AccessTokenSource value ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> bundle . putSerializable ( TOKEN_SOURCE_KEY , value ) ; </a> 0
<a> } </a> 0
<a> public static Date getLastRefreshDate ( Bundle bundle ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> return getDate ( bundle , LAST_REFRESH_DATE_KEY ) ; </a> 0
<a> } </a> 0
<a> public static void putLastRefreshDate ( Bundle bundle , Date value ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> Validate . notNull ( value , "value" ) ; </a> 0
<a> putDate ( bundle , LAST_REFRESH_DATE_KEY , value ) ; </a> 0
<a> } </a> 0
<a> public static long getLastRefreshMilliseconds ( Bundle bundle ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> return bundle . getLong ( LAST_REFRESH_DATE_KEY ) ; </a> 0
<a> } </a> 0
<a> public static void putLastRefreshMilliseconds ( Bundle bundle , long value ) { </a> 0
<a> Validate . notNull ( bundle , "bundle" ) ; </a> 0
<a> bundle . putLong ( LAST_REFRESH_DATE_KEY , value ) ; </a> 0
<a> } </a> 0
<a> static Date getDate ( Bundle bundle , String key ) { </a> 0
<a> if ( bundle == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> long n = bundle . getLong ( key , INVALID_BUNDLE_MILLISECONDS ) ; </a> 0
<a> if ( n == INVALID_BUNDLE_MILLISECONDS ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return new Date ( n ) ; </a> 0
<a> } </a> 0
<a> static void putDate ( Bundle bundle , String key , Date date ) { </a> 0
<a> bundle . putLong ( key , date . getTime ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . BroadcastReceiver ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . content . IntentFilter ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . content . LocalBroadcastManager ; </a> 0
<a> public class UiLifecycleHelper { </a> 0
<a> private final static String ACTIVITY_NULL_MESSAGE = "activity cannot be null" ; </a> 0
<a> private final Activity activity ; </a> 0
<a> private final Session . StatusCallback callback ; </a> 0
<a> private final BroadcastReceiver receiver ; </a> 0
<a> private final LocalBroadcastManager broadcastManager ; </a> 0
<a> public UiLifecycleHelper ( Activity activity , Session . StatusCallback callback ) { </a> 0
<a> if ( activity == null ) { </a> 0
<a> throw new IllegalArgumentException ( ACTIVITY_NULL_MESSAGE ) ; </a> 0
<a> } </a> 0
<a> this . activity = activity ; </a> 0
<a> this . callback = callback ; </a> 0
<a> this . receiver = new ActiveSessionBroadcastReceiver ( ) ; </a> 0
<a> this . broadcastManager = LocalBroadcastManager . getInstance ( activity ) ; </a> 0
<a> } </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session == null ) { </a> 0
<a> if ( savedInstanceState != null ) { </a> 0
<a> session = Session . restoreSession ( activity , null , callback , savedInstanceState ) ; </a> 0
<a> } </a> 0
<a> if ( session == null ) { </a> 0
<a> session = new Session ( activity ) ; </a> 0
<a> } </a> 0
<a> Session . setActiveSession ( session ) ; </a> 0
<a> } </a> 0
<a> IntentFilter filter = new IntentFilter ( ) ; </a> 1
<a> filter . addAction ( Session . ACTION_ACTIVE_SESSION_SET ) ; </a> 1
<a> filter . addAction ( Session . ACTION_ACTIVE_SESSION_UNSET ) ; </a> 1
<a> broadcastManager . registerReceiver ( receiver , filter ) ; </a> 1
<a> } </a> 0
<a> public void onResume ( ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session != null ) { </a> 0
<a> if ( callback != null ) { </a> 0
<a> session . addCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> if ( SessionState . CREATED_TOKEN_LOADED . equals ( session . getState ( ) ) ) { </a> 0
<a> session . openForRead ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session != null ) { </a> 0
<a> session . onActivityResult ( activity , requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onSaveInstanceState ( Bundle outState ) { </a> 0
<a> Session . saveSession ( Session . getActiveSession ( ) , outState ) ; </a> 0
<a> } </a> 0
<a> public void onPause ( ) { </a> 0
<a> if ( callback != null ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session != null ) { </a> 0
<a> session . removeCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onDestroy ( ) { </a> 0
<a> broadcastManager . unregisterReceiver ( receiver ) ; </a> 1
<a> } </a> 0
<a> private class ActiveSessionBroadcastReceiver extends BroadcastReceiver { </a> 0
<a> @ Override </a> 0
<a> public void onReceive ( Context context , Intent intent ) { </a> 0
<a> if ( Session . ACTION_ACTIVE_SESSION_SET . equals ( intent . getAction ( ) ) ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session != null && callback != null ) { </a> 0
<a> session . addCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> } else if ( Session . ACTION_ACTIVE_SESSION_UNSET . equals ( intent . getAction ( ) ) ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session != null && callback != null ) { </a> 0
<a> session . removeCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> public class DialogError extends Throwable { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> private int mErrorCode ; </a> 0
<a> private String mFailingUrl ; </a> 0
<a> @ Deprecated </a> 0
<a> public DialogError ( String message , int errorCode , String failingUrl ) { </a> 0
<a> super ( message ) ; </a> 0
<a> mErrorCode = errorCode ; </a> 0
<a> mFailingUrl = failingUrl ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public int getErrorCode ( ) { </a> 0
<a> return mErrorCode ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public String getFailingUrl ( ) { </a> 0
<a> return mFailingUrl ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . Manifest ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . * ; </a> 0
<a> import android . content . pm . PackageInfo ; </a> 0
<a> import android . content . pm . PackageManager ; </a> 0
<a> import android . content . pm . PackageManager . NameNotFoundException ; </a> 0
<a> import android . content . pm . ResolveInfo ; </a> 0
<a> import android . content . pm . Signature ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . os . * ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . Session . StatusCallback ; </a> 0
<a> import java . io . FileNotFoundException ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . lang . ref . WeakReference ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class Facebook { </a> 0
<a> @ Deprecated </a> 0
<a> public static final String REDIRECT_URI = "fbconnect://success" ; </a> 0
<a> @ Deprecated </a> 0
<a> public static final String CANCEL_URI = "fbconnect://cancel" ; </a> 0
<a> @ Deprecated </a> 0
<a> public static final String TOKEN = "access_token" ; </a> 0
<a> @ Deprecated </a> 0
<a> public static final String EXPIRES = "expires_in" ; </a> 0
<a> @ Deprecated </a> 0
<a> public static final String SINGLE_SIGN_ON_DISABLED = "service_disabled" ; </a> 0
<a> @ Deprecated </a> 0
<a> public static final Uri ATTRIBUTION_ID_CONTENT_URI = </a> 0
<a> Uri . parse ( "content://com.facebook.katana.provider.AttributionIdProvider" ) ; </a> 0
<a> @ Deprecated </a> 0
<a> public static final String ATTRIBUTION_ID_COLUMN_NAME = "aid" ; </a> 0
<a> @ Deprecated </a> 0
<a> public static final int FORCE_DIALOG_AUTH = - 1 ; </a> 0
<a> private static final String LOGIN = "oauth" ; </a> 0
<a> private static final int DEFAULT_AUTH_ACTIVITY_CODE = 32665 ; </a> 0
<a> @ Deprecated </a> 0
<a> protected static String DIALOG_BASE_URL = "https://m.facebook.com/dialog/" ; </a> 0
<a> @ Deprecated </a> 0
<a> protected static String GRAPH_BASE_URL = "https://graph.facebook.com/" ; </a> 0
<a> @ Deprecated </a> 0
<a> protected static String RESTSERVER_URL = "https://api.facebook.com/restserver.php" ; </a> 0
<a> private final Object lock = new Object ( ) ; </a> 0
<a> private String accessToken = null ; </a> 0
<a> private long accessExpiresMillisecondsAfterEpoch = 0 ; </a> 0
<a> private long lastAccessUpdateMillisecondsAfterEpoch = 0 ; </a> 0
<a> private String mAppId ; </a> 0
<a> private Activity pendingAuthorizationActivity ; </a> 0
<a> private String [ ] pendingAuthorizationPermissions ; </a> 0
<a> private Session pendingOpeningSession ; </a> 0
<a> private volatile Session session ; </a> 0
<a> private boolean sessionInvalidated ; </a> 0
<a> private SetterTokenCachingStrategy tokenCache ; </a> 0
<a> private volatile Session userSetSession ; </a> 0
<a> final private long REFRESH_TOKEN_BARRIER = 24L * 60L * 60L * 1000L ; </a> 0
<a> @ Deprecated </a> 0
<a> public Facebook ( String appId ) { </a> 0
<a> if ( appId == null ) { </a> 0
<a> throw new IllegalArgumentException ( "You must specify your application ID when instantiating " </a> 0
<a> + "a Facebook object. See README for details." ) ; </a> 0
<a> } </a> 0
<a> mAppId = appId ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void authorize ( Activity activity , final DialogListener listener ) { </a> 0
<a> authorize ( activity , new String [ ] { } , DEFAULT_AUTH_ACTIVITY_CODE , SessionLoginBehavior . SSO_WITH_FALLBACK , </a> 0
<a> listener ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void authorize ( Activity activity , String [ ] permissions , final DialogListener listener ) { </a> 0
<a> authorize ( activity , permissions , DEFAULT_AUTH_ACTIVITY_CODE , SessionLoginBehavior . SSO_WITH_FALLBACK , listener ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void authorize ( Activity activity , String [ ] permissions , int activityCode , final DialogListener listener ) { </a> 0
<a> SessionLoginBehavior behavior = ( activityCode >= 0 ) ? SessionLoginBehavior . SSO_WITH_FALLBACK </a> 0
<a> : SessionLoginBehavior . SUPPRESS_SSO ; </a> 0
<a> authorize ( activity , permissions , activityCode , behavior , listener ) ; </a> 0
<a> } </a> 0
<a> private void authorize ( Activity activity , String [ ] permissions , int activityCode , </a> 0
<a> SessionLoginBehavior behavior , final DialogListener listener ) { </a> 0
<a> checkUserSession ( "authorize" ) ; </a> 0
<a> pendingOpeningSession = new Session . Builder ( activity ) . </a> 0
<a> setApplicationId ( mAppId ) . </a> 0
<a> setTokenCachingStrategy ( getTokenCache ( ) ) . </a> 0
<a> build ( ) ; </a> 0
<a> pendingAuthorizationActivity = activity ; </a> 0
<a> pendingAuthorizationPermissions = ( permissions != null ) ? permissions : new String [ 0 ] ; </a> 0
<a> StatusCallback callback = new StatusCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session callbackSession , SessionState state , Exception exception ) { </a> 0
<a> onSessionCallback ( callbackSession , state , exception , listener ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> Session . OpenRequest openRequest = new Session . OpenRequest ( activity ) . </a> 0
<a> setCallback ( callback ) . </a> 0
<a> setLoginBehavior ( behavior ) . </a> 0
<a> setRequestCode ( activityCode ) . </a> 0
<a> setPermissions ( Arrays . asList ( permissions ) ) ; </a> 0
<a> openSession ( pendingOpeningSession , openRequest , pendingAuthorizationPermissions . length > 0 ) ; </a> 0
<a> } </a> 0
<a> private void openSession ( Session session , Session . OpenRequest openRequest , boolean isPublish ) { </a> 0
<a> openRequest . setIsLegacy ( true ) ; </a> 0
<a> if ( isPublish ) { </a> 0
<a> session . openForPublish ( openRequest ) ; </a> 0
<a> } else { </a> 0
<a> session . openForRead ( openRequest ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> private void onSessionCallback ( Session callbackSession , SessionState state , Exception exception , </a> 0
<a> DialogListener listener ) { </a> 0
<a> Bundle extras = callbackSession . getAuthorizationBundle ( ) ; </a> 0
<a> if ( state == SessionState . OPENED ) { </a> 0
<a> Session sessionToClose = null ; </a> 0
<a> synchronized ( Facebook . this . lock ) { </a> 0
<a> if ( callbackSession != Facebook . this . session ) { </a> 0
<a> sessionToClose = Facebook . this . session ; </a> 0
<a> Facebook . this . session = callbackSession ; </a> 0
<a> Facebook . this . sessionInvalidated = false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( sessionToClose != null ) { </a> 0
<a> sessionToClose . close ( ) ; </a> 0
<a> } </a> 0
<a> listener . onComplete ( extras ) ; </a> 0
<a> } else if ( exception != null ) { </a> 0
<a> if ( exception instanceof FacebookOperationCanceledException ) { </a> 0
<a> listener . onCancel ( ) ; </a> 0
<a> } else if ( ( exception instanceof FacebookAuthorizationException ) && ( extras != null ) </a> 0
<a> && extras . containsKey ( Session . WEB_VIEW_ERROR_CODE_KEY ) </a> 0
<a> && extras . containsKey ( Session . WEB_VIEW_FAILING_URL_KEY ) ) { </a> 0
<a> DialogError error = new DialogError ( exception . getMessage ( ) , </a> 0
<a> extras . getInt ( Session . WEB_VIEW_ERROR_CODE_KEY ) , </a> 0
<a> extras . getString ( Session . WEB_VIEW_FAILING_URL_KEY ) ) ; </a> 0
<a> listener . onError ( error ) ; </a> 0
<a> } else { </a> 0
<a> FacebookError error = new FacebookError ( exception . getMessage ( ) ) ; </a> 0
<a> listener . onFacebookError ( error ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean validateServiceIntent ( Context context , Intent intent ) { </a> 0
<a> ResolveInfo resolveInfo = context . getPackageManager ( ) . resolveService ( intent , 0 ) ; </a> 0
<a> if ( resolveInfo == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return validateAppSignatureForPackage ( context , resolveInfo . serviceInfo . packageName ) ; </a> 0
<a> } </a> 0
<a> private boolean validateAppSignatureForPackage ( Context context , String packageName ) { </a> 0
<a> PackageInfo packageInfo ; </a> 0
<a> try { </a> 0
<a> packageInfo = context . getPackageManager ( ) . getPackageInfo ( packageName , PackageManager . GET_SIGNATURES ) ; </a> 0
<a> } catch ( NameNotFoundException e ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> for ( Signature signature : packageInfo . signatures ) { </a> 0
<a> if ( signature . toCharsString ( ) . equals ( FB_APP_SIGNATURE ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void authorizeCallback ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> checkUserSession ( "authorizeCallback" ) ; </a> 0
<a> Session pending = this . pendingOpeningSession ; </a> 0
<a> if ( pending != null ) { </a> 0
<a> if ( pending . onActivityResult ( this . pendingAuthorizationActivity , requestCode , resultCode , data ) ) { </a> 0
<a> this . pendingOpeningSession = null ; </a> 0
<a> this . pendingAuthorizationActivity = null ; </a> 0
<a> this . pendingAuthorizationPermissions = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public boolean extendAccessToken ( Context context , ServiceListener serviceListener ) { </a> 0
<a> checkUserSession ( "extendAccessToken" ) ; </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . setClassName ( "com.facebook.katana" , "com.facebook.katana.platform.TokenRefreshService" ) ; </a> 0
<a> if ( ! validateServiceIntent ( context , intent ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return context . bindService ( intent , new TokenRefreshServiceConnection ( context , serviceListener ) , </a> 0
<a> Context . BIND_AUTO_CREATE ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public boolean extendAccessTokenIfNeeded ( Context context , ServiceListener serviceListener ) { </a> 0
<a> checkUserSession ( "extendAccessTokenIfNeeded" ) ; </a> 0
<a> if ( shouldExtendAccessToken ( ) ) { </a> 0
<a> return extendAccessToken ( context , serviceListener ) ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public boolean shouldExtendAccessToken ( ) { </a> 0
<a> checkUserSession ( "shouldExtendAccessToken" ) ; </a> 0
<a> return isSessionValid ( ) </a> 0
<a> && ( System . currentTimeMillis ( ) - lastAccessUpdateMillisecondsAfterEpoch >= REFRESH_TOKEN_BARRIER ) ; </a> 0
<a> } </a> 0
<a> private class TokenRefreshServiceConnection implements ServiceConnection { </a> 0
<a> final Messenger messageReceiver = new Messenger ( </a> 0
<a> new TokenRefreshConnectionHandler ( Facebook . this , this ) ) ; </a> 0
<a> final ServiceListener serviceListener ; </a> 0
<a> final Context applicationsContext ; </a> 0
<a> Messenger messageSender = null ; </a> 0
<a> public TokenRefreshServiceConnection ( Context applicationsContext , ServiceListener serviceListener ) { </a> 0
<a> this . applicationsContext = applicationsContext ; </a> 0
<a> this . serviceListener = serviceListener ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onServiceConnected ( ComponentName className , IBinder service ) { </a> 0
<a> messageSender = new Messenger ( service ) ; </a> 0
<a> refreshToken ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onServiceDisconnected ( ComponentName arg ) { </a> 0
<a> serviceListener . onError ( new Error ( "Service disconnected" ) ) ; </a> 0
<a> applicationsContext . unbindService ( TokenRefreshServiceConnection . this ) ; </a> 0
<a> } </a> 0
<a> private void refreshToken ( ) { </a> 0
<a> Bundle requestData = new Bundle ( ) ; </a> 0
<a> requestData . putString ( TOKEN , accessToken ) ; </a> 0
<a> Message request = Message . obtain ( ) ; </a> 0
<a> request . setData ( requestData ) ; </a> 0
<a> request . replyTo = messageReceiver ; </a> 0
<a> try { </a> 0
<a> messageSender . send ( request ) ; </a> 0
<a> } catch ( RemoteException e ) { </a> 0
<a> serviceListener . onError ( new Error ( "Service connection error" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class TokenRefreshConnectionHandler extends Handler { </a> 0
<a> WeakReference < Facebook > facebookWeakReference ; </a> 0
<a> WeakReference < TokenRefreshServiceConnection > connectionWeakReference ; </a> 0
<a> TokenRefreshConnectionHandler ( Facebook facebook , TokenRefreshServiceConnection connection ) { </a> 0
<a> super ( ) ; </a> 0
<a> facebookWeakReference = new WeakReference < Facebook > ( facebook ) ; </a> 0
<a> connectionWeakReference = new WeakReference < TokenRefreshServiceConnection > ( connection ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public void handleMessage ( Message msg ) { </a> 0
<a> Facebook facebook = facebookWeakReference . get ( ) ; </a> 0
<a> TokenRefreshServiceConnection connection = connectionWeakReference . get ( ) ; </a> 0
<a> if ( facebook == null || connection == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> String token = msg . getData ( ) . getString ( TOKEN ) ; </a> 0
<a> long expiresAtMsecFromEpoch = msg . getData ( ) . getLong ( EXPIRES ) * 1000L ; </a> 0
<a> if ( token != null ) { </a> 0
<a> facebook . setAccessToken ( token ) ; </a> 0
<a> facebook . setAccessExpires ( expiresAtMsecFromEpoch ) ; </a> 0
<a> Session refreshSession = facebook . session ; </a> 0
<a> if ( refreshSession != null ) { </a> 0
<a> LegacyHelper . extendTokenCompleted ( refreshSession , msg . getData ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( connection . serviceListener != null ) { </a> 0
<a> Bundle resultBundle = ( Bundle ) msg . getData ( ) . clone ( ) ; </a> 0
<a> resultBundle . putLong ( EXPIRES , expiresAtMsecFromEpoch ) ; </a> 0
<a> connection . serviceListener . onComplete ( resultBundle ) ; </a> 0
<a> } </a> 0
<a> } else if ( connection . serviceListener != null ) { </a> 0
<a> String error = msg . getData ( ) . getString ( "error" ) ; </a> 0
<a> if ( msg . getData ( ) . containsKey ( "error_code" ) ) { </a> 0
<a> int errorCode = msg . getData ( ) . getInt ( "error_code" ) ; </a> 0
<a> connection . serviceListener . onFacebookError ( new FacebookError ( error , null , errorCode ) ) ; </a> 0
<a> } else { </a> 0
<a> connection . serviceListener . onError ( new Error ( error != null ? error : "Unknown service error" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( connection != null ) { </a> 0
<a> connection . applicationsContext . unbindService ( connection ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public String logout ( Context context ) throws MalformedURLException , IOException { </a> 0
<a> return logoutImpl ( context ) ; </a> 0
<a> } </a> 0
<a> String logoutImpl ( Context context ) throws MalformedURLException , IOException { </a> 0
<a> checkUserSession ( "logout" ) ; </a> 0
<a> Bundle b = new Bundle ( ) ; </a> 0
<a> b . putString ( "method" , "auth.expireSession" ) ; </a> 0
<a> String response = request ( b ) ; </a> 0
<a> long currentTimeMillis = System . currentTimeMillis ( ) ; </a> 0
<a> Session sessionToClose = null ; </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> sessionToClose = session ; </a> 0
<a> session = null ; </a> 0
<a> accessToken = null ; </a> 0
<a> accessExpiresMillisecondsAfterEpoch = 0 ; </a> 0
<a> lastAccessUpdateMillisecondsAfterEpoch = currentTimeMillis ; </a> 0
<a> sessionInvalidated = false ; </a> 0
<a> } </a> 0
<a> if ( sessionToClose != null ) { </a> 0
<a> sessionToClose . closeAndClearTokenInformation ( ) ; </a> 0
<a> } </a> 0
<a> return response ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public String request ( Bundle parameters ) throws MalformedURLException , IOException { </a> 0
<a> if ( ! parameters . containsKey ( "method" ) ) { </a> 0
<a> throw new IllegalArgumentException ( "API method must be specified. " </a> 0
<a> + "(parameters must contain key \"method\" and value). See" </a> 0
<a> + " http://developers.facebook.com/docs/reference/rest/" ) ; </a> 0
<a> } </a> 0
<a> return requestImpl ( null , parameters , "GET" ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public String request ( String graphPath ) throws MalformedURLException , IOException { </a> 0
<a> return requestImpl ( graphPath , new Bundle ( ) , "GET" ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public String request ( String graphPath , Bundle parameters ) throws MalformedURLException , IOException { </a> 0
<a> return requestImpl ( graphPath , parameters , "GET" ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public String request ( String graphPath , Bundle params , String httpMethod ) throws FileNotFoundException , </a> 0
<a> MalformedURLException , IOException { </a> 0
<a> return requestImpl ( graphPath , params , httpMethod ) ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> String requestImpl ( String graphPath , Bundle params , String httpMethod ) throws FileNotFoundException , </a> 0
<a> MalformedURLException , IOException { </a> 0
<a> params . putString ( "format" , "json" ) ; </a> 0
<a> if ( isSessionValid ( ) ) { </a> 0
<a> params . putString ( TOKEN , getAccessToken ( ) ) ; </a> 0
<a> } </a> 0
<a> String url = ( graphPath != null ) ? GRAPH_BASE_URL + graphPath : RESTSERVER_URL ; </a> 0
<a> return Util . openUrl ( url , httpMethod , params ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void dialog ( Context context , String action , DialogListener listener ) { </a> 0
<a> dialog ( context , action , new Bundle ( ) , listener ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void dialog ( Context context , String action , Bundle parameters , final DialogListener listener ) { </a> 0
<a> parameters . putString ( "display" , "touch" ) ; </a> 0
<a> parameters . putString ( "redirect_uri" , REDIRECT_URI ) ; </a> 0
<a> if ( action . equals ( LOGIN ) ) { </a> 0
<a> parameters . putString ( "type" , "user_agent" ) ; </a> 0
<a> parameters . putString ( "client_id" , mAppId ) ; </a> 0
<a> } else { </a> 0
<a> parameters . putString ( "app_id" , mAppId ) ; </a> 0
<a> if ( isSessionValid ( ) ) { </a> 0
<a> parameters . putString ( TOKEN , getAccessToken ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( context . checkCallingOrSelfPermission ( Manifest . permission . INTERNET ) != PackageManager . PERMISSION_GRANTED ) { </a> 0
<a> Util . showAlert ( context , "Error" , "Application requires permission to access the Internet" ) ; </a> 0
<a> } else { </a> 0
<a> new FbDialog ( context , action , parameters , listener ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public boolean isSessionValid ( ) { </a> 0
<a> return ( getAccessToken ( ) != null ) </a> 0
<a> && ( ( getAccessExpires ( ) == 0 ) || ( System . currentTimeMillis ( ) < getAccessExpires ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void setSession ( Session session ) { </a> 0
<a> if ( session == null ) { </a> 0
<a> throw new IllegalArgumentException ( "session cannot be null" ) ; </a> 0
<a> } </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> this . userSetSession = session ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void checkUserSession ( String methodName ) { </a> 0
<a> if ( userSetSession != null ) { </a> 0
<a> throw new UnsupportedOperationException ( </a> 0
<a> String . format ( "Cannot call %s after setSession has been called." , methodName ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public final Session getSession ( ) { </a> 0
<a> while ( true ) { </a> 0
<a> String cachedToken = null ; </a> 0
<a> Session oldSession = null ; </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> if ( userSetSession != null ) { </a> 0
<a> return userSetSession ; </a> 0
<a> } </a> 0
<a> if ( ( session != null ) || ! sessionInvalidated ) { </a> 0
<a> return session ; </a> 0
<a> } </a> 0
<a> cachedToken = accessToken ; </a> 0
<a> oldSession = session ; </a> 0
<a> } </a> 0
<a> if ( cachedToken == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> List < String > permissions ; </a> 0
<a> if ( oldSession != null ) { </a> 0
<a> permissions = oldSession . getPermissions ( ) ; </a> 0
<a> } else if ( pendingAuthorizationPermissions != null ) { </a> 0
<a> permissions = Arrays . asList ( pendingAuthorizationPermissions ) ; </a> 0
<a> } else { </a> 0
<a> permissions = Collections . < String > emptyList ( ) ; </a> 0
<a> } </a> 0
<a> Session newSession = new Session . Builder ( pendingAuthorizationActivity ) . </a> 0
<a> setApplicationId ( mAppId ) . </a> 0
<a> setTokenCachingStrategy ( getTokenCache ( ) ) . </a> 0
<a> build ( ) ; </a> 0
<a> if ( newSession . getState ( ) != SessionState . CREATED_TOKEN_LOADED ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> Session . OpenRequest openRequest = </a> 0
<a> new Session . OpenRequest ( pendingAuthorizationActivity ) . setPermissions ( permissions ) ; </a> 0
<a> openSession ( newSession , openRequest , ! permissions . isEmpty ( ) ) ; </a> 0
<a> Session invalidatedSession = null ; </a> 0
<a> Session returnSession = null ; </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> if ( sessionInvalidated || ( session == null ) ) { </a> 0
<a> invalidatedSession = session ; </a> 0
<a> returnSession = session = newSession ; </a> 0
<a> sessionInvalidated = false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( invalidatedSession != null ) { </a> 0
<a> invalidatedSession . close ( ) ; </a> 0
<a> } </a> 0
<a> if ( returnSession != null ) { </a> 0
<a> return returnSession ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public String getAccessToken ( ) { </a> 0
<a> Session s = getSession ( ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> return s . getAccessToken ( ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public long getAccessExpires ( ) { </a> 0
<a> Session s = getSession ( ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> return s . getExpirationDate ( ) . getTime ( ) ; </a> 0
<a> } else { </a> 0
<a> return accessExpiresMillisecondsAfterEpoch ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public long getLastAccessUpdate ( ) { </a> 0
<a> return lastAccessUpdateMillisecondsAfterEpoch ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void setTokenFromCache ( String accessToken , long accessExpires , long lastAccessUpdate ) { </a> 0
<a> checkUserSession ( "setTokenFromCache" ) ; </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> this . accessToken = accessToken ; </a> 0
<a> accessExpiresMillisecondsAfterEpoch = accessExpires ; </a> 0
<a> lastAccessUpdateMillisecondsAfterEpoch = lastAccessUpdate ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void setAccessToken ( String token ) { </a> 0
<a> checkUserSession ( "setAccessToken" ) ; </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> accessToken = token ; </a> 0
<a> lastAccessUpdateMillisecondsAfterEpoch = System . currentTimeMillis ( ) ; </a> 0
<a> sessionInvalidated = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void setAccessExpires ( long timestampInMsec ) { </a> 0
<a> checkUserSession ( "setAccessExpires" ) ; </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> accessExpiresMillisecondsAfterEpoch = timestampInMsec ; </a> 0
<a> lastAccessUpdateMillisecondsAfterEpoch = System . currentTimeMillis ( ) ; </a> 0
<a> sessionInvalidated = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void setAccessExpiresIn ( String expiresInSecsFromNow ) { </a> 0
<a> checkUserSession ( "setAccessExpiresIn" ) ; </a> 0
<a> if ( expiresInSecsFromNow != null ) { </a> 0
<a> long expires = expiresInSecsFromNow . equals ( "0" ) ? 0 : System . currentTimeMillis ( ) </a> 0
<a> + Long . parseLong ( expiresInSecsFromNow ) * 1000L ; </a> 0
<a> setAccessExpires ( expires ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public String getAppId ( ) { </a> 0
<a> return mAppId ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void setAppId ( String appId ) { </a> 0
<a> checkUserSession ( "setAppId" ) ; </a> 0
<a> synchronized ( this . lock ) { </a> 0
<a> mAppId = appId ; </a> 0
<a> sessionInvalidated = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private TokenCachingStrategy getTokenCache ( ) { </a> 0
<a> if ( tokenCache == null ) { </a> 1
<a> tokenCache = new SetterTokenCachingStrategy ( ) ; </a> 0
<a> } </a> 0
<a> return tokenCache ; </a> 1
<a> } </a> 1
<a> private static String [ ] stringArray ( List < String > list ) { </a> 1
<a> String [ ] array = new String [ list . size ( ) ] ; </a> 1
<a> if ( list != null ) { </a> 0
<a> for ( int i = 0 ; i < array . length ; i ++ ) { </a> 0
<a> array [ i ] = list . get ( i ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return array ; </a> 0
<a> } </a> 0
<a> private static List < String > stringList ( String [ ] array ) { </a> 0
<a> if ( array != null ) { </a> 0
<a> return Arrays . asList ( array ) ; </a> 0
<a> } else { </a> 0
<a> return Collections . emptyList ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class SetterTokenCachingStrategy extends TokenCachingStrategy { </a> 0
<a> @ Override </a> 0
<a> public Bundle load ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> if ( accessToken != null ) { </a> 0
<a> TokenCachingStrategy . putToken ( bundle , accessToken ) ; </a> 0
<a> TokenCachingStrategy . putExpirationMilliseconds ( bundle , accessExpiresMillisecondsAfterEpoch ) ; </a> 0
<a> TokenCachingStrategy . putPermissions ( bundle , stringList ( pendingAuthorizationPermissions ) ) ; </a> 0
<a> TokenCachingStrategy . putSource ( bundle , AccessTokenSource . WEB_VIEW ) ; </a> 0
<a> TokenCachingStrategy . putLastRefreshMilliseconds ( bundle , lastAccessUpdateMillisecondsAfterEpoch ) ; </a> 0
<a> } </a> 0
<a> return bundle ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void save ( Bundle bundle ) { </a> 0
<a> accessToken = TokenCachingStrategy . getToken ( bundle ) ; </a> 0
<a> accessExpiresMillisecondsAfterEpoch = TokenCachingStrategy . getExpirationMilliseconds ( bundle ) ; </a> 0
<a> pendingAuthorizationPermissions = stringArray ( TokenCachingStrategy . getPermissions ( bundle ) ) ; </a> 0
<a> lastAccessUpdateMillisecondsAfterEpoch = TokenCachingStrategy . getLastRefreshMilliseconds ( bundle ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clear ( ) { </a> 0
<a> accessToken = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static String getAttributionId ( ContentResolver contentResolver ) { </a> 0
<a> return Settings . getAttributionId ( contentResolver ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public boolean getShouldAutoPublishInstall ( ) { </a> 0
<a> return Settings . getShouldAutoPublishInstall ( ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public void setShouldAutoPublishInstall ( boolean value ) { </a> 0
<a> Settings . setShouldAutoPublishInstall ( value ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public boolean publishInstall ( final Context context ) { </a> 0
<a> Settings . publishInstallAsync ( context , mAppId ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> public static interface DialogListener { </a> 0
<a> public void onComplete ( Bundle values ) ; </a> 0
<a> public void onFacebookError ( FacebookError e ) ; </a> 0
<a> public void onError ( DialogError e ) ; </a> 0
<a> public void onCancel ( ) ; </a> 0
<a> } </a> 0
<a> public static interface ServiceListener { </a> 0
<a> public void onComplete ( Bundle values ) ; </a> 0
<a> public void onFacebookError ( FacebookError e ) ; </a> 0
<a> public void onError ( Error e ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static final String FB_APP_SIGNATURE = </a> 0
<a> "30820268308201d102044a9c4610300d06092a864886f70d0101040500307a310" </a> 0
<a> + "b3009060355040613025553310b30090603550408130243413112301006035504" </a> 0
<a> + "07130950616c6f20416c746f31183016060355040a130f46616365626f6f6b204" </a> 0
<a> + "d6f62696c653111300f060355040b130846616365626f6f6b311d301b06035504" </a> 0
<a> + "03131446616365626f6f6b20436f72706f726174696f6e3020170d30393038333" </a> 0
<a> + "13231353231365a180f32303530303932353231353231365a307a310b30090603" </a> 0
<a> + "55040613025553310b30090603550408130243413112301006035504071309506" </a> 0
<a> + "16c6f20416c746f31183016060355040a130f46616365626f6f6b204d6f62696c" </a> 0
<a> + "653111300f060355040b130846616365626f6f6b311d301b06035504031314466" </a> 0
<a> + "16365626f6f6b20436f72706f726174696f6e30819f300d06092a864886f70d01" </a> 0
<a> + "0101050003818d0030818902818100c207d51df8eb8c97d93ba0c8c1002c928fa" </a> 0
<a> + "b00dc1b42fca5e66e99cc3023ed2d214d822bc59e8e35ddcf5f44c7ae8ade50d7" </a> 0
<a> + "e0c434f500e6c131f4a2834f987fc46406115de2018ebbb0d5a3c261bd97581cc" </a> 0
<a> + "fef76afc7135a6d59e8855ecd7eacc8f8737e794c60a761c536b72b11fac8e603" </a> 0
<a> + "f5da1a2d54aa103b8a13c0dbc10203010001300d06092a864886f70d010104050" </a> 0
<a> + "0038181005ee9be8bcbb250648d3b741290a82a1c9dc2e76a0af2f2228f1d9f9c" </a> 0
<a> + "4007529c446a70175c5a900d5141812866db46be6559e2141616483998211f4a6" </a> 0
<a> + "73149fb2232a10d247663b26a9031e15f84bc1c74d141ff98a02d76f85b2c8ab2" </a> 0
<a> + "571b6469b232d8e768a7f7ca04f7abe4a775615916c07940656b58717457b42bd" </a> 0
<a> + "928a2" ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> public class FacebookError extends RuntimeException { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> private int mErrorCode = 0 ; </a> 0
<a> private String mErrorType ; </a> 0
<a> @ Deprecated </a> 0
<a> public FacebookError ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public FacebookError ( String message , String type , int code ) { </a> 0
<a> super ( message ) ; </a> 0
<a> mErrorType = type ; </a> 0
<a> mErrorCode = code ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public int getErrorCode ( ) { </a> 0
<a> return mErrorCode ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public String getErrorType ( ) { </a> 0
<a> return mErrorType ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . android . Facebook . DialogListener ; </a> 0
<a> import com . facebook . widget . WebDialog ; </a> 0
<a> @ Deprecated </a> 0
<a> public class FbDialog extends WebDialog { </a> 0
<a> private DialogListener mListener ; </a> 0
<a> public FbDialog ( Context context , String url , DialogListener listener ) { </a> 0
<a> this ( context , url , listener , DEFAULT_THEME ) ; </a> 0
<a> } </a> 0
<a> public FbDialog ( Context context , String url , DialogListener listener , int theme ) { </a> 0
<a> super ( context , url , theme ) ; </a> 0
<a> setDialogListener ( listener ) ; </a> 0
<a> } </a> 0
<a> public FbDialog ( Context context , String action , Bundle parameters , DialogListener listener ) { </a> 0
<a> super ( context , action , parameters , DEFAULT_THEME , null ) ; </a> 0
<a> setDialogListener ( listener ) ; </a> 0
<a> } </a> 0
<a> public FbDialog ( Context context , String action , Bundle parameters , DialogListener listener , </a> 0
<a> int theme ) { </a> 0
<a> super ( context , action , parameters , theme , null ) ; </a> 0
<a> setDialogListener ( listener ) ; </a> 0
<a> } </a> 0
<a> private void setDialogListener ( DialogListener listener ) { </a> 0
<a> this . mListener = listener ; </a> 0
<a> setOnCompleteListener ( new OnCompleteListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( Bundle values , FacebookException error ) { </a> 0
<a> callDialogListener ( values , error ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private void callDialogListener ( Bundle values , FacebookException error ) { </a> 0
<a> if ( mListener == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( values != null ) { </a> 0
<a> mListener . onComplete ( values ) ; </a> 0
<a> } else { </a> 0
<a> if ( error instanceof FacebookDialogException ) { </a> 0
<a> FacebookDialogException facebookDialogException = ( FacebookDialogException ) error ; </a> 0
<a> DialogError dialogError = new DialogError ( facebookDialogException . getMessage ( ) , </a> 0
<a> facebookDialogException . getErrorCode ( ) , facebookDialogException . getFailingUrl ( ) ) ; </a> 0
<a> mListener . onError ( dialogError ) ; </a> 0
<a> } else if ( error instanceof FacebookOperationCanceledException ) { </a> 0
<a> mListener . onCancel ( ) ; </a> 0
<a> } else { </a> 0
<a> FacebookError facebookError = new FacebookError ( error . getMessage ( ) ) ; </a> 0
<a> mListener . onFacebookError ( facebookError ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . AlertDialog . Builder ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . io . * ; </a> 0
<a> import java . net . * ; </a> 0
<a> public final class Util { </a> 0
<a> private final static String UTF8 = "UTF-8" ; </a> 0
<a> @ Deprecated </a> 0
<a> public static String encodePostBody ( Bundle parameters , String boundary ) { </a> 0
<a> if ( parameters == null ) return "" ; </a> 0
<a> StringBuilder sb = new StringBuilder ( ) ; </a> 0
<a> for ( String key : parameters . keySet ( ) ) { </a> 0
<a> Object parameter = parameters . get ( key ) ; </a> 0
<a> if ( ! ( parameter instanceof String ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> sb . append ( "Content-Disposition: form-data; name=\"" + key + </a> 0
<a> "\"\r\n\r\n" + ( String ) parameter ) ; </a> 0
<a> sb . append ( "\r\n" + "--" + boundary + "\r\n" ) ; </a> 0
<a> } </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static String encodeUrl ( Bundle parameters ) { </a> 0
<a> if ( parameters == null ) { </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> StringBuilder sb = new StringBuilder ( ) ; </a> 0
<a> boolean first = true ; </a> 0
<a> for ( String key : parameters . keySet ( ) ) { </a> 0
<a> Object parameter = parameters . get ( key ) ; </a> 0
<a> if ( ! ( parameter instanceof String ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> if ( first ) first = false ; else sb . append ( "&" ) ; </a> 0
<a> sb . append ( URLEncoder . encode ( key ) + "=" + </a> 0
<a> URLEncoder . encode ( parameters . getString ( key ) ) ) ; </a> 0
<a> } </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static Bundle decodeUrl ( String s ) { </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> String array [ ] = s . split ( "&" ) ; </a> 0
<a> for ( String parameter : array ) { </a> 0
<a> String v [ ] = parameter . split ( "=" ) ; </a> 0
<a> try { </a> 0
<a> if ( v . length == 2 ) { </a> 0
<a> params . putString ( URLDecoder . decode ( v [ 0 ] , UTF8 ) , </a> 0
<a> URLDecoder . decode ( v [ 1 ] , UTF8 ) ) ; </a> 0
<a> } else if ( v . length == 1 ) { </a> 0
<a> params . putString ( URLDecoder . decode ( v [ 0 ] , UTF8 ) , "" ) ; </a> 0
<a> } </a> 0
<a> } catch ( UnsupportedEncodingException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return params ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static Bundle parseUrl ( String url ) { </a> 0
<a> url = url . replace ( "fbconnect" , "http" ) ; </a> 0
<a> try { </a> 0
<a> URL u = new URL ( url ) ; </a> 0
<a> Bundle b = decodeUrl ( u . getQuery ( ) ) ; </a> 0
<a> b . putAll ( decodeUrl ( u . getRef ( ) ) ) ; </a> 0
<a> return b ; </a> 0
<a> } catch ( MalformedURLException e ) { </a> 0
<a> return new Bundle ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static String openUrl ( String url , String method , Bundle params ) </a> 0
<a> throws MalformedURLException , IOException { </a> 0
<a> String strBoundary = "3i2ndDfv2rTHiSisAbouNdArYfORhtTPEefj3q2f" ; </a> 0
<a> String endLine = "\r\n" ; </a> 0
<a> OutputStream os ; </a> 0
<a> if ( method . equals ( "GET" ) ) { </a> 0
<a> url = url + "?" + encodeUrl ( params ) ; </a> 0
<a> } </a> 0
<a> Utility . logd ( "Facebook-Util" , method + " URL: " + url ) ; </a> 0
<a> HttpURLConnection conn = </a> 0
<a> ( HttpURLConnection ) new URL ( url ) . openConnection ( ) ; </a> 0
<a> conn . setRequestProperty ( "User-Agent" , System . getProperties ( ) . </a> 0
<a> getProperty ( "http.agent" ) + " FacebookAndroidSDK" ) ; </a> 0
<a> if ( ! method . equals ( "GET" ) ) { </a> 0
<a> Bundle dataparams = new Bundle ( ) ; </a> 0
<a> for ( String key : params . keySet ( ) ) { </a> 0
<a> Object parameter = params . get ( key ) ; </a> 0
<a> if ( parameter instanceof byte [ ] ) { </a> 0
<a> dataparams . putByteArray ( key , ( byte [ ] ) parameter ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! params . containsKey ( "method" ) ) { </a> 0
<a> params . putString ( "method" , method ) ; </a> 0
<a> } </a> 0
<a> if ( params . containsKey ( "access_token" ) ) { </a> 0
<a> String decoded_token = </a> 0
<a> URLDecoder . decode ( params . getString ( "access_token" ) ) ; </a> 0
<a> params . putString ( "access_token" , decoded_token ) ; </a> 0
<a> } </a> 0
<a> conn . setRequestMethod ( "POST" ) ; </a> 0
<a> conn . setRequestProperty ( </a> 0
<a> "Content-Type" , </a> 0
<a> "multipart/form-data;boundary=" + strBoundary ) ; </a> 0
<a> conn . setDoOutput ( true ) ; </a> 0
<a> conn . setDoInput ( true ) ; </a> 0
<a> conn . setRequestProperty ( "Connection" , "Keep-Alive" ) ; </a> 0
<a> conn . connect ( ) ; </a> 0
<a> os = new BufferedOutputStream ( conn . getOutputStream ( ) ) ; </a> 0
<a> os . write ( ( "--" + strBoundary + endLine ) . getBytes ( ) ) ; </a> 0
<a> os . write ( ( encodePostBody ( params , strBoundary ) ) . getBytes ( ) ) ; </a> 0
<a> os . write ( ( endLine + "--" + strBoundary + endLine ) . getBytes ( ) ) ; </a> 0
<a> if ( ! dataparams . isEmpty ( ) ) { </a> 0
<a> for ( String key : dataparams . keySet ( ) ) { </a> 0
<a> os . write ( ( "Content-Disposition: form-data; filename=\"" + key + "\"" + endLine ) . getBytes ( ) ) ; </a> 0
<a> os . write ( ( "Content-Type: content/unknown" + endLine + endLine ) . getBytes ( ) ) ; </a> 0
<a> os . write ( dataparams . getByteArray ( key ) ) ; </a> 0
<a> os . write ( ( endLine + "--" + strBoundary + endLine ) . getBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> os . flush ( ) ; </a> 0
<a> } </a> 0
<a> String response = "" ; </a> 0
<a> try { </a> 0
<a> response = read ( conn . getInputStream ( ) ) ; </a> 0
<a> } catch ( FileNotFoundException e ) { </a> 0
<a> response = read ( conn . getErrorStream ( ) ) ; </a> 0
<a> } </a> 0
<a> return response ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> private static String read ( InputStream in ) throws IOException { </a> 0
<a> StringBuilder sb = new StringBuilder ( ) ; </a> 0
<a> BufferedReader r = new BufferedReader ( new InputStreamReader ( in ) , 1000 ) ; </a> 0
<a> for ( String line = r . readLine ( ) ; line != null ; line = r . readLine ( ) ) { </a> 0
<a> sb . append ( line ) ; </a> 0
<a> } </a> 0
<a> in . close ( ) ; </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static JSONObject parseJson ( String response ) </a> 0
<a> throws JSONException , FacebookError { </a> 0
<a> if ( response . equals ( "false" ) ) { </a> 0
<a> throw new FacebookError ( "request failed" ) ; </a> 0
<a> } </a> 0
<a> if ( response . equals ( "true" ) ) { </a> 0
<a> response = "{value : true}" ; </a> 0
<a> } </a> 0
<a> JSONObject json = new JSONObject ( response ) ; </a> 0
<a> if ( json . has ( "error" ) ) { </a> 0
<a> JSONObject error = json . getJSONObject ( "error" ) ; </a> 0
<a> throw new FacebookError ( </a> 0
<a> error . getString ( "message" ) , error . getString ( "type" ) , 0 ) ; </a> 0
<a> } </a> 0
<a> if ( json . has ( "error_code" ) && json . has ( "error_msg" ) ) { </a> 0
<a> throw new FacebookError ( json . getString ( "error_msg" ) , "" , </a> 0
<a> Integer . parseInt ( json . getString ( "error_code" ) ) ) ; </a> 0
<a> } </a> 0
<a> if ( json . has ( "error_code" ) ) { </a> 0
<a> throw new FacebookError ( "request failed" , "" , </a> 0
<a> Integer . parseInt ( json . getString ( "error_code" ) ) ) ; </a> 0
<a> } </a> 0
<a> if ( json . has ( "error_msg" ) ) { </a> 0
<a> throw new FacebookError ( json . getString ( "error_msg" ) ) ; </a> 0
<a> } </a> 0
<a> if ( json . has ( "error_reason" ) ) { </a> 0
<a> throw new FacebookError ( json . getString ( "error_reason" ) ) ; </a> 0
<a> } </a> 0
<a> return json ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static void showAlert ( Context context , String title , String text ) { </a> 0
<a> Builder alertBuilder = new Builder ( context ) ; </a> 0
<a> alertBuilder . setTitle ( title ) ; </a> 0
<a> alertBuilder . setMessage ( text ) ; </a> 0
<a> alertBuilder . create ( ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . internal ; </a> 0
<a> import com . facebook . Request ; </a> 0
<a> import com . facebook . RequestBatch ; </a> 0
<a> public class CacheableRequestBatch extends RequestBatch { </a> 0
<a> private String cacheKey ; </a> 0
<a> private boolean forceRoundTrip ; </a> 0
<a> public CacheableRequestBatch ( ) { </a> 0
<a> } </a> 0
<a> public CacheableRequestBatch ( Request ... requests ) { </a> 0
<a> super ( requests ) ; </a> 0
<a> } </a> 0
<a> public final String getCacheKeyOverride ( ) { </a> 0
<a> return cacheKey ; </a> 0
<a> } </a> 0
<a> public final void setCacheKeyOverride ( String cacheKey ) { </a> 0
<a> this . cacheKey = cacheKey ; </a> 0
<a> } </a> 0
<a> public final boolean getForceRoundTrip ( ) { </a> 0
<a> return forceRoundTrip ; </a> 0
<a> } </a> 0
<a> public final void setForceRoundTrip ( boolean forceRoundTrip ) { </a> 0
<a> this . forceRoundTrip = forceRoundTrip ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . internal ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import com . facebook . LoggingBehavior ; </a> 0
<a> import com . facebook . Settings ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import org . json . JSONTokener ; </a> 0
<a> import java . io . * ; </a> 0
<a> import java . security . InvalidParameterException ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . PriorityQueue ; </a> 0
<a> import java . util . concurrent . atomic . AtomicLong ; </a> 0
<a> public final class FileLruCache { </a> 0
<a> static final String TAG = FileLruCache . class . getSimpleName ( ) ; </a> 0
<a> private static final String HEADER_CACHEKEY_KEY = "key" ; </a> 0
<a> private static final String HEADER_CACHE_CONTENT_TAG_KEY = "tag" ; </a> 0
<a> private static final AtomicLong bufferIndex = new AtomicLong ( ) ; </a> 0
<a> private final String tag ; </a> 0
<a> private final Limits limits ; </a> 0
<a> private final File directory ; </a> 0
<a> private boolean isTrimPending ; </a> 0
<a> private final Object lock ; </a> 0
<a> public FileLruCache ( Context context , String tag , Limits limits ) { </a> 0
<a> this . tag = tag ; </a> 0
<a> this . limits = limits ; </a> 0
<a> this . directory = new File ( context . getCacheDir ( ) , tag ) ; </a> 0
<a> this . lock = new Object ( ) ; </a> 0
<a> this . directory . mkdirs ( ) ; </a> 0
<a> BufferFile . deleteAll ( this . directory ) ; </a> 0
<a> } </a> 0
<a> public void clearForTest ( ) throws IOException { </a> 0
<a> for ( File file : this . directory . listFiles ( ) ) { </a> 0
<a> file . delete ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> long sizeInBytesForTest ( ) { </a> 0
<a> synchronized ( lock ) { </a> 0
<a> while ( isTrimPending ) { </a> 0
<a> try { </a> 0
<a> lock . wait ( ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> File [ ] files = this . directory . listFiles ( ) ; </a> 0
<a> long total = 0 ; </a> 0
<a> for ( File file : files ) { </a> 0
<a> total += file . length ( ) ; </a> 0
<a> } </a> 0
<a> return total ; </a> 0
<a> } </a> 0
<a> public InputStream get ( String key ) throws IOException { </a> 0
<a> return get ( key , null ) ; </a> 0
<a> } </a> 0
<a> public InputStream get ( String key , String contentTag ) throws IOException { </a> 0
<a> File file = new File ( this . directory , Utility . md5hash ( key ) ) ; </a> 0
<a> FileInputStream input = null ; </a> 0
<a> try { </a> 0
<a> input = new FileInputStream ( file ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> BufferedInputStream buffered = new BufferedInputStream ( input , Utility . DEFAULT_STREAM_BUFFER_SIZE ) ; </a> 0
<a> boolean success = false ; </a> 0
<a> try { </a> 0
<a> JSONObject header = StreamHeader . readHeader ( buffered ) ; </a> 0
<a> if ( header == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> String foundKey = header . optString ( HEADER_CACHEKEY_KEY ) ; </a> 0
<a> if ( ( foundKey == null ) || ! foundKey . equals ( key ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> String headerContentTag = header . optString ( HEADER_CACHE_CONTENT_TAG_KEY , null ) ; </a> 0
<a> if ( ( contentTag == null && headerContentTag != null ) || </a> 0
<a> ( contentTag != null && ! contentTag . equals ( headerContentTag ) ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> long accessTime = new Date ( ) . getTime ( ) ; </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , TAG , "Setting lastModified to " + Long . valueOf ( accessTime ) + " for " </a> 0
<a> + file . getName ( ) ) ; </a> 0
<a> file . setLastModified ( accessTime ) ; </a> 0
<a> success = true ; </a> 0
<a> return buffered ; </a> 0
<a> } finally { </a> 0
<a> if ( ! success ) { </a> 0
<a> buffered . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> OutputStream openPutStream ( final String key ) throws IOException { </a> 0
<a> return openPutStream ( key , null ) ; </a> 0
<a> } </a> 0
<a> public OutputStream openPutStream ( final String key , String contentTag ) throws IOException { </a> 0
<a> final File buffer = BufferFile . newFile ( this . directory ) ; </a> 0
<a> buffer . delete ( ) ; </a> 0
<a> if ( ! buffer . createNewFile ( ) ) { </a> 0
<a> throw new IOException ( "Could not create file at " + buffer . getAbsolutePath ( ) ) ; </a> 0
<a> } </a> 0
<a> FileOutputStream file = null ; </a> 0
<a> try { </a> 0
<a> file = new FileOutputStream ( buffer ) ; </a> 0
<a> } catch ( FileNotFoundException e ) { </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , "Error creating buffer output stream: " + e ) ; </a> 0
<a> throw new IOException ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> StreamCloseCallback renameToTargetCallback = new StreamCloseCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClose ( ) { </a> 0
<a> renameToTargetAndTrim ( key , buffer ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> CloseCallbackOutputStream cleanup = new CloseCallbackOutputStream ( file , renameToTargetCallback ) ; </a> 0
<a> BufferedOutputStream buffered = new BufferedOutputStream ( cleanup , Utility . DEFAULT_STREAM_BUFFER_SIZE ) ; </a> 0
<a> boolean success = false ; </a> 0
<a> try { </a> 0
<a> JSONObject header = new JSONObject ( ) ; </a> 0
<a> header . put ( HEADER_CACHEKEY_KEY , key ) ; </a> 0
<a> if ( ! Utility . isNullOrEmpty ( contentTag ) ) { </a> 0
<a> header . put ( HEADER_CACHE_CONTENT_TAG_KEY , contentTag ) ; </a> 0
<a> } </a> 0
<a> StreamHeader . writeHeader ( buffered , header ) ; </a> 0
<a> success = true ; </a> 0
<a> return buffered ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , "Error creating JSON header for cache file: " + e ) ; </a> 0
<a> throw new IOException ( e . getMessage ( ) ) ; </a> 0
<a> } finally { </a> 0
<a> if ( ! success ) { </a> 0
<a> buffered . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void renameToTargetAndTrim ( String key , File buffer ) { </a> 0
<a> final File target = new File ( directory , Utility . md5hash ( key ) ) ; </a> 0
<a> if ( ! buffer . renameTo ( target ) ) { </a> 0
<a> buffer . delete ( ) ; </a> 0
<a> } </a> 0
<a> postTrim ( ) ; </a> 0
<a> } </a> 0
<a> public InputStream interceptAndPut ( String key , InputStream input ) throws IOException { </a> 0
<a> OutputStream output = openPutStream ( key ) ; </a> 0
<a> return new CopyingInputStream ( input , output ) ; </a> 0
<a> } </a> 0
<a> public String toString ( ) { </a> 0
<a> return "{FileLruCache:" + " tag:" + this . tag + " file:" + this . directory . getName ( ) + "}" ; </a> 0
<a> } </a> 0
<a> private void postTrim ( ) { </a> 0
<a> synchronized ( lock ) { </a> 0
<a> if ( ! isTrimPending ) { </a> 0
<a> isTrimPending = true ; </a> 0
<a> Settings . getExecutor ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> trim ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void trim ( ) { </a> 0
<a> try { </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , TAG , "trim started" ) ; </a> 0
<a> PriorityQueue < ModifiedFile > heap = new PriorityQueue < ModifiedFile > ( ) ; </a> 0
<a> long size = 0 ; </a> 0
<a> long count = 0 ; </a> 0
<a> for ( File file : this . directory . listFiles ( BufferFile . excludeBufferFiles ( ) ) ) { </a> 0
<a> ModifiedFile modified = new ModifiedFile ( file ) ; </a> 0
<a> heap . add ( modified ) ; </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , TAG , " trim considering time=" + Long . valueOf ( modified . getModified ( ) ) </a> 0
<a> + " name=" + modified . getFile ( ) . getName ( ) ) ; </a> 0
<a> size += file . length ( ) ; </a> 0
<a> count ++ ; </a> 0
<a> } </a> 0
<a> while ( ( size > limits . getByteCount ( ) ) || ( count > limits . getFileCount ( ) ) ) { </a> 0
<a> File file = heap . remove ( ) . getFile ( ) ; </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , TAG , " trim removing " + file . getName ( ) ) ; </a> 0
<a> size -= file . length ( ) ; </a> 0
<a> count -- ; </a> 0
<a> file . delete ( ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> synchronized ( lock ) { </a> 0
<a> isTrimPending = false ; </a> 0
<a> lock . notifyAll ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class BufferFile { </a> 0
<a> private static final String FILE_NAME_PREFIX = "buffer" ; </a> 0
<a> private static final FilenameFilter filterExcludeBufferFiles = new FilenameFilter ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean accept ( File dir , String filename ) { </a> 0
<a> return ! filename . startsWith ( FILE_NAME_PREFIX ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private static final FilenameFilter filterExcludeNonBufferFiles = new FilenameFilter ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean accept ( File dir , String filename ) { </a> 0
<a> return filename . startsWith ( FILE_NAME_PREFIX ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> static void deleteAll ( final File root ) { </a> 0
<a> for ( File file : root . listFiles ( excludeNonBufferFiles ( ) ) ) { </a> 0
<a> file . delete ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static FilenameFilter excludeBufferFiles ( ) { </a> 0
<a> return filterExcludeBufferFiles ; </a> 0
<a> } </a> 0
<a> static FilenameFilter excludeNonBufferFiles ( ) { </a> 0
<a> return filterExcludeNonBufferFiles ; </a> 0
<a> } </a> 0
<a> static File newFile ( final File root ) { </a> 0
<a> String name = FILE_NAME_PREFIX + Long . valueOf ( bufferIndex . incrementAndGet ( ) ) . toString ( ) ; </a> 0
<a> return new File ( root , name ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static final class StreamHeader { </a> 0
<a> private static final int HEADER_VERSION = 0 ; </a> 0
<a> static void writeHeader ( OutputStream stream , JSONObject header ) throws IOException { </a> 0
<a> String headerString = header . toString ( ) ; </a> 0
<a> byte [ ] headerBytes = headerString . getBytes ( ) ; </a> 0
<a> stream . write ( HEADER_VERSION ) ; </a> 0
<a> stream . write ( ( headerBytes . length > > 16 ) & 0xff ) ; </a> 0
<a> stream . write ( ( headerBytes . length > > 8 ) & 0xff ) ; </a> 0
<a> stream . write ( ( headerBytes . length > > 0 ) & 0xff ) ; </a> 0
<a> stream . write ( headerBytes ) ; </a> 0
<a> } </a> 0
<a> static JSONObject readHeader ( InputStream stream ) throws IOException { </a> 0
<a> int version = stream . read ( ) ; </a> 0
<a> if ( version != HEADER_VERSION ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> int headerSize = 0 ; </a> 0
<a> for ( int i = 0 ; i < 3 ; i ++ ) { </a> 0
<a> int b = stream . read ( ) ; </a> 0
<a> if ( b == - 1 ) { </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , TAG , </a> 0
<a> "readHeader: stream.read returned -1 while reading header size" ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> headerSize <<= 8 ; </a> 0
<a> headerSize += b & 0xff ; </a> 0
<a> } </a> 0
<a> byte [ ] headerBytes = new byte [ headerSize ] ; </a> 0
<a> int count = 0 ; </a> 0
<a> while ( count < headerBytes . length ) { </a> 0
<a> int readCount = stream . read ( headerBytes , count , headerBytes . length - count ) ; </a> 0
<a> if ( readCount < 1 ) { </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , TAG , </a> 0
<a> "readHeader: stream.read stopped at " + Integer . valueOf ( count ) + " when expected " </a> 0
<a> + headerBytes . length ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> count += readCount ; </a> 0
<a> } </a> 0
<a> String headerString = new String ( headerBytes ) ; </a> 0
<a> JSONObject header = null ; </a> 0
<a> JSONTokener tokener = new JSONTokener ( headerString ) ; </a> 0
<a> try { </a> 0
<a> Object parsed = tokener . nextValue ( ) ; </a> 0
<a> if ( ! ( parsed instanceof JSONObject ) ) { </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , TAG , "readHeader: expected JSONObject, got " + parsed . getClass ( ) . getCanonicalName ( ) ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> header = ( JSONObject ) parsed ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> throw new IOException ( e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> return header ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class CloseCallbackOutputStream extends OutputStream { </a> 0
<a> final OutputStream innerStream ; </a> 0
<a> final StreamCloseCallback callback ; </a> 0
<a> CloseCallbackOutputStream ( OutputStream innerStream , StreamCloseCallback callback ) { </a> 0
<a> this . innerStream = innerStream ; </a> 0
<a> this . callback = callback ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws IOException { </a> 0
<a> try { </a> 0
<a> this . innerStream . close ( ) ; </a> 0
<a> } finally { </a> 0
<a> this . callback . onClose ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( ) throws IOException { </a> 0
<a> this . innerStream . flush ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( byte [ ] buffer , int offset , int count ) throws IOException { </a> 0
<a> this . innerStream . write ( buffer , offset , count ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( byte [ ] buffer ) throws IOException { </a> 0
<a> this . innerStream . write ( buffer ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( int oneByte ) throws IOException { </a> 0
<a> this . innerStream . write ( oneByte ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static final class CopyingInputStream extends InputStream { </a> 0
<a> final InputStream input ; </a> 0
<a> final OutputStream output ; </a> 0
<a> CopyingInputStream ( final InputStream input , final OutputStream output ) { </a> 0
<a> this . input = input ; </a> 0
<a> this . output = output ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int available ( ) throws IOException { </a> 0
<a> return input . available ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws IOException { </a> 0
<a> try { </a> 0
<a> this . input . close ( ) ; </a> 0
<a> } finally { </a> 0
<a> this . output . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void mark ( int readlimit ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean markSupported ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int read ( byte [ ] buffer ) throws IOException { </a> 0
<a> int count = input . read ( buffer ) ; </a> 0
<a> if ( count > 0 ) { </a> 0
<a> output . write ( buffer , 0 , count ) ; </a> 0
<a> } </a> 0
<a> return count ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int read ( ) throws IOException { </a> 0
<a> int b = input . read ( ) ; </a> 0
<a> if ( b >= 0 ) { </a> 0
<a> output . write ( b ) ; </a> 0
<a> } </a> 0
<a> return b ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int read ( byte [ ] buffer , int offset , int length ) throws IOException { </a> 0
<a> int count = input . read ( buffer , offset , length ) ; </a> 0
<a> if ( count > 0 ) { </a> 0
<a> output . write ( buffer , offset , count ) ; </a> 0
<a> } </a> 0
<a> return count ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized void reset ( ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long skip ( long byteCount ) throws IOException { </a> 0
<a> byte [ ] buffer = new byte [ 1024 ] ; </a> 0
<a> long total = 0 ; </a> 0
<a> while ( total < byteCount ) { </a> 0
<a> int count = read ( buffer , 0 , ( int ) Math . min ( byteCount - total , buffer . length ) ) ; </a> 0
<a> if ( count < 0 ) { </a> 0
<a> return total ; </a> 0
<a> } </a> 0
<a> total += count ; </a> 0
<a> } </a> 0
<a> return total ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final class Limits { </a> 0
<a> private int byteCount ; </a> 0
<a> private int fileCount ; </a> 0
<a> public Limits ( ) { </a> 0
<a> this . fileCount = 1024 ; </a> 0
<a> this . byteCount = 1024 * 1024 ; </a> 0
<a> } </a> 0
<a> int getByteCount ( ) { </a> 0
<a> return byteCount ; </a> 0
<a> } </a> 0
<a> int getFileCount ( ) { </a> 0
<a> return fileCount ; </a> 0
<a> } </a> 0
<a> void setByteCount ( int n ) { </a> 0
<a> if ( n < 0 ) { </a> 0
<a> throw new InvalidParameterException ( "Cache byte-count limit must be >= 0" ) ; </a> 0
<a> } </a> 0
<a> byteCount = n ; </a> 0
<a> } </a> 0
<a> void setFileCount ( int n ) { </a> 0
<a> if ( n < 0 ) { </a> 0
<a> throw new InvalidParameterException ( "Cache file count limit must be >= 0" ) ; </a> 0
<a> } </a> 0
<a> fileCount = n ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final static class ModifiedFile implements Comparable < ModifiedFile > { </a> 0
<a> private final File file ; </a> 0
<a> private final long modified ; </a> 0
<a> ModifiedFile ( File file ) { </a> 0
<a> this . file = file ; </a> 0
<a> this . modified = file . lastModified ( ) ; </a> 0
<a> } </a> 0
<a> File getFile ( ) { </a> 0
<a> return file ; </a> 0
<a> } </a> 0
<a> long getModified ( ) { </a> 0
<a> return modified ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( ModifiedFile another ) { </a> 0
<a> if ( getModified ( ) < another . getModified ( ) ) { </a> 0
<a> return - 1 ; </a> 0
<a> } else if ( getModified ( ) > another . getModified ( ) ) { </a> 0
<a> return 1 ; </a> 0
<a> } else { </a> 0
<a> return getFile ( ) . compareTo ( another . getFile ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object another ) { </a> 0
<a> return </a> 0
<a> ( another instanceof ModifiedFile ) && </a> 0
<a> ( compareTo ( ( ModifiedFile ) another ) == 0 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface StreamCloseCallback { </a> 0
<a> void onClose ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . internal ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> public final class ServerProtocol { </a> 0
<a> static final String FACEBOOK_COM = "facebook.com" ; </a> 0
<a> public static final String DIALOG_AUTHORITY = "m." + FACEBOOK_COM ; </a> 0
<a> public static final String DIALOG_PATH = "dialog/" ; </a> 0
<a> public static final String DIALOG_PARAM_SCOPE = "scope" ; </a> 0
<a> public static final String DIALOG_PARAM_CLIENT_ID = "client_id" ; </a> 0
<a> public static final String DIALOG_PARAM_DISPLAY = "display" ; </a> 0
<a> public static final String DIALOG_PARAM_REDIRECT_URI = "redirect_uri" ; </a> 0
<a> public static final String DIALOG_PARAM_TYPE = "type" ; </a> 0
<a> public static final String GRAPH_URL = "https://graph." + FACEBOOK_COM ; </a> 0
<a> public static final String GRAPH_URL_BASE = "https://graph." + FACEBOOK_COM + "/" ; </a> 0
<a> public static final String REST_URL_BASE = "https://api." + FACEBOOK_COM + "/method/" ; </a> 0
<a> public static final String BATCHED_REST_METHOD_URL_BASE = "method/" ; </a> 0
<a> public static final Collection < String > errorsProxyAuthDisabled = </a> 0
<a> Utility . unmodifiableCollection ( "service_disabled" , "AndroidAuthKillSwitchException" ) ; </a> 0
<a> public static final Collection < String > errorsUserCanceled = </a> 0
<a> Utility . unmodifiableCollection ( "access_denied" , "OAuthAccessDeniedException" ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . internal ; </a> 0
<a> public enum SessionAuthorizationType { </a> 0
<a> READ , </a> 0
<a> PUBLISH </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . internal ; </a> 0
<a> import android . content . BroadcastReceiver ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . content . IntentFilter ; </a> 0
<a> import android . support . v4 . content . LocalBroadcastManager ; </a> 0
<a> import com . facebook . Session ; </a> 0
<a> import com . facebook . SessionState ; </a> 0
<a> public class SessionTracker { </a> 0
<a> private Session session ; </a> 0
<a> private final Session . StatusCallback callback ; </a> 0
<a> private final BroadcastReceiver receiver ; </a> 0
<a> private final LocalBroadcastManager broadcastManager ; </a> 0
<a> private boolean isTracking = false ; </a> 0
<a> public SessionTracker ( Context context , Session . StatusCallback callback ) { </a> 0
<a> this ( context , callback , null ) ; </a> 0
<a> } </a> 0
<a> SessionTracker ( Context context , Session . StatusCallback callback , Session session ) { </a> 0
<a> this ( context , callback , session , true ) ; </a> 0
<a> } </a> 0
<a> public SessionTracker ( Context context , Session . StatusCallback callback , Session session , boolean startTracking ) { </a> 0
<a> this . callback = new CallbackWrapper ( callback ) ; </a> 0
<a> this . session = session ; </a> 0
<a> this . receiver = new ActiveSessionBroadcastReceiver ( ) ; </a> 0
<a> this . broadcastManager = LocalBroadcastManager . getInstance ( context ) ; </a> 0
<a> if ( startTracking ) { </a> 0
<a> startTracking ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public Session getSession ( ) { </a> 0
<a> return ( session == null ) ? Session . getActiveSession ( ) : session ; </a> 0
<a> } </a> 0
<a> public Session getOpenSession ( ) { </a> 0
<a> Session openSession = getSession ( ) ; </a> 0
<a> if ( openSession != null && openSession . isOpened ( ) ) { </a> 0
<a> return openSession ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public void setSession ( Session newSession ) { </a> 0
<a> if ( newSession == null ) { </a> 0
<a> if ( session != null ) { </a> 0
<a> session . removeCallback ( callback ) ; </a> 0
<a> session = null ; </a> 0
<a> addBroadcastReceiver ( ) ; </a> 0
<a> if ( getSession ( ) != null ) { </a> 0
<a> getSession ( ) . addCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( session == null ) { </a> 0
<a> Session activeSession = Session . getActiveSession ( ) ; </a> 0
<a> if ( activeSession != null ) { </a> 0
<a> activeSession . removeCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> broadcastManager . unregisterReceiver ( receiver ) ; </a> 0
<a> } else { </a> 0
<a> session . removeCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> session = newSession ; </a> 0
<a> session . addCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void startTracking ( ) { </a> 0
<a> if ( isTracking ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( this . session == null ) { </a> 0
<a> addBroadcastReceiver ( ) ; </a> 0
<a> } </a> 0
<a> if ( getSession ( ) != null ) { </a> 0
<a> getSession ( ) . addCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> isTracking = true ; </a> 0
<a> } </a> 0
<a> public void stopTracking ( ) { </a> 0
<a> if ( ! isTracking ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> Session session = getSession ( ) ; </a> 0
<a> if ( session != null ) { </a> 0
<a> session . removeCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> broadcastManager . unregisterReceiver ( receiver ) ; </a> 0
<a> isTracking = false ; </a> 0
<a> } </a> 0
<a> public boolean isTracking ( ) { </a> 0
<a> return isTracking ; </a> 0
<a> } </a> 0
<a> public boolean isTrackingActiveSession ( ) { </a> 0
<a> return session == null ; </a> 0
<a> } </a> 0
<a> private void addBroadcastReceiver ( ) { </a> 0
<a> IntentFilter filter = new IntentFilter ( ) ; </a> 0
<a> filter . addAction ( Session . ACTION_ACTIVE_SESSION_SET ) ; </a> 0
<a> filter . addAction ( Session . ACTION_ACTIVE_SESSION_UNSET ) ; </a> 0
<a> broadcastManager . registerReceiver ( receiver , filter ) ; </a> 0
<a> } </a> 0
<a> private class ActiveSessionBroadcastReceiver extends BroadcastReceiver { </a> 0
<a> @ Override </a> 0
<a> public void onReceive ( Context context , Intent intent ) { </a> 0
<a> if ( Session . ACTION_ACTIVE_SESSION_SET . equals ( intent . getAction ( ) ) ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session != null ) { </a> 0
<a> session . addCallback ( SessionTracker . this . callback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class CallbackWrapper implements Session . StatusCallback { </a> 0
<a> private final Session . StatusCallback wrapped ; </a> 0
<a> public CallbackWrapper ( Session . StatusCallback wrapped ) { </a> 0
<a> this . wrapped = wrapped ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> if ( wrapped != null && isTracking ( ) ) { </a> 0
<a> wrapped . call ( session , state , exception ) ; </a> 0
<a> } </a> 0
<a> if ( session == SessionTracker . this . session && state . isClosed ( ) ) { </a> 0
<a> setSession ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . internal ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> public final class Validate { </a> 0
<a> public static void notNull ( Object arg , String name ) { </a> 0
<a> if ( arg == null ) { </a> 0
<a> throw new NullPointerException ( "Argument " + name + " cannot be null" ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> public static < T > void notEmpty ( Collection < T > container , String name ) { </a> 0
<a> if ( container . isEmpty ( ) ) { </a> 0
<a> throw new IllegalArgumentException ( "Container '" + name + "' cannot be empty" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static < T > void containsNoNulls ( Collection < T > container , String name ) { </a> 0
<a> Validate . notNull ( container , name ) ; </a> 0
<a> for ( T item : container ) { </a> 0
<a> if ( item == null ) { </a> 0
<a> throw new NullPointerException ( "Container '" + name + "' cannot contain null values" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static < T > void notEmptyAndContainsNoNulls ( Collection < T > container , String name ) { </a> 0
<a> Validate . containsNoNulls ( container , name ) ; </a> 0
<a> Validate . notEmpty ( container , name ) ; </a> 0
<a> } </a> 0
<a> public static void notNullOrEmpty ( String arg , String name ) { </a> 0
<a> if ( Utility . isNullOrEmpty ( arg ) ) { </a> 0
<a> throw new IllegalArgumentException ( "Argument " + name + " cannot be null or empty" ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> public static void oneOf ( Object arg , String name , Object ... values ) { </a> 0
<a> for ( Object value : values ) { </a> 0
<a> if ( value != null ) { </a> 0
<a> if ( value . equals ( arg ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( arg == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> throw new IllegalArgumentException ( "Argument " + name + " was not one of the allowed values" ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . model ; </a> 0
<a> public interface GraphLocation extends GraphObject { </a> 0
<a> public String getStreet ( ) ; </a> 0
<a> public void setStreet ( String street ) ; </a> 0
<a> public String getCity ( ) ; </a> 0
<a> public void setCity ( String city ) ; </a> 0
<a> public String getState ( ) ; </a> 0
<a> public void setState ( String state ) ; </a> 0
<a> public String getCountry ( ) ; </a> 0
<a> public void setCountry ( String country ) ; </a> 0
<a> public String getZip ( ) ; </a> 0
<a> public void setZip ( String zip ) ; </a> 0
<a> public double getLatitude ( ) ; </a> 0
<a> public void setLatitude ( double latitude ) ; </a> 0
<a> public double getLongitude ( ) ; </a> 0
<a> public void setLongitude ( double longitude ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . model ; </a> 0
<a> public interface GraphMultiResult extends GraphObject { </a> 0
<a> public GraphObjectList < GraphObject > getData ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . model ; </a> 0
<a> import com . facebook . FacebookGraphObjectException ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import com . facebook . internal . Validate ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . lang . reflect . * ; </a> 0
<a> import java . text . ParseException ; </a> 0
<a> import java . text . SimpleDateFormat ; </a> 0
<a> import java . util . * ; </a> 0
<a> public interface GraphObject { </a> 0
<a> public < T extends GraphObject > T cast ( Class < T > graphObjectClass ) ; </a> 0
<a> public Map < String , Object > asMap ( ) ; </a> 0
<a> public JSONObject getInnerJSONObject ( ) ; </a> 0
<a> public Object getProperty ( String propertyName ) ; </a> 0
<a> public void setProperty ( String propertyName , Object propertyValue ) ; </a> 0
<a> public void removeProperty ( String propertyName ) ; </a> 0
<a> final class Factory { </a> 0
<a> private static final HashSet < Class < ? > > verifiedGraphObjectClasses = new HashSet < Class < ? > > ( ) ; </a> 0
<a> private static final SimpleDateFormat [ ] dateFormats = new SimpleDateFormat [ ] { </a> 0
<a> new SimpleDateFormat ( "yyyy-MM-dd'T'HH:mm:ssZ" , Locale . US ) , </a> 0
<a> new SimpleDateFormat ( "yyyy-MM-dd'T'HH:mm:ss" , Locale . US ) , new SimpleDateFormat ( "yyyy-MM-dd" , Locale . US ) , } ; </a> 0
<a> private Factory ( ) { </a> 0
<a> } </a> 0
<a> public static GraphObject create ( JSONObject json ) { </a> 0
<a> return create ( json , GraphObject . class ) ; </a> 0
<a> } </a> 0
<a> public static < T extends GraphObject > T create ( JSONObject json , Class < T > graphObjectClass ) { </a> 0
<a> return createGraphObjectProxy ( graphObjectClass , json ) ; </a> 0
<a> } </a> 0
<a> public static GraphObject create ( ) { </a> 0
<a> return create ( GraphObject . class ) ; </a> 0
<a> } </a> 0
<a> public static < T extends GraphObject > T create ( Class < T > graphObjectClass ) { </a> 0
<a> return createGraphObjectProxy ( graphObjectClass , new JSONObject ( ) ) ; </a> 0
<a> } </a> 0
<a> public static boolean hasSameId ( GraphObject a , GraphObject b ) { </a> 0
<a> if ( a == null || b == null || ! a . asMap ( ) . containsKey ( "id" ) || ! b . asMap ( ) . containsKey ( "id" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( a . equals ( b ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> Object idA = a . getProperty ( "id" ) ; </a> 0
<a> Object idB = b . getProperty ( "id" ) ; </a> 0
<a> if ( idA == null || idB == null || ! ( idA instanceof String ) || ! ( idB instanceof String ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return idA . equals ( idB ) ; </a> 0
<a> } </a> 0
<a> public static < T > GraphObjectList < T > createList ( JSONArray array , Class < T > graphObjectClass ) { </a> 0
<a> return new GraphObjectListImpl < T > ( array , graphObjectClass ) ; </a> 0
<a> } </a> 0
<a> public static < T > GraphObjectList < T > createList ( Class < T > graphObjectClass ) { </a> 0
<a> return createList ( new JSONArray ( ) , graphObjectClass ) ; </a> 0
<a> } </a> 0
<a> private static < T extends GraphObject > T createGraphObjectProxy ( Class < T > graphObjectClass , JSONObject state ) { </a> 0
<a> verifyCanProxyClass ( graphObjectClass ) ; </a> 0
<a> Class < ? > [ ] interfaces = new Class [ ] { graphObjectClass } ; </a> 0
<a> GraphObjectProxy graphObjectProxy = new GraphObjectProxy ( state , graphObjectClass ) ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> T graphObject = ( T ) Proxy . newProxyInstance ( GraphObject . class . getClassLoader ( ) , interfaces , graphObjectProxy ) ; </a> 0
<a> return graphObject ; </a> 0
<a> } </a> 0
<a> private static Map < String , Object > createGraphObjectProxyForMap ( JSONObject state ) { </a> 0
<a> Class < ? > [ ] interfaces = new Class [ ] { Map . class } ; </a> 0
<a> GraphObjectProxy graphObjectProxy = new GraphObjectProxy ( state , Map . class ) ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> Map < String , Object > graphObject = ( Map < String , Object > ) Proxy </a> 0
<a> . newProxyInstance ( GraphObject . class . getClassLoader ( ) , interfaces , graphObjectProxy ) ; </a> 0
<a> return graphObject ; </a> 0
<a> } </a> 0
<a> private static synchronized < T extends GraphObject > boolean hasClassBeenVerified ( Class < T > graphObjectClass ) { </a> 0
<a> return verifiedGraphObjectClasses . contains ( graphObjectClass ) ; </a> 0
<a> } </a> 0
<a> private static synchronized < T extends GraphObject > void recordClassHasBeenVerified ( Class < T > graphObjectClass ) { </a> 0
<a> verifiedGraphObjectClasses . add ( graphObjectClass ) ; </a> 0
<a> } </a> 0
<a> private static < T extends GraphObject > void verifyCanProxyClass ( Class < T > graphObjectClass ) { </a> 0
<a> if ( hasClassBeenVerified ( graphObjectClass ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( ! graphObjectClass . isInterface ( ) ) { </a> 0
<a> throw new FacebookGraphObjectException ( "Factory can only wrap interfaces, not class: " </a> 0
<a> + graphObjectClass . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> Method [ ] methods = graphObjectClass . getMethods ( ) ; </a> 0
<a> for ( Method method : methods ) { </a> 0
<a> String methodName = method . getName ( ) ; </a> 0
<a> int parameterCount = method . getParameterTypes ( ) . length ; </a> 0
<a> Class < ? > returnType = method . getReturnType ( ) ; </a> 0
<a> boolean hasPropertyNameOverride = method . isAnnotationPresent ( PropertyName . class ) ; </a> 0
<a> if ( method . getDeclaringClass ( ) . isAssignableFrom ( GraphObject . class ) ) { </a> 0
<a> continue ; </a> 0
<a> } else if ( parameterCount == 1 && returnType == Void . TYPE ) { </a> 0
<a> if ( hasPropertyNameOverride ) { </a> 0
<a> if ( ! Utility . isNullOrEmpty ( method . getAnnotation ( PropertyName . class ) . value ( ) ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> } else if ( methodName . startsWith ( "set" ) && methodName . length ( ) > 3 ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> } else if ( parameterCount == 0 && returnType != Void . TYPE ) { </a> 0
<a> if ( hasPropertyNameOverride ) { </a> 0
<a> if ( ! Utility . isNullOrEmpty ( method . getAnnotation ( PropertyName . class ) . value ( ) ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> } else if ( methodName . startsWith ( "get" ) && methodName . length ( ) > 3 ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> throw new FacebookGraphObjectException ( "Factory can't proxy method: " + method . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> recordClassHasBeenVerified ( graphObjectClass ) ; </a> 0
<a> } </a> 0
<a> static < U > U coerceValueToExpectedType ( Object value , Class < U > expectedType , </a> 0
<a> ParameterizedType expectedTypeAsParameterizedType ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> Class < ? > valueType = value . getClass ( ) ; </a> 0
<a> if ( expectedType . isAssignableFrom ( valueType ) ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> U result = ( U ) value ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> if ( expectedType . isPrimitive ( ) ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> U result = ( U ) value ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> if ( GraphObject . class . isAssignableFrom ( expectedType ) ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> Class < ? extends GraphObject > graphObjectClass = ( Class < ? extends GraphObject > ) expectedType ; </a> 0
<a> if ( JSONObject . class . isAssignableFrom ( valueType ) ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> U result = ( U ) createGraphObjectProxy ( graphObjectClass , ( JSONObject ) value ) ; </a> 0
<a> return result ; </a> 0
<a> } else if ( GraphObject . class . isAssignableFrom ( valueType ) ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> U result = ( U ) ( ( GraphObject ) value ) . cast ( graphObjectClass ) ; </a> 0
<a> return result ; </a> 0
<a> } else { </a> 0
<a> throw new FacebookGraphObjectException ( "Can't create GraphObject from " + valueType . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> } else if ( Iterable . class . equals ( expectedType ) || Collection . class . equals ( expectedType ) </a> 0
<a> || List . class . equals ( expectedType ) || GraphObjectList . class . equals ( expectedType ) ) { </a> 0
<a> if ( expectedTypeAsParameterizedType == null ) { </a> 0
<a> throw new FacebookGraphObjectException ( "can't infer generic type of: " + expectedType . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> Type [ ] actualTypeArguments = expectedTypeAsParameterizedType . getActualTypeArguments ( ) ; </a> 0
<a> if ( actualTypeArguments == null || actualTypeArguments . length != 1 </a> 0
<a> || ! ( actualTypeArguments [ 0 ] instanceof Class < ? > ) ) { </a> 0
<a> throw new FacebookGraphObjectException ( </a> 0
<a> "Expect collection properties to be of a type with exactly one generic parameter." ) ; </a> 0
<a> } </a> 0
<a> Class < ? > collectionGenericArgument = ( Class < ? > ) actualTypeArguments [ 0 ] ; </a> 0
<a> if ( JSONArray . class . isAssignableFrom ( valueType ) ) { </a> 0
<a> JSONArray jsonArray = ( JSONArray ) value ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> U result = ( U ) createList ( jsonArray , collectionGenericArgument ) ; </a> 0
<a> return result ; </a> 0
<a> } else { </a> 0
<a> throw new FacebookGraphObjectException ( "Can't create Collection from " + valueType . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> } else if ( String . class . equals ( expectedType ) ) { </a> 0
<a> if ( Double . class . isAssignableFrom ( valueType ) || </a> 0
<a> Float . class . isAssignableFrom ( valueType ) ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> U result = ( U ) String . format ( "%f" , value ) ; </a> 0
<a> return result ; </a> 0
<a> } else if ( Number . class . isAssignableFrom ( valueType ) ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> U result = ( U ) String . format ( "%d" , value ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> } else if ( Date . class . equals ( expectedType ) ) { </a> 0
<a> if ( String . class . isAssignableFrom ( valueType ) ) { </a> 0
<a> for ( SimpleDateFormat format : dateFormats ) { </a> 0
<a> try { </a> 0
<a> Date date = format . parse ( ( String ) value ) ; </a> 0
<a> if ( date != null ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> U result = ( U ) date ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> } catch ( ParseException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> throw new FacebookGraphObjectException ( "Can't convert type" + valueType . getName ( ) + " to " </a> 0
<a> + expectedType . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> static String convertCamelCaseToLowercaseWithUnderscores ( String string ) { </a> 0
<a> string = string . replaceAll ( "([a-z])([A-Z])" , "$1_$2" ) ; </a> 0
<a> return string . toLowerCase ( Locale . US ) ; </a> 0
<a> } </a> 0
<a> private static Object getUnderlyingJSONObject ( Object obj ) { </a> 0
<a> Class < ? > objClass = obj . getClass ( ) ; </a> 0
<a> if ( GraphObject . class . isAssignableFrom ( objClass ) ) { </a> 0
<a> GraphObject graphObject = ( GraphObject ) obj ; </a> 0
<a> return graphObject . getInnerJSONObject ( ) ; </a> 0
<a> } else if ( GraphObjectList . class . isAssignableFrom ( objClass ) ) { </a> 0
<a> GraphObjectList < ? > graphObjectList = ( GraphObjectList < ? > ) obj ; </a> 0
<a> return graphObjectList . getInnerJSONArray ( ) ; </a> 0
<a> } </a> 0
<a> return obj ; </a> 0
<a> } </a> 0
<a> private abstract static class ProxyBase < STATE > implements InvocationHandler { </a> 0
<a> private static final String EQUALS_METHOD = "equals" ; </a> 0
<a> private static final String TOSTRING_METHOD = "toString" ; </a> 0
<a> protected final STATE state ; </a> 0
<a> protected ProxyBase ( STATE state ) { </a> 0
<a> this . state = state ; </a> 0
<a> } </a> 0
<a> protected final Object throwUnexpectedMethodSignature ( Method method ) { </a> 0
<a> throw new FacebookGraphObjectException ( getClass ( ) . getName ( ) + " got an unexpected method signature: " </a> 0
<a> + method . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> protected final Object proxyObjectMethods ( Object proxy , Method method , Object [ ] args ) throws Throwable { </a> 0
<a> String methodName = method . getName ( ) ; </a> 0
<a> if ( methodName . equals ( EQUALS_METHOD ) ) { </a> 0
<a> Object other = args [ 0 ] ; </a> 0
<a> if ( other == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> InvocationHandler handler = Proxy . getInvocationHandler ( other ) ; </a> 0
<a> if ( ! ( handler instanceof GraphObjectProxy ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> GraphObjectProxy otherProxy = ( GraphObjectProxy ) handler ; </a> 0
<a> return this . state . equals ( otherProxy . state ) ; </a> 0
<a> } else if ( methodName . equals ( TOSTRING_METHOD ) ) { </a> 0
<a> return toString ( ) ; </a> 0
<a> } </a> 0
<a> return method . invoke ( this . state , args ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final static class GraphObjectProxy extends ProxyBase < JSONObject > { </a> 0
<a> private static final String CLEAR_METHOD = "clear" ; </a> 0
<a> private static final String CONTAINSKEY_METHOD = "containsKey" ; </a> 0
<a> private static final String CONTAINSVALUE_METHOD = "containsValue" ; </a> 0
<a> private static final String ENTRYSET_METHOD = "entrySet" ; </a> 0
<a> private static final String GET_METHOD = "get" ; </a> 0
<a> private static final String ISEMPTY_METHOD = "isEmpty" ; </a> 0
<a> private static final String KEYSET_METHOD = "keySet" ; </a> 0
<a> private static final String PUT_METHOD = "put" ; </a> 0
<a> private static final String PUTALL_METHOD = "putAll" ; </a> 0
<a> private static final String REMOVE_METHOD = "remove" ; </a> 0
<a> private static final String SIZE_METHOD = "size" ; </a> 0
<a> private static final String VALUES_METHOD = "values" ; </a> 0
<a> private static final String CAST_METHOD = "cast" ; </a> 0
<a> private static final String CASTTOMAP_METHOD = "asMap" ; </a> 0
<a> private static final String GETPROPERTY_METHOD = "getProperty" ; </a> 0
<a> private static final String SETPROPERTY_METHOD = "setProperty" ; </a> 0
<a> private static final String REMOVEPROPERTY_METHOD = "removeProperty" ; </a> 0
<a> private static final String GETINNERJSONOBJECT_METHOD = "getInnerJSONObject" ; </a> 0
<a> private final Class < ? > graphObjectClass ; </a> 0
<a> public GraphObjectProxy ( JSONObject state , Class < ? > graphObjectClass ) { </a> 0
<a> super ( state ) ; </a> 0
<a> this . graphObjectClass = graphObjectClass ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return String . format ( "GraphObject{graphObjectClass=%s, state=%s}" , graphObjectClass . getSimpleName ( ) , state ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { </a> 0
<a> Class < ? > declaringClass = method . getDeclaringClass ( ) ; </a> 0
<a> if ( declaringClass == Object . class ) { </a> 0
<a> return proxyObjectMethods ( proxy , method , args ) ; </a> 0
<a> } else if ( declaringClass == Map . class ) { </a> 0
<a> return proxyMapMethods ( method , args ) ; </a> 0
<a> } else if ( declaringClass == GraphObject . class ) { </a> 0
<a> return proxyGraphObjectMethods ( proxy , method , args ) ; </a> 0
<a> } else if ( GraphObject . class . isAssignableFrom ( declaringClass ) ) { </a> 0
<a> return proxyGraphObjectGettersAndSetters ( method , args ) ; </a> 0
<a> } </a> 0
<a> return throwUnexpectedMethodSignature ( method ) ; </a> 0
<a> } </a> 0
<a> private final Object proxyMapMethods ( Method method , Object [ ] args ) { </a> 0
<a> String methodName = method . getName ( ) ; </a> 0
<a> if ( methodName . equals ( CLEAR_METHOD ) ) { </a> 0
<a> JsonUtil . jsonObjectClear ( this . state ) ; </a> 0
<a> return null ; </a> 0
<a> } else if ( methodName . equals ( CONTAINSKEY_METHOD ) ) { </a> 0
<a> return this . state . has ( ( String ) args [ 0 ] ) ; </a> 0
<a> } else if ( methodName . equals ( CONTAINSVALUE_METHOD ) ) { </a> 0
<a> return JsonUtil . jsonObjectContainsValue ( this . state , args [ 0 ] ) ; </a> 0
<a> } else if ( methodName . equals ( ENTRYSET_METHOD ) ) { </a> 0
<a> return JsonUtil . jsonObjectEntrySet ( this . state ) ; </a> 0
<a> } else if ( methodName . equals ( GET_METHOD ) ) { </a> 0
<a> return this . state . opt ( ( String ) args [ 0 ] ) ; </a> 0
<a> } else if ( methodName . equals ( ISEMPTY_METHOD ) ) { </a> 0
<a> return this . state . length ( ) == 0 ; </a> 0
<a> } else if ( methodName . equals ( KEYSET_METHOD ) ) { </a> 0
<a> return JsonUtil . jsonObjectKeySet ( this . state ) ; </a> 0
<a> } else if ( methodName . equals ( PUT_METHOD ) ) { </a> 0
<a> return setJSONProperty ( args ) ; </a> 0
<a> } else if ( methodName . equals ( PUTALL_METHOD ) ) { </a> 0
<a> Map < String , Object > map = null ; </a> 0
<a> if ( args [ 0 ] instanceof Map < ? , ? > ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> Map < String , Object > castMap = ( Map < String , Object > ) args [ 0 ] ; </a> 0
<a> map = castMap ; </a> 0
<a> } else if ( args [ 0 ] instanceof GraphObject ) { </a> 0
<a> map = ( ( GraphObject ) args [ 0 ] ) . asMap ( ) ; </a> 0
<a> } </a> 0
<a> JsonUtil . jsonObjectPutAll ( this . state , map ) ; </a> 0
<a> return null ; </a> 0
<a> } else if ( methodName . equals ( REMOVE_METHOD ) ) { </a> 0
<a> this . state . remove ( ( String ) args [ 0 ] ) ; </a> 0
<a> return null ; </a> 0
<a> } else if ( methodName . equals ( SIZE_METHOD ) ) { </a> 0
<a> return this . state . length ( ) ; </a> 0
<a> } else if ( methodName . equals ( VALUES_METHOD ) ) { </a> 0
<a> return JsonUtil . jsonObjectValues ( this . state ) ; </a> 0
<a> } </a> 0
<a> return throwUnexpectedMethodSignature ( method ) ; </a> 0
<a> } </a> 0
<a> private final Object proxyGraphObjectMethods ( Object proxy , Method method , Object [ ] args ) { </a> 0
<a> String methodName = method . getName ( ) ; </a> 0
<a> if ( methodName . equals ( CAST_METHOD ) ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> Class < ? extends GraphObject > graphObjectClass = ( Class < ? extends GraphObject > ) args [ 0 ] ; </a> 0
<a> if ( graphObjectClass != null && </a> 0
<a> graphObjectClass . isAssignableFrom ( this . graphObjectClass ) ) { </a> 0
<a> return proxy ; </a> 0
<a> } </a> 0
<a> return Factory . createGraphObjectProxy ( graphObjectClass , this . state ) ; </a> 0
<a> } else if ( methodName . equals ( GETINNERJSONOBJECT_METHOD ) ) { </a> 0
<a> InvocationHandler handler = Proxy . getInvocationHandler ( proxy ) ; </a> 0
<a> GraphObjectProxy otherProxy = ( GraphObjectProxy ) handler ; </a> 0
<a> return otherProxy . state ; </a> 0
<a> } else if ( methodName . equals ( CASTTOMAP_METHOD ) ) { </a> 0
<a> return Factory . createGraphObjectProxyForMap ( this . state ) ; </a> 0
<a> } else if ( methodName . equals ( GETPROPERTY_METHOD ) ) { </a> 0
<a> return state . opt ( ( String ) args [ 0 ] ) ; </a> 0
<a> } else if ( methodName . equals ( SETPROPERTY_METHOD ) ) { </a> 0
<a> return setJSONProperty ( args ) ; </a> 0
<a> } else if ( methodName . equals ( REMOVEPROPERTY_METHOD ) ) { </a> 0
<a> this . state . remove ( ( String ) args [ 0 ] ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return throwUnexpectedMethodSignature ( method ) ; </a> 0
<a> } </a> 0
<a> private final Object proxyGraphObjectGettersAndSetters ( Method method , Object [ ] args ) throws JSONException { </a> 0
<a> String methodName = method . getName ( ) ; </a> 0
<a> int parameterCount = method . getParameterTypes ( ) . length ; </a> 0
<a> PropertyName propertyNameOverride = method . getAnnotation ( PropertyName . class ) ; </a> 0
<a> String key = propertyNameOverride != null ? propertyNameOverride . value ( ) : </a> 0
<a> convertCamelCaseToLowercaseWithUnderscores ( methodName . substring ( 3 ) ) ; </a> 0
<a> if ( parameterCount == 0 ) { </a> 0
<a> Object value = this . state . opt ( key ) ; </a> 0
<a> Class < ? > expectedType = method . getReturnType ( ) ; </a> 0
<a> Type genericReturnType = method . getGenericReturnType ( ) ; </a> 0
<a> ParameterizedType parameterizedReturnType = null ; </a> 0
<a> if ( genericReturnType instanceof ParameterizedType ) { </a> 0
<a> parameterizedReturnType = ( ParameterizedType ) genericReturnType ; </a> 0
<a> } </a> 0
<a> value = coerceValueToExpectedType ( value , expectedType , parameterizedReturnType ) ; </a> 0
<a> return value ; </a> 0
<a> } else if ( parameterCount == 1 ) { </a> 0
<a> Object value = args [ 0 ] ; </a> 0
<a> if ( GraphObject . class . isAssignableFrom ( value . getClass ( ) ) ) { </a> 0
<a> value = ( ( GraphObject ) value ) . getInnerJSONObject ( ) ; </a> 0
<a> } else if ( GraphObjectList . class . isAssignableFrom ( value . getClass ( ) ) ) { </a> 0
<a> value = ( ( GraphObjectList < ? > ) value ) . getInnerJSONArray ( ) ; </a> 0
<a> } else if ( Iterable . class . isAssignableFrom ( value . getClass ( ) ) ) { </a> 0
<a> JSONArray jsonArray = new JSONArray ( ) ; </a> 0
<a> Iterable < ? > iterable = ( Iterable < ? > ) value ; </a> 0
<a> for ( Object o : iterable ) { </a> 0
<a> if ( GraphObject . class . isAssignableFrom ( o . getClass ( ) ) ) { </a> 0
<a> jsonArray . put ( ( ( GraphObject ) o ) . getInnerJSONObject ( ) ) ; </a> 0
<a> } else { </a> 0
<a> jsonArray . put ( o ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> value = jsonArray ; </a> 0
<a> } </a> 0
<a> this . state . putOpt ( key , value ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return throwUnexpectedMethodSignature ( method ) ; </a> 0
<a> } </a> 0
<a> private Object setJSONProperty ( Object [ ] args ) { </a> 0
<a> String name = ( String ) args [ 0 ] ; </a> 0
<a> Object property = args [ 1 ] ; </a> 0
<a> Object value = getUnderlyingJSONObject ( property ) ; </a> 0
<a> try { </a> 0
<a> state . putOpt ( name , value ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> throw new IllegalArgumentException ( e ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final static class GraphObjectListImpl < T > extends AbstractList < T > implements GraphObjectList < T > { </a> 0
<a> private final JSONArray state ; </a> 0
<a> private final Class < ? > itemType ; </a> 0
<a> public GraphObjectListImpl ( JSONArray state , Class < ? > itemType ) { </a> 0
<a> Validate . notNull ( state , "state" ) ; </a> 0
<a> Validate . notNull ( itemType , "itemType" ) ; </a> 0
<a> this . state = state ; </a> 0
<a> this . itemType = itemType ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return String . format ( "GraphObjectList{itemType=%s, state=%s}" , itemType . getSimpleName ( ) , state ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void add ( int location , T object ) { </a> 0
<a> if ( location < 0 ) { </a> 0
<a> throw new IndexOutOfBoundsException ( ) ; </a> 0
<a> } else if ( location < size ( ) ) { </a> 0
<a> throw new UnsupportedOperationException ( "Only adding items at the end of the list is supported." ) ; </a> 0
<a> } </a> 0
<a> put ( location , object ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public T set ( int location , T object ) { </a> 0
<a> checkIndex ( location ) ; </a> 0
<a> T result = get ( location ) ; </a> 0
<a> put ( location , object ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return state . hashCode ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object obj ) { </a> 0
<a> if ( this == obj ) </a> 0
<a> return true ; </a> 0
<a> if ( getClass ( ) != obj . getClass ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> GraphObjectListImpl < T > other = ( GraphObjectListImpl < T > ) obj ; </a> 0
<a> return state . equals ( other . state ) ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> @ Override </a> 0
<a> public T get ( int location ) { </a> 0
<a> checkIndex ( location ) ; </a> 0
<a> Object value = state . opt ( location ) ; </a> 0
<a> T result = ( T ) coerceValueToExpectedType ( value , itemType , null ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int size ( ) { </a> 0
<a> return state . length ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final < U extends GraphObject > GraphObjectList < U > castToListOf ( Class < U > graphObjectClass ) { </a> 0
<a> if ( GraphObject . class . isAssignableFrom ( itemType ) ) { </a> 0
<a> if ( graphObjectClass . isAssignableFrom ( itemType ) ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> GraphObjectList < U > result = ( GraphObjectList < U > ) this ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> return createList ( state , graphObjectClass ) ; </a> 0
<a> } else { </a> 0
<a> throw new FacebookGraphObjectException ( "Can't cast GraphObjectCollection of non-GraphObject type " </a> 0
<a> + itemType ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final JSONArray getInnerJSONArray ( ) { </a> 0
<a> return state ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clear ( ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean remove ( Object o ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean removeAll ( Collection < ? > c ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean retainAll ( Collection < ? > c ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> private void checkIndex ( int index ) { </a> 0
<a> if ( index < 0 || index >= state . length ( ) ) { </a> 0
<a> throw new IndexOutOfBoundsException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void put ( int index , T obj ) { </a> 0
<a> Object underlyingObject = getUnderlyingJSONObject ( obj ) ; </a> 0
<a> try { </a> 0
<a> state . put ( index , underlyingObject ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> throw new IllegalArgumentException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . model ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> import java . util . List ; </a> 0
<a> public interface GraphObjectList < T > extends List < T > { </a> 0
<a> public < U extends GraphObject > GraphObjectList < U > castToListOf ( Class < U > graphObjectClass ) ; </a> 0
<a> public JSONArray getInnerJSONArray ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . model ; </a> 0
<a> public interface GraphPlace extends GraphObject { </a> 0
<a> public String getId ( ) ; </a> 0
<a> public void setId ( String id ) ; </a> 0
<a> public String getName ( ) ; </a> 0
<a> public void setName ( String name ) ; </a> 0
<a> public String getCategory ( ) ; </a> 0
<a> public void setCategory ( String category ) ; </a> 0
<a> public GraphLocation getLocation ( ) ; </a> 0
<a> public void setLocation ( GraphLocation location ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . model ; </a> 0
<a> public interface GraphUser extends GraphObject { </a> 0
<a> public String getId ( ) ; </a> 0
<a> public void setId ( String id ) ; </a> 0
<a> public String getName ( ) ; </a> 0
<a> public void setName ( String name ) ; </a> 0
<a> public String getFirstName ( ) ; </a> 0
<a> public void setFirstName ( String firstName ) ; </a> 0
<a> public String getMiddleName ( ) ; </a> 0
<a> public void setMiddleName ( String middleName ) ; </a> 0
<a> public String getLastName ( ) ; </a> 0
<a> public void setLastName ( String lastName ) ; </a> 0
<a> public String getLink ( ) ; </a> 0
<a> public void setLink ( String link ) ; </a> 0
<a> public String getUsername ( ) ; </a> 0
<a> public void setUsername ( String username ) ; </a> 0
<a> public String getBirthday ( ) ; </a> 0
<a> public void setBirthday ( String birthday ) ; </a> 0
<a> public GraphLocation getLocation ( ) ; </a> 0
<a> public void setLocation ( GraphLocation location ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . model ; </a> 0
<a> import android . annotation . SuppressLint ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . util . * ; </a> 0
<a> class JsonUtil { </a> 0
<a> static void jsonObjectClear ( JSONObject jsonObject ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> Iterator < String > keys = ( Iterator < String > ) jsonObject . keys ( ) ; </a> 0
<a> while ( keys . hasNext ( ) ) { </a> 0
<a> keys . next ( ) ; </a> 0
<a> keys . remove ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static boolean jsonObjectContainsValue ( JSONObject jsonObject , Object value ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> Iterator < String > keys = ( Iterator < String > ) jsonObject . keys ( ) ; </a> 0
<a> while ( keys . hasNext ( ) ) { </a> 0
<a> Object thisValue = jsonObject . opt ( keys . next ( ) ) ; </a> 0
<a> if ( thisValue != null && thisValue . equals ( value ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private final static class JSONObjectEntry implements Map . Entry < String , Object > { </a> 0
<a> private final String key ; </a> 0
<a> private final Object value ; </a> 0
<a> JSONObjectEntry ( String key , Object value ) { </a> 0
<a> this . key = key ; </a> 0
<a> this . value = value ; </a> 0
<a> } </a> 0
<a> @ SuppressLint ( "FieldGetter" ) </a> 0
<a> @ Override </a> 0
<a> public String getKey ( ) { </a> 0
<a> return this . key ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object getValue ( ) { </a> 0
<a> return this . value ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object setValue ( Object object ) { </a> 0
<a> throw new UnsupportedOperationException ( "JSONObjectEntry is immutable" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static Set < Map . Entry < String , Object > > jsonObjectEntrySet ( JSONObject jsonObject ) { </a> 0
<a> HashSet < Map . Entry < String , Object > > result = new HashSet < Map . Entry < String , Object > > ( ) ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> Iterator < String > keys = ( Iterator < String > ) jsonObject . keys ( ) ; </a> 0
<a> while ( keys . hasNext ( ) ) { </a> 0
<a> String key = keys . next ( ) ; </a> 0
<a> Object value = jsonObject . opt ( key ) ; </a> 0
<a> result . add ( new JSONObjectEntry ( key , value ) ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> static Set < String > jsonObjectKeySet ( JSONObject jsonObject ) { </a> 0
<a> HashSet < String > result = new HashSet < String > ( ) ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> Iterator < String > keys = ( Iterator < String > ) jsonObject . keys ( ) ; </a> 0
<a> while ( keys . hasNext ( ) ) { </a> 0
<a> result . add ( keys . next ( ) ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> static void jsonObjectPutAll ( JSONObject jsonObject , Map < String , Object > map ) { </a> 0
<a> Set < Map . Entry < String , Object > > entrySet = map . entrySet ( ) ; </a> 0
<a> for ( Map . Entry < String , Object > entry : entrySet ) { </a> 0
<a> try { </a> 0
<a> jsonObject . putOpt ( entry . getKey ( ) , entry . getValue ( ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> throw new IllegalArgumentException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static Collection < Object > jsonObjectValues ( JSONObject jsonObject ) { </a> 0
<a> ArrayList < Object > result = new ArrayList < Object > ( ) ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> Iterator < String > keys = ( Iterator < String > ) jsonObject . keys ( ) ; </a> 0
<a> while ( keys . hasNext ( ) ) { </a> 0
<a> result . add ( jsonObject . opt ( keys . next ( ) ) ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . model ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . List ; </a> 0
<a> public interface OpenGraphAction extends GraphObject { </a> 0
<a> public String getId ( ) ; </a> 0
<a> public void setId ( String id ) ; </a> 0
<a> public Date getStartTime ( ) ; </a> 0
<a> public void setStartTime ( Date startTime ) ; </a> 0
<a> public Date getEndTime ( ) ; </a> 0
<a> public void setEndTime ( Date endTime ) ; </a> 0
<a> public Date getPublishTime ( ) ; </a> 0
<a> public void setPublishTime ( Date publishTime ) ; </a> 0
<a> public Date getCreatedTime ( ) ; </a> 0
<a> public void setCreatedTime ( Date createdTime ) ; </a> 0
<a> public Date getExpiresTime ( ) ; </a> 0
<a> public void setExpiresTime ( Date expiresTime ) ; </a> 0
<a> public String getRef ( ) ; </a> 0
<a> public void setRef ( String ref ) ; </a> 0
<a> public String getMessage ( ) ; </a> 0
<a> public void setMessage ( String message ) ; </a> 0
<a> public GraphPlace getPlace ( ) ; </a> 0
<a> public void setPlace ( GraphPlace place ) ; </a> 0
<a> public List < GraphObject > getTags ( ) ; </a> 0
<a> public void setTags ( List < ? extends GraphObject > tags ) ; </a> 0
<a> public List < JSONObject > getImage ( ) ; </a> 0
<a> public void setImage ( List < JSONObject > image ) ; </a> 0
<a> public GraphUser getFrom ( ) ; </a> 0
<a> public void setFrom ( GraphUser from ) ; </a> 0
<a> public JSONObject getLikes ( ) ; </a> 0
<a> public void setLikes ( JSONObject likes ) ; </a> 0
<a> public GraphObject getApplication ( ) ; </a> 0
<a> public void setApplication ( GraphObject application ) ; </a> 0
<a> public JSONObject getComments ( ) ; </a> 0
<a> public void setComments ( JSONObject comments ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . model ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> public @ interface PropertyName { </a> 0
<a> String value ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import com . facebook . Session ; </a> 0
<a> import com . facebook . SessionLoginBehavior ; </a> 0
<a> import com . facebook . SessionState ; </a> 0
<a> import com . facebook . internal . SessionAuthorizationType ; </a> 0
<a> import com . facebook . internal . SessionTracker ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . List ; </a> 0
<a> class FacebookFragment extends Fragment { </a> 0
<a> private SessionTracker sessionTracker ; </a> 0
<a> @ Override </a> 0
<a> public void onActivityCreated ( Bundle savedInstanceState ) { </a> 0
<a> super . onActivityCreated ( savedInstanceState ) ; </a> 0
<a> sessionTracker = new SessionTracker ( getActivity ( ) , new DefaultSessionStatusCallback ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> super . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> sessionTracker . getSession ( ) . onActivityResult ( this . getActivity ( ) , requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDestroy ( ) { </a> 0
<a> super . onDestroy ( ) ; </a> 0
<a> sessionTracker . stopTracking ( ) ; </a> 0
<a> } </a> 0
<a> public void setSession ( Session newSession ) { </a> 0
<a> if ( sessionTracker != null ) { </a> 0
<a> sessionTracker . setSession ( newSession ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void onSessionStateChange ( SessionState state , Exception exception ) { </a> 0
<a> } </a> 0
<a> protected final Session getSession ( ) { </a> 0
<a> if ( sessionTracker != null ) { </a> 0
<a> return sessionTracker . getSession ( ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> protected final boolean isSessionOpen ( ) { </a> 0
<a> if ( sessionTracker != null ) { </a> 0
<a> return sessionTracker . getOpenSession ( ) != null ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> protected final SessionState getSessionState ( ) { </a> 0
<a> if ( sessionTracker != null ) { </a> 0
<a> Session currentSession = sessionTracker . getSession ( ) ; </a> 0
<a> return ( currentSession != null ) ? currentSession . getState ( ) : null ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> protected final String getAccessToken ( ) { </a> 0
<a> if ( sessionTracker != null ) { </a> 0
<a> Session currentSession = sessionTracker . getOpenSession ( ) ; </a> 0
<a> return ( currentSession != null ) ? currentSession . getAccessToken ( ) : null ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> protected final Date getExpirationDate ( ) { </a> 0
<a> if ( sessionTracker != null ) { </a> 0
<a> Session currentSession = sessionTracker . getOpenSession ( ) ; </a> 0
<a> return ( currentSession != null ) ? currentSession . getExpirationDate ( ) : null ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> protected final void closeSession ( ) { </a> 0
<a> if ( sessionTracker != null ) { </a> 0
<a> Session currentSession = sessionTracker . getOpenSession ( ) ; </a> 0
<a> if ( currentSession != null ) { </a> 0
<a> currentSession . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected final void closeSessionAndClearTokenInformation ( ) { </a> 0
<a> if ( sessionTracker != null ) { </a> 0
<a> Session currentSession = sessionTracker . getOpenSession ( ) ; </a> 0
<a> if ( currentSession != null ) { </a> 0
<a> currentSession . closeAndClearTokenInformation ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected final List < String > getSessionPermissions ( ) { </a> 0
<a> if ( sessionTracker != null ) { </a> 0
<a> Session currentSession = sessionTracker . getSession ( ) ; </a> 0
<a> return ( currentSession != null ) ? currentSession . getPermissions ( ) : null ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> protected final void openSession ( ) { </a> 0
<a> openSessionForRead ( null , null ) ; </a> 0
<a> } </a> 0
<a> protected final void openSessionForRead ( String applicationId , List < String > permissions ) { </a> 0
<a> openSessionForRead ( applicationId , permissions , SessionLoginBehavior . SSO_WITH_FALLBACK , </a> 0
<a> Session . DEFAULT_AUTHORIZE_ACTIVITY_CODE ) ; </a> 0
<a> } </a> 0
<a> protected final void openSessionForRead ( String applicationId , List < String > permissions , </a> 0
<a> SessionLoginBehavior behavior , int activityCode ) { </a> 0
<a> openSession ( applicationId , permissions , behavior , activityCode , SessionAuthorizationType . READ ) ; </a> 0
<a> } </a> 0
<a> protected final void openSessionForPublish ( String applicationId , List < String > permissions ) { </a> 0
<a> openSessionForPublish ( applicationId , permissions , SessionLoginBehavior . SSO_WITH_FALLBACK , </a> 0
<a> Session . DEFAULT_AUTHORIZE_ACTIVITY_CODE ) ; </a> 0
<a> } </a> 0
<a> protected final void openSessionForPublish ( String applicationId , List < String > permissions , </a> 0
<a> SessionLoginBehavior behavior , int activityCode ) { </a> 0
<a> openSession ( applicationId , permissions , behavior , activityCode , SessionAuthorizationType . PUBLISH ) ; </a> 0
<a> } </a> 0
<a> private void openSession ( String applicationId , List < String > permissions , </a> 0
<a> SessionLoginBehavior behavior , int activityCode , SessionAuthorizationType authType ) { </a> 0
<a> if ( sessionTracker != null ) { </a> 0
<a> Session currentSession = sessionTracker . getSession ( ) ; </a> 0
<a> if ( currentSession == null || currentSession . getState ( ) . isClosed ( ) ) { </a> 0
<a> Session session = new Session . Builder ( getActivity ( ) ) . setApplicationId ( applicationId ) . build ( ) ; </a> 0
<a> Session . setActiveSession ( session ) ; </a> 0
<a> currentSession = session ; </a> 0
<a> } </a> 0
<a> if ( ! currentSession . isOpened ( ) ) { </a> 0
<a> Session . OpenRequest openRequest = new Session . OpenRequest ( this ) . </a> 0
<a> setPermissions ( permissions ) . </a> 0
<a> setLoginBehavior ( behavior ) . </a> 0
<a> setRequestCode ( activityCode ) ; </a> 0
<a> if ( SessionAuthorizationType . PUBLISH . equals ( authType ) ) { </a> 0
<a> currentSession . openForPublish ( openRequest ) ; </a> 0
<a> } else { </a> 0
<a> currentSession . openForRead ( openRequest ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class DefaultSessionStatusCallback implements Session . StatusCallback { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , </a> 0
<a> SessionState state , </a> 0
<a> Exception exception ) { </a> 0
<a> FacebookFragment . this . onSessionStateChange ( state , exception ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . annotation . SuppressLint ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . res . TypedArray ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import android . util . AttributeSet ; </a> 0
<a> import com . facebook . * ; </a> 1
<a> import com . facebook . android . R ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import java . util . Arrays ; </a> 1
<a> import java . util . HashSet ; </a> 1
<a> import java . util . List ; </a> 1
<a> import java . util . Set ; </a> 1
<a> public class FriendPickerFragment extends PickerFragment < GraphUser > { </a> 0
<a> public static final String USER_ID_BUNDLE_KEY = "com.facebook.widget.FriendPickerFragment.UserId" ; </a> 0
<a> public static final String MULTI_SELECT_BUNDLE_KEY = "com.facebook.widget.FriendPickerFragment.MultiSelect" ; </a> 0
<a> private static final String ID = "id" ; </a> 0
<a> private static final String NAME = "name" ; </a> 0
<a> private String userId ; </a> 0
<a> private boolean multiSelect = true ; </a> 0
<a> public FriendPickerFragment ( ) { </a> 0
<a> this ( null ) ; </a> 0
<a> } </a> 0
<a> @ SuppressLint ( "ValidFragment" ) </a> 0
<a> public FriendPickerFragment ( Bundle args ) { </a> 0
<a> super ( GraphUser . class , R . layout . com_facebook_friendpickerfragment , args ) ; </a> 0
<a> setFriendPickerSettingsFromBundle ( args ) ; </a> 0
<a> } </a> 0
<a> public String getUserId ( ) { </a> 0
<a> return userId ; </a> 0
<a> } </a> 0
<a> public void setUserId ( String userId ) { </a> 0
<a> this . userId = userId ; </a> 0
<a> } </a> 0
<a> public boolean getMultiSelect ( ) { </a> 0
<a> return multiSelect ; </a> 0
<a> } </a> 0
<a> public void setMultiSelect ( boolean multiSelect ) { </a> 0
<a> if ( this . multiSelect != multiSelect ) { </a> 0
<a> this . multiSelect = multiSelect ; </a> 0
<a> setSelectionStrategy ( createSelectionStrategy ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public List < GraphUser > getSelection ( ) { </a> 0
<a> return getSelectedGraphObjects ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onInflate ( Activity activity , AttributeSet attrs , Bundle savedInstanceState ) { </a> 0
<a> super . onInflate ( activity , attrs , savedInstanceState ) ; </a> 0
<a> TypedArray a = activity . obtainStyledAttributes ( attrs , R . styleable . com_facebook_friend_picker_fragment ) ; </a> 0
<a> setMultiSelect ( a . getBoolean ( R . styleable . com_facebook_friend_picker_fragment_multi_select , multiSelect ) ) ; </a> 0
<a> a . recycle ( ) ; </a> 0
<a> } </a> 0
<a> public void setSettingsFromBundle ( Bundle inState ) { </a> 0
<a> super . setSettingsFromBundle ( inState ) ; </a> 0
<a> setFriendPickerSettingsFromBundle ( inState ) ; </a> 0
<a> } </a> 0
<a> void saveSettingsToBundle ( Bundle outState ) { </a> 0
<a> super . saveSettingsToBundle ( outState ) ; </a> 0
<a> outState . putString ( USER_ID_BUNDLE_KEY , userId ) ; </a> 0
<a> outState . putBoolean ( MULTI_SELECT_BUNDLE_KEY , multiSelect ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> PickerFragmentAdapter < GraphUser > createAdapter ( ) { </a> 0
<a> PickerFragmentAdapter < GraphUser > adapter = new PickerFragmentAdapter < GraphUser > ( </a> 0
<a> this . getActivity ( ) ) { </a> 0
<a> @ Override </a> 0
<a> protected int getGraphObjectRowLayoutId ( GraphUser graphObject ) { </a> 0
<a> return R . layout . com_facebook_picker_list_row ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int getDefaultPicture ( ) { </a> 0
<a> return R . drawable . com_facebook_profile_default_icon ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> adapter . setShowCheckbox ( true ) ; </a> 0
<a> adapter . setShowPicture ( getShowPictures ( ) ) ; </a> 0
<a> adapter . setSortFields ( Arrays . asList ( new String [ ] { NAME } ) ) ; </a> 0
<a> adapter . setGroupByField ( NAME ) ; </a> 0
<a> return adapter ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> LoadingStrategy createLoadingStrategy ( ) { </a> 0
<a> return new ImmediateLoadingStrategy ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> SelectionStrategy createSelectionStrategy ( ) { </a> 0
<a> return multiSelect ? new MultiSelectionStrategy ( ) : new SingleSelectionStrategy ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> Request getRequestForLoadData ( Session session ) { </a> 0
<a> if ( adapter == null ) { </a> 0
<a> throw new FacebookException ( "Can't issue requests until Fragment has been created." ) ; </a> 0
<a> } </a> 0
<a> String userToFetch = ( userId != null ) ? userId : "me" ; </a> 0
<a> return createRequest ( userToFetch , extraFields , session ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> String getDefaultTitleText ( ) { </a> 0
<a> return getString ( R . string . com_facebook_choose_friends ) ; </a> 0
<a> } </a> 0
<a> private Request createRequest ( String userID , Set < String > extraFields , Session session ) { </a> 0
<a> Request request = Request . newGraphPathRequest ( session , userID + "/friends" , null ) ; </a> 0
<a> Set < String > fields = new HashSet < String > ( extraFields ) ; </a> 0
<a> String [ ] requiredFields = new String [ ] { </a> 0
<a> ID , </a> 0
<a> NAME </a> 0
<a> } ; </a> 0
<a> fields . addAll ( Arrays . asList ( requiredFields ) ) ; </a> 0
<a> String pictureField = adapter . getPictureFieldSpecifier ( ) ; </a> 0
<a> if ( pictureField != null ) { </a> 0
<a> fields . add ( pictureField ) ; </a> 0
<a> } </a> 0
<a> Bundle parameters = request . getParameters ( ) ; </a> 0
<a> parameters . putString ( "fields" , TextUtils . join ( "," , fields ) ) ; </a> 0
<a> request . setParameters ( parameters ) ; </a> 0
<a> return request ; </a> 0
<a> } </a> 0
<a> private void setFriendPickerSettingsFromBundle ( Bundle inState ) { </a> 0
<a> if ( inState != null ) { </a> 0
<a> if ( inState . containsKey ( USER_ID_BUNDLE_KEY ) ) { </a> 0
<a> setUserId ( inState . getString ( USER_ID_BUNDLE_KEY ) ) ; </a> 0
<a> } </a> 0
<a> setMultiSelect ( inState . getBoolean ( MULTI_SELECT_BUNDLE_KEY , multiSelect ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class ImmediateLoadingStrategy extends LoadingStrategy { </a> 0
<a> @ Override </a> 0
<a> protected void onLoadFinished ( GraphObjectPagingLoader < GraphUser > loader , </a> 0
<a> SimpleGraphObjectCursor < GraphUser > data ) { </a> 0
<a> super . onLoadFinished ( loader , data ) ; </a> 0
<a> if ( data == null || loader . isLoading ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( data . areMoreObjectsAvailable ( ) ) { </a> 0
<a> followNextLink ( ) ; </a> 0
<a> } else { </a> 0
<a> hideActivityCircle ( ) ; </a> 0
<a> if ( data . isFromCache ( ) ) { </a> 0
<a> loader . refreshOriginalRequest ( data . getCount ( ) == 0 ? CACHED_RESULT_REFRESH_DELAY : 0 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void followNextLink ( ) { </a> 0
<a> displayActivityCircle ( ) ; </a> 0
<a> loader . followNextLink ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . view . LayoutInflater ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . view . ViewStub ; </a> 0
<a> import android . widget . * ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . android . R ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> import java . net . URL ; </a> 0
<a> import java . text . Collator ; </a> 0
<a> import java . util . * ; </a> 0
<a> class GraphObjectAdapter < T extends GraphObject > extends BaseAdapter implements SectionIndexer { </a> 0
<a> private static final int DISPLAY_SECTIONS_THRESHOLD = 1 ; </a> 0
<a> private static final int HEADER_VIEW_TYPE = 0 ; </a> 0
<a> private static final int GRAPH_OBJECT_VIEW_TYPE = 1 ; </a> 0
<a> private static final int ACTIVITY_CIRCLE_VIEW_TYPE = 2 ; </a> 0
<a> private static final int MAX_PREFETCHED_PICTURES = 20 ; </a> 0
<a> private static final String ID = "id" ; </a> 0
<a> private static final String NAME = "name" ; </a> 0
<a> private static final String PICTURE = "picture" ; </a> 0
<a> private final Map < String , ImageRequest > pendingRequests = new HashMap < String , ImageRequest > ( ) ; </a> 0
<a> private final LayoutInflater inflater ; </a> 0
<a> private List < String > sectionKeys = new ArrayList < String > ( ) ; </a> 0
<a> private Map < String , ArrayList < T > > graphObjectsBySection = new HashMap < String , ArrayList < T > > ( ) ; </a> 0
<a> private Map < String , T > graphObjectsById = new HashMap < String , T > ( ) ; </a> 0
<a> private boolean displaySections ; </a> 0
<a> private List < String > sortFields ; </a> 0
<a> private String groupByField ; </a> 0
<a> private boolean showPicture ; </a> 0
<a> private boolean showCheckbox ; </a> 0
<a> private Filter < T > filter ; </a> 0
<a> private DataNeededListener dataNeededListener ; </a> 0
<a> private GraphObjectCursor < T > cursor ; </a> 0
<a> private Context context ; </a> 0
<a> private Map < String , ImageResponse > prefetchedPictureCache = new HashMap < String , ImageResponse > ( ) ; </a> 0
<a> private ArrayList < String > prefetchedProfilePictureIds = new ArrayList < String > ( ) ; </a> 0
<a> public interface DataNeededListener { </a> 0
<a> public void onDataNeeded ( ) ; </a> 0
<a> } </a> 0
<a> public static class SectionAndItem < T extends GraphObject > { </a> 0
<a> public String sectionKey ; </a> 0
<a> public T graphObject ; </a> 0
<a> public enum Type { </a> 0
<a> GRAPH_OBJECT , </a> 0
<a> SECTION_HEADER , </a> 0
<a> ACTIVITY_CIRCLE </a> 0
<a> } </a> 0
<a> public SectionAndItem ( String sectionKey , T graphObject ) { </a> 0
<a> this . sectionKey = sectionKey ; </a> 0
<a> this . graphObject = graphObject ; </a> 0
<a> } </a> 0
<a> public Type getType ( ) { </a> 0
<a> if ( sectionKey == null ) { </a> 0
<a> return Type . ACTIVITY_CIRCLE ; </a> 0
<a> } else if ( graphObject == null ) { </a> 0
<a> return Type . SECTION_HEADER ; </a> 0
<a> } else { </a> 0
<a> return Type . GRAPH_OBJECT ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> interface Filter < T > { </a> 0
<a> boolean includeItem ( T graphObject ) ; </a> 0
<a> } </a> 0
<a> public GraphObjectAdapter ( Context context ) { </a> 0
<a> this . context = context ; </a> 0
<a> this . inflater = LayoutInflater . from ( context ) ; </a> 0
<a> } </a> 0
<a> public List < String > getSortFields ( ) { </a> 0
<a> return sortFields ; </a> 0
<a> } </a> 0
<a> public void setSortFields ( List < String > sortFields ) { </a> 0
<a> this . sortFields = sortFields ; </a> 0
<a> } </a> 0
<a> public String getGroupByField ( ) { </a> 0
<a> return groupByField ; </a> 0
<a> } </a> 0
<a> public void setGroupByField ( String groupByField ) { </a> 0
<a> this . groupByField = groupByField ; </a> 0
<a> } </a> 0
<a> public boolean getShowPicture ( ) { </a> 0
<a> return showPicture ; </a> 0
<a> } </a> 0
<a> public void setShowPicture ( boolean showPicture ) { </a> 0
<a> this . showPicture = showPicture ; </a> 0
<a> } </a> 0
<a> public boolean getShowCheckbox ( ) { </a> 0
<a> return showCheckbox ; </a> 0
<a> } </a> 0
<a> public void setShowCheckbox ( boolean showCheckbox ) { </a> 0
<a> this . showCheckbox = showCheckbox ; </a> 0
<a> } </a> 0
<a> public DataNeededListener getDataNeededListener ( ) { </a> 0
<a> return dataNeededListener ; </a> 0
<a> } </a> 0
<a> public void setDataNeededListener ( DataNeededListener dataNeededListener ) { </a> 0
<a> this . dataNeededListener = dataNeededListener ; </a> 0
<a> } </a> 0
<a> public GraphObjectCursor < T > getCursor ( ) { </a> 0
<a> return cursor ; </a> 0
<a> } </a> 0
<a> public boolean changeCursor ( GraphObjectCursor < T > cursor ) { </a> 0
<a> if ( this . cursor == cursor ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( this . cursor != null ) { </a> 0
<a> this . cursor . close ( ) ; </a> 0
<a> } </a> 0
<a> this . cursor = cursor ; </a> 0
<a> rebuildAndNotify ( ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public void rebuildAndNotify ( ) { </a> 0
<a> rebuildSections ( ) ; </a> 0
<a> notifyDataSetChanged ( ) ; </a> 0
<a> } </a> 0
<a> public void prioritizeViewRange ( int firstVisibleItem , int lastVisibleItem , int prefetchBuffer ) { </a> 0
<a> if ( lastVisibleItem < firstVisibleItem ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> for ( int i = lastVisibleItem ; i >= 0 ; i -- ) { </a> 0
<a> SectionAndItem < T > sectionAndItem = getSectionAndItem ( i ) ; </a> 0
<a> if ( sectionAndItem . graphObject != null ) { </a> 0
<a> String id = getIdOfGraphObject ( sectionAndItem . graphObject ) ; </a> 0
<a> ImageRequest request = pendingRequests . get ( id ) ; </a> 0
<a> if ( request != null ) { </a> 0
<a> ImageDownloader . prioritizeRequest ( request ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int start = Math . max ( 0 , firstVisibleItem - prefetchBuffer ) ; </a> 0
<a> int end = Math . min ( lastVisibleItem + prefetchBuffer , getCount ( ) - 1 ) ; </a> 0
<a> ArrayList < T > graphObjectsToPrefetchPicturesFor = new ArrayList < T > ( ) ; </a> 0
<a> for ( int i = start ; i < firstVisibleItem ; ++ i ) { </a> 0
<a> SectionAndItem < T > sectionAndItem = getSectionAndItem ( i ) ; </a> 0
<a> if ( sectionAndItem . graphObject != null ) { </a> 0
<a> graphObjectsToPrefetchPicturesFor . add ( sectionAndItem . graphObject ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( int i = lastVisibleItem + 1 ; i <= end ; ++ i ) { </a> 0
<a> SectionAndItem < T > sectionAndItem = getSectionAndItem ( i ) ; </a> 0
<a> if ( sectionAndItem . graphObject != null ) { </a> 0
<a> graphObjectsToPrefetchPicturesFor . add ( sectionAndItem . graphObject ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( T graphObject : graphObjectsToPrefetchPicturesFor ) { </a> 0
<a> URL url = getPictureUrlOfGraphObject ( graphObject ) ; </a> 0
<a> final String id = getIdOfGraphObject ( graphObject ) ; </a> 0
<a> boolean alreadyPrefetching = prefetchedProfilePictureIds . remove ( id ) ; </a> 0
<a> prefetchedProfilePictureIds . add ( id ) ; </a> 0
<a> if ( ! alreadyPrefetching ) { </a> 0
<a> downloadProfilePicture ( id , url , null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected String getSectionKeyOfGraphObject ( T graphObject ) { </a> 0
<a> String result = null ; </a> 0
<a> if ( groupByField != null ) { </a> 0
<a> result = ( String ) graphObject . getProperty ( groupByField ) ; </a> 0
<a> if ( result != null && result . length ( ) > 0 ) { </a> 0
<a> result = result . substring ( 0 , 1 ) . toUpperCase ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return ( result != null ) ? result : "" ; </a> 0
<a> } </a> 0
<a> protected CharSequence getTitleOfGraphObject ( T graphObject ) { </a> 0
<a> return ( String ) graphObject . getProperty ( NAME ) ; </a> 0
<a> } </a> 0
<a> protected CharSequence getSubTitleOfGraphObject ( T graphObject ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> protected URL getPictureUrlOfGraphObject ( T graphObject ) { </a> 0
<a> String url = null ; </a> 0
<a> Object o = graphObject . getProperty ( PICTURE ) ; </a> 0
<a> if ( o instanceof String ) { </a> 0
<a> url = ( String ) o ; </a> 0
<a> } else if ( o instanceof JSONObject ) { </a> 0
<a> ItemPicture itemPicture = GraphObject . Factory . create ( ( JSONObject ) o ) . cast ( ItemPicture . class ) ; </a> 0
<a> ItemPictureData data = itemPicture . getData ( ) ; </a> 0
<a> if ( data != null ) { </a> 0
<a> url = data . getUrl ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( url != null ) { </a> 0
<a> try { </a> 0
<a> return new URL ( url ) ; </a> 0
<a> } catch ( MalformedURLException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> protected View getSectionHeaderView ( String sectionHeader , View convertView , ViewGroup parent ) { </a> 0
<a> TextView result = ( TextView ) convertView ; </a> 0
<a> if ( result == null ) { </a> 0
<a> result = ( TextView ) inflater . inflate ( R . layout . com_facebook_picker_list_section_header , null ) ; </a> 0
<a> } </a> 0
<a> result . setText ( sectionHeader ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> protected View getGraphObjectView ( T graphObject , View convertView , ViewGroup parent ) { </a> 0
<a> View result = convertView ; </a> 0
<a> if ( result == null ) { </a> 0
<a> result = createGraphObjectView ( graphObject , convertView ) ; </a> 0
<a> } </a> 0
<a> populateGraphObjectView ( result , graphObject ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> private View getActivityCircleView ( View convertView , ViewGroup parent ) { </a> 0
<a> View result = convertView ; </a> 0
<a> if ( result == null ) { </a> 0
<a> result = inflater . inflate ( R . layout . com_facebook_picker_activity_circle_row , null ) ; </a> 0
<a> } </a> 0
<a> ProgressBar activityCircle = ( ProgressBar ) result . findViewById ( R . id . com_facebook_picker_row_activity_circle ) ; </a> 0
<a> activityCircle . setVisibility ( View . VISIBLE ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> protected int getGraphObjectRowLayoutId ( T graphObject ) { </a> 0
<a> return R . layout . com_facebook_picker_list_row ; </a> 0
<a> } </a> 0
<a> protected int getDefaultPicture ( ) { </a> 0
<a> return R . drawable . com_facebook_profile_default_icon ; </a> 0
<a> } </a> 0
<a> protected View createGraphObjectView ( T graphObject , View convertView ) { </a> 0
<a> View result = inflater . inflate ( getGraphObjectRowLayoutId ( graphObject ) , null ) ; </a> 0
<a> ViewStub checkboxStub = ( ViewStub ) result . findViewById ( R . id . com_facebook_picker_checkbox_stub ) ; </a> 0
<a> if ( checkboxStub != null ) { </a> 0
<a> if ( ! getShowCheckbox ( ) ) { </a> 0
<a> checkboxStub . setVisibility ( View . GONE ) ; </a> 0
<a> } else { </a> 0
<a> CheckBox checkBox = ( CheckBox ) checkboxStub . inflate ( ) ; </a> 0
<a> updateCheckboxState ( checkBox , false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ViewStub profilePicStub = ( ViewStub ) result . findViewById ( R . id . com_facebook_picker_profile_pic_stub ) ; </a> 0
<a> if ( ! getShowPicture ( ) ) { </a> 0
<a> profilePicStub . setVisibility ( View . GONE ) ; </a> 0
<a> } else { </a> 0
<a> ImageView imageView = ( ImageView ) profilePicStub . inflate ( ) ; </a> 0
<a> imageView . setVisibility ( View . VISIBLE ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> protected void populateGraphObjectView ( View view , T graphObject ) { </a> 0
<a> String id = getIdOfGraphObject ( graphObject ) ; </a> 0
<a> view . setTag ( id ) ; </a> 0
<a> CharSequence title = getTitleOfGraphObject ( graphObject ) ; </a> 0
<a> TextView titleView = ( TextView ) view . findViewById ( R . id . com_facebook_picker_title ) ; </a> 0
<a> if ( titleView != null ) { </a> 0
<a> titleView . setText ( title , TextView . BufferType . SPANNABLE ) ; </a> 0
<a> } </a> 0
<a> CharSequence subtitle = getSubTitleOfGraphObject ( graphObject ) ; </a> 0
<a> TextView subtitleView = ( TextView ) view . findViewById ( R . id . picker_subtitle ) ; </a> 0
<a> if ( subtitleView != null ) { </a> 0
<a> if ( subtitle != null ) { </a> 0
<a> subtitleView . setText ( subtitle , TextView . BufferType . SPANNABLE ) ; </a> 0
<a> subtitleView . setVisibility ( View . VISIBLE ) ; </a> 0
<a> } else { </a> 0
<a> subtitleView . setVisibility ( View . GONE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( getShowCheckbox ( ) ) { </a> 0
<a> CheckBox checkBox = ( CheckBox ) view . findViewById ( R . id . com_facebook_picker_checkbox ) ; </a> 0
<a> updateCheckboxState ( checkBox , isGraphObjectSelected ( id ) ) ; </a> 0
<a> } </a> 0
<a> if ( getShowPicture ( ) ) { </a> 0
<a> URL pictureURL = getPictureUrlOfGraphObject ( graphObject ) ; </a> 0
<a> if ( pictureURL != null ) { </a> 0
<a> ImageView profilePic = ( ImageView ) view . findViewById ( R . id . com_facebook_picker_image ) ; </a> 0
<a> if ( prefetchedPictureCache . containsKey ( id ) ) { </a> 0
<a> ImageResponse response = prefetchedPictureCache . get ( id ) ; </a> 0
<a> profilePic . setImageBitmap ( response . getBitmap ( ) ) ; </a> 0
<a> profilePic . setTag ( response . getRequest ( ) . getImageUrl ( ) ) ; </a> 0
<a> } else { </a> 0
<a> downloadProfilePicture ( id , pictureURL , profilePic ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> String getIdOfGraphObject ( T graphObject ) { </a> 0
<a> if ( graphObject . asMap ( ) . containsKey ( ID ) ) { </a> 0
<a> Object obj = graphObject . getProperty ( ID ) ; </a> 0
<a> if ( obj instanceof String ) { </a> 0
<a> return ( String ) obj ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> throw new FacebookException ( "Received an object without an ID." ) ; </a> 0
<a> } </a> 0
<a> boolean filterIncludesItem ( T graphObject ) { </a> 0
<a> return filter == null || filter . includeItem ( graphObject ) ; </a> 0
<a> } </a> 0
<a> Filter < T > getFilter ( ) { </a> 0
<a> return filter ; </a> 0
<a> } </a> 0
<a> void setFilter ( Filter < T > filter ) { </a> 0
<a> this . filter = filter ; </a> 0
<a> } </a> 0
<a> boolean isGraphObjectSelected ( String graphObjectId ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> void updateCheckboxState ( CheckBox checkBox , boolean graphObjectSelected ) { </a> 0
<a> } </a> 0
<a> String getPictureFieldSpecifier ( ) { </a> 0
<a> View view = createGraphObjectView ( null , null ) ; </a> 0
<a> ImageView picture = ( ImageView ) view . findViewById ( R . id . com_facebook_picker_image ) ; </a> 0
<a> if ( picture == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> ViewGroup . LayoutParams layoutParams = picture . getLayoutParams ( ) ; </a> 0
<a> return String . format ( "picture.height(%d).width(%d)" , layoutParams . height , layoutParams . width ) ; </a> 0
<a> } </a> 0
<a> private boolean shouldShowActivityCircleCell ( ) { </a> 0
<a> return ( cursor != null ) && cursor . areMoreObjectsAvailable ( ) && ( dataNeededListener != null ) && ! isEmpty ( ) ; </a> 0
<a> } </a> 0
<a> private void rebuildSections ( ) { </a> 0
<a> sectionKeys = new ArrayList < String > ( ) ; </a> 0
<a> graphObjectsBySection = new HashMap < String , ArrayList < T > > ( ) ; </a> 0
<a> graphObjectsById = new HashMap < String , T > ( ) ; </a> 0
<a> displaySections = false ; </a> 0
<a> if ( cursor == null || cursor . getCount ( ) == 0 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> int objectsAdded = 0 ; </a> 0
<a> cursor . moveToFirst ( ) ; </a> 0
<a> do { </a> 0
<a> T graphObject = cursor . getGraphObject ( ) ; </a> 0
<a> if ( ! filterIncludesItem ( graphObject ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> objectsAdded ++ ; </a> 0
<a> String sectionKeyOfItem = getSectionKeyOfGraphObject ( graphObject ) ; </a> 0
<a> if ( ! graphObjectsBySection . containsKey ( sectionKeyOfItem ) ) { </a> 0
<a> sectionKeys . add ( sectionKeyOfItem ) ; </a> 0
<a> graphObjectsBySection . put ( sectionKeyOfItem , new ArrayList < T > ( ) ) ; </a> 0
<a> } </a> 0
<a> List < T > section = graphObjectsBySection . get ( sectionKeyOfItem ) ; </a> 0
<a> section . add ( graphObject ) ; </a> 0
<a> graphObjectsById . put ( getIdOfGraphObject ( graphObject ) , graphObject ) ; </a> 0
<a> } while ( cursor . moveToNext ( ) ) ; </a> 0
<a> if ( sortFields != null ) { </a> 0
<a> final Collator collator = Collator . getInstance ( ) ; </a> 0
<a> for ( List < T > section : graphObjectsBySection . values ( ) ) { </a> 0
<a> Collections . sort ( section , new Comparator < GraphObject > ( ) { </a> 0
<a> @ Override </a> 0
<a> public int compare ( GraphObject a , GraphObject b ) { </a> 0
<a> return compareGraphObjects ( a , b , sortFields , collator ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Collections . sort ( sectionKeys , Collator . getInstance ( ) ) ; </a> 0
<a> displaySections = sectionKeys . size ( ) > 1 && objectsAdded > DISPLAY_SECTIONS_THRESHOLD ; </a> 0
<a> } </a> 0
<a> SectionAndItem < T > getSectionAndItem ( int position ) { </a> 0
<a> if ( sectionKeys . size ( ) == 0 ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> String sectionKey = null ; </a> 0
<a> T graphObject = null ; </a> 0
<a> if ( ! displaySections ) { </a> 0
<a> sectionKey = sectionKeys . get ( 0 ) ; </a> 0
<a> List < T > section = graphObjectsBySection . get ( sectionKey ) ; </a> 0
<a> if ( position >= 0 && position < section . size ( ) ) { </a> 0
<a> graphObject = graphObjectsBySection . get ( sectionKey ) . get ( position ) ; </a> 0
<a> } else { </a> 0
<a> assert dataNeededListener != null && cursor . areMoreObjectsAvailable ( ) ; </a> 0
<a> return new SectionAndItem < T > ( null , null ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> for ( String key : sectionKeys ) { </a> 0
<a> if ( position -- == 0 ) { </a> 0
<a> sectionKey = key ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> List < T > section = graphObjectsBySection . get ( key ) ; </a> 0
<a> if ( position < section . size ( ) ) { </a> 0
<a> sectionKey = key ; </a> 0
<a> graphObject = section . get ( position ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> position -= section . size ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( sectionKey != null ) { </a> 0
<a> return new SectionAndItem < T > ( sectionKey , graphObject ) ; </a> 0
<a> } else { </a> 0
<a> throw new IndexOutOfBoundsException ( "position" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int getPosition ( String sectionKey , T graphObject ) { </a> 0
<a> int position = 0 ; </a> 0
<a> boolean found = false ; </a> 0
<a> for ( String key : sectionKeys ) { </a> 0
<a> if ( displaySections ) { </a> 0
<a> position ++ ; </a> 0
<a> } </a> 0
<a> if ( key . equals ( sectionKey ) ) { </a> 0
<a> found = true ; </a> 0
<a> break ; </a> 0
<a> } else { </a> 0
<a> position += graphObjectsBySection . get ( key ) . size ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! found ) { </a> 0
<a> return - 1 ; </a> 0
<a> } else if ( graphObject == null ) { </a> 0
<a> return position - ( displaySections ? 1 : 0 ) ; </a> 0
<a> } </a> 0
<a> for ( T t : graphObjectsBySection . get ( sectionKey ) ) { </a> 0
<a> if ( GraphObject . Factory . hasSameId ( t , graphObject ) ) { </a> 0
<a> return position ; </a> 0
<a> } </a> 0
<a> position ++ ; </a> 0
<a> } </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEmpty ( ) { </a> 0
<a> return sectionKeys . size ( ) == 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getCount ( ) { </a> 0
<a> if ( sectionKeys . size ( ) == 0 ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> int count = ( displaySections ) ? sectionKeys . size ( ) : 0 ; </a> 0
<a> for ( List < T > section : graphObjectsBySection . values ( ) ) { </a> 0
<a> count += section . size ( ) ; </a> 0
<a> } </a> 0
<a> if ( shouldShowActivityCircleCell ( ) ) { </a> 0
<a> ++ count ; </a> 0
<a> } </a> 0
<a> return count ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean areAllItemsEnabled ( ) { </a> 0
<a> return displaySections ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasStableIds ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEnabled ( int position ) { </a> 0
<a> SectionAndItem < T > sectionAndItem = getSectionAndItem ( position ) ; </a> 0
<a> return sectionAndItem . getType ( ) == SectionAndItem . Type . GRAPH_OBJECT ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object getItem ( int position ) { </a> 0
<a> SectionAndItem < T > sectionAndItem = getSectionAndItem ( position ) ; </a> 0
<a> return ( sectionAndItem . getType ( ) == SectionAndItem . Type . GRAPH_OBJECT ) ? sectionAndItem . graphObject : null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getItemId ( int position ) { </a> 0
<a> SectionAndItem < T > sectionAndItem = getSectionAndItem ( position ) ; </a> 0
<a> if ( sectionAndItem != null && sectionAndItem . graphObject != null ) { </a> 0
<a> String id = getIdOfGraphObject ( sectionAndItem . graphObject ) ; </a> 0
<a> if ( id != null ) { </a> 0
<a> return Long . parseLong ( id ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getViewTypeCount ( ) { </a> 0
<a> return 3 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getItemViewType ( int position ) { </a> 0
<a> SectionAndItem < T > sectionAndItem = getSectionAndItem ( position ) ; </a> 0
<a> switch ( sectionAndItem . getType ( ) ) { </a> 0
<a> case SECTION_HEADER : </a> 0
<a> return HEADER_VIEW_TYPE ; </a> 0
<a> case GRAPH_OBJECT : </a> 0
<a> return GRAPH_OBJECT_VIEW_TYPE ; </a> 0
<a> case ACTIVITY_CIRCLE : </a> 0
<a> return ACTIVITY_CIRCLE_VIEW_TYPE ; </a> 0
<a> default : </a> 0
<a> throw new FacebookException ( "Unexpected type of section and item." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View getView ( int position , View convertView , ViewGroup parent ) { </a> 0
<a> SectionAndItem < T > sectionAndItem = getSectionAndItem ( position ) ; </a> 0
<a> switch ( sectionAndItem . getType ( ) ) { </a> 0
<a> case SECTION_HEADER : </a> 0
<a> return getSectionHeaderView ( sectionAndItem . sectionKey , convertView , parent ) ; </a> 0
<a> case GRAPH_OBJECT : </a> 0
<a> return getGraphObjectView ( sectionAndItem . graphObject , convertView , parent ) ; </a> 0
<a> case ACTIVITY_CIRCLE : </a> 0
<a> assert cursor . areMoreObjectsAvailable ( ) && ( dataNeededListener != null ) ; </a> 0
<a> dataNeededListener . onDataNeeded ( ) ; </a> 0
<a> return getActivityCircleView ( convertView , parent ) ; </a> 0
<a> default : </a> 0
<a> throw new FacebookException ( "Unexpected type of section and item." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object [ ] getSections ( ) { </a> 0
<a> if ( displaySections ) { </a> 0
<a> return sectionKeys . toArray ( ) ; </a> 0
<a> } else { </a> 0
<a> return new Object [ 0 ] ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getPositionForSection ( int section ) { </a> 0
<a> if ( displaySections ) { </a> 0
<a> section = Math . max ( 0 , Math . min ( section , sectionKeys . size ( ) - 1 ) ) ; </a> 0
<a> if ( section < sectionKeys . size ( ) ) { </a> 0
<a> return getPosition ( sectionKeys . get ( section ) , null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getSectionForPosition ( int position ) { </a> 0
<a> SectionAndItem < T > sectionAndItem = getSectionAndItem ( position ) ; </a> 0
<a> if ( sectionAndItem != null && </a> 0
<a> sectionAndItem . getType ( ) != SectionAndItem . Type . ACTIVITY_CIRCLE ) { </a> 0
<a> return Math . max ( 0 , Math . min ( sectionKeys . indexOf ( sectionAndItem . sectionKey ) , sectionKeys . size ( ) - 1 ) ) ; </a> 0
<a> } </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> public List < T > getGraphObjectsById ( Collection < String > ids ) { </a> 0
<a> Set < String > idSet = new HashSet < String > ( ) ; </a> 0
<a> idSet . addAll ( ids ) ; </a> 0
<a> ArrayList < T > result = new ArrayList < T > ( idSet . size ( ) ) ; </a> 0
<a> for ( String id : idSet ) { </a> 0
<a> T graphObject = graphObjectsById . get ( id ) ; </a> 0
<a> if ( graphObject != null ) { </a> 0
<a> result . add ( graphObject ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> private void downloadProfilePicture ( final String profileId , URL pictureURL , final ImageView imageView ) { </a> 0
<a> if ( pictureURL == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> boolean prefetching = imageView == null ; </a> 0
<a> if ( prefetching || ! pictureURL . equals ( imageView . getTag ( ) ) ) { </a> 0
<a> if ( ! prefetching ) { </a> 0
<a> imageView . setTag ( profileId ) ; </a> 0
<a> imageView . setImageResource ( getDefaultPicture ( ) ) ; </a> 0
<a> } </a> 0
<a> ImageRequest . Builder builder = new ImageRequest . Builder ( context . getApplicationContext ( ) , pictureURL ) </a> 0
<a> . setCallerTag ( this ) </a> 0
<a> . setCallback ( </a> 0
<a> new ImageRequest . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( ImageResponse response ) { </a> 0
<a> processImageResponse ( response , profileId , imageView ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> ImageRequest newRequest = builder . build ( ) ; </a> 0
<a> pendingRequests . put ( profileId , newRequest ) ; </a> 0
<a> ImageDownloader . downloadAsync ( newRequest ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void processImageResponse ( ImageResponse response , String graphObjectId , ImageView imageView ) { </a> 0
<a> pendingRequests . remove ( graphObjectId ) ; </a> 0
<a> if ( imageView == null ) { </a> 0
<a> if ( response . getBitmap ( ) != null ) { </a> 0
<a> if ( prefetchedPictureCache . size ( ) >= MAX_PREFETCHED_PICTURES ) { </a> 0
<a> String oldestId = prefetchedProfilePictureIds . remove ( 0 ) ; </a> 0
<a> prefetchedPictureCache . remove ( oldestId ) ; </a> 0
<a> } </a> 0
<a> prefetchedPictureCache . put ( graphObjectId , response ) ; </a> 0
<a> } </a> 0
<a> } else if ( imageView != null && graphObjectId . equals ( imageView . getTag ( ) ) ) { </a> 0
<a> Exception error = response . getError ( ) ; </a> 0
<a> Bitmap bitmap = response . getBitmap ( ) ; </a> 0
<a> if ( error == null && bitmap != null ) { </a> 0
<a> imageView . setImageBitmap ( bitmap ) ; </a> 0
<a> imageView . setTag ( response . getRequest ( ) . getImageUrl ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static int compareGraphObjects ( GraphObject a , GraphObject b , Collection < String > sortFields , </a> 0
<a> Collator collator ) { </a> 0
<a> for ( String sortField : sortFields ) { </a> 0
<a> String sa = ( String ) a . getProperty ( sortField ) ; </a> 0
<a> String sb = ( String ) b . getProperty ( sortField ) ; </a> 0
<a> if ( sa != null && sb != null ) { </a> 0
<a> int result = collator . compare ( sa , sb ) ; </a> 0
<a> if ( result != 0 ) { </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> } else if ( ! ( sa == null && sb == null ) ) { </a> 0
<a> return ( sa == null ) ? - 1 : 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> private interface ItemPicture extends GraphObject { </a> 0
<a> ItemPictureData getData ( ) ; </a> 0
<a> } </a> 0
<a> private interface ItemPictureData extends GraphObject { </a> 0
<a> String getUrl ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> interface GraphObjectCursor < T extends GraphObject > { </a> 0
<a> boolean isFromCache ( ) ; </a> 0
<a> boolean areMoreObjectsAvailable ( ) ; </a> 0
<a> int getCount ( ) ; </a> 0
<a> int getPosition ( ) ; </a> 0
<a> boolean move ( int offset ) ; </a> 0
<a> boolean moveToPosition ( int position ) ; </a> 0
<a> boolean moveToFirst ( ) ; </a> 0
<a> boolean moveToLast ( ) ; </a> 0
<a> boolean moveToNext ( ) ; </a> 0
<a> boolean moveToPrevious ( ) ; </a> 0
<a> boolean isFirst ( ) ; </a> 0
<a> boolean isLast ( ) ; </a> 0
<a> boolean isBeforeFirst ( ) ; </a> 0
<a> boolean isAfterLast ( ) ; </a> 0
<a> T getGraphObject ( ) ; </a> 0
<a> void close ( ) ; </a> 0
<a> boolean isClosed ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . support . v4 . content . Loader ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import com . facebook . model . GraphObjectList ; </a> 0
<a> import com . facebook . internal . CacheableRequestBatch ; </a> 0
<a> class GraphObjectPagingLoader < T extends GraphObject > extends Loader < SimpleGraphObjectCursor < T > > { </a> 0
<a> private final Class < T > graphObjectClass ; </a> 0
<a> private boolean skipRoundtripIfCached ; </a> 0
<a> private Request originalRequest ; </a> 0
<a> private Request currentRequest ; </a> 0
<a> private Request nextRequest ; </a> 0
<a> private OnErrorListener onErrorListener ; </a> 0
<a> private SimpleGraphObjectCursor < T > cursor ; </a> 0
<a> private boolean appendResults = false ; </a> 0
<a> private boolean loading = false ; </a> 0
<a> public interface OnErrorListener { </a> 0
<a> public void onError ( FacebookException error , GraphObjectPagingLoader < ? > loader ) ; </a> 0
<a> } </a> 0
<a> public GraphObjectPagingLoader ( Context context , Class < T > graphObjectClass ) { </a> 0
<a> super ( context ) ; </a> 0
<a> this . graphObjectClass = graphObjectClass ; </a> 0
<a> } </a> 0
<a> public OnErrorListener getOnErrorListener ( ) { </a> 0
<a> return onErrorListener ; </a> 0
<a> } </a> 0
<a> public void setOnErrorListener ( OnErrorListener listener ) { </a> 0
<a> this . onErrorListener = listener ; </a> 0
<a> } </a> 0
<a> public SimpleGraphObjectCursor < T > getCursor ( ) { </a> 0
<a> return cursor ; </a> 0
<a> } </a> 0
<a> public void clearResults ( ) { </a> 0
<a> nextRequest = null ; </a> 0
<a> originalRequest = null ; </a> 0
<a> currentRequest = null ; </a> 0
<a> deliverResult ( null ) ; </a> 0
<a> } </a> 0
<a> public boolean isLoading ( ) { </a> 0
<a> return loading ; </a> 0
<a> } </a> 0
<a> public void startLoading ( Request request , boolean skipRoundtripIfCached ) { </a> 0
<a> originalRequest = request ; </a> 0
<a> startLoading ( request , skipRoundtripIfCached , 0 ) ; </a> 0
<a> } </a> 0
<a> public void refreshOriginalRequest ( long afterDelay ) { </a> 0
<a> if ( originalRequest == null ) { </a> 0
<a> throw new FacebookException ( </a> 0
<a> "refreshOriginalRequest may not be called until after startLoading has been called." ) ; </a> 0
<a> } </a> 0
<a> startLoading ( originalRequest , false , afterDelay ) ; </a> 0
<a> } </a> 0
<a> public void followNextLink ( ) { </a> 0
<a> if ( nextRequest != null ) { </a> 0
<a> appendResults = true ; </a> 0
<a> currentRequest = nextRequest ; </a> 0
<a> currentRequest . setCallback ( new Request . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> requestCompleted ( response ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> loading = true ; </a> 0
<a> CacheableRequestBatch batch = putRequestIntoBatch ( currentRequest , skipRoundtripIfCached ) ; </a> 0
<a> Request . executeBatchAsync ( batch ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void deliverResult ( SimpleGraphObjectCursor < T > cursor ) { </a> 0
<a> SimpleGraphObjectCursor < T > oldCursor = this . cursor ; </a> 0
<a> this . cursor = cursor ; </a> 0
<a> if ( isStarted ( ) ) { </a> 0
<a> super . deliverResult ( cursor ) ; </a> 0
<a> if ( oldCursor != null && oldCursor != cursor && ! oldCursor . isClosed ( ) ) { </a> 0
<a> oldCursor . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onStartLoading ( ) { </a> 0
<a> super . onStartLoading ( ) ; </a> 0
<a> if ( cursor != null ) { </a> 0
<a> deliverResult ( cursor ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void startLoading ( Request request , boolean skipRoundtripIfCached , long afterDelay ) { </a> 0
<a> this . skipRoundtripIfCached = skipRoundtripIfCached ; </a> 0
<a> appendResults = false ; </a> 0
<a> nextRequest = null ; </a> 0
<a> currentRequest = request ; </a> 0
<a> currentRequest . setCallback ( new Request . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> requestCompleted ( response ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> loading = true ; </a> 0
<a> final RequestBatch batch = putRequestIntoBatch ( request , skipRoundtripIfCached ) ; </a> 0
<a> Runnable r = new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> Request . executeBatchAsync ( batch ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> if ( afterDelay == 0 ) { </a> 0
<a> r . run ( ) ; </a> 0
<a> } else { </a> 0
<a> Handler handler = new Handler ( ) ; </a> 0
<a> handler . postDelayed ( r , afterDelay ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private CacheableRequestBatch putRequestIntoBatch ( Request request , boolean skipRoundtripIfCached ) { </a> 0
<a> CacheableRequestBatch batch = new CacheableRequestBatch ( request ) ; </a> 0
<a> batch . setForceRoundTrip ( ! skipRoundtripIfCached ) ; </a> 0
<a> return batch ; </a> 0
<a> } </a> 0
<a> private void requestCompleted ( Response response ) { </a> 0
<a> Request request = response . getRequest ( ) ; </a> 0
<a> if ( request != currentRequest ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> loading = false ; </a> 0
<a> currentRequest = null ; </a> 0
<a> FacebookRequestError requestError = response . getError ( ) ; </a> 0
<a> FacebookException exception = ( requestError == null ) ? null : requestError . getException ( ) ; </a> 0
<a> if ( response . getGraphObject ( ) == null && exception == null ) { </a> 0
<a> exception = new FacebookException ( "GraphObjectPagingLoader received neither a result nor an error." ) ; </a> 0
<a> } </a> 0
<a> if ( exception != null ) { </a> 0
<a> nextRequest = null ; </a> 0
<a> if ( onErrorListener != null ) { </a> 0
<a> onErrorListener . onError ( exception , this ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> addResults ( response ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void addResults ( Response response ) { </a> 0
<a> SimpleGraphObjectCursor < T > cursorToModify = ( cursor == null || ! appendResults ) ? new SimpleGraphObjectCursor < T > ( ) : </a> 0
<a> new SimpleGraphObjectCursor < T > ( cursor ) ; </a> 0
<a> PagedResults result = response . getGraphObjectAs ( PagedResults . class ) ; </a> 0
<a> boolean fromCache = response . getIsFromCache ( ) ; </a> 0
<a> GraphObjectList < T > data = result . getData ( ) . castToListOf ( graphObjectClass ) ; </a> 0
<a> boolean haveData = data . size ( ) > 0 ; </a> 0
<a> if ( haveData ) { </a> 0
<a> nextRequest = response . getRequestForPagedResults ( Response . PagingDirection . NEXT ) ; </a> 0
<a> cursorToModify . addGraphObjects ( data , fromCache ) ; </a> 0
<a> cursorToModify . setMoreObjectsAvailable ( true ) ; </a> 0
<a> } </a> 0
<a> if ( ! haveData ) { </a> 0
<a> cursorToModify . setMoreObjectsAvailable ( false ) ; </a> 0
<a> cursorToModify . setFromCache ( fromCache ) ; </a> 0
<a> nextRequest = null ; </a> 0
<a> } </a> 0
<a> if ( ! fromCache ) { </a> 0
<a> skipRoundtripIfCached = false ; </a> 0
<a> } </a> 0
<a> deliverResult ( cursorToModify ) ; </a> 0
<a> } </a> 0
<a> interface PagedResults extends GraphObject { </a> 0
<a> GraphObjectList < GraphObject > getData ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> class ImageResponse { </a> 0
<a> private ImageRequest request ; </a> 0
<a> private Exception error ; </a> 0
<a> private boolean isCachedRedirect ; </a> 0
<a> private Bitmap bitmap ; </a> 0
<a> ImageResponse ( ImageRequest request , Exception error , boolean isCachedRedirect , Bitmap bitmap ) { </a> 0
<a> this . request = request ; </a> 0
<a> this . error = error ; </a> 0
<a> this . bitmap = bitmap ; </a> 0
<a> this . isCachedRedirect = isCachedRedirect ; </a> 0
<a> } </a> 0
<a> ImageRequest getRequest ( ) { </a> 0
<a> return request ; </a> 0
<a> } </a> 0
<a> Exception getError ( ) { </a> 0
<a> return error ; </a> 0
<a> } </a> 0
<a> Bitmap getBitmap ( ) { </a> 0
<a> return bitmap ; </a> 0
<a> } </a> 0
<a> boolean isCachedRedirect ( ) { </a> 0
<a> return isCachedRedirect ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import com . facebook . internal . Logger ; </a> 0
<a> import com . facebook . LoggingBehavior ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import com . facebook . internal . FileLruCache ; </a> 0
<a> import java . io . BufferedInputStream ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . net . HttpURLConnection ; </a> 0
<a> import java . net . URL ; </a> 0
<a> class ImageResponseCache { </a> 0
<a> static final String TAG = ImageResponseCache . class . getSimpleName ( ) ; </a> 0
<a> private volatile static FileLruCache imageCache ; </a> 0
<a> synchronized static FileLruCache getCache ( Context context ) throws IOException { </a> 0
<a> if ( imageCache == null ) { </a> 0
<a> imageCache = new FileLruCache ( context . getApplicationContext ( ) , TAG , new FileLruCache . Limits ( ) ) ; </a> 0
<a> } </a> 0
<a> return imageCache ; </a> 0
<a> } </a> 0
<a> static InputStream getCachedImageStream ( URL url , Context context ) { </a> 0
<a> InputStream imageStream = null ; </a> 0
<a> if ( url != null ) { </a> 0
<a> if ( isCDNURL ( url ) ) { </a> 0
<a> try { </a> 0
<a> FileLruCache cache = getCache ( context ) ; </a> 0
<a> imageStream = cache . get ( url . toString ( ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , e . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return imageStream ; </a> 0
<a> } </a> 0
<a> static InputStream interceptAndCacheImageStream ( Context context , HttpURLConnection connection ) throws IOException { </a> 0
<a> InputStream stream = null ; </a> 0
<a> if ( connection . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) { </a> 0
<a> URL url = connection . getURL ( ) ; </a> 0
<a> stream = connection . getInputStream ( ) ; </a> 0
<a> if ( isCDNURL ( url ) ) { </a> 0
<a> try { </a> 0
<a> FileLruCache cache = getCache ( context ) ; </a> 0
<a> stream = cache . interceptAndPut ( </a> 0
<a> url . toString ( ) , </a> 0
<a> new BufferedHttpInputStream ( stream , connection ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return stream ; </a> 0
<a> } </a> 0
<a> private static boolean isCDNURL ( URL url ) { </a> 0
<a> if ( url != null ) { </a> 0
<a> String uriHost = url . getHost ( ) ; </a> 0
<a> if ( uriHost . endsWith ( "fbcdn.net" ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( uriHost . startsWith ( "fbcdn" ) && uriHost . endsWith ( "akamaihd.net" ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private static class BufferedHttpInputStream extends BufferedInputStream { </a> 0
<a> HttpURLConnection connection ; </a> 0
<a> BufferedHttpInputStream ( InputStream stream , HttpURLConnection connection ) { </a> 0
<a> super ( stream , Utility . DEFAULT_STREAM_BUFFER_SIZE ) ; </a> 0
<a> this . connection = connection ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws IOException { </a> 0
<a> super . close ( ) ; </a> 0
<a> Utility . disconnectQuietly ( connection ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . app . AlertDialog ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . DialogInterface ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . content . res . TypedArray ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . util . AttributeSet ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import android . util . TypedValue ; </a> 0
<a> import android . view . Gravity ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . android . R ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import com . facebook . internal . SessionAuthorizationType ; </a> 0
<a> import com . facebook . internal . SessionTracker ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class LoginButton extends Button { </a> 0
<a> private static final String TAG = LoginButton . class . getName ( ) ; </a> 0
<a> private String applicationId = null ; </a> 0
<a> private SessionTracker sessionTracker ; </a> 0
<a> private GraphUser user = null ; </a> 0
<a> private Session userInfoSession = null ; </a> 0
<a> private boolean confirmLogout ; </a> 0
<a> private boolean fetchUserInfo ; </a> 0
<a> private String loginText ; </a> 0
<a> private String logoutText ; </a> 0
<a> private UserInfoChangedCallback userInfoChangedCallback ; </a> 0
<a> private Fragment parentFragment ; </a> 0
<a> private LoginButtonProperties properties = new LoginButtonProperties ( ) ; </a> 0
<a> static class LoginButtonProperties { </a> 0
<a> private SessionDefaultAudience defaultAudience = SessionDefaultAudience . FRIENDS ; </a> 0
<a> private List < String > permissions = Collections . < String > emptyList ( ) ; </a> 0
<a> private SessionAuthorizationType authorizationType = null ; </a> 0
<a> private OnErrorListener onErrorListener ; </a> 0
<a> private SessionLoginBehavior loginBehavior = SessionLoginBehavior . SSO_WITH_FALLBACK ; </a> 0
<a> private Session . StatusCallback sessionStatusCallback ; </a> 0
<a> public void setOnErrorListener ( OnErrorListener onErrorListener ) { </a> 0
<a> this . onErrorListener = onErrorListener ; </a> 0
<a> } </a> 0
<a> public OnErrorListener getOnErrorListener ( ) { </a> 0
<a> return onErrorListener ; </a> 0
<a> } </a> 0
<a> public void setDefaultAudience ( SessionDefaultAudience defaultAudience ) { </a> 0
<a> this . defaultAudience = defaultAudience ; </a> 0
<a> } </a> 0
<a> public SessionDefaultAudience getDefaultAudience ( ) { </a> 0
<a> return defaultAudience ; </a> 0
<a> } </a> 0
<a> public void setReadPermissions ( List < String > permissions , Session session ) { </a> 0
<a> if ( SessionAuthorizationType . PUBLISH . equals ( authorizationType ) ) { </a> 0
<a> throw new UnsupportedOperationException ( </a> 0
<a> "Cannot call setReadPermissions after setPublishPermissions has been called." ) ; </a> 0
<a> } </a> 0
<a> if ( validatePermissions ( permissions , SessionAuthorizationType . READ , session ) ) { </a> 0
<a> this . permissions = permissions ; </a> 0
<a> authorizationType = SessionAuthorizationType . READ ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void setPublishPermissions ( List < String > permissions , Session session ) { </a> 0
<a> if ( SessionAuthorizationType . READ . equals ( authorizationType ) ) { </a> 0
<a> throw new UnsupportedOperationException ( </a> 0
<a> "Cannot call setPublishPermissions after setReadPermissions has been called." ) ; </a> 0
<a> } </a> 0
<a> if ( validatePermissions ( permissions , SessionAuthorizationType . PUBLISH , session ) ) { </a> 0
<a> this . permissions = permissions ; </a> 0
<a> authorizationType = SessionAuthorizationType . PUBLISH ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean validatePermissions ( List < String > permissions , </a> 0
<a> SessionAuthorizationType authType , Session currentSession ) { </a> 0
<a> if ( SessionAuthorizationType . PUBLISH . equals ( authType ) ) { </a> 0
<a> if ( Utility . isNullOrEmpty ( permissions ) ) { </a> 0
<a> throw new IllegalArgumentException ( "Permissions for publish actions cannot be null or empty." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( currentSession != null && currentSession . isOpened ( ) ) { </a> 0
<a> if ( ! Utility . isSubset ( permissions , currentSession . getPermissions ( ) ) ) { </a> 0
<a> Log . e ( TAG , "Cannot set additional permissions when session is already open." ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> List < String > getPermissions ( ) { </a> 0
<a> return permissions ; </a> 0
<a> } </a> 0
<a> public void clearPermissions ( ) { </a> 0
<a> permissions = null ; </a> 0
<a> authorizationType = null ; </a> 0
<a> } </a> 0
<a> public void setLoginBehavior ( SessionLoginBehavior loginBehavior ) { </a> 0
<a> this . loginBehavior = loginBehavior ; </a> 0
<a> } </a> 0
<a> public SessionLoginBehavior getLoginBehavior ( ) { </a> 0
<a> return loginBehavior ; </a> 0
<a> } </a> 0
<a> public void setSessionStatusCallback ( Session . StatusCallback callback ) { </a> 0
<a> this . sessionStatusCallback = callback ; </a> 0
<a> } </a> 0
<a> public Session . StatusCallback getSessionStatusCallback ( ) { </a> 0
<a> return sessionStatusCallback ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public interface UserInfoChangedCallback { </a> 0
<a> void onUserInfoFetched ( GraphUser user ) ; </a> 0
<a> } </a> 0
<a> public interface OnErrorListener { </a> 0
<a> void onError ( FacebookException error ) ; </a> 0
<a> } </a> 0
<a> public LoginButton ( Context context ) { </a> 0
<a> super ( context ) ; </a> 0
<a> initializeActiveSessionWithCachedToken ( context ) ; </a> 0
<a> finishInit ( ) ; </a> 0
<a> } </a> 0
<a> public LoginButton ( Context context , AttributeSet attrs ) { </a> 0
<a> super ( context , attrs ) ; </a> 0
<a> if ( attrs . getStyleAttribute ( ) == 0 ) { </a> 0
<a> this . setTextColor ( getResources ( ) . getColor ( R . color . com_facebook_loginview_text_color ) ) ; </a> 0
<a> this . setTextSize ( TypedValue . COMPLEX_UNIT_PX , </a> 0
<a> getResources ( ) . getDimension ( R . dimen . com_facebook_loginview_text_size ) ) ; </a> 0
<a> this . setPadding ( getResources ( ) . getDimensionPixelSize ( R . dimen . com_facebook_loginview_padding_left ) , </a> 0
<a> getResources ( ) . getDimensionPixelSize ( R . dimen . com_facebook_loginview_padding_top ) , </a> 0
<a> getResources ( ) . getDimensionPixelSize ( R . dimen . com_facebook_loginview_padding_right ) , </a> 0
<a> getResources ( ) . getDimensionPixelSize ( R . dimen . com_facebook_loginview_padding_bottom ) ) ; </a> 0
<a> this . setWidth ( getResources ( ) . getDimensionPixelSize ( R . dimen . com_facebook_loginview_width ) ) ; </a> 0
<a> this . setHeight ( getResources ( ) . getDimensionPixelSize ( R . dimen . com_facebook_loginview_height ) ) ; </a> 0
<a> this . setGravity ( Gravity . CENTER ) ; </a> 0
<a> parseAttributes ( attrs ) ; </a> 1
<a> if ( isInEditMode ( ) ) { </a> 0
<a> this . setBackgroundColor ( getResources ( ) . getColor ( R . color . com_facebook_blue ) ) ; </a> 0
<a> loginText = "Log in" ; </a> 0
<a> } else { </a> 0
<a> this . setBackgroundResource ( R . drawable . com_facebook_loginbutton_blue ) ; </a> 0
<a> initializeActiveSessionWithCachedToken ( context ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> public LoginButton ( Context context , AttributeSet attrs , int defStyle ) { </a> 0
<a> super ( context , attrs , defStyle ) ; </a> 0
<a> parseAttributes ( attrs ) ; </a> 0
<a> initializeActiveSessionWithCachedToken ( context ) ; </a> 0
<a> } </a> 0
<a> public void setOnErrorListener ( OnErrorListener onErrorListener ) { </a> 0
<a> properties . setOnErrorListener ( onErrorListener ) ; </a> 0
<a> } </a> 0
<a> public OnErrorListener getOnErrorListener ( ) { </a> 0
<a> return properties . getOnErrorListener ( ) ; </a> 0
<a> } </a> 0
<a> public void setDefaultAudience ( SessionDefaultAudience defaultAudience ) { </a> 0
<a> properties . setDefaultAudience ( defaultAudience ) ; </a> 0
<a> } </a> 0
<a> public SessionDefaultAudience getDefaultAudience ( ) { </a> 0
<a> return properties . getDefaultAudience ( ) ; </a> 0
<a> } </a> 0
<a> public void setReadPermissions ( List < String > permissions ) { </a> 0
<a> properties . setReadPermissions ( permissions , sessionTracker . getSession ( ) ) ; </a> 0
<a> } </a> 0
<a> public void setPublishPermissions ( List < String > permissions ) { </a> 0
<a> properties . setPublishPermissions ( permissions , sessionTracker . getSession ( ) ) ; </a> 0
<a> } </a> 0
<a> public void clearPermissions ( ) { </a> 0
<a> properties . clearPermissions ( ) ; </a> 0
<a> } </a> 0
<a> public void setLoginBehavior ( SessionLoginBehavior loginBehavior ) { </a> 0
<a> properties . setLoginBehavior ( loginBehavior ) ; </a> 0
<a> } </a> 0
<a> public SessionLoginBehavior getLoginBehavior ( ) { </a> 0
<a> return properties . getLoginBehavior ( ) ; </a> 0
<a> } </a> 0
<a> public void setApplicationId ( String applicationId ) { </a> 0
<a> this . applicationId = applicationId ; </a> 0
<a> } </a> 0
<a> public UserInfoChangedCallback getUserInfoChangedCallback ( ) { </a> 0
<a> return userInfoChangedCallback ; </a> 0
<a> } </a> 0
<a> public void setUserInfoChangedCallback ( UserInfoChangedCallback userInfoChangedCallback ) { </a> 0
<a> this . userInfoChangedCallback = userInfoChangedCallback ; </a> 0
<a> } </a> 0
<a> public void setSessionStatusCallback ( Session . StatusCallback callback ) { </a> 0
<a> properties . setSessionStatusCallback ( callback ) ; </a> 0
<a> } </a> 0
<a> public Session . StatusCallback getSessionStatusCallback ( ) { </a> 0
<a> return properties . getSessionStatusCallback ( ) ; </a> 0
<a> } </a> 0
<a> public boolean onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> Session session = sessionTracker . getSession ( ) ; </a> 0
<a> if ( session != null ) { </a> 0
<a> return session . onActivityResult ( ( Activity ) getContext ( ) , requestCode , </a> 0
<a> resultCode , data ) ; </a> 0
<a> } else { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void setSession ( Session newSession ) { </a> 0
<a> sessionTracker . setSession ( newSession ) ; </a> 0
<a> fetchUserInfo ( ) ; </a> 0
<a> setButtonText ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onFinishInflate ( ) { </a> 0
<a> super . onFinishInflate ( ) ; </a> 0
<a> finishInit ( ) ; </a> 0
<a> } </a> 0
<a> private void finishInit ( ) { </a> 0
<a> setOnClickListener ( new LoginClickListener ( ) ) ; </a> 0
<a> setButtonText ( ) ; </a> 0
<a> if ( ! isInEditMode ( ) ) { </a> 0
<a> sessionTracker = new SessionTracker ( getContext ( ) , new LoginButtonCallback ( ) , null , false ) ; </a> 0
<a> fetchUserInfo ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void setFragment ( Fragment fragment ) { </a> 0
<a> parentFragment = fragment ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onAttachedToWindow ( ) { </a> 0
<a> super . onAttachedToWindow ( ) ; </a> 0
<a> if ( sessionTracker != null && ! sessionTracker . isTracking ( ) ) { </a> 0
<a> sessionTracker . startTracking ( ) ; </a> 0
<a> fetchUserInfo ( ) ; </a> 0
<a> setButtonText ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onDetachedFromWindow ( ) { </a> 0
<a> super . onDetachedFromWindow ( ) ; </a> 0
<a> if ( sessionTracker != null ) { </a> 0
<a> sessionTracker . stopTracking ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> List < String > getPermissions ( ) { </a> 0
<a> return properties . getPermissions ( ) ; </a> 0
<a> } </a> 0
<a> void setProperties ( LoginButtonProperties properties ) { </a> 0
<a> this . properties = properties ; </a> 0
<a> } </a> 0
<a> private void parseAttributes ( AttributeSet attrs ) { </a> 0
<a> TypedArray a = getContext ( ) . obtainStyledAttributes ( attrs , R . styleable . com_facebook_login_view ) ; </a> 0
<a> confirmLogout = a . getBoolean ( R . styleable . com_facebook_login_view_confirm_logout , true ) ; </a> 0
<a> fetchUserInfo = a . getBoolean ( R . styleable . com_facebook_login_view_fetch_user_info , true ) ; </a> 0
<a> loginText = a . getString ( R . styleable . com_facebook_login_view_login_text ) ; </a> 0
<a> logoutText = a . getString ( R . styleable . com_facebook_login_view_logout_text ) ; </a> 0
<a> a . recycle ( ) ; </a> 0
<a> } </a> 0
<a> private void setButtonText ( ) { </a> 0
<a> if ( sessionTracker != null && sessionTracker . getOpenSession ( ) != null ) { </a> 0
<a> setText ( ( logoutText != null ) ? logoutText : </a> 0
<a> getResources ( ) . getString ( R . string . com_facebook_loginview_log_out_button ) ) ; </a> 0
<a> } else { </a> 0
<a> setText ( ( loginText != null ) ? loginText : </a> 0
<a> getResources ( ) . getString ( R . string . com_facebook_loginview_log_in_button ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean initializeActiveSessionWithCachedToken ( Context context ) { </a> 0
<a> if ( context == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session != null ) { </a> 0
<a> return session . isOpened ( ) ; </a> 0
<a> } </a> 0
<a> String applicationId = Utility . getMetadataApplicationId ( context ) ; </a> 0
<a> if ( applicationId == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return Session . openActiveSessionFromCache ( context ) != null ; </a> 0
<a> } </a> 0
<a> private void fetchUserInfo ( ) { </a> 0
<a> if ( fetchUserInfo ) { </a> 0
<a> final Session currentSession = sessionTracker . getOpenSession ( ) ; </a> 0
<a> if ( currentSession != null ) { </a> 0
<a> if ( currentSession != userInfoSession ) { </a> 0
<a> Request request = Request . newMeRequest ( currentSession , new Request . GraphUserCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( GraphUser me , Response response ) { </a> 0
<a> if ( currentSession == sessionTracker . getOpenSession ( ) ) { </a> 0
<a> user = me ; </a> 0
<a> if ( userInfoChangedCallback != null ) { </a> 0
<a> userInfoChangedCallback . onUserInfoFetched ( user ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( response . getError ( ) != null ) { </a> 0
<a> handleError ( response . getError ( ) . getException ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Request . executeBatchAsync ( request ) ; </a> 0
<a> userInfoSession = currentSession ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> user = null ; </a> 0
<a> if ( userInfoChangedCallback != null ) { </a> 0
<a> userInfoChangedCallback . onUserInfoFetched ( user ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class LoginClickListener implements OnClickListener { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> Context context = getContext ( ) ; </a> 0
<a> final Session openSession = sessionTracker . getOpenSession ( ) ; </a> 0
<a> if ( openSession != null ) { </a> 0
<a> if ( confirmLogout ) { </a> 0
<a> String logout = getResources ( ) . getString ( R . string . com_facebook_loginview_log_out_action ) ; </a> 0
<a> String cancel = getResources ( ) . getString ( R . string . com_facebook_loginview_cancel_action ) ; </a> 0
<a> String message ; </a> 0
<a> if ( user != null && user . getName ( ) != null ) { </a> 0
<a> message = String . format ( getResources ( ) . getString ( R . string . com_facebook_loginview_logged_in_as ) , user . getName ( ) ) ; </a> 0
<a> } else { </a> 0
<a> message = getResources ( ) . getString ( R . string . com_facebook_loginview_logged_in_using_facebook ) ; </a> 0
<a> } </a> 0
<a> AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; </a> 0
<a> builder . setMessage ( message ) </a> 0
<a> . setCancelable ( true ) </a> 0
<a> . setPositiveButton ( logout , new DialogInterface . OnClickListener ( ) { </a> 0
<a> public void onClick ( DialogInterface dialog , int which ) { </a> 0
<a> openSession . closeAndClearTokenInformation ( ) ; </a> 0
<a> } </a> 0
<a> } ) </a> 0
<a> . setNegativeButton ( cancel , null ) ; </a> 0
<a> builder . create ( ) . show ( ) ; </a> 0
<a> } else { </a> 0
<a> openSession . closeAndClearTokenInformation ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> Session currentSession = sessionTracker . getSession ( ) ; </a> 0
<a> if ( currentSession == null || currentSession . getState ( ) . isClosed ( ) ) { </a> 0
<a> sessionTracker . setSession ( null ) ; </a> 0
<a> Session session = new Session . Builder ( context ) . setApplicationId ( applicationId ) . build ( ) ; </a> 0
<a> Session . setActiveSession ( session ) ; </a> 0
<a> currentSession = session ; </a> 0
<a> } </a> 0
<a> if ( ! currentSession . isOpened ( ) ) { </a> 0
<a> Session . OpenRequest openRequest = null ; </a> 0
<a> if ( parentFragment != null ) { </a> 0
<a> openRequest = new Session . OpenRequest ( parentFragment ) ; </a> 0
<a> } else if ( context instanceof Activity ) { </a> 0
<a> openRequest = new Session . OpenRequest ( ( Activity ) context ) ; </a> 0
<a> } </a> 0
<a> if ( openRequest != null ) { </a> 0
<a> openRequest . setDefaultAudience ( properties . defaultAudience ) ; </a> 0
<a> openRequest . setPermissions ( properties . permissions ) ; </a> 0
<a> openRequest . setLoginBehavior ( properties . loginBehavior ) ; </a> 0
<a> if ( SessionAuthorizationType . PUBLISH . equals ( properties . authorizationType ) ) { </a> 0
<a> currentSession . openForPublish ( openRequest ) ; </a> 0
<a> } else { </a> 0
<a> currentSession . openForRead ( openRequest ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class LoginButtonCallback implements Session . StatusCallback { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , </a> 0
<a> Exception exception ) { </a> 0
<a> fetchUserInfo ( ) ; </a> 0
<a> setButtonText ( ) ; </a> 0
<a> if ( exception != null ) { </a> 0
<a> handleError ( exception ) ; </a> 0
<a> } </a> 0
<a> if ( properties . sessionStatusCallback != null ) { </a> 0
<a> properties . sessionStatusCallback . call ( session , state , exception ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> void handleError ( Exception exception ) { </a> 0
<a> if ( properties . onErrorListener != null ) { </a> 0
<a> if ( exception instanceof FacebookException ) { </a> 0
<a> properties . onErrorListener . onError ( ( FacebookException ) exception ) ; </a> 0
<a> } else { </a> 0
<a> properties . onErrorListener . onError ( new FacebookException ( exception ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . res . TypedArray ; </a> 0
<a> import android . graphics . drawable . Drawable ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . support . v4 . app . LoaderManager ; </a> 0
<a> import android . support . v4 . content . Loader ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import android . util . AttributeSet ; </a> 0
<a> import android . view . LayoutInflater ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . view . ViewStub ; </a> 0
<a> import android . view . animation . AlphaAnimation ; </a> 0
<a> import android . widget . * ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . android . R ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import com . facebook . internal . SessionTracker ; </a> 0
<a> import java . util . * ; </a> 0
<a> public abstract class PickerFragment < T extends GraphObject > extends Fragment { </a> 0
<a> public static final String SHOW_PICTURES_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ShowPictures" ; </a> 0
<a> public static final String EXTRA_FIELDS_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ExtraFields" ; </a> 0
<a> public static final String SHOW_TITLE_BAR_BUNDLE_KEY = "com.facebook.widget.PickerFragment.ShowTitleBar" ; </a> 0
<a> public static final String TITLE_TEXT_BUNDLE_KEY = "com.facebook.widget.PickerFragment.TitleText" ; </a> 0
<a> public static final String DONE_BUTTON_TEXT_BUNDLE_KEY = "com.facebook.widget.PickerFragment.DoneButtonText" ; </a> 0
<a> private static final String SELECTION_BUNDLE_KEY = "com.facebook.android.PickerFragment.Selection" ; </a> 0
<a> private static final String ACTIVITY_CIRCLE_SHOW_KEY = "com.facebook.android.PickerFragment.ActivityCircleShown" ; </a> 0
<a> private static final int PROFILE_PICTURE_PREFETCH_BUFFER = 5 ; </a> 0
<a> private final int layout ; </a> 0
<a> private OnErrorListener onErrorListener ; </a> 0
<a> private OnDataChangedListener onDataChangedListener ; </a> 0
<a> private OnSelectionChangedListener onSelectionChangedListener ; </a> 0
<a> private OnDoneButtonClickedListener onDoneButtonClickedListener ; </a> 0
<a> private GraphObjectFilter < T > filter ; </a> 0
<a> private boolean showPictures = true ; </a> 0
<a> private boolean showTitleBar = true ; </a> 0
<a> private ListView listView ; </a> 0
<a> HashSet < String > extraFields = new HashSet < String > ( ) ; </a> 0
<a> GraphObjectAdapter < T > adapter ; </a> 0
<a> private final Class < T > graphObjectClass ; </a> 0
<a> private LoadingStrategy loadingStrategy ; </a> 0
<a> private SelectionStrategy selectionStrategy ; </a> 0
<a> private ProgressBar activityCircle ; </a> 0
<a> private SessionTracker sessionTracker ; </a> 0
<a> private String titleText ; </a> 0
<a> private String doneButtonText ; </a> 0
<a> private TextView titleTextView ; </a> 0
<a> private Button doneButton ; </a> 0
<a> private Drawable titleBarBackground ; </a> 0
<a> private Drawable doneButtonBackground ; </a> 0
<a> PickerFragment ( Class < T > graphObjectClass , int layout , Bundle args ) { </a> 0
<a> this . graphObjectClass = graphObjectClass ; </a> 0
<a> this . layout = layout ; </a> 0
<a> setPickerFragmentSettingsFromBundle ( args ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> adapter = createAdapter ( ) ; </a> 0
<a> adapter . setFilter ( new GraphObjectAdapter . Filter < T > ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean includeItem ( T graphObject ) { </a> 0
<a> return filterIncludesItem ( graphObject ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onInflate ( Activity activity , AttributeSet attrs , Bundle savedInstanceState ) { </a> 0
<a> super . onInflate ( activity , attrs , savedInstanceState ) ; </a> 0
<a> TypedArray a = activity . obtainStyledAttributes ( attrs , R . styleable . com_facebook_picker_fragment ) ; </a> 0
<a> setShowPictures ( a . getBoolean ( R . styleable . com_facebook_picker_fragment_show_pictures , showPictures ) ) ; </a> 0
<a> String extraFieldsString = a . getString ( R . styleable . com_facebook_picker_fragment_extra_fields ) ; </a> 0
<a> if ( extraFieldsString != null ) { </a> 0
<a> String [ ] strings = extraFieldsString . split ( "," ) ; </a> 0
<a> setExtraFields ( Arrays . asList ( strings ) ) ; </a> 0
<a> } </a> 0
<a> showTitleBar = a . getBoolean ( R . styleable . com_facebook_picker_fragment_show_title_bar , showTitleBar ) ; </a> 0
<a> titleText = a . getString ( R . styleable . com_facebook_picker_fragment_title_text ) ; </a> 0
<a> doneButtonText = a . getString ( R . styleable . com_facebook_picker_fragment_done_button_text ) ; </a> 0
<a> titleBarBackground = a . getDrawable ( R . styleable . com_facebook_picker_fragment_title_bar_background ) ; </a> 0
<a> doneButtonBackground = a . getDrawable ( R . styleable . com_facebook_picker_fragment_done_button_background ) ; </a> 0
<a> a . recycle ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { </a> 0
<a> ViewGroup view = ( ViewGroup ) inflater . inflate ( layout , container , false ) ; </a> 0
<a> listView = ( ListView ) view . findViewById ( R . id . com_facebook_picker_list_view ) ; </a> 0
<a> listView . setOnItemClickListener ( new AdapterView . OnItemClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onItemClick ( AdapterView < ? > parent , View v , int position , long id ) { </a> 0
<a> onListItemClick ( ( ListView ) parent , v , position ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> listView . setOnLongClickListener ( new View . OnLongClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean onLongClick ( View v ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> listView . setOnScrollListener ( onScrollListener ) ; </a> 0
<a> listView . setAdapter ( adapter ) ; </a> 0
<a> activityCircle = ( ProgressBar ) view . findViewById ( R . id . com_facebook_picker_activity_circle ) ; </a> 0
<a> return view ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onActivityCreated ( final Bundle savedInstanceState ) { </a> 0
<a> super . onActivityCreated ( savedInstanceState ) ; </a> 0
<a> sessionTracker = new SessionTracker ( getActivity ( ) , new Session . StatusCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> if ( ! session . isOpened ( ) ) { </a> 0
<a> clearResults ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> setSettingsFromBundle ( savedInstanceState ) ; </a> 0
<a> loadingStrategy = createLoadingStrategy ( ) ; </a> 0
<a> loadingStrategy . attach ( adapter ) ; </a> 0
<a> selectionStrategy = createSelectionStrategy ( ) ; </a> 0
<a> selectionStrategy . readSelectionFromBundle ( savedInstanceState , SELECTION_BUNDLE_KEY ) ; </a> 0
<a> if ( showTitleBar ) { </a> 0
<a> inflateTitleBar ( ( ViewGroup ) getView ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( activityCircle != null && savedInstanceState != null ) { </a> 0
<a> boolean shown = savedInstanceState . getBoolean ( ACTIVITY_CIRCLE_SHOW_KEY , false ) ; </a> 0
<a> if ( shown ) { </a> 0
<a> displayActivityCircle ( ) ; </a> 0
<a> } else { </a> 0
<a> hideActivityCircle ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDetach ( ) { </a> 0
<a> super . onDetach ( ) ; </a> 0
<a> listView . setOnScrollListener ( null ) ; </a> 0
<a> listView . setAdapter ( null ) ; </a> 0
<a> loadingStrategy . detach ( ) ; </a> 0
<a> sessionTracker . stopTracking ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onSaveInstanceState ( Bundle outState ) { </a> 0
<a> super . onSaveInstanceState ( outState ) ; </a> 0
<a> saveSettingsToBundle ( outState ) ; </a> 0
<a> selectionStrategy . saveSelectionToBundle ( outState , SELECTION_BUNDLE_KEY ) ; </a> 0
<a> if ( activityCircle != null ) { </a> 0
<a> outState . putBoolean ( ACTIVITY_CIRCLE_SHOW_KEY , activityCircle . getVisibility ( ) == View . VISIBLE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setArguments ( Bundle args ) { </a> 0
<a> super . setArguments ( args ) ; </a> 0
<a> setSettingsFromBundle ( args ) ; </a> 0
<a> } </a> 0
<a> public OnDataChangedListener getOnDataChangedListener ( ) { </a> 0
<a> return onDataChangedListener ; </a> 0
<a> } </a> 0
<a> public void setOnDataChangedListener ( OnDataChangedListener onDataChangedListener ) { </a> 0
<a> this . onDataChangedListener = onDataChangedListener ; </a> 0
<a> } </a> 0
<a> public OnSelectionChangedListener getOnSelectionChangedListener ( ) { </a> 0
<a> return onSelectionChangedListener ; </a> 0
<a> } </a> 0
<a> public void setOnSelectionChangedListener ( </a> 0
<a> OnSelectionChangedListener onSelectionChangedListener ) { </a> 0
<a> this . onSelectionChangedListener = onSelectionChangedListener ; </a> 0
<a> } </a> 0
<a> public OnDoneButtonClickedListener getOnDoneButtonClickedListener ( ) { </a> 0
<a> return onDoneButtonClickedListener ; </a> 0
<a> } </a> 0
<a> public void setOnDoneButtonClickedListener ( OnDoneButtonClickedListener onDoneButtonClickedListener ) { </a> 0
<a> this . onDoneButtonClickedListener = onDoneButtonClickedListener ; </a> 0
<a> } </a> 0
<a> public OnErrorListener getOnErrorListener ( ) { </a> 0
<a> return onErrorListener ; </a> 0
<a> } </a> 0
<a> public void setOnErrorListener ( OnErrorListener onErrorListener ) { </a> 0
<a> this . onErrorListener = onErrorListener ; </a> 0
<a> } </a> 0
<a> public GraphObjectFilter < T > getFilter ( ) { </a> 0
<a> return filter ; </a> 0
<a> } </a> 0
<a> public void setFilter ( GraphObjectFilter < T > filter ) { </a> 0
<a> this . filter = filter ; </a> 0
<a> } </a> 0
<a> public Session getSession ( ) { </a> 0
<a> return sessionTracker . getSession ( ) ; </a> 0
<a> } </a> 0
<a> public void setSession ( Session session ) { </a> 0
<a> sessionTracker . setSession ( session ) ; </a> 0
<a> } </a> 0
<a> public boolean getShowPictures ( ) { </a> 0
<a> return showPictures ; </a> 0
<a> } </a> 0
<a> public void setShowPictures ( boolean showPictures ) { </a> 0
<a> this . showPictures = showPictures ; </a> 0
<a> } </a> 0
<a> public Set < String > getExtraFields ( ) { </a> 0
<a> return new HashSet < String > ( extraFields ) ; </a> 0
<a> } </a> 0
<a> public void setExtraFields ( Collection < String > fields ) { </a> 0
<a> extraFields = new HashSet < String > ( ) ; </a> 0
<a> if ( fields != null ) { </a> 0
<a> extraFields . addAll ( fields ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void setShowTitleBar ( boolean showTitleBar ) { </a> 0
<a> this . showTitleBar = showTitleBar ; </a> 0
<a> } </a> 0
<a> public boolean getShowTitleBar ( ) { </a> 0
<a> return showTitleBar ; </a> 0
<a> } </a> 0
<a> public void setTitleText ( String titleText ) { </a> 0
<a> this . titleText = titleText ; </a> 0
<a> } </a> 0
<a> public String getTitleText ( ) { </a> 0
<a> if ( titleText == null ) { </a> 0
<a> titleText = getDefaultTitleText ( ) ; </a> 0
<a> } </a> 0
<a> return titleText ; </a> 0
<a> } </a> 0
<a> public void setDoneButtonText ( String doneButtonText ) { </a> 0
<a> this . doneButtonText = doneButtonText ; </a> 0
<a> } </a> 0
<a> public String getDoneButtonText ( ) { </a> 0
<a> if ( doneButtonText == null ) { </a> 0
<a> doneButtonText = getDefaultDoneButtonText ( ) ; </a> 0
<a> } </a> 0
<a> return doneButtonText ; </a> 0
<a> } </a> 0
<a> public void loadData ( boolean forceReload ) { </a> 0
<a> if ( ! forceReload && loadingStrategy . isDataPresentOrLoading ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> loadDataSkippingRoundTripIfCached ( ) ; </a> 0
<a> } </a> 0
<a> public void setSettingsFromBundle ( Bundle inState ) { </a> 0
<a> setPickerFragmentSettingsFromBundle ( inState ) ; </a> 0
<a> } </a> 0
<a> boolean filterIncludesItem ( T graphObject ) { </a> 0
<a> if ( filter != null ) { </a> 0
<a> return filter . includeItem ( graphObject ) ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> List < T > getSelectedGraphObjects ( ) { </a> 0
<a> return adapter . getGraphObjectsById ( selectionStrategy . getSelectedIds ( ) ) ; </a> 0
<a> } </a> 0
<a> void saveSettingsToBundle ( Bundle outState ) { </a> 0
<a> outState . putBoolean ( SHOW_PICTURES_BUNDLE_KEY , showPictures ) ; </a> 0
<a> if ( ! extraFields . isEmpty ( ) ) { </a> 0
<a> outState . putString ( EXTRA_FIELDS_BUNDLE_KEY , TextUtils . join ( "," , extraFields ) ) ; </a> 0
<a> } </a> 0
<a> outState . putBoolean ( SHOW_TITLE_BAR_BUNDLE_KEY , showTitleBar ) ; </a> 0
<a> outState . putString ( TITLE_TEXT_BUNDLE_KEY , titleText ) ; </a> 0
<a> outState . putString ( DONE_BUTTON_TEXT_BUNDLE_KEY , doneButtonText ) ; </a> 0
<a> } </a> 0
<a> abstract Request getRequestForLoadData ( Session session ) ; </a> 0
<a> abstract PickerFragmentAdapter < T > createAdapter ( ) ; </a> 0
<a> abstract LoadingStrategy createLoadingStrategy ( ) ; </a> 0
<a> abstract SelectionStrategy createSelectionStrategy ( ) ; </a> 0
<a> void onLoadingData ( ) { </a> 0
<a> } </a> 0
<a> String getDefaultTitleText ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> String getDefaultDoneButtonText ( ) { </a> 0
<a> return getString ( R . string . com_facebook_picker_done_button_text ) ; </a> 0
<a> } </a> 0
<a> void displayActivityCircle ( ) { </a> 0
<a> if ( activityCircle != null ) { </a> 0
<a> layoutActivityCircle ( ) ; </a> 0
<a> activityCircle . setVisibility ( View . VISIBLE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void layoutActivityCircle ( ) { </a> 0
<a> float alpha = ( ! adapter . isEmpty ( ) ) ? .25f : 1.0f ; </a> 0
<a> setAlpha ( activityCircle , alpha ) ; </a> 0
<a> } </a> 0
<a> void hideActivityCircle ( ) { </a> 0
<a> if ( activityCircle != null ) { </a> 0
<a> activityCircle . clearAnimation ( ) ; </a> 0
<a> activityCircle . setVisibility ( View . INVISIBLE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void setSelectionStrategy ( SelectionStrategy selectionStrategy ) { </a> 0
<a> if ( selectionStrategy != this . selectionStrategy ) { </a> 0
<a> this . selectionStrategy = selectionStrategy ; </a> 0
<a> if ( adapter != null ) { </a> 0
<a> adapter . notifyDataSetChanged ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void setAlpha ( View view , float alpha ) { </a> 0
<a> AlphaAnimation alphaAnimation = new AlphaAnimation ( alpha , alpha ) ; </a> 0
<a> alphaAnimation . setDuration ( 0 ) ; </a> 0
<a> alphaAnimation . setFillAfter ( true ) ; </a> 0
<a> view . startAnimation ( alphaAnimation ) ; </a> 0
<a> } </a> 0
<a> private void setPickerFragmentSettingsFromBundle ( Bundle inState ) { </a> 0
<a> if ( inState != null ) { </a> 0
<a> showPictures = inState . getBoolean ( SHOW_PICTURES_BUNDLE_KEY , showPictures ) ; </a> 0
<a> String extraFieldsString = inState . getString ( EXTRA_FIELDS_BUNDLE_KEY ) ; </a> 0
<a> if ( extraFieldsString != null ) { </a> 0
<a> String [ ] strings = extraFieldsString . split ( "," ) ; </a> 0
<a> setExtraFields ( Arrays . asList ( strings ) ) ; </a> 0
<a> } </a> 0
<a> showTitleBar = inState . getBoolean ( SHOW_TITLE_BAR_BUNDLE_KEY , showTitleBar ) ; </a> 0
<a> String titleTextString = inState . getString ( TITLE_TEXT_BUNDLE_KEY ) ; </a> 0
<a> if ( titleTextString != null ) { </a> 0
<a> titleText = titleTextString ; </a> 0
<a> if ( titleTextView != null ) { </a> 0
<a> titleTextView . setText ( titleText ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> String doneButtonTextString = inState . getString ( DONE_BUTTON_TEXT_BUNDLE_KEY ) ; </a> 0
<a> if ( doneButtonTextString != null ) { </a> 0
<a> doneButtonText = doneButtonTextString ; </a> 0
<a> if ( doneButton != null ) { </a> 0
<a> doneButton . setText ( doneButtonText ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void inflateTitleBar ( ViewGroup view ) { </a> 0
<a> ViewStub stub = ( ViewStub ) view . findViewById ( R . id . com_facebook_picker_title_bar_stub ) ; </a> 0
<a> if ( stub != null ) { </a> 0
<a> View titleBar = stub . inflate ( ) ; </a> 0
<a> final RelativeLayout . LayoutParams layoutParams = new RelativeLayout . LayoutParams ( </a> 0
<a> RelativeLayout . LayoutParams . FILL_PARENT , </a> 0
<a> RelativeLayout . LayoutParams . FILL_PARENT ) ; </a> 0
<a> layoutParams . addRule ( RelativeLayout . BELOW , R . id . com_facebook_picker_title_bar ) ; </a> 0
<a> listView . setLayoutParams ( layoutParams ) ; </a> 0
<a> if ( titleBarBackground != null ) { </a> 0
<a> titleBar . setBackgroundDrawable ( titleBarBackground ) ; </a> 0
<a> } </a> 0
<a> doneButton = ( Button ) view . findViewById ( R . id . com_facebook_picker_done_button ) ; </a> 0
<a> if ( doneButton != null ) { </a> 0
<a> doneButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> if ( onDoneButtonClickedListener != null ) { </a> 0
<a> onDoneButtonClickedListener . onDoneButtonClicked ( PickerFragment . this ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> if ( getDoneButtonText ( ) != null ) { </a> 0
<a> doneButton . setText ( getDoneButtonText ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( doneButtonBackground != null ) { </a> 0
<a> doneButton . setBackgroundDrawable ( doneButtonBackground ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> titleTextView = ( TextView ) view . findViewById ( R . id . com_facebook_picker_title ) ; </a> 0
<a> if ( titleTextView != null ) { </a> 0
<a> if ( getTitleText ( ) != null ) { </a> 0
<a> titleTextView . setText ( getTitleText ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onListItemClick ( ListView listView , View v , int position ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> T graphObject = ( T ) listView . getItemAtPosition ( position ) ; </a> 0
<a> String id = adapter . getIdOfGraphObject ( graphObject ) ; </a> 0
<a> selectionStrategy . toggleSelection ( id ) ; </a> 0
<a> adapter . notifyDataSetChanged ( ) ; </a> 0
<a> if ( onSelectionChangedListener != null ) { </a> 0
<a> onSelectionChangedListener . onSelectionChanged ( PickerFragment . this ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void loadDataSkippingRoundTripIfCached ( ) { </a> 0
<a> clearResults ( ) ; </a> 0
<a> Request request = getRequestForLoadData ( getSession ( ) ) ; </a> 0
<a> if ( request != null ) { </a> 0
<a> onLoadingData ( ) ; </a> 0
<a> loadingStrategy . startLoading ( request ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void clearResults ( ) { </a> 0
<a> if ( adapter != null ) { </a> 0
<a> boolean wasSelection = ! selectionStrategy . isEmpty ( ) ; </a> 0
<a> boolean wasData = ! adapter . isEmpty ( ) ; </a> 0
<a> loadingStrategy . clearResults ( ) ; </a> 0
<a> selectionStrategy . clear ( ) ; </a> 0
<a> adapter . notifyDataSetChanged ( ) ; </a> 0
<a> if ( wasData && onDataChangedListener != null ) { </a> 0
<a> onDataChangedListener . onDataChanged ( PickerFragment . this ) ; </a> 0
<a> } </a> 0
<a> if ( wasSelection && onSelectionChangedListener != null ) { </a> 0
<a> onSelectionChangedListener . onSelectionChanged ( PickerFragment . this ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void updateAdapter ( SimpleGraphObjectCursor < T > data ) { </a> 0
<a> if ( adapter != null ) { </a> 0
<a> View view = listView . getChildAt ( 1 ) ; </a> 0
<a> int anchorPosition = listView . getFirstVisiblePosition ( ) ; </a> 0
<a> if ( anchorPosition > 0 ) { </a> 0
<a> anchorPosition ++ ; </a> 0
<a> } </a> 0
<a> GraphObjectAdapter . SectionAndItem < T > anchorItem = adapter . getSectionAndItem ( anchorPosition ) ; </a> 0
<a> final int top = ( view != null && </a> 0
<a> anchorItem . getType ( ) != GraphObjectAdapter . SectionAndItem . Type . ACTIVITY_CIRCLE ) ? </a> 0
<a> view . getTop ( ) : 0 ; </a> 0
<a> boolean dataChanged = adapter . changeCursor ( data ) ; </a> 0
<a> if ( view != null && anchorItem != null ) { </a> 0
<a> final int newPositionOfItem = adapter . getPosition ( anchorItem . sectionKey , anchorItem . graphObject ) ; </a> 0
<a> if ( newPositionOfItem != - 1 ) { </a> 0
<a> listView . setSelectionFromTop ( newPositionOfItem , top ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( dataChanged && onDataChangedListener != null ) { </a> 0
<a> onDataChangedListener . onDataChanged ( PickerFragment . this ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void reprioritizeDownloads ( ) { </a> 0
<a> int lastVisibleItem = listView . getLastVisiblePosition ( ) ; </a> 0
<a> if ( lastVisibleItem >= 0 ) { </a> 0
<a> int firstVisibleItem = listView . getFirstVisiblePosition ( ) ; </a> 0
<a> adapter . prioritizeViewRange ( firstVisibleItem , lastVisibleItem , PROFILE_PICTURE_PREFETCH_BUFFER ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private ListView . OnScrollListener onScrollListener = new ListView . OnScrollListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onScrollStateChanged ( AbsListView view , int scrollState ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onScroll ( AbsListView view , int firstVisibleItem , int visibleItemCount , int totalItemCount ) { </a> 0
<a> reprioritizeDownloads ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> public interface OnErrorListener { </a> 0
<a> void onError ( PickerFragment < ? > fragment , FacebookException error ) ; </a> 0
<a> } </a> 0
<a> public interface OnDataChangedListener { </a> 0
<a> void onDataChanged ( PickerFragment < ? > fragment ) ; </a> 0
<a> } </a> 0
<a> public interface OnSelectionChangedListener { </a> 0
<a> void onSelectionChanged ( PickerFragment < ? > fragment ) ; </a> 0
<a> } </a> 0
<a> public interface OnDoneButtonClickedListener { </a> 0
<a> void onDoneButtonClicked ( PickerFragment < ? > fragment ) ; </a> 0
<a> } </a> 0
<a> public interface GraphObjectFilter < T > { </a> 0
<a> boolean includeItem ( T graphObject ) ; </a> 0
<a> } </a> 0
<a> abstract class LoadingStrategy { </a> 0
<a> protected final static int CACHED_RESULT_REFRESH_DELAY = 2 * 1000 ; </a> 0
<a> protected GraphObjectPagingLoader < T > loader ; </a> 0
<a> protected GraphObjectAdapter < T > adapter ; </a> 0
<a> public void attach ( GraphObjectAdapter < T > adapter ) { </a> 0
<a> loader = ( GraphObjectPagingLoader < T > ) getLoaderManager ( ) . initLoader ( 0 , null , </a> 0
<a> new LoaderManager . LoaderCallbacks < SimpleGraphObjectCursor < T > > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Loader < SimpleGraphObjectCursor < T > > onCreateLoader ( int id , Bundle args ) { </a> 0
<a> return LoadingStrategy . this . onCreateLoader ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onLoadFinished ( Loader < SimpleGraphObjectCursor < T > > loader , </a> 0
<a> SimpleGraphObjectCursor < T > data ) { </a> 0
<a> if ( loader != LoadingStrategy . this . loader ) { </a> 0
<a> throw new FacebookException ( "Received callback for unknown loader." ) ; </a> 0
<a> } </a> 0
<a> LoadingStrategy . this . onLoadFinished ( ( GraphObjectPagingLoader < T > ) loader , data ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onLoaderReset ( Loader < SimpleGraphObjectCursor < T > > loader ) { </a> 0
<a> if ( loader != LoadingStrategy . this . loader ) { </a> 0
<a> throw new FacebookException ( "Received callback for unknown loader." ) ; </a> 0
<a> } </a> 0
<a> LoadingStrategy . this . onLoadReset ( ( GraphObjectPagingLoader < T > ) loader ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> loader . setOnErrorListener ( new GraphObjectPagingLoader . OnErrorListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onError ( FacebookException error , GraphObjectPagingLoader < ? > loader ) { </a> 0
<a> hideActivityCircle ( ) ; </a> 0
<a> if ( onErrorListener != null ) { </a> 0
<a> onErrorListener . onError ( PickerFragment . this , error ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> this . adapter = adapter ; </a> 0
<a> this . adapter . changeCursor ( loader . getCursor ( ) ) ; </a> 0
<a> } </a> 0
<a> public void detach ( ) { </a> 0
<a> adapter . setDataNeededListener ( null ) ; </a> 0
<a> loader . setOnErrorListener ( null ) ; </a> 0
<a> loader = null ; </a> 0
<a> adapter = null ; </a> 0
<a> } </a> 0
<a> public void clearResults ( ) { </a> 0
<a> if ( loader != null ) { </a> 0
<a> loader . clearResults ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void startLoading ( Request request ) { </a> 0
<a> if ( loader != null ) { </a> 0
<a> loader . startLoading ( request , true ) ; </a> 0
<a> onStartLoading ( loader , request ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public boolean isDataPresentOrLoading ( ) { </a> 0
<a> return ! adapter . isEmpty ( ) || loader . isLoading ( ) ; </a> 0
<a> } </a> 0
<a> protected GraphObjectPagingLoader < T > onCreateLoader ( ) { </a> 0
<a> return new GraphObjectPagingLoader < T > ( getActivity ( ) , graphObjectClass ) ; </a> 0
<a> } </a> 0
<a> protected void onStartLoading ( GraphObjectPagingLoader < T > loader , Request request ) { </a> 0
<a> displayActivityCircle ( ) ; </a> 0
<a> } </a> 0
<a> protected void onLoadReset ( GraphObjectPagingLoader < T > loader ) { </a> 0
<a> adapter . changeCursor ( null ) ; </a> 0
<a> } </a> 0
<a> protected void onLoadFinished ( GraphObjectPagingLoader < T > loader , SimpleGraphObjectCursor < T > data ) { </a> 0
<a> updateAdapter ( data ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> abstract class SelectionStrategy { </a> 0
<a> abstract boolean isSelected ( String id ) ; </a> 0
<a> abstract void toggleSelection ( String id ) ; </a> 0
<a> abstract Collection < String > getSelectedIds ( ) ; </a> 0
<a> abstract void clear ( ) ; </a> 0
<a> abstract boolean isEmpty ( ) ; </a> 0
<a> abstract boolean shouldShowCheckBoxIfUnselected ( ) ; </a> 0
<a> abstract void saveSelectionToBundle ( Bundle outBundle , String key ) ; </a> 0
<a> abstract void readSelectionFromBundle ( Bundle inBundle , String key ) ; </a> 0
<a> } </a> 0
<a> class SingleSelectionStrategy extends SelectionStrategy { </a> 0
<a> private String selectedId ; </a> 0
<a> public Collection < String > getSelectedIds ( ) { </a> 0
<a> return Arrays . asList ( new String [ ] { selectedId } ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> boolean isSelected ( String id ) { </a> 0
<a> return selectedId != null && id != null && selectedId . equals ( id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void toggleSelection ( String id ) { </a> 0
<a> if ( selectedId != null && selectedId . equals ( id ) ) { </a> 0
<a> selectedId = null ; </a> 0
<a> } else { </a> 0
<a> selectedId = id ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void saveSelectionToBundle ( Bundle outBundle , String key ) { </a> 0
<a> if ( ! TextUtils . isEmpty ( selectedId ) ) { </a> 0
<a> outBundle . putString ( key , selectedId ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void readSelectionFromBundle ( Bundle inBundle , String key ) { </a> 0
<a> if ( inBundle != null ) { </a> 0
<a> selectedId = inBundle . getString ( key ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clear ( ) { </a> 0
<a> selectedId = null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> boolean isEmpty ( ) { </a> 0
<a> return selectedId == null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> boolean shouldShowCheckBoxIfUnselected ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> class MultiSelectionStrategy extends SelectionStrategy { </a> 0
<a> private Set < String > selectedIds = new HashSet < String > ( ) ; </a> 0
<a> public Collection < String > getSelectedIds ( ) { </a> 0
<a> return selectedIds ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> boolean isSelected ( String id ) { </a> 0
<a> return id != null && selectedIds . contains ( id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void toggleSelection ( String id ) { </a> 0
<a> if ( id != null ) { </a> 0
<a> if ( selectedIds . contains ( id ) ) { </a> 0
<a> selectedIds . remove ( id ) ; </a> 0
<a> } else { </a> 0
<a> selectedIds . add ( id ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void saveSelectionToBundle ( Bundle outBundle , String key ) { </a> 0
<a> if ( ! selectedIds . isEmpty ( ) ) { </a> 0
<a> String ids = TextUtils . join ( "," , selectedIds ) ; </a> 0
<a> outBundle . putString ( key , ids ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void readSelectionFromBundle ( Bundle inBundle , String key ) { </a> 0
<a> if ( inBundle != null ) { </a> 0
<a> String ids = inBundle . getString ( key ) ; </a> 0
<a> if ( ids != null ) { </a> 0
<a> String [ ] splitIds = TextUtils . split ( ids , "," ) ; </a> 0
<a> selectedIds . clear ( ) ; </a> 0
<a> Collections . addAll ( selectedIds , splitIds ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clear ( ) { </a> 0
<a> selectedIds . clear ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> boolean isEmpty ( ) { </a> 0
<a> return selectedIds . isEmpty ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> boolean shouldShowCheckBoxIfUnselected ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> abstract class PickerFragmentAdapter < U extends GraphObject > extends GraphObjectAdapter < T > { </a> 0
<a> public PickerFragmentAdapter ( Context context ) { </a> 0
<a> super ( context ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> boolean isGraphObjectSelected ( String graphObjectId ) { </a> 0
<a> return selectionStrategy . isSelected ( graphObjectId ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void updateCheckboxState ( CheckBox checkBox , boolean graphObjectSelected ) { </a> 0
<a> checkBox . setChecked ( graphObjectSelected ) ; </a> 0
<a> int visible = ( graphObjectSelected || selectionStrategy </a> 0
<a> . shouldShowCheckBoxIfUnselected ( ) ) ? View . VISIBLE : View . GONE ; </a> 0
<a> checkBox . setVisibility ( visible ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . res . TypedArray ; </a> 0
<a> import android . location . Location ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . os . Looper ; </a> 0
<a> import android . text . Editable ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import android . text . TextWatcher ; </a> 0
<a> import android . util . AttributeSet ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . view . ViewStub ; </a> 0
<a> import android . view . inputmethod . InputMethodManager ; </a> 0
<a> import android . widget . EditText ; </a> 0
<a> import android . widget . ListView ; </a> 0
<a> import android . widget . RelativeLayout ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . android . R ; </a> 0
<a> import com . facebook . model . GraphPlace ; </a> 0
<a> import com . facebook . internal . Logger ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import java . util . * ; </a> 0
<a> public class PlacePickerFragment extends PickerFragment < GraphPlace > { </a> 0
<a> public static final String RADIUS_IN_METERS_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.RadiusInMeters" ; </a> 0
<a> public static final String RESULTS_LIMIT_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.ResultsLimit" ; </a> 0
<a> public static final String SEARCH_TEXT_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.SearchText" ; </a> 0
<a> public static final String LOCATION_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.Location" ; </a> 0
<a> public static final String SHOW_SEARCH_BOX_BUNDLE_KEY = "com.facebook.widget.PlacePickerFragment.ShowSearchBox" ; </a> 0
<a> public static final int DEFAULT_RADIUS_IN_METERS = 1000 ; </a> 0
<a> public static final int DEFAULT_RESULTS_LIMIT = 100 ; </a> 0
<a> private static final int searchTextTimerDelayInMilliseconds = 2 * 1000 ; </a> 0
<a> private static final String ID = "id" ; </a> 0
<a> private static final String NAME = "name" ; </a> 0
<a> private static final String LOCATION = "location" ; </a> 0
<a> private static final String CATEGORY = "category" ; </a> 0
<a> private static final String WERE_HERE_COUNT = "were_here_count" ; </a> 0
<a> private static final String TAG = "PlacePickerFragment" ; </a> 0
<a> private Location location ; </a> 0
<a> private int radiusInMeters = DEFAULT_RADIUS_IN_METERS ; </a> 0
<a> private int resultsLimit = DEFAULT_RESULTS_LIMIT ; </a> 0
<a> private String searchText ; </a> 0
<a> private Timer searchTextTimer ; </a> 0
<a> private boolean hasSearchTextChangedSinceLastQuery ; </a> 0
<a> private boolean showSearchBox = true ; </a> 0
<a> private EditText searchBox ; </a> 0
<a> public PlacePickerFragment ( ) { </a> 0
<a> this ( null ) ; </a> 0
<a> } </a> 0
<a> public PlacePickerFragment ( Bundle args ) { </a> 0
<a> super ( GraphPlace . class , R . layout . com_facebook_placepickerfragment , args ) ; </a> 0
<a> setPlacePickerSettingsFromBundle ( args ) ; </a> 0
<a> } </a> 0
<a> public Location getLocation ( ) { </a> 0
<a> return location ; </a> 0
<a> } </a> 0
<a> public void setLocation ( Location location ) { </a> 0
<a> this . location = location ; </a> 0
<a> } </a> 0
<a> public int getRadiusInMeters ( ) { </a> 0
<a> return radiusInMeters ; </a> 0
<a> } </a> 0
<a> public void setRadiusInMeters ( int radiusInMeters ) { </a> 0
<a> this . radiusInMeters = radiusInMeters ; </a> 0
<a> } </a> 0
<a> public int getResultsLimit ( ) { </a> 0
<a> return resultsLimit ; </a> 0
<a> } </a> 0
<a> public void setResultsLimit ( int resultsLimit ) { </a> 0
<a> this . resultsLimit = resultsLimit ; </a> 0
<a> } </a> 0
<a> public String getSearchText ( ) { </a> 0
<a> return searchText ; </a> 0
<a> } </a> 0
<a> public void setSearchText ( String searchText ) { </a> 0
<a> if ( TextUtils . isEmpty ( searchText ) ) { </a> 0
<a> searchText = null ; </a> 0
<a> } </a> 0
<a> this . searchText = searchText ; </a> 0
<a> if ( this . searchBox != null ) { </a> 0
<a> this . searchBox . setText ( searchText ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onSearchBoxTextChanged ( String searchText , boolean forceReloadEventIfSameText ) { </a> 0
<a> if ( ! forceReloadEventIfSameText && Utility . stringsEqualOrEmpty ( this . searchText , searchText ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( TextUtils . isEmpty ( searchText ) ) { </a> 0
<a> searchText = null ; </a> 0
<a> } </a> 0
<a> this . searchText = searchText ; </a> 0
<a> hasSearchTextChangedSinceLastQuery = true ; </a> 0
<a> if ( searchTextTimer == null ) { </a> 0
<a> searchTextTimer = createSearchTextTimer ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public GraphPlace getSelection ( ) { </a> 0
<a> Collection < GraphPlace > selection = getSelectedGraphObjects ( ) ; </a> 0
<a> return ( selection != null && selection . size ( ) > 0 ) ? selection . iterator ( ) . next ( ) : null ; </a> 0
<a> } </a> 0
<a> public void setSettingsFromBundle ( Bundle inState ) { </a> 0
<a> super . setSettingsFromBundle ( inState ) ; </a> 0
<a> setPlacePickerSettingsFromBundle ( inState ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onInflate ( Activity activity , AttributeSet attrs , Bundle savedInstanceState ) { </a> 0
<a> super . onInflate ( activity , attrs , savedInstanceState ) ; </a> 0
<a> TypedArray a = activity . obtainStyledAttributes ( attrs , R . styleable . com_facebook_place_picker_fragment ) ; </a> 0
<a> setRadiusInMeters ( a . getInt ( R . styleable . com_facebook_place_picker_fragment_radius_in_meters , radiusInMeters ) ) ; </a> 0
<a> setResultsLimit ( a . getInt ( R . styleable . com_facebook_place_picker_fragment_results_limit , resultsLimit ) ) ; </a> 0
<a> if ( a . hasValue ( R . styleable . com_facebook_place_picker_fragment_results_limit ) ) { </a> 0
<a> setSearchText ( a . getString ( R . styleable . com_facebook_place_picker_fragment_search_text ) ) ; </a> 0
<a> } </a> 0
<a> showSearchBox = a . getBoolean ( R . styleable . com_facebook_place_picker_fragment_show_search_box , showSearchBox ) ; </a> 0
<a> a . recycle ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onActivityCreated ( final Bundle savedInstanceState ) { </a> 0
<a> super . onActivityCreated ( savedInstanceState ) ; </a> 0
<a> ViewGroup view = ( ViewGroup ) getView ( ) ; </a> 0
<a> if ( showSearchBox ) { </a> 0
<a> ViewStub stub = ( ViewStub ) view . findViewById ( R . id . com_facebook_placepickerfragment_search_box_stub ) ; </a> 0
<a> if ( stub != null ) { </a> 0
<a> searchBox = ( EditText ) stub . inflate ( ) ; </a> 0
<a> RelativeLayout . LayoutParams layoutParams = new RelativeLayout . LayoutParams ( </a> 0
<a> RelativeLayout . LayoutParams . FILL_PARENT , </a> 0
<a> RelativeLayout . LayoutParams . FILL_PARENT ) ; </a> 0
<a> layoutParams . addRule ( RelativeLayout . BELOW , R . id . search_box ) ; </a> 0
<a> ListView listView = ( ListView ) view . findViewById ( R . id . com_facebook_picker_list_view ) ; </a> 0
<a> listView . setLayoutParams ( layoutParams ) ; </a> 0
<a> if ( view . findViewById ( R . id . com_facebook_picker_title_bar ) != null ) { </a> 0
<a> layoutParams = new RelativeLayout . LayoutParams ( </a> 0
<a> RelativeLayout . LayoutParams . FILL_PARENT , </a> 0
<a> RelativeLayout . LayoutParams . WRAP_CONTENT ) ; </a> 0
<a> layoutParams . addRule ( RelativeLayout . BELOW , R . id . com_facebook_picker_title_bar ) ; </a> 0
<a> searchBox . setLayoutParams ( layoutParams ) ; </a> 0
<a> } </a> 0
<a> searchBox . addTextChangedListener ( new SearchTextWatcher ( ) ) ; </a> 0
<a> if ( ! TextUtils . isEmpty ( searchText ) ) { </a> 0
<a> searchBox . setText ( searchText ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onAttach ( Activity activity ) { </a> 0
<a> super . onAttach ( activity ) ; </a> 0
<a> if ( searchBox != null ) { </a> 0
<a> InputMethodManager imm = ( InputMethodManager ) getActivity ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; </a> 0
<a> imm . showSoftInput ( searchBox , InputMethodManager . SHOW_IMPLICIT ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDetach ( ) { </a> 0
<a> super . onDetach ( ) ; </a> 0
<a> if ( searchBox != null ) { </a> 0
<a> InputMethodManager imm = ( InputMethodManager ) getActivity ( ) . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; </a> 0
<a> imm . hideSoftInputFromWindow ( searchBox . getWindowToken ( ) , 0 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void saveSettingsToBundle ( Bundle outState ) { </a> 0
<a> super . saveSettingsToBundle ( outState ) ; </a> 0
<a> outState . putInt ( RADIUS_IN_METERS_BUNDLE_KEY , radiusInMeters ) ; </a> 0
<a> outState . putInt ( RESULTS_LIMIT_BUNDLE_KEY , resultsLimit ) ; </a> 0
<a> outState . putString ( SEARCH_TEXT_BUNDLE_KEY , searchText ) ; </a> 0
<a> outState . putParcelable ( LOCATION_BUNDLE_KEY , location ) ; </a> 0
<a> outState . putBoolean ( SHOW_SEARCH_BOX_BUNDLE_KEY , showSearchBox ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void onLoadingData ( ) { </a> 0
<a> hasSearchTextChangedSinceLastQuery = false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> Request getRequestForLoadData ( Session session ) { </a> 0
<a> return createRequest ( location , radiusInMeters , resultsLimit , searchText , extraFields , session ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> String getDefaultTitleText ( ) { </a> 0
<a> return getString ( R . string . com_facebook_nearby ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> PickerFragmentAdapter < GraphPlace > createAdapter ( ) { </a> 0
<a> PickerFragmentAdapter < GraphPlace > adapter = new PickerFragmentAdapter < GraphPlace > ( </a> 0
<a> this . getActivity ( ) ) { </a> 0
<a> @ Override </a> 0
<a> protected CharSequence getSubTitleOfGraphObject ( GraphPlace graphObject ) { </a> 0
<a> String category = graphObject . getCategory ( ) ; </a> 0
<a> Integer wereHereCount = ( Integer ) graphObject . getProperty ( WERE_HERE_COUNT ) ; </a> 0
<a> String result = null ; </a> 0
<a> if ( category != null && wereHereCount != null ) { </a> 0
<a> result = getString ( R . string . com_facebook_placepicker_subtitle_format , category , wereHereCount ) ; </a> 0
<a> } else if ( category == null && wereHereCount != null ) { </a> 0
<a> result = getString ( R . string . com_facebook_placepicker_subtitle_were_here_only_format , wereHereCount ) ; </a> 0
<a> } else if ( category != null && wereHereCount == null ) { </a> 0
<a> result = getString ( R . string . com_facebook_placepicker_subtitle_catetory_only_format , category ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int getGraphObjectRowLayoutId ( GraphPlace graphObject ) { </a> 0
<a> return R . layout . com_facebook_placepickerfragment_list_row ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int getDefaultPicture ( ) { </a> 0
<a> return R . drawable . com_facebook_place_default_icon ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> adapter . setShowCheckbox ( false ) ; </a> 0
<a> adapter . setShowPicture ( getShowPictures ( ) ) ; </a> 0
<a> return adapter ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> LoadingStrategy createLoadingStrategy ( ) { </a> 0
<a> return new AsNeededLoadingStrategy ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> SelectionStrategy createSelectionStrategy ( ) { </a> 0
<a> return new SingleSelectionStrategy ( ) ; </a> 0
<a> } </a> 0
<a> private Request createRequest ( Location location , int radiusInMeters , int resultsLimit , String searchText , </a> 0
<a> Set < String > extraFields , </a> 0
<a> Session session ) { </a> 0
<a> Request request = Request . newPlacesSearchRequest ( session , location , radiusInMeters , resultsLimit , searchText , </a> 0
<a> null ) ; </a> 0
<a> Set < String > fields = new HashSet < String > ( extraFields ) ; </a> 0
<a> String [ ] requiredFields = new String [ ] { </a> 0
<a> ID , </a> 0
<a> NAME , </a> 0
<a> LOCATION , </a> 0
<a> CATEGORY , </a> 0
<a> WERE_HERE_COUNT </a> 0
<a> } ; </a> 0
<a> fields . addAll ( Arrays . asList ( requiredFields ) ) ; </a> 0
<a> String pictureField = adapter . getPictureFieldSpecifier ( ) ; </a> 0
<a> if ( pictureField != null ) { </a> 0
<a> fields . add ( pictureField ) ; </a> 0
<a> } </a> 0
<a> Bundle parameters = request . getParameters ( ) ; </a> 0
<a> parameters . putString ( "fields" , TextUtils . join ( "," , fields ) ) ; </a> 0
<a> request . setParameters ( parameters ) ; </a> 0
<a> return request ; </a> 0
<a> } </a> 0
<a> private void setPlacePickerSettingsFromBundle ( Bundle inState ) { </a> 0
<a> if ( inState != null ) { </a> 0
<a> setRadiusInMeters ( inState . getInt ( RADIUS_IN_METERS_BUNDLE_KEY , radiusInMeters ) ) ; </a> 0
<a> setResultsLimit ( inState . getInt ( RESULTS_LIMIT_BUNDLE_KEY , resultsLimit ) ) ; </a> 0
<a> if ( inState . containsKey ( SEARCH_TEXT_BUNDLE_KEY ) ) { </a> 0
<a> setSearchText ( inState . getString ( SEARCH_TEXT_BUNDLE_KEY ) ) ; </a> 0
<a> } </a> 0
<a> if ( inState . containsKey ( LOCATION_BUNDLE_KEY ) ) { </a> 0
<a> Location location = inState . getParcelable ( LOCATION_BUNDLE_KEY ) ; </a> 0
<a> setLocation ( location ) ; </a> 0
<a> } </a> 0
<a> showSearchBox = inState . getBoolean ( SHOW_SEARCH_BOX_BUNDLE_KEY , showSearchBox ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private Timer createSearchTextTimer ( ) { </a> 0
<a> Timer timer = new Timer ( ) ; </a> 0
<a> timer . schedule ( new TimerTask ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> onSearchTextTimerTriggered ( ) ; </a> 0
<a> } </a> 0
<a> } , 0 , searchTextTimerDelayInMilliseconds ) ; </a> 0
<a> return timer ; </a> 0
<a> } </a> 0
<a> private void onSearchTextTimerTriggered ( ) { </a> 0
<a> if ( hasSearchTextChangedSinceLastQuery ) { </a> 0
<a> Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; </a> 0
<a> handler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> FacebookException error = null ; </a> 0
<a> try { </a> 0
<a> loadData ( true ) ; </a> 0
<a> } catch ( FacebookException fe ) { </a> 0
<a> error = fe ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> error = new FacebookException ( e ) ; </a> 0
<a> } finally { </a> 0
<a> if ( error != null ) { </a> 0
<a> OnErrorListener onErrorListener = getOnErrorListener ( ) ; </a> 0
<a> if ( onErrorListener != null ) { </a> 0
<a> onErrorListener . onError ( PlacePickerFragment . this , error ) ; </a> 0
<a> } else { </a> 0
<a> Logger . log ( LoggingBehavior . REQUESTS , TAG , "Error loading data : %s" , error ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } else { </a> 0
<a> searchTextTimer . cancel ( ) ; </a> 0
<a> searchTextTimer = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class AsNeededLoadingStrategy extends LoadingStrategy { </a> 0
<a> @ Override </a> 0
<a> public void attach ( GraphObjectAdapter < GraphPlace > adapter ) { </a> 0
<a> super . attach ( adapter ) ; </a> 0
<a> this . adapter . setDataNeededListener ( new GraphObjectAdapter . DataNeededListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onDataNeeded ( ) { </a> 0
<a> if ( ! loader . isLoading ( ) ) { </a> 0
<a> loader . followNextLink ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onLoadFinished ( GraphObjectPagingLoader < GraphPlace > loader , </a> 0
<a> SimpleGraphObjectCursor < GraphPlace > data ) { </a> 0
<a> super . onLoadFinished ( loader , data ) ; </a> 0
<a> if ( data == null || loader . isLoading ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> hideActivityCircle ( ) ; </a> 0
<a> if ( data . isFromCache ( ) ) { </a> 0
<a> loader . refreshOriginalRequest ( data . areMoreObjectsAvailable ( ) ? CACHED_RESULT_REFRESH_DELAY : 0 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class SearchTextWatcher implements TextWatcher { </a> 0
<a> @ Override </a> 0
<a> public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onTextChanged ( CharSequence s , int start , int before , int count ) { </a> 0
<a> onSearchBoxTextChanged ( s . toString ( ) , false ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void afterTextChanged ( Editable s ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . res . TypedArray ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . graphics . BitmapFactory ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Parcelable ; </a> 0
<a> import android . util . AttributeSet ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . widget . FrameLayout ; </a> 0
<a> import android . widget . ImageView ; </a> 0
<a> import com . facebook . FacebookException ; </a> 0
<a> import com . facebook . LoggingBehavior ; </a> 0
<a> import com . facebook . android . R ; </a> 0
<a> import com . facebook . internal . Logger ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> public class ProfilePictureView extends FrameLayout { </a> 0
<a> public interface OnErrorListener { </a> 0
<a> void onError ( FacebookException error ) ; </a> 0
<a> } </a> 0
<a> public static final String TAG = ProfilePictureView . class . getSimpleName ( ) ; </a> 0
<a> public static final int CUSTOM = - 1 ; </a> 0
<a> public static final int SMALL = - 2 ; </a> 0
<a> public static final int NORMAL = - 3 ; </a> 0
<a> public static final int LARGE = - 4 ; </a> 0
<a> private static final int MIN_SIZE = 1 ; </a> 0
<a> private static final boolean IS_CROPPED_DEFAULT_VALUE = true ; </a> 0
<a> private static final String SUPER_STATE_KEY = "ProfilePictureView_superState" ; </a> 0
<a> private static final String PROFILE_ID_KEY = "ProfilePictureView_profileId" ; </a> 0
<a> private static final String PRESET_SIZE_KEY = "ProfilePictureView_presetSize" ; </a> 0
<a> private static final String IS_CROPPED_KEY = "ProfilePictureView_isCropped" ; </a> 0
<a> private static final String BITMAP_KEY = "ProfilePictureView_bitmap" ; </a> 0
<a> private static final String BITMAP_WIDTH_KEY = "ProfilePictureView_width" ; </a> 0
<a> private static final String BITMAP_HEIGHT_KEY = "ProfilePictureView_height" ; </a> 0
<a> private static final String PENDING_REFRESH_KEY = "ProfilePictureView_refresh" ; </a> 0
<a> private String profileId ; </a> 0
<a> private int queryHeight = ImageRequest . UNSPECIFIED_DIMENSION ; </a> 0
<a> private int queryWidth = ImageRequest . UNSPECIFIED_DIMENSION ; </a> 0
<a> private boolean isCropped = IS_CROPPED_DEFAULT_VALUE ; </a> 0
<a> private Bitmap imageContents ; </a> 0
<a> private ImageView image ; </a> 0
<a> private int presetSizeType = CUSTOM ; </a> 0
<a> private ImageRequest lastRequest ; </a> 0
<a> private OnErrorListener onErrorListener ; </a> 0
<a> public ProfilePictureView ( Context context ) { </a> 0
<a> super ( context ) ; </a> 0
<a> initialize ( context ) ; </a> 0
<a> } </a> 0
<a> public ProfilePictureView ( Context context , AttributeSet attrs ) { </a> 0
<a> super ( context , attrs ) ; </a> 0
<a> initialize ( context ) ; </a> 0
<a> parseAttributes ( attrs ) ; </a> 0
<a> } </a> 0
<a> public ProfilePictureView ( Context context , AttributeSet attrs , int defStyle ) { </a> 0
<a> super ( context , attrs , defStyle ) ; </a> 0
<a> initialize ( context ) ; </a> 0
<a> parseAttributes ( attrs ) ; </a> 0
<a> } </a> 0
<a> public final int getPresetSize ( ) { </a> 0
<a> return presetSizeType ; </a> 0
<a> } </a> 0
<a> public final void setPresetSize ( int sizeType ) { </a> 0
<a> switch ( sizeType ) { </a> 0
<a> case SMALL : </a> 0
<a> case NORMAL : </a> 0
<a> case LARGE : </a> 0
<a> case CUSTOM : </a> 0
<a> this . presetSizeType = sizeType ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new IllegalArgumentException ( "Must use a predefined preset size" ) ; </a> 0
<a> } </a> 0
<a> requestLayout ( ) ; </a> 0
<a> } </a> 0
<a> public final boolean isCropped ( ) { </a> 0
<a> return isCropped ; </a> 0
<a> } </a> 0
<a> public final void setCropped ( boolean showCroppedVersion ) { </a> 0
<a> isCropped = showCroppedVersion ; </a> 0
<a> refreshImage ( false ) ; </a> 0
<a> } </a> 0
<a> public final String getProfileId ( ) { </a> 0
<a> return profileId ; </a> 0
<a> } </a> 0
<a> public final void setProfileId ( String profileId ) { </a> 0
<a> boolean force = false ; </a> 0
<a> if ( Utility . isNullOrEmpty ( this . profileId ) || ! this . profileId . equalsIgnoreCase ( profileId ) ) { </a> 0
<a> setBlankProfilePicture ( ) ; </a> 0
<a> force = true ; </a> 0
<a> } </a> 0
<a> this . profileId = profileId ; </a> 0
<a> refreshImage ( force ) ; </a> 0
<a> } </a> 0
<a> public final OnErrorListener getOnErrorListener ( ) { </a> 0
<a> return onErrorListener ; </a> 0
<a> } </a> 0
<a> public final void setOnErrorListener ( OnErrorListener onErrorListener ) { </a> 0
<a> this . onErrorListener = onErrorListener ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { </a> 0
<a> ViewGroup . LayoutParams params = getLayoutParams ( ) ; </a> 0
<a> boolean customMeasure = false ; </a> 0
<a> int newHeight = MeasureSpec . getSize ( heightMeasureSpec ) ; </a> 0
<a> int newWidth = MeasureSpec . getSize ( widthMeasureSpec ) ; </a> 0
<a> if ( MeasureSpec . getMode ( heightMeasureSpec ) != MeasureSpec . EXACTLY && </a> 0
<a> params . height == ViewGroup . LayoutParams . WRAP_CONTENT ) { </a> 0
<a> newHeight = getPresetSizeInPixels ( true ) ; </a> 0
<a> heightMeasureSpec = MeasureSpec . makeMeasureSpec ( newHeight , MeasureSpec . EXACTLY ) ; </a> 0
<a> customMeasure = true ; </a> 0
<a> } </a> 0
<a> if ( MeasureSpec . getMode ( widthMeasureSpec ) != MeasureSpec . EXACTLY && </a> 0
<a> params . width == ViewGroup . LayoutParams . WRAP_CONTENT ) { </a> 0
<a> newWidth = getPresetSizeInPixels ( true ) ; </a> 0
<a> widthMeasureSpec = MeasureSpec . makeMeasureSpec ( newWidth , MeasureSpec . EXACTLY ) ; </a> 0
<a> customMeasure = true ; </a> 0
<a> } </a> 0
<a> if ( customMeasure ) { </a> 0
<a> setMeasuredDimension ( newWidth , newHeight ) ; </a> 0
<a> measureChildren ( widthMeasureSpec , heightMeasureSpec ) ; </a> 0
<a> } else { </a> 0
<a> super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { </a> 0
<a> super . onLayout ( changed , left , top , right , bottom ) ; </a> 0
<a> refreshImage ( false ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected Parcelable onSaveInstanceState ( ) { </a> 0
<a> Parcelable superState = super . onSaveInstanceState ( ) ; </a> 0
<a> Bundle instanceState = new Bundle ( ) ; </a> 0
<a> instanceState . putParcelable ( SUPER_STATE_KEY , superState ) ; </a> 0
<a> instanceState . putString ( PROFILE_ID_KEY , profileId ) ; </a> 0
<a> instanceState . putInt ( PRESET_SIZE_KEY , presetSizeType ) ; </a> 0
<a> instanceState . putBoolean ( IS_CROPPED_KEY , isCropped ) ; </a> 0
<a> instanceState . putParcelable ( BITMAP_KEY , imageContents ) ; </a> 0
<a> instanceState . putInt ( BITMAP_WIDTH_KEY , queryWidth ) ; </a> 0
<a> instanceState . putInt ( BITMAP_HEIGHT_KEY , queryHeight ) ; </a> 0
<a> instanceState . putBoolean ( PENDING_REFRESH_KEY , lastRequest != null ) ; </a> 0
<a> return instanceState ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onRestoreInstanceState ( Parcelable state ) { </a> 0
<a> if ( state . getClass ( ) != Bundle . class ) { </a> 0
<a> super . onRestoreInstanceState ( state ) ; </a> 0
<a> } else { </a> 0
<a> Bundle instanceState = ( Bundle ) state ; </a> 0
<a> super . onRestoreInstanceState ( instanceState . getParcelable ( SUPER_STATE_KEY ) ) ; </a> 0
<a> profileId = instanceState . getString ( PROFILE_ID_KEY ) ; </a> 0
<a> presetSizeType = instanceState . getInt ( PRESET_SIZE_KEY ) ; </a> 0
<a> isCropped = instanceState . getBoolean ( IS_CROPPED_KEY ) ; </a> 0
<a> queryWidth = instanceState . getInt ( BITMAP_WIDTH_KEY ) ; </a> 0
<a> queryHeight = instanceState . getInt ( BITMAP_HEIGHT_KEY ) ; </a> 0
<a> setImageBitmap ( ( Bitmap ) instanceState . getParcelable ( BITMAP_KEY ) ) ; </a> 0
<a> if ( instanceState . getBoolean ( PENDING_REFRESH_KEY ) ) { </a> 0
<a> refreshImage ( true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onDetachedFromWindow ( ) { </a> 0
<a> super . onDetachedFromWindow ( ) ; </a> 0
<a> lastRequest = null ; </a> 0
<a> } </a> 0
<a> private void initialize ( Context context ) { </a> 0
<a> removeAllViews ( ) ; </a> 0
<a> image = new ImageView ( context ) ; </a> 0
<a> LayoutParams imageLayout = new LayoutParams ( </a> 0
<a> LayoutParams . MATCH_PARENT , </a> 0
<a> LayoutParams . MATCH_PARENT ) ; </a> 0
<a> image . setLayoutParams ( imageLayout ) ; </a> 0
<a> image . setScaleType ( ImageView . ScaleType . CENTER_INSIDE ) ; </a> 0
<a> addView ( image ) ; </a> 0
<a> } </a> 0
<a> private void parseAttributes ( AttributeSet attrs ) { </a> 0
<a> TypedArray a = getContext ( ) . obtainStyledAttributes ( attrs , R . styleable . com_facebook_profile_picture_view ) ; </a> 0
<a> setPresetSize ( a . getInt ( R . styleable . com_facebook_profile_picture_view_preset_size , CUSTOM ) ) ; </a> 0
<a> isCropped = a . getBoolean ( R . styleable . com_facebook_profile_picture_view_is_cropped , IS_CROPPED_DEFAULT_VALUE ) ; </a> 0
<a> a . recycle ( ) ; </a> 0
<a> } </a> 0
<a> private void refreshImage ( boolean force ) { </a> 0
<a> boolean changed = updateImageQueryParameters ( ) ; </a> 0
<a> if ( profileId == null || profileId . length ( ) == 0 || </a> 0
<a> ( ( queryWidth == ImageRequest . UNSPECIFIED_DIMENSION ) && </a> 0
<a> ( queryHeight == ImageRequest . UNSPECIFIED_DIMENSION ) ) ) { </a> 0
<a> setBlankProfilePicture ( ) ; </a> 0
<a> } else if ( changed || force ) { </a> 0
<a> sendImageRequest ( true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void setBlankProfilePicture ( ) { </a> 0
<a> int blankImageResource = isCropped ( ) ? </a> 0
<a> R . drawable . com_facebook_profile_picture_blank_square : </a> 0
<a> R . drawable . com_facebook_profile_picture_blank_portrait ; </a> 0
<a> setImageBitmap ( BitmapFactory . decodeResource ( getResources ( ) , blankImageResource ) ) ; </a> 0
<a> } </a> 0
<a> private void setImageBitmap ( Bitmap imageBitmap ) { </a> 0
<a> if ( image != null && imageBitmap != null ) { </a> 0
<a> imageContents = imageBitmap ; </a> 0
<a> image . setImageBitmap ( imageBitmap ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void sendImageRequest ( boolean allowCachedResponse ) { </a> 0
<a> try { </a> 0
<a> ImageRequest . Builder requestBuilder = new ImageRequest . Builder ( </a> 0
<a> getContext ( ) , </a> 0
<a> ImageRequest . getProfilePictureUrl ( profileId , queryWidth , queryHeight ) ) ; </a> 0
<a> ImageRequest request = requestBuilder . setAllowCachedRedirects ( allowCachedResponse ) </a> 0
<a> . setCallerTag ( this ) </a> 0
<a> . setCallback ( </a> 0
<a> new ImageRequest . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( ImageResponse response ) { </a> 0
<a> processResponse ( response ) ; </a> 0
<a> } </a> 0
<a> } ) </a> 0
<a> . build ( ) ; </a> 0
<a> if ( lastRequest != null ) { </a> 0
<a> ImageDownloader . cancelRequest ( lastRequest ) ; </a> 0
<a> } </a> 0
<a> lastRequest = request ; </a> 0
<a> ImageDownloader . downloadAsync ( request ) ; </a> 0
<a> } catch ( MalformedURLException e ) { </a> 0
<a> Logger . log ( LoggingBehavior . REQUESTS , Log . ERROR , TAG , e . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void processResponse ( ImageResponse response ) { </a> 0
<a> if ( response . getRequest ( ) == lastRequest ) { </a> 0
<a> lastRequest = null ; </a> 0
<a> Bitmap responseImage = response . getBitmap ( ) ; </a> 0
<a> Exception error = response . getError ( ) ; </a> 0
<a> if ( error != null ) { </a> 0
<a> OnErrorListener listener = onErrorListener ; </a> 0
<a> if ( listener != null ) { </a> 0
<a> listener . onError ( new FacebookException ( </a> 0
<a> "Error in downloading profile picture for profileId: " + getProfileId ( ) , error ) ) ; </a> 0
<a> } else { </a> 0
<a> Logger . log ( LoggingBehavior . REQUESTS , Log . ERROR , TAG , error . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } else if ( responseImage != null ) { </a> 0
<a> setImageBitmap ( responseImage ) ; </a> 0
<a> if ( response . isCachedRedirect ( ) ) { </a> 0
<a> sendImageRequest ( false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean updateImageQueryParameters ( ) { </a> 0
<a> int newHeightPx = getHeight ( ) ; </a> 0
<a> int newWidthPx = getWidth ( ) ; </a> 0
<a> if ( newWidthPx < MIN_SIZE || newHeightPx < MIN_SIZE ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> int presetSize = getPresetSizeInPixels ( false ) ; </a> 0
<a> if ( presetSize != ImageRequest . UNSPECIFIED_DIMENSION ) { </a> 0
<a> newWidthPx = presetSize ; </a> 0
<a> newHeightPx = presetSize ; </a> 0
<a> } </a> 0
<a> if ( newWidthPx <= newHeightPx ) { </a> 0
<a> newHeightPx = isCropped ( ) ? newWidthPx : ImageRequest . UNSPECIFIED_DIMENSION ; </a> 0
<a> } else { </a> 0
<a> newWidthPx = isCropped ( ) ? newHeightPx : ImageRequest . UNSPECIFIED_DIMENSION ; </a> 0
<a> } </a> 0
<a> boolean changed = ( newWidthPx != queryWidth ) || ( newHeightPx != queryHeight ) ; </a> 0
<a> queryWidth = newWidthPx ; </a> 0
<a> queryHeight = newHeightPx ; </a> 0
<a> return changed ; </a> 0
<a> } </a> 0
<a> private int getPresetSizeInPixels ( boolean forcePreset ) { </a> 0
<a> int dimensionId ; </a> 0
<a> switch ( presetSizeType ) { </a> 0
<a> case SMALL : </a> 0
<a> dimensionId = R . dimen . com_facebook_profilepictureview_preset_size_small ; </a> 0
<a> break ; </a> 0
<a> case NORMAL : </a> 0
<a> dimensionId = R . dimen . com_facebook_profilepictureview_preset_size_normal ; </a> 0
<a> break ; </a> 0
<a> case LARGE : </a> 0
<a> dimensionId = R . dimen . com_facebook_profilepictureview_preset_size_large ; </a> 0
<a> break ; </a> 0
<a> case CUSTOM : </a> 0
<a> if ( ! forcePreset ) { </a> 0
<a> return ImageRequest . UNSPECIFIED_DIMENSION ; </a> 0
<a> } else { </a> 0
<a> dimensionId = R . dimen . com_facebook_profilepictureview_preset_size_normal ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> default : </a> 0
<a> return ImageRequest . UNSPECIFIED_DIMENSION ; </a> 0
<a> } </a> 0
<a> return getResources ( ) . getDimensionPixelSize ( dimensionId ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . database . CursorIndexOutOfBoundsException ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> class SimpleGraphObjectCursor < T extends GraphObject > implements GraphObjectCursor < T > { </a> 0
<a> private int pos = - 1 ; </a> 0
<a> private boolean closed = false ; </a> 0
<a> private ArrayList < T > graphObjects = new ArrayList < T > ( ) ; </a> 0
<a> private boolean moreObjectsAvailable = false ; </a> 0
<a> private boolean fromCache = false ; </a> 0
<a> SimpleGraphObjectCursor ( ) { </a> 0
<a> } </a> 0
<a> SimpleGraphObjectCursor ( SimpleGraphObjectCursor < T > other ) { </a> 0
<a> pos = other . pos ; </a> 0
<a> closed = other . closed ; </a> 0
<a> graphObjects = new ArrayList < T > ( ) ; </a> 0
<a> graphObjects . addAll ( other . graphObjects ) ; </a> 0
<a> fromCache = other . fromCache ; </a> 0
<a> } </a> 0
<a> public void addGraphObjects ( Collection < T > graphObjects , boolean fromCache ) { </a> 0
<a> this . graphObjects . addAll ( graphObjects ) ; </a> 0
<a> this . fromCache |= fromCache ; </a> 0
<a> } </a> 0
<a> public boolean isFromCache ( ) { </a> 0
<a> return fromCache ; </a> 0
<a> } </a> 0
<a> public void setFromCache ( boolean fromCache ) { </a> 0
<a> this . fromCache = fromCache ; </a> 0
<a> } </a> 0
<a> public boolean areMoreObjectsAvailable ( ) { </a> 0
<a> return moreObjectsAvailable ; </a> 0
<a> } </a> 0
<a> public void setMoreObjectsAvailable ( boolean moreObjectsAvailable ) { </a> 0
<a> this . moreObjectsAvailable = moreObjectsAvailable ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getCount ( ) { </a> 0
<a> return graphObjects . size ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getPosition ( ) { </a> 0
<a> return pos ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean move ( int offset ) { </a> 0
<a> return moveToPosition ( pos + offset ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean moveToPosition ( int position ) { </a> 0
<a> final int count = getCount ( ) ; </a> 0
<a> if ( position >= count ) { </a> 0
<a> pos = count ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( position < 0 ) { </a> 0
<a> pos = - 1 ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> pos = position ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean moveToFirst ( ) { </a> 0
<a> return moveToPosition ( 0 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean moveToLast ( ) { </a> 0
<a> return moveToPosition ( getCount ( ) - 1 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean moveToNext ( ) { </a> 0
<a> return moveToPosition ( pos + 1 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean moveToPrevious ( ) { </a> 0
<a> return moveToPosition ( pos - 1 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isFirst ( ) { </a> 0
<a> return ( pos == 0 ) && ( getCount ( ) != 0 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isLast ( ) { </a> 0
<a> final int count = getCount ( ) ; </a> 0
<a> return ( pos == ( count - 1 ) ) && ( count != 0 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isBeforeFirst ( ) { </a> 0
<a> return ( getCount ( ) == 0 ) || ( pos == - 1 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isAfterLast ( ) { </a> 0
<a> final int count = getCount ( ) ; </a> 0
<a> return ( count == 0 ) || ( pos == count ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public T getGraphObject ( ) { </a> 0
<a> if ( pos < 0 ) { </a> 0
<a> throw new CursorIndexOutOfBoundsException ( "Before first object." ) ; </a> 0
<a> } </a> 0
<a> if ( pos >= graphObjects . size ( ) ) { </a> 0
<a> throw new CursorIndexOutOfBoundsException ( "After last object." ) ; </a> 0
<a> } </a> 0
<a> return graphObjects . get ( pos ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) { </a> 0
<a> closed = true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isClosed ( ) { </a> 0
<a> return closed ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import com . facebook . internal . FileLruCache ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . InputStreamReader ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> import java . net . URL ; </a> 0
<a> class UrlRedirectCache { </a> 0
<a> static final String TAG = UrlRedirectCache . class . getSimpleName ( ) ; </a> 0
<a> private static final String REDIRECT_CONTENT_TAG = TAG + "_Redirect" ; </a> 0
<a> private volatile static FileLruCache urlRedirectCache ; </a> 0
<a> synchronized static FileLruCache getCache ( Context context ) throws IOException { </a> 0
<a> if ( urlRedirectCache == null ) { </a> 0
<a> urlRedirectCache = new FileLruCache ( context . getApplicationContext ( ) , TAG , new FileLruCache . Limits ( ) ) ; </a> 0
<a> } </a> 0
<a> return urlRedirectCache ; </a> 0
<a> } </a> 0
<a> static URL getRedirectedUrl ( Context context , URL url ) { </a> 0
<a> if ( url == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> String urlString = url . toString ( ) ; </a> 0
<a> URL finalUrl = null ; </a> 0
<a> InputStreamReader reader = null ; </a> 0
<a> try { </a> 0
<a> InputStream stream ; </a> 0
<a> FileLruCache cache = getCache ( context ) ; </a> 0
<a> boolean redirectExists = false ; </a> 0
<a> while ( ( stream = cache . get ( urlString , REDIRECT_CONTENT_TAG ) ) != null ) { </a> 0
<a> redirectExists = true ; </a> 0
<a> reader = new InputStreamReader ( stream ) ; </a> 0
<a> char [ ] buffer = new char [ 128 ] ; </a> 0
<a> int bufferLength ; </a> 0
<a> StringBuilder urlBuilder = new StringBuilder ( ) ; </a> 0
<a> while ( ( bufferLength = reader . read ( buffer , 0 , buffer . length ) ) > 0 ) { </a> 0
<a> urlBuilder . append ( buffer , 0 , bufferLength ) ; </a> 0
<a> } </a> 0
<a> Utility . closeQuietly ( reader ) ; </a> 0
<a> urlString = urlBuilder . toString ( ) ; </a> 0
<a> } </a> 0
<a> if ( redirectExists ) { </a> 0
<a> finalUrl = new URL ( urlString ) ; </a> 0
<a> } </a> 0
<a> } catch ( MalformedURLException e ) { </a> 0
<a> } catch ( IOException ioe ) { </a> 0
<a> } finally { </a> 0
<a> Utility . closeQuietly ( reader ) ; </a> 0
<a> } </a> 0
<a> return finalUrl ; </a> 0
<a> } </a> 0
<a> static void cacheUrlRedirect ( Context context , URL fromUrl , URL toUrl ) { </a> 0
<a> if ( fromUrl == null || toUrl == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> OutputStream redirectStream = null ; </a> 0
<a> try { </a> 0
<a> FileLruCache cache = getCache ( context ) ; </a> 0
<a> redirectStream = cache . openPutStream ( fromUrl . toString ( ) , REDIRECT_CONTENT_TAG ) ; </a> 0
<a> redirectStream . write ( toUrl . toString ( ) . getBytes ( ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> } finally { </a> 0
<a> Utility . closeQuietly ( redirectStream ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . graphics . drawable . BitmapDrawable ; </a> 0
<a> import android . graphics . drawable . Drawable ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import android . view . LayoutInflater ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . android . R ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> import java . net . URL ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class UserSettingsFragment extends FacebookFragment { </a> 0
<a> private static final String NAME = "name" ; </a> 0
<a> private static final String ID = "id" ; </a> 0
<a> private static final String PICTURE = "picture" ; </a> 0
<a> private static final String FIELDS = "fields" ; </a> 0
<a> private static final String REQUEST_FIELDS = TextUtils . join ( "," , new String [ ] { ID , NAME , PICTURE } ) ; </a> 0
<a> private LoginButton loginButton ; </a> 0
<a> private LoginButton . LoginButtonProperties loginButtonProperties = new LoginButton . LoginButtonProperties ( ) ; </a> 0
<a> private TextView connectedStateLabel ; </a> 0
<a> private GraphUser user ; </a> 0
<a> private Session userInfoSession ; </a> 0
<a> private Drawable userProfilePic ; </a> 0
<a> private String userProfilePicID ; </a> 0
<a> private Session . StatusCallback sessionStatusCallback ; </a> 0
<a> @ Override </a> 0
<a> public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { </a> 0
<a> View view = inflater . inflate ( R . layout . com_facebook_usersettingsfragment , container , false ) ; </a> 0
<a> loginButton = ( LoginButton ) view . findViewById ( R . id . com_facebook_usersettingsfragment_login_button ) ; </a> 0
<a> loginButton . setProperties ( loginButtonProperties ) ; </a> 0
<a> loginButton . setFragment ( this ) ; </a> 0
<a> Session session = getSession ( ) ; </a> 0
<a> if ( session != null && ! session . equals ( Session . getActiveSession ( ) ) ) { </a> 0
<a> loginButton . setSession ( session ) ; </a> 0
<a> } </a> 0
<a> connectedStateLabel = ( TextView ) view . findViewById ( R . id . com_facebook_usersettingsfragment_profile_name ) ; </a> 0
<a> if ( view . getBackground ( ) == null ) { </a> 0
<a> view . setBackgroundColor ( getResources ( ) . getColor ( R . color . com_facebook_blue ) ) ; </a> 0
<a> } else { </a> 0
<a> view . getBackground ( ) . setDither ( true ) ; </a> 0
<a> } </a> 0
<a> return view ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setRetainInstance ( true ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onResume ( ) { </a> 0
<a> super . onResume ( ) ; </a> 0
<a> fetchUserInfo ( ) ; </a> 0
<a> updateUI ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setSession ( Session newSession ) { </a> 0
<a> super . setSession ( newSession ) ; </a> 0
<a> if ( loginButton != null ) { </a> 0
<a> loginButton . setSession ( newSession ) ; </a> 0
<a> } </a> 0
<a> fetchUserInfo ( ) ; </a> 0
<a> updateUI ( ) ; </a> 0
<a> } </a> 0
<a> public void setDefaultAudience ( SessionDefaultAudience defaultAudience ) { </a> 0
<a> loginButtonProperties . setDefaultAudience ( defaultAudience ) ; </a> 0
<a> } </a> 0
<a> public SessionDefaultAudience getDefaultAudience ( ) { </a> 0
<a> return loginButtonProperties . getDefaultAudience ( ) ; </a> 0
<a> } </a> 0
<a> public void setReadPermissions ( List < String > permissions ) { </a> 0
<a> loginButtonProperties . setReadPermissions ( permissions , getSession ( ) ) ; </a> 0
<a> } </a> 0
<a> public void setPublishPermissions ( List < String > permissions ) { </a> 0
<a> loginButtonProperties . setPublishPermissions ( permissions , getSession ( ) ) ; </a> 0
<a> } </a> 0
<a> public void clearPermissions ( ) { </a> 0
<a> loginButtonProperties . clearPermissions ( ) ; </a> 0
<a> } </a> 0
<a> public void setLoginBehavior ( SessionLoginBehavior loginBehavior ) { </a> 0
<a> loginButtonProperties . setLoginBehavior ( loginBehavior ) ; </a> 0
<a> } </a> 0
<a> public SessionLoginBehavior getLoginBehavior ( ) { </a> 0
<a> return loginButtonProperties . getLoginBehavior ( ) ; </a> 0
<a> } </a> 0
<a> public void setOnErrorListener ( LoginButton . OnErrorListener onErrorListener ) { </a> 0
<a> loginButtonProperties . setOnErrorListener ( onErrorListener ) ; </a> 0
<a> } </a> 0
<a> public LoginButton . OnErrorListener getOnErrorListener ( ) { </a> 0
<a> return loginButtonProperties . getOnErrorListener ( ) ; </a> 0
<a> } </a> 0
<a> public void setSessionStatusCallback ( Session . StatusCallback callback ) { </a> 0
<a> this . sessionStatusCallback = callback ; </a> 0
<a> } </a> 0
<a> public Session . StatusCallback getSessionStatusCallback ( ) { </a> 0
<a> return sessionStatusCallback ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onSessionStateChange ( SessionState state , Exception exception ) { </a> 0
<a> fetchUserInfo ( ) ; </a> 0
<a> updateUI ( ) ; </a> 0
<a> if ( sessionStatusCallback != null ) { </a> 0
<a> sessionStatusCallback . call ( getSession ( ) , state , exception ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> List < String > getPermissions ( ) { </a> 0
<a> return loginButtonProperties . getPermissions ( ) ; </a> 0
<a> } </a> 0
<a> private void fetchUserInfo ( ) { </a> 0
<a> final Session currentSession = getSession ( ) ; </a> 0
<a> if ( currentSession != null && currentSession . isOpened ( ) ) { </a> 0
<a> if ( currentSession != userInfoSession ) { </a> 0
<a> Request request = Request . newMeRequest ( currentSession , new Request . GraphUserCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( GraphUser me , Response response ) { </a> 0
<a> if ( currentSession == getSession ( ) ) { </a> 0
<a> user = me ; </a> 0
<a> updateUI ( ) ; </a> 0
<a> } </a> 0
<a> if ( response . getError ( ) != null ) { </a> 0
<a> loginButton . handleError ( response . getError ( ) . getException ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> parameters . putString ( FIELDS , REQUEST_FIELDS ) ; </a> 0
<a> request . setParameters ( parameters ) ; </a> 0
<a> Request . executeBatchAsync ( request ) ; </a> 0
<a> userInfoSession = currentSession ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> user = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void updateUI ( ) { </a> 0
<a> if ( ! isAdded ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( isSessionOpen ( ) ) { </a> 0
<a> connectedStateLabel . setTextColor ( getResources ( ) . getColor ( R . color . com_facebook_usersettingsfragment_connected_text_color ) ) ; </a> 0
<a> connectedStateLabel . setShadowLayer ( 1f , 0f , - 1f , </a> 0
<a> getResources ( ) . getColor ( R . color . com_facebook_usersettingsfragment_connected_shadow_color ) ) ; </a> 0
<a> if ( user != null ) { </a> 0
<a> ImageRequest request = getImageRequest ( ) ; </a> 0
<a> if ( request != null ) { </a> 0
<a> URL requestUrl = request . getImageUrl ( ) ; </a> 0
<a> if ( ! requestUrl . equals ( connectedStateLabel . getTag ( ) ) ) { </a> 0
<a> if ( user . getId ( ) . equals ( userProfilePicID ) ) { </a> 0
<a> connectedStateLabel . setCompoundDrawables ( null , userProfilePic , null , null ) ; </a> 0
<a> connectedStateLabel . setTag ( requestUrl ) ; </a> 0
<a> } else { </a> 0
<a> ImageDownloader . downloadAsync ( request ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> connectedStateLabel . setText ( user . getName ( ) ) ; </a> 0
<a> } else { </a> 0
<a> connectedStateLabel . setText ( getResources ( ) . getString ( </a> 0
<a> R . string . com_facebook_usersettingsfragment_logged_in ) ) ; </a> 0
<a> Drawable noProfilePic = getResources ( ) . getDrawable ( R . drawable . com_facebook_profile_default_icon ) ; </a> 0
<a> noProfilePic . setBounds ( 0 , 0 , </a> 0
<a> getResources ( ) . getDimensionPixelSize ( R . dimen . com_facebook_usersettingsfragment_profile_picture_width ) , </a> 0
<a> getResources ( ) . getDimensionPixelSize ( R . dimen . com_facebook_usersettingsfragment_profile_picture_height ) ) ; </a> 0
<a> connectedStateLabel . setCompoundDrawables ( null , noProfilePic , null , null ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> int textColor = getResources ( ) . getColor ( R . color . com_facebook_usersettingsfragment_not_connected_text_color ) ; </a> 0
<a> connectedStateLabel . setTextColor ( textColor ) ; </a> 0
<a> connectedStateLabel . setShadowLayer ( 0f , 0f , 0f , textColor ) ; </a> 0
<a> connectedStateLabel . setText ( getResources ( ) . getString ( </a> 0
<a> R . string . com_facebook_usersettingsfragment_not_logged_in ) ) ; </a> 0
<a> connectedStateLabel . setCompoundDrawables ( null , null , null , null ) ; </a> 0
<a> connectedStateLabel . setTag ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private ImageRequest getImageRequest ( ) { </a> 0
<a> ImageRequest request = null ; </a> 0
<a> try { </a> 0
<a> ImageRequest . Builder requestBuilder = new ImageRequest . Builder ( </a> 0
<a> getActivity ( ) , </a> 0
<a> ImageRequest . getProfilePictureUrl ( </a> 0
<a> user . getId ( ) , </a> 0
<a> getResources ( ) . getDimensionPixelSize ( R . dimen . com_facebook_usersettingsfragment_profile_picture_width ) , </a> 0
<a> getResources ( ) . getDimensionPixelSize ( R . dimen . com_facebook_usersettingsfragment_profile_picture_height ) ) ) ; </a> 0
<a> request = requestBuilder . setCallerTag ( this ) </a> 0
<a> . setCallback ( </a> 0
<a> new ImageRequest . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( ImageResponse response ) { </a> 0
<a> processImageResponse ( user . getId ( ) , response ) ; </a> 0
<a> } </a> 0
<a> } ) </a> 0
<a> . build ( ) ; </a> 0
<a> } catch ( MalformedURLException e ) { </a> 0
<a> } </a> 0
<a> return request ; </a> 0
<a> } </a> 0
<a> private void processImageResponse ( String id , ImageResponse response ) { </a> 0
<a> if ( response != null ) { </a> 0
<a> Bitmap bitmap = response . getBitmap ( ) ; </a> 0
<a> if ( bitmap != null ) { </a> 0
<a> BitmapDrawable drawable = new BitmapDrawable ( UserSettingsFragment . this . getResources ( ) , bitmap ) ; </a> 0
<a> drawable . setBounds ( 0 , 0 , </a> 0
<a> getResources ( ) . getDimensionPixelSize ( R . dimen . com_facebook_usersettingsfragment_profile_picture_width ) , </a> 0
<a> getResources ( ) . getDimensionPixelSize ( R . dimen . com_facebook_usersettingsfragment_profile_picture_height ) ) ; </a> 0
<a> userProfilePic = drawable ; </a> 0
<a> userProfilePicID = id ; </a> 0
<a> connectedStateLabel . setCompoundDrawables ( null , drawable , null , null ) ; </a> 0
<a> connectedStateLabel . setTag ( response . getRequest ( ) . getImageUrl ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . annotation . SuppressLint ; </a> 0
<a> import android . app . Dialog ; </a> 0
<a> import android . app . ProgressDialog ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . DialogInterface ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . graphics . Color ; </a> 0
<a> import android . graphics . drawable . Drawable ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . net . http . SslError ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . view . Window ; </a> 0
<a> import android . webkit . SslErrorHandler ; </a> 0
<a> import android . webkit . WebView ; </a> 0
<a> import android . webkit . WebViewClient ; </a> 0
<a> import android . widget . FrameLayout ; </a> 0
<a> import android . widget . ImageView ; </a> 0
<a> import android . widget . LinearLayout ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . android . * ; </a> 0
<a> import com . facebook . internal . Logger ; </a> 0
<a> import com . facebook . internal . ServerProtocol ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import com . facebook . internal . Validate ; </a> 0
<a> public class WebDialog extends Dialog { </a> 0
<a> private static final String LOG_TAG = Logger . LOG_TAG_BASE + "WebDialog" ; </a> 0
<a> private static final String DISPLAY_TOUCH = "touch" ; </a> 0
<a> private static final String USER_AGENT = "user_agent" ; </a> 0
<a> static final String REDIRECT_URI = "fbconnect://success" ; </a> 0
<a> static final String CANCEL_URI = "fbconnect://cancel" ; </a> 0
<a> public static final int DEFAULT_THEME = android . R . style . Theme_Translucent_NoTitleBar ; </a> 0
<a> private String url ; </a> 0
<a> private OnCompleteListener onCompleteListener ; </a> 0
<a> private WebView webView ; </a> 0
<a> private ProgressDialog spinner ; </a> 0
<a> private ImageView crossImageView ; </a> 0
<a> private FrameLayout contentFrameLayout ; </a> 0
<a> private boolean listenerCalled = false ; </a> 0
<a> private boolean isDetached = false ; </a> 0
<a> public interface OnCompleteListener { </a> 0
<a> void onComplete ( Bundle values , FacebookException error ) ; </a> 0
<a> } </a> 0
<a> public WebDialog ( Context context , String url ) { </a> 0
<a> this ( context , url , DEFAULT_THEME ) ; </a> 0
<a> } </a> 0
<a> public WebDialog ( Context context , String url , int theme ) { </a> 0
<a> super ( context , theme ) ; </a> 0
<a> this . url = url ; </a> 0
<a> } </a> 0
<a> public WebDialog ( Context context , String action , Bundle parameters , int theme , OnCompleteListener listener ) { </a> 0
<a> super ( context , theme ) ; </a> 0
<a> if ( parameters == null ) { </a> 0
<a> parameters = new Bundle ( ) ; </a> 0
<a> } </a> 0
<a> parameters . putString ( ServerProtocol . DIALOG_PARAM_DISPLAY , DISPLAY_TOUCH ) ; </a> 0
<a> parameters . putString ( ServerProtocol . DIALOG_PARAM_TYPE , USER_AGENT ) ; </a> 0
<a> Uri uri = Utility . buildUri ( ServerProtocol . DIALOG_AUTHORITY , ServerProtocol . DIALOG_PATH + action , parameters ) ; </a> 0
<a> this . url = uri . toString ( ) ; </a> 0
<a> onCompleteListener = listener ; </a> 0
<a> } </a> 0
<a> public void setOnCompleteListener ( OnCompleteListener listener ) { </a> 0
<a> onCompleteListener = listener ; </a> 0
<a> } </a> 0
<a> public OnCompleteListener getOnCompleteListener ( ) { </a> 0
<a> return onCompleteListener ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void dismiss ( ) { </a> 0
<a> if ( webView != null ) { </a> 0
<a> webView . stopLoading ( ) ; </a> 0
<a> } </a> 0
<a> if ( ! isDetached ) { </a> 0
<a> if ( spinner . isShowing ( ) ) { </a> 0
<a> spinner . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> super . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDetachedFromWindow ( ) { </a> 0
<a> isDetached = true ; </a> 0
<a> super . onDetachedFromWindow ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onAttachedToWindow ( ) { </a> 0
<a> isDetached = false ; </a> 0
<a> super . onAttachedToWindow ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setOnCancelListener ( new OnCancelListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCancel ( DialogInterface dialogInterface ) { </a> 0
<a> sendCancelToListener ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> spinner = new ProgressDialog ( getContext ( ) ) ; </a> 0
<a> spinner . requestWindowFeature ( Window . FEATURE_NO_TITLE ) ; </a> 0
<a> spinner . setMessage ( getContext ( ) . getString ( R . string . com_facebook_loading ) ) ; </a> 0
<a> spinner . setOnCancelListener ( new OnCancelListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCancel ( DialogInterface dialogInterface ) { </a> 0
<a> sendCancelToListener ( ) ; </a> 0
<a> WebDialog . this . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> requestWindowFeature ( Window . FEATURE_NO_TITLE ) ; </a> 0
<a> contentFrameLayout = new FrameLayout ( getContext ( ) ) ; </a> 0
<a> createCrossImage ( ) ; </a> 0
<a> int crossWidth = crossImageView . getDrawable ( ) . getIntrinsicWidth ( ) ; </a> 0
<a> setUpWebView ( crossWidth / 2 ) ; </a> 0
<a> contentFrameLayout . addView ( crossImageView , new ViewGroup . LayoutParams ( </a> 0
<a> ViewGroup . LayoutParams . WRAP_CONTENT , ViewGroup . LayoutParams . WRAP_CONTENT ) ) ; </a> 0
<a> addContentView ( contentFrameLayout , </a> 1
<a> new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , ViewGroup . LayoutParams . MATCH_PARENT ) ) ; </a> 1
<a> } </a> 0
<a> private void sendSuccessToListener ( Bundle values ) { </a> 0
<a> if ( onCompleteListener != null && ! listenerCalled ) { </a> 0
<a> listenerCalled = true ; </a> 0
<a> onCompleteListener . onComplete ( values , null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void sendErrorToListener ( Throwable error ) { </a> 0
<a> if ( onCompleteListener != null && ! listenerCalled ) { </a> 0
<a> listenerCalled = true ; </a> 0
<a> FacebookException facebookException = null ; </a> 0
<a> if ( error instanceof FacebookException ) { </a> 0
<a> facebookException = ( FacebookException ) error ; </a> 0
<a> } else { </a> 0
<a> facebookException = new FacebookException ( error ) ; </a> 0
<a> } </a> 0
<a> onCompleteListener . onComplete ( null , facebookException ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void sendCancelToListener ( ) { </a> 0
<a> sendErrorToListener ( new FacebookOperationCanceledException ( ) ) ; </a> 0
<a> } </a> 0
<a> private void createCrossImage ( ) { </a> 0
<a> crossImageView = new ImageView ( getContext ( ) ) ; </a> 0
<a> crossImageView . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> sendCancelToListener ( ) ; </a> 0
<a> WebDialog . this . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Drawable crossDrawable = getContext ( ) . getResources ( ) . getDrawable ( R . drawable . com_facebook_close ) ; </a> 0
<a> crossImageView . setImageDrawable ( crossDrawable ) ; </a> 0
<a> crossImageView . setVisibility ( View . INVISIBLE ) ; </a> 0
<a> } </a> 0
<a> @ SuppressLint ( "SetJavaScriptEnabled" ) </a> 0
<a> private void setUpWebView ( int margin ) { </a> 0
<a> LinearLayout webViewContainer = new LinearLayout ( getContext ( ) ) ; </a> 0
<a> webView = new WebView ( getContext ( ) ) ; </a> 0
<a> webView . setVerticalScrollBarEnabled ( false ) ; </a> 0
<a> webView . setHorizontalScrollBarEnabled ( false ) ; </a> 0
<a> webView . setWebViewClient ( new DialogWebViewClient ( ) ) ; </a> 0
<a> webView . getSettings ( ) . setJavaScriptEnabled ( true ) ; </a> 0
<a> webView . loadUrl ( url ) ; </a> 0
<a> webView . setLayoutParams ( new FrameLayout . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT , </a> 0
<a> ViewGroup . LayoutParams . MATCH_PARENT ) ) ; </a> 0
<a> webView . setVisibility ( View . INVISIBLE ) ; </a> 0
<a> webView . getSettings ( ) . setSavePassword ( false ) ; </a> 0
<a> webViewContainer . setPadding ( margin , margin , margin , margin ) ; </a> 0
<a> webViewContainer . addView ( webView ) ; </a> 0
<a> contentFrameLayout . addView ( webViewContainer ) ; </a> 0
<a> } </a> 0
<a> private class DialogWebViewClient extends WebViewClient { </a> 0
<a> @ Override </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public boolean shouldOverrideUrlLoading ( WebView view , String url ) { </a> 0
<a> Utility . logd ( LOG_TAG , "Redirect URL: " + url ) ; </a> 0
<a> if ( url . startsWith ( WebDialog . REDIRECT_URI ) ) { </a> 0
<a> Bundle values = Util . parseUrl ( url ) ; </a> 0
<a> String error = values . getString ( "error" ) ; </a> 0
<a> if ( error == null ) { </a> 0
<a> error = values . getString ( "error_type" ) ; </a> 0
<a> } </a> 0
<a> String errorMessage = values . getString ( "error_msg" ) ; </a> 0
<a> if ( errorMessage == null ) { </a> 0
<a> errorMessage = values . getString ( "error_description" ) ; </a> 0
<a> } </a> 0
<a> String errorCodeString = values . getString ( "error_code" ) ; </a> 0
<a> int errorCode = FacebookRequestError . INVALID_ERROR_CODE ; </a> 0
<a> if ( ! Utility . isNullOrEmpty ( errorCodeString ) ) { </a> 0
<a> try { </a> 0
<a> errorCode = Integer . parseInt ( errorCodeString ) ; </a> 0
<a> } catch ( NumberFormatException ex ) { </a> 0
<a> errorCode = FacebookRequestError . INVALID_ERROR_CODE ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( Utility . isNullOrEmpty ( error ) && Utility </a> 0
<a> . isNullOrEmpty ( errorMessage ) && errorCode == FacebookRequestError . INVALID_ERROR_CODE ) { </a> 0
<a> sendSuccessToListener ( values ) ; </a> 0
<a> } else if ( error != null && ( error . equals ( "access_denied" ) || </a> 0
<a> error . equals ( "OAuthAccessDeniedException" ) ) ) { </a> 0
<a> sendCancelToListener ( ) ; </a> 0
<a> } else { </a> 0
<a> FacebookRequestError requestError = new FacebookRequestError ( errorCode , error , errorMessage ) ; </a> 0
<a> sendErrorToListener ( new FacebookServiceException ( requestError , errorMessage ) ) ; </a> 0
<a> } </a> 0
<a> WebDialog . this . dismiss ( ) ; </a> 0
<a> return true ; </a> 0
<a> } else if ( url . startsWith ( WebDialog . CANCEL_URI ) ) { </a> 0
<a> sendCancelToListener ( ) ; </a> 0
<a> WebDialog . this . dismiss ( ) ; </a> 0
<a> return true ; </a> 0
<a> } else if ( url . contains ( DISPLAY_TOUCH ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> getContext ( ) . startActivity ( </a> 0
<a> new Intent ( Intent . ACTION_VIEW , Uri . parse ( url ) ) ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onReceivedError ( WebView view , int errorCode , </a> 0
<a> String description , String failingUrl ) { </a> 0
<a> super . onReceivedError ( view , errorCode , description , failingUrl ) ; </a> 0
<a> sendErrorToListener ( new FacebookDialogException ( description , errorCode , failingUrl ) ) ; </a> 0
<a> WebDialog . this . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onReceivedSslError ( WebView view , SslErrorHandler handler , SslError error ) { </a> 0
<a> super . onReceivedSslError ( view , handler , error ) ; </a> 0
<a> sendErrorToListener ( new FacebookDialogException ( null , ERROR_FAILED_SSL_HANDSHAKE , null ) ) ; </a> 0
<a> handler . cancel ( ) ; </a> 0
<a> WebDialog . this . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onPageStarted ( WebView view , String url , Bitmap favicon ) { </a> 0
<a> Utility . logd ( LOG_TAG , "Webview loading URL: " + url ) ; </a> 0
<a> super . onPageStarted ( view , url , favicon ) ; </a> 0
<a> if ( ! isDetached ) { </a> 0
<a> spinner . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onPageFinished ( WebView view , String url ) { </a> 0
<a> super . onPageFinished ( view , url ) ; </a> 0
<a> if ( ! isDetached ) { </a> 0
<a> spinner . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> contentFrameLayout . setBackgroundColor ( Color . TRANSPARENT ) ; </a> 0
<a> webView . setVisibility ( View . VISIBLE ) ; </a> 0
<a> crossImageView . setVisibility ( View . VISIBLE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class BuilderBase < CONCRETE extends BuilderBase < ? > > { </a> 0
<a> private static final String APP_ID_PARAM = "app_id" ; </a> 1
<a> public static final String ACCESS_TOKEN = "access_token" ; </a> 1
<a> private Context context ; </a> 0
<a> private Session session ; </a> 0
<a> private String applicationId ; </a> 0
<a> private String action ; </a> 0
<a> private int theme = DEFAULT_THEME ; </a> 0
<a> private OnCompleteListener listener ; </a> 0
<a> private Bundle parameters ; </a> 0
<a> protected BuilderBase ( Context context , Session session , String action , Bundle parameters ) { </a> 0
<a> Validate . notNull ( session , "session" ) ; </a> 0
<a> if ( ! session . isOpened ( ) ) { </a> 0
<a> throw new FacebookException ( "Attempted to use a Session that was not open." ) ; </a> 0
<a> } </a> 0
<a> this . session = session ; </a> 0
<a> finishInit ( context , action , parameters ) ; </a> 0
<a> } </a> 0
<a> protected BuilderBase ( Context context , String applicationId , String action , Bundle parameters ) { </a> 0
<a> Validate . notNullOrEmpty ( applicationId , "applicationId" ) ; </a> 0
<a> this . applicationId = applicationId ; </a> 0
<a> finishInit ( context , action , parameters ) ; </a> 0
<a> } </a> 0
<a> public CONCRETE setTheme ( int theme ) { </a> 0
<a> this . theme = theme ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> CONCRETE result = ( CONCRETE ) this ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> public CONCRETE setOnCompleteListener ( OnCompleteListener listener ) { </a> 0
<a> this . listener = listener ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> CONCRETE result = ( CONCRETE ) this ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> public WebDialog build ( ) { </a> 0
<a> if ( session != null && session . isOpened ( ) ) { </a> 0
<a> parameters . putString ( APP_ID_PARAM , session . getApplicationId ( ) ) ; </a> 1
<a> parameters . putString ( ACCESS_TOKEN , session . getAccessToken ( ) ) ; </a> 1
<a> } else { </a> 0
<a> parameters . putString ( APP_ID_PARAM , applicationId ) ; </a> 1
<a> } </a> 0
<a> if ( ! parameters . containsKey ( ServerProtocol . DIALOG_PARAM_REDIRECT_URI ) ) { </a> 0
<a> parameters . putString ( ServerProtocol . DIALOG_PARAM_REDIRECT_URI , REDIRECT_URI ) ; </a> 0
<a> } </a> 0
<a> return new WebDialog ( context , action , parameters , theme , listener ) ; </a> 0
<a> } </a> 0
<a> protected String getApplicationId ( ) { </a> 0
<a> return applicationId ; </a> 0
<a> } </a> 0
<a> protected Context getContext ( ) { </a> 0
<a> return context ; </a> 0
<a> } </a> 0
<a> protected int getTheme ( ) { </a> 0
<a> return theme ; </a> 0
<a> } </a> 0
<a> protected Bundle getParameters ( ) { </a> 0
<a> return parameters ; </a> 0
<a> } </a> 0
<a> protected WebDialog . OnCompleteListener getListener ( ) { </a> 0
<a> return listener ; </a> 0
<a> } </a> 0
<a> private void finishInit ( Context context , String action , Bundle parameters ) { </a> 0
<a> this . context = context ; </a> 0
<a> this . action = action ; </a> 0
<a> if ( parameters != null ) { </a> 0
<a> this . parameters = parameters ; </a> 0
<a> } else { </a> 0
<a> this . parameters = new Bundle ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static class Builder extends BuilderBase < Builder > { </a> 0
<a> public Builder ( Context context , Session session , String action , Bundle parameters ) { </a> 0
<a> super ( context , session , action , parameters ) ; </a> 0
<a> } </a> 0
<a> public Builder ( Context context , String applicationId , String action , Bundle parameters ) { </a> 0
<a> super ( context , applicationId , action , parameters ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static class FeedDialogBuilder extends BuilderBase < FeedDialogBuilder > { </a> 0
<a> private static final String FEED_DIALOG = "feed" ; </a> 0
<a> private static final String FROM_PARAM = "from" ; </a> 0
<a> private static final String TO_PARAM = "to" ; </a> 0
<a> private static final String LINK_PARAM = "link" ; </a> 0
<a> private static final String PICTURE_PARAM = "picture" ; </a> 0
<a> private static final String SOURCE_PARAM = "source" ; </a> 0
<a> private static final String NAME_PARAM = "name" ; </a> 0
<a> private static final String CAPTION_PARAM = "caption" ; </a> 0
<a> private static final String DESCRIPTION_PARAM = "description" ; </a> 0
<a> public FeedDialogBuilder ( Context context , Session session ) { </a> 0
<a> super ( context , session , FEED_DIALOG , null ) ; </a> 0
<a> } </a> 0
<a> public FeedDialogBuilder ( Context context , Session session , Bundle parameters ) { </a> 0
<a> super ( context , session , FEED_DIALOG , parameters ) ; </a> 0
<a> } </a> 0
<a> public FeedDialogBuilder setFrom ( String id ) { </a> 0
<a> getParameters ( ) . putString ( FROM_PARAM , id ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public FeedDialogBuilder setTo ( String id ) { </a> 0
<a> getParameters ( ) . putString ( TO_PARAM , id ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public FeedDialogBuilder setLink ( String link ) { </a> 0
<a> getParameters ( ) . putString ( LINK_PARAM , link ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public FeedDialogBuilder setPicture ( String picture ) { </a> 0
<a> getParameters ( ) . putString ( PICTURE_PARAM , picture ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public FeedDialogBuilder setSource ( String source ) { </a> 0
<a> getParameters ( ) . putString ( SOURCE_PARAM , source ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public FeedDialogBuilder setName ( String name ) { </a> 0
<a> getParameters ( ) . putString ( NAME_PARAM , name ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public FeedDialogBuilder setCaption ( String caption ) { </a> 0
<a> getParameters ( ) . putString ( CAPTION_PARAM , caption ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public FeedDialogBuilder setDescription ( String description ) { </a> 0
<a> getParameters ( ) . putString ( DESCRIPTION_PARAM , description ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static class RequestsDialogBuilder extends BuilderBase < RequestsDialogBuilder > { </a> 0
<a> private static final String APPREQUESTS_DIALOG = "apprequests" ; </a> 0
<a> private static final String MESSAGE_PARAM = "message" ; </a> 0
<a> private static final String TO_PARAM = "to" ; </a> 0
<a> private static final String DATA_PARAM = "data" ; </a> 0
<a> private static final String TITLE_PARAM = "title" ; </a> 0
<a> public RequestsDialogBuilder ( Context context , Session session ) { </a> 0
<a> super ( context , session , APPREQUESTS_DIALOG , null ) ; </a> 0
<a> } </a> 0
<a> public RequestsDialogBuilder ( Context context , Session session , Bundle parameters ) { </a> 0
<a> super ( context , session , APPREQUESTS_DIALOG , parameters ) ; </a> 0
<a> } </a> 0
<a> public RequestsDialogBuilder setMessage ( String message ) { </a> 0
<a> getParameters ( ) . putString ( MESSAGE_PARAM , message ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public RequestsDialogBuilder setTo ( String id ) { </a> 0
<a> getParameters ( ) . putString ( TO_PARAM , id ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public RequestsDialogBuilder setData ( String data ) { </a> 0
<a> getParameters ( ) . putString ( DATA_PARAM , data ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public RequestsDialogBuilder setTitle ( String title ) { </a> 0
<a> getParameters ( ) . putString ( TITLE_PARAM , title ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import com . facebook . Settings ; </a> 0
<a> import java . util . concurrent . Executor ; </a> 0
<a> class WorkQueue { </a> 0
<a> public static final int DEFAULT_MAX_CONCURRENT = 8 ; </a> 0
<a> private final Object workLock = new Object ( ) ; </a> 0
<a> private WorkNode pendingJobs ; </a> 0
<a> private final int maxConcurrent ; </a> 0
<a> private final Executor executor ; </a> 0
<a> private WorkNode runningJobs = null ; </a> 0
<a> private int runningCount = 0 ; </a> 0
<a> WorkQueue ( ) { </a> 0
<a> this ( DEFAULT_MAX_CONCURRENT ) ; </a> 0
<a> } </a> 0
<a> WorkQueue ( int maxConcurrent ) { </a> 0
<a> this ( maxConcurrent , Settings . getExecutor ( ) ) ; </a> 0
<a> } </a> 0
<a> WorkQueue ( int maxConcurrent , Executor executor ) { </a> 0
<a> this . maxConcurrent = maxConcurrent ; </a> 0
<a> this . executor = executor ; </a> 0
<a> } </a> 0
<a> WorkItem addActiveWorkItem ( Runnable callback ) { </a> 0
<a> return addActiveWorkItem ( callback , true ) ; </a> 0
<a> } </a> 0
<a> WorkItem addActiveWorkItem ( Runnable callback , boolean addToFront ) { </a> 0
<a> WorkNode node = new WorkNode ( callback ) ; </a> 0
<a> synchronized ( workLock ) { </a> 0
<a> pendingJobs = node . addToList ( pendingJobs , addToFront ) ; </a> 0
<a> } </a> 0
<a> startItem ( ) ; </a> 0
<a> return node ; </a> 0
<a> } </a> 0
<a> void validate ( ) { </a> 0
<a> synchronized ( workLock ) { </a> 0
<a> int count = 0 ; </a> 0
<a> if ( runningJobs != null ) { </a> 0
<a> WorkNode walk = runningJobs ; </a> 0
<a> do { </a> 0
<a> walk . verify ( true ) ; </a> 0
<a> count ++ ; </a> 0
<a> walk = walk . getNext ( ) ; </a> 0
<a> } while ( walk != runningJobs ) ; </a> 0
<a> } </a> 0
<a> assert runningCount == count ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void startItem ( ) { </a> 0
<a> finishItemAndStartNew ( null ) ; </a> 0
<a> } </a> 0
<a> private void finishItemAndStartNew ( WorkNode finished ) { </a> 0
<a> WorkNode ready = null ; </a> 0
<a> synchronized ( workLock ) { </a> 0
<a> if ( finished != null ) { </a> 0
<a> runningJobs = finished . removeFromList ( runningJobs ) ; </a> 0
<a> runningCount -- ; </a> 0
<a> } </a> 0
<a> if ( runningCount < maxConcurrent ) { </a> 0
<a> ready = pendingJobs ; </a> 0
<a> if ( ready != null ) { </a> 0
<a> pendingJobs = ready . removeFromList ( pendingJobs ) ; </a> 0
<a> runningJobs = ready . addToList ( runningJobs , false ) ; </a> 0
<a> runningCount ++ ; </a> 0
<a> ready . setIsRunning ( true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ready != null ) { </a> 0
<a> execute ( ready ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void execute ( final WorkNode node ) { </a> 0
<a> executor . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> try { </a> 0
<a> node . getCallback ( ) . run ( ) ; </a> 0
<a> } finally { </a> 0
<a> finishItemAndStartNew ( node ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private class WorkNode implements WorkItem { </a> 0
<a> private final Runnable callback ; </a> 0
<a> private WorkNode next ; </a> 0
<a> private WorkNode prev ; </a> 0
<a> private boolean isRunning ; </a> 0
<a> WorkNode ( Runnable callback ) { </a> 0
<a> this . callback = callback ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean cancel ( ) { </a> 0
<a> synchronized ( workLock ) { </a> 0
<a> if ( ! isRunning ( ) ) { </a> 0
<a> pendingJobs = removeFromList ( pendingJobs ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void moveToFront ( ) { </a> 0
<a> synchronized ( workLock ) { </a> 0
<a> if ( ! isRunning ( ) ) { </a> 0
<a> pendingJobs = removeFromList ( pendingJobs ) ; </a> 0
<a> pendingJobs = addToList ( pendingJobs , true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isRunning ( ) { </a> 0
<a> return isRunning ; </a> 0
<a> } </a> 0
<a> Runnable getCallback ( ) { </a> 0
<a> return callback ; </a> 0
<a> } </a> 0
<a> WorkNode getNext ( ) { </a> 0
<a> return next ; </a> 0
<a> } </a> 0
<a> void setIsRunning ( boolean isRunning ) { </a> 0
<a> this . isRunning = isRunning ; </a> 0
<a> } </a> 0
<a> WorkNode addToList ( WorkNode list , boolean addToFront ) { </a> 0
<a> assert next == null ; </a> 0
<a> assert prev == null ; </a> 0
<a> if ( list == null ) { </a> 0
<a> list = next = prev = this ; </a> 0
<a> } else { </a> 0
<a> next = list ; </a> 0
<a> prev = list . prev ; </a> 0
<a> next . prev = prev . next = this ; </a> 0
<a> } </a> 0
<a> return addToFront ? this : list ; </a> 0
<a> } </a> 0
<a> WorkNode removeFromList ( WorkNode list ) { </a> 0
<a> assert next != null ; </a> 0
<a> assert prev != null ; </a> 0
<a> if ( list == this ) { </a> 0
<a> if ( next == this ) { </a> 0
<a> list = null ; </a> 0
<a> } else { </a> 0
<a> list = next ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> next . prev = prev ; </a> 0
<a> prev . next = next ; </a> 0
<a> next = prev = null ; </a> 0
<a> return list ; </a> 0
<a> } </a> 0
<a> void verify ( boolean shouldBeRunning ) { </a> 0
<a> assert prev . next == this ; </a> 0
<a> assert next . prev == this ; </a> 0
<a> assert isRunning ( ) == shouldBeRunning ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> interface WorkItem { </a> 0
<a> boolean cancel ( ) ; </a> 0
<a> boolean isRunning ( ) ; </a> 0
<a> void moveToFront ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . test . AndroidTestCase ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . List ; </a> 0
<a> public final class AccessTokenTests extends AndroidTestCase { </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testEmptyToken ( ) { </a> 0
<a> List < String > permissions = Utility . arrayList ( ) ; </a> 0
<a> AccessToken token = AccessToken . createEmptyToken ( permissions ) ; </a> 0
<a> TestUtils . assertSamePermissions ( permissions , token ) ; </a> 0
<a> assertEquals ( "" , token . getToken ( ) ) ; </a> 0
<a> assertTrue ( token . isInvalid ( ) ) ; </a> 0
<a> assertTrue ( token . getExpires ( ) . before ( new Date ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testEmptyTokenWithPermissions ( ) { </a> 0
<a> List < String > permissions = Utility . arrayList ( "stream_publish" ) ; </a> 0
<a> AccessToken token = AccessToken . createEmptyToken ( permissions ) ; </a> 0
<a> TestUtils . assertSamePermissions ( permissions , token ) ; </a> 0
<a> assertEquals ( "" , token . getToken ( ) ) ; </a> 0
<a> assertTrue ( token . isInvalid ( ) ) ; </a> 0
<a> assertTrue ( token . getExpires ( ) . before ( new Date ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testFromDialog ( ) { </a> 0
<a> List < String > permissions = Utility . arrayList ( "stream_publish" , "go_outside_and_play" ) ; </a> 0
<a> String token = "AnImaginaryTokenValue" ; </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putString ( "access_token" , token ) ; </a> 0
<a> bundle . putString ( "expires_in" , "60" ) ; </a> 0
<a> AccessToken accessToken = AccessToken . createFromWebBundle ( permissions , bundle , AccessTokenSource . WEB_VIEW ) ; </a> 0
<a> TestUtils . assertSamePermissions ( permissions , accessToken ) ; </a> 0
<a> assertEquals ( token , accessToken . getToken ( ) ) ; </a> 0
<a> assertEquals ( AccessTokenSource . WEB_VIEW , accessToken . getSource ( ) ) ; </a> 0
<a> assertTrue ( ! accessToken . isInvalid ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testFromSSOWithExpiresString ( ) { </a> 0
<a> List < String > permissions = Utility . arrayList ( "stream_publish" , "go_outside_and_play" ) ; </a> 0
<a> String token = "AnImaginaryTokenValue" ; </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . putExtra ( "access_token" , token ) ; </a> 0
<a> intent . putExtra ( "expires_in" , "60" ) ; </a> 0
<a> intent . putExtra ( "extra_extra" , "Something unrelated" ) ; </a> 0
<a> AccessToken accessToken = AccessToken </a> 0
<a> . createFromWebBundle ( permissions , intent . getExtras ( ) , AccessTokenSource . FACEBOOK_APPLICATION_WEB ) ; </a> 0
<a> TestUtils . assertSamePermissions ( permissions , accessToken ) ; </a> 0
<a> assertEquals ( token , accessToken . getToken ( ) ) ; </a> 0
<a> assertEquals ( AccessTokenSource . FACEBOOK_APPLICATION_WEB , accessToken . getSource ( ) ) ; </a> 0
<a> assertTrue ( ! accessToken . isInvalid ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testFromSSOWithExpiresLong ( ) { </a> 0
<a> List < String > permissions = Utility . arrayList ( "stream_publish" , "go_outside_and_play" ) ; </a> 0
<a> String token = "AnImaginaryTokenValue" ; </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . putExtra ( "access_token" , token ) ; </a> 0
<a> intent . putExtra ( "expires_in" , 60L ) ; </a> 0
<a> intent . putExtra ( "extra_extra" , "Something unrelated" ) ; </a> 0
<a> AccessToken accessToken = AccessToken </a> 0
<a> . createFromWebBundle ( permissions , intent . getExtras ( ) , AccessTokenSource . FACEBOOK_APPLICATION_WEB ) ; </a> 0
<a> TestUtils . assertSamePermissions ( permissions , accessToken ) ; </a> 0
<a> assertEquals ( token , accessToken . getToken ( ) ) ; </a> 0
<a> assertEquals ( AccessTokenSource . FACEBOOK_APPLICATION_WEB , accessToken . getSource ( ) ) ; </a> 0
<a> assertTrue ( ! accessToken . isInvalid ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testFromNativeLogin ( ) { </a> 0
<a> ArrayList < String > permissions = Utility . arrayList ( "stream_publish" , "go_outside_and_play" ) ; </a> 0
<a> String token = "AnImaginaryTokenValue" ; </a> 0
<a> long nowSeconds = new Date ( ) . getTime ( ) / 1000 ; </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . putExtra ( NativeProtocol . EXTRA_ACCESS_TOKEN , token ) ; </a> 0
<a> intent . putExtra ( NativeProtocol . EXTRA_EXPIRES_SECONDS_SINCE_EPOCH , nowSeconds + 60L ) ; </a> 0
<a> intent . putExtra ( NativeProtocol . EXTRA_PERMISSIONS , permissions ) ; </a> 0
<a> AccessToken accessToken = AccessToken . createFromNativeLogin ( </a> 0
<a> intent . getExtras ( ) , AccessTokenSource . FACEBOOK_APPLICATION_NATIVE ) ; </a> 0
<a> TestUtils . assertSamePermissions ( permissions , accessToken ) ; </a> 0
<a> assertEquals ( token , accessToken . getToken ( ) ) ; </a> 0
<a> assertEquals ( AccessTokenSource . FACEBOOK_APPLICATION_NATIVE , accessToken . getSource ( ) ) ; </a> 0
<a> assertTrue ( ! accessToken . isInvalid ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCacheRoundtrip ( ) { </a> 0
<a> ArrayList < String > permissions = Utility . arrayList ( "stream_publish" , "go_outside_and_play" ) ; </a> 0
<a> String token = "AnImaginaryTokenValue" ; </a> 0
<a> Date later = TestUtils . nowPlusSeconds ( 60 ) ; </a> 0
<a> Date earlier = TestUtils . nowPlusSeconds ( - 60 ) ; </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> TokenCachingStrategy . putToken ( bundle , token ) ; </a> 0
<a> TokenCachingStrategy . putExpirationDate ( bundle , later ) ; </a> 0
<a> TokenCachingStrategy . putSource ( bundle , AccessTokenSource . FACEBOOK_APPLICATION_WEB ) ; </a> 0
<a> TokenCachingStrategy . putLastRefreshDate ( bundle , earlier ) ; </a> 0
<a> TokenCachingStrategy . putPermissions ( bundle , permissions ) ; </a> 0
<a> AccessToken accessToken = AccessToken . createFromCache ( bundle ) ; </a> 0
<a> TestUtils . assertSamePermissions ( permissions , accessToken ) ; </a> 0
<a> assertEquals ( token , accessToken . getToken ( ) ) ; </a> 0
<a> assertEquals ( AccessTokenSource . FACEBOOK_APPLICATION_WEB , accessToken . getSource ( ) ) ; </a> 0
<a> assertTrue ( ! accessToken . isInvalid ( ) ) ; </a> 0
<a> Bundle cache = accessToken . toCacheBundle ( ) ; </a> 0
<a> TestUtils . assertEqualContents ( bundle , cache ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCachePutGet ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> for ( String token : new String [ ] { "" , "A completely random token value" } ) { </a> 0
<a> TokenCachingStrategy . putToken ( bundle , token ) ; </a> 0
<a> assertEquals ( token , TokenCachingStrategy . getToken ( bundle ) ) ; </a> 0
<a> } </a> 0
<a> for ( Date date : new Date [ ] { new Date ( 42 ) , new Date ( ) } ) { </a> 0
<a> TokenCachingStrategy . putExpirationDate ( bundle , date ) ; </a> 0
<a> assertEquals ( date , TokenCachingStrategy . getExpirationDate ( bundle ) ) ; </a> 0
<a> TokenCachingStrategy . putLastRefreshDate ( bundle , date ) ; </a> 0
<a> assertEquals ( date , TokenCachingStrategy . getLastRefreshDate ( bundle ) ) ; </a> 0
<a> } </a> 0
<a> for ( long milliseconds : new long [ ] { 0 , - 1 , System . currentTimeMillis ( ) } ) { </a> 0
<a> TokenCachingStrategy . putExpirationMilliseconds ( bundle , milliseconds ) ; </a> 0
<a> assertEquals ( milliseconds , TokenCachingStrategy . getExpirationMilliseconds ( bundle ) ) ; </a> 0
<a> TokenCachingStrategy . putLastRefreshMilliseconds ( bundle , milliseconds ) ; </a> 0
<a> assertEquals ( milliseconds , TokenCachingStrategy . getLastRefreshMilliseconds ( bundle ) ) ; </a> 0
<a> } </a> 0
<a> for ( AccessTokenSource source : AccessTokenSource . values ( ) ) { </a> 0
<a> TokenCachingStrategy . putSource ( bundle , source ) ; </a> 0
<a> assertEquals ( source , TokenCachingStrategy . getSource ( bundle ) ) ; </a> 0
<a> } </a> 0
<a> List < String > normalList = Arrays . asList ( "" , "Another completely random token value" ) ; </a> 0
<a> List < String > emptyList = Arrays . asList ( ) ; </a> 0
<a> ArrayList < String > normalArrayList = new ArrayList < String > ( normalList ) ; </a> 0
<a> ArrayList < String > emptyArrayList = new ArrayList < String > ( ) ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> List < List < String > > permissionLists = Arrays </a> 0
<a> . asList ( normalList , emptyList , normalArrayList , emptyArrayList ) ; </a> 0
<a> for ( List < String > list : permissionLists ) { </a> 0
<a> TokenCachingStrategy . putPermissions ( bundle , list ) ; </a> 0
<a> TestUtils . assertSamePermissions ( list , TokenCachingStrategy . getPermissions ( bundle ) ) ; </a> 0
<a> } </a> 0
<a> normalArrayList . add ( null ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testBasicSerialization ( ) throws IOException { </a> 0
<a> AccessToken accessToken = AccessToken . createFromString ( "a token" , </a> 0
<a> Arrays . asList ( "permission_1" , "permission_2" ) , AccessTokenSource . WEB_VIEW ) ; </a> 0
<a> AccessToken res = TestUtils . serializeAndUnserialize ( accessToken ) ; </a> 0
<a> assertEquals ( accessToken . getPermissions ( ) , res . getPermissions ( ) ) ; </a> 0
<a> assertEquals ( accessToken . getToken ( ) , res . getToken ( ) ) ; </a> 0
<a> assertEquals ( accessToken . getSource ( ) , res . getSource ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testPermissionsAreImmutable ( ) { </a> 0
<a> List < String > permissions = Arrays . asList ( "go to Jail" , "do not pass Go" ) ; </a> 0
<a> AccessToken accessToken = new AccessToken ( "some token" , new Date ( ) , permissions , </a> 0
<a> AccessTokenSource . FACEBOOK_APPLICATION_WEB , new Date ( ) ) ; </a> 0
<a> permissions = accessToken . getPermissions ( ) ; </a> 0
<a> try { </a> 0
<a> permissions . add ( "can't touch this" ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( UnsupportedOperationException ex ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreateFromExistingTokenDefaults ( ) { </a> 0
<a> final String token = "A token of my esteem" ; </a> 0
<a> AccessToken accessToken = AccessToken . createFromExistingAccessToken ( token , null , null , null , null ) ; </a> 0
<a> assertEquals ( token , accessToken . getToken ( ) ) ; </a> 0
<a> assertEquals ( new Date ( Long . MAX_VALUE ) , accessToken . getExpires ( ) ) ; </a> 0
<a> assertEquals ( AccessTokenSource . FACEBOOK_APPLICATION_WEB , accessToken . getSource ( ) ) ; </a> 0
<a> assertEquals ( 0 , accessToken . getPermissions ( ) . size ( ) ) ; </a> 0
<a> long delta = accessToken . getLastRefresh ( ) . getTime ( ) - new Date ( ) . getTime ( ) ; </a> 0
<a> assertTrue ( delta < 1000 ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreateFromExistingToken ( ) { </a> 0
<a> final String token = "A token of my esteem" ; </a> 0
<a> final List < String > permissions = Arrays . asList ( "walk" , "chew gum" ) ; </a> 0
<a> final Date expires = new Date ( 2025 , 5 , 3 ) ; </a> 0
<a> final Date lastRefresh = new Date ( 2023 , 8 , 15 ) ; </a> 0
<a> final AccessTokenSource source = AccessTokenSource . WEB_VIEW ; </a> 0
<a> AccessToken accessToken = AccessToken </a> 0
<a> . createFromExistingAccessToken ( token , expires , lastRefresh , source , permissions ) ; </a> 0
<a> assertEquals ( token , accessToken . getToken ( ) ) ; </a> 0
<a> assertEquals ( expires , accessToken . getExpires ( ) ) ; </a> 0
<a> assertEquals ( lastRefresh , accessToken . getLastRefresh ( ) ) ; </a> 0
<a> assertEquals ( source , accessToken . getSource ( ) ) ; </a> 0
<a> assertEquals ( permissions , accessToken . getPermissions ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import com . facebook . model . GraphPlace ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import java . net . HttpURLConnection ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class AsyncRequestTests extends FacebookTestCase { </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanLaunchAsyncRequestFromUiThread ( ) { </a> 0
<a> Request request = Request . newPostRequest ( null , "me/feeds" , null , null ) ; </a> 0
<a> try { </a> 0
<a> TestRequestAsyncTask task = createAsyncTaskOnUiThread ( request ) ; </a> 0
<a> assertNotNull ( task ) ; </a> 0
<a> } catch ( Throwable throwable ) { </a> 0
<a> assertNull ( throwable ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteWithNullRequestsThrows ( ) throws Exception { </a> 0
<a> try { </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( ( Request [ ] ) null ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccessOrRethrow ( 1 ) ; </a> 0
<a> fail ( "expected NullPointerException" ) ; </a> 0
<a> } catch ( NullPointerException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteBatchWithZeroRequestsThrows ( ) throws Exception { </a> 0
<a> try { </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( new Request [ ] { } ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccessOrRethrow ( 1 ) ; </a> 0
<a> fail ( "expected IllegalArgumentException" ) ; </a> 0
<a> } catch ( IllegalArgumentException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteBatchWithNullRequestThrows ( ) throws Exception { </a> 0
<a> try { </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( new Request [ ] { null } ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccessOrRethrow ( 1 ) ; </a> 0
<a> fail ( "expected NullPointerException" ) ; </a> 0
<a> } catch ( NullPointerException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteSingleGet ( ) { </a> 0
<a> Request request = new Request ( null , "TourEiffel" , null , null , new ExpectSuccessCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> protected void performAsserts ( Response response ) { </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> GraphPlace graphPlace = response . getGraphObjectAs ( GraphPlace . class ) ; </a> 0
<a> assertEquals ( "Paris" , graphPlace . getLocation ( ) . getCity ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( request ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccess ( 2 ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteSingleGetUsingHttpURLConnection ( ) { </a> 0
<a> Request request = new Request ( null , "TourEiffel" , null , null , new ExpectSuccessCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> protected void performAsserts ( Response response ) { </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> GraphPlace graphPlace = response . getGraphObjectAs ( GraphPlace . class ) ; </a> 0
<a> assertEquals ( "Paris" , graphPlace . getLocation ( ) . getCity ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> HttpURLConnection connection = Request . toHttpConnection ( request ) ; </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( connection , Arrays . asList ( new Request [ ] { request } ) ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccess ( 2 ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteSingleGetFailureCase ( ) { </a> 0
<a> Request request = new Request ( null , "-1" , null , null , new ExpectFailureCallback ( ) ) ; </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( request ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccess ( 2 ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testBatchWithoutAppIDIsError ( ) throws Throwable { </a> 0
<a> Request request1 = new Request ( null , "TourEiffel" , null , null , new ExpectFailureCallback ( ) ) ; </a> 0
<a> Request request2 = new Request ( null , "SpaceNeedle" , null , null , new ExpectFailureCallback ( ) ) ; </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( request1 , request2 ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccessOrRethrow ( 3 ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testMixedSuccessAndFailure ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> final int NUM_REQUESTS = 8 ; </a> 0
<a> Request [ ] requests = new Request [ NUM_REQUESTS ] ; </a> 0
<a> for ( int i = 0 ; i < NUM_REQUESTS ; ++ i ) { </a> 0
<a> boolean shouldSucceed = ( i % 2 ) == 1 ; </a> 0
<a> if ( shouldSucceed ) { </a> 0
<a> requests [ i ] = new Request ( session , "me" , null , null , new ExpectSuccessCallback ( ) ) ; </a> 0
<a> } else { </a> 0
<a> requests [ i ] = new Request ( session , "-1" , null , null , new ExpectFailureCallback ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( requests ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccess ( NUM_REQUESTS + 1 ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testStaticExecuteMeAsync ( ) { </a> 0
<a> final TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> class MeCallback extends ExpectSuccessCallback implements Request . GraphUserCallback { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( GraphUser me , Response response ) { </a> 0
<a> assertNotNull ( me ) ; </a> 0
<a> assertEquals ( session . getTestUserId ( ) , me . getId ( ) ) ; </a> 0
<a> RequestTests . validateMeResponse ( session , response ) ; </a> 0
<a> onCompleted ( response ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> runOnBlockerThread ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> Request . executeMeRequestAsync ( session , new MeCallback ( ) ) ; </a> 0
<a> } </a> 0
<a> } , false ) ; </a> 0
<a> waitAndAssertSuccess ( 1 ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testStaticExecuteMyFriendsAsync ( ) { </a> 0
<a> final TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> class FriendsCallback extends ExpectSuccessCallback implements Request . GraphUserListCallback { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( List < GraphUser > friends , Response response ) { </a> 0
<a> assertNotNull ( friends ) ; </a> 0
<a> RequestTests . validateMyFriendsResponse ( session , response ) ; </a> 0
<a> onCompleted ( response ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> runOnBlockerThread ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> Request . executeMyFriendsRequestAsync ( session , new FriendsCallback ( ) ) ; </a> 0
<a> } </a> 0
<a> } , false ) ; </a> 0
<a> waitAndAssertSuccess ( 1 ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testBatchUploadPhoto ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUserAndPermissions ( null , "user_photos" ) ; </a> 0
<a> final int image1Size = 120 ; </a> 0
<a> final int image2Size = 150 ; </a> 0
<a> Bitmap bitmap1 = createTestBitmap ( image1Size ) ; </a> 0
<a> Bitmap bitmap2 = createTestBitmap ( image2Size ) ; </a> 0
<a> Request uploadRequest1 = Request . newUploadPhotoRequest ( session , bitmap1 , null ) ; </a> 0
<a> uploadRequest1 . setBatchEntryName ( "uploadRequest1" ) ; </a> 0
<a> Request uploadRequest2 = Request . newUploadPhotoRequest ( session , bitmap2 , null ) ; </a> 0
<a> uploadRequest2 . setBatchEntryName ( "uploadRequest2" ) ; </a> 0
<a> Request getRequest1 = new Request ( session , "{result=uploadRequest1:$.id}" , null , null , </a> 0
<a> new ExpectSuccessCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> protected void performAsserts ( Response response ) { </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> GraphObject retrievedPhoto = response . getGraphObject ( ) ; </a> 0
<a> assertNotNull ( retrievedPhoto ) ; </a> 0
<a> assertEquals ( image1Size , retrievedPhoto . getProperty ( "width" ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Request getRequest2 = new Request ( session , "{result=uploadRequest2:$.id}" , null , null , </a> 0
<a> new ExpectSuccessCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> protected void performAsserts ( Response response ) { </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> GraphObject retrievedPhoto = response . getGraphObject ( ) ; </a> 0
<a> assertNotNull ( retrievedPhoto ) ; </a> 0
<a> assertEquals ( image2Size , retrievedPhoto . getProperty ( "width" ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( uploadRequest1 , uploadRequest2 , getRequest1 , getRequest2 ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccess ( 3 ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testShortTimeoutCausesFailure ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Request request = new Request ( session , "me/likes" , null , null , new ExpectFailureCallback ( ) ) ; </a> 0
<a> RequestBatch requestBatch = new RequestBatch ( request ) ; </a> 0
<a> requestBatch . setTimeout ( 1 ) ; </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( requestBatch ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccess ( 2 ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testLongTimeoutAllowsSuccess ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Request request = new Request ( session , "me" , null , null , new ExpectSuccessCallback ( ) ) ; </a> 0
<a> RequestBatch requestBatch = new RequestBatch ( request ) ; </a> 0
<a> requestBatch . setTimeout ( 10000 ) ; </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( requestBatch ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccess ( 2 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . content . pm . PackageManager ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import com . facebook . model . GraphMultiResult ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import com . facebook . model . GraphObjectList ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import java . io . * ; </a> 0
<a> import java . util . * ; </a> 0
<a> public class AuthorizationClientTests extends FacebookTestCase { </a> 0
<a> private static final String ACCESS_TOKEN = "An access token" ; </a> 0
<a> private static final long EXPIRES_IN_DELTA = 3600 * 24 * 60 ; </a> 0
<a> private static final ArrayList < String > PERMISSIONS = new ArrayList < String > ( </a> 0
<a> Arrays . asList ( "go outside" , "come back in" ) ) ; </a> 0
<a> private static final String ERROR_MESSAGE = "This is bad!" ; </a> 0
<a> class MockAuthorizationClient extends AuthorizationClient { </a> 0
<a> Result result ; </a> 0
<a> boolean triedNextHandler = false ; </a> 0
<a> MockAuthorizationClient ( ) { </a> 0
<a> setContext ( getActivity ( ) ) ; </a> 0
<a> } </a> 0
<a> AuthorizationClient . AuthorizationRequest getRequest ( ) { </a> 0
<a> return pendingRequest ; </a> 0
<a> } </a> 0
<a> void setRequest ( AuthorizationClient . AuthorizationRequest request ) { </a> 0
<a> pendingRequest = request ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void complete ( Result result ) { </a> 0
<a> this . result = result ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void tryNextHandler ( ) { </a> 0
<a> triedNextHandler = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> AuthorizationClient . AuthorizationRequest createRequest ( ) { </a> 0
<a> Session . AuthorizationRequest request = new Session . AuthorizationRequest ( getActivity ( ) ) ; </a> 0
<a> request . setPermissions ( PERMISSIONS ) ; </a> 0
<a> return request . getAuthorizationClientRequest ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testWebViewHandlesSuccess ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putString ( "access_token" , ACCESS_TOKEN ) ; </a> 0
<a> bundle . putString ( "expires_in" , String . format ( "%d" , EXPIRES_IN_DELTA ) ) ; </a> 0
<a> bundle . putString ( "code" , "Something else" ) ; </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . WebViewAuthHandler handler = client . new WebViewAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . onWebDialogComplete ( request , bundle , null ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . SUCCESS , client . result . code ) ; </a> 0
<a> AccessToken token = client . result . token ; </a> 0
<a> assertNotNull ( token ) ; </a> 0
<a> assertEquals ( ACCESS_TOKEN , token . getToken ( ) ) ; </a> 0
<a> assertDateDiffersWithinDelta ( new Date ( ) , token . getExpires ( ) , EXPIRES_IN_DELTA * 1000 , 1000 ) ; </a> 0
<a> assertEquals ( PERMISSIONS , token . getPermissions ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testWebViewHandlesCancel ( ) { </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . WebViewAuthHandler handler = client . new WebViewAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . onWebDialogComplete ( request , null , new FacebookOperationCanceledException ( ) ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . CANCEL , client . result . code ) ; </a> 0
<a> assertNull ( client . result . token ) ; </a> 0
<a> assertNotNull ( client . result . errorMessage ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testWebViewHandlesError ( ) { </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . WebViewAuthHandler handler = client . new WebViewAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . onWebDialogComplete ( request , null , new FacebookException ( ERROR_MESSAGE ) ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . ERROR , client . result . code ) ; </a> 0
<a> assertNull ( client . result . token ) ; </a> 0
<a> assertNotNull ( client . result . errorMessage ) ; </a> 0
<a> assertEquals ( client . result . errorMessage , ERROR_MESSAGE ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testWebViewChecksInternetPermission ( ) { </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) { </a> 0
<a> @ Override </a> 0
<a> int checkPermission ( String permission ) { </a> 0
<a> return PackageManager . PERMISSION_DENIED ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> AuthorizationClient . WebViewAuthHandler handler = client . new WebViewAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . onWebDialogComplete ( request , null , new FacebookException ( ERROR_MESSAGE ) ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . ERROR , client . result . code ) ; </a> 0
<a> assertNull ( client . result . token ) ; </a> 0
<a> assertNotNull ( client . result . errorMessage ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testGetTokenHandlesSuccessWithAllPermissions ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putStringArrayList ( NativeProtocol . EXTRA_PERMISSIONS , PERMISSIONS ) ; </a> 0
<a> bundle . putLong ( NativeProtocol . EXTRA_EXPIRES_SECONDS_SINCE_EPOCH , new Date ( ) . getTime ( ) / 1000 + EXPIRES_IN_DELTA ) ; </a> 0
<a> bundle . putString ( NativeProtocol . EXTRA_ACCESS_TOKEN , ACCESS_TOKEN ) ; </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . GetTokenAuthHandler handler = client . new GetTokenAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . getTokenCompleted ( request , bundle ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . SUCCESS , client . result . code ) ; </a> 0
<a> AccessToken token = client . result . token ; </a> 0
<a> assertNotNull ( token ) ; </a> 0
<a> assertEquals ( ACCESS_TOKEN , token . getToken ( ) ) ; </a> 0
<a> assertDateDiffersWithinDelta ( new Date ( ) , token . getExpires ( ) , EXPIRES_IN_DELTA * 1000 , 1000 ) ; </a> 0
<a> assertEquals ( PERMISSIONS , token . getPermissions ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testGetTokenHandlesSuccessWithSomePermissions ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putStringArrayList ( NativeProtocol . EXTRA_PERMISSIONS , new ArrayList < String > ( Arrays . asList ( "go outside" ) ) ) ; </a> 0
<a> bundle . putLong ( NativeProtocol . EXTRA_EXPIRES_SECONDS_SINCE_EPOCH , new Date ( ) . getTime ( ) / 1000 + EXPIRES_IN_DELTA ) ; </a> 0
<a> bundle . putString ( NativeProtocol . EXTRA_ACCESS_TOKEN , ACCESS_TOKEN ) ; </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . GetTokenAuthHandler handler = client . new GetTokenAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> assertEquals ( PERMISSIONS . size ( ) , request . getPermissions ( ) . size ( ) ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . getTokenCompleted ( request , bundle ) ; </a> 0
<a> assertNull ( client . result ) ; </a> 0
<a> assertTrue ( client . triedNextHandler ) ; </a> 0
<a> assertEquals ( 1 , request . getPermissions ( ) . size ( ) ) ; </a> 0
<a> assertTrue ( request . getPermissions ( ) . contains ( "come back in" ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testGetTokenHandlesNoResult ( ) { </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . GetTokenAuthHandler handler = client . new GetTokenAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> assertEquals ( PERMISSIONS . size ( ) , request . getPermissions ( ) . size ( ) ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . getTokenCompleted ( request , null ) ; </a> 0
<a> assertNull ( client . result ) ; </a> 0
<a> assertTrue ( client . triedNextHandler ) ; </a> 0
<a> assertEquals ( PERMISSIONS . size ( ) , request . getPermissions ( ) . size ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testLoginDialogHandlesSuccess ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putStringArrayList ( NativeProtocol . EXTRA_PERMISSIONS , PERMISSIONS ) ; </a> 0
<a> bundle . putLong ( NativeProtocol . EXTRA_EXPIRES_SECONDS_SINCE_EPOCH , new Date ( ) . getTime ( ) / 1000 + EXPIRES_IN_DELTA ) ; </a> 0
<a> bundle . putString ( NativeProtocol . EXTRA_ACCESS_TOKEN , ACCESS_TOKEN ) ; </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . putExtras ( bundle ) ; </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . KatanaLoginDialogAuthHandler handler = client . new KatanaLoginDialogAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . onActivityResult ( 0 , Activity . RESULT_OK , intent ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . SUCCESS , client . result . code ) ; </a> 0
<a> AccessToken token = client . result . token ; </a> 0
<a> assertNotNull ( token ) ; </a> 0
<a> assertEquals ( ACCESS_TOKEN , token . getToken ( ) ) ; </a> 0
<a> assertDateDiffersWithinDelta ( new Date ( ) , token . getExpires ( ) , EXPIRES_IN_DELTA * 1000 , 1000 ) ; </a> 0
<a> assertEquals ( PERMISSIONS , token . getPermissions ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testLoginDialogHandlesCancel ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putString ( NativeProtocol . STATUS_ERROR_DESCRIPTION , ERROR_MESSAGE ) ; </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . putExtras ( bundle ) ; </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . KatanaLoginDialogAuthHandler handler = client . new KatanaLoginDialogAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . onActivityResult ( 0 , Activity . RESULT_CANCELED , intent ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . CANCEL , client . result . code ) ; </a> 0
<a> AccessToken token = client . result . token ; </a> 0
<a> assertNull ( token ) ; </a> 0
<a> assertNotNull ( client . result . errorMessage ) ; </a> 0
<a> assertEquals ( ERROR_MESSAGE , client . result . errorMessage ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testLoginDialogHandlesError ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putString ( NativeProtocol . STATUS_ERROR_TYPE , ERROR_MESSAGE ) ; </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . putExtras ( bundle ) ; </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . KatanaLoginDialogAuthHandler handler = client . new KatanaLoginDialogAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . onActivityResult ( 0 , Activity . RESULT_OK , intent ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . ERROR , client . result . code ) ; </a> 0
<a> AccessToken token = client . result . token ; </a> 0
<a> assertNull ( token ) ; </a> 0
<a> assertNotNull ( client . result . errorMessage ) ; </a> 0
<a> assertEquals ( ERROR_MESSAGE , client . result . errorMessage ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testLoginDialogHandlesDisabled ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putInt ( NativeProtocol . EXTRA_PROTOCOL_VERSION , NativeProtocol . PROTOCOL_VERSION_20121101 ) ; </a> 0
<a> bundle . putString ( NativeProtocol . STATUS_ERROR_TYPE , NativeProtocol . ERROR_SERVICE_DISABLED ) ; </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . putExtras ( bundle ) ; </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . KatanaLoginDialogAuthHandler handler = client . new KatanaLoginDialogAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . onActivityResult ( 0 , Activity . RESULT_OK , intent ) ; </a> 0
<a> assertNull ( client . result ) ; </a> 0
<a> assertTrue ( client . triedNextHandler ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testProxyAuthHandlesSuccess ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putLong ( AccessToken . EXPIRES_IN_KEY , EXPIRES_IN_DELTA ) ; </a> 0
<a> bundle . putString ( AccessToken . ACCESS_TOKEN_KEY , ACCESS_TOKEN ) ; </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . putExtras ( bundle ) ; </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . KatanaProxyAuthHandler handler = client . new KatanaProxyAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . onActivityResult ( 0 , Activity . RESULT_OK , intent ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . SUCCESS , client . result . code ) ; </a> 0
<a> AccessToken token = client . result . token ; </a> 0
<a> assertNotNull ( token ) ; </a> 0
<a> assertEquals ( ACCESS_TOKEN , token . getToken ( ) ) ; </a> 0
<a> assertDateDiffersWithinDelta ( new Date ( ) , token . getExpires ( ) , EXPIRES_IN_DELTA * 1000 , 1000 ) ; </a> 0
<a> assertEquals ( PERMISSIONS , token . getPermissions ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testProxyAuthHandlesCancel ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putString ( "error" , ERROR_MESSAGE ) ; </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . putExtras ( bundle ) ; </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . KatanaProxyAuthHandler handler = client . new KatanaProxyAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . onActivityResult ( 0 , Activity . RESULT_CANCELED , intent ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . CANCEL , client . result . code ) ; </a> 0
<a> assertNull ( client . result . token ) ; </a> 0
<a> assertNotNull ( client . result . errorMessage ) ; </a> 0
<a> assertTrue ( client . result . errorMessage . contains ( ERROR_MESSAGE ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testProxyAuthHandlesCancelErrorMessage ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putString ( "error" , "access_denied" ) ; </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . putExtras ( bundle ) ; </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . KatanaProxyAuthHandler handler = client . new KatanaProxyAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . onActivityResult ( 0 , Activity . RESULT_CANCELED , intent ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . CANCEL , client . result . code ) ; </a> 0
<a> assertNull ( client . result . token ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testProxyAuthHandlesDisabled ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putString ( "error" , "service_disabled" ) ; </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . putExtras ( bundle ) ; </a> 0
<a> MockAuthorizationClient client = new MockAuthorizationClient ( ) ; </a> 0
<a> AuthorizationClient . KatanaProxyAuthHandler handler = client . new KatanaProxyAuthHandler ( ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createRequest ( ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> handler . onActivityResult ( 0 , Activity . RESULT_OK , intent ) ; </a> 0
<a> assertNull ( client . result ) ; </a> 0
<a> assertTrue ( client . triedNextHandler ) ; </a> 0
<a> } </a> 0
<a> class MockValidatingAuthorizationClient extends MockAuthorizationClient { </a> 0
<a> private final HashMap < String , String > mapAccessTokenToFbid = new HashMap < String , String > ( ) ; </a> 0
<a> private List < String > permissionsToReport = Arrays . asList ( ) ; </a> 0
<a> private TestBlocker blocker ; </a> 0
<a> public MockValidatingAuthorizationClient ( TestBlocker blocker ) { </a> 0
<a> this . blocker = blocker ; </a> 0
<a> } </a> 0
<a> public void addAccessTokenToFbidMapping ( String accessToken , String fbid ) { </a> 0
<a> mapAccessTokenToFbid . put ( accessToken , fbid ) ; </a> 0
<a> } </a> 0
<a> public void addAccessTokenToFbidMapping ( AccessToken accessToken , String fbid ) { </a> 0
<a> mapAccessTokenToFbid . put ( accessToken . getToken ( ) , fbid ) ; </a> 0
<a> } </a> 0
<a> public void setPermissionsToReport ( List < String > permissionsToReport ) { </a> 0
<a> this . permissionsToReport = permissionsToReport ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void complete ( Result result ) { </a> 0
<a> super . complete ( result ) ; </a> 0
<a> blocker . signal ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> Request createGetProfileIdRequest ( final String accessToken ) { </a> 0
<a> return new MockRequest ( ) { </a> 0
<a> @ Override </a> 0
<a> public Response createResponse ( ) { </a> 0
<a> String fbid = mapAccessTokenToFbid . get ( accessToken ) ; </a> 0
<a> GraphUser user = GraphObject . Factory . create ( GraphUser . class ) ; </a> 0
<a> user . setId ( fbid ) ; </a> 0
<a> return new Response ( this , null , user , false ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> Request createGetPermissionsRequest ( String accessToken ) { </a> 0
<a> final List < String > permissions = permissionsToReport ; </a> 0
<a> return new MockRequest ( ) { </a> 0
<a> @ Override </a> 0
<a> public Response createResponse ( ) { </a> 0
<a> GraphObject permissionsObject = GraphObject . Factory . create ( ) ; </a> 0
<a> if ( permissions != null ) { </a> 0
<a> for ( String permission : permissions ) { </a> 0
<a> permissionsObject . setProperty ( permission , 1 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> GraphObjectList < GraphObject > data = GraphObject . Factory . createList ( GraphObject . class ) ; </a> 0
<a> data . add ( permissionsObject ) ; </a> 0
<a> GraphMultiResult result = GraphObject . Factory . create ( GraphMultiResult . class ) ; </a> 0
<a> result . setProperty ( "data" , data ) ; </a> 0
<a> return new Response ( this , null , result , false ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> RequestBatch createReauthValidationBatch ( final Result pendingResult ) { </a> 0
<a> RequestBatch batch = super . createReauthValidationBatch ( pendingResult ) ; </a> 0
<a> batch . setCallbackHandler ( blocker . getHandler ( ) ) ; </a> 0
<a> return new MockRequestBatch ( batch ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static final String USER_1_FBID = "user1" ; </a> 0
<a> static final String USER_1_ACCESS_TOKEN = "An access token for user 1" ; </a> 0
<a> static final String USER_2_FBID = "user2" ; </a> 0
<a> static final String USER_2_ACCESS_TOKEN = "An access token for user 2" ; </a> 0
<a> AuthorizationClient . AuthorizationRequest createNewPermissionRequest ( String accessToken ) { </a> 0
<a> Session . NewPermissionsRequest request = new Session . NewPermissionsRequest ( getActivity ( ) , PERMISSIONS ) ; </a> 0
<a> request . setValidateSameFbidAsToken ( accessToken ) ; </a> 0
<a> return request . getAuthorizationClientRequest ( ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testReauthorizationWithSameFbidSucceeds ( ) throws Exception { </a> 0
<a> TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient ( blocker ) ; </a> 0
<a> client . addAccessTokenToFbidMapping ( USER_1_ACCESS_TOKEN , USER_1_FBID ) ; </a> 0
<a> client . addAccessTokenToFbidMapping ( USER_2_ACCESS_TOKEN , USER_2_FBID ) ; </a> 0
<a> client . setPermissionsToReport ( PERMISSIONS ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createNewPermissionRequest ( USER_1_ACCESS_TOKEN ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> AccessToken token = AccessToken . createFromExistingAccessToken ( USER_1_ACCESS_TOKEN , null , null , null , PERMISSIONS ) ; </a> 0
<a> AuthorizationClient . Result result = AuthorizationClient . Result . createTokenResult ( token ) ; </a> 0
<a> client . completeAndValidate ( result ) ; </a> 0
<a> blocker . waitForSignals ( 1 ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . SUCCESS , client . result . code ) ; </a> 0
<a> AccessToken resultToken = client . result . token ; </a> 0
<a> assertNotNull ( resultToken ) ; </a> 0
<a> assertEquals ( USER_1_ACCESS_TOKEN , resultToken . getToken ( ) ) ; </a> 0
<a> assertEquals ( PERMISSIONS , resultToken . getPermissions ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testReauthorizationWithFewerPermissionsSucceeds ( ) throws Exception { </a> 0
<a> TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient ( blocker ) ; </a> 0
<a> client . addAccessTokenToFbidMapping ( USER_1_ACCESS_TOKEN , USER_1_FBID ) ; </a> 0
<a> client . addAccessTokenToFbidMapping ( USER_2_ACCESS_TOKEN , USER_2_FBID ) ; </a> 0
<a> client . setPermissionsToReport ( Arrays . asList ( "go outside" ) ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createNewPermissionRequest ( USER_1_ACCESS_TOKEN ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> AccessToken token = AccessToken . createFromExistingAccessToken ( USER_1_ACCESS_TOKEN , null , null , null , PERMISSIONS ) ; </a> 0
<a> AuthorizationClient . Result result = AuthorizationClient . Result . createTokenResult ( token ) ; </a> 0
<a> client . completeAndValidate ( result ) ; </a> 0
<a> blocker . waitForSignals ( 1 ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . SUCCESS , client . result . code ) ; </a> 0
<a> AccessToken resultToken = client . result . token ; </a> 0
<a> assertNotNull ( resultToken ) ; </a> 0
<a> assertEquals ( USER_1_ACCESS_TOKEN , resultToken . getToken ( ) ) ; </a> 0
<a> assertEquals ( Arrays . asList ( "go outside" ) , resultToken . getPermissions ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testReauthorizationWithDifferentFbidsFails ( ) throws Exception { </a> 0
<a> TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient ( blocker ) ; </a> 0
<a> client . addAccessTokenToFbidMapping ( USER_1_ACCESS_TOKEN , USER_1_FBID ) ; </a> 0
<a> client . addAccessTokenToFbidMapping ( USER_2_ACCESS_TOKEN , USER_2_FBID ) ; </a> 0
<a> client . setPermissionsToReport ( PERMISSIONS ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createNewPermissionRequest ( USER_1_ACCESS_TOKEN ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> AccessToken token = AccessToken . createFromExistingAccessToken ( USER_2_ACCESS_TOKEN , null , null , null , PERMISSIONS ) ; </a> 0
<a> AuthorizationClient . Result result = AuthorizationClient . Result . createTokenResult ( token ) ; </a> 0
<a> client . completeAndValidate ( result ) ; </a> 0
<a> blocker . waitForSignals ( 1 ) ; </a> 0
<a> assertNotNull ( client . result ) ; </a> 0
<a> assertEquals ( AuthorizationClient . Result . Code . ERROR , client . result . code ) ; </a> 0
<a> assertNull ( client . result . token ) ; </a> 0
<a> assertNotNull ( client . result . errorMessage ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testLegacyReauthDoesntValidate ( ) throws Exception { </a> 0
<a> TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> MockValidatingAuthorizationClient client = new MockValidatingAuthorizationClient ( blocker ) ; </a> 0
<a> AuthorizationClient . AuthorizationRequest request = createNewPermissionRequest ( USER_1_ACCESS_TOKEN ) ; </a> 0
<a> request . setIsLegacy ( true ) ; </a> 0
<a> client . setRequest ( request ) ; </a> 0
<a> AccessToken token = AccessToken . createFromExistingAccessToken ( USER_2_ACCESS_TOKEN , null , null , null , PERMISSIONS ) ; </a> 0
<a> AuthorizationClient . Result result = AuthorizationClient . Result . createTokenResult ( token ) ; </a> 0
<a> client . completeAndValidate ( result ) ; </a> 0
<a> AccessToken resultToken = client . result . token ; </a> 0
<a> assertNotNull ( resultToken ) ; </a> 0
<a> assertEquals ( USER_2_ACCESS_TOKEN , resultToken . getToken ( ) ) ; </a> 0
<a> assertEquals ( PERMISSIONS , resultToken . getPermissions ( ) ) ; </a> 0
<a> } </a> 0
<a> static class DoNothingAuthorizationClient extends AuthorizationClient { </a> 0
<a> @ Override </a> 0
<a> boolean tryCurrentHandler ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void testSerialization ( ) throws IOException , ClassNotFoundException { </a> 0
<a> AuthorizationClient client = new DoNothingAuthorizationClient ( ) ; </a> 0
<a> client . setContext ( getActivity ( ) ) ; </a> 0
<a> client . setOnCompletedListener ( new AuthorizationClient . OnCompletedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( AuthorizationClient . Result result ) { </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> client . setBackgroundProcessingListener ( new AuthorizationClient . BackgroundProcessingListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onBackgroundProcessingStarted ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onBackgroundProcessingStopped ( ) { </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> client . authorize ( createRequest ( ) ) ; </a> 0
<a> ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; </a> 0
<a> ObjectOutputStream outputStream = new ObjectOutputStream ( byteArrayOutputStream ) ; </a> 0
<a> outputStream . writeObject ( client ) ; </a> 0
<a> outputStream . close ( ) ; </a> 0
<a> byte [ ] byteArray = byteArrayOutputStream . toByteArray ( ) ; </a> 0
<a> ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream ( byteArray ) ; </a> 0
<a> ObjectInputStream inputStream = new ObjectInputStream ( byteArrayInputStream ) ; </a> 0
<a> Object obj = inputStream . readObject ( ) ; </a> 0
<a> assertNotNull ( obj ) ; </a> 0
<a> assertTrue ( obj instanceof AuthorizationClient ) ; </a> 0
<a> AuthorizationClient resultClient = ( AuthorizationClient ) obj ; </a> 0
<a> assertNull ( resultClient . startActivityDelegate ) ; </a> 0
<a> assertNull ( resultClient . onCompletedListener ) ; </a> 0
<a> assertNull ( resultClient . backgroundProcessingListener ) ; </a> 0
<a> assertNull ( resultClient . context ) ; </a> 0
<a> assertNotNull ( resultClient . currentHandler ) ; </a> 0
<a> assertTrue ( resultClient . currentHandler instanceof AuthorizationClient . GetTokenAuthHandler ) ; </a> 0
<a> assertNotNull ( resultClient . handlersToTry ) ; </a> 0
<a> assertTrue ( resultClient . handlersToTry . size ( ) > 0 ) ; </a> 0
<a> assertNotNull ( resultClient . pendingRequest ) ; </a> 0
<a> assertEquals ( PERMISSIONS , resultClient . pendingRequest . getPermissions ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import com . facebook . model . GraphPlace ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import com . facebook . internal . CacheableRequestBatch ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> public class BatchRequestTests extends FacebookTestCase { </a> 0
<a> protected void setUp ( ) throws Exception { </a> 0
<a> super . setUp ( ) ; </a> 0
<a> Request . setDefaultBatchApplicationId ( null ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreateEmptyRequestBatch ( ) { </a> 0
<a> CacheableRequestBatch batch = new CacheableRequestBatch ( ) ; </a> 0
<a> Request meRequest = Request . newMeRequest ( null , null ) ; </a> 0
<a> assertEquals ( 0 , batch . size ( ) ) ; </a> 0
<a> batch . add ( meRequest ) ; </a> 0
<a> assertEquals ( 1 , batch . size ( ) ) ; </a> 0
<a> assertEquals ( meRequest , batch . get ( 0 ) ) ; </a> 0
<a> String key = "The Key" ; </a> 0
<a> assertNull ( batch . getCacheKeyOverride ( ) ) ; </a> 0
<a> batch . setCacheKeyOverride ( key ) ; </a> 0
<a> assertEquals ( key , batch . getCacheKeyOverride ( ) ) ; </a> 0
<a> assertTrue ( ! batch . getForceRoundTrip ( ) ) ; </a> 0
<a> batch . setForceRoundTrip ( true ) ; </a> 0
<a> assertTrue ( batch . getForceRoundTrip ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreateNonemptyRequestBatch ( ) { </a> 0
<a> Request meRequest = Request . newMeRequest ( null , null ) ; </a> 0
<a> RequestBatch batch = new RequestBatch ( new Request [ ] { meRequest , meRequest } ) ; </a> 0
<a> assertEquals ( 2 , batch . size ( ) ) ; </a> 0
<a> assertEquals ( meRequest , batch . get ( 0 ) ) ; </a> 0
<a> assertEquals ( meRequest , batch . get ( 1 ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testBatchWithoutAppIDIsError ( ) { </a> 0
<a> Request request1 = new Request ( null , "TourEiffel" , null , null , new ExpectFailureCallback ( ) ) ; </a> 0
<a> Request request2 = new Request ( null , "SpaceNeedle" , null , null , new ExpectFailureCallback ( ) ) ; </a> 0
<a> Request . executeBatchAndWait ( request1 , request2 ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteBatchedGets ( ) throws IOException { </a> 0
<a> setBatchApplicationIdForTestApp ( ) ; </a> 0
<a> Request request1 = new Request ( null , "TourEiffel" ) ; </a> 0
<a> Request request2 = new Request ( null , "SpaceNeedle" ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( request1 , request2 ) ; </a> 0
<a> assertEquals ( 2 , responses . size ( ) ) ; </a> 0
<a> assertTrue ( responses . get ( 0 ) . getError ( ) == null ) ; </a> 0
<a> assertTrue ( responses . get ( 1 ) . getError ( ) == null ) ; </a> 0
<a> GraphPlace eiffelTower = responses . get ( 0 ) . getGraphObjectAs ( GraphPlace . class ) ; </a> 0
<a> GraphPlace spaceNeedle = responses . get ( 1 ) . getGraphObjectAs ( GraphPlace . class ) ; </a> 0
<a> assertTrue ( eiffelTower != null ) ; </a> 0
<a> assertTrue ( spaceNeedle != null ) ; </a> 0
<a> assertEquals ( "Paris" , eiffelTower . getLocation ( ) . getCity ( ) ) ; </a> 0
<a> assertEquals ( "Seattle" , spaceNeedle . getLocation ( ) . getCity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testFacebookErrorResponsesCreateErrors ( ) { </a> 0
<a> setBatchApplicationIdForTestApp ( ) ; </a> 0
<a> Request request1 = new Request ( null , "somestringthatshouldneverbeavalidfobjectid" ) ; </a> 0
<a> Request request2 = new Request ( null , "someotherstringthatshouldneverbeavalidfobjectid" ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( request1 , request2 ) ; </a> 0
<a> assertEquals ( 2 , responses . size ( ) ) ; </a> 0
<a> assertTrue ( responses . get ( 0 ) . getError ( ) != null ) ; </a> 0
<a> assertTrue ( responses . get ( 1 ) . getError ( ) != null ) ; </a> 0
<a> FacebookRequestError error = responses . get ( 0 ) . getError ( ) ; </a> 0
<a> assertTrue ( error . getException ( ) instanceof FacebookServiceException ) ; </a> 0
<a> assertTrue ( error . getErrorType ( ) != null ) ; </a> 0
<a> assertTrue ( error . getErrorCode ( ) != FacebookRequestError . INVALID_ERROR_CODE ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testBatchPostStatusUpdate ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> GraphObject statusUpdate1 = createStatusUpdate ( ) ; </a> 0
<a> GraphObject statusUpdate2 = createStatusUpdate ( ) ; </a> 0
<a> Request postRequest1 = Request . newPostRequest ( session , "me/feed" , statusUpdate1 , null ) ; </a> 0
<a> postRequest1 . setBatchEntryName ( "postRequest1" ) ; </a> 0
<a> Request postRequest2 = Request . newPostRequest ( session , "me/feed" , statusUpdate2 , null ) ; </a> 0
<a> postRequest2 . setBatchEntryName ( "postRequest2" ) ; </a> 0
<a> Request getRequest1 = new Request ( session , "{result=postRequest1:$.id}" ) ; </a> 0
<a> Request getRequest2 = new Request ( session , "{result=postRequest2:$.id}" ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( postRequest1 , postRequest2 , getRequest1 , getRequest2 ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 4 , responses . size ( ) ) ; </a> 0
<a> assertNoErrors ( responses ) ; </a> 0
<a> GraphObject retrievedStatusUpdate1 = responses . get ( 2 ) . getGraphObject ( ) ; </a> 0
<a> GraphObject retrievedStatusUpdate2 = responses . get ( 3 ) . getGraphObject ( ) ; </a> 0
<a> assertNotNull ( retrievedStatusUpdate1 ) ; </a> 0
<a> assertNotNull ( retrievedStatusUpdate2 ) ; </a> 0
<a> assertEquals ( statusUpdate1 . getProperty ( "message" ) , retrievedStatusUpdate1 . getProperty ( "message" ) ) ; </a> 0
<a> assertEquals ( statusUpdate2 . getProperty ( "message" ) , retrievedStatusUpdate2 . getProperty ( "message" ) ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testTwoDifferentAccessTokens ( ) { </a> 0
<a> TestSession session1 = openTestSessionWithSharedUser ( ) ; </a> 0
<a> TestSession session2 = openTestSessionWithSharedUser ( SECOND_TEST_USER_TAG ) ; </a> 0
<a> Request request1 = Request . newMeRequest ( session1 , null ) ; </a> 0
<a> Request request2 = Request . newMeRequest ( session2 , null ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( request1 , request2 ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 2 , responses . size ( ) ) ; </a> 0
<a> GraphUser user1 = responses . get ( 0 ) . getGraphObjectAs ( GraphUser . class ) ; </a> 0
<a> GraphUser user2 = responses . get ( 1 ) . getGraphObjectAs ( GraphUser . class ) ; </a> 0
<a> assertNotNull ( user1 ) ; </a> 0
<a> assertNotNull ( user2 ) ; </a> 0
<a> assertFalse ( user1 . getId ( ) . equals ( user2 . getId ( ) ) ) ; </a> 0
<a> assertEquals ( session1 . getTestUserId ( ) , user1 . getId ( ) ) ; </a> 0
<a> assertEquals ( session2 . getTestUserId ( ) , user2 . getId ( ) ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testBatchWithValidSessionAndNoSession ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Request request1 = new Request ( session , "me" ) ; </a> 0
<a> Request request2 = new Request ( null , "zuck" ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( request1 , request2 ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 2 , responses . size ( ) ) ; </a> 0
<a> GraphUser user1 = responses . get ( 0 ) . getGraphObjectAs ( GraphUser . class ) ; </a> 0
<a> GraphUser user2 = responses . get ( 1 ) . getGraphObjectAs ( GraphUser . class ) ; </a> 0
<a> assertNotNull ( user1 ) ; </a> 0
<a> assertNotNull ( user2 ) ; </a> 0
<a> assertFalse ( user1 . getId ( ) . equals ( user2 . getId ( ) ) ) ; </a> 0
<a> assertEquals ( session . getTestUserId ( ) , user1 . getId ( ) ) ; </a> 0
<a> assertEquals ( "4" , user2 . getId ( ) ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testBatchWithNoSessionAndValidSession ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Request request1 = new Request ( null , "zuck" ) ; </a> 0
<a> Request request2 = new Request ( session , "me" ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( request1 , request2 ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 2 , responses . size ( ) ) ; </a> 0
<a> GraphUser user1 = responses . get ( 0 ) . getGraphObjectAs ( GraphUser . class ) ; </a> 0
<a> GraphUser user2 = responses . get ( 1 ) . getGraphObjectAs ( GraphUser . class ) ; </a> 0
<a> assertNotNull ( user1 ) ; </a> 0
<a> assertNotNull ( user2 ) ; </a> 0
<a> assertFalse ( user1 . getId ( ) . equals ( user2 . getId ( ) ) ) ; </a> 0
<a> assertEquals ( "4" , user1 . getId ( ) ) ; </a> 0
<a> assertEquals ( session . getTestUserId ( ) , user2 . getId ( ) ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testBatchWithTwoSessionlessRequestsAndDefaultAppID ( ) { </a> 0
<a> TestSession session = getTestSessionWithSharedUser ( null ) ; </a> 0
<a> String appId = session . getApplicationId ( ) ; </a> 0
<a> Request . setDefaultBatchApplicationId ( appId ) ; </a> 0
<a> Request request1 = new Request ( null , "zuck" ) ; </a> 0
<a> Request request2 = new Request ( null , "zuck" ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( request1 , request2 ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 2 , responses . size ( ) ) ; </a> 0
<a> GraphUser user1 = responses . get ( 0 ) . getGraphObjectAs ( GraphUser . class ) ; </a> 0
<a> GraphUser user2 = responses . get ( 1 ) . getGraphObjectAs ( GraphUser . class ) ; </a> 0
<a> assertNotNull ( user1 ) ; </a> 0
<a> assertNotNull ( user2 ) ; </a> 0
<a> assertEquals ( "4" , user1 . getId ( ) ) ; </a> 0
<a> assertEquals ( "4" , user2 . getId ( ) ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testMixedSuccessAndFailure ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> final int NUM_REQUESTS = 8 ; </a> 0
<a> Request [ ] requests = new Request [ NUM_REQUESTS ] ; </a> 0
<a> for ( int i = 0 ; i < NUM_REQUESTS ; ++ i ) { </a> 0
<a> boolean shouldSucceed = ( i % 2 ) == 1 ; </a> 0
<a> requests [ i ] = new Request ( session , shouldSucceed ? "me" : "-1" ) ; </a> 0
<a> } </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( requests ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( NUM_REQUESTS , responses . size ( ) ) ; </a> 0
<a> for ( int i = 0 ; i < NUM_REQUESTS ; ++ i ) { </a> 0
<a> boolean shouldSucceed = ( i % 2 ) == 1 ; </a> 0
<a> Response response = responses . get ( i ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> if ( shouldSucceed ) { </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> assertNotNull ( response . getGraphObject ( ) ) ; </a> 0
<a> } else { </a> 0
<a> assertNotNull ( response . getError ( ) ) ; </a> 0
<a> assertNull ( response . getGraphObject ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testClosedSessionDoesntAppendAccessToken ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> session . close ( ) ; </a> 0
<a> Request request1 = new Request ( session , "me" , null , null , new ExpectFailureCallback ( ) ) ; </a> 0
<a> Request request2 = new Request ( session , "me" , null , null , new ExpectFailureCallback ( ) ) ; </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( request1 , request2 ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccess ( 2 ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testBatchUploadPhoto ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUserAndPermissions ( null , "user_photos" ) ; </a> 0
<a> final int image1Size = 120 ; </a> 0
<a> final int image2Size = 150 ; </a> 0
<a> Bitmap bitmap1 = createTestBitmap ( image1Size ) ; </a> 0
<a> Bitmap bitmap2 = createTestBitmap ( image2Size ) ; </a> 0
<a> Request uploadRequest1 = Request . newUploadPhotoRequest ( session , bitmap1 , null ) ; </a> 0
<a> uploadRequest1 . setBatchEntryName ( "uploadRequest1" ) ; </a> 0
<a> Request uploadRequest2 = Request . newUploadPhotoRequest ( session , bitmap2 , null ) ; </a> 0
<a> uploadRequest2 . setBatchEntryName ( "uploadRequest2" ) ; </a> 0
<a> Request getRequest1 = new Request ( session , "{result=uploadRequest1:$.id}" ) ; </a> 0
<a> Request getRequest2 = new Request ( session , "{result=uploadRequest2:$.id}" ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( uploadRequest1 , uploadRequest2 , getRequest1 , getRequest2 ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 4 , responses . size ( ) ) ; </a> 0
<a> assertNoErrors ( responses ) ; </a> 0
<a> GraphObject retrievedPhoto1 = responses . get ( 2 ) . getGraphObject ( ) ; </a> 0
<a> GraphObject retrievedPhoto2 = responses . get ( 3 ) . getGraphObject ( ) ; </a> 0
<a> assertNotNull ( retrievedPhoto1 ) ; </a> 0
<a> assertNotNull ( retrievedPhoto2 ) ; </a> 0
<a> assertEquals ( image1Size , retrievedPhoto1 . getProperty ( "width" ) ) ; </a> 0
<a> assertEquals ( image2Size , retrievedPhoto2 . getProperty ( "width" ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCallbacksAreCalled ( ) { </a> 0
<a> setBatchApplicationIdForTestApp ( ) ; </a> 0
<a> ArrayList < Request > requests = new ArrayList < Request > ( ) ; </a> 0
<a> final ArrayList < Boolean > calledBack = new ArrayList < Boolean > ( ) ; </a> 0
<a> final int NUM_REQUESTS = 4 ; </a> 0
<a> for ( int i = 0 ; i < NUM_REQUESTS ; ++ i ) { </a> 0
<a> Request request = new Request ( null , "4" ) ; </a> 0
<a> request . setCallback ( new Request . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> calledBack . add ( true ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> requests . add ( request ) ; </a> 0
<a> } </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( requests ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertTrue ( calledBack . size ( ) == NUM_REQUESTS ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCacheMyFriendsRequest ( ) throws IOException { </a> 0
<a> Response . getResponseCache ( ) . clearForTest ( ) ; </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Request request = Request . newMyFriendsRequest ( session , null ) ; </a> 0
<a> CacheableRequestBatch batch = new CacheableRequestBatch ( request ) ; </a> 0
<a> batch . setCacheKeyOverride ( "MyFriends" ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( batch ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 1 , responses . size ( ) ) ; </a> 0
<a> Response response = responses . get ( 0 ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> assertTrue ( ! response . getIsFromCache ( ) ) ; </a> 0
<a> responses = Request . executeBatchAndWait ( batch ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 1 , responses . size ( ) ) ; </a> 0
<a> response = responses . get ( 0 ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> assertTrue ( response . getIsFromCache ( ) ) ; </a> 0
<a> batch . setForceRoundTrip ( true ) ; </a> 0
<a> responses = Request . executeBatchAndWait ( batch ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 1 , responses . size ( ) ) ; </a> 0
<a> response = responses . get ( 0 ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> assertTrue ( ! response . getIsFromCache ( ) ) ; </a> 0
<a> Response . getResponseCache ( ) . clearForTest ( ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCacheMeAndMyFriendsRequest ( ) throws IOException { </a> 0
<a> Response . getResponseCache ( ) . clearForTest ( ) ; </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Request requestMe = Request . newMeRequest ( session , null ) ; </a> 0
<a> Request requestMyFriends = Request . newMyFriendsRequest ( session , null ) ; </a> 0
<a> CacheableRequestBatch batch = new CacheableRequestBatch ( new Request [ ] { requestMyFriends , requestMe } ) ; </a> 0
<a> batch . setCacheKeyOverride ( "MyFriends" ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( batch ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 2 , responses . size ( ) ) ; </a> 0
<a> for ( Response response : responses ) { </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> assertTrue ( ! response . getIsFromCache ( ) ) ; </a> 0
<a> } </a> 0
<a> responses = Request . executeBatchAndWait ( batch ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 2 , responses . size ( ) ) ; </a> 0
<a> for ( Response response : responses ) { </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> assertTrue ( response . getIsFromCache ( ) ) ; </a> 0
<a> } </a> 0
<a> batch . setForceRoundTrip ( true ) ; </a> 0
<a> responses = Request . executeBatchAndWait ( batch ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 2 , responses . size ( ) ) ; </a> 0
<a> for ( Response response : responses ) { </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> assertTrue ( ! response . getIsFromCache ( ) ) ; </a> 0
<a> } </a> 0
<a> Response . getResponseCache ( ) . clearForTest ( ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExplicitDependencyDefaultsToOmitFirstResponse ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Request requestMe = Request . newMeRequest ( session , null ) ; </a> 0
<a> requestMe . setBatchEntryName ( "me_request" ) ; </a> 0
<a> Request requestMyFriends = Request . newMyFriendsRequest ( session , null ) ; </a> 0
<a> requestMyFriends . setBatchEntryDependsOn ( "me_request" ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( requestMe , requestMyFriends ) ; </a> 0
<a> Response meResponse = responses . get ( 0 ) ; </a> 0
<a> Response myFriendsResponse = responses . get ( 1 ) ; </a> 0
<a> assertNull ( meResponse . getGraphObject ( ) ) ; </a> 0
<a> assertNotNull ( myFriendsResponse . getGraphObject ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExplicitDependencyCanIncludeFirstResponse ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Request requestMe = Request . newMeRequest ( session , null ) ; </a> 0
<a> requestMe . setBatchEntryName ( "me_request" ) ; </a> 0
<a> requestMe . setBatchEntryOmitResultOnSuccess ( false ) ; </a> 0
<a> Request requestMyFriends = Request . newMyFriendsRequest ( session , null ) ; </a> 0
<a> requestMyFriends . setBatchEntryDependsOn ( "me_request" ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( requestMe , requestMyFriends ) ; </a> 0
<a> Response meResponse = responses . get ( 0 ) ; </a> 0
<a> Response myFriendsResponse = responses . get ( 1 ) ; </a> 0
<a> assertNotNull ( meResponse . getGraphObject ( ) ) ; </a> 0
<a> assertNotNull ( myFriendsResponse . getGraphObject ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testAddAndRemoveBatchCallbacks ( ) { </a> 0
<a> RequestBatch batch = new RequestBatch ( ) ; </a> 0
<a> RequestBatch . Callback callback1 = new RequestBatch . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onBatchCompleted ( RequestBatch batch ) { </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> RequestBatch . Callback callback2 = new RequestBatch . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onBatchCompleted ( RequestBatch batch ) { </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> batch . addCallback ( callback1 ) ; </a> 0
<a> batch . addCallback ( callback2 ) ; </a> 0
<a> assertEquals ( 2 , batch . getCallbacks ( ) . size ( ) ) ; </a> 0
<a> batch . removeCallback ( callback1 ) ; </a> 0
<a> batch . removeCallback ( callback2 ) ; </a> 0
<a> assertEquals ( 0 , batch . getCallbacks ( ) . size ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testBatchCallbackIsCalled ( ) { </a> 0
<a> final AtomicInteger count = new AtomicInteger ( ) ; </a> 0
<a> Request request1 = Request . newGraphPathRequest ( null , "4" , new Request . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> count . incrementAndGet ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Request request2 = Request . newGraphPathRequest ( null , "4" , new Request . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> count . incrementAndGet ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> RequestBatch batch = new RequestBatch ( request1 , request2 ) ; </a> 0
<a> batch . addCallback ( new RequestBatch . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onBatchCompleted ( RequestBatch batch ) { </a> 0
<a> count . incrementAndGet ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> batch . executeAndWait ( ) ; </a> 0
<a> assertEquals ( 3 , count . get ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . res . AssetManager ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . graphics . Color ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . ConditionVariable ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . test . ActivityInstrumentationTestCase2 ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import junit . framework . AssertionFailedError ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import org . json . JSONTokener ; </a> 0
<a> import java . io . * ; </a> 0
<a> import java . net . HttpURLConnection ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> public class FacebookActivityTestCase < T extends Activity > extends ActivityInstrumentationTestCase2 < T > { </a> 0
<a> private static final String TAG = FacebookActivityTestCase . class . getSimpleName ( ) ; </a> 0
<a> private static String applicationId ; </a> 0
<a> private static String applicationSecret ; </a> 0
<a> public final static String SECOND_TEST_USER_TAG = "Second" ; </a> 0
<a> public final static String THIRD_TEST_USER_TAG = "Third" ; </a> 0
<a> private TestBlocker testBlocker ; </a> 0
<a> protected synchronized TestBlocker getTestBlocker ( ) { </a> 0
<a> if ( testBlocker == null ) { </a> 0
<a> testBlocker = TestBlocker . createTestBlocker ( ) ; </a> 0
<a> } </a> 0
<a> return testBlocker ; </a> 0
<a> } </a> 0
<a> public FacebookActivityTestCase ( Class < T > activityClass ) { </a> 0
<a> super ( "" , activityClass ) ; </a> 0
<a> } </a> 0
<a> protected TestSession getTestSessionWithSharedUser ( ) { </a> 0
<a> return getTestSessionWithSharedUser ( null ) ; </a> 0
<a> } </a> 0
<a> protected TestSession getTestSessionWithSharedUser ( String sessionUniqueUserTag ) { </a> 0
<a> return getTestSessionWithSharedUserAndPermissions ( sessionUniqueUserTag , new ArrayList < String > ( ) ) ; </a> 0
<a> } </a> 0
<a> protected TestSession getTestSessionWithSharedUserAndPermissions ( String sessionUniqueUserTag , </a> 0
<a> List < String > permissions ) { </a> 0
<a> return TestSession . createSessionWithSharedUser ( getActivity ( ) , permissions , sessionUniqueUserTag ) ; </a> 0
<a> } </a> 0
<a> protected TestSession getTestSessionWithPrivateUser ( TestBlocker testBlocker ) { </a> 0
<a> return TestSession . createSessionWithPrivateUser ( getActivity ( ) , null ) ; </a> 0
<a> } </a> 0
<a> protected TestSession openTestSessionWithSharedUser ( final TestBlocker blocker ) { </a> 0
<a> return openTestSessionWithSharedUser ( blocker , null ) ; </a> 0
<a> } </a> 0
<a> protected TestSession openTestSessionWithSharedUser ( final TestBlocker blocker , String sessionUniqueUserTag ) { </a> 0
<a> TestSession session = getTestSessionWithSharedUser ( ) ; </a> 0
<a> openSession ( getActivity ( ) , session , blocker ) ; </a> 0
<a> return session ; </a> 0
<a> } </a> 0
<a> protected TestSession openTestSessionWithSharedUser ( ) { </a> 0
<a> return openTestSessionWithSharedUser ( ( String ) null ) ; </a> 0
<a> } </a> 0
<a> protected TestSession openTestSessionWithSharedUser ( String sessionUniqueUserTag ) { </a> 0
<a> return openTestSessionWithSharedUserAndPermissions ( sessionUniqueUserTag , ( String [ ] ) null ) ; </a> 0
<a> } </a> 0
<a> protected TestSession openTestSessionWithSharedUserAndPermissions ( String sessionUniqueUserTag , </a> 0
<a> String ... permissions ) { </a> 0
<a> List < String > permissionList = ( permissions != null ) ? Arrays . asList ( permissions ) : null ; </a> 0
<a> return openTestSessionWithSharedUserAndPermissions ( sessionUniqueUserTag , permissionList ) ; </a> 0
<a> } </a> 0
<a> protected TestSession openTestSessionWithSharedUserAndPermissions ( String sessionUniqueUserTag , </a> 0
<a> List < String > permissions ) { </a> 0
<a> final TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> TestSession session = getTestSessionWithSharedUserAndPermissions ( sessionUniqueUserTag , permissions ) ; </a> 0
<a> openSession ( getActivity ( ) , session , blocker ) ; </a> 0
<a> return session ; </a> 0
<a> } </a> 0
<a> protected void waitAndAssertSuccess ( TestBlocker testBlocker , int numSignals ) { </a> 0
<a> try { </a> 0
<a> testBlocker . waitForSignalsAndAssertSuccess ( numSignals ) ; </a> 0
<a> } catch ( AssertionFailedError e ) { </a> 0
<a> throw e ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> fail ( "Got exception: " + e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void waitAndAssertSuccess ( int numSignals ) { </a> 0
<a> waitAndAssertSuccess ( getTestBlocker ( ) , numSignals ) ; </a> 0
<a> } </a> 0
<a> protected void waitAndAssertSuccessOrRethrow ( int numSignals ) throws Exception { </a> 0
<a> getTestBlocker ( ) . waitForSignalsAndAssertSuccess ( numSignals ) ; </a> 0
<a> } </a> 0
<a> protected void runAndBlockOnUiThread ( final int expectedSignals , final Runnable runnable ) throws Throwable { </a> 0
<a> final TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> runTestOnUiThread ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> runnable . run ( ) ; </a> 0
<a> blocker . signal ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> blocker . waitForSignals ( 1 + expectedSignals ) ; </a> 0
<a> getInstrumentation ( ) . waitForIdleSync ( ) ; </a> 0
<a> } </a> 0
<a> protected synchronized void readApplicationIdAndSecret ( ) { </a> 0
<a> synchronized ( FacebookTestCase . class ) { </a> 0
<a> if ( applicationId != null && applicationSecret != null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> AssetManager assets = getInstrumentation ( ) . getContext ( ) . getResources ( ) . getAssets ( ) ; </a> 0
<a> InputStream stream = null ; </a> 0
<a> final String errorMessage = "could not read applicationId and applicationSecret from config.json; ensure " </a> 0
<a> + "you have run 'configure_unit_tests.sh'. Error: " ; </a> 0
<a> try { </a> 0
<a> stream = assets . open ( "config.json" ) ; </a> 0
<a> String string = Utility . readStreamToString ( stream ) ; </a> 0
<a> JSONTokener tokener = new JSONTokener ( string ) ; </a> 0
<a> Object obj = tokener . nextValue ( ) ; </a> 0
<a> if ( ! ( obj instanceof JSONObject ) ) { </a> 0
<a> fail ( errorMessage + "could not deserialize a JSONObject" ) ; </a> 0
<a> } </a> 0
<a> JSONObject jsonObject = ( JSONObject ) obj ; </a> 0
<a> applicationId = jsonObject . optString ( "applicationId" ) ; </a> 0
<a> applicationSecret = jsonObject . optString ( "applicationSecret" ) ; </a> 0
<a> if ( Utility . isNullOrEmpty ( applicationId ) || Utility . isNullOrEmpty ( applicationSecret ) ) { </a> 0
<a> fail ( errorMessage + "one or both config values are missing" ) ; </a> 0
<a> } </a> 0
<a> TestSession . setTestApplicationId ( applicationId ) ; </a> 0
<a> TestSession . setTestApplicationSecret ( applicationSecret ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> fail ( errorMessage + e . toString ( ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> fail ( errorMessage + e . toString ( ) ) ; </a> 0
<a> } finally { </a> 0
<a> if ( stream != null ) { </a> 0
<a> try { </a> 0
<a> stream . close ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> fail ( errorMessage + e . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void openSession ( Activity activity , TestSession session ) { </a> 0
<a> final TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> openSession ( activity , session , blocker ) ; </a> 0
<a> } </a> 0
<a> protected void openSession ( Activity activity , TestSession session , final TestBlocker blocker ) { </a> 0
<a> Session . OpenRequest openRequest = new Session . OpenRequest ( activity ) . </a> 0
<a> setCallback ( new Session . StatusCallback ( ) { </a> 0
<a> boolean signaled = false ; </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> if ( exception != null ) { </a> 0
<a> Log . w ( TAG , </a> 0
<a> "openSession: received an error opening session: " + exception . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> assertTrue ( exception == null ) ; </a> 0
<a> if ( ! signaled ) { </a> 0
<a> blocker . signal ( ) ; </a> 0
<a> signaled = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> session . openForRead ( openRequest ) ; </a> 0
<a> waitAndAssertSuccess ( blocker , 1 ) ; </a> 0
<a> } </a> 0
<a> protected void setUp ( ) throws Exception { </a> 0
<a> super . setUp ( ) ; </a> 0
<a> readApplicationIdAndSecret ( ) ; </a> 0
<a> Settings . addLoggingBehavior ( LoggingBehavior . REQUESTS ) ; </a> 0
<a> Settings . addLoggingBehavior ( LoggingBehavior . INCLUDE_ACCESS_TOKENS ) ; </a> 0
<a> turnOnStrictModeForUiThread ( ) ; </a> 0
<a> } </a> 0
<a> protected void tearDown ( ) throws Exception { </a> 0
<a> super . tearDown ( ) ; </a> 0
<a> if ( testBlocker != null ) { </a> 0
<a> testBlocker . quit ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected Bundle getNativeLinkingExtras ( String token ) { </a> 0
<a> Bundle extras = new Bundle ( ) ; </a> 0
<a> String extraLaunchUriString = String </a> 0
<a> . format ( "fbrpc://facebook/nativethirdparty?app_id=%s&package_name=com.facebook.sdk.tests&class_name=com.facebook.FacebookActivityTests$FacebookTestActivity&access_token=%s" , </a> 0
<a> TestSession . getTestApplicationId ( ) , token ) ; </a> 0
<a> extras . putString ( "extra_launch_uri" , extraLaunchUriString ) ; </a> 0
<a> extras . putString ( "expires_in" , "3600" ) ; </a> 0
<a> extras . putLong ( "app_id" , Long . parseLong ( TestSession . getTestApplicationId ( ) ) ) ; </a> 0
<a> extras . putString ( "access_token" , token ) ; </a> 0
<a> return extras ; </a> 0
<a> } </a> 0
<a> interface GraphObjectPostResult extends GraphObject { </a> 0
<a> String getId ( ) ; </a> 0
<a> } </a> 0
<a> protected GraphObject getAndAssert ( Session session , String id ) { </a> 0
<a> Request request = new Request ( session , id ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> GraphObject result = response . getGraphObject ( ) ; </a> 0
<a> assertNotNull ( result ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> protected GraphObject postGetAndAssert ( Session session , String path , GraphObject graphObject ) { </a> 0
<a> Request request = Request . newPostRequest ( session , path , graphObject , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> GraphObjectPostResult result = response . getGraphObjectAs ( GraphObjectPostResult . class ) ; </a> 0
<a> assertNotNull ( result ) ; </a> 0
<a> assertNotNull ( result . getId ( ) ) ; </a> 0
<a> return getAndAssert ( session , result . getId ( ) ) ; </a> 0
<a> } </a> 0
<a> protected void setBatchApplicationIdForTestApp ( ) { </a> 0
<a> String appId = TestSession . getTestApplicationId ( ) ; </a> 0
<a> Request . setDefaultBatchApplicationId ( appId ) ; </a> 0
<a> } </a> 0
<a> protected < U extends GraphObject > U batchCreateAndGet ( Session session , String graphPath , GraphObject graphObject , </a> 0
<a> String fields , Class < U > resultClass ) { </a> 0
<a> Request create = Request . newPostRequest ( session , graphPath , graphObject , new ExpectSuccessCallback ( ) ) ; </a> 0
<a> create . setBatchEntryName ( "create" ) ; </a> 0
<a> Request get = Request . newGraphPathRequest ( session , "{result=create:$.id}" , new ExpectSuccessCallback ( ) ) ; </a> 0
<a> if ( fields != null ) { </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> parameters . putString ( "fields" , fields ) ; </a> 0
<a> get . setParameters ( parameters ) ; </a> 0
<a> } </a> 0
<a> return batchPostAndGet ( create , get , resultClass ) ; </a> 0
<a> } </a> 0
<a> protected < U extends GraphObject > U batchUpdateAndGet ( Session session , String graphPath , GraphObject graphObject , </a> 0
<a> String fields , Class < U > resultClass ) { </a> 0
<a> Request update = Request . newPostRequest ( session , graphPath , graphObject , new ExpectSuccessCallback ( ) ) ; </a> 0
<a> Request get = Request . newGraphPathRequest ( session , graphPath , new ExpectSuccessCallback ( ) ) ; </a> 0
<a> if ( fields != null ) { </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> parameters . putString ( "fields" , fields ) ; </a> 0
<a> get . setParameters ( parameters ) ; </a> 0
<a> } </a> 0
<a> return batchPostAndGet ( update , get , resultClass ) ; </a> 0
<a> } </a> 0
<a> protected < U extends GraphObject > U batchPostAndGet ( Request post , Request get , Class < U > resultClass ) { </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( post , get ) ; </a> 0
<a> assertEquals ( 2 , responses . size ( ) ) ; </a> 0
<a> U resultGraphObject = responses . get ( 1 ) . getGraphObjectAs ( resultClass ) ; </a> 0
<a> assertNotNull ( resultGraphObject ) ; </a> 0
<a> return resultGraphObject ; </a> 0
<a> } </a> 0
<a> protected GraphObject createStatusUpdate ( ) { </a> 0
<a> GraphObject statusUpdate = GraphObject . Factory . create ( ) ; </a> 0
<a> String message = String . format ( </a> 0
<a> "Check out my awesome new status update posted at: %s. Some chars for you: +\"[]:," , new Date ( ) ) ; </a> 0
<a> statusUpdate . setProperty ( "message" , message ) ; </a> 0
<a> return statusUpdate ; </a> 0
<a> } </a> 0
<a> protected Bitmap createTestBitmap ( int size ) { </a> 0
<a> Bitmap image = Bitmap . createBitmap ( size , size , Bitmap . Config . RGB_565 ) ; </a> 0
<a> image . eraseColor ( Color . BLUE ) ; </a> 0
<a> return image ; </a> 0
<a> } </a> 0
<a> protected void issueFriendRequest ( TestSession session , String targetUserId ) { </a> 0
<a> String graphPath = "me/friends/" + targetUserId ; </a> 0
<a> Request request = Request . newPostRequest ( session , graphPath , null , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> FacebookRequestError error = response . getError ( ) ; </a> 0
<a> assertTrue ( error == null || error . getRequestStatusCode ( ) == 400 ) ; </a> 0
<a> } </a> 0
<a> protected void makeTestUsersFriends ( TestSession session1 , TestSession session2 ) { </a> 0
<a> issueFriendRequest ( session1 , session2 . getTestUserId ( ) ) ; </a> 0
<a> issueFriendRequest ( session2 , session1 . getTestUserId ( ) ) ; </a> 0
<a> } </a> 0
<a> protected void assertDateEqualsWithinDelta ( Date expected , Date actual , long deltaInMsec ) { </a> 0
<a> long delta = Math . abs ( expected . getTime ( ) - actual . getTime ( ) ) ; </a> 0
<a> assertTrue ( delta < deltaInMsec ) ; </a> 0
<a> } </a> 0
<a> protected void assertDateDiffersWithinDelta ( Date expected , Date actual , long expectedDifference , long deltaInMsec ) { </a> 0
<a> long delta = Math . abs ( expected . getTime ( ) - actual . getTime ( ) ) - expectedDifference ; </a> 0
<a> assertTrue ( delta < deltaInMsec ) ; </a> 0
<a> } </a> 0
<a> protected void assertNoErrors ( List < Response > responses ) { </a> 0
<a> for ( int i = 0 ; i < responses . size ( ) ; ++ i ) { </a> 0
<a> Response response = responses . get ( i ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected File createTempFileFromAsset ( String assetPath ) throws IOException { </a> 0
<a> InputStream inputStream = null ; </a> 0
<a> FileOutputStream outStream = null ; </a> 0
<a> try { </a> 0
<a> AssetManager assets = getInstrumentation ( ) . getContext ( ) . getResources ( ) . getAssets ( ) ; </a> 0
<a> inputStream = assets . open ( assetPath ) ; </a> 0
<a> File outputDir = getActivity ( ) . getCacheDir ( ) ; </a> 0
<a> File outputFile = File . createTempFile ( "prefix" , assetPath , outputDir ) ; </a> 0
<a> outStream = new FileOutputStream ( outputFile ) ; </a> 0
<a> final int bufferSize = 1024 * 2 ; </a> 0
<a> byte [ ] buffer = new byte [ bufferSize ] ; </a> 0
<a> int n = 0 ; </a> 0
<a> while ( ( n = inputStream . read ( buffer ) ) != - 1 ) { </a> 0
<a> outStream . write ( buffer , 0 , n ) ; </a> 0
<a> } </a> 0
<a> return outputFile ; </a> 0
<a> } finally { </a> 0
<a> Utility . closeQuietly ( outStream ) ; </a> 0
<a> Utility . closeQuietly ( inputStream ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void runOnBlockerThread ( final Runnable runnable , boolean waitForCompletion ) { </a> 0
<a> Runnable runnableToPost = runnable ; </a> 0
<a> final ConditionVariable condition = waitForCompletion ? new ConditionVariable ( ! waitForCompletion ) : null ; </a> 0
<a> if ( waitForCompletion ) { </a> 0
<a> runnableToPost = new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> runnable . run ( ) ; </a> 0
<a> condition . open ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> Handler handler = blocker . getHandler ( ) ; </a> 0
<a> handler . post ( runnableToPost ) ; </a> 0
<a> if ( waitForCompletion ) { </a> 0
<a> boolean success = condition . block ( 10000 ) ; </a> 0
<a> assertTrue ( success ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void closeBlockerAndAssertSuccess ( ) { </a> 0
<a> TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> testBlocker = null ; </a> 0
<a> blocker . quit ( ) ; </a> 0
<a> boolean joined = false ; </a> 0
<a> while ( ! joined ) { </a> 0
<a> try { </a> 0
<a> blocker . join ( ) ; </a> 0
<a> joined = true ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> blocker . assertSuccess ( ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> fail ( e . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected TestRequestAsyncTask createAsyncTaskOnUiThread ( final Request ... requests ) throws Throwable { </a> 0
<a> final ArrayList < TestRequestAsyncTask > result = new ArrayList < TestRequestAsyncTask > ( ) ; </a> 0
<a> runTestOnUiThread ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> result . add ( new TestRequestAsyncTask ( requests ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> return result . isEmpty ( ) ? null : result . get ( 0 ) ; </a> 0
<a> } </a> 0
<a> protected class TestRequestAsyncTask extends RequestAsyncTask { </a> 0
<a> private final TestBlocker blocker = FacebookActivityTestCase . this . getTestBlocker ( ) ; </a> 0
<a> public TestRequestAsyncTask ( Request ... requests ) { </a> 0
<a> super ( requests ) ; </a> 0
<a> } </a> 0
<a> public TestRequestAsyncTask ( List < Request > requests ) { </a> 0
<a> super ( requests ) ; </a> 0
<a> } </a> 0
<a> public TestRequestAsyncTask ( RequestBatch requests ) { </a> 0
<a> super ( requests ) ; </a> 0
<a> } </a> 0
<a> public TestRequestAsyncTask ( HttpURLConnection connection , Request ... requests ) { </a> 0
<a> super ( connection , requests ) ; </a> 0
<a> } </a> 0
<a> public TestRequestAsyncTask ( HttpURLConnection connection , List < Request > requests ) { </a> 0
<a> super ( connection , requests ) ; </a> 0
<a> } </a> 0
<a> public TestRequestAsyncTask ( HttpURLConnection connection , RequestBatch requests ) { </a> 0
<a> super ( connection , requests ) ; </a> 0
<a> } </a> 0
<a> public final TestBlocker getBlocker ( ) { </a> 0
<a> return blocker ; </a> 0
<a> } </a> 0
<a> public final Exception getThrowable ( ) { </a> 0
<a> return getException ( ) ; </a> 0
<a> } </a> 0
<a> protected void onPostExecute ( List < Response > result ) { </a> 0
<a> try { </a> 0
<a> super . onPostExecute ( result ) ; </a> 0
<a> if ( getException ( ) != null ) { </a> 0
<a> blocker . setException ( getException ( ) ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> Log . d ( "TestRequestAsyncTask" , "signaling blocker" ) ; </a> 0
<a> blocker . signal ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void executeOnBlockerThread ( ) { </a> 0
<a> ensureAsyncTaskLoaded ( ) ; </a> 0
<a> Runnable runnable = new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> execute ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> Handler handler = new Handler ( blocker . getLooper ( ) ) ; </a> 0
<a> handler . post ( runnable ) ; </a> 0
<a> } </a> 0
<a> private void ensureAsyncTaskLoaded ( ) { </a> 0
<a> try { </a> 0
<a> runAndBlockOnUiThread ( 0 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> try { </a> 0
<a> Class . forName ( "android.os.AsyncTask" ) ; </a> 0
<a> } catch ( ClassNotFoundException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } catch ( Throwable throwable ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected class TestCallback implements Request . Callback { </a> 0
<a> private final TestBlocker blocker ; </a> 0
<a> private final boolean expectSuccess ; </a> 0
<a> public TestCallback ( TestBlocker blocker , boolean expectSuccess ) { </a> 0
<a> this . blocker = blocker ; </a> 0
<a> this . expectSuccess = expectSuccess ; </a> 0
<a> } </a> 0
<a> public TestCallback ( boolean expectSuccess ) { </a> 0
<a> this ( FacebookActivityTestCase . this . getTestBlocker ( ) , expectSuccess ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> try { </a> 0
<a> if ( Thread . currentThread ( ) != blocker ) { </a> 0
<a> throw new FacebookException ( "Invalid thread " + Thread . currentThread ( ) . getId ( ) </a> 0
<a> + "; expected to be called on thread " + blocker . getId ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( expectSuccess && response . getError ( ) != null ) { </a> 0
<a> throw response . getError ( ) . getException ( ) ; </a> 0
<a> } else if ( ! expectSuccess && response . getError ( ) == null ) { </a> 0
<a> throw new FacebookException ( "Expected failure case, received no error" ) ; </a> 0
<a> } </a> 0
<a> performAsserts ( response ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> blocker . setException ( e ) ; </a> 0
<a> } finally { </a> 0
<a> blocker . signal ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void performAsserts ( Response response ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected class ExpectSuccessCallback extends TestCallback { </a> 0
<a> public ExpectSuccessCallback ( ) { </a> 0
<a> super ( true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected class ExpectFailureCallback extends TestCallback { </a> 0
<a> public ExpectFailureCallback ( ) { </a> 0
<a> super ( false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static abstract class MockRequest extends Request { </a> 0
<a> public abstract Response createResponse ( ) ; </a> 0
<a> } </a> 0
<a> public static class MockRequestBatch extends RequestBatch { </a> 0
<a> public MockRequestBatch ( MockRequest ... requests ) { </a> 0
<a> super ( requests ) ; </a> 0
<a> } </a> 0
<a> public MockRequestBatch ( RequestBatch requests ) { </a> 0
<a> super ( requests ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> List < Response > executeAndWaitImpl ( ) { </a> 0
<a> List < Request > requests = getRequests ( ) ; </a> 0
<a> List < Response > responses = new ArrayList < Response > ( ) ; </a> 0
<a> for ( Request request : requests ) { </a> 0
<a> MockRequest mockRequest = ( MockRequest ) request ; </a> 0
<a> responses . add ( mockRequest . createResponse ( ) ) ; </a> 0
<a> } </a> 0
<a> Request . runCallbacks ( this , responses ) ; </a> 0
<a> return responses ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private AtomicBoolean strictModeOnForUiThread = new AtomicBoolean ( ) ; </a> 0
<a> protected void turnOnStrictModeForUiThread ( ) { </a> 0
<a> if ( strictModeOnForUiThread . get ( ) == false ) { </a> 0
<a> try { </a> 0
<a> runTestOnUiThread ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> if ( strictModeOnForUiThread . compareAndSet ( false , true ) ) { </a> 0
<a> turnOnStrictModeForThisThread ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } catch ( Throwable throwable ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void turnOnStrictModeForThisThread ( ) { </a> 0
<a> try { </a> 0
<a> ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; </a> 0
<a> Class < ? > strictModeClass = Class . forName ( "android.os.StrictMode" , true , loader ) ; </a> 0
<a> Class < ? > threadPolicyClass = Class . forName ( "android.os.StrictMode$ThreadPolicy" , true , loader ) ; </a> 0
<a> Class < ? > threadPolicyBuilderClass = Class . forName ( "android.os.StrictMode$ThreadPolicy$Builder" , true , </a> 0
<a> loader ) ; </a> 0
<a> Object threadPolicyBuilder = threadPolicyBuilderClass . getConstructor ( ) . newInstance ( ) ; </a> 0
<a> threadPolicyBuilder = threadPolicyBuilderClass . getMethod ( "detectAll" ) . invoke ( threadPolicyBuilder ) ; </a> 0
<a> threadPolicyBuilder = threadPolicyBuilderClass . getMethod ( "penaltyDeath" ) . invoke ( threadPolicyBuilder ) ; </a> 0
<a> Object threadPolicy = threadPolicyBuilderClass . getMethod ( "build" ) . invoke ( threadPolicyBuilder ) ; </a> 0
<a> strictModeClass . getMethod ( "setThreadPolicy" , threadPolicyClass ) . invoke ( strictModeClass , threadPolicy ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import com . facebook . sdk . tests . R ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> public class FacebookRequestErrorTests extends FacebookTestCase { </a> 0
<a> public static final String ERROR_SINGLE_RESPONSE = </a> 0
<a> "{\n" + </a> 0
<a> " \"error\": {\n" + </a> 0
<a> " \"message\": \"Unknown path components: /unknown\",\n" + </a> 0
<a> " \"type\": \"OAuthException\",\n" + </a> 0
<a> " \"code\": 2500\n" + </a> 0
<a> " }\n" + </a> 0
<a> "}" ; </a> 0
<a> public static final String ERROR_BATCH_RESPONSE = </a> 0
<a> "[\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"headers\": [\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"*\",\n" + </a> 0
<a> " \"name\": \"Access-Control-Allow-Origin\"\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"no-store\",\n" + </a> 0
<a> " \"name\": \"Cache-Control\"\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"close\",\n" + </a> 0
<a> " \"name\": \"Connection\"\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"text\\/javascript; charset=UTF-8\",\n" + </a> 0
<a> " \"name\": \"Content-Type\"\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"Sat, 01 Jan 2000 00:00:00 GMT\",\n" + </a> 0
<a> " \"name\": \"Expires\"\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"no-cache\",\n" + </a> 0
<a> " \"name\": \"Pragma\"\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"OAuth \\\"Facebook Platform\\\" \\\"invalid_request\\\" \\\"An active access token must be used to query information about the current user.\\\"\",\n" + </a> 0
<a> " \"name\": \"WWW-Authenticate\"\n" + </a> 0
<a> " }\n" + </a> 0
<a> " ],\n" + </a> 0
<a> " \"body\": \"{\\\"error\\\":{\\\"message\\\":\\\"An active access token must be used to query information about the current user.\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":2500}}\",\n" + </a> 0
<a> " \"code\": 400\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"headers\": [\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"*\",\n" + </a> 0
<a> " \"name\": \"Access-Control-Allow-Origin\"\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"no-store\",\n" + </a> 0
<a> " \"name\": \"Cache-Control\"\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"close\",\n" + </a> 0
<a> " \"name\": \"Connection\"\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"text\\/javascript; charset=UTF-8\",\n" + </a> 0
<a> " \"name\": \"Content-Type\"\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"Sat, 01 Jan 2000 00:00:00 GMT\",\n" + </a> 0
<a> " \"name\": \"Expires\"\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"no-cache\",\n" + </a> 0
<a> " \"name\": \"Pragma\"\n" + </a> 0
<a> " },\n" + </a> 0
<a> " {\n" + </a> 0
<a> " \"value\": \"OAuth \\\"Facebook Platform\\\" \\\"invalid_request\\\" \\\"An active access token must be used to query information about the current user.\\\"\",\n" + </a> 0
<a> " \"name\": \"WWW-Authenticate\"\n" + </a> 0
<a> " }\n" + </a> 0
<a> " ],\n" + </a> 0
<a> " \"body\": \"{\\\"error\\\":{\\\"message\\\":\\\"An active access token must be used to query information about the current user.\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":2500}}\",\n" + </a> 0
<a> " \"code\": 400\n" + </a> 0
<a> " }\n" + </a> 0
<a> "]" ; </a> 0
<a> public static final String ERROR_SINGLE_RESPONSE_THROTTLE = </a> 0
<a> "{\n" + </a> 0
<a> " \"error\": {\n" + </a> 0
<a> " \"message\": \"Application request limit reached\",\n" + </a> 0
<a> " \"code\": 4\n" + </a> 0
<a> " }\n" + </a> 0
<a> "}" ; </a> 0
<a> public static final String ERROR_SINGLE_RESPONSE_SERVER = </a> 0
<a> "{\n" + </a> 0
<a> " \"error\": {\n" + </a> 0
<a> " \"message\": \"Some Server Error\",\n" + </a> 0
<a> " \"code\": 2\n" + </a> 0
<a> " }\n" + </a> 0
<a> "}" ; </a> 0
<a> public static final String ERROR_SINGLE_RESPONSE_PERMISSION = </a> 0
<a> "{\n" + </a> 0
<a> " \"error\": {\n" + </a> 0
<a> " \"type\": \"OAuthException\",\n" + </a> 0
<a> " \"message\": \"(#200) Requires extended permission: publish_actions\",\n" + </a> 0
<a> " \"code\": 200\n" + </a> 0
<a> " }\n" + </a> 0
<a> "}" ; </a> 0
<a> public static final String ERROR_SINGLE_RESPONSE_WEB_LOGIN = </a> 0
<a> "{\n" + </a> 0
<a> " \"error\": {\n" + </a> 0
<a> " \"message\": \"User need to login\",\n" + </a> 0
<a> " \"type\": \"OAuthException\",\n" + </a> 0
<a> " \"code\": 102,\n" + </a> 0
<a> " \"error_subcode\": 459\n" + </a> 0
<a> " }\n" + </a> 0
<a> "}" ; </a> 0
<a> public static final String ERROR_SINGLE_RESPONSE_RELOGIN = </a> 0
<a> "{\n" + </a> 0
<a> " \"error\": {\n" + </a> 0
<a> " \"message\": \"User need to relogin\",\n" + </a> 0
<a> " \"type\": \"OAuthException\",\n" + </a> 0
<a> " \"code\": 102\n" + </a> 0
<a> " }\n" + </a> 0
<a> "}" ; </a> 0
<a> public static final String ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP = </a> 0
<a> "{\n" + </a> 0
<a> " \"error\": {\n" + </a> 0
<a> " \"message\": \"User need to relogin\",\n" + </a> 0
<a> " \"type\": \"OAuthException\",\n" + </a> 0
<a> " \"code\": 190,\n" + </a> 0
<a> " \"error_subcode\": 458\n" + </a> 0
<a> " }\n" + </a> 0
<a> "}" ; </a> 0
<a> public void testClientException ( ) { </a> 0
<a> final String errorMsg = "some error happened" ; </a> 0
<a> FacebookRequestError error = new FacebookRequestError ( null , new FacebookException ( errorMsg ) ) ; </a> 0
<a> assertEquals ( errorMsg , error . getErrorMessage ( ) ) ; </a> 0
<a> assertEquals ( FacebookRequestError . Category . CLIENT , error . getCategory ( ) ) ; </a> 0
<a> assertEquals ( FacebookRequestError . INVALID_ERROR_CODE , error . getErrorCode ( ) ) ; </a> 0
<a> assertEquals ( FacebookRequestError . INVALID_HTTP_STATUS_CODE , error . getRequestStatusCode ( ) ) ; </a> 0
<a> assertEquals ( 0 , error . getUserActionMessageId ( ) ) ; </a> 0
<a> } </a> 0
<a> public void testSingleRequestWithoutBody ( ) throws JSONException { </a> 0
<a> JSONObject withStatusCode = new JSONObject ( ) ; </a> 0
<a> withStatusCode . put ( "code" , 400 ) ; </a> 0
<a> FacebookRequestError error = </a> 0
<a> FacebookRequestError . checkResponseAndCreateError ( withStatusCode , withStatusCode , null ) ; </a> 0
<a> assertNotNull ( error ) ; </a> 0
<a> assertEquals ( 400 , error . getRequestStatusCode ( ) ) ; </a> 0
<a> assertEquals ( FacebookRequestError . Category . BAD_REQUEST , error . getCategory ( ) ) ; </a> 0
<a> assertEquals ( 0 , error . getUserActionMessageId ( ) ) ; </a> 0
<a> } </a> 0
<a> public void testSingleErrorWithBody ( ) throws JSONException { </a> 0
<a> JSONObject originalResponse = new JSONObject ( ERROR_SINGLE_RESPONSE ) ; </a> 0
<a> JSONObject withStatusCodeAndBody = new JSONObject ( ) ; </a> 0
<a> withStatusCodeAndBody . put ( "code" , 400 ) ; </a> 0
<a> withStatusCodeAndBody . put ( "body" , originalResponse ) ; </a> 0
<a> FacebookRequestError error = </a> 0
<a> FacebookRequestError . checkResponseAndCreateError ( withStatusCodeAndBody , originalResponse , null ) ; </a> 0
<a> assertNotNull ( error ) ; </a> 0
<a> assertEquals ( 400 , error . getRequestStatusCode ( ) ) ; </a> 0
<a> assertEquals ( "Unknown path components: /unknown" , error . getErrorMessage ( ) ) ; </a> 0
<a> assertEquals ( "OAuthException" , error . getErrorType ( ) ) ; </a> 0
<a> assertEquals ( 2500 , error . getErrorCode ( ) ) ; </a> 0
<a> assertTrue ( error . getBatchRequestResult ( ) instanceof JSONObject ) ; </a> 0
<a> assertEquals ( FacebookRequestError . Category . BAD_REQUEST , error . getCategory ( ) ) ; </a> 0
<a> assertEquals ( 0 , error . getUserActionMessageId ( ) ) ; </a> 0
<a> } </a> 0
<a> public void testBatchRequest ( ) throws JSONException { </a> 0
<a> JSONArray batchResponse = new JSONArray ( ERROR_BATCH_RESPONSE ) ; </a> 0
<a> assertEquals ( 2 , batchResponse . length ( ) ) ; </a> 0
<a> JSONObject firstResponse = ( JSONObject ) batchResponse . get ( 0 ) ; </a> 0
<a> FacebookRequestError error = </a> 0
<a> FacebookRequestError . checkResponseAndCreateError ( firstResponse , batchResponse , null ) ; </a> 0
<a> assertNotNull ( error ) ; </a> 0
<a> assertEquals ( 400 , error . getRequestStatusCode ( ) ) ; </a> 0
<a> assertEquals ( "An active access token must be used to query information about the current user." , </a> 0
<a> error . getErrorMessage ( ) ) ; </a> 0
<a> assertEquals ( "OAuthException" , error . getErrorType ( ) ) ; </a> 0
<a> assertEquals ( 2500 , error . getErrorCode ( ) ) ; </a> 0
<a> assertTrue ( error . getBatchRequestResult ( ) instanceof JSONArray ) ; </a> 0
<a> assertEquals ( FacebookRequestError . Category . BAD_REQUEST , error . getCategory ( ) ) ; </a> 0
<a> assertEquals ( 0 , error . getUserActionMessageId ( ) ) ; </a> 0
<a> } </a> 0
<a> public void testSingleThrottledError ( ) throws JSONException { </a> 0
<a> JSONObject originalResponse = new JSONObject ( ERROR_SINGLE_RESPONSE_THROTTLE ) ; </a> 0
<a> JSONObject withStatusCodeAndBody = new JSONObject ( ) ; </a> 0
<a> withStatusCodeAndBody . put ( "code" , 403 ) ; </a> 0
<a> withStatusCodeAndBody . put ( "body" , originalResponse ) ; </a> 0
<a> FacebookRequestError error = </a> 0
<a> FacebookRequestError . checkResponseAndCreateError ( withStatusCodeAndBody , originalResponse , null ) ; </a> 0
<a> assertNotNull ( error ) ; </a> 0
<a> assertEquals ( 403 , error . getRequestStatusCode ( ) ) ; </a> 0
<a> assertEquals ( "Application request limit reached" , error . getErrorMessage ( ) ) ; </a> 0
<a> assertNull ( error . getErrorType ( ) ) ; </a> 0
<a> assertEquals ( 4 , error . getErrorCode ( ) ) ; </a> 0
<a> assertTrue ( error . getBatchRequestResult ( ) instanceof JSONObject ) ; </a> 0
<a> assertEquals ( FacebookRequestError . Category . THROTTLING , error . getCategory ( ) ) ; </a> 0
<a> assertEquals ( 0 , error . getUserActionMessageId ( ) ) ; </a> 0
<a> } </a> 0
<a> public void testSingleServerError ( ) throws JSONException { </a> 0
<a> JSONObject originalResponse = new JSONObject ( ERROR_SINGLE_RESPONSE_SERVER ) ; </a> 0
<a> JSONObject withStatusCodeAndBody = new JSONObject ( ) ; </a> 0
<a> withStatusCodeAndBody . put ( "code" , 500 ) ; </a> 0
<a> withStatusCodeAndBody . put ( "body" , originalResponse ) ; </a> 0
<a> FacebookRequestError error = </a> 0
<a> FacebookRequestError . checkResponseAndCreateError ( withStatusCodeAndBody , originalResponse , null ) ; </a> 0
<a> assertNotNull ( error ) ; </a> 0
<a> assertEquals ( 500 , error . getRequestStatusCode ( ) ) ; </a> 0
<a> assertEquals ( "Some Server Error" , error . getErrorMessage ( ) ) ; </a> 0
<a> assertNull ( error . getErrorType ( ) ) ; </a> 0
<a> assertEquals ( 2 , error . getErrorCode ( ) ) ; </a> 0
<a> assertTrue ( error . getBatchRequestResult ( ) instanceof JSONObject ) ; </a> 0
<a> assertEquals ( FacebookRequestError . Category . SERVER , error . getCategory ( ) ) ; </a> 0
<a> assertEquals ( 0 , error . getUserActionMessageId ( ) ) ; </a> 0
<a> } </a> 0
<a> public void testSinglePermissionError ( ) throws JSONException { </a> 0
<a> JSONObject originalResponse = new JSONObject ( ERROR_SINGLE_RESPONSE_PERMISSION ) ; </a> 0
<a> JSONObject withStatusCodeAndBody = new JSONObject ( ) ; </a> 0
<a> withStatusCodeAndBody . put ( "code" , 400 ) ; </a> 0
<a> withStatusCodeAndBody . put ( "body" , originalResponse ) ; </a> 0
<a> FacebookRequestError error = </a> 0
<a> FacebookRequestError . checkResponseAndCreateError ( withStatusCodeAndBody , originalResponse , null ) ; </a> 0
<a> assertNotNull ( error ) ; </a> 0
<a> assertEquals ( 400 , error . getRequestStatusCode ( ) ) ; </a> 0
<a> assertEquals ( "(#200) Requires extended permission: publish_actions" , error . getErrorMessage ( ) ) ; </a> 0
<a> assertEquals ( "OAuthException" , error . getErrorType ( ) ) ; </a> 0
<a> assertEquals ( 200 , error . getErrorCode ( ) ) ; </a> 0
<a> assertEquals ( FacebookRequestError . INVALID_ERROR_CODE , error . getSubErrorCode ( ) ) ; </a> 0
<a> assertTrue ( error . getBatchRequestResult ( ) instanceof JSONObject ) ; </a> 0
<a> assertEquals ( FacebookRequestError . Category . PERMISSION , error . getCategory ( ) ) ; </a> 0
<a> assertEquals ( R . string . com_facebook_requesterror_permissions , error . getUserActionMessageId ( ) ) ; </a> 0
<a> } </a> 0
<a> public void testSingleWebLoginError ( ) throws JSONException { </a> 0
<a> JSONObject originalResponse = new JSONObject ( ERROR_SINGLE_RESPONSE_WEB_LOGIN ) ; </a> 0
<a> JSONObject withStatusCodeAndBody = new JSONObject ( ) ; </a> 0
<a> withStatusCodeAndBody . put ( "code" , 400 ) ; </a> 0
<a> withStatusCodeAndBody . put ( "body" , originalResponse ) ; </a> 0
<a> FacebookRequestError error = </a> 0
<a> FacebookRequestError . checkResponseAndCreateError ( withStatusCodeAndBody , originalResponse , null ) ; </a> 0
<a> assertNotNull ( error ) ; </a> 0
<a> assertEquals ( 400 , error . getRequestStatusCode ( ) ) ; </a> 0
<a> assertEquals ( "User need to login" , error . getErrorMessage ( ) ) ; </a> 0
<a> assertEquals ( "OAuthException" , error . getErrorType ( ) ) ; </a> 0
<a> assertEquals ( 102 , error . getErrorCode ( ) ) ; </a> 0
<a> assertEquals ( 459 , error . getSubErrorCode ( ) ) ; </a> 0
<a> assertTrue ( error . getBatchRequestResult ( ) instanceof JSONObject ) ; </a> 0
<a> assertEquals ( FacebookRequestError . Category . AUTHENTICATION_RETRY , error . getCategory ( ) ) ; </a> 0
<a> assertEquals ( R . string . com_facebook_requesterror_web_login , error . getUserActionMessageId ( ) ) ; </a> 0
<a> } </a> 0
<a> public void testSingleReloginError ( ) throws JSONException { </a> 0
<a> JSONObject originalResponse = new JSONObject ( ERROR_SINGLE_RESPONSE_RELOGIN ) ; </a> 0
<a> JSONObject withStatusCodeAndBody = new JSONObject ( ) ; </a> 0
<a> withStatusCodeAndBody . put ( "code" , 400 ) ; </a> 0
<a> withStatusCodeAndBody . put ( "body" , originalResponse ) ; </a> 0
<a> FacebookRequestError error = </a> 0
<a> FacebookRequestError . checkResponseAndCreateError ( withStatusCodeAndBody , originalResponse , null ) ; </a> 0
<a> assertNotNull ( error ) ; </a> 0
<a> assertEquals ( 400 , error . getRequestStatusCode ( ) ) ; </a> 0
<a> assertEquals ( "User need to relogin" , error . getErrorMessage ( ) ) ; </a> 0
<a> assertEquals ( "OAuthException" , error . getErrorType ( ) ) ; </a> 0
<a> assertEquals ( 102 , error . getErrorCode ( ) ) ; </a> 0
<a> assertEquals ( FacebookRequestError . INVALID_ERROR_CODE , error . getSubErrorCode ( ) ) ; </a> 0
<a> assertTrue ( error . getBatchRequestResult ( ) instanceof JSONObject ) ; </a> 0
<a> assertEquals ( FacebookRequestError . Category . AUTHENTICATION_REOPEN_SESSION , error . getCategory ( ) ) ; </a> 0
<a> assertEquals ( R . string . com_facebook_requesterror_reconnect , error . getUserActionMessageId ( ) ) ; </a> 0
<a> } </a> 0
<a> public void testSingleReloginDeletedAppError ( ) throws JSONException { </a> 0
<a> JSONObject originalResponse = new JSONObject ( ERROR_SINGLE_RESPONSE_RELOGIN_DELETED_APP ) ; </a> 0
<a> JSONObject withStatusCodeAndBody = new JSONObject ( ) ; </a> 0
<a> withStatusCodeAndBody . put ( "code" , 400 ) ; </a> 0
<a> withStatusCodeAndBody . put ( "body" , originalResponse ) ; </a> 0
<a> FacebookRequestError error = </a> 0
<a> FacebookRequestError . checkResponseAndCreateError ( withStatusCodeAndBody , originalResponse , null ) ; </a> 0
<a> assertNotNull ( error ) ; </a> 0
<a> assertEquals ( 400 , error . getRequestStatusCode ( ) ) ; </a> 0
<a> assertEquals ( "User need to relogin" , error . getErrorMessage ( ) ) ; </a> 0
<a> assertEquals ( "OAuthException" , error . getErrorType ( ) ) ; </a> 0
<a> assertEquals ( 190 , error . getErrorCode ( ) ) ; </a> 0
<a> assertEquals ( 458 , error . getSubErrorCode ( ) ) ; </a> 0
<a> assertTrue ( error . getBatchRequestResult ( ) instanceof JSONObject ) ; </a> 0
<a> assertEquals ( FacebookRequestError . Category . AUTHENTICATION_REOPEN_SESSION , error . getCategory ( ) ) ; </a> 0
<a> assertEquals ( R . string . com_facebook_requesterror_relogin , error . getUserActionMessageId ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import java . util . Date ; </a> 0
<a> public class GraphRequestTests extends FacebookTestCase { </a> 0
<a> @ LargeTest </a> 0
<a> public void testCommentRoundTrip ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> GraphObject status = createStatusUpdate ( ) ; </a> 0
<a> GraphObject createdStatus = batchCreateAndGet ( session , "me/feed" , status , null , GraphObject . class ) ; </a> 0
<a> String statusID = ( String ) createdStatus . getProperty ( "id" ) ; </a> 0
<a> GraphObject comment = GraphObject . Factory . create ( ) ; </a> 0
<a> final String commentMessage = "It truly is a wonderful status update." ; </a> 0
<a> comment . setProperty ( "message" , commentMessage ) ; </a> 0
<a> GraphObject createdComment1 = batchCreateAndGet ( session , statusID + "/comments" , comment , null , </a> 0
<a> GraphObject . class ) ; </a> 0
<a> assertNotNull ( createdComment1 ) ; </a> 0
<a> String comment1ID = ( String ) createdComment1 . getProperty ( "id" ) ; </a> 0
<a> String comment1Message = ( String ) createdComment1 . getProperty ( "message" ) ; </a> 0
<a> assertNotNull ( comment1ID ) ; </a> 0
<a> assertNotNull ( comment1Message ) ; </a> 0
<a> assertEquals ( commentMessage , comment1Message ) ; </a> 0
<a> createdComment1 . removeProperty ( "id" ) ; </a> 0
<a> GraphObject createdComment2 = batchCreateAndGet ( session , statusID + "/comments" , createdComment1 , null , </a> 0
<a> GraphObject . class ) ; </a> 0
<a> assertNotNull ( createdComment2 ) ; </a> 0
<a> String comment2ID = ( String ) createdComment2 . getProperty ( "id" ) ; </a> 0
<a> String comment2Message = ( String ) createdComment2 . getProperty ( "message" ) ; </a> 0
<a> assertNotNull ( comment2ID ) ; </a> 0
<a> assertFalse ( comment1ID . equals ( comment2ID ) ) ; </a> 0
<a> assertNotNull ( comment2Message ) ; </a> 0
<a> assertEquals ( commentMessage , comment2Message ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testEventRoundTrip ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUserAndPermissions ( null , "create_event" ) ; </a> 0
<a> GraphObject event = GraphObject . Factory . create ( ) ; </a> 0
<a> Date startTime = new Date ( 130 , 2 , 17 , 12 , 34 , 56 ) ; </a> 0
<a> event . setProperty ( "name" , "My awesome St. Patrick's Day party on " + startTime . toString ( ) ) ; </a> 0
<a> final String eventDescription = "This is a great event. You should all come." ; </a> 0
<a> event . setProperty ( "description" , eventDescription ) ; </a> 0
<a> Date endTime = new Date ( startTime . getTime ( ) + 3600 * 1000 ) ; </a> 0
<a> event . setProperty ( "start_time" , startTime ) ; </a> 0
<a> event . setProperty ( "end_time" , endTime ) ; </a> 0
<a> event . setProperty ( "location" , "My house" ) ; </a> 0
<a> GraphObject event1 = batchCreateAndGet ( session , "me/events" , event , null , GraphObject . class ) ; </a> 0
<a> assertNotNull ( event1 ) ; </a> 0
<a> assertEquals ( eventDescription , event1 . getProperty ( "description" ) ) ; </a> 0
<a> event1 . removeProperty ( "id" ) ; </a> 0
<a> GraphObject event2 = batchCreateAndGet ( session , "me/events" , event1 , null , GraphObject . class ) ; </a> 0
<a> assertNotNull ( event2 ) ; </a> 0
<a> assertEquals ( eventDescription , event2 . getProperty ( "description" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . location . Location ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import com . facebook . model . * ; </a> 0
<a> import java . io . File ; </a> 0
<a> import java . io . FileOutputStream ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . HttpURLConnection ; </a> 0
<a> import java . net . URISyntaxException ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class RequestTests extends FacebookTestCase { </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreateRequest ( ) { </a> 0
<a> Request request = new Request ( ) ; </a> 0
<a> assertTrue ( request != null ) ; </a> 0
<a> assertEquals ( HttpMethod . GET , request . getHttpMethod ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreatePostRequest ( ) { </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( ) ; </a> 0
<a> Request request = Request . newPostRequest ( null , "me/statuses" , graphObject , null ) ; </a> 0
<a> assertTrue ( request != null ) ; </a> 0
<a> assertEquals ( HttpMethod . POST , request . getHttpMethod ( ) ) ; </a> 0
<a> assertEquals ( "me/statuses" , request . getGraphPath ( ) ) ; </a> 0
<a> assertEquals ( graphObject , request . getGraphObject ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreateMeRequest ( ) { </a> 0
<a> Request request = Request . newMeRequest ( null , null ) ; </a> 0
<a> assertTrue ( request != null ) ; </a> 0
<a> assertEquals ( HttpMethod . GET , request . getHttpMethod ( ) ) ; </a> 0
<a> assertEquals ( "me" , request . getGraphPath ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreateMyFriendsRequest ( ) { </a> 0
<a> Request request = Request . newMyFriendsRequest ( null , null ) ; </a> 0
<a> assertTrue ( request != null ) ; </a> 0
<a> assertEquals ( HttpMethod . GET , request . getHttpMethod ( ) ) ; </a> 0
<a> assertEquals ( "me/friends" , request . getGraphPath ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreateUploadPhotoRequest ( ) { </a> 0
<a> Bitmap image = Bitmap . createBitmap ( 128 , 128 , Bitmap . Config . ALPHA_8 ) ; </a> 0
<a> Request request = Request . newUploadPhotoRequest ( null , image , null ) ; </a> 0
<a> assertTrue ( request != null ) ; </a> 0
<a> Bundle parameters = request . getParameters ( ) ; </a> 0
<a> assertTrue ( parameters != null ) ; </a> 0
<a> assertTrue ( parameters . containsKey ( "picture" ) ) ; </a> 0
<a> assertEquals ( image , parameters . getParcelable ( "picture" ) ) ; </a> 0
<a> assertEquals ( "me/photos" , request . getGraphPath ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreatePlacesSearchRequestWithLocation ( ) { </a> 0
<a> Location location = new Location ( "" ) ; </a> 0
<a> location . setLatitude ( 47.6204 ) ; </a> 0
<a> location . setLongitude ( - 122.3491 ) ; </a> 0
<a> Request request = Request . newPlacesSearchRequest ( null , location , 1000 , 50 , null , null ) ; </a> 0
<a> assertTrue ( request != null ) ; </a> 0
<a> assertEquals ( HttpMethod . GET , request . getHttpMethod ( ) ) ; </a> 0
<a> assertEquals ( "search" , request . getGraphPath ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreatePlacesSearchRequestWithSearchText ( ) { </a> 0
<a> Request request = Request . newPlacesSearchRequest ( null , null , 1000 , 50 , "Starbucks" , null ) ; </a> 0
<a> assertTrue ( request != null ) ; </a> 0
<a> assertEquals ( HttpMethod . GET , request . getHttpMethod ( ) ) ; </a> 0
<a> assertEquals ( "search" , request . getGraphPath ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreatePlacesSearchRequestRequiresLocationOrSearchText ( ) { </a> 0
<a> try { </a> 0
<a> Request request = Request . newPlacesSearchRequest ( null , null , 1000 , 50 , null , null ) ; </a> 0
<a> fail ( "expected exception" ) ; </a> 0
<a> } catch ( FacebookException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testSetHttpMethodToNilGivesDefault ( ) { </a> 0
<a> Request request = new Request ( ) ; </a> 0
<a> assertEquals ( HttpMethod . GET , request . getHttpMethod ( ) ) ; </a> 0
<a> request . setHttpMethod ( null ) ; </a> 0
<a> assertEquals ( HttpMethod . GET , request . getHttpMethod ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteBatchWithNullRequestsThrows ( ) { </a> 0
<a> try { </a> 0
<a> Request . executeBatchAndWait ( ( Request [ ] ) null ) ; </a> 0
<a> fail ( "expected NullPointerException" ) ; </a> 0
<a> } catch ( NullPointerException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteBatchWithZeroRequestsThrows ( ) { </a> 0
<a> try { </a> 0
<a> Request . executeBatchAndWait ( new Request [ ] { } ) ; </a> 0
<a> fail ( "expected IllegalArgumentException" ) ; </a> 0
<a> } catch ( IllegalArgumentException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteBatchWithNullRequestThrows ( ) { </a> 0
<a> try { </a> 0
<a> Request . executeBatchAndWait ( new Request [ ] { null } ) ; </a> 0
<a> fail ( "expected NullPointerException" ) ; </a> 0
<a> } catch ( NullPointerException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testToHttpConnectionWithNullRequestsThrows ( ) { </a> 0
<a> try { </a> 0
<a> Request . toHttpConnection ( ( Request [ ] ) null ) ; </a> 0
<a> fail ( "expected NullPointerException" ) ; </a> 0
<a> } catch ( NullPointerException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testToHttpConnectionWithZeroRequestsThrows ( ) { </a> 0
<a> try { </a> 0
<a> Request . toHttpConnection ( new Request [ ] { } ) ; </a> 0
<a> fail ( "expected IllegalArgumentException" ) ; </a> 0
<a> } catch ( IllegalArgumentException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testToHttpConnectionWithNullRequestThrows ( ) { </a> 0
<a> try { </a> 0
<a> Request . toHttpConnection ( new Request [ ] { null } ) ; </a> 0
<a> fail ( "expected NullPointerException" ) ; </a> 0
<a> } catch ( NullPointerException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testSingleGetToHttpRequest ( ) throws Exception { </a> 0
<a> Request requestMe = new Request ( null , "TourEiffel" ) ; </a> 0
<a> HttpURLConnection connection = Request . toHttpConnection ( requestMe ) ; </a> 0
<a> assertTrue ( connection != null ) ; </a> 0
<a> assertEquals ( "GET" , connection . getRequestMethod ( ) ) ; </a> 0
<a> assertEquals ( "/TourEiffel" , connection . getURL ( ) . getPath ( ) ) ; </a> 0
<a> assertTrue ( connection . getRequestProperty ( "User-Agent" ) . startsWith ( "FBAndroidSDK" ) ) ; </a> 0
<a> Uri uri = Uri . parse ( connection . getURL ( ) . toString ( ) ) ; </a> 0
<a> assertEquals ( "android" , uri . getQueryParameter ( "sdk" ) ) ; </a> 0
<a> assertEquals ( "json" , uri . getQueryParameter ( "format" ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteSingleGet ( ) { </a> 0
<a> Request request = new Request ( null , "TourEiffel" ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertTrue ( response != null ) ; </a> 0
<a> assertTrue ( response . getError ( ) == null ) ; </a> 0
<a> assertTrue ( response . getGraphObject ( ) != null ) ; </a> 0
<a> GraphPlace graphPlace = response . getGraphObjectAs ( GraphPlace . class ) ; </a> 0
<a> assertEquals ( "Paris" , graphPlace . getLocation ( ) . getCity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteSingleGetUsingHttpURLConnection ( ) throws IOException { </a> 0
<a> Request request = new Request ( null , "TourEiffel" ) ; </a> 0
<a> HttpURLConnection connection = Request . toHttpConnection ( request ) ; </a> 0
<a> List < Response > responses = Request . executeConnectionAndWait ( connection , Arrays . asList ( new Request [ ] { request } ) ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertEquals ( 1 , responses . size ( ) ) ; </a> 0
<a> Response response = responses . get ( 0 ) ; </a> 0
<a> assertTrue ( response != null ) ; </a> 0
<a> assertTrue ( response . getError ( ) == null ) ; </a> 0
<a> assertTrue ( response . getGraphObject ( ) != null ) ; </a> 0
<a> GraphPlace graphPlace = response . getGraphObjectAs ( GraphPlace . class ) ; </a> 0
<a> assertEquals ( "Paris" , graphPlace . getLocation ( ) . getCity ( ) ) ; </a> 0
<a> int code = connection . getResponseCode ( ) ; </a> 0
<a> assertEquals ( 200 , code ) ; </a> 0
<a> assertTrue ( connection . getHeaderFields ( ) . keySet ( ) . contains ( "Content-Length" ) ) ; </a> 0
<a> connection . disconnect ( ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testFacebookErrorResponseCreatesError ( ) { </a> 0
<a> Request request = new Request ( null , "somestringthatshouldneverbeavalidfobjectid" ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertTrue ( response != null ) ; </a> 0
<a> FacebookRequestError error = response . getError ( ) ; </a> 0
<a> assertNotNull ( error ) ; </a> 0
<a> FacebookException exception = error . getException ( ) ; </a> 0
<a> assertNotNull ( exception ) ; </a> 0
<a> assertTrue ( exception instanceof FacebookServiceException ) ; </a> 0
<a> assertNotNull ( error . getErrorType ( ) ) ; </a> 0
<a> assertTrue ( error . getErrorCode ( ) != FacebookRequestError . INVALID_ERROR_CODE ) ; </a> 0
<a> assertNotNull ( error . getRequestResultBody ( ) ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testFacebookSuccessResponseWithErrorCodeCreatesError ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Request request = Request . newRestRequest ( session , "auth.extendSSOAccessToken" , null , null ) ; </a> 0
<a> assertNotNull ( request ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertTrue ( response != null ) ; </a> 0
<a> FacebookRequestError error = response . getError ( ) ; </a> 0
<a> assertNotNull ( error ) ; </a> 0
<a> assertTrue ( error . getException ( ) instanceof FacebookServiceException ) ; </a> 0
<a> assertTrue ( error . getErrorCode ( ) != FacebookRequestError . INVALID_ERROR_CODE ) ; </a> 0
<a> assertNotNull ( error . getRequestResultBody ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testRequestWithUnopenedSessionFails ( ) { </a> 0
<a> TestSession session = getTestSessionWithSharedUser ( null ) ; </a> 0
<a> Request request = new Request ( session , "me" ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNotNull ( response . getError ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteRequestMe ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Request request = Request . newMeRequest ( session , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> validateMeResponse ( session , response ) ; </a> 0
<a> } </a> 0
<a> static void validateMeResponse ( TestSession session , Response response ) { </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> GraphUser me = response . getGraphObjectAs ( GraphUser . class ) ; </a> 0
<a> assertNotNull ( me ) ; </a> 0
<a> assertEquals ( session . getTestUserId ( ) , me . getId ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteMyFriendsRequest ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Request request = Request . newMyFriendsRequest ( session , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> validateMyFriendsResponse ( session , response ) ; </a> 0
<a> } </a> 0
<a> static void validateMyFriendsResponse ( TestSession session , Response response ) { </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> GraphMultiResult graphResult = response . getGraphObjectAs ( GraphMultiResult . class ) ; </a> 0
<a> assertNotNull ( graphResult ) ; </a> 0
<a> List < GraphObject > results = graphResult . getData ( ) ; </a> 0
<a> assertNotNull ( results ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecutePlaceRequestWithLocation ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Location location = new Location ( "" ) ; </a> 0
<a> location . setLatitude ( 47.6204 ) ; </a> 0
<a> location . setLongitude ( - 122.3491 ) ; </a> 0
<a> Request request = Request . newPlacesSearchRequest ( session , location , 5 , 5 , null , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> GraphMultiResult graphResult = response . getGraphObjectAs ( GraphMultiResult . class ) ; </a> 0
<a> assertNotNull ( graphResult ) ; </a> 0
<a> List < GraphObject > results = graphResult . getData ( ) ; </a> 0
<a> assertNotNull ( results ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecutePlaceRequestWithSearchText ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Request request = Request . newPlacesSearchRequest ( session , null , 1000 , 5 , "Starbucks" , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> GraphMultiResult graphResult = response . getGraphObjectAs ( GraphMultiResult . class ) ; </a> 0
<a> assertNotNull ( graphResult ) ; </a> 0
<a> List < GraphObject > results = graphResult . getData ( ) ; </a> 0
<a> assertNotNull ( results ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecutePlaceRequestWithLocationAndSearchText ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Location location = new Location ( "" ) ; </a> 0
<a> location . setLatitude ( 47.6204 ) ; </a> 0
<a> location . setLongitude ( - 122.3491 ) ; </a> 0
<a> Request request = Request . newPlacesSearchRequest ( session , location , 1000 , 5 , "Starbucks" , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> GraphMultiResult graphResult = response . getGraphObjectAs ( GraphMultiResult . class ) ; </a> 0
<a> assertNotNull ( graphResult ) ; </a> 0
<a> List < GraphObject > results = graphResult . getData ( ) ; </a> 0
<a> assertNotNull ( results ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteUploadPhoto ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Bitmap image = createTestBitmap ( 128 ) ; </a> 0
<a> Request request = Request . newUploadPhotoRequest ( session , image , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> GraphObject result = response . getGraphObject ( ) ; </a> 0
<a> assertNotNull ( result ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testExecuteUploadPhotoViaFile ( ) throws IOException { </a> 0
<a> File outputFile = null ; </a> 0
<a> FileOutputStream outStream = null ; </a> 0
<a> try { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Bitmap image = createTestBitmap ( 128 ) ; </a> 0
<a> File outputDir = getActivity ( ) . getCacheDir ( ) ; </a> 0
<a> outputFile = File . createTempFile ( "prefix" , "extension" , outputDir ) ; </a> 0
<a> outStream = new FileOutputStream ( outputFile ) ; </a> 0
<a> image . compress ( Bitmap . CompressFormat . PNG , 100 , outStream ) ; </a> 0
<a> outStream . close ( ) ; </a> 0
<a> outStream = null ; </a> 0
<a> Request request = Request . newUploadPhotoRequest ( session , outputFile , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> GraphObject result = response . getGraphObject ( ) ; </a> 0
<a> assertNotNull ( result ) ; </a> 0
<a> } finally { </a> 0
<a> if ( outStream != null ) { </a> 0
<a> outStream . close ( ) ; </a> 0
<a> } </a> 0
<a> if ( outputFile != null ) { </a> 0
<a> outputFile . delete ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testUploadVideoFile ( ) throws IOException , URISyntaxException { </a> 0
<a> File tempFile = null ; </a> 0
<a> try { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> tempFile = createTempFileFromAsset ( "DarkScreen.mov" ) ; </a> 0
<a> Request request = Request . newUploadVideoRequest ( session , tempFile , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> GraphObject result = response . getGraphObject ( ) ; </a> 0
<a> assertNotNull ( result ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> return ; </a> 0
<a> } finally { </a> 0
<a> if ( tempFile != null ) { </a> 0
<a> tempFile . delete ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testPostStatusUpdate ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> GraphObject statusUpdate = createStatusUpdate ( ) ; </a> 0
<a> GraphObject retrievedStatusUpdate = postGetAndAssert ( session , "me/feed" , statusUpdate ) ; </a> 0
<a> assertEquals ( statusUpdate . getProperty ( "message" ) , retrievedStatusUpdate . getProperty ( "message" ) ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testRestMethodGetUser ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> String testUserId = session . getTestUserId ( ) ; </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> parameters . putString ( "uids" , testUserId ) ; </a> 0
<a> parameters . putString ( "fields" , "uid,name" ) ; </a> 0
<a> Request request = Request . newRestRequest ( session , "users.getInfo" , parameters , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> GraphObjectList < GraphObject > graphObjects = response . getGraphObjectList ( ) ; </a> 0
<a> assertNotNull ( graphObjects ) ; </a> 0
<a> assertEquals ( 1 , graphObjects . size ( ) ) ; </a> 0
<a> GraphObject user = graphObjects . get ( 0 ) ; </a> 0
<a> assertNotNull ( user ) ; </a> 0
<a> assertEquals ( testUserId , user . getProperty ( "uid" ) . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCallbackIsCalled ( ) { </a> 0
<a> Request request = new Request ( null , "4" ) ; </a> 0
<a> final ArrayList < Boolean > calledBack = new ArrayList < Boolean > ( ) ; </a> 0
<a> request . setCallback ( new Request . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> calledBack . add ( true ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertTrue ( calledBack . size ( ) == 1 ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testBatchTimeoutIsApplied ( ) { </a> 0
<a> Request request = new Request ( null , "me" ) ; </a> 0
<a> RequestBatch batch = new RequestBatch ( request ) ; </a> 0
<a> batch . setTimeout ( 1 ) ; </a> 0
<a> List < Response > responses = Request . executeBatchAndWait ( batch ) ; </a> 0
<a> assertNotNull ( responses ) ; </a> 0
<a> assertTrue ( responses . size ( ) == 1 ) ; </a> 0
<a> Response response = responses . get ( 0 ) ; </a> 0
<a> assertNotNull ( response ) ; </a> 0
<a> assertNotNull ( response . getError ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testBatchTimeoutCantBeNegative ( ) { </a> 0
<a> try { </a> 0
<a> RequestBatch batch = new RequestBatch ( ) ; </a> 0
<a> batch . setTimeout ( - 1 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( IllegalArgumentException ex ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantSetBothGraphPathAndRestMethod ( ) { </a> 0
<a> Request request = new Request ( ) ; </a> 0
<a> request . setGraphPath ( "me" ) ; </a> 0
<a> request . setRestMethod ( "amethod" ) ; </a> 0
<a> request . setCallback ( new ExpectFailureCallback ( ) ) ; </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( request ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccess ( 1 ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testClosedSessionDoesntAppendAccessToken ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> session . close ( ) ; </a> 0
<a> Request request = new Request ( session , "me" , null , null , new ExpectFailureCallback ( ) ) ; </a> 0
<a> TestRequestAsyncTask task = new TestRequestAsyncTask ( request ) ; </a> 0
<a> task . executeOnBlockerThread ( ) ; </a> 0
<a> waitAndAssertSuccess ( 1 ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantUseComplexParameterInGetRequest ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> parameters . putShortArray ( "foo" , new short [ 1 ] ) ; </a> 0
<a> Request request = new Request ( session , "me" , parameters , HttpMethod . GET , new ExpectFailureCallback ( ) ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> FacebookRequestError error = response . getError ( ) ; </a> 0
<a> assertNotNull ( error ) ; </a> 0
<a> FacebookException exception = error . getException ( ) ; </a> 0
<a> assertNotNull ( exception ) ; </a> 0
<a> assertTrue ( exception . getMessage ( ) . contains ( "short[]" ) ) ; </a> 0
<a> } </a> 0
<a> private final Location SEATTLE_LOCATION = new Location ( "" ) { </a> 0
<a> { </a> 0
<a> setLatitude ( 47.6097 ) ; </a> 0
<a> setLongitude ( - 122.3331 ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> @ LargeTest </a> 0
<a> public void testPaging ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> final List < GraphPlace > returnedPlaces = new ArrayList < GraphPlace > ( ) ; </a> 0
<a> Request request = Request </a> 0
<a> . newPlacesSearchRequest ( session , SEATTLE_LOCATION , 1000 , 5 , null , new Request . GraphPlaceListCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( List < GraphPlace > places , Response response ) { </a> 0
<a> returnedPlaces . addAll ( places ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> assertNotNull ( response . getGraphObject ( ) ) ; </a> 0
<a> assertNotSame ( 0 , returnedPlaces . size ( ) ) ; </a> 0
<a> returnedPlaces . clear ( ) ; </a> 0
<a> Request nextRequest = response . getRequestForPagedResults ( Response . PagingDirection . NEXT ) ; </a> 0
<a> assertNotNull ( nextRequest ) ; </a> 0
<a> nextRequest . setCallback ( request . getCallback ( ) ) ; </a> 0
<a> response = nextRequest . executeAndWait ( ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> assertNotNull ( response . getGraphObject ( ) ) ; </a> 0
<a> assertNotSame ( 0 , returnedPlaces . size ( ) ) ; </a> 0
<a> returnedPlaces . clear ( ) ; </a> 0
<a> Request previousRequest = response . getRequestForPagedResults ( Response . PagingDirection . PREVIOUS ) ; </a> 0
<a> assertNotNull ( previousRequest ) ; </a> 0
<a> previousRequest . setCallback ( request . getCallback ( ) ) ; </a> 0
<a> response = previousRequest . executeAndWait ( ) ; </a> 0
<a> assertNull ( response . getError ( ) ) ; </a> 0
<a> assertNotNull ( response . getGraphObject ( ) ) ; </a> 0
<a> assertNotSame ( 0 , returnedPlaces . size ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testRequestWithClosedSessionThrowsException ( ) { </a> 0
<a> TestSession session = getTestSessionWithSharedUser ( ) ; </a> 0
<a> assertFalse ( session . isOpened ( ) ) ; </a> 0
<a> Request request = new Request ( session , "4" ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> assertNotNull ( response . getError ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . content . IntentFilter ; </a> 0
<a> import android . support . v4 . content . LocalBroadcastManager ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class SessionTests extends SessionTestsBase { </a> 0
<a> @ Override </a> 0
<a> protected void setUp ( ) throws Exception { </a> 0
<a> super . setUp ( ) ; </a> 0
<a> new SharedPreferencesTokenCachingStrategy ( getActivity ( ) ) . clear ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testFailNullArguments ( ) { </a> 0
<a> try { </a> 0
<a> new Session ( null ) ; </a> 0
<a> assertFalse ( true ) ; </a> 0
<a> } catch ( NullPointerException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testActiveSessionChangeRegistration ( ) { </a> 0
<a> final WaitForBroadcastReceiver receiver0 = new WaitForBroadcastReceiver ( ) ; </a> 0
<a> final WaitForBroadcastReceiver receiver1 = new WaitForBroadcastReceiver ( ) ; </a> 0
<a> final WaitForBroadcastReceiver receiver2 = new WaitForBroadcastReceiver ( ) ; </a> 0
<a> final LocalBroadcastManager broadcastManager = LocalBroadcastManager . getInstance ( getActivity ( ) ) ; </a> 0
<a> try { </a> 0
<a> Runnable initialize0 = new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> broadcastManager . registerReceiver ( receiver0 , getActiveSessionAllFilter ( ) ) ; </a> 0
<a> broadcastManager . registerReceiver ( receiver1 , </a> 0
<a> getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_SET ) ) ; </a> 0
<a> broadcastManager . registerReceiver ( receiver1 , </a> 0
<a> getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_OPENED ) ) ; </a> 0
<a> broadcastManager . registerReceiver ( receiver1 , </a> 0
<a> getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_CLOSED ) ) ; </a> 0
<a> broadcastManager . registerReceiver ( receiver2 , </a> 0
<a> getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_OPENED ) ) ; </a> 0
<a> broadcastManager . registerReceiver ( receiver2 , </a> 0
<a> getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_CLOSED ) ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> runOnBlockerThread ( initialize0 , true ) ; </a> 0
<a> WaitForBroadcastReceiver . incrementExpectCounts ( receiver0 , receiver1 , receiver2 ) ; </a> 0
<a> Session . postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_OPENED ) ; </a> 0
<a> WaitForBroadcastReceiver . waitForExpectedCalls ( receiver0 , receiver1 , receiver2 ) ; </a> 0
<a> WaitForBroadcastReceiver . incrementExpectCounts ( receiver0 , receiver1 , receiver2 ) ; </a> 0
<a> Session . postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_CLOSED ) ; </a> 0
<a> WaitForBroadcastReceiver . waitForExpectedCalls ( receiver0 , receiver1 , receiver2 ) ; </a> 0
<a> WaitForBroadcastReceiver . incrementExpectCounts ( receiver0 , receiver1 ) ; </a> 0
<a> Session . postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_SET ) ; </a> 0
<a> WaitForBroadcastReceiver . waitForExpectedCalls ( receiver0 , receiver1 ) ; </a> 0
<a> receiver0 . incrementExpectCount ( ) ; </a> 0
<a> Session . postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_UNSET ) ; </a> 0
<a> receiver0 . waitForExpectedCalls ( ) ; </a> 0
<a> broadcastManager . unregisterReceiver ( receiver1 ) ; </a> 0
<a> WaitForBroadcastReceiver . incrementExpectCounts ( receiver0 , receiver2 ) ; </a> 0
<a> Session . postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_OPENED ) ; </a> 0
<a> WaitForBroadcastReceiver . waitForExpectedCalls ( receiver0 , receiver2 ) ; </a> 0
<a> WaitForBroadcastReceiver . incrementExpectCounts ( receiver0 , receiver2 ) ; </a> 0
<a> Session . postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_CLOSED ) ; </a> 0
<a> WaitForBroadcastReceiver . waitForExpectedCalls ( receiver0 , receiver2 ) ; </a> 0
<a> receiver0 . incrementExpectCount ( ) ; </a> 0
<a> Session . postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_SET ) ; </a> 0
<a> receiver0 . waitForExpectedCalls ( ) ; </a> 0
<a> receiver0 . incrementExpectCount ( ) ; </a> 0
<a> Session . postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_UNSET ) ; </a> 0
<a> receiver0 . waitForExpectedCalls ( ) ; </a> 0
<a> broadcastManager . unregisterReceiver ( receiver0 ) ; </a> 0
<a> Runnable initialize1 = new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> broadcastManager . registerReceiver ( receiver1 , </a> 0
<a> getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_OPENED ) ) ; </a> 0
<a> broadcastManager . registerReceiver ( receiver1 , </a> 0
<a> getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_OPENED ) ) ; </a> 0
<a> broadcastManager . registerReceiver ( receiver1 , </a> 0
<a> getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_OPENED ) ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> runOnBlockerThread ( initialize1 , true ) ; </a> 0
<a> receiver1 . incrementExpectCount ( 3 ) ; </a> 0
<a> receiver2 . incrementExpectCount ( ) ; </a> 0
<a> Session . postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_OPENED ) ; </a> 0
<a> receiver1 . waitForExpectedCalls ( ) ; </a> 0
<a> receiver2 . waitForExpectedCalls ( ) ; </a> 0
<a> receiver2 . incrementExpectCount ( ) ; </a> 0
<a> Session . postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_CLOSED ) ; </a> 0
<a> receiver2 . waitForExpectedCalls ( ) ; </a> 0
<a> Session . postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_SET ) ; </a> 0
<a> Session . postActiveSessionAction ( Session . ACTION_ACTIVE_SESSION_UNSET ) ; </a> 0
<a> closeBlockerAndAssertSuccess ( ) ; </a> 0
<a> } finally { </a> 0
<a> broadcastManager . unregisterReceiver ( receiver0 ) ; </a> 0
<a> broadcastManager . unregisterReceiver ( receiver1 ) ; </a> 0
<a> broadcastManager . unregisterReceiver ( receiver2 ) ; </a> 0
<a> Session . setActiveSession ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testSetActiveSession ( ) { </a> 0
<a> Session . setActiveSession ( null ) ; </a> 0
<a> final WaitForBroadcastReceiver receiverOpened = new WaitForBroadcastReceiver ( ) ; </a> 0
<a> final WaitForBroadcastReceiver receiverClosed = new WaitForBroadcastReceiver ( ) ; </a> 0
<a> final WaitForBroadcastReceiver receiverSet = new WaitForBroadcastReceiver ( ) ; </a> 0
<a> final WaitForBroadcastReceiver receiverUnset = new WaitForBroadcastReceiver ( ) ; </a> 0
<a> final LocalBroadcastManager broadcastManager = LocalBroadcastManager . getInstance ( getActivity ( ) ) ; </a> 0
<a> try { </a> 0
<a> Runnable initializeOnBlockerThread = new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> broadcastManager . registerReceiver ( receiverOpened , </a> 0
<a> getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_OPENED ) ) ; </a> 0
<a> broadcastManager . registerReceiver ( receiverClosed , </a> 0
<a> getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_CLOSED ) ) ; </a> 0
<a> broadcastManager . registerReceiver ( receiverSet , </a> 0
<a> getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_SET ) ) ; </a> 0
<a> broadcastManager . registerReceiver ( receiverUnset , </a> 0
<a> getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_UNSET ) ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> runOnBlockerThread ( initializeOnBlockerThread , true ) ; </a> 0
<a> assertEquals ( null , Session . getActiveSession ( ) ) ; </a> 0
<a> Session . setActiveSession ( null ) ; </a> 0
<a> assertEquals ( null , Session . getActiveSession ( ) ) ; </a> 0
<a> Session session0 = new Session . Builder ( getActivity ( ) ) . </a> 0
<a> setApplicationId ( "FakeAppId" ) . </a> 0
<a> setTokenCachingStrategy ( new MockTokenCachingStrategy ( ) ) . </a> 0
<a> build ( ) ; </a> 0
<a> assertEquals ( SessionState . CREATED_TOKEN_LOADED , session0 . getState ( ) ) ; </a> 0
<a> receiverSet . incrementExpectCount ( ) ; </a> 0
<a> Session . setActiveSession ( session0 ) ; </a> 0
<a> assertEquals ( session0 , Session . getActiveSession ( ) ) ; </a> 0
<a> receiverSet . waitForExpectedCalls ( ) ; </a> 0
<a> receiverOpened . incrementExpectCount ( ) ; </a> 0
<a> session0 . openForRead ( null ) ; </a> 0
<a> receiverOpened . waitForExpectedCalls ( ) ; </a> 0
<a> Session . setActiveSession ( session0 ) ; </a> 0
<a> assertEquals ( session0 , Session . getActiveSession ( ) ) ; </a> 0
<a> WaitForBroadcastReceiver . incrementExpectCounts ( receiverClosed , receiverUnset , receiverSet , receiverOpened ) ; </a> 0
<a> Session session1 = new Session . Builder ( getActivity ( ) ) . </a> 0
<a> setApplicationId ( "FakeAppId" ) . </a> 0
<a> setTokenCachingStrategy ( new MockTokenCachingStrategy ( ) ) . </a> 0
<a> build ( ) ; </a> 0
<a> assertEquals ( SessionState . CREATED_TOKEN_LOADED , session1 . getState ( ) ) ; </a> 0
<a> session1 . openForRead ( null ) ; </a> 0
<a> assertEquals ( SessionState . OPENED , session1 . getState ( ) ) ; </a> 0
<a> Session . setActiveSession ( session1 ) ; </a> 0
<a> WaitForBroadcastReceiver . waitForExpectedCalls ( receiverClosed , receiverUnset , receiverSet , receiverOpened ) ; </a> 0
<a> assertEquals ( SessionState . CLOSED , session0 . getState ( ) ) ; </a> 0
<a> assertEquals ( session1 , Session . getActiveSession ( ) ) ; </a> 0
<a> closeBlockerAndAssertSuccess ( ) ; </a> 0
<a> } finally { </a> 0
<a> broadcastManager . unregisterReceiver ( receiverOpened ) ; </a> 0
<a> broadcastManager . unregisterReceiver ( receiverClosed ) ; </a> 0
<a> broadcastManager . unregisterReceiver ( receiverSet ) ; </a> 0
<a> broadcastManager . unregisterReceiver ( receiverUnset ) ; </a> 0
<a> Session . setActiveSession ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testOpenSuccess ( ) { </a> 0
<a> ArrayList < String > permissions = new ArrayList < String > ( ) ; </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> AccessToken openToken = AccessToken </a> 0
<a> . createFromString ( "A token of thanks" , permissions , AccessTokenSource . TEST_USER ) ; </a> 0
<a> assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> session . addAuthorizeResult ( openToken ) ; </a> 0
<a> session . openForRead ( new Session . OpenRequest ( getActivity ( ) ) . setCallback ( statusRecorder ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> verifySessionHasToken ( session , openToken ) ; </a> 0
<a> session . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) != null ) ; </a> 0
<a> assertEquals ( openToken . getToken ( ) , TokenCachingStrategy . getToken ( cache . getSavedState ( ) ) ) ; </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) == null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testOpenForPublishSuccess ( ) { </a> 0
<a> ArrayList < String > permissions = new ArrayList < String > ( ) ; </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> AccessToken openToken = AccessToken </a> 0
<a> . createFromString ( "A token of thanks" , permissions , AccessTokenSource . TEST_USER ) ; </a> 0
<a> assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> session . addAuthorizeResult ( openToken ) ; </a> 0
<a> session . openForPublish ( new Session . OpenRequest ( getActivity ( ) ) . setCallback ( statusRecorder ) . </a> 0
<a> setPermissions ( Arrays . asList ( new String [ ] { </a> 0
<a> "publish_something" , </a> 0
<a> "manage_something" , </a> 0
<a> "ads_management" , </a> 0
<a> "create_event" , </a> 0
<a> "rsvp_event" </a> 0
<a> } ) ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> verifySessionHasToken ( session , openToken ) ; </a> 0
<a> session . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) != null ) ; </a> 0
<a> assertEquals ( openToken . getToken ( ) , TokenCachingStrategy . getToken ( cache . getSavedState ( ) ) ) ; </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) == null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testOpenForPublishSuccessWithReadPermissions ( ) { </a> 0
<a> ArrayList < String > permissions = new ArrayList < String > ( ) ; </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> AccessToken openToken = AccessToken </a> 0
<a> . createFromString ( "A token of thanks" , permissions , AccessTokenSource . TEST_USER ) ; </a> 0
<a> assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> session . addAuthorizeResult ( openToken ) ; </a> 0
<a> session . openForPublish ( new Session . OpenRequest ( getActivity ( ) ) . setCallback ( statusRecorder ) . </a> 0
<a> setPermissions ( Arrays . asList ( new String [ ] { </a> 0
<a> "publish_something" , </a> 0
<a> "manage_something" , </a> 0
<a> "ads_management" , </a> 0
<a> "create_event" , </a> 0
<a> "rsvp_event" , </a> 0
<a> "read_something" </a> 0
<a> } ) ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> verifySessionHasToken ( session , openToken ) ; </a> 0
<a> session . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) != null ) ; </a> 0
<a> assertEquals ( openToken . getToken ( ) , TokenCachingStrategy . getToken ( cache . getSavedState ( ) ) ) ; </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) == null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testOpenFromTokenCache ( ) { </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> String token = "A token less unique than most" ; </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( token , DEFAULT_TIMEOUT_MILLISECONDS ) ; </a> 0
<a> ScriptedSession session = createScriptedSessionOnBlockerThread ( "app-id" , cache ) ; </a> 0
<a> assertEquals ( SessionState . CREATED_TOKEN_LOADED , session . getState ( ) ) ; </a> 0
<a> session . openForRead ( new Session . OpenRequest ( getActivity ( ) ) . setCallback ( statusRecorder ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) == null ) ; </a> 0
<a> session . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testOpenActiveFromEmptyTokenCache ( ) { </a> 0
<a> new SharedPreferencesTokenCachingStrategy ( getActivity ( ) ) . clear ( ) ; </a> 0
<a> assertNull ( Session . openActiveSessionFromCache ( getActivity ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testOpenFailure ( ) { </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> Exception openException = new Exception ( ) ; </a> 0
<a> session . addAuthorizeResult ( openException ) ; </a> 0
<a> session . openForRead ( new Session . OpenRequest ( getActivity ( ) ) . setCallback ( statusRecorder ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED_LOGIN_FAILED , openException ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) == null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testOpenForReadFailure ( ) { </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> try { </a> 0
<a> session . openForRead ( new Session . OpenRequest ( getActivity ( ) ) . setCallback ( statusRecorder ) . </a> 0
<a> setPermissions ( Arrays . asList ( new String [ ] { "publish_something" } ) ) ) ; </a> 0
<a> fail ( "should not reach here without an exception" ) ; </a> 0
<a> } catch ( FacebookException e ) { </a> 0
<a> assertTrue ( e . getMessage ( ) . contains ( "Cannot pass a publish or manage permission" ) ) ; </a> 0
<a> } finally { </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testRequestNewReadPermissionsSuccess ( ) { </a> 0
<a> ArrayList < String > permissions = new ArrayList < String > ( ) ; </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> final AccessToken openToken = AccessToken </a> 0
<a> . createFromString ( "Allows playing outside" , permissions , AccessTokenSource . TEST_USER ) ; </a> 0
<a> permissions . add ( "play_outside" ) ; </a> 0
<a> session . addAuthorizeResult ( openToken , "play_outside" ) ; </a> 0
<a> session . openForRead ( new Session . OpenRequest ( getActivity ( ) ) . setCallback ( statusRecorder ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> verifySessionHasToken ( session , openToken ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) != null ) ; </a> 0
<a> assertEquals ( openToken . getToken ( ) , TokenCachingStrategy . getToken ( cache . getSavedState ( ) ) ) ; </a> 0
<a> final AccessToken reauthorizeToken = AccessToken . createFromString ( </a> 0
<a> "Allows playing outside and eating ice cream" , permissions , AccessTokenSource . TEST_USER ) ; </a> 0
<a> permissions . add ( "eat_ice_cream" ) ; </a> 0
<a> session . addAuthorizeResult ( reauthorizeToken , "play_outside" , "eat_ice_cream" ) ; </a> 0
<a> session . requestNewReadPermissions ( new Session . NewPermissionsRequest ( getActivity ( ) , permissions ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED_TOKEN_UPDATED , null ) ; </a> 0
<a> verifySessionHasToken ( session , reauthorizeToken ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) != null ) ; </a> 0
<a> assertEquals ( reauthorizeToken . getToken ( ) , TokenCachingStrategy . getToken ( cache . getSavedState ( ) ) ) ; </a> 0
<a> final Exception reauthorizeException = new Exception ( "Don't run with scissors" ) ; </a> 0
<a> permissions . add ( "run_with_scissors" ) ; </a> 0
<a> session . addAuthorizeResult ( reauthorizeException ) ; </a> 0
<a> session . requestNewReadPermissions ( new Session . NewPermissionsRequest ( getActivity ( ) , permissions ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED_TOKEN_UPDATED , reauthorizeException ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) != null ) ; </a> 0
<a> assertEquals ( reauthorizeToken . getToken ( ) , TokenCachingStrategy . getToken ( cache . getSavedState ( ) ) ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testRequestNewPublishPermissionsSuccess ( ) { </a> 0
<a> ArrayList < String > permissions = new ArrayList < String > ( ) ; </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> final AccessToken openToken = AccessToken </a> 0
<a> . createFromString ( "Allows playing outside" , permissions , AccessTokenSource . TEST_USER ) ; </a> 0
<a> permissions . add ( "play_outside" ) ; </a> 0
<a> session . addAuthorizeResult ( openToken , "play_outside" ) ; </a> 0
<a> session . openForRead ( new Session . OpenRequest ( getActivity ( ) ) . setCallback ( statusRecorder ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> verifySessionHasToken ( session , openToken ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) != null ) ; </a> 0
<a> assertEquals ( openToken . getToken ( ) , TokenCachingStrategy . getToken ( cache . getSavedState ( ) ) ) ; </a> 0
<a> final AccessToken reauthorizeToken = AccessToken . createFromString ( </a> 0
<a> "Allows playing outside and publish eating ice cream" , permissions , AccessTokenSource . TEST_USER ) ; </a> 0
<a> permissions . add ( "publish_eat_ice_cream" ) ; </a> 0
<a> session . addAuthorizeResult ( reauthorizeToken , "play_outside" , "publish_eat_ice_cream" ) ; </a> 0
<a> session . requestNewPublishPermissions ( new Session . NewPermissionsRequest ( getActivity ( ) , permissions ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED_TOKEN_UPDATED , null ) ; </a> 0
<a> verifySessionHasToken ( session , reauthorizeToken ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) != null ) ; </a> 0
<a> assertEquals ( reauthorizeToken . getToken ( ) , TokenCachingStrategy . getToken ( cache . getSavedState ( ) ) ) ; </a> 0
<a> permissions . add ( "publish_run_with_scissors" ) ; </a> 0
<a> try { </a> 0
<a> session . requestNewReadPermissions ( new Session . NewPermissionsRequest ( getActivity ( ) , permissions ) ) ; </a> 0
<a> fail ( "Should not reach here without an exception" ) ; </a> 0
<a> } catch ( FacebookException e ) { </a> 0
<a> assertTrue ( e . getMessage ( ) . contains ( "Cannot pass a publish or manage permission" ) ) ; </a> 0
<a> } finally { </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testOpenWithAccessToken ( ) { </a> 0
<a> String token = "This is a fake token." ; </a> 0
<a> Date expirationDate = new Date ( new Date ( ) . getTime ( ) + 3600 * 1000 ) ; </a> 0
<a> Date lastRefreshDate = new Date ( ) ; </a> 0
<a> List < String > permissions = Arrays . asList ( new String [ ] { "email" , "publish_stream" } ) ; </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> AccessToken accessToken = AccessToken . createFromExistingAccessToken ( token , expirationDate , lastRefreshDate , </a> 0
<a> AccessTokenSource . FACEBOOK_APPLICATION_WEB , permissions ) ; </a> 0
<a> session . open ( accessToken , statusRecorder ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> AccessToken expectedToken = new AccessToken ( token , expirationDate , permissions , </a> 0
<a> AccessTokenSource . FACEBOOK_APPLICATION_WEB , lastRefreshDate ) ; </a> 0
<a> verifySessionHasToken ( session , expectedToken ) ; </a> 0
<a> session . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) != null ) ; </a> 0
<a> assertEquals ( expectedToken . getToken ( ) , TokenCachingStrategy . getToken ( cache . getSavedState ( ) ) ) ; </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) == null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testOpenWithAccessTokenWithDefaults ( ) { </a> 0
<a> String token = "This is a fake token." ; </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> AccessToken accessToken = AccessToken . createFromExistingAccessToken ( token , null , null , null , null ) ; </a> 0
<a> session . open ( accessToken , statusRecorder ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> assertEquals ( token , session . getAccessToken ( ) ) ; </a> 0
<a> assertEquals ( new Date ( Long . MAX_VALUE ) , session . getExpirationDate ( ) ) ; </a> 0
<a> assertEquals ( 0 , session . getPermissions ( ) . size ( ) ) ; </a> 0
<a> session . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) != null ) ; </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) == null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testSessionWillExtendTokenIfNeeded ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> session . forceExtendAccessToken ( true ) ; </a> 0
<a> Request request = Request . newMeRequest ( session , null ) ; </a> 0
<a> request . executeAndWait ( ) ; </a> 0
<a> assertTrue ( session . getWasAskedToExtendAccessToken ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testSessionWillNotExtendTokenIfCurrentlyAttempting ( ) { </a> 0
<a> TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> session . forceExtendAccessToken ( true ) ; </a> 0
<a> session . fakeTokenRefreshAttempt ( ) ; </a> 0
<a> Request request = Request . newMeRequest ( session , null ) ; </a> 0
<a> request . executeAndWait ( ) ; </a> 0
<a> assertFalse ( session . getWasAskedToExtendAccessToken ( ) ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testBasicSerialization ( ) throws IOException , ClassNotFoundException { </a> 0
<a> Session session0 = new Session . Builder ( getActivity ( ) ) . setApplicationId ( "fakeID" ) . build ( ) ; </a> 0
<a> Session session1 = TestUtils . serializeAndUnserialize ( session0 ) ; </a> 0
<a> assertNotNull ( session0 . getAccessToken ( ) ) ; </a> 0
<a> assertEquals ( session0 , session1 ) ; </a> 0
<a> Session . AuthorizationRequest authRequest0 = </a> 0
<a> new Session . OpenRequest ( getActivity ( ) ) . </a> 0
<a> setRequestCode ( 123 ) . </a> 0
<a> setLoginBehavior ( SessionLoginBehavior . SSO_ONLY ) ; </a> 0
<a> Session . AuthorizationRequest authRequest1 = TestUtils . serializeAndUnserialize ( authRequest0 ) ; </a> 0
<a> assertEquals ( authRequest0 . getLoginBehavior ( ) , authRequest1 . getLoginBehavior ( ) ) ; </a> 0
<a> assertEquals ( authRequest0 . getRequestCode ( ) , authRequest1 . getRequestCode ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testOpenSessionWithNativeLinkingIntent ( ) { </a> 0
<a> String token = "A token less unique than most" ; </a> 0
<a> Intent intent = new Intent ( Intent . ACTION_MAIN ) ; </a> 0
<a> intent . putExtras ( getNativeLinkingExtras ( token ) ) ; </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , DEFAULT_TIMEOUT_MILLISECONDS ) ; </a> 0
<a> ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> AccessToken accessToken = AccessToken . createFromNativeLinkingIntent ( intent ) ; </a> 0
<a> assertNotNull ( accessToken ) ; </a> 0
<a> session . open ( accessToken , statusRecorder ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> assertEquals ( token , session . getAccessToken ( ) ) ; </a> 0
<a> long delta = session . getExpirationDate ( ) . getTime ( ) - new Date ( ) . getTime ( ) ; </a> 0
<a> assertTrue ( Math . abs ( delta - 3600 * 1000 ) < 5000 ) ; </a> 0
<a> assertEquals ( 0 , session . getPermissions ( ) . size ( ) ) ; </a> 0
<a> assertEquals ( Utility . getMetadataApplicationId ( getActivity ( ) ) , session . getApplicationId ( ) ) ; </a> 0
<a> session . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> assertFalse ( cache . getSavedState ( ) == null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testOpenActiveSessionWithNativeLinkingIntent ( ) { </a> 0
<a> Session activeSession = Session . getActiveSession ( ) ; </a> 0
<a> if ( activeSession != null ) { </a> 0
<a> activeSession . closeAndClearTokenInformation ( ) ; </a> 0
<a> } </a> 0
<a> SharedPreferencesTokenCachingStrategy tokenCache = new SharedPreferencesTokenCachingStrategy ( getActivity ( ) ) ; </a> 0
<a> assertEquals ( 0 , tokenCache . load ( ) . size ( ) ) ; </a> 0
<a> String token = "A token less unique than most" ; </a> 0
<a> Intent intent = new Intent ( Intent . ACTION_MAIN ) ; </a> 0
<a> intent . putExtras ( getNativeLinkingExtras ( token ) ) ; </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> AccessToken accessToken = AccessToken . createFromNativeLinkingIntent ( intent ) ; </a> 0
<a> assertNotNull ( accessToken ) ; </a> 0
<a> Session session = Session . openActiveSessionWithAccessToken ( getActivity ( ) , accessToken , statusRecorder ) ; </a> 0
<a> assertEquals ( session , Session . getActiveSession ( ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> assertNotSame ( 0 , tokenCache . load ( ) . size ( ) ) ; </a> 0
<a> assertEquals ( token , session . getAccessToken ( ) ) ; </a> 0
<a> long delta = session . getExpirationDate ( ) . getTime ( ) - new Date ( ) . getTime ( ) ; </a> 0
<a> assertTrue ( Math . abs ( delta - 3600 * 1000 ) < 5000 ) ; </a> 0
<a> assertEquals ( 0 , session . getPermissions ( ) . size ( ) ) ; </a> 0
<a> assertEquals ( Utility . getMetadataApplicationId ( getActivity ( ) ) , session . getApplicationId ( ) ) ; </a> 0
<a> session . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testOpeningSessionWithPendingRequestResultsInExceptionCallback ( ) { </a> 0
<a> ArrayList < String > permissions = new ArrayList < String > ( ) ; </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> AccessToken openToken = AccessToken </a> 0
<a> . createFromString ( "A token of thanks" , permissions , AccessTokenSource . TEST_USER ) ; </a> 0
<a> assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> session . addPendingAuthorizeResult ( ) ; </a> 0
<a> session . openForRead ( new Session . OpenRequest ( getActivity ( ) ) . setCallback ( statusRecorder ) ) ; </a> 0
<a> session . openForRead ( new Session . OpenRequest ( getActivity ( ) ) . setCallback ( statusRecorder ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , new UnsupportedOperationException ( ) ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> static IntentFilter getActiveSessionFilter ( String ... actions ) { </a> 0
<a> IntentFilter filter = new IntentFilter ( ) ; </a> 0
<a> for ( String action : actions ) { </a> 0
<a> filter . addAction ( action ) ; </a> 0
<a> } </a> 0
<a> return filter ; </a> 0
<a> } </a> 0
<a> static IntentFilter getActiveSessionAllFilter ( ) { </a> 0
<a> return getActiveSessionFilter ( Session . ACTION_ACTIVE_SESSION_CLOSED , Session . ACTION_ACTIVE_SESSION_OPENED , </a> 0
<a> Session . ACTION_ACTIVE_SESSION_SET , Session . ACTION_ACTIVE_SESSION_UNSET ) ; </a> 0
<a> } </a> 0
<a> private void verifySessionHasToken ( Session session , AccessToken token ) { </a> 0
<a> assertEquals ( token . getToken ( ) , session . getAccessToken ( ) ) ; </a> 0
<a> assertEquals ( token . getExpires ( ) , session . getExpirationDate ( ) ) ; </a> 0
<a> TestUtils . assertAtLeastExpectedPermissions ( token . getPermissions ( ) , session . getPermissions ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . os . ConditionVariable ; </a> 0
<a> import android . test . AndroidTestCase ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import java . util . concurrent . Executor ; </a> 0
<a> public final class SettingsTests extends AndroidTestCase { </a> 0
<a> @ SmallTest @ MediumTest @ LargeTest </a> 0
<a> public void testGetExecutor ( ) { </a> 0
<a> final ConditionVariable condition = new ConditionVariable ( ) ; </a> 0
<a> Settings . getExecutor ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> condition . open ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> boolean success = condition . block ( 5000 ) ; </a> 0
<a> assertTrue ( success ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest @ MediumTest @ LargeTest </a> 0
<a> public void testSetExecutor ( ) { </a> 0
<a> final ConditionVariable condition = new ConditionVariable ( ) ; </a> 0
<a> final Runnable runnable = new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { } </a> 0
<a> } ; </a> 0
<a> final Executor executor = new Executor ( ) { </a> 0
<a> @ Override </a> 0
<a> public void execute ( Runnable command ) { </a> 0
<a> assertEquals ( runnable , command ) ; </a> 0
<a> command . run ( ) ; </a> 0
<a> condition . open ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> Executor original = Settings . getExecutor ( ) ; </a> 0
<a> try { </a> 0
<a> Settings . setExecutor ( executor ) ; </a> 0
<a> Settings . getExecutor ( ) . execute ( runnable ) ; </a> 0
<a> boolean success = condition . block ( 5000 ) ; </a> 0
<a> assertTrue ( success ) ; </a> 0
<a> } finally { </a> 0
<a> Settings . setExecutor ( original ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . test . AndroidTestCase ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import junit . framework . Assert ; </a> 0
<a> import java . lang . reflect . Array ; </a> 0
<a> import java . util . * ; </a> 0
<a> public final class SharedPreferencesTokenCacheTests extends AndroidTestCase { </a> 0
<a> private static final String BOOLEAN_KEY = "booleanKey" ; </a> 0
<a> private static final String BOOLEAN_ARRAY_KEY = "booleanArrayKey" ; </a> 0
<a> private static final String BYTE_KEY = "byteKey" ; </a> 0
<a> private static final String BYTE_ARRAY_KEY = "byteArrayKey" ; </a> 0
<a> private static final String SHORT_KEY = "shortKey" ; </a> 0
<a> private static final String SHORT_ARRAY_KEY = "shortArrayKey" ; </a> 0
<a> private static final String INT_KEY = "intKey" ; </a> 0
<a> private static final String INT_ARRAY_KEY = "intArrayKey" ; </a> 0
<a> private static final String LONG_KEY = "longKey" ; </a> 0
<a> private static final String LONG_ARRAY_KEY = "longArrayKey" ; </a> 0
<a> private static final String FLOAT_ARRAY_KEY = "floatKey" ; </a> 0
<a> private static final String FLOAT_KEY = "floatArrayKey" ; </a> 0
<a> private static final String DOUBLE_KEY = "doubleKey" ; </a> 0
<a> private static final String DOUBLE_ARRAY_KEY = "doubleArrayKey" ; </a> 0
<a> private static final String CHAR_KEY = "charKey" ; </a> 0
<a> private static final String CHAR_ARRAY_KEY = "charArrayKey" ; </a> 0
<a> private static final String STRING_KEY = "stringKey" ; </a> 0
<a> private static final String STRING_LIST_KEY = "stringListKey" ; </a> 0
<a> private static final String SERIALIZABLE_KEY = "serializableKey" ; </a> 0
<a> private static Random random = new Random ( ( new Date ( ) ) . getTime ( ) ) ; </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testAllTypes ( ) { </a> 0
<a> Bundle originalBundle = new Bundle ( ) ; </a> 0
<a> putBoolean ( BOOLEAN_KEY , originalBundle ) ; </a> 0
<a> putBooleanArray ( BOOLEAN_ARRAY_KEY , originalBundle ) ; </a> 0
<a> putByte ( BYTE_KEY , originalBundle ) ; </a> 0
<a> putByteArray ( BYTE_ARRAY_KEY , originalBundle ) ; </a> 0
<a> putShort ( SHORT_KEY , originalBundle ) ; </a> 0
<a> putShortArray ( SHORT_ARRAY_KEY , originalBundle ) ; </a> 0
<a> putInt ( INT_KEY , originalBundle ) ; </a> 0
<a> putIntArray ( INT_ARRAY_KEY , originalBundle ) ; </a> 0
<a> putLong ( LONG_KEY , originalBundle ) ; </a> 0
<a> putLongArray ( LONG_ARRAY_KEY , originalBundle ) ; </a> 0
<a> putFloat ( FLOAT_KEY , originalBundle ) ; </a> 0
<a> putFloatArray ( FLOAT_ARRAY_KEY , originalBundle ) ; </a> 0
<a> putDouble ( DOUBLE_KEY , originalBundle ) ; </a> 0
<a> putDoubleArray ( DOUBLE_ARRAY_KEY , originalBundle ) ; </a> 0
<a> putChar ( CHAR_KEY , originalBundle ) ; </a> 0
<a> putCharArray ( CHAR_ARRAY_KEY , originalBundle ) ; </a> 0
<a> putString ( STRING_KEY , originalBundle ) ; </a> 0
<a> putStringList ( STRING_LIST_KEY , originalBundle ) ; </a> 0
<a> originalBundle . putSerializable ( SERIALIZABLE_KEY , AccessTokenSource . FACEBOOK_APPLICATION_WEB ) ; </a> 0
<a> ensureApplicationContext ( ) ; </a> 0
<a> SharedPreferencesTokenCachingStrategy cache = new SharedPreferencesTokenCachingStrategy ( getContext ( ) ) ; </a> 0
<a> cache . save ( originalBundle ) ; </a> 0
<a> SharedPreferencesTokenCachingStrategy cache2 = new SharedPreferencesTokenCachingStrategy ( getContext ( ) ) ; </a> 0
<a> Bundle cachedBundle = cache2 . load ( ) ; </a> 0
<a> Assert . assertEquals ( originalBundle . getBoolean ( BOOLEAN_KEY ) , cachedBundle . getBoolean ( BOOLEAN_KEY ) ) ; </a> 0
<a> assertArrayEquals ( originalBundle . getBooleanArray ( BOOLEAN_ARRAY_KEY ) , cachedBundle . getBooleanArray ( BOOLEAN_ARRAY_KEY ) ) ; </a> 0
<a> Assert . assertEquals ( originalBundle . getByte ( BYTE_KEY ) , cachedBundle . getByte ( BYTE_KEY ) ) ; </a> 0
<a> assertArrayEquals ( originalBundle . getByteArray ( BYTE_ARRAY_KEY ) , cachedBundle . getByteArray ( BYTE_ARRAY_KEY ) ) ; </a> 0
<a> Assert . assertEquals ( originalBundle . getShort ( SHORT_KEY ) , cachedBundle . getShort ( SHORT_KEY ) ) ; </a> 0
<a> assertArrayEquals ( originalBundle . getShortArray ( SHORT_ARRAY_KEY ) , cachedBundle . getShortArray ( SHORT_ARRAY_KEY ) ) ; </a> 0
<a> Assert . assertEquals ( originalBundle . getInt ( INT_KEY ) , cachedBundle . getInt ( INT_KEY ) ) ; </a> 0
<a> assertArrayEquals ( originalBundle . getIntArray ( INT_ARRAY_KEY ) , cachedBundle . getIntArray ( INT_ARRAY_KEY ) ) ; </a> 0
<a> Assert . assertEquals ( originalBundle . getLong ( LONG_KEY ) , cachedBundle . getLong ( LONG_KEY ) ) ; </a> 0
<a> assertArrayEquals ( originalBundle . getLongArray ( LONG_ARRAY_KEY ) , cachedBundle . getLongArray ( LONG_ARRAY_KEY ) ) ; </a> 0
<a> Assert . assertEquals ( originalBundle . getFloat ( FLOAT_KEY ) , cachedBundle . getFloat ( FLOAT_KEY ) ) ; </a> 0
<a> assertArrayEquals ( originalBundle . getFloatArray ( FLOAT_ARRAY_KEY ) , cachedBundle . getFloatArray ( FLOAT_ARRAY_KEY ) ) ; </a> 0
<a> Assert . assertEquals ( originalBundle . getDouble ( DOUBLE_KEY ) , cachedBundle . getDouble ( DOUBLE_KEY ) ) ; </a> 0
<a> assertArrayEquals ( originalBundle . getDoubleArray ( DOUBLE_ARRAY_KEY ) , cachedBundle . getDoubleArray ( DOUBLE_ARRAY_KEY ) ) ; </a> 0
<a> Assert . assertEquals ( originalBundle . getChar ( CHAR_KEY ) , cachedBundle . getChar ( CHAR_KEY ) ) ; </a> 0
<a> assertArrayEquals ( originalBundle . getCharArray ( CHAR_ARRAY_KEY ) , cachedBundle . getCharArray ( CHAR_ARRAY_KEY ) ) ; </a> 0
<a> Assert . assertEquals ( originalBundle . getString ( STRING_KEY ) , cachedBundle . getString ( STRING_KEY ) ) ; </a> 0
<a> assertListEquals ( originalBundle . getStringArrayList ( STRING_LIST_KEY ) , cachedBundle . getStringArrayList ( </a> 0
<a> STRING_LIST_KEY ) ) ; </a> 0
<a> Assert . assertEquals ( originalBundle . getSerializable ( SERIALIZABLE_KEY ) , </a> 0
<a> cachedBundle . getSerializable ( SERIALIZABLE_KEY ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMultipleCaches ( ) { </a> 0
<a> Bundle bundle1 = new Bundle ( ) , bundle2 = new Bundle ( ) ; </a> 0
<a> bundle1 . putInt ( INT_KEY , 10 ) ; </a> 0
<a> bundle1 . putString ( STRING_KEY , "ABC" ) ; </a> 0
<a> bundle2 . putInt ( INT_KEY , 100 ) ; </a> 0
<a> bundle2 . putString ( STRING_KEY , "xyz" ) ; </a> 0
<a> ensureApplicationContext ( ) ; </a> 0
<a> SharedPreferencesTokenCachingStrategy cache1 = new SharedPreferencesTokenCachingStrategy ( getContext ( ) ) ; </a> 0
<a> SharedPreferencesTokenCachingStrategy cache2 = new SharedPreferencesTokenCachingStrategy ( getContext ( ) , "CustomCache" ) ; </a> 0
<a> cache1 . save ( bundle1 ) ; </a> 0
<a> cache2 . save ( bundle2 ) ; </a> 0
<a> cache1 = new SharedPreferencesTokenCachingStrategy ( getContext ( ) , "CustomCache" ) ; </a> 0
<a> cache2 = new SharedPreferencesTokenCachingStrategy ( getContext ( ) ) ; </a> 0
<a> Bundle newBundle1 = cache1 . load ( ) , newBundle2 = cache2 . load ( ) ; </a> 0
<a> Assert . assertEquals ( bundle2 . getInt ( INT_KEY ) , newBundle1 . getInt ( INT_KEY ) ) ; </a> 0
<a> Assert . assertEquals ( bundle2 . getString ( STRING_KEY ) , newBundle1 . getString ( STRING_KEY ) ) ; </a> 0
<a> Assert . assertEquals ( bundle1 . getInt ( INT_KEY ) , newBundle2 . getInt ( INT_KEY ) ) ; </a> 0
<a> Assert . assertEquals ( bundle1 . getString ( STRING_KEY ) , newBundle2 . getString ( STRING_KEY ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCacheRoundtrip ( ) { </a> 0
<a> ArrayList < String > permissions = Utility . arrayList ( "stream_publish" , "go_outside_and_play" ) ; </a> 0
<a> String token = "AnImaginaryTokenValue" ; </a> 0
<a> Date later = TestUtils . nowPlusSeconds ( 60 ) ; </a> 0
<a> Date earlier = TestUtils . nowPlusSeconds ( - 60 ) ; </a> 0
<a> SharedPreferencesTokenCachingStrategy cache = new SharedPreferencesTokenCachingStrategy ( getContext ( ) ) ; </a> 0
<a> cache . clear ( ) ; </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> TokenCachingStrategy . putToken ( bundle , token ) ; </a> 0
<a> TokenCachingStrategy . putExpirationDate ( bundle , later ) ; </a> 0
<a> TokenCachingStrategy . putSource ( bundle , AccessTokenSource . FACEBOOK_APPLICATION_NATIVE ) ; </a> 0
<a> TokenCachingStrategy . putLastRefreshDate ( bundle , earlier ) ; </a> 0
<a> TokenCachingStrategy . putPermissions ( bundle , permissions ) ; </a> 0
<a> cache . save ( bundle ) ; </a> 0
<a> bundle = cache . load ( ) ; </a> 0
<a> AccessToken accessToken = AccessToken . createFromCache ( bundle ) ; </a> 0
<a> TestUtils . assertSamePermissions ( permissions , accessToken ) ; </a> 0
<a> assertEquals ( token , accessToken . getToken ( ) ) ; </a> 0
<a> assertEquals ( AccessTokenSource . FACEBOOK_APPLICATION_NATIVE , accessToken . getSource ( ) ) ; </a> 0
<a> assertTrue ( ! accessToken . isInvalid ( ) ) ; </a> 0
<a> Bundle cachedBundle = accessToken . toCacheBundle ( ) ; </a> 0
<a> TestUtils . assertEqualContents ( bundle , cachedBundle ) ; </a> 0
<a> } </a> 0
<a> private static void assertArrayEquals ( Object a1 , Object a2 ) { </a> 0
<a> Assert . assertNotNull ( a1 ) ; </a> 0
<a> Assert . assertNotNull ( a2 ) ; </a> 0
<a> Assert . assertEquals ( a1 . getClass ( ) , a2 . getClass ( ) ) ; </a> 0
<a> Assert . assertTrue ( "Not an array" , a1 . getClass ( ) . isArray ( ) ) ; </a> 0
<a> int length = Array . getLength ( a1 ) ; </a> 0
<a> Assert . assertEquals ( length , Array . getLength ( a2 ) ) ; </a> 0
<a> for ( int i = 0 ; i < length ; i ++ ) { </a> 0
<a> Object a1Value = Array . get ( a1 , i ) ; </a> 0
<a> Object a2Value = Array . get ( a2 , i ) ; </a> 0
<a> Assert . assertEquals ( a1Value , a2Value ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void assertListEquals ( List < ? > l1 , List < ? > l2 ) { </a> 0
<a> Assert . assertNotNull ( l1 ) ; </a> 0
<a> Assert . assertNotNull ( l2 ) ; </a> 0
<a> Iterator < ? > i1 = l1 . iterator ( ) , i2 = l2 . iterator ( ) ; </a> 0
<a> while ( i1 . hasNext ( ) && i2 . hasNext ( ) ) { </a> 0
<a> Assert . assertEquals ( i1 . next ( ) , i2 . next ( ) ) ; </a> 0
<a> } </a> 0
<a> Assert . assertTrue ( "Lists not of the same length" , ! i1 . hasNext ( ) ) ; </a> 0
<a> Assert . assertTrue ( "Lists not of the same length" , ! i2 . hasNext ( ) ) ; </a> 0
<a> } </a> 0
<a> private static void putInt ( String key , Bundle bundle ) { </a> 0
<a> bundle . putInt ( key , random . nextInt ( ) ) ; </a> 0
<a> } </a> 0
<a> private static void putIntArray ( String key , Bundle bundle ) { </a> 0
<a> int length = random . nextInt ( 50 ) ; </a> 0
<a> int [ ] array = new int [ length ] ; </a> 0
<a> for ( int i = 0 ; i < length ; i ++ ) { </a> 0
<a> array [ i ] = random . nextInt ( ) ; </a> 0
<a> } </a> 0
<a> bundle . putIntArray ( key , array ) ; </a> 0
<a> } </a> 0
<a> private static void putShort ( String key , Bundle bundle ) { </a> 0
<a> bundle . putShort ( key , ( short ) random . nextInt ( ) ) ; </a> 0
<a> } </a> 0
<a> private static void putShortArray ( String key , Bundle bundle ) { </a> 0
<a> int length = random . nextInt ( 50 ) ; </a> 0
<a> short [ ] array = new short [ length ] ; </a> 0
<a> for ( int i = 0 ; i < length ; i ++ ) { </a> 0
<a> array [ i ] = ( short ) random . nextInt ( ) ; </a> 0
<a> } </a> 0
<a> bundle . putShortArray ( key , array ) ; </a> 0
<a> } </a> 0
<a> private static void putByte ( String key , Bundle bundle ) { </a> 0
<a> bundle . putByte ( key , ( byte ) random . nextInt ( ) ) ; </a> 0
<a> } </a> 0
<a> private static void putByteArray ( String key , Bundle bundle ) { </a> 0
<a> int length = random . nextInt ( 50 ) ; </a> 0
<a> byte [ ] array = new byte [ length ] ; </a> 0
<a> random . nextBytes ( array ) ; </a> 0
<a> bundle . putByteArray ( key , array ) ; </a> 0
<a> } </a> 0
<a> private static void putBoolean ( String key , Bundle bundle ) { </a> 0
<a> bundle . putBoolean ( key , random . nextBoolean ( ) ) ; </a> 0
<a> } </a> 0
<a> private static void putBooleanArray ( String key , Bundle bundle ) { </a> 0
<a> int length = random . nextInt ( 50 ) ; </a> 0
<a> boolean [ ] array = new boolean [ length ] ; </a> 0
<a> for ( int i = 0 ; i < length ; i ++ ) { </a> 0
<a> array [ i ] = random . nextBoolean ( ) ; </a> 0
<a> } </a> 0
<a> bundle . putBooleanArray ( key , array ) ; </a> 0
<a> } </a> 0
<a> private static void putLong ( String key , Bundle bundle ) { </a> 0
<a> bundle . putLong ( key , random . nextLong ( ) ) ; </a> 0
<a> } </a> 0
<a> private static void putLongArray ( String key , Bundle bundle ) { </a> 0
<a> int length = random . nextInt ( 50 ) ; </a> 0
<a> long [ ] array = new long [ length ] ; </a> 0
<a> for ( int i = 0 ; i < length ; i ++ ) { </a> 0
<a> array [ i ] = random . nextLong ( ) ; </a> 0
<a> } </a> 0
<a> bundle . putLongArray ( key , array ) ; </a> 0
<a> } </a> 0
<a> private static void putFloat ( String key , Bundle bundle ) { </a> 0
<a> bundle . putFloat ( key , random . nextFloat ( ) ) ; </a> 0
<a> } </a> 0
<a> private static void putFloatArray ( String key , Bundle bundle ) { </a> 0
<a> int length = random . nextInt ( 50 ) ; </a> 0
<a> float [ ] array = new float [ length ] ; </a> 0
<a> for ( int i = 0 ; i < length ; i ++ ) { </a> 0
<a> array [ i ] = random . nextFloat ( ) ; </a> 0
<a> } </a> 0
<a> bundle . putFloatArray ( key , array ) ; </a> 0
<a> } </a> 0
<a> private static void putDouble ( String key , Bundle bundle ) { </a> 0
<a> bundle . putDouble ( key , random . nextDouble ( ) ) ; </a> 0
<a> } </a> 0
<a> private static void putDoubleArray ( String key , Bundle bundle ) { </a> 0
<a> int length = random . nextInt ( 50 ) ; </a> 0
<a> double [ ] array = new double [ length ] ; </a> 0
<a> for ( int i = 0 ; i < length ; i ++ ) { </a> 0
<a> array [ i ] = random . nextDouble ( ) ; </a> 0
<a> } </a> 0
<a> bundle . putDoubleArray ( key , array ) ; </a> 0
<a> } </a> 0
<a> private static void putChar ( String key , Bundle bundle ) { </a> 0
<a> bundle . putChar ( key , getChar ( ) ) ; </a> 0
<a> } </a> 0
<a> private static void putCharArray ( String key , Bundle bundle ) { </a> 0
<a> bundle . putCharArray ( key , getCharArray ( ) ) ; </a> 0
<a> } </a> 0
<a> private static void putString ( String key , Bundle bundle ) { </a> 0
<a> bundle . putString ( key , new String ( getCharArray ( ) ) ) ; </a> 0
<a> } </a> 0
<a> private static void putStringList ( String key , Bundle bundle ) { </a> 0
<a> int length = random . nextInt ( 50 ) ; </a> 0
<a> ArrayList < String > stringList = new ArrayList < String > ( length ) ; </a> 0
<a> while ( 0 < length -- ) { </a> 0
<a> if ( length == 0 ) { </a> 0
<a> stringList . add ( null ) ; </a> 0
<a> } else { </a> 0
<a> stringList . add ( new String ( getCharArray ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> bundle . putStringArrayList ( key , stringList ) ; </a> 0
<a> } </a> 0
<a> private static char [ ] getCharArray ( ) { </a> 0
<a> int length = random . nextInt ( 50 ) ; </a> 0
<a> char [ ] array = new char [ length ] ; </a> 0
<a> for ( int i = 0 ; i < length ; i ++ ) { </a> 0
<a> array [ i ] = getChar ( ) ; </a> 0
<a> } </a> 0
<a> return array ; </a> 0
<a> } </a> 0
<a> private static char getChar ( ) { </a> 0
<a> return ( char ) random . nextInt ( 255 ) ; </a> 0
<a> } </a> 0
<a> private void ensureApplicationContext ( ) { </a> 0
<a> long waitedFor = 0 ; </a> 0
<a> try { </a> 0
<a> while ( getContext ( ) . getApplicationContext ( ) == null && waitedFor <= 2000 ) { </a> 0
<a> Thread . sleep ( 50 ) ; </a> 0
<a> waitedFor += 50 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . os . HandlerThread ; </a> 0
<a> public class TestBlocker extends HandlerThread { </a> 0
<a> private Exception exception ; </a> 0
<a> public int signals ; </a> 0
<a> private volatile Handler handler ; </a> 0
<a> private TestBlocker ( ) { </a> 0
<a> super ( "TestBlocker" ) ; </a> 0
<a> } </a> 0
<a> public synchronized static TestBlocker createTestBlocker ( ) { </a> 0
<a> TestBlocker blocker = new TestBlocker ( ) ; </a> 0
<a> blocker . start ( ) ; </a> 0
<a> synchronized ( blocker ) { </a> 0
<a> while ( blocker . handler == null ) { </a> 0
<a> try { </a> 0
<a> blocker . wait ( ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return blocker ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> try { </a> 0
<a> super . run ( ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> setException ( e ) ; </a> 0
<a> } </a> 0
<a> synchronized ( this ) { </a> 0
<a> notifyAll ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public Handler getHandler ( ) { </a> 0
<a> return handler ; </a> 0
<a> } </a> 0
<a> public void assertSuccess ( ) throws Exception { </a> 0
<a> Exception e = getException ( ) ; </a> 0
<a> if ( e != null ) { </a> 0
<a> throw e ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public synchronized void signal ( ) { </a> 0
<a> ++ signals ; </a> 0
<a> notifyAll ( ) ; </a> 0
<a> } </a> 0
<a> public void waitForSignals ( int numSignals ) throws Exception { </a> 0
<a> assertSuccess ( ) ; </a> 0
<a> setException ( null ) ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> while ( getException ( ) == null && signals < numSignals ) { </a> 0
<a> try { </a> 0
<a> wait ( ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> signals = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void waitForSignalsAndAssertSuccess ( int numSignals ) throws Exception { </a> 0
<a> waitForSignals ( numSignals ) ; </a> 0
<a> assertSuccess ( ) ; </a> 0
<a> } </a> 0
<a> public synchronized Exception getException ( ) { </a> 0
<a> return exception ; </a> 0
<a> } </a> 0
<a> public synchronized void setException ( Exception e ) { </a> 0
<a> exception = e ; </a> 0
<a> notifyAll ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onLooperPrepared ( ) { </a> 0
<a> synchronized ( this ) { </a> 0
<a> handler = new Handler ( getLooper ( ) ) ; </a> 0
<a> notifyAll ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> public class TestSessionTests extends FacebookTestCase { </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanCreateWithPrivateUser ( ) { </a> 0
<a> TestSession session = TestSession . createSessionWithPrivateUser ( getActivity ( ) , null ) ; </a> 0
<a> assertTrue ( session != null ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanCreateWithSharedUser ( ) { </a> 0
<a> TestSession session = TestSession . createSessionWithSharedUser ( getActivity ( ) , null ) ; </a> 0
<a> assertTrue ( session != null ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanOpenWithSharedUser ( ) throws Throwable { </a> 0
<a> final TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> TestSession session = getTestSessionWithSharedUser ( ) ; </a> 0
<a> Session . OpenRequest openRequest = new Session . OpenRequest ( getActivity ( ) ) . </a> 0
<a> setCallback ( </a> 0
<a> new Session . StatusCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> assertTrue ( exception == null ) ; </a> 0
<a> blocker . signal ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> session . openForRead ( openRequest ) ; </a> 0
<a> waitAndAssertSuccess ( blocker , 1 ) ; </a> 0
<a> assertTrue ( session . getState ( ) . isOpened ( ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testSharedUserDoesntCreateUnnecessaryUsers ( ) throws Throwable { </a> 0
<a> TestSession session = getTestSessionWithSharedUser ( ) ; </a> 0
<a> openSession ( getActivity ( ) , session ) ; </a> 0
<a> int startingUserCount = countTestUsers ( ) ; </a> 0
<a> session = getTestSessionWithSharedUser ( ) ; </a> 0
<a> openSession ( getActivity ( ) , session ) ; </a> 0
<a> int endingUserCount = countTestUsers ( ) ; </a> 0
<a> assertSame ( startingUserCount , endingUserCount ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void failing_testPrivateUserIsDeletedOnSessionClose ( ) throws Throwable { </a> 0
<a> final TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> int startingUserCount = countTestUsers ( ) ; </a> 0
<a> TestSession session = getTestSessionWithPrivateUser ( blocker ) ; </a> 0
<a> openSession ( getActivity ( ) , session ) ; </a> 0
<a> int sessionOpenUserCount = countTestUsers ( ) ; </a> 0
<a> assertSame ( startingUserCount + 1 , sessionOpenUserCount ) ; </a> 0
<a> session . close ( ) ; </a> 0
<a> int endingUserCount = countTestUsers ( ) ; </a> 0
<a> assertSame ( startingUserCount , endingUserCount ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCannotChangeTestApplicationIdOnceSet ( ) { </a> 0
<a> try { </a> 0
<a> TestSession . setTestApplicationId ( "hello" ) ; </a> 0
<a> TestSession . setTestApplicationId ( "world" ) ; </a> 0
<a> fail ( "expected exception" ) ; </a> 0
<a> } catch ( FacebookException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCannotChangeTestApplicationSecretOnceSet ( ) { </a> 0
<a> try { </a> 0
<a> TestSession . setTestApplicationSecret ( "hello" ) ; </a> 0
<a> TestSession . setTestApplicationSecret ( "world" ) ; </a> 0
<a> fail ( "expected exception" ) ; </a> 0
<a> } catch ( FacebookException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private int countTestUsers ( ) { </a> 0
<a> TestSession session = getTestSessionWithSharedUser ( null ) ; </a> 0
<a> String appAccessToken = TestSession . getAppAccessToken ( ) ; </a> 0
<a> assertNotNull ( appAccessToken ) ; </a> 0
<a> String applicationId = session . getApplicationId ( ) ; </a> 0
<a> assertNotNull ( applicationId ) ; </a> 0
<a> String fqlQuery = String . format ( "SELECT id FROM test_account WHERE app_id = %s" , applicationId ) ; </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> parameters . putString ( "q" , fqlQuery ) ; </a> 0
<a> parameters . putString ( "access_token" , appAccessToken ) ; </a> 0
<a> Request request = new Request ( null , "fql" , parameters , null ) ; </a> 0
<a> Response response = request . executeAndWait ( ) ; </a> 0
<a> JSONArray data = ( JSONArray ) response . getGraphObject ( ) . getProperty ( "data" ) ; </a> 0
<a> return data . length ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import junit . framework . Assert ; </a> 0
<a> import java . io . * ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class TestUtils { </a> 0
<a> public static < T extends Serializable > T serializeAndUnserialize ( T t ) { </a> 0
<a> try { </a> 0
<a> ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; </a> 0
<a> new ObjectOutputStream ( os ) . writeObject ( t ) ; </a> 0
<a> ByteArrayInputStream is = new ByteArrayInputStream ( os . toByteArray ( ) ) ; </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> T ret = ( T ) ( new ObjectInputStream ( is ) ) . readObject ( ) ; </a> 0
<a> return ret ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new RuntimeException ( e ) ; </a> 0
<a> } catch ( ClassNotFoundException e ) { </a> 0
<a> throw new RuntimeException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static Date nowPlusSeconds ( long offset ) { </a> 0
<a> return new Date ( new Date ( ) . getTime ( ) + ( offset * 1000L ) ) ; </a> 0
<a> } </a> 0
<a> static void assertSamePermissions ( List < String > expected , AccessToken actual ) { </a> 0
<a> if ( expected == null ) { </a> 0
<a> Assert . assertEquals ( null , actual . getPermissions ( ) ) ; </a> 0
<a> } else { </a> 0
<a> for ( String p : expected ) { </a> 0
<a> Assert . assertTrue ( actual . getPermissions ( ) . contains ( p ) ) ; </a> 0
<a> } </a> 0
<a> for ( String p : actual . getPermissions ( ) ) { </a> 0
<a> Assert . assertTrue ( expected . contains ( p ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static void assertSamePermissions ( List < String > expected , List < String > actual ) { </a> 0
<a> if ( expected == null ) { </a> 0
<a> Assert . assertEquals ( null , actual ) ; </a> 0
<a> } else { </a> 0
<a> for ( String p : expected ) { </a> 0
<a> Assert . assertTrue ( actual . contains ( p ) ) ; </a> 0
<a> } </a> 0
<a> for ( String p : actual ) { </a> 0
<a> Assert . assertTrue ( expected . contains ( p ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static void assertAtLeastExpectedPermissions ( List < String > expected , List < String > actual ) { </a> 0
<a> if ( expected != null ) { </a> 0
<a> for ( String p : expected ) { </a> 0
<a> Assert . assertTrue ( actual . contains ( p ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static void assertEqualContents ( Bundle a , Bundle b ) { </a> 0
<a> for ( String key : a . keySet ( ) ) { </a> 0
<a> if ( ! b . containsKey ( key ) ) { </a> 0
<a> Assert . fail ( "bundle does not include key " + key ) ; </a> 0
<a> } </a> 0
<a> Assert . assertEquals ( a . get ( key ) , b . get ( key ) ) ; </a> 0
<a> } </a> 0
<a> for ( String key : b . keySet ( ) ) { </a> 0
<a> if ( ! a . containsKey ( key ) ) { </a> 0
<a> Assert . fail ( "bundle does not include key " + key ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . internal ; </a> 0
<a> import android . test . AndroidTestCase ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import java . io . ByteArrayInputStream ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . util . Random ; </a> 0
<a> public final class FileLruCacheTests extends AndroidTestCase { </a> 0
<a> private static final Random random = new Random ( ) ; </a> 0
<a> @ SmallTest @ MediumTest @ LargeTest </a> 0
<a> public void testCacheOutputStream ( ) throws IOException { </a> 0
<a> int dataSize = 1024 ; </a> 0
<a> byte [ ] data = generateBytes ( dataSize ) ; </a> 0
<a> String key = "a" ; </a> 0
<a> FileLruCache cache = new FileLruCache ( getContext ( ) , "testCacheOutputStream" , limitCacheSize ( 2 * dataSize ) ) ; </a> 0
<a> put ( cache , key , data ) ; </a> 0
<a> checkValue ( cache , key , data ) ; </a> 0
<a> cache . clearForTest ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest @ MediumTest @ LargeTest </a> 0
<a> public void testCacheInputStream ( ) throws IOException { </a> 0
<a> int dataSize = 1024 ; </a> 0
<a> byte [ ] data = generateBytes ( dataSize ) ; </a> 0
<a> String key = "a" ; </a> 0
<a> InputStream stream = new ByteArrayInputStream ( data ) ; </a> 0
<a> FileLruCache cache = new FileLruCache ( getContext ( ) , "testCacheInputStream" , limitCacheSize ( 2 * dataSize ) ) ; </a> 0
<a> cache . clearForTest ( ) ; </a> 0
<a> InputStream wrapped = cache . interceptAndPut ( key , stream ) ; </a> 0
<a> consumeAndClose ( wrapped ) ; </a> 0
<a> checkValue ( cache , key , data ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest @ MediumTest @ LargeTest </a> 0
<a> public void testCacheClear ( ) throws IOException { </a> 0
<a> int dataSize = 1024 ; </a> 0
<a> byte [ ] data = generateBytes ( dataSize ) ; </a> 0
<a> String key = "a" ; </a> 0
<a> FileLruCache cache = new FileLruCache ( getContext ( ) , "testCacheClear" , limitCacheSize ( 2 * dataSize ) ) ; </a> 0
<a> cache . clearForTest ( ) ; </a> 0
<a> put ( cache , key , data ) ; </a> 0
<a> checkValue ( cache , key , data ) ; </a> 0
<a> cache . clearForTest ( ) ; </a> 0
<a> assertEquals ( false , hasValue ( cache , key ) ) ; </a> 0
<a> assertEquals ( 0 , cache . sizeInBytesForTest ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest @ MediumTest @ LargeTest </a> 0
<a> public void testSizeInBytes ( ) throws IOException { </a> 0
<a> int count = 17 ; </a> 0
<a> int dataSize = 53 ; </a> 0
<a> int cacheSize = count * dataSize ; </a> 0
<a> byte [ ] data = generateBytes ( dataSize ) ; </a> 0
<a> FileLruCache cache = new FileLruCache ( getContext ( ) , "testSizeInBytes" , limitCacheSize ( 2 * cacheSize ) ) ; </a> 0
<a> cache . clearForTest ( ) ; </a> 0
<a> for ( int i = 0 ; i < count ; i ++ ) { </a> 0
<a> put ( cache , i , data ) ; </a> 0
<a> int totalDataSize = ( i + 1 ) * dataSize ; </a> 0
<a> assertTrue ( cache . sizeInBytesForTest ( ) > totalDataSize ) ; </a> 0
<a> assertTrue ( cache . sizeInBytesForTest ( ) < 2 * totalDataSize ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < count ; i ++ ) { </a> 0
<a> String key = Integer . valueOf ( i ) . toString ( ) ; </a> 0
<a> checkValue ( cache , key , data ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ MediumTest @ LargeTest </a> 0
<a> public void testCacheSizeLimit ( ) throws IOException { </a> 0
<a> int count = 64 ; </a> 0
<a> int dataSize = 32 ; </a> 0
<a> int cacheSize = count * dataSize / 2 ; </a> 0
<a> byte [ ] data = generateBytes ( dataSize ) ; </a> 0
<a> FileLruCache cache = new FileLruCache ( getContext ( ) , "testCacheSizeLimit" , limitCacheSize ( cacheSize ) ) ; </a> 0
<a> cache . clearForTest ( ) ; </a> 0
<a> for ( int i = 0 ; i < count ; i ++ ) { </a> 0
<a> put ( cache , i , data ) ; </a> 0
<a> int totalDataSize = ( i + 1 ) * dataSize ; </a> 0
<a> assertTrue ( cache . sizeInBytesForTest ( ) > Math . min ( totalDataSize , cacheSize / 2 ) ) ; </a> 0
<a> assertTrue ( cache . sizeInBytesForTest ( ) < Math . min ( 2 * totalDataSize , cacheSize ) ) ; </a> 0
<a> } </a> 0
<a> boolean hasValueExists = false ; </a> 0
<a> boolean hasNoValueExists = false ; </a> 0
<a> for ( int i = 0 ; i < count ; i ++ ) { </a> 0
<a> String key = Integer . valueOf ( i ) . toString ( ) ; </a> 0
<a> if ( hasValue ( cache , key ) ) { </a> 0
<a> hasValueExists = true ; </a> 0
<a> checkValue ( cache , key , data ) ; </a> 0
<a> } else { </a> 0
<a> hasNoValueExists = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> assertEquals ( true , hasValueExists ) ; </a> 0
<a> assertEquals ( true , hasNoValueExists ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest @ LargeTest </a> 0
<a> public void testCacheCountLimit ( ) throws IOException { </a> 0
<a> int count = 64 ; </a> 0
<a> int dataSize = 32 ; </a> 0
<a> int cacheCount = count / 2 ; </a> 0
<a> byte [ ] data = generateBytes ( dataSize ) ; </a> 0
<a> FileLruCache cache = new FileLruCache ( getContext ( ) , "testCacheCountLimit" , limitCacheCount ( cacheCount ) ) ; </a> 0
<a> cache . clearForTest ( ) ; </a> 0
<a> for ( int i = 0 ; i < count ; i ++ ) { </a> 0
<a> put ( cache , i , data ) ; </a> 0
<a> } </a> 0
<a> boolean hasValueExists = false ; </a> 0
<a> boolean hasNoValueExists = false ; </a> 0
<a> for ( int i = 0 ; i < count ; i ++ ) { </a> 0
<a> if ( hasValue ( cache , i ) ) { </a> 0
<a> hasValueExists = true ; </a> 0
<a> checkValue ( cache , i , data ) ; </a> 0
<a> } else { </a> 0
<a> hasNoValueExists = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> assertEquals ( true , hasValueExists ) ; </a> 0
<a> assertEquals ( true , hasNoValueExists ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testCacheLru ( ) throws IOException , InterruptedException { </a> 0
<a> int keepCount = 10 ; </a> 0
<a> int otherCount = 5 ; </a> 0
<a> int dataSize = 64 ; </a> 0
<a> byte [ ] data = generateBytes ( dataSize ) ; </a> 0
<a> FileLruCache cache = new FileLruCache ( getContext ( ) , "testCacheLru" , limitCacheCount ( keepCount + 1 ) ) ; </a> 0
<a> cache . clearForTest ( ) ; </a> 0
<a> for ( int i = 0 ; i < keepCount ; i ++ ) { </a> 0
<a> put ( cache , i , data ) ; </a> 0
<a> } </a> 0
<a> Thread . sleep ( 1000 ) ; </a> 0
<a> for ( int i = 0 ; i < otherCount ; i ++ ) { </a> 0
<a> put ( cache , keepCount + i , data ) ; </a> 0
<a> Thread . sleep ( 1000 ) ; </a> 0
<a> for ( int keepIndex = 0 ; keepIndex < keepCount ; keepIndex ++ ) { </a> 0
<a> checkValue ( cache , keepIndex , data ) ; </a> 0
<a> } </a> 0
<a> Thread . sleep ( 1000 ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < ( otherCount - 1 ) ; i ++ ) { </a> 0
<a> String key = Integer . valueOf ( keepCount + i ) . toString ( ) ; </a> 0
<a> assertEquals ( false , hasValue ( cache , key ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testConcurrentWritesToSameKey ( ) throws IOException , InterruptedException { </a> 0
<a> final int count = 5 ; </a> 0
<a> final int dataSize = 81 ; </a> 0
<a> final int threadCount = 31 ; </a> 0
<a> final int iterationCount = 10 ; </a> 0
<a> final byte [ ] data = generateBytes ( dataSize ) ; </a> 0
<a> final FileLruCache cache = new FileLruCache ( </a> 0
<a> getContext ( ) , "testConcurrentWritesToSameKey" , limitCacheCount ( count + 1 ) ) ; </a> 0
<a> cache . clearForTest ( ) ; </a> 0
<a> Runnable run = new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> for ( int iterations = 0 ; iterations < iterationCount ; iterations ++ ) { </a> 0
<a> for ( int i = 0 ; i < count ; i ++ ) { </a> 0
<a> put ( cache , i , data ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> Thread [ ] threads = new Thread [ threadCount ] ; </a> 0
<a> for ( int i = 0 ; i < threads . length ; i ++ ) { </a> 0
<a> threads [ i ] = new Thread ( run ) ; </a> 0
<a> } </a> 0
<a> for ( Thread thread : threads ) { </a> 0
<a> thread . start ( ) ; </a> 0
<a> } </a> 0
<a> for ( Thread thread : threads ) { </a> 0
<a> thread . join ( 10 * 1000 , 0 ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < count ; i ++ ) { </a> 0
<a> checkValue ( cache , i , data ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> byte [ ] generateBytes ( int n ) { </a> 0
<a> byte [ ] bytes = new byte [ n ] ; </a> 0
<a> random . nextBytes ( bytes ) ; </a> 0
<a> return bytes ; </a> 0
<a> } </a> 0
<a> FileLruCache . Limits limitCacheSize ( int n ) { </a> 0
<a> FileLruCache . Limits limits = new FileLruCache . Limits ( ) ; </a> 0
<a> limits . setByteCount ( n ) ; </a> 0
<a> return limits ; </a> 0
<a> } </a> 0
<a> FileLruCache . Limits limitCacheCount ( int n ) { </a> 0
<a> FileLruCache . Limits limits = new FileLruCache . Limits ( ) ; </a> 0
<a> limits . setFileCount ( n ) ; </a> 0
<a> return limits ; </a> 0
<a> } </a> 0
<a> void put ( FileLruCache cache , int i , byte [ ] data ) { </a> 0
<a> put ( cache , Integer . valueOf ( i ) . toString ( ) , data ) ; </a> 0
<a> } </a> 0
<a> void put ( FileLruCache cache , String key , byte [ ] data ) { </a> 0
<a> try { </a> 0
<a> OutputStream stream = cache . openPutStream ( key ) ; </a> 0
<a> assertNotNull ( stream ) ; </a> 0
<a> stream . write ( data ) ; </a> 0
<a> stream . close ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> assertNull ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void checkValue ( FileLruCache cache , int i , byte [ ] expected ) { </a> 0
<a> checkValue ( cache , Integer . valueOf ( i ) . toString ( ) , expected ) ; </a> 0
<a> } </a> 0
<a> void checkValue ( FileLruCache cache , String key , byte [ ] expected ) { </a> 0
<a> try { </a> 0
<a> InputStream stream = cache . get ( key ) ; </a> 0
<a> assertNotNull ( stream ) ; </a> 0
<a> checkInputStream ( expected , stream ) ; </a> 0
<a> stream . close ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> assertNull ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> boolean hasValue ( FileLruCache cache , int i ) { </a> 0
<a> return hasValue ( cache , Integer . valueOf ( i ) . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> boolean hasValue ( FileLruCache cache , String key ) { </a> 0
<a> InputStream stream = null ; </a> 0
<a> try { </a> 0
<a> stream = cache . get ( key ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> assertNull ( e ) ; </a> 0
<a> } </a> 0
<a> return stream != null ; </a> 0
<a> } </a> 0
<a> void checkInputStream ( byte [ ] expected , InputStream actual ) { </a> 0
<a> try { </a> 0
<a> for ( int i = 0 ; i < expected . length ; i ++ ) { </a> 0
<a> int b = actual . read ( ) ; </a> 0
<a> assertEquals ( ( ( int ) expected [ i ] ) & 0xff , b ) ; </a> 0
<a> } </a> 0
<a> int eof = actual . read ( ) ; </a> 0
<a> assertEquals ( - 1 , eof ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> assertNull ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void consumeAndClose ( InputStream stream ) { </a> 0
<a> try { </a> 0
<a> byte [ ] buffer = new byte [ 1024 ] ; </a> 0
<a> while ( stream . read ( buffer ) > - 1 ) { </a> 0
<a> } </a> 0
<a> stream . close ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> assertNull ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . internal ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . internal . SessionTracker ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> public class SessionTrackerTests extends SessionTestsBase { </a> 0
<a> private static final String TOKEN_STR = "A token of thanks" ; </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testDelegateWithActiveSession ( ) throws Exception { </a> 0
<a> Session . setActiveSession ( null ) ; </a> 0
<a> final SessionStatusCallbackRecorder statusRecorder = </a> 0
<a> new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> final MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> final ScriptedSession session = </a> 0
<a> createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> session . addAuthorizeResult ( TOKEN_STR , Collections . < String > emptyList ( ) , AccessTokenSource . TEST_USER ) ; </a> 0
<a> final SessionTracker tracker = new SessionTracker ( getActivity ( ) , statusRecorder ) ; </a> 0
<a> Session . setActiveSession ( session ) ; </a> 0
<a> session . openForRead ( new Session . OpenRequest ( getActivity ( ) ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> assertNotNull ( "Session should be open" , tracker . getOpenSession ( ) ) ; </a> 0
<a> assertEquals ( "Access Token check" , TOKEN_STR , tracker . getOpenSession ( ) . getAccessToken ( ) ) ; </a> 0
<a> tracker . getOpenSession ( ) . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> tracker . stopTracking ( ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testDelegateWithSessionInConstructor ( ) throws Exception { </a> 0
<a> final SessionStatusCallbackRecorder statusRecorder = </a> 0
<a> new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> final MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> final ScriptedSession session = </a> 0
<a> createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> session . addAuthorizeResult ( TOKEN_STR , Collections . < String > emptyList ( ) , AccessTokenSource . TEST_USER ) ; </a> 0
<a> SessionTracker tracker = new SessionTracker ( getActivity ( ) , statusRecorder , session ) ; </a> 0
<a> session . openForRead ( new Session . OpenRequest ( getActivity ( ) ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> assertNotNull ( "Session should be open" , tracker . getOpenSession ( ) ) ; </a> 0
<a> assertEquals ( "Access Token check" , TOKEN_STR , tracker . getOpenSession ( ) . getAccessToken ( ) ) ; </a> 0
<a> tracker . getOpenSession ( ) . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> tracker . stopTracking ( ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testDelegateWithActiveSessionThenNewSession ( ) throws Exception { </a> 0
<a> Session . setActiveSession ( null ) ; </a> 0
<a> final SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> final MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> final ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> session . addAuthorizeResult ( TOKEN_STR , Collections . < String > emptyList ( ) , AccessTokenSource . TEST_USER ) ; </a> 0
<a> SessionTracker tracker = new SessionTracker ( getActivity ( ) , statusRecorder ) ; </a> 0
<a> Session . setActiveSession ( session ) ; </a> 0
<a> session . openForRead ( new Session . OpenRequest ( getActivity ( ) ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> assertNotNull ( "Session should be open" , tracker . getOpenSession ( ) ) ; </a> 0
<a> assertEquals ( "Access Token check" , TOKEN_STR , tracker . getOpenSession ( ) . getAccessToken ( ) ) ; </a> 0
<a> tracker . getOpenSession ( ) . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> final ScriptedSession newSession = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> newSession . addAuthorizeResult ( TOKEN_STR , Collections . < String > emptyList ( ) , AccessTokenSource . TEST_USER ) ; </a> 0
<a> tracker . setSession ( newSession ) ; </a> 0
<a> assertNull ( "Session should not be open" , tracker . getOpenSession ( ) ) ; </a> 0
<a> newSession . openForRead ( new Session . OpenRequest ( getActivity ( ) ) ) ; </a> 0
<a> statusRecorder . waitForCall ( newSession , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( newSession , SessionState . OPENED , null ) ; </a> 0
<a> assertNotNull ( "Session should be open" , tracker . getOpenSession ( ) ) ; </a> 0
<a> assertEquals ( "Access Token check" , TOKEN_STR , tracker . getOpenSession ( ) . getAccessToken ( ) ) ; </a> 0
<a> tracker . getOpenSession ( ) . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( newSession , SessionState . CLOSED , null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> tracker . stopTracking ( ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testDelegateWithSessionThenActiveSession ( ) throws Exception { </a> 0
<a> Session . setActiveSession ( null ) ; </a> 0
<a> final SessionStatusCallbackRecorder statusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> final MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> final ScriptedSession session = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> session . addAuthorizeResult ( TOKEN_STR , Collections . < String > emptyList ( ) , AccessTokenSource . TEST_USER ) ; </a> 0
<a> final SessionTracker tracker = new SessionTracker ( getActivity ( ) , statusRecorder , session ) ; </a> 0
<a> session . openForRead ( new Session . OpenRequest ( getActivity ( ) ) ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> assertNotNull ( "Session should be open" , tracker . getOpenSession ( ) ) ; </a> 0
<a> assertEquals ( "Access Token check" , TOKEN_STR , tracker . getOpenSession ( ) . getAccessToken ( ) ) ; </a> 0
<a> tracker . getOpenSession ( ) . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> final ScriptedSession newSession = createScriptedSessionOnBlockerThread ( cache ) ; </a> 0
<a> newSession . addAuthorizeResult ( TOKEN_STR , Collections . < String > emptyList ( ) , AccessTokenSource . TEST_USER ) ; </a> 0
<a> runOnBlockerThread ( new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> tracker . setSession ( null ) ; </a> 0
<a> Session . setActiveSession ( newSession ) ; </a> 0
<a> } </a> 0
<a> } , true ) ; </a> 0
<a> assertNull ( "Session should not be open" , tracker . getOpenSession ( ) ) ; </a> 0
<a> newSession . openForRead ( new Session . OpenRequest ( getActivity ( ) ) ) ; </a> 0
<a> statusRecorder . waitForCall ( newSession , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( newSession , SessionState . OPENED , null ) ; </a> 0
<a> assertNotNull ( "Session should be open" , tracker . getOpenSession ( ) ) ; </a> 0
<a> assertEquals ( "Access Token check" , TOKEN_STR , tracker . getOpenSession ( ) . getAccessToken ( ) ) ; </a> 0
<a> tracker . getOpenSession ( ) . close ( ) ; </a> 0
<a> statusRecorder . waitForCall ( newSession , SessionState . CLOSED , null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> tracker . stopTracking ( ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . internal ; </a> 0
<a> import android . test . AndroidTestCase ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import com . facebook . internal . Validate ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> public class ValidateTests extends AndroidTestCase { </a> 0
<a> @ SmallTest </a> 0
<a> public void testNotNullOnNonNull ( ) { </a> 0
<a> Validate . notNull ( "A string" , "name" ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> public void testNotNullOnNull ( ) { </a> 0
<a> try { </a> 0
<a> Validate . notNull ( null , "name" ) ; </a> 0
<a> fail ( "expected exception" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> public void testNotEmptyOnNonEmpty ( ) { </a> 0
<a> Validate . notEmpty ( Arrays . asList ( new String [ ] { "hi" } ) , "name" ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> public void testNotEmptylOnEmpty ( ) { </a> 0
<a> try { </a> 0
<a> Validate . notEmpty ( Arrays . asList ( new String [ ] { } ) , "name" ) ; </a> 0
<a> fail ( "expected exception" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> public void testNotNullOrEmptyOnNonEmpty ( ) { </a> 0
<a> Validate . notNullOrEmpty ( "hi" , "name" ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> public void testNotNullOrEmptyOnEmpty ( ) { </a> 0
<a> try { </a> 0
<a> Validate . notNullOrEmpty ( "" , "name" ) ; </a> 0
<a> fail ( "expected exception" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> public void testNotNullOrEmptyOnNull ( ) { </a> 0
<a> try { </a> 0
<a> Validate . notNullOrEmpty ( null , "name" ) ; </a> 0
<a> fail ( "expected exception" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> public void testOneOfOnValid ( ) { </a> 0
<a> Validate . oneOf ( "hi" , "name" , "hi" , "there" ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> public void testOneOfOnInvalid ( ) { </a> 0
<a> try { </a> 0
<a> Validate . oneOf ( "hit" , "name" , "hi" , "there" ) ; </a> 0
<a> fail ( "expected exception" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> public void testOneOfOnValidNull ( ) { </a> 0
<a> Validate . oneOf ( null , "name" , "hi" , "there" , null ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> public void testOneOfOnInvalidNull ( ) { </a> 0
<a> try { </a> 0
<a> Validate . oneOf ( null , "name" , "hi" , "there" ) ; </a> 0
<a> fail ( "expected exception" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . model ; </a> 0
<a> import android . test . AndroidTestCase ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import com . facebook . FacebookGraphObjectException ; </a> 0
<a> import junit . framework . Assert ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . util . * ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> public final class GraphObjectFactoryTests extends AndroidTestCase { </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCreateEmptyGraphObject ( ) { </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( ) ; </a> 0
<a> assertTrue ( graphObject != null ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanTreatAsMap ( ) { </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( ) ; </a> 0
<a> graphObject . setProperty ( "hello" , "world" ) ; </a> 0
<a> assertEquals ( "world" , ( String ) graphObject . asMap ( ) . get ( "hello" ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanTreatAsGraphPlace ( ) { </a> 0
<a> GraphPlace graphPlace = GraphObject . Factory . create ( GraphPlace . class ) ; </a> 0
<a> graphPlace . setName ( "hello" ) ; </a> 0
<a> assertEquals ( "hello" , graphPlace . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanTreatAsGraphUser ( ) { </a> 0
<a> GraphUser graphUser = GraphObject . Factory . create ( GraphUser . class ) ; </a> 0
<a> graphUser . setFirstName ( "Michael" ) ; </a> 0
<a> assertEquals ( "Michael" , graphUser . getFirstName ( ) ) ; </a> 0
<a> assertEquals ( "Michael" , graphUser . getProperty ( "first_name" ) ) ; </a> 0
<a> assertEquals ( "Michael" , graphUser . asMap ( ) . get ( "first_name" ) ) ; </a> 0
<a> graphUser . setProperty ( "last_name" , "Scott" ) ; </a> 0
<a> assertEquals ( "Scott" , graphUser . getProperty ( "last_name" ) ) ; </a> 0
<a> assertEquals ( "Scott" , graphUser . getLastName ( ) ) ; </a> 0
<a> assertEquals ( "Scott" , graphUser . asMap ( ) . get ( "last_name" ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanCastBetweenGraphObjectTypes ( ) { </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( ) ; </a> 0
<a> graphObject . setProperty ( "first_name" , "Mickey" ) ; </a> 0
<a> GraphUser graphUser = graphObject . cast ( GraphUser . class ) ; </a> 0
<a> assertTrue ( graphUser != null ) ; </a> 0
<a> assertEquals ( "Mickey" , graphUser . getFirstName ( ) ) ; </a> 0
<a> graphUser . setLastName ( "Mouse" ) ; </a> 0
<a> assertEquals ( "Mouse" , graphObject . getProperty ( "last_name" ) ) ; </a> 0
<a> } </a> 0
<a> interface Base extends GraphObject { </a> 0
<a> } </a> 0
<a> interface Derived extends Base { </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCastingToSameTypeGivesSameObject ( ) { </a> 0
<a> Base base = GraphObject . Factory . create ( Base . class ) ; </a> 0
<a> Base cast = base . cast ( Base . class ) ; </a> 0
<a> assertTrue ( base == cast ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCastingToBaseTypeGivesSameObject ( ) { </a> 0
<a> Derived derived = GraphObject . Factory . create ( Derived . class ) ; </a> 0
<a> Base cast = derived . cast ( Base . class ) ; </a> 0
<a> assertTrue ( derived == cast ) ; </a> 0
<a> cast = cast . cast ( Derived . class ) ; </a> 0
<a> assertTrue ( derived == cast ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanSetComplexTypes ( ) { </a> 0
<a> GraphLocation graphLocation = GraphObject . Factory . create ( GraphLocation . class ) ; </a> 0
<a> graphLocation . setCity ( "Seattle" ) ; </a> 0
<a> GraphPlace graphPlace = GraphObject . Factory . create ( GraphPlace . class ) ; </a> 0
<a> graphPlace . setLocation ( graphLocation ) ; </a> 0
<a> assertEquals ( graphLocation , graphPlace . getLocation ( ) ) ; </a> 0
<a> assertEquals ( "Seattle" , graphPlace . getLocation ( ) . getCity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanConvertFromJSON ( ) throws JSONException { </a> 0
<a> JSONObject jsonLocation = new JSONObject ( ) ; </a> 0
<a> jsonLocation . put ( "city" , "Paris" ) ; </a> 0
<a> jsonLocation . put ( "country" , "France" ) ; </a> 0
<a> JSONObject jsonPlace = new JSONObject ( ) ; </a> 0
<a> jsonPlace . put ( "location" , jsonLocation ) ; </a> 0
<a> jsonPlace . put ( "name" , "Eiffel Tower" ) ; </a> 0
<a> GraphPlace graphPlace = GraphObject . Factory . create ( jsonPlace , GraphPlace . class ) ; </a> 0
<a> GraphLocation graphLocation = graphPlace . getLocation ( ) ; </a> 0
<a> assertEquals ( "Paris" , graphLocation . getCity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanConvertFromGraphObject ( ) throws JSONException { </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( ) ; </a> 0
<a> graphObject . setProperty ( "city" , "Paris" ) ; </a> 0
<a> graphObject . setProperty ( "country" , "France" ) ; </a> 0
<a> JSONObject jsonPlace = new JSONObject ( ) ; </a> 0
<a> jsonPlace . put ( "location" , graphObject ) ; </a> 0
<a> jsonPlace . put ( "name" , "Eiffel Tower" ) ; </a> 0
<a> GraphPlace graphPlace = GraphObject . Factory . create ( jsonPlace , GraphPlace . class ) ; </a> 0
<a> GraphLocation graphLocation = graphPlace . getLocation ( ) ; </a> 0
<a> assertEquals ( "Paris" , graphLocation . getCity ( ) ) ; </a> 0
<a> } </a> 0
<a> private abstract class GraphObjectClass implements GraphObject { </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanConvertNumbers ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "double_as_string" , 3.14159 ) ; </a> 0
<a> jsonObject . put ( "int_as_string" , 42 ) ; </a> 0
<a> GraphMetric metric = GraphObject . Factory . create ( jsonObject , GraphMetric . class ) ; </a> 0
<a> assertEquals ( "42" , metric . getIntAsString ( ) ) ; </a> 0
<a> assertNotNull ( metric . getDoubleAsString ( ) ) ; </a> 0
<a> assertTrue ( metric . getDoubleAsString ( ) . startsWith ( "3.14159" ) ) ; </a> 0
<a> } </a> 0
<a> private interface GraphMetric extends GraphObject { </a> 0
<a> String getIntAsString ( ) ; </a> 0
<a> String getDoubleAsString ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantWrapNonInterface ( ) { </a> 0
<a> try { </a> 0
<a> GraphObject . Factory . create ( GraphObjectClass . class ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( FacebookGraphObjectException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface BadNoParameterMethodNameGraphObject extends GraphObject { </a> 0
<a> Object floppityFlee ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantWrapBadZeroParameterMethodName ( ) { </a> 0
<a> try { </a> 0
<a> GraphObject . Factory . create ( BadNoParameterMethodNameGraphObject . class ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( FacebookGraphObjectException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface BadSingleParameterMethodNameGraphObject extends GraphObject { </a> 0
<a> void floppityFlee ( Object obj ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantWrapBadSingleParameterMethodName ( ) { </a> 0
<a> try { </a> 0
<a> GraphObject . Factory . create ( BadSingleParameterMethodNameGraphObject . class ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( FacebookGraphObjectException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface BadGetterNameGraphObject extends GraphObject { </a> 0
<a> void get ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantWrapBadGetterName ( ) { </a> 0
<a> try { </a> 0
<a> GraphObject . Factory . create ( BadGetterNameGraphObject . class ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( FacebookGraphObjectException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface BadGetterParamsGraphObject extends GraphObject { </a> 0
<a> Object getFoo ( Object obj ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantWrapBadGetterParams ( ) { </a> 0
<a> try { </a> 0
<a> GraphObject . Factory . create ( BadGetterParamsGraphObject . class ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( FacebookGraphObjectException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface BadGetterReturnTypeGraphObject extends GraphObject { </a> 0
<a> void getFoo ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantWrapBadGetterReturnType ( ) { </a> 0
<a> try { </a> 0
<a> GraphObject . Factory . create ( BadGetterReturnTypeGraphObject . class ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( FacebookGraphObjectException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface BadSetterNameGraphObject extends GraphObject { </a> 0
<a> void set ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantWrapBadSetterName ( ) { </a> 0
<a> try { </a> 0
<a> GraphObject . Factory . create ( BadSetterNameGraphObject . class ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( FacebookGraphObjectException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface BadSetterParamsGraphObject extends GraphObject { </a> 0
<a> void setFoo ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantWrapBadSetterParams ( ) { </a> 0
<a> try { </a> 0
<a> GraphObject . Factory . create ( BadSetterParamsGraphObject . class ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( FacebookGraphObjectException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface BadSetterReturnTypeGraphObject extends GraphObject { </a> 0
<a> Object setFoo ( Object obj ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantWrapBadSetterReturnType ( ) { </a> 0
<a> try { </a> 0
<a> GraphObject . Factory . create ( BadSetterReturnTypeGraphObject . class ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( FacebookGraphObjectException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface BadBaseInterfaceGraphObject extends BadSetterReturnTypeGraphObject { </a> 0
<a> void setBar ( Object obj ) ; </a> 0
<a> Object getBar ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantWrapBadBaseInterface ( ) { </a> 0
<a> try { </a> 0
<a> GraphObject . Factory . create ( BadBaseInterfaceGraphObject . class ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( FacebookGraphObjectException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface GoodPropertyOverrideInterfaceGraphObject extends GraphObject { </a> 0
<a> void setDefaultName ( String s ) ; </a> 0
<a> String getAnotherDefaultName ( ) ; </a> 0
<a> @ PropertyName ( "another_default_name" ) </a> 0
<a> void putSomething ( String s ) ; </a> 0
<a> @ PropertyName ( "default_name" ) </a> 0
<a> String retrieveSomething ( ) ; </a> 0
<a> @ PropertyName ( "MixedCase" ) </a> 0
<a> void setMixedCase ( String s ) ; </a> 0
<a> @ PropertyName ( "MixedCase" ) </a> 0
<a> String getMixedCase ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanOverrideGraphPropertyNames ( ) { </a> 0
<a> GoodPropertyOverrideInterfaceGraphObject graphObject = </a> 0
<a> GraphObject . Factory . create ( GoodPropertyOverrideInterfaceGraphObject . class ) ; </a> 0
<a> String testValue = "flu-blah" ; </a> 0
<a> graphObject . setDefaultName ( testValue ) ; </a> 0
<a> Assert . assertEquals ( testValue , graphObject . retrieveSomething ( ) ) ; </a> 0
<a> testValue = testValue + "1" ; </a> 0
<a> graphObject . putSomething ( testValue ) ; </a> 0
<a> Assert . assertEquals ( testValue , graphObject . getAnotherDefaultName ( ) ) ; </a> 0
<a> testValue = testValue + "2" ; </a> 0
<a> graphObject . setMixedCase ( testValue ) ; </a> 0
<a> Assert . assertEquals ( testValue , graphObject . getMixedCase ( ) ) ; </a> 0
<a> } </a> 0
<a> private interface BadPropertyOverrideInterfaceGraphObject extends GraphObject { </a> 0
<a> @ PropertyName ( "" ) </a> 0
<a> void setMissingProperty ( Object value ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantWrapBadPropertyNameOverrides ( ) { </a> 0
<a> try { </a> 0
<a> GraphObject . Factory . create ( BadPropertyOverrideInterfaceGraphObject . class ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( FacebookGraphObjectException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testObjectEquals ( ) { </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( ) ; </a> 0
<a> graphObject . setProperty ( "aKey" , "aValue" ) ; </a> 0
<a> assertTrue ( graphObject . equals ( graphObject ) ) ; </a> 0
<a> GraphPlace graphPlace = graphObject . cast ( GraphPlace . class ) ; </a> 0
<a> assertTrue ( graphObject . equals ( graphPlace ) ) ; </a> 0
<a> assertTrue ( graphPlace . equals ( graphObject ) ) ; </a> 0
<a> GraphObject aDifferentGraphObject = GraphObject . Factory . create ( ) ; </a> 0
<a> aDifferentGraphObject . setProperty ( "aKey" , "aDifferentValue" ) ; </a> 0
<a> assertFalse ( graphObject . equals ( aDifferentGraphObject ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testGetProperty ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> assertEquals ( "world" , graphObject . getProperty ( "hello" ) ) ; </a> 0
<a> assertTrue ( graphObject . getProperty ( "fred" ) == null ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testSetProperty ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> graphObject . setProperty ( "hello" , "world" ) ; </a> 0
<a> graphObject . setProperty ( "don't imagine" , "purple elephants" ) ; </a> 0
<a> assertEquals ( "world" , jsonObject . getString ( "hello" ) ) ; </a> 0
<a> assertEquals ( "purple elephants" , jsonObject . getString ( "don't imagine" ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testRemoveProperty ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "whirled" , "peas" ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> graphObject . setProperty ( "hello" , "world" ) ; </a> 0
<a> graphObject . setProperty ( "don't imagine" , "purple elephants" ) ; </a> 0
<a> assertEquals ( "world" , jsonObject . getString ( "hello" ) ) ; </a> 0
<a> assertEquals ( "purple elephants" , jsonObject . getString ( "don't imagine" ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapClear ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> assertEquals ( 1 , jsonObject . length ( ) ) ; </a> 0
<a> graphObject . asMap ( ) . clear ( ) ; </a> 0
<a> assertEquals ( 0 , jsonObject . length ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapContainsKey ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> assertTrue ( graphObject . asMap ( ) . containsKey ( "hello" ) ) ; </a> 0
<a> assertFalse ( graphObject . asMap ( ) . containsKey ( "hocus" ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapContainsValue ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> assertTrue ( graphObject . asMap ( ) . containsValue ( "world" ) ) ; </a> 0
<a> assertFalse ( graphObject . asMap ( ) . containsValue ( "pocus" ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapEntrySet ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> Set < Entry < String , Object > > entrySet = graphObject . asMap ( ) . entrySet ( ) ; </a> 0
<a> assertEquals ( 2 , entrySet . size ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapGet ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> assertEquals ( "world" , graphObject . asMap ( ) . get ( "hello" ) ) ; </a> 0
<a> assertTrue ( graphObject . getProperty ( "fred" ) == null ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapGetReturnsNullForMissingProperty ( ) throws JSONException { </a> 0
<a> GraphUser graphUser = GraphObject . Factory . create ( GraphUser . class ) ; </a> 0
<a> assertNull ( graphUser . getBirthday ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapIsEmpty ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> assertTrue ( graphObject . asMap ( ) . isEmpty ( ) ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> assertFalse ( graphObject . asMap ( ) . isEmpty ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapKeySet ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> Set < String > keySet = graphObject . asMap ( ) . keySet ( ) ; </a> 0
<a> assertEquals ( 2 , keySet . size ( ) ) ; </a> 0
<a> assertTrue ( keySet . contains ( "hello" ) ) ; </a> 0
<a> assertTrue ( keySet . contains ( "hocus" ) ) ; </a> 0
<a> assertFalse ( keySet . contains ( "world" ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapPut ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> graphObject . setProperty ( "hello" , "world" ) ; </a> 0
<a> graphObject . setProperty ( "hocus" , "pocus" ) ; </a> 0
<a> assertEquals ( "pocus" , jsonObject . get ( "hocus" ) ) ; </a> 0
<a> assertEquals ( 2 , jsonObject . length ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapPutOfWrapperPutsJSONObject ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> graphObject . setProperty ( "hello" , "world" ) ; </a> 0
<a> graphObject . setProperty ( "hocus" , "pocus" ) ; </a> 0
<a> GraphObject parentObject = GraphObject . Factory . create ( ) ; </a> 0
<a> parentObject . setProperty ( "key" , graphObject ) ; </a> 0
<a> JSONObject jsonParent = parentObject . getInnerJSONObject ( ) ; </a> 0
<a> Object obj = jsonParent . opt ( "key" ) ; </a> 0
<a> assertNotNull ( obj ) ; </a> 0
<a> assertEquals ( jsonObject , obj ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapPutOfWrapperPutsJSONArray ( ) throws JSONException { </a> 0
<a> JSONArray jsonArray = new JSONArray ( ) ; </a> 0
<a> GraphObjectList < String > graphObjectList = GraphObject . Factory </a> 0
<a> . createList ( jsonArray , String . class ) ; </a> 0
<a> graphObjectList . add ( "hello" ) ; </a> 0
<a> graphObjectList . add ( "world" ) ; </a> 0
<a> GraphObject parentObject = GraphObject . Factory . create ( ) ; </a> 0
<a> parentObject . setProperty ( "key" , graphObjectList ) ; </a> 0
<a> JSONObject jsonParent = parentObject . getInnerJSONObject ( ) ; </a> 0
<a> Object obj = jsonParent . opt ( "key" ) ; </a> 0
<a> assertNotNull ( obj ) ; </a> 0
<a> assertEquals ( jsonArray , obj ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapPutAll ( ) throws JSONException { </a> 0
<a> HashMap < String , Object > map = new HashMap < String , Object > ( ) ; </a> 0
<a> map . put ( "hello" , "world" ) ; </a> 0
<a> map . put ( "hocus" , "pocus" ) ; </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> graphObject . asMap ( ) . putAll ( map ) ; </a> 0
<a> assertEquals ( "pocus" , jsonObject . get ( "hocus" ) ) ; </a> 0
<a> assertEquals ( 2 , jsonObject . length ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapRemove ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> graphObject . removeProperty ( "hello" ) ; </a> 0
<a> assertEquals ( 1 , jsonObject . length ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapSize ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> assertEquals ( 2 , graphObject . asMap ( ) . size ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMapValues ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> Collection < Object > values = graphObject . asMap ( ) . values ( ) ; </a> 0
<a> assertEquals ( 2 , values . size ( ) ) ; </a> 0
<a> assertTrue ( values . contains ( "world" ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testGetInnerJSONObject ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> assertEquals ( jsonObject , graphObject . getInnerJSONObject ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testSettingGraphObjectProxyStoresJSONObject ( ) throws JSONException { </a> 0
<a> GraphPlace graphPlace = GraphObject . Factory . create ( GraphPlace . class ) ; </a> 0
<a> GraphLocation graphLocation = GraphObject . Factory . create ( GraphLocation . class ) ; </a> 0
<a> graphPlace . setLocation ( graphLocation ) ; </a> 0
<a> assertEquals ( graphLocation . getInnerJSONObject ( ) , graphPlace . getInnerJSONObject ( ) . get ( "location" ) ) ; </a> 0
<a> } </a> 0
<a> private interface DateGraphObject extends GraphObject { </a> 0
<a> Date getDate1 ( ) ; </a> 0
<a> Date getDate2 ( ) ; </a> 0
<a> Date getDate3 ( ) ; </a> 0
<a> Date getDate4 ( ) ; </a> 0
<a> void setDate4 ( Date date ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testGetStringsAsDates ( ) { </a> 0
<a> DateGraphObject dates = GraphObject . Factory . create ( DateGraphObject . class ) ; </a> 0
<a> dates . setProperty ( "date1" , "2012-07-04" ) ; </a> 0
<a> dates . setProperty ( "date2" , "2012-07-04T19:30:50" ) ; </a> 0
<a> dates . setProperty ( "date3" , "2012-07-04T19:20:40-0400" ) ; </a> 0
<a> Calendar cal = new GregorianCalendar ( ) ; </a> 0
<a> cal . set ( Calendar . MILLISECOND , 0 ) ; </a> 0
<a> cal . set ( 2012 , 6 , 4 , 0 , 0 , 0 ) ; </a> 0
<a> Date expectedDate1 = cal . getTime ( ) ; </a> 0
<a> Date date1 = dates . getDate1 ( ) ; </a> 0
<a> assertEquals ( expectedDate1 , date1 ) ; </a> 0
<a> cal . set ( 2012 , 6 , 4 , 19 , 30 , 50 ) ; </a> 0
<a> Date expectedDate2 = cal . getTime ( ) ; </a> 0
<a> Date date2 = dates . getDate2 ( ) ; </a> 0
<a> assertEquals ( expectedDate2 , date2 ) ; </a> 0
<a> cal = new GregorianCalendar ( TimeZone . getTimeZone ( "GMT" ) ) ; </a> 0
<a> cal . set ( Calendar . MILLISECOND , 0 ) ; </a> 0
<a> cal . set ( 2012 , 6 , 4 , 23 , 20 , 40 ) ; </a> 0
<a> Date expectedDate3 = cal . getTime ( ) ; </a> 0
<a> Date date3 = dates . getDate3 ( ) ; </a> 0
<a> assertEquals ( expectedDate3 , date3 ) ; </a> 0
<a> cal . set ( 2012 , 9 , 28 , 9 , 53 , 0 ) ; </a> 0
<a> Date expectedDate4 = cal . getTime ( ) ; </a> 0
<a> dates . setDate4 ( expectedDate4 ) ; </a> 0
<a> Date date4 = dates . getDate4 ( ) ; </a> 0
<a> assertEquals ( expectedDate4 , date4 ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionAdd ( ) throws JSONException { </a> 0
<a> JSONArray array = new JSONArray ( ) ; </a> 0
<a> Collection < Integer > collection = GraphObject . Factory . createList ( array , Integer . class ) ; </a> 0
<a> collection . add ( 5 ) ; </a> 0
<a> assertTrue ( array . length ( ) == 1 ) ; </a> 0
<a> assertTrue ( array . optInt ( 0 ) == 5 ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionAddAll ( ) throws JSONException { </a> 0
<a> JSONArray array = new JSONArray ( ) ; </a> 0
<a> Collection < Integer > collectionToAdd = Arrays . asList ( 5 , - 1 ) ; </a> 0
<a> Collection < Integer > collection = GraphObject . Factory . createList ( array , Integer . class ) ; </a> 0
<a> collection . addAll ( collectionToAdd ) ; </a> 0
<a> assertTrue ( array . length ( ) == 2 ) ; </a> 0
<a> assertTrue ( array . optInt ( 0 ) == 5 ) ; </a> 0
<a> assertTrue ( array . optInt ( 1 ) == - 1 ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionContains ( ) throws JSONException { </a> 0
<a> JSONArray array = new JSONArray ( ) ; </a> 0
<a> array . put ( 5 ) ; </a> 0
<a> Collection < Integer > collection = GraphObject . Factory . createList ( array , Integer . class ) ; </a> 0
<a> assertTrue ( collection . contains ( 5 ) ) ; </a> 0
<a> assertFalse ( collection . contains ( 6 ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionContainsAll ( ) throws JSONException { </a> 0
<a> JSONArray array = new JSONArray ( ) ; </a> 0
<a> array . put ( 5 ) ; </a> 0
<a> array . put ( - 1 ) ; </a> 0
<a> Collection < Integer > collection = GraphObject . Factory . createList ( array , Integer . class ) ; </a> 0
<a> assertTrue ( collection . containsAll ( Arrays . asList ( 5 ) ) ) ; </a> 0
<a> assertTrue ( collection . containsAll ( Arrays . asList ( 5 , - 1 ) ) ) ; </a> 0
<a> assertFalse ( collection . containsAll ( Arrays . asList ( 5 , - 1 , 2 ) ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionIsEmpty ( ) throws JSONException { </a> 0
<a> JSONArray array = new JSONArray ( ) ; </a> 0
<a> Collection < Integer > collection = GraphObject . Factory . createList ( array , Integer . class ) ; </a> 0
<a> assertTrue ( collection . isEmpty ( ) ) ; </a> 0
<a> array . put ( 5 ) ; </a> 0
<a> assertFalse ( collection . isEmpty ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionIterator ( ) throws JSONException { </a> 0
<a> JSONArray array = new JSONArray ( ) ; </a> 0
<a> array . put ( 5 ) ; </a> 0
<a> array . put ( - 1 ) ; </a> 0
<a> Collection < Integer > collection = GraphObject . Factory . createList ( array , Integer . class ) ; </a> 0
<a> Iterator < Integer > iter = collection . iterator ( ) ; </a> 0
<a> assertTrue ( iter . hasNext ( ) ) ; </a> 0
<a> assertTrue ( iter . next ( ) == 5 ) ; </a> 0
<a> assertTrue ( iter . hasNext ( ) ) ; </a> 0
<a> assertTrue ( iter . next ( ) == - 1 ) ; </a> 0
<a> assertFalse ( iter . hasNext ( ) ) ; </a> 0
<a> for ( Integer i : collection ) { </a> 0
<a> assertNotSame ( 0 , i ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionIteratorOfGraphObject ( ) throws JSONException { </a> 0
<a> Collection < GraphLocation > collection = GraphObject . Factory . createList ( GraphLocation . class ) ; </a> 0
<a> GraphLocation seattle = GraphObject . Factory . create ( GraphLocation . class ) ; </a> 0
<a> seattle . setCity ( "Seattle" ) ; </a> 0
<a> collection . add ( seattle ) ; </a> 0
<a> GraphLocation paris = GraphObject . Factory . create ( GraphLocation . class ) ; </a> 0
<a> paris . setCity ( "Paris" ) ; </a> 0
<a> collection . add ( paris ) ; </a> 0
<a> Iterator < GraphLocation > iter = collection . iterator ( ) ; </a> 0
<a> assertTrue ( iter . hasNext ( ) ) ; </a> 0
<a> assertEquals ( seattle , iter . next ( ) ) ; </a> 0
<a> assertTrue ( iter . hasNext ( ) ) ; </a> 0
<a> assertEquals ( paris , iter . next ( ) ) ; </a> 0
<a> assertFalse ( iter . hasNext ( ) ) ; </a> 0
<a> for ( GraphLocation location : collection ) { </a> 0
<a> assertTrue ( location != null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionSize ( ) throws JSONException { </a> 0
<a> JSONArray array = new JSONArray ( ) ; </a> 0
<a> Collection < Integer > collection = GraphObject . Factory . createList ( array , Integer . class ) ; </a> 0
<a> assertEquals ( 0 , collection . size ( ) ) ; </a> 0
<a> array . put ( 5 ) ; </a> 0
<a> assertEquals ( 1 , collection . size ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionClearThrows ( ) throws JSONException { </a> 0
<a> try { </a> 0
<a> Collection < Integer > collection = GraphObject . Factory . createList ( Integer . class ) ; </a> 0
<a> collection . clear ( ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( UnsupportedOperationException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionRemoveThrows ( ) throws JSONException { </a> 0
<a> try { </a> 0
<a> Collection < Integer > collection = GraphObject . Factory . createList ( Integer . class ) ; </a> 0
<a> collection . remove ( 5 ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( UnsupportedOperationException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionRemoveAllThrows ( ) throws JSONException { </a> 0
<a> try { </a> 0
<a> Collection < Integer > collection = GraphObject . Factory . createList ( Integer . class ) ; </a> 0
<a> collection . removeAll ( Arrays . asList ( ) ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( UnsupportedOperationException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionRetainAllThrows ( ) throws JSONException { </a> 0
<a> try { </a> 0
<a> Collection < Integer > collection = GraphObject . Factory . createList ( Integer . class ) ; </a> 0
<a> collection . retainAll ( Arrays . asList ( ) ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( UnsupportedOperationException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface Locations extends GraphObject { </a> 0
<a> Collection < GraphLocation > getLocations ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testObjectWrapsJSONCollection ( ) throws JSONException { </a> 0
<a> JSONObject jsonLocation = new JSONObject ( ) ; </a> 0
<a> jsonLocation . put ( "city" , "Seattle" ) ; </a> 0
<a> JSONArray jsonArray = new JSONArray ( ) ; </a> 0
<a> jsonArray . put ( jsonLocation ) ; </a> 0
<a> JSONObject jsonLocations = new JSONObject ( ) ; </a> 0
<a> jsonLocations . put ( "locations" , jsonArray ) ; </a> 0
<a> Locations locations = GraphObject . Factory . create ( jsonLocations , Locations . class ) ; </a> 0
<a> Collection < GraphLocation > locationsGraphObjectCollection = locations . getLocations ( ) ; </a> 0
<a> assertTrue ( locationsGraphObjectCollection != null ) ; </a> 0
<a> GraphLocation graphLocation = locationsGraphObjectCollection . iterator ( ) . next ( ) ; </a> 0
<a> assertTrue ( graphLocation != null ) ; </a> 0
<a> assertEquals ( "Seattle" , graphLocation . getCity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testObjectWrapsIterable ( ) throws JSONException { </a> 0
<a> GraphUser user = GraphObject . Factory . create ( GraphUser . class ) ; </a> 0
<a> user . setFirstName ( "Foo" ) ; </a> 0
<a> user . setLastName ( "Bar" ) ; </a> 0
<a> List < GraphUser > users = new ArrayList < GraphUser > ( ) ; </a> 0
<a> users . add ( user ) ; </a> 0
<a> OpenGraphAction action = GraphObject . Factory . create ( OpenGraphAction . class ) ; </a> 0
<a> action . setTags ( users ) ; </a> 0
<a> String json = action . getInnerJSONObject ( ) . toString ( ) ; </a> 0
<a> assertTrue ( "JSON string should contain last_name" , json . contains ( "last_name" ) ) ; </a> 0
<a> Object tags = action . getInnerJSONObject ( ) . get ( "tags" ) ; </a> 0
<a> assertNotNull ( "tags should not be null" , tags ) ; </a> 0
<a> assertTrue ( "tags should be JSONArray" , tags instanceof JSONArray ) ; </a> 0
<a> List < GraphObject > retrievedUsers = action . getTags ( ) ; </a> 0
<a> assertEquals ( "Size should be 1" , 1 , retrievedUsers . size ( ) ) ; </a> 0
<a> GraphUser retrievedUser = retrievedUsers . get ( 0 ) . cast ( GraphUser . class ) ; </a> 0
<a> assertEquals ( "First name should be Foo" , "Foo" , retrievedUser . getFirstName ( ) ) ; </a> 0
<a> assertEquals ( "Last name should be Bar" , "Bar" , retrievedUser . getLastName ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionWrapsJSONObject ( ) throws JSONException { </a> 0
<a> JSONObject jsonLocation = new JSONObject ( ) ; </a> 0
<a> jsonLocation . put ( "city" , "Seattle" ) ; </a> 0
<a> JSONArray jsonArray = new JSONArray ( ) ; </a> 0
<a> jsonArray . put ( jsonLocation ) ; </a> 0
<a> Collection < GraphLocation > locationsGraphObjectCollection = GraphObject . Factory </a> 0
<a> . createList ( jsonArray , </a> 0
<a> GraphLocation . class ) ; </a> 0
<a> assertTrue ( locationsGraphObjectCollection != null ) ; </a> 0
<a> GraphLocation graphLocation = locationsGraphObjectCollection . iterator ( ) . next ( ) ; </a> 0
<a> assertTrue ( graphLocation != null ) ; </a> 0
<a> assertEquals ( "Seattle" , graphLocation . getCity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCannotCastCollectionOfNonGraphObjects ( ) throws JSONException { </a> 0
<a> try { </a> 0
<a> GraphObjectList < Integer > collection = GraphObject . Factory . createList ( Integer . class ) ; </a> 0
<a> collection . castToListOf ( GraphLocation . class ) ; </a> 0
<a> fail ( "Expected exception" ) ; </a> 0
<a> } catch ( FacebookGraphObjectException exception ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanCastCollectionOfGraphObjects ( ) throws JSONException { </a> 0
<a> JSONObject jsonSeattle = new JSONObject ( ) ; </a> 0
<a> jsonSeattle . put ( "city" , "Seattle" ) ; </a> 0
<a> JSONArray jsonArray = new JSONArray ( ) ; </a> 0
<a> jsonArray . put ( jsonSeattle ) ; </a> 0
<a> GraphObjectList < GraphObject > collection = GraphObject . Factory </a> 0
<a> . createList ( jsonArray , GraphObject . class ) ; </a> 0
<a> GraphObjectList < GraphLocation > locationCollection = collection . castToListOf ( GraphLocation . class ) ; </a> 0
<a> assertTrue ( locationCollection != null ) ; </a> 0
<a> GraphLocation seattle = locationCollection . iterator ( ) . next ( ) ; </a> 0
<a> assertTrue ( seattle != null ) ; </a> 0
<a> assertEquals ( "Seattle" , seattle . getCity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCastingCollectionToSameTypeGivesSameObject ( ) { </a> 0
<a> GraphObjectList < Base > base = GraphObject . Factory . createList ( Base . class ) ; </a> 0
<a> GraphObjectList < Base > cast = base . castToListOf ( Base . class ) ; </a> 0
<a> assertTrue ( base == cast ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCastingCollectionToBaseTypeGivesSameObject ( ) { </a> 0
<a> GraphObjectList < Derived > derived = GraphObject . Factory . createList ( Derived . class ) ; </a> 0
<a> GraphObjectList < Base > cast = derived . castToListOf ( Base . class ) ; </a> 0
<a> assertTrue ( ( GraphObjectList < ? > ) derived == ( GraphObjectList < ? > ) cast ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanGetInnerJSONArray ( ) throws JSONException { </a> 0
<a> JSONArray jsonArray = new JSONArray ( ) ; </a> 0
<a> GraphObjectList < GraphObject > collection = GraphObject . Factory </a> 0
<a> . createList ( jsonArray , GraphObject . class ) ; </a> 0
<a> assertEquals ( jsonArray , collection . getInnerJSONArray ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanGetRandomAccess ( ) throws JSONException { </a> 0
<a> JSONArray jsonArray = new JSONArray ( ) ; </a> 0
<a> jsonArray . put ( "Seattle" ) ; </a> 0
<a> jsonArray . put ( "Menlo Park" ) ; </a> 0
<a> GraphObjectList < String > collection = GraphObject . Factory </a> 0
<a> . createList ( jsonArray , String . class ) ; </a> 0
<a> assertEquals ( "Menlo Park" , collection . get ( 1 ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanSetRandomAccess ( ) throws JSONException { </a> 0
<a> JSONArray jsonArray = new JSONArray ( ) ; </a> 0
<a> GraphObjectList < String > collection = GraphObject . Factory </a> 0
<a> . createList ( jsonArray , String . class ) ; </a> 0
<a> collection . add ( "Seattle" ) ; </a> 0
<a> collection . add ( "Menlo Park" ) ; </a> 0
<a> collection . set ( 1 , "Ann Arbor" ) ; </a> 0
<a> assertEquals ( "Ann Arbor" , collection . get ( 1 ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCollectionPutOfWrapperPutsJSONObject ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> GraphObject graphObject = GraphObject . Factory . create ( jsonObject ) ; </a> 0
<a> graphObject . setProperty ( "hello" , "world" ) ; </a> 0
<a> graphObject . setProperty ( "hocus" , "pocus" ) ; </a> 0
<a> GraphObjectList < GraphObject > parentList = GraphObject . Factory </a> 0
<a> . createList ( GraphObject . class ) ; </a> 0
<a> parentList . add ( graphObject ) ; </a> 0
<a> JSONArray jsonArray = parentList . getInnerJSONArray ( ) ; </a> 0
<a> Object obj = jsonArray . opt ( 0 ) ; </a> 0
<a> assertNotNull ( obj ) ; </a> 0
<a> assertEquals ( jsonObject , obj ) ; </a> 0
<a> parentList . set ( 0 , graphObject ) ; </a> 0
<a> obj = jsonArray . opt ( 0 ) ; </a> 0
<a> assertNotNull ( obj ) ; </a> 0
<a> assertEquals ( jsonObject , obj ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCamelCaseToLowercase ( ) { </a> 0
<a> assertEquals ( "hello_world" , GraphObject . Factory </a> 0
<a> . convertCamelCaseToLowercaseWithUnderscores ( "HelloWorld" ) ) ; </a> 0
<a> assertEquals ( "hello_world" , GraphObject . Factory </a> 0
<a> . convertCamelCaseToLowercaseWithUnderscores ( "helloWorld" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . model ; </a> 0
<a> import android . test . AndroidTestCase ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> import java . util . Set ; </a> 0
<a> public final class JsonUtilTests extends AndroidTestCase { </a> 0
<a> @ SmallTest @ MediumTest @ LargeTest </a> 0
<a> public void testJsonObjectClear ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> JsonUtil . jsonObjectClear ( jsonObject ) ; </a> 0
<a> assertEquals ( 0 , jsonObject . length ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest @ MediumTest @ LargeTest </a> 0
<a> public void testJsonObjectContainsValue ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> assertTrue ( JsonUtil . jsonObjectContainsValue ( jsonObject , "pocus" ) ) ; </a> 0
<a> assertFalse ( JsonUtil . jsonObjectContainsValue ( jsonObject , "Fred" ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest @ MediumTest @ LargeTest </a> 0
<a> public void testJsonObjectEntrySet ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> Set < Entry < String , Object > > entrySet = JsonUtil . jsonObjectEntrySet ( jsonObject ) ; </a> 0
<a> assertEquals ( 2 , entrySet . size ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest @ MediumTest @ LargeTest </a> 0
<a> public void testJsonObjectKeySet ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> Set < String > keySet = JsonUtil . jsonObjectKeySet ( jsonObject ) ; </a> 0
<a> assertEquals ( 2 , keySet . size ( ) ) ; </a> 0
<a> assertTrue ( keySet . contains ( "hello" ) ) ; </a> 0
<a> assertFalse ( keySet . contains ( "world" ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest @ MediumTest @ LargeTest </a> 0
<a> public void testJsonObjectPutAll ( ) throws JSONException { </a> 0
<a> HashMap < String , Object > map = new HashMap < String , Object > ( ) ; </a> 0
<a> map . put ( "hello" , "world" ) ; </a> 0
<a> map . put ( "hocus" , "pocus" ) ; </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> JsonUtil . jsonObjectPutAll ( jsonObject , map ) ; </a> 0
<a> assertEquals ( "pocus" , jsonObject . get ( "hocus" ) ) ; </a> 0
<a> assertEquals ( 2 , jsonObject . length ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest @ MediumTest @ LargeTest </a> 0
<a> public void testJsonObjectValues ( ) throws JSONException { </a> 0
<a> JSONObject jsonObject = new JSONObject ( ) ; </a> 0
<a> jsonObject . put ( "hello" , "world" ) ; </a> 0
<a> jsonObject . put ( "hocus" , "pocus" ) ; </a> 0
<a> Collection < Object > values = JsonUtil . jsonObjectValues ( jsonObject ) ; </a> 0
<a> assertEquals ( 2 , values . size ( ) ) ; </a> 0
<a> assertTrue ( values . contains ( "world" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> import android . widget . LinearLayout ; </a> 0
<a> import com . facebook . FacebookActivityTestCase ; </a> 0
<a> public class FragmentTestCase < T extends FragmentTestCase . TestFragmentActivity < ? > > extends FacebookActivityTestCase < T > { </a> 0
<a> public FragmentTestCase ( Class < T > activityClass ) { </a> 0
<a> super ( activityClass ) ; </a> 0
<a> } </a> 0
<a> protected T getTestActivity ( ) { </a> 0
<a> return ( T ) getActivity ( ) ; </a> 0
<a> } </a> 0
<a> public static class TestFragmentActivity < T extends Fragment > extends FragmentActivity { </a> 0
<a> public static final int FRAGMENT_ID = 0xFACE ; </a> 0
<a> private Class < T > fragmentClass ; </a> 0
<a> private int fragmentId ; </a> 0
<a> protected TestFragmentActivity ( Class < T > fragmentClass ) { </a> 0
<a> this . fragmentClass = fragmentClass ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> if ( getAutoCreateUI ( ) ) { </a> 0
<a> setContentToFragment ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected boolean getAutoCreateUI ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> void setContentToFragment ( T fragment ) { </a> 0
<a> if ( fragment == null ) { </a> 0
<a> fragment = createFragment ( ) ; </a> 0
<a> } </a> 0
<a> LinearLayout layout = new LinearLayout ( this ) ; </a> 0
<a> layout . setOrientation ( LinearLayout . VERTICAL ) ; </a> 0
<a> layout . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . FILL_PARENT , </a> 0
<a> LinearLayout . LayoutParams . FILL_PARENT ) ) ; </a> 0
<a> layout . setId ( FRAGMENT_ID ) ; </a> 0
<a> getSupportFragmentManager ( ) . beginTransaction ( ) </a> 0
<a> . add ( FRAGMENT_ID , fragment ) </a> 0
<a> . commit ( ) ; </a> 0
<a> fragmentId = FRAGMENT_ID ; </a> 0
<a> setContentView ( layout ) ; </a> 0
<a> } </a> 0
<a> void setContentToLayout ( int i , int fragmentId ) { </a> 0
<a> this . fragmentId = fragmentId ; </a> 0
<a> setContentView ( i ) ; </a> 0
<a> } </a> 0
<a> T createFragment ( ) { </a> 0
<a> try { </a> 0
<a> return fragmentClass . newInstance ( ) ; </a> 0
<a> } catch ( IllegalAccessException e ) { </a> 0
<a> fail ( "could not create fragment" ) ; </a> 0
<a> } catch ( InstantiationException e ) { </a> 0
<a> fail ( "could not create fragment" ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> T getFragment ( ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> T fragment = ( T ) getSupportFragmentManager ( ) . findFragmentById ( fragmentId ) ; </a> 0
<a> return fragment ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . test . TouchUtils ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . widget . CheckBox ; </a> 0
<a> import android . widget . ListView ; </a> 0
<a> import com . facebook . TestBlocker ; </a> 0
<a> import com . facebook . TestSession ; </a> 0
<a> import com . facebook . sdk . tests . R ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> public class FriendPickerFragmentTests extends FragmentTestCase < FriendPickerFragmentTests . TestActivity > { </a> 0
<a> public FriendPickerFragmentTests ( ) { </a> 0
<a> super ( TestActivity . class ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanSetParametersProgrammatically ( ) throws Throwable { </a> 0
<a> TestActivity activity = getActivity ( ) ; </a> 0
<a> assertNotNull ( activity ) ; </a> 0
<a> runAndBlockOnUiThread ( 0 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putString ( FriendPickerFragment . USER_ID_BUNDLE_KEY , "4" ) ; </a> 0
<a> bundle . putBoolean ( FriendPickerFragment . MULTI_SELECT_BUNDLE_KEY , false ) ; </a> 0
<a> bundle . putBoolean ( FriendPickerFragment . SHOW_PICTURES_BUNDLE_KEY , false ) ; </a> 0
<a> bundle . putString ( FriendPickerFragment . EXTRA_FIELDS_BUNDLE_KEY , "middle_name,link" ) ; </a> 0
<a> FriendPickerFragment fragment = new FriendPickerFragment ( bundle ) ; </a> 0
<a> getActivity ( ) . setContentToFragment ( fragment ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> final FriendPickerFragment fragment = activity . getFragment ( ) ; </a> 0
<a> assertNotNull ( fragment ) ; </a> 0
<a> assertEquals ( "4" , fragment . getUserId ( ) ) ; </a> 0
<a> assertEquals ( false , fragment . getMultiSelect ( ) ) ; </a> 0
<a> assertEquals ( false , fragment . getShowPictures ( ) ) ; </a> 0
<a> Collection < String > extraFields = fragment . getExtraFields ( ) ; </a> 0
<a> assertTrue ( extraFields . contains ( "middle_name" ) ) ; </a> 0
<a> assertTrue ( extraFields . contains ( "link" ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanSetParametersViaLayout ( ) throws Throwable { </a> 0
<a> TestActivity activity = getActivity ( ) ; </a> 0
<a> assertNotNull ( activity ) ; </a> 0
<a> runAndBlockOnUiThread ( 0 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> getActivity ( ) . setContentToLayout ( R . layout . friend_picker_test_layout_1 , R . id . friend_picker_fragment ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> final FriendPickerFragment fragment = activity . getFragment ( ) ; </a> 0
<a> assertNotNull ( fragment ) ; </a> 0
<a> assertEquals ( false , fragment . getShowPictures ( ) ) ; </a> 0
<a> assertEquals ( false , fragment . getMultiSelect ( ) ) ; </a> 0
<a> Collection < String > extraFields = fragment . getExtraFields ( ) ; </a> 0
<a> assertTrue ( extraFields . contains ( "middle_name" ) ) ; </a> 0
<a> assertTrue ( extraFields . contains ( "link" ) ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testFriendsLoad ( ) throws Throwable { </a> 0
<a> TestActivity activity = getActivity ( ) ; </a> 0
<a> assertNotNull ( activity ) ; </a> 0
<a> runAndBlockOnUiThread ( 0 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> getActivity ( ) . setContentToFragment ( null ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> final FriendPickerFragment fragment = activity . getFragment ( ) ; </a> 0
<a> assertNotNull ( fragment ) ; </a> 0
<a> final TestSession session1 = openTestSessionWithSharedUser ( ) ; </a> 0
<a> TestSession session2 = openTestSessionWithSharedUser ( SECOND_TEST_USER_TAG ) ; </a> 0
<a> makeTestUsersFriends ( session1 , session2 ) ; </a> 0
<a> final TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> runAndBlockOnUiThread ( 2 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> fragment . setSession ( session1 ) ; </a> 0
<a> fragment . setOnDataChangedListener ( new PickerFragment . OnDataChangedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onDataChanged ( PickerFragment < ? > fragment ) { </a> 0
<a> blocker . signal ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> fragment . setExtraFields ( Arrays . asList ( "first_name" ) ) ; </a> 0
<a> fragment . loadData ( true ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> ListView listView = ( ListView ) fragment . getView ( ) . findViewById ( R . id . com_facebook_picker_list_view ) ; </a> 0
<a> assertNotNull ( listView ) ; </a> 0
<a> View firstChild = listView . getChildAt ( 0 ) ; </a> 0
<a> assertNotNull ( firstChild ) ; </a> 0
<a> CheckBox checkBox = ( CheckBox ) listView . findViewById ( R . id . com_facebook_picker_checkbox ) ; </a> 0
<a> assertNotNull ( checkBox ) ; </a> 0
<a> assertFalse ( checkBox . isChecked ( ) ) ; </a> 0
<a> assertEquals ( 0 , fragment . getSelection ( ) . size ( ) ) ; </a> 0
<a> TouchUtils . clickView ( this , firstChild ) ; </a> 0
<a> assertEquals ( 1 , fragment . getSelection ( ) . size ( ) ) ; </a> 0
<a> assertNotNull ( fragment . getSelection ( ) . iterator ( ) . next ( ) . getFirstName ( ) ) ; </a> 0
<a> assertTrue ( checkBox . isChecked ( ) ) ; </a> 0
<a> TouchUtils . clickView ( this , firstChild ) ; </a> 0
<a> assertEquals ( 0 , fragment . getSelection ( ) . size ( ) ) ; </a> 0
<a> assertFalse ( checkBox . isChecked ( ) ) ; </a> 0
<a> } </a> 0
<a> public static class TestActivity extends FragmentTestCase . TestFragmentActivity < FriendPickerFragment > { </a> 0
<a> public TestActivity ( ) { </a> 0
<a> super ( FriendPickerFragment . class ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean getAutoCreateUI ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . graphics . BitmapFactory ; </a> 0
<a> import android . test . AndroidTestCase ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import com . facebook . internal . Utility ; </a> 0
<a> import com . facebook . widget . ImageResponseCache ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . net . HttpURLConnection ; </a> 0
<a> import java . net . URL ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> public final class ImageResponseCacheTests extends AndroidTestCase { </a> 0
<a> @ MediumTest @ LargeTest </a> 0
<a> public void testImageCaching ( ) throws IOException { </a> 0
<a> ImageResponseCache . getCache ( safeGetContext ( ) ) . clearForTest ( ) ; </a> 0
<a> String imgUrl = "http://sphotos-b.xx.fbcdn.net/hphotos-snc7/300716_163831917043403_1106723719_n.jpg" ; </a> 0
<a> Bitmap bmp1 = readImage ( imgUrl , false ) ; </a> 0
<a> Bitmap bmp2 = readImage ( imgUrl , true ) ; </a> 0
<a> compareImages ( bmp1 , bmp2 ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest @ LargeTest </a> 0
<a> public void testImageNotCaching ( ) throws IOException { </a> 0
<a> String imgUrl = "http://graph.facebook.com/ryanseacrest/picture?type=large" ; </a> 0
<a> Bitmap bmp1 = readImage ( imgUrl , false ) ; </a> 0
<a> Bitmap bmp2 = readImage ( imgUrl , false ) ; </a> 0
<a> compareImages ( bmp1 , bmp2 ) ; </a> 0
<a> } </a> 0
<a> private Bitmap readImage ( String uri , boolean expectedFromCache ) { </a> 0
<a> Bitmap bmp = null ; </a> 0
<a> InputStream istream = null ; </a> 0
<a> try </a> 0
<a> { </a> 0
<a> URL url = new URL ( uri ) ; </a> 0
<a> boolean isInCache = ( ImageResponseCache . getCache ( safeGetContext ( ) ) . get ( url . toString ( ) ) != null ) ; </a> 0
<a> assertTrue ( isInCache == expectedFromCache ) ; </a> 0
<a> istream = ImageResponseCache . getCachedImageStream ( url , safeGetContext ( ) ) ; </a> 0
<a> if ( istream == null ) { </a> 0
<a> HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; </a> 0
<a> istream = ImageResponseCache . interceptAndCacheImageStream ( safeGetContext ( ) , connection ) ; </a> 0
<a> } </a> 0
<a> assertTrue ( istream != null ) ; </a> 0
<a> bmp = BitmapFactory . decodeStream ( istream ) ; </a> 0
<a> assertTrue ( bmp != null ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> assertNull ( e ) ; </a> 0
<a> } finally { </a> 0
<a> Utility . closeQuietly ( istream ) ; </a> 0
<a> } </a> 0
<a> return bmp ; </a> 0
<a> } </a> 0
<a> private static void compareImages ( Bitmap bmp1 , Bitmap bmp2 ) { </a> 0
<a> assertTrue ( bmp1 . getHeight ( ) == bmp2 . getHeight ( ) ) ; </a> 0
<a> assertTrue ( bmp1 . getWidth ( ) == bmp1 . getWidth ( ) ) ; </a> 0
<a> ByteBuffer buffer1 = ByteBuffer . allocate ( bmp1 . getHeight ( ) * bmp1 . getRowBytes ( ) ) ; </a> 0
<a> bmp1 . copyPixelsToBuffer ( buffer1 ) ; </a> 0
<a> ByteBuffer buffer2 = ByteBuffer . allocate ( bmp2 . getHeight ( ) * bmp2 . getRowBytes ( ) ) ; </a> 0
<a> bmp2 . copyPixelsToBuffer ( buffer2 ) ; </a> 0
<a> assertTrue ( Arrays . equals ( buffer1 . array ( ) , buffer2 . array ( ) ) ) ; </a> 0
<a> } </a> 0
<a> private Context safeGetContext ( ) { </a> 0
<a> for ( ; ; ) { </a> 0
<a> if ( ( getContext ( ) != null ) && ( getContext ( ) . getApplicationContext ( ) != null ) ) { </a> 0
<a> return getContext ( ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 25 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . widget . LoginButton ; </a> 0
<a> import junit . framework . Assert ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> public class LoginButtonTest extends SessionTestsBase { </a> 0
<a> static final int STRAY_CALLBACK_WAIT_MILLISECONDS = 50 ; </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testLoginButton ( ) throws Throwable { </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> final ScriptedSession session = new ScriptedSession ( getActivity ( ) , "SomeId" , cache ) ; </a> 0
<a> SessionTestsBase . SessionStatusCallbackRecorder statusRecorder = new SessionTestsBase . SessionStatusCallbackRecorder ( ) ; </a> 0
<a> session . addAuthorizeResult ( "A token of thanks" , new ArrayList < String > ( ) , AccessTokenSource . TEST_USER ) ; </a> 0
<a> session . addCallback ( statusRecorder ) ; </a> 0
<a> Assert . assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> final SessionStatusCallbackRecorder loginButtonStatusRecorder = new SessionStatusCallbackRecorder ( ) ; </a> 0
<a> final LoginButton button = new LoginButton ( getActivity ( ) ) ; </a> 0
<a> runAndBlockOnUiThread ( 0 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> getActivity ( ) . setContentView ( button ) ; </a> 0
<a> button . setSession ( session ) ; </a> 0
<a> button . setSessionStatusCallback ( loginButtonStatusRecorder ) ; </a> 0
<a> button . performClick ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> loginButtonStatusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> loginButtonStatusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) == null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> loginButtonStatusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testLoginFail ( ) { </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> ScriptedSession session = new ScriptedSession ( getActivity ( ) , "SomeId" , cache ) ; </a> 0
<a> final Exception openException = new Exception ( "Open failed!" ) ; </a> 0
<a> final AtomicBoolean clicked = new AtomicBoolean ( false ) ; </a> 0
<a> assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> final LoginButton button = new LoginButton ( getActivity ( ) ) ; </a> 0
<a> LoginButton . OnErrorListener listener = new LoginButton . OnErrorListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onError ( FacebookException exception ) { </a> 0
<a> synchronized ( this ) { </a> 0
<a> assertEquals ( exception . getCause ( ) . getMessage ( ) , openException . getMessage ( ) ) ; </a> 0
<a> clicked . set ( true ) ; </a> 0
<a> this . notifyAll ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> button . setOnErrorListener ( listener ) ; </a> 0
<a> button . setSession ( session ) ; </a> 0
<a> session . addAuthorizeResult ( openException ) ; </a> 0
<a> button . onAttachedToWindow ( ) ; </a> 0
<a> button . performClick ( ) ; </a> 0
<a> try { </a> 0
<a> synchronized ( listener ) { </a> 0
<a> listener . wait ( DEFAULT_TIMEOUT_MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> fail ( "Interrupted during open" ) ; </a> 0
<a> } </a> 0
<a> if ( ! clicked . get ( ) ) { </a> 0
<a> fail ( "Did not get exception" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanAddReadPermissions ( ) { </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> ScriptedSession session = new ScriptedSession ( getActivity ( ) , "SomeId" , cache ) ; </a> 0
<a> SessionTestsBase . SessionStatusCallbackRecorder statusRecorder = new SessionTestsBase . SessionStatusCallbackRecorder ( ) ; </a> 0
<a> assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> final LoginButton button = new LoginButton ( getActivity ( ) ) ; </a> 0
<a> button . setSession ( session ) ; </a> 0
<a> button . setReadPermissions ( Arrays . asList ( new String [ ] { "read_permission" , "read_another" } ) ) ; </a> 0
<a> session . addAuthorizeResult ( "A token of thanks" , new ArrayList < String > ( ) , AccessTokenSource . TEST_USER ) ; </a> 0
<a> session . addCallback ( statusRecorder ) ; </a> 0
<a> button . performClick ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) == null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanAddPublishPermissions ( ) { </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> ScriptedSession session = new ScriptedSession ( getActivity ( ) , "SomeId" , cache ) ; </a> 0
<a> SessionTestsBase . SessionStatusCallbackRecorder statusRecorder = </a> 0
<a> new SessionTestsBase . SessionStatusCallbackRecorder ( ) ; </a> 0
<a> assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> final LoginButton button = new LoginButton ( getActivity ( ) ) ; </a> 0
<a> button . setSession ( session ) ; </a> 0
<a> button . setPublishPermissions ( Arrays . asList ( new String [ ] { "publish_permission" , "publish_another" } ) ) ; </a> 0
<a> session . addAuthorizeResult ( "A token of thanks" , new ArrayList < String > ( ) , AccessTokenSource . TEST_USER ) ; </a> 0
<a> session . addCallback ( statusRecorder ) ; </a> 0
<a> button . performClick ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) == null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantAddReadThenPublishPermissions ( ) { </a> 0
<a> final LoginButton button = new LoginButton ( getActivity ( ) ) ; </a> 0
<a> button . setReadPermissions ( Arrays . asList ( new String [ ] { "read_permission" , "read_another" } ) ) ; </a> 0
<a> try { </a> 0
<a> button . setPublishPermissions ( Arrays . asList ( new String [ ] { "read_permission" , "read_a_third" } ) ) ; </a> 0
<a> fail ( "Should not be able to reach here" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> assertTrue ( e instanceof UnsupportedOperationException ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantAddPublishThenReadPermissions ( ) { </a> 0
<a> final LoginButton button = new LoginButton ( getActivity ( ) ) ; </a> 0
<a> button . setPublishPermissions ( Arrays . asList ( new String [ ] { "publish_permission" , "publish_another" } ) ) ; </a> 0
<a> try { </a> 0
<a> button . setReadPermissions ( Arrays . asList ( new String [ ] { "publish_permission" , "publish_a_third" } ) ) ; </a> 0
<a> fail ( "Should not be able to reach here" ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> assertTrue ( e instanceof UnsupportedOperationException ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanAddReadThenPublishPermissionsWithClear ( ) { </a> 0
<a> final LoginButton button = new LoginButton ( getActivity ( ) ) ; </a> 0
<a> button . setReadPermissions ( Arrays . asList ( new String [ ] { "read_permission" , "read_another" } ) ) ; </a> 0
<a> button . clearPermissions ( ) ; </a> 0
<a> button . setPublishPermissions ( Arrays . asList ( new String [ ] { "publish_permission" , "publish_another" } ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCantAddMorePermissionsToOpenSession ( ) { </a> 0
<a> MockTokenCachingStrategy cache = new MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> ScriptedSession session = new ScriptedSession ( getActivity ( ) , "SomeId" , cache ) ; </a> 0
<a> SessionTestsBase . SessionStatusCallbackRecorder statusRecorder = </a> 0
<a> new SessionTestsBase . SessionStatusCallbackRecorder ( ) ; </a> 0
<a> assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> final LoginButton button = new LoginButton ( getActivity ( ) ) ; </a> 0
<a> button . setSession ( session ) ; </a> 0
<a> session . addAuthorizeResult ( "A token of thanks" , </a> 0
<a> Arrays . asList ( new String [ ] { "read_permission" , "read_another" } ) , AccessTokenSource . TEST_USER ) ; </a> 0
<a> session . addCallback ( statusRecorder ) ; </a> 0
<a> button . performClick ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> button . setReadPermissions ( Arrays . asList ( new String [ ] { "read_permission" , "read_another" } ) ) ; </a> 0
<a> button . setReadPermissions ( Arrays . asList ( new String [ ] { "read_permission" , "read_a_third" } ) ) ; </a> 0
<a> List < String > permissions = button . getPermissions ( ) ; </a> 0
<a> assertTrue ( permissions . contains ( "read_permission" ) ) ; </a> 0
<a> assertTrue ( permissions . contains ( "read_another" ) ) ; </a> 0
<a> assertFalse ( permissions . contains ( "read_a_third" ) ) ; </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) == null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanSetDefaultAudience ( ) { </a> 0
<a> SessionTestsBase . MockTokenCachingStrategy cache = new SessionTestsBase . MockTokenCachingStrategy ( null , 0 ) ; </a> 0
<a> ScriptedSession session = new ScriptedSession ( getActivity ( ) , "SomeId" , cache ) ; </a> 0
<a> SessionTestsBase . SessionStatusCallbackRecorder statusRecorder = </a> 0
<a> new SessionTestsBase . SessionStatusCallbackRecorder ( ) ; </a> 0
<a> assertEquals ( SessionState . CREATED , session . getState ( ) ) ; </a> 0
<a> final LoginButton button = new LoginButton ( getActivity ( ) ) ; </a> 0
<a> button . setSession ( session ) ; </a> 0
<a> button . setPublishPermissions ( Arrays . asList ( new String [ ] { "publish_permission" , "publish_another" } ) ) ; </a> 0
<a> button . setDefaultAudience ( SessionDefaultAudience . FRIENDS ) ; </a> 0
<a> session . addAuthorizeResult ( "A token of thanks" , new ArrayList < String > ( ) , AccessTokenSource . TEST_USER ) ; </a> 0
<a> session . addCallback ( statusRecorder ) ; </a> 0
<a> button . performClick ( ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENING , null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . OPENED , null ) ; </a> 0
<a> assertNotNull ( session . getLastRequest ( ) ) ; </a> 0
<a> assertEquals ( SessionDefaultAudience . FRIENDS , session . getLastRequestAudience ( ) ) ; </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> assertTrue ( cache . getSavedState ( ) == null ) ; </a> 0
<a> statusRecorder . waitForCall ( session , SessionState . CLOSED , null ) ; </a> 0
<a> stall ( STRAY_CALLBACK_WAIT_MILLISECONDS ) ; </a> 0
<a> statusRecorder . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . location . Location ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . test . TouchUtils ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . widget . ListView ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . sdk . tests . R ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> public class PlacePickerFragmentTests extends FragmentTestCase < PlacePickerFragmentTests . TestActivity > { </a> 0
<a> public PlacePickerFragmentTests ( ) { </a> 0
<a> super ( TestActivity . class ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanSetParametersProgrammatically ( ) throws Throwable { </a> 0
<a> TestActivity activity = getActivity ( ) ; </a> 0
<a> assertNotNull ( activity ) ; </a> 0
<a> final Location location = new Location ( "" ) ; </a> 0
<a> location . setLatitude ( 47.6204 ) ; </a> 0
<a> location . setLongitude ( - 122.3491 ) ; </a> 0
<a> runAndBlockOnUiThread ( 0 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> Bundle bundle = new Bundle ( ) ; </a> 0
<a> bundle . putBoolean ( PlacePickerFragment . SHOW_PICTURES_BUNDLE_KEY , false ) ; </a> 0
<a> bundle . putInt ( PlacePickerFragment . RADIUS_IN_METERS_BUNDLE_KEY , 75 ) ; </a> 0
<a> bundle . putInt ( PlacePickerFragment . RESULTS_LIMIT_BUNDLE_KEY , 5 ) ; </a> 0
<a> bundle . putString ( PlacePickerFragment . SEARCH_TEXT_BUNDLE_KEY , "coffee" ) ; </a> 0
<a> bundle . putParcelable ( PlacePickerFragment . LOCATION_BUNDLE_KEY , location ) ; </a> 0
<a> bundle . putString ( FriendPickerFragment . EXTRA_FIELDS_BUNDLE_KEY , "checkins,general_info" ) ; </a> 0
<a> PlacePickerFragment fragment = new PlacePickerFragment ( bundle ) ; </a> 0
<a> getActivity ( ) . setContentToFragment ( fragment ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> final PlacePickerFragment fragment = activity . getFragment ( ) ; </a> 0
<a> assertNotNull ( fragment ) ; </a> 0
<a> assertEquals ( false , fragment . getShowPictures ( ) ) ; </a> 0
<a> assertEquals ( 75 , fragment . getRadiusInMeters ( ) ) ; </a> 0
<a> assertEquals ( 5 , fragment . getResultsLimit ( ) ) ; </a> 0
<a> assertEquals ( "coffee" , fragment . getSearchText ( ) ) ; </a> 0
<a> assertEquals ( location , fragment . getLocation ( ) ) ; </a> 0
<a> Collection < String > extraFields = fragment . getExtraFields ( ) ; </a> 0
<a> assertTrue ( extraFields . contains ( "checkins" ) ) ; </a> 0
<a> assertTrue ( extraFields . contains ( "general_info" ) ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanSetParametersViaLayout ( ) throws Throwable { </a> 0
<a> TestActivity activity = getActivity ( ) ; </a> 0
<a> assertNotNull ( activity ) ; </a> 0
<a> runAndBlockOnUiThread ( 0 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> getActivity ( ) . setContentToLayout ( R . layout . place_picker_test_layout_1 , R . id . place_picker_fragment ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> final PlacePickerFragment fragment = activity . getFragment ( ) ; </a> 0
<a> assertNotNull ( fragment ) ; </a> 0
<a> assertEquals ( false , fragment . getShowPictures ( ) ) ; </a> 0
<a> assertEquals ( 75 , fragment . getRadiusInMeters ( ) ) ; </a> 0
<a> assertEquals ( 5 , fragment . getResultsLimit ( ) ) ; </a> 0
<a> assertEquals ( "coffee" , fragment . getSearchText ( ) ) ; </a> 0
<a> Collection < String > extraFields = fragment . getExtraFields ( ) ; </a> 0
<a> assertTrue ( extraFields . contains ( "checkins" ) ) ; </a> 0
<a> assertTrue ( extraFields . contains ( "general_info" ) ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testPlacesLoad ( ) throws Throwable { </a> 0
<a> TestActivity activity = getActivity ( ) ; </a> 0
<a> assertNotNull ( activity ) ; </a> 0
<a> runAndBlockOnUiThread ( 0 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> getActivity ( ) . setContentToFragment ( null ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> getInstrumentation ( ) . waitForIdleSync ( ) ; </a> 0
<a> final PlacePickerFragment fragment = activity . getFragment ( ) ; </a> 0
<a> assertNotNull ( fragment ) ; </a> 0
<a> final TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> final TestBlocker blocker = getTestBlocker ( ) ; </a> 0
<a> runAndBlockOnUiThread ( 1 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> fragment . setSession ( session ) ; </a> 0
<a> Location location = new Location ( "" ) ; </a> 0
<a> location . setLatitude ( 47.6204 ) ; </a> 0
<a> location . setLongitude ( - 122.3491 ) ; </a> 0
<a> fragment . setLocation ( location ) ; </a> 0
<a> fragment . setOnDataChangedListener ( new PickerFragment . OnDataChangedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onDataChanged ( PickerFragment < ? > fragment ) { </a> 0
<a> blocker . signal ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> fragment . setOnErrorListener ( new PickerFragment . OnErrorListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onError ( PickerFragment < ? > fragment , FacebookException error ) { </a> 0
<a> fail ( "Got unexpected error: " + error . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> fragment . loadData ( true ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> ListView listView = ( ListView ) fragment . getView ( ) . findViewById ( R . id . com_facebook_picker_list_view ) ; </a> 0
<a> assertNotNull ( listView ) ; </a> 0
<a> View firstChild = listView . getChildAt ( 0 ) ; </a> 0
<a> assertNotNull ( firstChild ) ; </a> 0
<a> assertNull ( fragment . getSelection ( ) ) ; </a> 0
<a> TouchUtils . clickView ( this , firstChild ) ; </a> 0
<a> assertNotNull ( fragment . getSelection ( ) ) ; </a> 0
<a> TouchUtils . clickView ( this , firstChild ) ; </a> 0
<a> assertNull ( fragment . getSelection ( ) ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testClearsResultsWhenSessionClosed ( ) throws Throwable { </a> 0
<a> TestActivity activity = getActivity ( ) ; </a> 0
<a> assertNotNull ( activity ) ; </a> 0
<a> runAndBlockOnUiThread ( 0 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> getActivity ( ) . setContentToFragment ( null ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> getInstrumentation ( ) . waitForIdleSync ( ) ; </a> 0
<a> final PlacePickerFragment fragment = activity . getFragment ( ) ; </a> 0
<a> assertNotNull ( fragment ) ; </a> 0
<a> final TestSession session = openTestSessionWithSharedUser ( ) ; </a> 0
<a> final TestBlocker blocker1 = TestBlocker . createTestBlocker ( ) ; </a> 0
<a> runAndBlockOnUiThread ( 0 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> fragment . setSession ( session ) ; </a> 0
<a> Location location = new Location ( "" ) ; </a> 0
<a> location . setLatitude ( 47.6204 ) ; </a> 0
<a> location . setLongitude ( - 122.3491 ) ; </a> 0
<a> fragment . setLocation ( location ) ; </a> 0
<a> fragment . setOnDataChangedListener ( new PickerFragment . OnDataChangedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onDataChanged ( PickerFragment < ? > fragment ) { </a> 0
<a> blocker1 . signal ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> fragment . setOnErrorListener ( new PickerFragment . OnErrorListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onError ( PickerFragment < ? > fragment , FacebookException error ) { </a> 0
<a> fail ( "Got unexpected error: " + error . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> fragment . loadData ( true ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> blocker1 . waitForSignals ( 1 ) ; </a> 0
<a> ListView listView = ( ListView ) fragment . getView ( ) . findViewById ( R . id . com_facebook_picker_list_view ) ; </a> 0
<a> assertNotNull ( listView ) ; </a> 0
<a> Thread . sleep ( 500 ) ; </a> 0
<a> int lastPosition = listView . getLastVisiblePosition ( ) ; </a> 0
<a> assertTrue ( lastPosition > - 1 ) ; </a> 0
<a> View firstChild = listView . getChildAt ( 0 ) ; </a> 0
<a> assertNotNull ( firstChild ) ; </a> 0
<a> assertNull ( fragment . getSelection ( ) ) ; </a> 0
<a> TouchUtils . clickView ( this , firstChild ) ; </a> 0
<a> assertNotNull ( fragment . getSelection ( ) ) ; </a> 0
<a> final TestBlocker blocker2 = TestBlocker . createTestBlocker ( ) ; </a> 0
<a> runAndBlockOnUiThread ( 0 , new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> session . addCallback ( new Session . StatusCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> blocker2 . signal ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> session . close ( ) ; </a> 0
<a> blocker2 . waitForSignals ( 1 ) ; </a> 0
<a> getInstrumentation ( ) . waitForIdleSync ( ) ; </a> 0
<a> Thread . sleep ( 500 ) ; </a> 0
<a> lastPosition = listView . getLastVisiblePosition ( ) ; </a> 0
<a> assertTrue ( lastPosition == - 1 ) ; </a> 0
<a> assertNull ( fragment . getSelection ( ) ) ; </a> 0
<a> } </a> 0
<a> public static class TestActivity extends FragmentTestCase . TestFragmentActivity < PlacePickerFragment > { </a> 0
<a> public TestActivity ( ) { </a> 0
<a> super ( PlacePickerFragment . class ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean getAutoCreateUI ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import com . facebook . SessionDefaultAudience ; </a> 0
<a> import com . facebook . SessionLoginBehavior ; </a> 0
<a> import java . util . Arrays ; </a> 1
<a> import java . util . List ; </a> 0
<a> public class UserSettingsFragmentTests extends FragmentTestCase < UserSettingsFragmentTests . TestActivity > { </a> 0
<a> public UserSettingsFragmentTests ( ) { </a> 0
<a> super ( TestActivity . class ) ; </a> 0
<a> } </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testCanSetParametersViaLayout ( ) throws Throwable { </a> 0
<a> TestActivity activity = getActivity ( ) ; </a> 0
<a> assertNotNull ( activity ) ; </a> 0
<a> final UserSettingsFragment fragment = activity . getFragment ( ) ; </a> 0
<a> assertNotNull ( fragment ) ; </a> 0
<a> assertEquals ( SessionLoginBehavior . SUPPRESS_SSO , fragment . getLoginBehavior ( ) ) ; </a> 0
<a> assertEquals ( SessionDefaultAudience . EVERYONE , fragment . getDefaultAudience ( ) ) ; </a> 0
<a> List < String > permissions = fragment . getPermissions ( ) ; </a> 0
<a> assertEquals ( 2 , permissions . size ( ) ) ; </a> 0
<a> assertEquals ( "read_1" , permissions . get ( 0 ) ) ; </a> 0
<a> } </a> 0
<a> public static class TestActivity extends FragmentTestCase . TestFragmentActivity < UserSettingsFragment > { </a> 0
<a> public TestActivity ( ) { </a> 0
<a> super ( UserSettingsFragment . class ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> getSupportFragmentManager ( ) . executePendingTransactions ( ) ; </a> 0
<a> UserSettingsFragment fragment = getFragment ( ) ; </a> 0
<a> fragment . setLoginBehavior ( SessionLoginBehavior . SUPPRESS_SSO ) ; </a> 0
<a> fragment . setReadPermissions ( Arrays . asList ( "read_1" , "read_2" ) ) ; </a> 0
<a> fragment . setDefaultAudience ( SessionDefaultAudience . EVERYONE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . widget ; </a> 0
<a> import android . test . suitebuilder . annotation . LargeTest ; </a> 0
<a> import android . test . suitebuilder . annotation . MediumTest ; </a> 0
<a> import android . test . suitebuilder . annotation . SmallTest ; </a> 0
<a> import com . facebook . FacebookTestCase ; </a> 0
<a> import com . facebook . widget . WorkQueue ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . concurrent . Executor ; </a> 0
<a> import java . security . SecureRandom ; </a> 0
<a> public class WorkQueueTests extends FacebookTestCase { </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testEmptyValidate ( ) { </a> 0
<a> WorkQueue manager = new WorkQueue ( ) ; </a> 0
<a> manager . validate ( ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testRunSomething ( ) { </a> 0
<a> CountingRunnable run = new CountingRunnable ( ) ; </a> 0
<a> assertEquals ( 0 , run . getRunCount ( ) ) ; </a> 0
<a> ScriptableExecutor executor = new ScriptableExecutor ( ) ; </a> 0
<a> assertEquals ( 0 , executor . getPendingCount ( ) ) ; </a> 0
<a> WorkQueue manager = new WorkQueue ( 1 , executor ) ; </a> 0
<a> addActiveWorkItem ( manager , run ) ; </a> 0
<a> assertEquals ( 1 , executor . getPendingCount ( ) ) ; </a> 0
<a> assertEquals ( 0 , run . getRunCount ( ) ) ; </a> 0
<a> executeNext ( manager , executor ) ; </a> 0
<a> assertEquals ( 0 , executor . getPendingCount ( ) ) ; </a> 0
<a> assertEquals ( 1 , run . getRunCount ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testRunSequence ( ) { </a> 0
<a> final int workTotal = 100 ; </a> 0
<a> CountingRunnable run = new CountingRunnable ( ) ; </a> 0
<a> ScriptableExecutor executor = new ScriptableExecutor ( ) ; </a> 0
<a> WorkQueue manager = new WorkQueue ( 1 , executor ) ; </a> 0
<a> for ( int i = 0 ; i < workTotal ; i ++ ) { </a> 0
<a> addActiveWorkItem ( manager , run ) ; </a> 0
<a> assertEquals ( 1 , executor . getPendingCount ( ) ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < workTotal ; i ++ ) { </a> 0
<a> assertEquals ( 1 , executor . getPendingCount ( ) ) ; </a> 0
<a> assertEquals ( i , run . getRunCount ( ) ) ; </a> 0
<a> executeNext ( manager , executor ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , executor . getPendingCount ( ) ) ; </a> 0
<a> assertEquals ( workTotal , run . getRunCount ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testRunParallel ( ) { </a> 0
<a> final int workTotal = 100 ; </a> 0
<a> CountingRunnable run = new CountingRunnable ( ) ; </a> 0
<a> ScriptableExecutor executor = new ScriptableExecutor ( ) ; </a> 0
<a> WorkQueue manager = new WorkQueue ( workTotal , executor ) ; </a> 0
<a> for ( int i = 0 ; i < workTotal ; i ++ ) { </a> 0
<a> assertEquals ( i , executor . getPendingCount ( ) ) ; </a> 0
<a> addActiveWorkItem ( manager , run ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < workTotal ; i ++ ) { </a> 0
<a> assertEquals ( workTotal - i , executor . getPendingCount ( ) ) ; </a> 0
<a> assertEquals ( i , run . getRunCount ( ) ) ; </a> 0
<a> executeNext ( manager , executor ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 0 , executor . getPendingCount ( ) ) ; </a> 0
<a> assertEquals ( workTotal , run . getRunCount ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testSimpleCancel ( ) { </a> 0
<a> CountingRunnable run = new CountingRunnable ( ) ; </a> 0
<a> ScriptableExecutor executor = new ScriptableExecutor ( ) ; </a> 0
<a> WorkQueue manager = new WorkQueue ( 1 , executor ) ; </a> 0
<a> addActiveWorkItem ( manager , run ) ; </a> 0
<a> WorkQueue . WorkItem work1 = addActiveWorkItem ( manager , run ) ; </a> 0
<a> cancelWork ( manager , work1 ) ; </a> 0
<a> assertEquals ( 1 , executor . getPendingCount ( ) ) ; </a> 0
<a> executeNext ( manager , executor ) ; </a> 0
<a> assertEquals ( 0 , executor . getPendingCount ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SmallTest </a> 0
<a> @ MediumTest </a> 0
<a> @ LargeTest </a> 0
<a> public void testMoveToFront ( ) { </a> 0
<a> final int firstCount = 8 ; </a> 0
<a> final int highCount = 17 ; </a> 0
<a> ArrayList < WorkQueue . WorkItem > highWorkItems = new ArrayList < WorkQueue . WorkItem > ( ) ; </a> 0
<a> CountingRunnable highRun = new CountingRunnable ( ) ; </a> 0
<a> CountingRunnable firstRun = new CountingRunnable ( ) ; </a> 0
<a> CountingRunnable lowRun = new CountingRunnable ( ) ; </a> 0
<a> ScriptableExecutor executor = new ScriptableExecutor ( ) ; </a> 0
<a> WorkQueue manager = new WorkQueue ( firstCount , executor ) ; </a> 0
<a> for ( int i = 0 ; i < firstCount ; i ++ ) { </a> 0
<a> addActiveWorkItem ( manager , firstRun ) ; </a> 0
<a> } </a> 0
<a> int lowCount = 0 ; </a> 0
<a> for ( int h = 0 ; h < highCount ; h ++ ) { </a> 0
<a> highWorkItems . add ( addActiveWorkItem ( manager , highRun ) ) ; </a> 0
<a> for ( int l = 0 ; l < h ; l ++ ) { </a> 0
<a> addActiveWorkItem ( manager , lowRun ) ; </a> 0
<a> lowCount ++ ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> assertEquals ( firstCount , executor . getPendingCount ( ) ) ; </a> 0
<a> for ( WorkQueue . WorkItem highItem : highWorkItems ) { </a> 0
<a> prioritizeWork ( manager , highItem ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < firstCount ; i ++ ) { </a> 0
<a> assertEquals ( i , firstRun . getRunCount ( ) ) ; </a> 0
<a> executeNext ( manager , executor ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < highCount ; i ++ ) { </a> 0
<a> assertEquals ( i , highRun . getRunCount ( ) ) ; </a> 0
<a> executeNext ( manager , executor ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < lowCount ; i ++ ) { </a> 0
<a> assertEquals ( i , lowRun . getRunCount ( ) ) ; </a> 0
<a> executeNext ( manager , executor ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( firstCount , firstRun . getRunCount ( ) ) ; </a> 0
<a> assertEquals ( highCount , highRun . getRunCount ( ) ) ; </a> 0
<a> assertEquals ( lowCount , lowRun . getRunCount ( ) ) ; </a> 0
<a> } </a> 0
<a> @ LargeTest </a> 0
<a> public void testThreadStress ( ) { </a> 0
<a> WorkQueue manager = new WorkQueue ( ) ; </a> 0
<a> ArrayList < StressRunnable > runnables = new ArrayList < StressRunnable > ( ) ; </a> 0
<a> final int threadCount = 20 ; </a> 0
<a> for ( int i = 0 ; i < threadCount ; i ++ ) { </a> 0
<a> runnables . add ( new StressRunnable ( manager , 20 ) ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < threadCount ; i ++ ) { </a> 0
<a> manager . addActiveWorkItem ( runnables . get ( i ) ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < threadCount ; i ++ ) { </a> 0
<a> runnables . get ( i ) . waitForDone ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private WorkQueue . WorkItem addActiveWorkItem ( WorkQueue manager , Runnable runnable ) { </a> 0
<a> manager . validate ( ) ; </a> 0
<a> WorkQueue . WorkItem workItem = manager . addActiveWorkItem ( runnable ) ; </a> 0
<a> manager . validate ( ) ; </a> 0
<a> return workItem ; </a> 0
<a> } </a> 0
<a> private void executeNext ( WorkQueue manager , ScriptableExecutor executor ) { </a> 0
<a> manager . validate ( ) ; </a> 0
<a> executor . runNext ( ) ; </a> 0
<a> manager . validate ( ) ; </a> 0
<a> } </a> 0
<a> private void cancelWork ( WorkQueue manager , WorkQueue . WorkItem workItem ) { </a> 0
<a> manager . validate ( ) ; </a> 0
<a> workItem . cancel ( ) ; </a> 0
<a> manager . validate ( ) ; </a> 0
<a> } </a> 0
<a> private void prioritizeWork ( WorkQueue manager , WorkQueue . WorkItem workItem ) { </a> 0
<a> manager . validate ( ) ; </a> 0
<a> workItem . moveToFront ( ) ; </a> 0
<a> manager . validate ( ) ; </a> 0
<a> } </a> 0
<a> static class StressRunnable implements Runnable { </a> 0
<a> static ArrayList < WorkQueue . WorkItem > tracked = new ArrayList < WorkQueue . WorkItem > ( ) ; </a> 0
<a> final WorkQueue manager ; </a> 0
<a> final SecureRandom random = new SecureRandom ( ) ; </a> 0
<a> final int iterationCount ; </a> 0
<a> int iterationIndex = 0 ; </a> 0
<a> boolean isDone = false ; </a> 0
<a> StressRunnable ( WorkQueue manager , int iterationCount ) { </a> 0
<a> this . manager = manager ; </a> 0
<a> this . iterationCount = iterationCount ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> if ( iterationIndex ++ < iterationCount ) { </a> 0
<a> final int sleepWeight = 80 ; </a> 0
<a> final int trackThisWeight = 10 ; </a> 0
<a> final int prioritizeTrackedWeight = 6 ; </a> 0
<a> final int validateWeight = 2 ; </a> 0
<a> int weight = 0 ; </a> 0
<a> final int n = random . nextInt ( sleepWeight + trackThisWeight + prioritizeTrackedWeight + validateWeight ) ; </a> 0
<a> WorkQueue . WorkItem workItem = manager . addActiveWorkItem ( this ) ; </a> 0
<a> if ( n < ( weight += sleepWeight ) ) { </a> 0
<a> try { </a> 0
<a> Thread . sleep ( n / 4 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } else if ( n < ( weight += trackThisWeight ) ) { </a> 0
<a> synchronized ( tracked ) { </a> 0
<a> tracked . add ( workItem ) ; </a> 0
<a> } </a> 0
<a> } else if ( n < ( weight += prioritizeTrackedWeight ) ) { </a> 0
<a> ArrayList < WorkQueue . WorkItem > items = new ArrayList < WorkQueue . WorkItem > ( ) ; </a> 0
<a> synchronized ( tracked ) { </a> 0
<a> items . addAll ( tracked ) ; </a> 0
<a> tracked . clear ( ) ; </a> 0
<a> } </a> 0
<a> for ( WorkQueue . WorkItem item : items ) { </a> 0
<a> item . moveToFront ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> manager . validate ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> manager . validate ( ) ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> isDone = true ; </a> 0
<a> this . notifyAll ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void waitForDone ( ) { </a> 0
<a> synchronized ( this ) { </a> 0
<a> while ( ! isDone ) { </a> 0
<a> try { </a> 0
<a> this . wait ( ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> class ScriptableExecutor implements Executor { </a> 0
<a> private final ArrayList < Runnable > runnables = new ArrayList < Runnable > ( ) ; </a> 0
<a> int getPendingCount ( ) { </a> 0
<a> return runnables . size ( ) ; </a> 0
<a> } </a> 0
<a> void runNext ( ) { </a> 0
<a> assertTrue ( runnables . size ( ) > 0 ) ; </a> 0
<a> runnables . get ( 0 ) . run ( ) ; </a> 0
<a> runnables . remove ( 0 ) ; </a> 0
<a> } </a> 0
<a> void runLast ( ) { </a> 0
<a> assertTrue ( runnables . size ( ) > 0 ) ; </a> 0
<a> int index = runnables . size ( ) - 1 ; </a> 0
<a> runnables . get ( index ) . run ( ) ; </a> 0
<a> runnables . remove ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void execute ( Runnable runnable ) { </a> 0
<a> synchronized ( this ) { </a> 0
<a> runnables . add ( runnable ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> class CountingRunnable implements Runnable { </a> 0
<a> volatile int runCount = 0 ; </a> 0
<a> int getRunCount ( ) { </a> 0
<a> return runCount ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> synchronized ( this ) { </a> 0
<a> runCount ++ ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . booleanog ; </a> 0
<a> import android . app . AlertDialog ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . database . MatrixCursor ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Parcel ; </a> 0
<a> import android . os . Parcelable ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> import android . support . v4 . app . FragmentManager ; </a> 0
<a> import android . support . v4 . app . FragmentTransaction ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . widget . * ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . model . * ; </a> 0
<a> import com . facebook . widget . FriendPickerFragment ; </a> 0
<a> import com . facebook . widget . UserSettingsFragment ; </a> 0
<a> import com . facebook . widget . PickerFragment ; </a> 0
<a> import java . text . SimpleDateFormat ; </a> 0
<a> import java . util . * ; </a> 0
<a> public class LogicActivity extends FragmentActivity { </a> 0
<a> private static final String TAG = "BooleanOpenGraphSample" ; </a> 0
<a> private static final String SAVE_ACTIVE_TAB = TAG + ".SAVE_ACTIVE_TAB" ; </a> 0
<a> private static final String SAVE_CONTENT_SELECTION = TAG + ".SAVE_CONTENT_SELECTION" ; </a> 0
<a> private static final String SAVE_LEFT_OPERAND_SELECTION = TAG + ".SAVE_LEFT_OPERAND_SELECTION" ; </a> 0
<a> private static final String SAVE_RIGHT_OPERAND_SELECTION = TAG + ".SAVE_RIGHT_OPERAND_SELECTION" ; </a> 0
<a> private static final String SAVE_RESULT_TEXT = TAG + ".SAVE_RESULT_TEXT" ; </a> 0
<a> private static final String SAVE_POST_RESULT_TEXT = TAG + ".SAVE_POST_RESULT_TEXT" ; </a> 0
<a> private static final String SAVE_PENDING = TAG + ".SAVE_PENDING" ; </a> 0
<a> private static final String SAVE_FRIEND_ACTIONS = TAG + ".SAVE_FRIEND_ACTIONS" ; </a> 0
<a> private static final String PENDING_POST_PATH = "PENDING_POST_PATH" ; </a> 0
<a> private static final String PENDING_POST_LEFT = "PENDING_POST_LEFT" ; </a> 0
<a> private static final String PENDING_POST_RIGHT = "PENDING_POST_RIGHT" ; </a> 0
<a> private static final String PENDING_POST_RESULT = "PENDING_POST_RESULT" ; </a> 0
<a> private static final String AND_ACTION = "fb_sample_boolean_og:and" ; </a> 0
<a> private static final String OR_ACTION = "fb_sample_boolean_og:or" ; </a> 0
<a> private static final String POST_AND_ACTION_PATH = "me/" + AND_ACTION ; </a> 0
<a> private static final String POST_OR_ACTION_PATH = "me/" + OR_ACTION ; </a> 0
<a> private static final String TRUE_GRAPH_OBJECT_URL = "http://samples.ogp.me/369360019783304" ; </a> 0
<a> private static final String FALSE_GRAPH_OBJECT_URL = "http://samples.ogp.me/369360256449947" ; </a> 0
<a> private static final String INSTALLED = "installed" ; </a> 0
<a> private static final List < String > PERMISSIONS = Arrays . asList ( "publish_actions" ) ; </a> 0
<a> private static volatile TruthValueGraphObject TRUE_GRAPH_OBJECT ; </a> 0
<a> private static volatile TruthValueGraphObject FALSE_GRAPH_OBJECT ; </a> 0
<a> private static volatile int TRUE_SPINNER_INDEX = - 1 ; </a> 0
<a> private static volatile int FALSE_SPINNER_INDEX = - 1 ; </a> 0
<a> private Button logicButton ; </a> 0
<a> private Button friendsButton ; </a> 0
<a> private Button settingsButton ; </a> 0
<a> private Button contentButton ; </a> 0
<a> private String activeTab ; </a> 0
<a> private ViewGroup logicGroup ; </a> 0
<a> private Spinner leftSpinner ; </a> 0
<a> private Spinner rightSpinner ; </a> 0
<a> private Button andButton ; </a> 0
<a> private Button orButton ; </a> 0
<a> private TextView resultText ; </a> 0
<a> private TextView postResultText ; </a> 0
<a> private Bundle pendingPost ; </a> 0
<a> private ViewGroup friendsGroup ; </a> 0
<a> private FriendPickerFragment friendPickerFragment ; </a> 0
<a> private RequestAsyncTask pendingRequest ; </a> 0
<a> private SimpleCursorAdapter friendActivityAdapter ; </a> 0
<a> private ProgressBar friendActivityProgressBar ; </a> 0
<a> private ArrayList < ActionRow > friendActionList ; </a> 0
<a> private ViewGroup settingsGroup ; </a> 0
<a> private UserSettingsFragment userSettingsFragment ; </a> 0
<a> private ViewGroup contentGroup ; </a> 0
<a> private ImageView contentImage ; </a> 0
<a> private Spinner contentSpinner ; </a> 0
<a> private UiLifecycleHelper uiHelper ; </a> 0
<a> private Session . StatusCallback callback = new Session . StatusCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> if ( exception != null ) { </a> 0
<a> pendingPost = null ; </a> 0
<a> } else if ( state == SessionState . OPENED ) { </a> 0
<a> friendPickerFragment . loadData ( false ) ; </a> 0
<a> } else if ( state == SessionState . OPENED_TOKEN_UPDATED ) { </a> 0
<a> sendPendingPost ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> uiHelper = new UiLifecycleHelper ( this , callback ) ; </a> 0
<a> uiHelper . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . main ) ; </a> 0
<a> logicButton = ( Button ) findViewById ( R . id . logic_button ) ; </a> 0
<a> friendsButton = ( Button ) findViewById ( R . id . friends_button ) ; </a> 0
<a> settingsButton = ( Button ) findViewById ( R . id . settings_button ) ; </a> 0
<a> contentButton = ( Button ) findViewById ( R . id . content_button ) ; </a> 0
<a> logicGroup = ( ViewGroup ) findViewById ( R . id . logic_group ) ; </a> 0
<a> leftSpinner = ( Spinner ) findViewById ( R . id . left_spinner ) ; </a> 0
<a> rightSpinner = ( Spinner ) findViewById ( R . id . right_spinner ) ; </a> 0
<a> andButton = ( Button ) findViewById ( R . id . and_button ) ; </a> 0
<a> orButton = ( Button ) findViewById ( R . id . or_button ) ; </a> 0
<a> resultText = ( TextView ) findViewById ( R . id . result_text ) ; </a> 0
<a> postResultText = ( TextView ) findViewById ( R . id . post_result_text ) ; </a> 0
<a> friendsGroup = ( ViewGroup ) findViewById ( R . id . friends_group ) ; </a> 0
<a> ListView friendActivityList = ( ListView ) findViewById ( R . id . friend_activity_list ) ; </a> 0
<a> String [ ] mapColumnNames = { "date" , "action" } ; </a> 0
<a> int [ ] mapViewIds = { R . id . friend_action_date , R . id . friend_action_data } ; </a> 0
<a> friendActivityAdapter = new SimpleCursorAdapter ( this , R . layout . friend_activity_row , createEmptyCursor ( ) , </a> 0
<a> mapColumnNames , mapViewIds ) ; </a> 0
<a> friendActivityList . setAdapter ( friendActivityAdapter ) ; </a> 0
<a> friendActivityProgressBar = ( ProgressBar ) findViewById ( R . id . friend_activity_progress_bar ) ; </a> 0
<a> settingsGroup = ( ViewGroup ) findViewById ( R . id . settings_group ) ; </a> 0
<a> contentGroup = ( ViewGroup ) findViewById ( R . id . content_group ) ; </a> 0
<a> contentImage = ( ImageView ) findViewById ( R . id . content_image ) ; </a> 0
<a> contentSpinner = ( Spinner ) findViewById ( R . id . content_spinner ) ; </a> 0
<a> FragmentManager fragmentManager = getSupportFragmentManager ( ) ; </a> 0
<a> FragmentTransaction transaction = fragmentManager . beginTransaction ( ) ; </a> 0
<a> friendPickerFragment = ( FriendPickerFragment ) fragmentManager . findFragmentById ( R . id . friend_picker_fragment ) ; </a> 0
<a> if ( friendPickerFragment == null ) { </a> 0
<a> Bundle args = new Bundle ( ) ; </a> 0
<a> args . putBoolean ( FriendPickerFragment . SHOW_TITLE_BAR_BUNDLE_KEY , false ) ; </a> 0
<a> friendPickerFragment = new FriendPickerFragment ( args ) ; </a> 0
<a> transaction . add ( R . id . friend_picker_fragment , friendPickerFragment ) ; </a> 0
<a> } </a> 0
<a> userSettingsFragment = ( UserSettingsFragment ) fragmentManager . findFragmentById ( R . id . login_fragment ) ; </a> 0
<a> if ( userSettingsFragment == null ) { </a> 0
<a> userSettingsFragment = new UserSettingsFragment ( ) ; </a> 0
<a> transaction . add ( R . id . login_fragment , userSettingsFragment ) ; </a> 0
<a> } </a> 0
<a> transaction . commit ( ) ; </a> 0
<a> ArrayAdapter < CharSequence > truthAdapter = ArrayAdapter </a> 0
<a> . createFromResource ( this , R . array . truth_values , android . R . layout . simple_spinner_item ) ; </a> 0
<a> truthAdapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ; </a> 0
<a> leftSpinner . setAdapter ( truthAdapter ) ; </a> 0
<a> rightSpinner . setAdapter ( truthAdapter ) ; </a> 0
<a> contentSpinner . setAdapter ( truthAdapter ) ; </a> 0
<a> leftSpinner . setSelection ( 0 ) ; </a> 0
<a> rightSpinner . setSelection ( 0 ) ; </a> 0
<a> for ( Button button : Arrays . asList ( logicButton , friendsButton , settingsButton , contentButton ) ) { </a> 0
<a> initializeNavigationButton ( button ) ; </a> 0
<a> } </a> 0
<a> initializeCalculationButton ( andButton ) ; </a> 0
<a> initializeCalculationButton ( orButton ) ; </a> 0
<a> friendPickerFragment . setOnErrorListener ( new PickerFragment . OnErrorListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onError ( PickerFragment < ? > fragment , FacebookException error ) { </a> 0
<a> LogicActivity . this . onError ( error ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> friendPickerFragment . setUserId ( "me" ) ; </a> 0
<a> friendPickerFragment . setMultiSelect ( false ) ; </a> 0
<a> friendPickerFragment . setOnSelectionChangedListener ( new PickerFragment . OnSelectionChangedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onSelectionChanged ( PickerFragment < ? > fragment ) { </a> 0
<a> LogicActivity . this . onFriendSelectionChanged ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> friendPickerFragment . setExtraFields ( Arrays . asList ( INSTALLED ) ) ; </a> 0
<a> friendPickerFragment . setFilter ( new PickerFragment . GraphObjectFilter < GraphUser > ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean includeItem ( GraphUser graphObject ) { </a> 0
<a> Boolean installed = graphObject . cast ( GraphUserWithInstalled . class ) . getInstalled ( ) ; </a> 0
<a> return ( installed != null ) && installed . booleanValue ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> contentSpinner . setOnItemSelectedListener ( new AdapterView . OnItemSelectedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onItemSelected ( AdapterView < ? > adapterView , View view , int i , long l ) { </a> 0
<a> LogicActivity . this . onContentSelectionChanged ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onNothingSelected ( AdapterView < ? > adapterView ) { </a> 0
<a> LogicActivity . this . onContentSelectionChanged ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Button startButton = logicButton ; </a> 0
<a> if ( savedInstanceState != null ) { </a> 0
<a> leftSpinner . setSelection ( savedInstanceState . getInt ( SAVE_LEFT_OPERAND_SELECTION ) ) ; </a> 0
<a> rightSpinner . setSelection ( savedInstanceState . getInt ( SAVE_RIGHT_OPERAND_SELECTION ) ) ; </a> 0
<a> contentSpinner . setSelection ( savedInstanceState . getInt ( SAVE_CONTENT_SELECTION ) ) ; </a> 0
<a> resultText . setText ( savedInstanceState . getString ( SAVE_RESULT_TEXT ) ) ; </a> 0
<a> postResultText . setText ( savedInstanceState . getString ( SAVE_POST_RESULT_TEXT ) ) ; </a> 0
<a> activeTab = savedInstanceState . getString ( SAVE_ACTIVE_TAB ) ; </a> 0
<a> pendingPost = savedInstanceState . getBundle ( SAVE_PENDING ) ; </a> 0
<a> friendActionList = savedInstanceState . getParcelableArrayList ( SAVE_FRIEND_ACTIONS ) ; </a> 0
<a> if ( ( friendActionList != null ) && ( friendActionList . size ( ) > 0 ) ) { </a> 0
<a> updateCursor ( friendActionList ) ; </a> 0
<a> } </a> 0
<a> if ( getString ( R . string . navigate_friends ) . equals ( activeTab ) ) { </a> 0
<a> startButton = friendsButton ; </a> 0
<a> } else if ( getString ( R . string . navigate_content ) . equals ( activeTab ) ) { </a> 0
<a> startButton = contentButton ; </a> 0
<a> } else if ( getString ( R . string . navigate_settings ) . equals ( activeTab ) ) { </a> 0
<a> startButton = settingsButton ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! handleNativeLink ( ) ) { </a> 0
<a> onNavigateButtonClick ( startButton ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onStart ( ) { </a> 0
<a> super . onStart ( ) ; </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session != null && session . isOpened ( ) ) { </a> 0
<a> friendPickerFragment . loadData ( false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onResume ( ) { </a> 0
<a> super . onResume ( ) ; </a> 0
<a> uiHelper . onResume ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onSaveInstanceState ( Bundle outState ) { </a> 0
<a> super . onSaveInstanceState ( outState ) ; </a> 0
<a> uiHelper . onSaveInstanceState ( outState ) ; </a> 0
<a> outState . putInt ( SAVE_LEFT_OPERAND_SELECTION , leftSpinner . getSelectedItemPosition ( ) ) ; </a> 0
<a> outState . putInt ( SAVE_RIGHT_OPERAND_SELECTION , rightSpinner . getSelectedItemPosition ( ) ) ; </a> 0
<a> outState . putInt ( SAVE_CONTENT_SELECTION , contentSpinner . getSelectedItemPosition ( ) ) ; </a> 0
<a> outState . putString ( SAVE_RESULT_TEXT , resultText . getText ( ) . toString ( ) ) ; </a> 0
<a> outState . putString ( SAVE_POST_RESULT_TEXT , postResultText . getText ( ) . toString ( ) ) ; </a> 0
<a> outState . putString ( SAVE_ACTIVE_TAB , activeTab ) ; </a> 0
<a> outState . putBundle ( SAVE_PENDING , pendingPost ) ; </a> 0
<a> outState . putParcelableArrayList ( SAVE_FRIEND_ACTIONS , friendActionList ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onPause ( ) { </a> 0
<a> super . onPause ( ) ; </a> 0
<a> uiHelper . onPause ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDestroy ( ) { </a> 0
<a> super . onDestroy ( ) ; </a> 0
<a> uiHelper . onDestroy ( ) ; </a> 0
<a> friendPickerFragment . setOnErrorListener ( null ) ; </a> 0
<a> friendPickerFragment . setOnSelectionChangedListener ( null ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> super . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> uiHelper . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> private void initializeNavigationButton ( Button button ) { </a> 0
<a> button . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> onNavigateButtonClick ( ( Button ) view ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private void onNavigateButtonClick ( Button source ) { </a> 0
<a> activeTab = source . getText ( ) . toString ( ) ; </a> 0
<a> logicGroup . setVisibility ( getGroupVisibility ( source , logicButton ) ) ; </a> 0
<a> friendsGroup . setVisibility ( getGroupVisibility ( source , friendsButton ) ) ; </a> 0
<a> settingsGroup . setVisibility ( getGroupVisibility ( source , settingsButton ) ) ; </a> 0
<a> contentGroup . setVisibility ( getGroupVisibility ( source , contentButton ) ) ; </a> 0
<a> if ( source == friendsButton ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( ( session == null ) || ! session . isOpened ( ) ) { </a> 0
<a> new AlertDialog . Builder ( this ) </a> 0
<a> . setTitle ( R . string . feature_requires_login_title ) </a> 0
<a> . setMessage ( R . string . feature_requires_login_message ) </a> 0
<a> . setPositiveButton ( R . string . ok_button , null ) </a> 0
<a> . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private int getGroupVisibility ( Button source , Button groupButton ) { </a> 0
<a> if ( source == groupButton ) { </a> 0
<a> return View . VISIBLE ; </a> 0
<a> } else { </a> 0
<a> return View . GONE ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void initializeCalculationButton ( Button button ) { </a> 0
<a> button . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> onOperationButtonClick ( view ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private void onOperationButtonClick ( View view ) { </a> 0
<a> if ( view == andButton ) { </a> 0
<a> onAndButtonClick ( ) ; </a> 0
<a> } else if ( view == orButton ) { </a> 0
<a> onOrButtonClick ( ) ; </a> 0
<a> } else { </a> 0
<a> assert false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onAndButtonClick ( ) { </a> 0
<a> boolean leftOperand = getSpinnerBoolean ( leftSpinner ) ; </a> 0
<a> boolean rightOperand = getSpinnerBoolean ( rightSpinner ) ; </a> 0
<a> boolean result = leftOperand && rightOperand ; </a> 0
<a> resultText . setText ( getLogicText ( getString ( R . string . and_operation ) , leftOperand , rightOperand , result ) ) ; </a> 0
<a> postAction ( POST_AND_ACTION_PATH , leftOperand , rightOperand , result ) ; </a> 0
<a> } </a> 0
<a> private void onOrButtonClick ( ) { </a> 0
<a> boolean leftOperand = getSpinnerBoolean ( leftSpinner ) ; </a> 0
<a> boolean rightOperand = getSpinnerBoolean ( rightSpinner ) ; </a> 0
<a> boolean result = leftOperand || rightOperand ; </a> 0
<a> resultText . setText ( getLogicText ( getString ( R . string . or_operation ) , leftOperand , rightOperand , result ) ) ; </a> 0
<a> postAction ( POST_OR_ACTION_PATH , leftOperand , rightOperand , result ) ; </a> 0
<a> } </a> 0
<a> private String getLogicText ( String op , boolean leftOperand , boolean rightOperand , boolean result ) { </a> 0
<a> String trueString = getString ( R . string . true_value ) ; </a> 0
<a> String falseString = getString ( R . string . false_value ) ; </a> 0
<a> String arg0String = leftOperand ? trueString : falseString ; </a> 0
<a> String arg1String = rightOperand ? trueString : falseString ; </a> 0
<a> String resultString = result ? trueString : falseString ; </a> 0
<a> return String . format ( "%s %s %s = %s" , arg0String , op , arg1String , resultString ) ; </a> 0
<a> } </a> 0
<a> private void postAction ( final String actionPath , final boolean leftOperand , final boolean rightOperand , </a> 0
<a> final boolean result ) { </a> 0
<a> Bundle post = new Bundle ( ) ; </a> 0
<a> post . putString ( PENDING_POST_PATH , actionPath ) ; </a> 0
<a> post . putBoolean ( PENDING_POST_LEFT , leftOperand ) ; </a> 0
<a> post . putBoolean ( PENDING_POST_RIGHT , rightOperand ) ; </a> 0
<a> post . putBoolean ( PENDING_POST_RESULT , result ) ; </a> 0
<a> pendingPost = post ; </a> 0
<a> sendPendingPost ( ) ; </a> 0
<a> } </a> 0
<a> private void sendPendingPost ( ) { </a> 0
<a> if ( pendingPost == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( ( session == null ) || ! session . isOpened ( ) ) { </a> 0
<a> postResultText . setText ( "Not logged in, no post generated." ) ; </a> 0
<a> pendingPost = null ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> List < String > permissions = session . getPermissions ( ) ; </a> 0
<a> if ( ! permissions . containsAll ( PERMISSIONS ) ) { </a> 0
<a> Session . NewPermissionsRequest newPermissionsRequest = new Session . NewPermissionsRequest ( this , PERMISSIONS ) ; </a> 0
<a> session . requestNewPublishPermissions ( newPermissionsRequest ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> postResultText . setText ( "Posting action..." ) ; </a> 0
<a> String actionPath = pendingPost . getString ( PENDING_POST_PATH ) ; </a> 0
<a> boolean leftOperand = pendingPost . getBoolean ( PENDING_POST_LEFT ) ; </a> 0
<a> boolean rightOperand = pendingPost . getBoolean ( PENDING_POST_RIGHT ) ; </a> 0
<a> boolean result = pendingPost . getBoolean ( PENDING_POST_RESULT ) ; </a> 0
<a> LogicAction action = GraphObject . Factory . create ( LogicAction . class ) ; </a> 0
<a> action . setResult ( result ) ; </a> 0
<a> action . setTruthvalue ( getTruthValueObject ( leftOperand ) ) ; </a> 0
<a> action . setAnothertruthvalue ( getTruthValueObject ( rightOperand ) ) ; </a> 0
<a> Request . Callback callback = new Request . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> onPostActionResponse ( response ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> Request request = new Request ( session , actionPath , null , HttpMethod . POST , </a> 0
<a> callback ) ; </a> 0
<a> request . setGraphObject ( action ) ; </a> 0
<a> RequestAsyncTask task = new RequestAsyncTask ( request ) ; </a> 0
<a> task . execute ( ) ; </a> 0
<a> } </a> 0
<a> private void onPostActionResponse ( Response response ) { </a> 0
<a> PostResponse postResponse = response . getGraphObjectAs ( PostResponse . class ) ; </a> 0
<a> if ( postResponse != null && postResponse . getId ( ) != null ) { </a> 0
<a> postResultText . setText ( "Post id = " + postResponse . getId ( ) ) ; </a> 0
<a> } else if ( response . getError ( ) != null ) { </a> 0
<a> postResultText . setText ( response . getError ( ) . getErrorMessage ( ) ) ; </a> 0
<a> } else { </a> 0
<a> postResultText . setText ( "" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private TruthValueGraphObject getTruthValueObject ( boolean value ) { </a> 0
<a> if ( value ) { </a> 0
<a> if ( TRUE_GRAPH_OBJECT == null ) { </a> 0
<a> TruthValueGraphObject object = GraphObject . Factory </a> 0
<a> . create ( TruthValueGraphObject . class ) ; </a> 0
<a> object . setUrl ( TRUE_GRAPH_OBJECT_URL ) ; </a> 0
<a> TRUE_GRAPH_OBJECT = object ; </a> 0
<a> } </a> 0
<a> return TRUE_GRAPH_OBJECT ; </a> 0
<a> } else { </a> 0
<a> if ( FALSE_GRAPH_OBJECT == null ) { </a> 0
<a> TruthValueGraphObject object = GraphObject . Factory </a> 0
<a> . create ( TruthValueGraphObject . class ) ; </a> 0
<a> object . setUrl ( FALSE_GRAPH_OBJECT_URL ) ; </a> 0
<a> FALSE_GRAPH_OBJECT = object ; </a> 0
<a> } </a> 0
<a> return FALSE_GRAPH_OBJECT ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onFriendSelectionChanged ( ) { </a> 0
<a> GraphUser user = chooseOne ( friendPickerFragment . getSelection ( ) ) ; </a> 0
<a> if ( user != null ) { </a> 0
<a> onChooseFriend ( user . getId ( ) ) ; </a> 0
<a> } else { </a> 0
<a> friendActivityAdapter . changeCursor ( createEmptyCursor ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onChooseFriend ( String friendId ) { </a> 0
<a> friendActivityProgressBar . setVisibility ( View . VISIBLE ) ; </a> 0
<a> String andPath = String . format ( "%s/%s" , friendId , AND_ACTION ) ; </a> 0
<a> String orPath = String . format ( "%s/%s" , friendId , OR_ACTION ) ; </a> 0
<a> Request getAnds = new Request ( Session . getActiveSession ( ) , andPath , null , HttpMethod . GET ) ; </a> 0
<a> Request getOrs = new Request ( Session . getActiveSession ( ) , orPath , null , HttpMethod . GET ) ; </a> 0
<a> RequestBatch batch = new RequestBatch ( getAnds , getOrs ) ; </a> 0
<a> if ( pendingRequest != null ) { </a> 0
<a> pendingRequest . cancel ( true ) ; </a> 0
<a> } </a> 0
<a> pendingRequest = new RequestAsyncTask ( batch ) { </a> 0
<a> @ Override </a> 0
<a> protected void onPostExecute ( List < Response > result ) { </a> 0
<a> if ( pendingRequest == this ) { </a> 0
<a> pendingRequest = null ; </a> 0
<a> LogicActivity . this . onPostExecute ( result ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> pendingRequest . execute ( ) ; </a> 0
<a> } </a> 0
<a> private void onPostExecute ( List < Response > result ) { </a> 0
<a> friendActivityProgressBar . setVisibility ( View . GONE ) ; </a> 0
<a> friendActionList = createActionRows ( result ) ; </a> 0
<a> updateCursor ( friendActionList ) ; </a> 0
<a> } </a> 0
<a> private ArrayList < ActionRow > createActionRows ( List < Response > result ) { </a> 0
<a> ArrayList < ActionRow > publishedItems = new ArrayList < ActionRow > ( ) ; </a> 0
<a> for ( Response response : result ) { </a> 0
<a> if ( response . getError ( ) != null ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> GraphMultiResult list = response . getGraphObjectAs ( GraphMultiResult . class ) ; </a> 0
<a> List < PublishedLogicAction > listData = list . getData ( ) . castToListOf ( PublishedLogicAction . class ) ; </a> 0
<a> for ( PublishedLogicAction action : listData ) { </a> 0
<a> publishedItems . add ( createActionRow ( action ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Collections . sort ( publishedItems ) ; </a> 0
<a> return publishedItems ; </a> 0
<a> } </a> 0
<a> private void updateCursor ( Iterable < ActionRow > publishedItems ) { </a> 0
<a> MatrixCursor cursor = createEmptyCursor ( ) ; </a> 0
<a> SimpleDateFormat dateFormat = new SimpleDateFormat ( "yyyy-MM-dd" , Locale . getDefault ( ) ) ; </a> 0
<a> int id = 0 ; </a> 0
<a> for ( ActionRow item : publishedItems ) { </a> 0
<a> Object [ ] row = new Object [ 3 ] ; </a> 0
<a> row [ 0 ] = id ++ ; </a> 0
<a> row [ 1 ] = dateFormat . format ( item . publishDate ) ; </a> 0
<a> row [ 2 ] = item . actionText ; </a> 0
<a> cursor . addRow ( row ) ; </a> 0
<a> } </a> 0
<a> friendActivityAdapter . changeCursor ( cursor ) ; </a> 0
<a> friendActivityAdapter . notifyDataSetChanged ( ) ; </a> 0
<a> } </a> 0
<a> private MatrixCursor createEmptyCursor ( ) { </a> 0
<a> String [ ] cursorColumns = { "_ID" , "date" , "action" } ; </a> 0
<a> return new MatrixCursor ( cursorColumns ) ; </a> 0
<a> } </a> 0
<a> private ActionRow createActionRow ( PublishedLogicAction action ) { </a> 0
<a> String actionText = getActionText ( action ) ; </a> 0
<a> Date publishDate = action . getPublishTime ( ) ; </a> 0
<a> return new ActionRow ( actionText , publishDate ) ; </a> 0
<a> } </a> 0
<a> private String getActionText ( PublishedLogicAction action ) { </a> 0
<a> LogicAction actionData = action . getData ( ) ; </a> 0
<a> if ( actionData == null ) { </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> TruthValueGraphObject left = actionData . getTruthvalue ( ) ; </a> 0
<a> TruthValueGraphObject right = actionData . getAnothertruthvalue ( ) ; </a> 0
<a> Boolean actionResult = actionData . getResult ( ) ; </a> 0
<a> String verb = action . getType ( ) ; </a> 0
<a> if ( AND_ACTION . equals ( verb ) ) { </a> 0
<a> verb = getString ( R . string . and_operation ) ; </a> 0
<a> } else if ( OR_ACTION . equals ( verb ) ) { </a> 0
<a> verb = getString ( R . string . or_operation ) ; </a> 0
<a> } </a> 0
<a> if ( ( left == null ) || ( right == null ) || ( actionResult == null ) || ( verb == null ) ) { </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> return String . format ( "%s %s %s = %s" , left . getTitle ( ) , verb , right . getTitle ( ) , actionResult . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> private Boolean getDeepLinkContent ( Uri deepLinkUri ) { </a> 0
<a> if ( deepLinkUri != null ) { </a> 0
<a> String deepLink = deepLinkUri . toString ( ) ; </a> 0
<a> if ( deepLink . startsWith ( TRUE_GRAPH_OBJECT_URL ) ) { </a> 0
<a> return Boolean . TRUE ; </a> 0
<a> } else if ( deepLink . startsWith ( FALSE_GRAPH_OBJECT_URL ) ) { </a> 0
<a> return Boolean . FALSE ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> private void onContentSelectionChanged ( ) { </a> 0
<a> Boolean spinnerBoolean = getSpinnerBoolean ( contentSpinner ) ; </a> 0
<a> if ( Boolean . TRUE . equals ( spinnerBoolean ) ) { </a> 0
<a> contentImage . setVisibility ( View . VISIBLE ) ; </a> 0
<a> contentImage . setImageResource ( R . drawable . true_content ) ; </a> 0
<a> } else if ( Boolean . FALSE . equals ( spinnerBoolean ) ) { </a> 0
<a> contentImage . setVisibility ( View . VISIBLE ) ; </a> 0
<a> contentImage . setImageResource ( R . drawable . false_content ) ; </a> 0
<a> } else { </a> 0
<a> contentImage . setImageResource ( View . INVISIBLE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean handleNativeLink ( ) { </a> 0
<a> Session existingSession = Session . getActiveSession ( ) ; </a> 0
<a> if ( existingSession == null || ! existingSession . isOpened ( ) ) { </a> 0
<a> AccessToken accessToken = AccessToken . createFromNativeLinkingIntent ( getIntent ( ) ) ; </a> 0
<a> if ( accessToken != null ) { </a> 0
<a> Session newSession = new Session . Builder ( this ) . setTokenCachingStrategy ( new NonCachingTokenCachingStrategy ( ) ) </a> 0
<a> . build ( ) ; </a> 0
<a> newSession . open ( accessToken , null ) ; </a> 0
<a> Session . setActiveSession ( newSession ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Boolean deepLinkContent = getDeepLinkContent ( getIntent ( ) . getData ( ) ) ; </a> 0
<a> if ( deepLinkContent != null ) { </a> 0
<a> onNavigateButtonClick ( contentButton ) ; </a> 0
<a> contentSpinner . setSelection ( getSpinnerPosition ( deepLinkContent ) ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private int getSpinnerPosition ( Boolean value ) { </a> 0
<a> initializeSpinnerIndexes ( ) ; </a> 0
<a> if ( Boolean . TRUE . equals ( value ) ) { </a> 0
<a> return TRUE_SPINNER_INDEX ; </a> 0
<a> } else if ( Boolean . FALSE . equals ( value ) ) { </a> 0
<a> return FALSE_SPINNER_INDEX ; </a> 0
<a> } else { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private Boolean getSpinnerBoolean ( Spinner spinner ) { </a> 0
<a> initializeSpinnerIndexes ( ) ; </a> 0
<a> int position = spinner . getSelectedItemPosition ( ) ; </a> 0
<a> if ( position == TRUE_SPINNER_INDEX ) { </a> 0
<a> return Boolean . TRUE ; </a> 0
<a> } else if ( position == FALSE_SPINNER_INDEX ) { </a> 0
<a> return Boolean . FALSE ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void initializeSpinnerIndexes ( ) { </a> 0
<a> if ( ( TRUE_SPINNER_INDEX < 0 ) || ( FALSE_SPINNER_INDEX < 0 ) ) { </a> 0
<a> String [ ] truthArray = getResources ( ) . getStringArray ( R . array . truth_values ) ; </a> 0
<a> List < String > truthList = Arrays . asList ( truthArray ) ; </a> 0
<a> TRUE_SPINNER_INDEX = truthList . indexOf ( getString ( R . string . true_value ) ) ; </a> 0
<a> FALSE_SPINNER_INDEX = truthList . indexOf ( getString ( R . string . false_value ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onError ( Exception error ) { </a> 0
<a> showErrorMessage ( error . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> private void showErrorMessage ( String message ) { </a> 0
<a> new AlertDialog . Builder ( this ) </a> 0
<a> . setTitle ( R . string . error_dialog_title ) </a> 0
<a> . setMessage ( message ) </a> 0
<a> . setPositiveButton ( R . string . ok_button , null ) </a> 0
<a> . show ( ) ; </a> 0
<a> } </a> 0
<a> private < T > T chooseOne ( List < T > ts ) { </a> 0
<a> for ( T t : ts ) { </a> 0
<a> return t ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> private interface GraphUserWithInstalled extends GraphUser { </a> 0
<a> Boolean getInstalled ( ) ; </a> 0
<a> } </a> 0
<a> private static class ActionRow implements Comparable < ActionRow > , Parcelable { </a> 0
<a> final String actionText ; </a> 0
<a> final Date publishDate ; </a> 0
<a> ActionRow ( String actionText , Date publishDate ) { </a> 0
<a> this . actionText = actionText ; </a> 0
<a> this . publishDate = publishDate ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( ActionRow other ) { </a> 0
<a> if ( other == null ) { </a> 0
<a> return 1 ; </a> 0
<a> } else { </a> 0
<a> return publishDate . compareTo ( other . publishDate ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int describeContents ( ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeToParcel ( Parcel parcel , int flags ) { </a> 0
<a> parcel . writeString ( actionText ) ; </a> 0
<a> parcel . writeLong ( publishDate . getTime ( ) ) ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unused" ) </a> 0
<a> public final Creator < ActionRow > CREATOR = new Creator < ActionRow > ( ) { </a> 0
<a> @ Override </a> 0
<a> public ActionRow createFromParcel ( Parcel parcel ) { </a> 0
<a> String actionText = parcel . readString ( ) ; </a> 0
<a> Date publishDate = new Date ( parcel . readLong ( ) ) ; </a> 0
<a> return new ActionRow ( actionText , publishDate ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ActionRow [ ] newArray ( int size ) { </a> 0
<a> return new ActionRow [ size ] ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> private interface TruthValueGraphObject extends GraphObject { </a> 0
<a> void setUrl ( String url ) ; </a> 0
<a> String getTitle ( ) ; </a> 0
<a> } </a> 0
<a> private interface LogicAction extends OpenGraphAction { </a> 0
<a> Boolean getResult ( ) ; </a> 0
<a> void setResult ( Boolean result ) ; </a> 0
<a> TruthValueGraphObject getTruthvalue ( ) ; </a> 0
<a> void setTruthvalue ( TruthValueGraphObject truthvalue ) ; </a> 0
<a> TruthValueGraphObject getAnothertruthvalue ( ) ; </a> 0
<a> void setAnothertruthvalue ( TruthValueGraphObject anothertruthvalue ) ; </a> 0
<a> } </a> 0
<a> private interface PublishedLogicAction extends OpenGraphAction { </a> 0
<a> LogicAction getData ( ) ; </a> 0
<a> String getType ( ) ; </a> 0
<a> } </a> 0
<a> private interface PostResponse extends GraphObject { </a> 0
<a> String getId ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . friendpicker ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import com . facebook . Session ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> public class FriendPickerSampleActivity extends FragmentActivity { </a> 0
<a> private static final int PICK_FRIENDS_ACTIVITY = 1 ; </a> 0
<a> private Button pickFriendsButton ; </a> 0
<a> private TextView resultsTextView ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . main ) ; </a> 0
<a> resultsTextView = ( TextView ) findViewById ( R . id . resultsTextView ) ; </a> 0
<a> pickFriendsButton = ( Button ) findViewById ( R . id . pickFriendsButton ) ; </a> 0
<a> pickFriendsButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> onClickPickFriends ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> if ( Session . getActiveSession ( ) == null || </a> 1
<a> Session . getActiveSession ( ) . isClosed ( ) ) { </a> 1
<a> Session . openActiveSession ( this , true , null ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onStart ( ) { </a> 0
<a> super . onStart ( ) ; </a> 0
<a> displaySelectedFriends ( RESULT_OK ) ; </a> 0
<a> } </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> switch ( requestCode ) { </a> 0
<a> case PICK_FRIENDS_ACTIVITY : </a> 0
<a> displaySelectedFriends ( resultCode ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> Session . getActiveSession ( ) . onActivityResult ( this , requestCode , resultCode , data ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void displaySelectedFriends ( int resultCode ) { </a> 0
<a> String results = "" ; </a> 0
<a> FriendPickerApplication application = ( FriendPickerApplication ) getApplication ( ) ; </a> 0
<a> Collection < GraphUser > selection = application . getSelectedUsers ( ) ; </a> 0
<a> if ( selection != null && selection . size ( ) > 0 ) { </a> 0
<a> ArrayList < String > names = new ArrayList < String > ( ) ; </a> 0
<a> for ( GraphUser user : selection ) { </a> 0
<a> names . add ( user . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> results = TextUtils . join ( ", " , names ) ; </a> 0
<a> } else { </a> 0
<a> results = "<No friends selected>" ; </a> 0
<a> } </a> 0
<a> resultsTextView . setText ( results ) ; </a> 0
<a> } </a> 0
<a> private void onClickPickFriends ( ) { </a> 0
<a> FriendPickerApplication application = ( FriendPickerApplication ) getApplication ( ) ; </a> 1
<a> application . setSelectedUsers ( null ) ; </a> 1
<a> Intent intent = new Intent ( this , PickFriendsActivity . class ) ; </a> 0
<a> PickFriendsActivity . populateParameters ( intent , null , true , true ) ; </a> 0
<a> startActivityForResult ( intent , PICK_FRIENDS_ACTIVITY ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . friendpicker ; </a> 0
<a> import android . app . AlertDialog ; </a> 1
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> import android . support . v4 . app . FragmentManager ; </a> 0
<a> import com . facebook . FacebookException ; </a> 0
<a> import com . facebook . widget . FriendPickerFragment ; </a> 0
<a> import com . facebook . widget . PickerFragment ; </a> 0
<a> public class PickFriendsActivity extends FragmentActivity { </a> 0
<a> FriendPickerFragment friendPickerFragment ; </a> 0
<a> public static void populateParameters ( Intent intent , String userId , boolean multiSelect , boolean showTitleBar ) { </a> 0
<a> intent . putExtra ( FriendPickerFragment . USER_ID_BUNDLE_KEY , userId ) ; </a> 0
<a> intent . putExtra ( FriendPickerFragment . MULTI_SELECT_BUNDLE_KEY , multiSelect ) ; </a> 0
<a> intent . putExtra ( FriendPickerFragment . SHOW_TITLE_BAR_BUNDLE_KEY , showTitleBar ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . pick_friends_activity ) ; </a> 0
<a> FragmentManager fm = getSupportFragmentManager ( ) ; </a> 0
<a> if ( savedInstanceState == null ) { </a> 0
<a> final Bundle args = getIntent ( ) . getExtras ( ) ; </a> 0
<a> friendPickerFragment = new FriendPickerFragment ( args ) ; </a> 0
<a> fm . beginTransaction ( ) </a> 0
<a> . add ( R . id . friend_picker_fragment , friendPickerFragment ) </a> 0
<a> . commit ( ) ; </a> 0
<a> } else { </a> 0
<a> friendPickerFragment = ( FriendPickerFragment ) fm . findFragmentById ( R . id . friend_picker_fragment ) ; </a> 0
<a> } </a> 0
<a> friendPickerFragment . setOnErrorListener ( new PickerFragment . OnErrorListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onError ( PickerFragment < ? > fragment , FacebookException error ) { </a> 0
<a> PickFriendsActivity . this . onError ( error ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> friendPickerFragment . setOnDoneButtonClickedListener ( new PickerFragment . OnDoneButtonClickedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onDoneButtonClicked ( PickerFragment < ? > fragment ) { </a> 0
<a> FriendPickerApplication application = ( FriendPickerApplication ) getApplication ( ) ; </a> 0
<a> application . setSelectedUsers ( friendPickerFragment . getSelection ( ) ) ; </a> 0
<a> setResult ( RESULT_OK , null ) ; </a> 0
<a> finish ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private void onError ( Exception error ) { </a> 0
<a> new AlertDialog . Builder ( this ) </a> 1
<a> . setTitle ( R . string . error_dialog_title ) </a> 1
<a> . setMessage ( error . getMessage ( ) ) </a> 1
<a> . setPositiveButton ( R . string . ok_button , null ) </a> 1
<a> . show ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onStart ( ) { </a> 0
<a> super . onStart ( ) ; </a> 0
<a> try { </a> 0
<a> friendPickerFragment . loadData ( false ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> onError ( ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . graphapi ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . app . AlertDialog ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . View . OnClickListener ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> import android . widget . EditText ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . Session . StatusCallback ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class GraphApiSampleActivity extends Activity { </a> 0
<a> static final String applicationId = "307234779396415" ; </a> 0
<a> static final String PENDING_REQUEST_BUNDLE_KEY = "com.facebook.samples.graphapi:PendingRequest" ; </a> 0
<a> Button buttonRequest ; </a> 0
<a> EditText editRequests ; </a> 0
<a> TextView textViewResults ; </a> 0
<a> Session session ; </a> 0
<a> boolean pendingRequest ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . main ) ; </a> 0
<a> this . buttonRequest = ( Button ) findViewById ( R . id . buttonRequest ) ; </a> 0
<a> this . buttonRequest . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> onClickRequest ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> this . editRequests = ( EditText ) findViewById ( R . id . editRequests ) ; </a> 0
<a> this . textViewResults = ( TextView ) findViewById ( R . id . textViewResults ) ; </a> 0
<a> this . session = createSession ( ) ; </a> 0
<a> Settings . addLoggingBehavior ( LoggingBehavior . INCLUDE_ACCESS_TOKENS ) ; </a> 0
<a> } </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> if ( this . session . onActivityResult ( this , requestCode , resultCode , data ) && </a> 0
<a> pendingRequest && </a> 0
<a> this . session . getState ( ) . isOpened ( ) ) { </a> 0
<a> sendRequests ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onRestoreInstanceState ( Bundle savedInstanceState ) { </a> 0
<a> super . onRestoreInstanceState ( savedInstanceState ) ; </a> 0
<a> pendingRequest = savedInstanceState . getBoolean ( PENDING_REQUEST_BUNDLE_KEY , pendingRequest ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onSaveInstanceState ( Bundle outState ) { </a> 0
<a> super . onSaveInstanceState ( outState ) ; </a> 0
<a> outState . putBoolean ( PENDING_REQUEST_BUNDLE_KEY , pendingRequest ) ; </a> 0
<a> } </a> 0
<a> private void onClickRequest ( ) { </a> 0
<a> if ( this . session . isOpened ( ) ) { </a> 0
<a> sendRequests ( ) ; </a> 0
<a> } else { </a> 0
<a> StatusCallback callback = new StatusCallback ( ) { </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> if ( exception != null ) { </a> 0
<a> new AlertDialog . Builder ( GraphApiSampleActivity . this ) </a> 0
<a> . setTitle ( R . string . login_failed_dialog_title ) </a> 0
<a> . setMessage ( exception . getMessage ( ) ) </a> 0
<a> . setPositiveButton ( R . string . ok_button , null ) </a> 0
<a> . show ( ) ; </a> 0
<a> GraphApiSampleActivity . this . session = createSession ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> pendingRequest = true ; </a> 0
<a> this . session . openForRead ( new Session . OpenRequest ( this ) . setCallback ( callback ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void sendRequests ( ) { </a> 0
<a> textViewResults . setText ( "" ) ; </a> 0
<a> String requestIdsText = editRequests . getText ( ) . toString ( ) ; </a> 0
<a> String [ ] requestIds = requestIdsText . split ( "," ) ; </a> 0
<a> List < Request > requests = new ArrayList < Request > ( ) ; </a> 0
<a> for ( final String requestId : requestIds ) { </a> 0
<a> requests . add ( new Request ( session , requestId , null , null , new Request . Callback ( ) { </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> GraphObject graphObject = response . getGraphObject ( ) ; </a> 0
<a> FacebookRequestError error = response . getError ( ) ; </a> 0
<a> String s = textViewResults . getText ( ) . toString ( ) ; </a> 0
<a> if ( graphObject != null ) { </a> 0
<a> if ( graphObject . getProperty ( "id" ) != null ) { </a> 0
<a> s = s + String . format ( "%s: %s\n" , graphObject . getProperty ( "id" ) , graphObject . getProperty ( </a> 0
<a> "name" ) ) ; </a> 0
<a> } else { </a> 0
<a> s = s + String . format ( "%s: <no such id>\n" , requestId ) ; </a> 0
<a> } </a> 0
<a> } else if ( error != null ) { </a> 0
<a> s = s + String . format ( "Error: %s" , error . getErrorMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> textViewResults . setText ( s ) ; </a> 0
<a> } </a> 0
<a> } ) ) ; </a> 0
<a> } </a> 0
<a> pendingRequest = false ; </a> 0
<a> Request . executeBatchAndWait ( requests ) ; </a> 0
<a> } </a> 0
<a> private Session createSession ( ) { </a> 0
<a> Session activeSession = Session . getActiveSession ( ) ; </a> 0
<a> if ( activeSession == null || activeSession . getState ( ) . isClosed ( ) ) { </a> 0
<a> activeSession = new Session . Builder ( this ) . setApplicationId ( applicationId ) . build ( ) ; </a> 0
<a> Session . setActiveSession ( activeSession ) ; </a> 0
<a> } </a> 0
<a> return activeSession ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import com . facebook . android . Facebook . DialogListener ; </a> 0
<a> public abstract class BaseDialogListener implements DialogListener { </a> 0
<a> @ Override </a> 0
<a> public void onFacebookError ( FacebookError e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onError ( DialogError e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCancel ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . app . Dialog ; </a> 0
<a> import android . app . ProgressDialog ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup . LayoutParams ; </a> 0
<a> import android . view . inputmethod . InputMethodManager ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> import android . widget . EditText ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public class FQLQuery extends Dialog { </a> 0
<a> private EditText mFQLQuery ; </a> 0
<a> private TextView mFQLOutput ; </a> 0
<a> private Button mSubmitButton ; </a> 0
<a> private Activity activity ; </a> 0
<a> private Handler mHandler ; </a> 0
<a> private ProgressDialog dialog ; </a> 0
<a> public FQLQuery ( Activity activity ) { </a> 0
<a> super ( activity ) ; </a> 0
<a> this . activity = activity ; </a> 0
<a> setTitle ( R . string . fqlquery ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> mHandler = new Handler ( ) ; </a> 0
<a> setContentView ( R . layout . fql_query ) ; </a> 0
<a> LayoutParams params = getWindow ( ) . getAttributes ( ) ; </a> 0
<a> params . width = LayoutParams . FILL_PARENT ; </a> 0
<a> params . height = LayoutParams . FILL_PARENT ; </a> 0
<a> getWindow ( ) . setAttributes ( ( android . view . WindowManager . LayoutParams ) params ) ; </a> 0
<a> mFQLQuery = ( EditText ) findViewById ( R . id . fqlquery ) ; </a> 0
<a> mFQLOutput = ( TextView ) findViewById ( R . id . fqlOutput ) ; </a> 0
<a> mSubmitButton = ( Button ) findViewById ( R . id . submit_button ) ; </a> 0
<a> mSubmitButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> ( ( InputMethodManager ) activity . getSystemService ( Context . INPUT_METHOD_SERVICE ) ) </a> 0
<a> . hideSoftInputFromWindow ( mFQLQuery . getWindowToken ( ) , 0 ) ; </a> 0
<a> dialog = ProgressDialog . show ( FQLQuery . this . activity , "" , </a> 0
<a> FQLQuery . this . activity . getString ( R . string . please_wait ) , true , true ) ; </a> 0
<a> String query = mFQLQuery . getText ( ) . toString ( ) ; </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "method" , "fql.query" ) ; </a> 0
<a> params . putString ( "query" , query ) ; </a> 0
<a> Utility . mAsyncRunner . request ( null , params , new FQLRequestListener ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> public class FQLRequestListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> try { </a> 0
<a> JSONArray json = new JSONArray ( response ) ; </a> 0
<a> setText ( json . toString ( 2 ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> try { </a> 0
<a> JSONObject json = new JSONObject ( response ) ; </a> 0
<a> setText ( json . toString ( 2 ) ) ; </a> 0
<a> } catch ( JSONException e1 ) { </a> 0
<a> setText ( activity . getString ( R . string . exception ) + e1 . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> setText ( activity . getString ( R . string . facebook_error ) + error . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void setText ( final String txt ) { </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> mFQLOutput . setText ( txt ) ; </a> 0
<a> mFQLOutput . setVisibility ( View . VISIBLE ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . os . AsyncTask ; </a> 0
<a> import android . widget . BaseAdapter ; </a> 0
<a> import java . util . Hashtable ; </a> 0
<a> import java . util . Stack ; </a> 0
<a> public class FriendsGetProfilePics { </a> 0
<a> Hashtable < String , Bitmap > friendsImages ; </a> 0
<a> Hashtable < String , String > positionRequested ; </a> 0
<a> BaseAdapter listener ; </a> 0
<a> int runningCount = 0 ; </a> 0
<a> Stack < ItemPair > queue ; </a> 0
<a> final static int MAX_ALLOWED_TASKS = 15 ; </a> 0
<a> public FriendsGetProfilePics ( ) { </a> 0
<a> friendsImages = new Hashtable < String , Bitmap > ( ) ; </a> 0
<a> positionRequested = new Hashtable < String , String > ( ) ; </a> 0
<a> queue = new Stack < ItemPair > ( ) ; </a> 0
<a> } </a> 0
<a> public void setListener ( BaseAdapter listener ) { </a> 0
<a> this . listener = listener ; </a> 0
<a> reset ( ) ; </a> 0
<a> } </a> 0
<a> public void reset ( ) { </a> 0
<a> positionRequested . clear ( ) ; </a> 0
<a> runningCount = 0 ; </a> 0
<a> queue . clear ( ) ; </a> 0
<a> } </a> 0
<a> public Bitmap getImage ( String uid , String url ) { </a> 0
<a> Bitmap image = friendsImages . get ( uid ) ; </a> 0
<a> if ( image != null ) { </a> 0
<a> return image ; </a> 0
<a> } </a> 0
<a> if ( ! positionRequested . containsKey ( uid ) ) { </a> 0
<a> positionRequested . put ( uid , "" ) ; </a> 0
<a> if ( runningCount >= MAX_ALLOWED_TASKS ) { </a> 0
<a> queue . push ( new ItemPair ( uid , url ) ) ; </a> 0
<a> } else { </a> 0
<a> runningCount ++ ; </a> 0
<a> new GetProfilePicAsyncTask ( ) . execute ( uid , url ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public void getNextImage ( ) { </a> 0
<a> if ( ! queue . isEmpty ( ) ) { </a> 0
<a> ItemPair item = queue . pop ( ) ; </a> 0
<a> new GetProfilePicAsyncTask ( ) . execute ( item . uid , item . url ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class GetProfilePicAsyncTask extends AsyncTask < Object , Void , Bitmap > { </a> 0
<a> String uid ; </a> 0
<a> @ Override </a> 0
<a> protected Bitmap doInBackground ( Object ... params ) { </a> 0
<a> this . uid = ( String ) params [ 0 ] ; </a> 0
<a> String url = ( String ) params [ 1 ] ; </a> 0
<a> return Utility . getBitmap ( url ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onPostExecute ( Bitmap result ) { </a> 0
<a> runningCount -- ; </a> 0
<a> if ( result != null ) { </a> 0
<a> friendsImages . put ( uid , result ) ; </a> 0
<a> listener . notifyDataSetChanged ( ) ; </a> 0
<a> getNextImage ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> class ItemPair { </a> 0
<a> String uid ; </a> 0
<a> String url ; </a> 0
<a> public ItemPair ( String uid , String url ) { </a> 0
<a> this . uid = uid ; </a> 0
<a> this . url = url ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . app . AlertDialog ; </a> 0
<a> import android . content . DialogInterface ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . view . LayoutInflater ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . widget . * ; </a> 0
<a> import android . widget . AdapterView . OnItemClickListener ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> public class FriendsList extends Activity implements OnItemClickListener { </a> 0
<a> private Handler mHandler ; </a> 0
<a> protected ListView friendsList ; </a> 0
<a> protected static JSONArray jsonArray ; </a> 0
<a> protected String graph_or_fql ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> mHandler = new Handler ( ) ; </a> 0
<a> setContentView ( R . layout . friends_list ) ; </a> 0
<a> Bundle extras = getIntent ( ) . getExtras ( ) ; </a> 0
<a> String apiResponse = extras . getString ( "API_RESPONSE" ) ; </a> 0
<a> graph_or_fql = extras . getString ( "METHOD" ) ; </a> 0
<a> try { </a> 0
<a> if ( graph_or_fql . equals ( "graph" ) ) { </a> 0
<a> jsonArray = new JSONObject ( apiResponse ) . getJSONArray ( "data" ) ; </a> 0
<a> } else { </a> 0
<a> jsonArray = new JSONArray ( apiResponse ) ; </a> 0
<a> } </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> showToast ( "Error: " + e . getMessage ( ) ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> friendsList = ( ListView ) findViewById ( R . id . friends_list ) ; </a> 0
<a> friendsList . setOnItemClickListener ( this ) ; </a> 0
<a> friendsList . setAdapter ( new FriendListAdapter ( this ) ) ; </a> 0
<a> showToast ( getString ( R . string . can_post_on_wall ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public void onItemClick ( AdapterView < ? > arg0 , View v , int position , long arg3 ) { </a> 0
<a> try { </a> 0
<a> final long friendId ; </a> 0
<a> if ( graph_or_fql . equals ( "graph" ) ) { </a> 0
<a> friendId = jsonArray . getJSONObject ( position ) . getLong ( "id" ) ; </a> 0
<a> } else { </a> 0
<a> friendId = jsonArray . getJSONObject ( position ) . getLong ( "uid" ) ; </a> 0
<a> } </a> 0
<a> String name = jsonArray . getJSONObject ( position ) . getString ( "name" ) ; </a> 0
<a> new AlertDialog . Builder ( this ) . setTitle ( R . string . post_on_wall_title ) </a> 0
<a> . setMessage ( String . format ( getString ( R . string . post_on_wall ) , name ) ) </a> 0
<a> . setPositiveButton ( R . string . yes , new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialog , int which ) { </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "to" , String . valueOf ( friendId ) ) ; </a> 0
<a> params . putString ( "caption" , getString ( R . string . app_name ) ) ; </a> 0
<a> params . putString ( "description" , getString ( R . string . app_desc ) ) ; </a> 0
<a> params . putString ( "picture" , Utility . HACK_ICON_URL ) ; </a> 0
<a> params . putString ( "name" , getString ( R . string . app_action ) ) ; </a> 0
<a> Utility . mFacebook . dialog ( FriendsList . this , "feed" , params , </a> 0
<a> new PostDialogListener ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) . setNegativeButton ( R . string . no , null ) . show ( ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> showToast ( "Error: " + e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class PostDialogListener extends BaseDialogListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( Bundle values ) { </a> 0
<a> final String postId = values . getString ( "post_id" ) ; </a> 0
<a> if ( postId != null ) { </a> 0
<a> showToast ( "Message posted on the wall." ) ; </a> 0
<a> } else { </a> 0
<a> showToast ( "No message posted on the wall." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void showToast ( final String msg ) { </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> Toast toast = Toast . makeText ( FriendsList . this , msg , Toast . LENGTH_LONG ) ; </a> 0
<a> toast . show ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> public class FriendListAdapter extends BaseAdapter { </a> 0
<a> private LayoutInflater mInflater ; </a> 0
<a> FriendsList friendsList ; </a> 0
<a> public FriendListAdapter ( FriendsList friendsList ) { </a> 0
<a> this . friendsList = friendsList ; </a> 0
<a> if ( Utility . model == null ) { </a> 0
<a> Utility . model = new FriendsGetProfilePics ( ) ; </a> 0
<a> } </a> 0
<a> Utility . model . setListener ( this ) ; </a> 0
<a> mInflater = LayoutInflater . from ( friendsList . getBaseContext ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getCount ( ) { </a> 0
<a> return jsonArray . length ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object getItem ( int position ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getItemId ( int position ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View getView ( int position , View convertView , ViewGroup parent ) { </a> 0
<a> JSONObject jsonObject = null ; </a> 0
<a> try { </a> 0
<a> jsonObject = jsonArray . getJSONObject ( position ) ; </a> 0
<a> } catch ( JSONException e1 ) { </a> 0
<a> e1 . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> View hView = convertView ; </a> 0
<a> if ( convertView == null ) { </a> 0
<a> hView = mInflater . inflate ( R . layout . friend_item , null ) ; </a> 0
<a> ViewHolder holder = new ViewHolder ( ) ; </a> 0
<a> holder . profile_pic = ( ImageView ) hView . findViewById ( R . id . profile_pic ) ; </a> 0
<a> holder . name = ( TextView ) hView . findViewById ( R . id . name ) ; </a> 0
<a> holder . info = ( TextView ) hView . findViewById ( R . id . info ) ; </a> 0
<a> hView . setTag ( holder ) ; </a> 0
<a> } </a> 0
<a> ViewHolder holder = ( ViewHolder ) hView . getTag ( ) ; </a> 0
<a> try { </a> 0
<a> if ( graph_or_fql . equals ( "graph" ) ) { </a> 0
<a> holder . profile_pic . setImageBitmap ( Utility . model . getImage ( </a> 0
<a> jsonObject . getString ( "id" ) , jsonObject . getString ( "picture" ) ) ) ; </a> 0
<a> } else { </a> 0
<a> holder . profile_pic . setImageBitmap ( Utility . model . getImage ( </a> 0
<a> jsonObject . getString ( "uid" ) , jsonObject . getString ( "pic_square" ) ) ) ; </a> 0
<a> } </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> holder . name . setText ( "" ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> holder . name . setText ( jsonObject . getString ( "name" ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> holder . name . setText ( "" ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> if ( graph_or_fql . equals ( "graph" ) ) { </a> 0
<a> holder . info . setText ( jsonObject . getJSONObject ( "location" ) . getString ( "name" ) ) ; </a> 0
<a> } else { </a> 0
<a> JSONObject location = jsonObject . getJSONObject ( "current_location" ) ; </a> 0
<a> holder . info . setText ( location . getString ( "city" ) + ", " </a> 0
<a> + location . getString ( "state" ) ) ; </a> 0
<a> } </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> holder . info . setText ( "" ) ; </a> 0
<a> } </a> 0
<a> return hView ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> class ViewHolder { </a> 0
<a> ImageView profile_pic ; </a> 0
<a> TextView name ; </a> 0
<a> TextView info ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . app . ProgressDialog ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import android . text . util . Linkify ; </a> 0
<a> import android . text . util . Linkify . TransformFilter ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . View . OnClickListener ; </a> 0
<a> import android . view . inputmethod . InputMethodManager ; </a> 0
<a> import android . widget . * ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . Vector ; </a> 0
<a> import java . util . regex . Matcher ; </a> 0
<a> import java . util . regex . Pattern ; </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public class GraphExplorer extends Activity { </a> 0
<a> private Button mSubmitButton , mViewURLButton ; </a> 0
<a> private Button mGetPermissionsButton ; </a> 0
<a> private Button mTextDeleteButton , mMeButton ; </a> 0
<a> private Button mFieldsConnectionsButton , mBackParentButton ; </a> 0
<a> private TextView mOutput ; </a> 0
<a> private EditText mInputId ; </a> 0
<a> private Bundle params ; </a> 0
<a> private String url , mParentObjectId ; </a> 0
<a> private ProgressDialog dialog ; </a> 0
<a> private String rootString ; </a> 0
<a> private ScrollView mScrollView ; </a> 0
<a> private Handler mHandler ; </a> 0
<a> private final static String BASE_GRAPH_URL = "https://graph.facebook.com" ; </a> 0
<a> private JSONObject metadataObject ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> mHandler = new Handler ( ) ; </a> 0
<a> setContentView ( R . layout . graph_explorer ) ; </a> 0
<a> url = BASE_GRAPH_URL ; </a> 0
<a> mInputId = ( EditText ) findViewById ( R . id . inputId ) ; </a> 0
<a> mOutput = ( TextView ) findViewById ( R . id . output ) ; </a> 0
<a> mSubmitButton = ( Button ) findViewById ( R . id . submitButton ) ; </a> 0
<a> mViewURLButton = ( Button ) findViewById ( R . id . viewURLButton ) ; </a> 0
<a> mGetPermissionsButton = ( Button ) findViewById ( R . id . accessTokenButton ) ; </a> 0
<a> mFieldsConnectionsButton = ( Button ) findViewById ( R . id . fieldsAndConnectionsButton ) ; </a> 0
<a> mBackParentButton = ( Button ) findViewById ( R . id . backParentButton ) ; </a> 0
<a> mScrollView = ( ScrollView ) findViewById ( R . id . ScrollView01 ) ; </a> 0
<a> mTextDeleteButton = ( Button ) findViewById ( R . id . textDeleteButton ) ; </a> 0
<a> mMeButton = ( Button ) findViewById ( R . id . meButton ) ; </a> 0
<a> if ( Utility . mFacebook . isSessionValid ( ) ) { </a> 0
<a> mMeButton . setVisibility ( View . VISIBLE ) ; </a> 0
<a> } </a> 0
<a> params = new Bundle ( ) ; </a> 0
<a> mSubmitButton . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> ( ( InputMethodManager ) getSystemService ( Context . INPUT_METHOD_SERVICE ) ) </a> 0
<a> . hideSoftInputFromWindow ( mInputId . getWindowToken ( ) , 0 ) ; </a> 0
<a> url = BASE_GRAPH_URL ; </a> 0
<a> rootString = mInputId . getText ( ) . toString ( ) ; </a> 0
<a> if ( ! TextUtils . isEmpty ( rootString ) ) { </a> 0
<a> dialog = ProgressDialog . show ( GraphExplorer . this , "" , </a> 0
<a> getString ( R . string . please_wait ) , true , true ) ; </a> 0
<a> params . putString ( "metadata" , "1" ) ; </a> 0
<a> Utility . mAsyncRunner . request ( rootString , params , new graphApiRequestListener ( ) ) ; </a> 0
<a> url += "/" + rootString ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> mViewURLButton . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> setText ( url ) ; </a> 0
<a> Linkify . addLinks ( mOutput , Linkify . WEB_URLS ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> mGetPermissionsButton . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> if ( Utility . mFacebook . isSessionValid ( ) ) { </a> 0
<a> dialog = ProgressDialog . show ( GraphExplorer . this , "" , </a> 0
<a> getString ( R . string . fetching_current_permissions ) , true , true ) ; </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "access_token" , Utility . mFacebook . getAccessToken ( ) ) ; </a> 0
<a> Utility . mAsyncRunner . request ( "me/permissions" , params , </a> 0
<a> new permissionsRequestListener ( ) ) ; </a> 0
<a> } else { </a> 0
<a> new PermissionsDialog ( GraphExplorer . this ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> mFieldsConnectionsButton . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> if ( metadataObject == null ) { </a> 0
<a> makeToast ( "No fields, connections availalbe for this object." ) ; </a> 0
<a> } else { </a> 0
<a> new FieldsConnectionsDialog ( GraphExplorer . this , metadataObject ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> mTextDeleteButton . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> url = BASE_GRAPH_URL ; </a> 0
<a> mParentObjectId = "" ; </a> 0
<a> mInputId . setText ( "" ) ; </a> 0
<a> params . clear ( ) ; </a> 0
<a> metadataObject = null ; </a> 0
<a> setText ( "" ) ; </a> 0
<a> mBackParentButton . setVisibility ( View . INVISIBLE ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> mMeButton . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> mInputId . setText ( "me" ) ; </a> 0
<a> mSubmitButton . performClick ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> mBackParentButton . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> mInputId . setText ( mParentObjectId ) ; </a> 0
<a> mParentObjectId = "" ; </a> 0
<a> mSubmitButton . performClick ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onResume ( ) { </a> 0
<a> super . onResume ( ) ; </a> 0
<a> if ( Utility . mFacebook . isSessionValid ( ) ) { </a> 0
<a> mMeButton . setVisibility ( View . VISIBLE ) ; </a> 0
<a> } </a> 0
<a> if ( Utility . objectID != null ) { </a> 0
<a> mInputId . setText ( Utility . objectID ) ; </a> 0
<a> Utility . objectID = null ; </a> 0
<a> mSubmitButton . performClick ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void processIntent ( Intent incomingIntent ) { </a> 0
<a> Uri intentUri = incomingIntent . getData ( ) ; </a> 0
<a> if ( intentUri == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> String objectID = intentUri . getHost ( ) ; </a> 0
<a> mInputId . setText ( objectID ) ; </a> 0
<a> mSubmitButton . performClick ( ) ; </a> 0
<a> } </a> 0
<a> public void getConnection ( String connection ) { </a> 0
<a> mInputId . setText ( rootString + "/" + connection ) ; </a> 0
<a> mParentObjectId = rootString ; </a> 0
<a> mSubmitButton . performClick ( ) ; </a> 0
<a> } </a> 0
<a> public void getFields ( Vector < String > fieldsVector ) { </a> 0
<a> String fields = "" ; </a> 0
<a> int count = 0 ; </a> 0
<a> for ( String field : fieldsVector ) { </a> 0
<a> fields += field ; </a> 0
<a> if ( ++ count < fieldsVector . size ( ) ) { </a> 0
<a> fields += "," ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> params . putString ( "fields" , fields ) ; </a> 0
<a> mSubmitButton . performClick ( ) ; </a> 0
<a> } </a> 0
<a> public class permissionsRequestListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> Utility . currentPermissions . clear ( ) ; </a> 0
<a> try { </a> 0
<a> JSONObject jsonObject = new JSONObject ( response ) . getJSONArray ( "data" ) </a> 0
<a> . getJSONObject ( 0 ) ; </a> 0
<a> Iterator < ? > iterator = jsonObject . keys ( ) ; </a> 0
<a> String permission ; </a> 0
<a> while ( iterator . hasNext ( ) ) { </a> 0
<a> permission = ( String ) iterator . next ( ) ; </a> 0
<a> Utility . currentPermissions . put ( permission , </a> 0
<a> String . valueOf ( jsonObject . getInt ( permission ) ) ) ; </a> 0
<a> } </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> makeToast ( "Permissions could not be fetched, none will be selected by default." ) ; </a> 0
<a> } </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> new PermissionsDialog ( GraphExplorer . this ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> makeToast ( "Permissions could not be fetched, none will be selected by default." ) ; </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> new PermissionsDialog ( GraphExplorer . this ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> Utility . mFacebook . authorizeCallback ( requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> public class graphApiRequestListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> if ( ! params . isEmpty ( ) ) { </a> 0
<a> url += "?" + Util . encodeUrl ( params ) ; </a> 0
<a> } </a> 0
<a> metadataObject = null ; </a> 0
<a> params . clear ( ) ; </a> 0
<a> try { </a> 0
<a> JSONObject json = Util . parseJson ( response ) ; </a> 0
<a> if ( json . has ( "metadata" ) ) { </a> 0
<a> metadataObject = json . getJSONObject ( "metadata" ) ; </a> 0
<a> json . remove ( "metadata" ) ; </a> 0
<a> } else { </a> 0
<a> metadataObject = null ; </a> 0
<a> } </a> 0
<a> setText ( json . toString ( 2 ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> setText ( e . getMessage ( ) ) ; </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> setText ( e . getMessage ( ) ) ; </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> setText ( error . getMessage ( ) ) ; </a> 0
<a> params . clear ( ) ; </a> 0
<a> metadataObject = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void setText ( final String txt ) { </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> TransformFilter idFilter = new TransformFilter ( ) { </a> 0
<a> @ Override </a> 0
<a> public final String transformUrl ( final Matcher match , String url ) { </a> 0
<a> return match . group ( 1 ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> mViewURLButton . setVisibility ( </a> 0
<a> TextUtils . isEmpty ( txt ) ? View . INVISIBLE : View . VISIBLE ) ; </a> 0
<a> mFieldsConnectionsButton . setVisibility ( TextUtils . isEmpty ( txt ) ? View . INVISIBLE </a> 0
<a> : View . VISIBLE ) ; </a> 0
<a> mOutput . setVisibility ( TextUtils . isEmpty ( txt ) ? View . INVISIBLE : View . VISIBLE ) ; </a> 0
<a> mBackParentButton . setVisibility ( </a> 0
<a> TextUtils . isEmpty ( mParentObjectId ) ? View . INVISIBLE : View . VISIBLE ) ; </a> 0
<a> String convertedTxt = txt . replace ( "\\/" , "/" ) ; </a> 0
<a> mOutput . setText ( convertedTxt ) ; </a> 0
<a> mScrollView . scrollTo ( 0 , 0 ) ; </a> 0
<a> Linkify . addLinks ( mOutput , Linkify . WEB_URLS ) ; </a> 0
<a> Pattern pattern = Pattern . compile ( "\"id\": \"(\\d*_?\\d*)\"" ) ; </a> 0
<a> String scheme = "fbGraphEx://" ; </a> 0
<a> Linkify . addLinks ( mOutput , pattern , scheme , null , idFilter ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private void makeToast ( final String msg ) { </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> Toast . makeText ( GraphExplorer . this , msg , Toast . LENGTH_SHORT ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . app . AlertDialog ; </a> 0
<a> import android . app . ProgressDialog ; </a> 0
<a> import android . content . DialogInterface ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . provider . MediaStore ; </a> 0
<a> import android . view . LayoutInflater ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . widget . * ; </a> 0
<a> import android . widget . AdapterView . OnItemClickListener ; </a> 0
<a> import com . facebook . android . SessionEvents . AuthListener ; </a> 0
<a> import com . facebook . android . SessionEvents . LogoutListener ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public class Hackbook extends Activity implements OnItemClickListener { </a> 0
<a> public static final String APP_ID = "157111564357680" ; </a> 0
<a> private LoginButton mLoginButton ; </a> 0
<a> private TextView mText ; </a> 0
<a> private ImageView mUserPic ; </a> 0
<a> private Handler mHandler ; </a> 0
<a> ProgressDialog dialog ; </a> 0
<a> final static int AUTHORIZE_ACTIVITY_RESULT_CODE = 0 ; </a> 0
<a> final static int PICK_EXISTING_PHOTO_RESULT_CODE = 1 ; </a> 0
<a> private String graph_or_fql ; </a> 0
<a> private ListView list ; </a> 0
<a> String [ ] main_items = { "Update Status" , "App Requests" , "Get Friends" , "Upload Photo" , </a> 0
<a> "Place Check-in" , "Run FQL Query" , "Graph API Explorer" , "Token Refresh" } ; </a> 0
<a> String [ ] permissions = { "offline_access" , "publish_stream" , "user_photos" , "publish_checkins" , </a> 0
<a> "photo_upload" } ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> if ( APP_ID == null ) { </a> 0
<a> Util . showAlert ( this , "Warning" , "Facebook Applicaton ID must be " </a> 0
<a> + "specified before running this example: see FbAPIs.java" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> setContentView ( R . layout . main ) ; </a> 0
<a> mHandler = new Handler ( ) ; </a> 0
<a> mText = ( TextView ) Hackbook . this . findViewById ( R . id . txt ) ; </a> 0
<a> mUserPic = ( ImageView ) Hackbook . this . findViewById ( R . id . user_pic ) ; </a> 0
<a> Utility . mFacebook = new Facebook ( APP_ID ) ; </a> 0
<a> Utility . mAsyncRunner = new AsyncFacebookRunner ( Utility . mFacebook ) ; </a> 0
<a> mLoginButton = ( LoginButton ) findViewById ( R . id . login ) ; </a> 0
<a> SessionStore . restore ( Utility . mFacebook , this ) ; </a> 0
<a> SessionEvents . addAuthListener ( new FbAPIsAuthListener ( ) ) ; </a> 0
<a> SessionEvents . addLogoutListener ( new FbAPIsLogoutListener ( ) ) ; </a> 0
<a> mLoginButton . init ( this , AUTHORIZE_ACTIVITY_RESULT_CODE , Utility . mFacebook , permissions ) ; </a> 0
<a> if ( Utility . mFacebook . isSessionValid ( ) ) { </a> 0
<a> requestUserData ( ) ; </a> 0
<a> } </a> 0
<a> list = ( ListView ) findViewById ( R . id . main_list ) ; </a> 0
<a> list . setOnItemClickListener ( this ) ; </a> 0
<a> list . setAdapter ( new ArrayAdapter < String > ( this , R . layout . main_list_item , main_items ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onResume ( ) { </a> 0
<a> super . onResume ( ) ; </a> 0
<a> if ( Utility . mFacebook != null ) { </a> 0
<a> if ( ! Utility . mFacebook . isSessionValid ( ) ) { </a> 0
<a> mText . setText ( "You are logged out! " ) ; </a> 0
<a> mUserPic . setImageBitmap ( null ) ; </a> 0
<a> } else { </a> 0
<a> Utility . mFacebook . extendAccessTokenIfNeeded ( this , null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> switch ( requestCode ) { </a> 0
<a> case AUTHORIZE_ACTIVITY_RESULT_CODE : { </a> 0
<a> Utility . mFacebook . authorizeCallback ( requestCode , resultCode , data ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case PICK_EXISTING_PHOTO_RESULT_CODE : { </a> 0
<a> if ( resultCode == Activity . RESULT_OK ) { </a> 0
<a> Uri photoUri = data . getData ( ) ; </a> 0
<a> if ( photoUri != null ) { </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> try { </a> 0
<a> params . putByteArray ( "photo" , </a> 0
<a> Utility . scaleImage ( getApplicationContext ( ) , photoUri ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> params . putString ( "caption" , "FbAPIs Sample App photo upload" ) ; </a> 0
<a> Utility . mAsyncRunner . request ( "me/photos" , params , "POST" , </a> 0
<a> new PhotoUploadListener ( ) , null ) ; </a> 0
<a> } else { </a> 0
<a> Toast . makeText ( getApplicationContext ( ) , </a> 0
<a> "Error selecting image from the gallery." , Toast . LENGTH_SHORT ) </a> 0
<a> . show ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> Toast . makeText ( getApplicationContext ( ) , "No image selected for upload." , </a> 0
<a> Toast . LENGTH_SHORT ) . show ( ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onItemClick ( AdapterView < ? > arg0 , View v , int position , long arg3 ) { </a> 0
<a> switch ( position ) { </a> 0
<a> case 0 : { </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "caption" , getString ( R . string . app_name ) ) ; </a> 0
<a> params . putString ( "description" , getString ( R . string . app_desc ) ) ; </a> 0
<a> params . putString ( "picture" , Utility . HACK_ICON_URL ) ; </a> 0
<a> params . putString ( "name" , getString ( R . string . app_action ) ) ; </a> 0
<a> Utility . mFacebook . dialog ( Hackbook . this , "feed" , params , new UpdateStatusListener ( ) ) ; </a> 0
<a> String access_token = Utility . mFacebook . getAccessToken ( ) ; </a> 0
<a> System . out . println ( access_token ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 1 : { </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "message" , getString ( R . string . request_message ) ) ; </a> 0
<a> Utility . mFacebook . dialog ( Hackbook . this , "apprequests" , params , </a> 0
<a> new AppRequestsListener ( ) ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 2 : { </a> 0
<a> if ( ! Utility . mFacebook . isSessionValid ( ) ) { </a> 0
<a> Util . showAlert ( this , "Warning" , "You must first log in." ) ; </a> 0
<a> } else { </a> 0
<a> dialog = ProgressDialog . show ( Hackbook . this , "" , </a> 0
<a> getString ( R . string . please_wait ) , true , true ) ; </a> 0
<a> new AlertDialog . Builder ( this ) </a> 0
<a> . setTitle ( R . string . Graph_FQL_title ) </a> 0
<a> . setMessage ( R . string . Graph_FQL_msg ) </a> 0
<a> . setPositiveButton ( R . string . graph_button , </a> 0
<a> new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialog , int which ) { </a> 0
<a> graph_or_fql = "graph" ; </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "fields" , "name, picture, location" ) ; </a> 0
<a> Utility . mAsyncRunner . request ( "me/friends" , params , </a> 0
<a> new FriendsRequestListener ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) </a> 0
<a> . setNegativeButton ( R . string . fql_button , </a> 0
<a> new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialog , int which ) { </a> 0
<a> graph_or_fql = "fql" ; </a> 0
<a> String query = "select name, current_location, uid, pic_square from user where uid in (select uid2 from friend where uid1=me()) order by name" ; </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "method" , "fql.query" ) ; </a> 0
<a> params . putString ( "query" , query ) ; </a> 0
<a> Utility . mAsyncRunner . request ( null , params , </a> 0
<a> new FriendsRequestListener ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) . setOnCancelListener ( new DialogInterface . OnCancelListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCancel ( DialogInterface d ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> } ) . show ( ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 3 : { </a> 0
<a> if ( ! Utility . mFacebook . isSessionValid ( ) ) { </a> 0
<a> Util . showAlert ( this , "Warning" , "You must first log in." ) ; </a> 0
<a> } else { </a> 0
<a> dialog = ProgressDialog . show ( Hackbook . this , "" , </a> 0
<a> getString ( R . string . please_wait ) , true , true ) ; </a> 0
<a> new AlertDialog . Builder ( this ) </a> 0
<a> . setTitle ( R . string . gallery_remote_title ) </a> 0
<a> . setMessage ( R . string . gallery_remote_msg ) </a> 0
<a> . setPositiveButton ( R . string . gallery_button , </a> 0
<a> new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialog , int which ) { </a> 0
<a> Intent intent = new Intent ( Intent . ACTION_PICK , </a> 0
<a> ( MediaStore . Images . Media . EXTERNAL_CONTENT_URI ) ) ; </a> 0
<a> startActivityForResult ( intent , </a> 0
<a> PICK_EXISTING_PHOTO_RESULT_CODE ) ; </a> 0
<a> } </a> 0
<a> } ) </a> 0
<a> . setNegativeButton ( R . string . remote_button , </a> 0
<a> new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialog , int which ) { </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "url" , </a> 0
<a> "http://www.facebook.com/images/devsite/iphone_connect_btn.jpg" ) ; </a> 0
<a> params . putString ( "caption" , </a> 0
<a> "FbAPIs Sample App photo upload" ) ; </a> 0
<a> Utility . mAsyncRunner . request ( "me/photos" , params , </a> 0
<a> "POST" , new PhotoUploadListener ( ) , null ) ; </a> 0
<a> } </a> 0
<a> } ) . setOnCancelListener ( new DialogInterface . OnCancelListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCancel ( DialogInterface d ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> } ) . show ( ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 4 : { </a> 0
<a> final Intent myIntent = new Intent ( getApplicationContext ( ) , Places . class ) ; </a> 0
<a> new AlertDialog . Builder ( this ) </a> 0
<a> . setTitle ( R . string . get_location ) </a> 0
<a> . setMessage ( R . string . get_default_or_new_location ) </a> 0
<a> . setPositiveButton ( R . string . current_location_button , </a> 0
<a> new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialog , int which ) { </a> 0
<a> myIntent . putExtra ( "LOCATION" , "current" ) ; </a> 0
<a> startActivity ( myIntent ) ; </a> 0
<a> } </a> 0
<a> } ) </a> 0
<a> . setNegativeButton ( R . string . times_square_button , </a> 0
<a> new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialog , int which ) { </a> 0
<a> myIntent . putExtra ( "LOCATION" , "times_square" ) ; </a> 0
<a> startActivity ( myIntent ) ; </a> 0
<a> } </a> 0
<a> } ) . show ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 5 : { </a> 0
<a> if ( ! Utility . mFacebook . isSessionValid ( ) ) { </a> 0
<a> Util . showAlert ( this , "Warning" , "You must first log in." ) ; </a> 0
<a> } else { </a> 0
<a> new FQLQuery ( Hackbook . this ) . show ( ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 6 : { </a> 0
<a> Intent myIntent = new Intent ( getApplicationContext ( ) , GraphExplorer . class ) ; </a> 0
<a> if ( Utility . mFacebook . isSessionValid ( ) ) { </a> 0
<a> Utility . objectID = "me" ; </a> 0
<a> } </a> 0
<a> startActivity ( myIntent ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 7 : { </a> 0
<a> if ( ! Utility . mFacebook . isSessionValid ( ) ) { </a> 0
<a> Util . showAlert ( this , "Warning" , "You must first log in." ) ; </a> 0
<a> } else { </a> 0
<a> new TokenRefreshDialog ( Hackbook . this ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class UpdateStatusListener extends BaseDialogListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( Bundle values ) { </a> 0
<a> final String postId = values . getString ( "post_id" ) ; </a> 0
<a> if ( postId != null ) { </a> 0
<a> new UpdateStatusResultDialog ( Hackbook . this , "Update Status executed" , values ) </a> 0
<a> . show ( ) ; </a> 0
<a> } else { </a> 0
<a> Toast toast = Toast . makeText ( getApplicationContext ( ) , "No wall post made" , </a> 0
<a> Toast . LENGTH_SHORT ) ; </a> 0
<a> toast . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> Toast . makeText ( getApplicationContext ( ) , "Facebook Error: " + error . getMessage ( ) , </a> 0
<a> Toast . LENGTH_SHORT ) . show ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCancel ( ) { </a> 0
<a> Toast toast = Toast . makeText ( getApplicationContext ( ) , "Update status cancelled" , </a> 0
<a> Toast . LENGTH_SHORT ) ; </a> 0
<a> toast . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class AppRequestsListener extends BaseDialogListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( Bundle values ) { </a> 0
<a> Toast toast = Toast . makeText ( getApplicationContext ( ) , "App request sent" , </a> 0
<a> Toast . LENGTH_SHORT ) ; </a> 0
<a> toast . show ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> Toast . makeText ( getApplicationContext ( ) , "Facebook Error: " + error . getMessage ( ) , </a> 0
<a> Toast . LENGTH_SHORT ) . show ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCancel ( ) { </a> 0
<a> Toast toast = Toast . makeText ( getApplicationContext ( ) , "App request cancelled" , </a> 0
<a> Toast . LENGTH_SHORT ) ; </a> 0
<a> toast . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class FriendsRequestListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> Intent myIntent = new Intent ( getApplicationContext ( ) , FriendsList . class ) ; </a> 0
<a> myIntent . putExtra ( "API_RESPONSE" , response ) ; </a> 0
<a> myIntent . putExtra ( "METHOD" , graph_or_fql ) ; </a> 0
<a> startActivity ( myIntent ) ; </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> Toast . makeText ( getApplicationContext ( ) , "Facebook Error: " + error . getMessage ( ) , </a> 0
<a> Toast . LENGTH_SHORT ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class PhotoUploadListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> new UploadPhotoResultDialog ( Hackbook . this , "Upload Photo executed" , response ) </a> 0
<a> . show ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> Toast . makeText ( getApplicationContext ( ) , "Facebook Error: " + error . getMessage ( ) , </a> 0
<a> Toast . LENGTH_LONG ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class FQLRequestListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> Toast . makeText ( getApplicationContext ( ) , "Response: " + response , </a> 0
<a> Toast . LENGTH_LONG ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> Toast . makeText ( getApplicationContext ( ) , "Facebook Error: " + error . getMessage ( ) , </a> 0
<a> Toast . LENGTH_LONG ) . show ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class UserRequestListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> JSONObject jsonObject ; </a> 0
<a> try { </a> 0
<a> jsonObject = new JSONObject ( response ) ; </a> 0
<a> final String picURL = jsonObject . getJSONObject ( "picture" ) </a> 0
<a> . getJSONObject ( "data" ) . getString ( "url" ) ; </a> 0
<a> final String name = jsonObject . getString ( "name" ) ; </a> 0
<a> Utility . userUID = jsonObject . getString ( "id" ) ; </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> mText . setText ( "Welcome " + name + "!" ) ; </a> 0
<a> mUserPic . setImageBitmap ( Utility . getBitmap ( picURL ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class FbAPIsAuthListener implements AuthListener { </a> 0
<a> @ Override </a> 0
<a> public void onAuthSucceed ( ) { </a> 0
<a> requestUserData ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onAuthFail ( String error ) { </a> 0
<a> mText . setText ( "Login Failed: " + error ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class FbAPIsLogoutListener implements LogoutListener { </a> 0
<a> @ Override </a> 0
<a> public void onLogoutBegin ( ) { </a> 0
<a> mText . setText ( "Logging out..." ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onLogoutFinish ( ) { </a> 0
<a> mText . setText ( "You have logged out! " ) ; </a> 0
<a> mUserPic . setImageBitmap ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void requestUserData ( ) { </a> 0
<a> mText . setText ( "Fetching user name, profile pic..." ) ; </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "fields" , "name, picture" ) ; </a> 0
<a> Utility . mAsyncRunner . request ( "me" , params , new UserRequestListener ( ) ) ; </a> 0
<a> } </a> 0
<a> public class MainListAdapter extends BaseAdapter { </a> 0
<a> private LayoutInflater mInflater ; </a> 0
<a> public MainListAdapter ( ) { </a> 0
<a> mInflater = LayoutInflater . from ( Hackbook . this . getBaseContext ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getCount ( ) { </a> 0
<a> return main_items . length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object getItem ( int position ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getItemId ( int position ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View getView ( int position , View convertView , ViewGroup parent ) { </a> 0
<a> View hView = convertView ; </a> 0
<a> if ( convertView == null ) { </a> 0
<a> hView = mInflater . inflate ( R . layout . main_list_item , null ) ; </a> 0
<a> ViewHolder holder = new ViewHolder ( ) ; </a> 0
<a> holder . main_list_item = ( TextView ) hView . findViewById ( R . id . main_api_item ) ; </a> 0
<a> hView . setTag ( holder ) ; </a> 0
<a> } </a> 0
<a> ViewHolder holder = ( ViewHolder ) hView . getTag ( ) ; </a> 0
<a> holder . main_list_item . setText ( main_items [ position ] ) ; </a> 0
<a> return hView ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> class ViewHolder { </a> 0
<a> TextView main_list_item ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> public class IntentUriHandler extends Activity { </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> Intent incomingIntent = getIntent ( ) ; </a> 0
<a> if ( incomingIntent != null ) { </a> 0
<a> Uri intentUri = incomingIntent . getData ( ) ; </a> 0
<a> if ( intentUri != null ) { </a> 0
<a> Utility . objectID = intentUri . getHost ( ) ; </a> 0
<a> Intent graphIntent = new Intent ( getApplicationContext ( ) , GraphExplorer . class ) ; </a> 0
<a> graphIntent . setFlags ( Intent . FLAG_ACTIVITY_REORDER_TO_FRONT ) ; </a> 0
<a> startActivity ( graphIntent ) ; </a> 0
<a> } </a> 0
<a> finish ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . graphics . Color ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . util . AttributeSet ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . widget . ImageButton ; </a> 0
<a> import com . facebook . android . Facebook . DialogListener ; </a> 0
<a> import com . facebook . android . SessionEvents . AuthListener ; </a> 0
<a> import com . facebook . android . SessionEvents . LogoutListener ; </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public class LoginButton extends ImageButton { </a> 0
<a> private Facebook mFb ; </a> 0
<a> private Handler mHandler ; </a> 0
<a> private SessionListener mSessionListener = new SessionListener ( ) ; </a> 0
<a> private String [ ] mPermissions ; </a> 0
<a> private Activity mActivity ; </a> 0
<a> private int mActivityCode ; </a> 0
<a> public LoginButton ( Context context ) { </a> 0
<a> super ( context ) ; </a> 0
<a> } </a> 0
<a> public LoginButton ( Context context , AttributeSet attrs ) { </a> 0
<a> super ( context , attrs ) ; </a> 0
<a> } </a> 0
<a> public LoginButton ( Context context , AttributeSet attrs , int defStyle ) { </a> 0
<a> super ( context , attrs , defStyle ) ; </a> 0
<a> } </a> 0
<a> public void init ( final Activity activity , final int activityCode , final Facebook fb ) { </a> 0
<a> init ( activity , activityCode , fb , new String [ ] { } ) ; </a> 0
<a> } </a> 0
<a> public void init ( final Activity activity , final int activityCode , final Facebook fb , </a> 0
<a> final String [ ] permissions ) { </a> 0
<a> mActivity = activity ; </a> 0
<a> mActivityCode = activityCode ; </a> 0
<a> mFb = fb ; </a> 0
<a> mPermissions = permissions ; </a> 0
<a> mHandler = new Handler ( ) ; </a> 0
<a> setBackgroundColor ( Color . TRANSPARENT ) ; </a> 0
<a> setImageResource ( fb . isSessionValid ( ) ? R . drawable . logout_button : R . drawable . login_button ) ; </a> 0
<a> drawableStateChanged ( ) ; </a> 0
<a> SessionEvents . addAuthListener ( mSessionListener ) ; </a> 0
<a> SessionEvents . addLogoutListener ( mSessionListener ) ; </a> 0
<a> setOnClickListener ( new ButtonOnClickListener ( ) ) ; </a> 0
<a> } </a> 0
<a> private final class ButtonOnClickListener implements OnClickListener { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View arg0 ) { </a> 0
<a> if ( mFb . isSessionValid ( ) ) { </a> 0
<a> SessionEvents . onLogoutBegin ( ) ; </a> 0
<a> AsyncFacebookRunner asyncRunner = new AsyncFacebookRunner ( mFb ) ; </a> 0
<a> asyncRunner . logout ( getContext ( ) , new LogoutRequestListener ( ) ) ; </a> 0
<a> } else { </a> 0
<a> mFb . authorize ( mActivity , mPermissions , mActivityCode , new LoginDialogListener ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final class LoginDialogListener implements DialogListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( Bundle values ) { </a> 0
<a> SessionEvents . onLoginSuccess ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> SessionEvents . onLoginError ( error . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onError ( DialogError error ) { </a> 0
<a> SessionEvents . onLoginError ( error . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCancel ( ) { </a> 0
<a> SessionEvents . onLoginError ( "Action Canceled" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class LogoutRequestListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( String response , final Object state ) { </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> SessionEvents . onLogoutFinish ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class SessionListener implements AuthListener , LogoutListener { </a> 0
<a> @ Override </a> 0
<a> public void onAuthSucceed ( ) { </a> 0
<a> setImageResource ( R . drawable . logout_button ) ; </a> 0
<a> SessionStore . save ( mFb , getContext ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onAuthFail ( String error ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onLogoutBegin ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onLogoutFinish ( ) { </a> 0
<a> SessionStore . clear ( getContext ( ) ) ; </a> 0
<a> setImageResource ( R . drawable . login_button ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . app . Dialog ; </a> 0
<a> import android . graphics . Color ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . text . method . LinkMovementMethod ; </a> 0
<a> import android . view . LayoutInflater ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . view . ViewGroup . LayoutParams ; </a> 0
<a> import android . widget . * ; </a> 0
<a> import android . widget . CompoundButton . OnCheckedChangeListener ; </a> 0
<a> import android . widget . TabHost . TabSpec ; </a> 0
<a> import com . facebook . android . Facebook . DialogListener ; </a> 0
<a> import java . util . Vector ; </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public class PermissionsDialog extends Dialog { </a> 0
<a> private final static int TAB_HEIGHT = 50 ; </a> 0
<a> private Button mGetPermissions ; </a> 0
<a> private TextView mPermissionDetails ; </a> 0
<a> private Activity activity ; </a> 0
<a> private ListView userPermissionsList , friendPermissionsList , extendedPermissionsList ; </a> 0
<a> private BaseAdapter userPermissionsAdapter , friendPermissionsAdapter , </a> 0
<a> extendedPermissionAdapter ; </a> 0
<a> protected Vector < String > reqPermVector ; </a> 0
<a> String [ ] user_permissions = { "user_about_me" , "user_activities" , "user_birthday" , </a> 0
<a> "user_checkins" , "user_education_history" , "user_events" , "user_groups" , </a> 0
<a> "user_hometown" , "user_interests" , "user_likes" , "user_location" , "user_notes" , </a> 0
<a> "user_online_presence" , "user_photos" , "user_photo_video_tags" , "user_relationships" , </a> 0
<a> "user_relationship_details" , "user_religion_politics" , "user_status" , "user_videos" , </a> 0
<a> "user_website" , "user_work_history" } ; </a> 0
<a> String [ ] friend_permissions = { "friends_about_me" , "friends_activities" , "friends_birthday" , </a> 0
<a> "friends_checkins" , "friends_education_history" , "friends_events" , "friends_groups" , </a> 0
<a> "friends_hometown" , "friends_interests" , "friends_likes" , "friends_location" , </a> 0
<a> "friends_notes" , "friends_online_presence" , "friends_photos" , </a> 0
<a> "friends_photo_video_tags" , "friends_relationships" , "friends_relationship_details" , </a> 0
<a> "friends_religion_politics" , "friends_status" , "friends_videos" , "friends_website" , </a> 0
<a> "friends_work_history" } ; </a> 0
<a> String [ ] extended_permissions = { "ads_management" , "create_event" , "create_note" , "email" , </a> 0
<a> "export_stream" , "manage_friendlists" , "manage_groups" , "manage_pages" , </a> 0
<a> "offline_access" , "publish_actions" , "photo_upload" , "publish_checkins" , </a> 0
<a> "publish_stream" , "read_friendlists" , "read_insights" , "read_mailbox" , "read_requests" , </a> 0
<a> "read_stream" , "rsvp_event" , "share_item" , "status_update" , "sms" , "video_upload" , </a> 0
<a> "xmpp_login" } ; </a> 0
<a> public PermissionsDialog ( Activity activity ) { </a> 0
<a> super ( activity ) ; </a> 0
<a> this . activity = activity ; </a> 0
<a> setTitle ( activity . getString ( R . string . permissions_request ) ) ; </a> 0
<a> reqPermVector = new Vector < String > ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . permissions_list ) ; </a> 0
<a> LayoutParams params = getWindow ( ) . getAttributes ( ) ; </a> 0
<a> params . width = LayoutParams . FILL_PARENT ; </a> 0
<a> params . height = LayoutParams . FILL_PARENT ; </a> 0
<a> getWindow ( ) . setAttributes ( ( android . view . WindowManager . LayoutParams ) params ) ; </a> 0
<a> mPermissionDetails = ( TextView ) findViewById ( R . id . permission_detail ) ; </a> 0
<a> mPermissionDetails . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; </a> 0
<a> userPermissionsList = ( ListView ) findViewById ( R . id . user_permissions_list ) ; </a> 0
<a> friendPermissionsList = ( ListView ) findViewById ( R . id . friend_permissions_list ) ; </a> 0
<a> extendedPermissionsList = ( ListView ) findViewById ( R . id . extended_permissions_list ) ; </a> 0
<a> userPermissionsAdapter = new PermissionsListAdapter ( user_permissions ) ; </a> 0
<a> userPermissionsList . setAdapter ( userPermissionsAdapter ) ; </a> 0
<a> friendPermissionsAdapter = new PermissionsListAdapter ( friend_permissions ) ; </a> 0
<a> friendPermissionsList . setAdapter ( friendPermissionsAdapter ) ; </a> 0
<a> extendedPermissionAdapter = new PermissionsListAdapter ( extended_permissions ) ; </a> 0
<a> extendedPermissionsList . setAdapter ( extendedPermissionAdapter ) ; </a> 0
<a> TabHost tabHost = ( TabHost ) findViewById ( R . id . tabHost ) ; </a> 0
<a> tabHost . setup ( ) ; </a> 0
<a> TabSpec spec1 = tabHost . newTabSpec ( "Tab 1" ) ; </a> 0
<a> spec1 . setIndicator ( activity . getString ( R . string . user ) ) ; </a> 0
<a> spec1 . setContent ( R . id . user_permissions_list ) ; </a> 0
<a> TabSpec spec2 = tabHost . newTabSpec ( "Tab 2" ) ; </a> 0
<a> spec2 . setIndicator ( activity . getString ( R . string . friend ) ) ; </a> 0
<a> spec2 . setContent ( R . id . friend_permissions_list ) ; </a> 0
<a> TabSpec spec3 = tabHost . newTabSpec ( "Tab 3" ) ; </a> 0
<a> spec3 . setIndicator ( activity . getString ( R . string . extended ) ) ; </a> 0
<a> spec3 . setContent ( R . id . extended_permissions_list ) ; </a> 0
<a> tabHost . addTab ( spec1 ) ; </a> 0
<a> tabHost . addTab ( spec2 ) ; </a> 0
<a> tabHost . addTab ( spec3 ) ; </a> 0
<a> tabHost . setCurrentTab ( 0 ) ; </a> 0
<a> tabHost . getTabWidget ( ) . getChildAt ( 0 ) . getLayoutParams ( ) . height = TAB_HEIGHT ; </a> 0
<a> tabHost . getTabWidget ( ) . getChildAt ( 1 ) . getLayoutParams ( ) . height = TAB_HEIGHT ; </a> 0
<a> tabHost . getTabWidget ( ) . getChildAt ( 2 ) . getLayoutParams ( ) . height = TAB_HEIGHT ; </a> 0
<a> mGetPermissions = ( Button ) findViewById ( R . id . get_permissions_button ) ; </a> 0
<a> mGetPermissions . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> if ( reqPermVector . isEmpty ( ) && Utility . mFacebook . isSessionValid ( ) ) { </a> 0
<a> Toast . makeText ( activity . getBaseContext ( ) , "No Permissions selected." , </a> 0
<a> Toast . LENGTH_SHORT ) . show ( ) ; </a> 0
<a> PermissionsDialog . this . dismiss ( ) ; </a> 0
<a> } else { </a> 0
<a> String [ ] permissions = reqPermVector . toArray ( new String [ 0 ] ) ; </a> 0
<a> Utility . mFacebook . authorize ( activity , permissions , new LoginDialogListener ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private final class LoginDialogListener implements DialogListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( Bundle values ) { </a> 0
<a> SessionEvents . onLoginSuccess ( ) ; </a> 0
<a> Toast . makeText ( activity . getBaseContext ( ) , "New Permissions granted." , </a> 0
<a> Toast . LENGTH_SHORT ) . show ( ) ; </a> 0
<a> PermissionsDialog . this . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> Toast . makeText ( activity . getBaseContext ( ) , </a> 0
<a> "Facebook Error! No new permissions granted." , Toast . LENGTH_SHORT ) . show ( ) ; </a> 0
<a> PermissionsDialog . this . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onError ( DialogError error ) { </a> 0
<a> Toast . makeText ( activity . getBaseContext ( ) , "Error! No new permissions granted." , </a> 0
<a> Toast . LENGTH_SHORT ) . show ( ) ; </a> 0
<a> PermissionsDialog . this . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCancel ( ) { </a> 0
<a> Toast . makeText ( activity . getBaseContext ( ) , </a> 0
<a> "Action cancelled, No new permissions granted." , Toast . LENGTH_SHORT ) . show ( ) ; </a> 0
<a> PermissionsDialog . this . dismiss ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class PermissionsListAdapter extends BaseAdapter { </a> 0
<a> private LayoutInflater mInflater ; </a> 0
<a> String [ ] permissions ; </a> 0
<a> boolean [ ] isChecked ; </a> 0
<a> public PermissionsListAdapter ( String [ ] permissions ) { </a> 0
<a> this . permissions = permissions ; </a> 0
<a> this . isChecked = new boolean [ permissions . length ] ; </a> 0
<a> mInflater = LayoutInflater . from ( activity . getBaseContext ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getCount ( ) { </a> 0
<a> return permissions . length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object getItem ( int position ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getItemId ( int position ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View getView ( final int position , View convertView , ViewGroup parent ) { </a> 0
<a> View hView = convertView ; </a> 0
<a> CheckBox checkbox ; </a> 0
<a> if ( hView == null ) { </a> 0
<a> hView = mInflater . inflate ( R . layout . permission_item , null ) ; </a> 0
<a> checkbox = ( CheckBox ) hView . findViewById ( R . id . permission_checkbox ) ; </a> 0
<a> hView . setTag ( checkbox ) ; </a> 0
<a> } else { </a> 0
<a> checkbox = ( CheckBox ) hView . getTag ( ) ; </a> 0
<a> } </a> 0
<a> checkbox . setText ( this . permissions [ position ] ) ; </a> 0
<a> checkbox . setId ( position ) ; </a> 0
<a> if ( Utility . currentPermissions . containsKey ( this . permissions [ position ] ) </a> 0
<a> && Utility . currentPermissions . get ( this . permissions [ position ] ) . equals ( "1" ) ) { </a> 0
<a> checkbox . setTextColor ( Color . GREEN ) ; </a> 0
<a> checkbox . setChecked ( true ) ; </a> 0
<a> checkbox . setEnabled ( false ) ; </a> 0
<a> checkbox . setOnCheckedChangeListener ( null ) ; </a> 0
<a> } else { </a> 0
<a> checkbox . setTextColor ( Color . WHITE ) ; </a> 0
<a> checkbox . setChecked ( this . isChecked [ position ] ) ; </a> 0
<a> checkbox . setEnabled ( true ) ; </a> 0
<a> checkbox . setOnCheckedChangeListener ( new OnCheckedChangeListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCheckedChanged ( CompoundButton button , boolean checked ) { </a> 0
<a> isChecked [ button . getId ( ) ] = checked ; </a> 0
<a> if ( checked ) { </a> 0
<a> reqPermVector . add ( button . getText ( ) . toString ( ) ) ; </a> 0
<a> } else if ( reqPermVector . contains ( button . getText ( ) ) ) { </a> 0
<a> reqPermVector . remove ( button . getText ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> return hView ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . app . AlertDialog ; </a> 0
<a> import android . app . ProgressDialog ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . DialogInterface ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . location . Criteria ; </a> 0
<a> import android . location . Location ; </a> 0
<a> import android . location . LocationListener ; </a> 0
<a> import android . location . LocationManager ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . os . Looper ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import android . view . LayoutInflater ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . widget . * ; </a> 0
<a> import android . widget . AdapterView . OnItemClickListener ; </a> 0
<a> import org . json . JSONArray ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public class Places extends Activity implements OnItemClickListener { </a> 0
<a> private Handler mHandler ; </a> 0
<a> private JSONObject location ; </a> 0
<a> protected ListView placesList ; </a> 0
<a> protected LocationManager lm ; </a> 0
<a> protected MyLocationListener locationListener ; </a> 0
<a> protected static JSONArray jsonArray ; </a> 0
<a> final static double TIMES_SQUARE_LAT = 40.756 ; </a> 0
<a> final static double TIMES_SQUARE_LON = - 73.987 ; </a> 0
<a> protected ProgressDialog dialog ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> mHandler = new Handler ( ) ; </a> 0
<a> location = new JSONObject ( ) ; </a> 0
<a> setContentView ( R . layout . places_list ) ; </a> 0
<a> Bundle extras = getIntent ( ) . getExtras ( ) ; </a> 0
<a> String default_or_new = extras . getString ( "LOCATION" ) ; </a> 0
<a> if ( default_or_new . equals ( "times_square" ) ) { </a> 0
<a> try { </a> 0
<a> location . put ( "latitude" , new Double ( TIMES_SQUARE_LAT ) ) ; </a> 0
<a> location . put ( "longitude" , new Double ( TIMES_SQUARE_LON ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> } </a> 0
<a> fetchPlaces ( ) ; </a> 0
<a> } else { </a> 0
<a> getLocation ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void getLocation ( ) { </a> 0
<a> new Thread ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> Looper . prepare ( ) ; </a> 0
<a> dialog = ProgressDialog . show ( Places . this , "" , </a> 0
<a> getString ( R . string . fetching_location ) , false , true , </a> 0
<a> new DialogInterface . OnCancelListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCancel ( DialogInterface dialog ) { </a> 0
<a> showToast ( "No location fetched." ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> if ( lm == null ) { </a> 0
<a> lm = ( LocationManager ) getSystemService ( Context . LOCATION_SERVICE ) ; </a> 0
<a> } </a> 0
<a> if ( locationListener == null ) { </a> 0
<a> locationListener = new MyLocationListener ( ) ; </a> 0
<a> } </a> 0
<a> Criteria criteria = new Criteria ( ) ; </a> 0
<a> criteria . setAccuracy ( Criteria . ACCURACY_COARSE ) ; </a> 0
<a> String provider = lm . getBestProvider ( criteria , true ) ; </a> 0
<a> if ( provider != null && lm . isProviderEnabled ( provider ) ) { </a> 0
<a> lm . requestLocationUpdates ( provider , 1 , 0 , locationListener , </a> 0
<a> Looper . getMainLooper ( ) ) ; </a> 0
<a> } else { </a> 0
<a> new AlertDialog . Builder ( Places . this ) </a> 0
<a> . setTitle ( R . string . enable_gps_title ) </a> 0
<a> . setMessage ( getString ( R . string . enable_gps ) ) </a> 0
<a> . setPositiveButton ( R . string . gps_settings , </a> 0
<a> new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialog , int which ) { </a> 0
<a> startActivityForResult ( </a> 0
<a> new Intent ( </a> 0
<a> android . provider . Settings . ACTION_LOCATION_SOURCE_SETTINGS ) , </a> 0
<a> 0 ) ; </a> 0
<a> } </a> 0
<a> } ) </a> 0
<a> . setNegativeButton ( R . string . cancel , </a> 0
<a> new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialog , int which ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> Places . this . finish ( ) ; </a> 0
<a> } </a> 0
<a> } ) . show ( ) ; </a> 0
<a> } </a> 0
<a> Looper . loop ( ) ; </a> 0
<a> } </a> 0
<a> } . start ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> getLocation ( ) ; </a> 0
<a> } </a> 0
<a> private void fetchPlaces ( ) { </a> 0
<a> if ( ! isFinishing ( ) ) { </a> 0
<a> dialog = ProgressDialog . show ( Places . this , "" , getString ( R . string . nearby_places ) , true , </a> 0
<a> true , new DialogInterface . OnCancelListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCancel ( DialogInterface dialog ) { </a> 0
<a> showToast ( "No places fetched." ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "type" , "place" ) ; </a> 0
<a> try { </a> 0
<a> params . putString ( "center" , </a> 0
<a> location . getString ( "latitude" ) + "," + location . getString ( "longitude" ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> showToast ( "No places fetched." ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> params . putString ( "distance" , "1000" ) ; </a> 0
<a> Utility . mAsyncRunner . request ( "search" , params , new placesRequestListener ( ) ) ; </a> 0
<a> } </a> 0
<a> public class placesRequestListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> Log . d ( "Facebook-FbAPIs" , "Got response: " + response ) ; </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> try { </a> 0
<a> jsonArray = new JSONObject ( response ) . getJSONArray ( "data" ) ; </a> 0
<a> if ( jsonArray == null ) { </a> 0
<a> showToast ( "Error: nearby places could not be fetched" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> showToast ( "Error: " + e . getMessage ( ) ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> placesList = ( ListView ) findViewById ( R . id . places_list ) ; </a> 0
<a> placesList . setOnItemClickListener ( Places . this ) ; </a> 0
<a> placesList . setAdapter ( new PlacesListAdapter ( Places . this ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> showToast ( "Fetch Places Error: " + error . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onItemClick ( AdapterView < ? > arg0 , View v , int position , long arg3 ) { </a> 0
<a> if ( ! Utility . mFacebook . isSessionValid ( ) ) { </a> 0
<a> Util . showAlert ( this , "Warning" , "You must first log in." ) ; </a> 0
<a> } else { </a> 0
<a> try { </a> 0
<a> final String message = "Check-in from the " + getString ( R . string . app_name ) ; </a> 0
<a> final String name = jsonArray . getJSONObject ( position ) . getString ( "name" ) ; </a> 0
<a> final String placeID = jsonArray . getJSONObject ( position ) . getString ( "id" ) ; </a> 0
<a> new AlertDialog . Builder ( this ) . setTitle ( R . string . check_in_title ) </a> 0
<a> . setMessage ( String . format ( getString ( R . string . check_in_at ) , name ) ) </a> 0
<a> . setPositiveButton ( R . string . checkin , new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialog , int which ) { </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "place" , placeID ) ; </a> 0
<a> params . putString ( "message" , message ) ; </a> 0
<a> params . putString ( "coordinates" , location . toString ( ) ) ; </a> 0
<a> Utility . mAsyncRunner . request ( "me/checkins" , params , "POST" , </a> 0
<a> new placesCheckInListener ( ) , null ) ; </a> 0
<a> } </a> 0
<a> } ) . setNegativeButton ( R . string . cancel , null ) . show ( ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> showToast ( "Error: " + e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class placesCheckInListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> showToast ( "API Response: " + response ) ; </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> showToast ( "Check-in Error: " + error . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void showToast ( final String msg ) { </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> Toast toast = Toast . makeText ( Places . this , msg , Toast . LENGTH_LONG ) ; </a> 0
<a> toast . show ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> public class PlacesListAdapter extends BaseAdapter { </a> 0
<a> private LayoutInflater mInflater ; </a> 0
<a> Places placesList ; </a> 0
<a> public PlacesListAdapter ( Context context ) { </a> 0
<a> mInflater = LayoutInflater . from ( context ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getCount ( ) { </a> 0
<a> return jsonArray . length ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object getItem ( int position ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getItemId ( int position ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View getView ( int position , View convertView , ViewGroup parent ) { </a> 0
<a> JSONObject jsonObject = null ; </a> 0
<a> try { </a> 0
<a> jsonObject = jsonArray . getJSONObject ( position ) ; </a> 0
<a> } catch ( JSONException e1 ) { </a> 0
<a> e1 . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> View hView = convertView ; </a> 0
<a> if ( convertView == null ) { </a> 0
<a> hView = mInflater . inflate ( R . layout . place_item , null ) ; </a> 0
<a> ViewHolder holder = new ViewHolder ( ) ; </a> 0
<a> holder . name = ( TextView ) hView . findViewById ( R . id . place_name ) ; </a> 0
<a> holder . location = ( TextView ) hView . findViewById ( R . id . place_location ) ; </a> 0
<a> hView . setTag ( holder ) ; </a> 0
<a> } </a> 0
<a> ViewHolder holder = ( ViewHolder ) hView . getTag ( ) ; </a> 0
<a> try { </a> 0
<a> holder . name . setText ( jsonObject . getString ( "name" ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> holder . name . setText ( "" ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> String location = jsonObject . getJSONObject ( "location" ) . getString ( "street" ) + ", " </a> 0
<a> + jsonObject . getJSONObject ( "location" ) . getString ( "city" ) + ", " </a> 0
<a> + jsonObject . getJSONObject ( "location" ) . getString ( "state" ) ; </a> 0
<a> holder . location . setText ( location ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> holder . location . setText ( "" ) ; </a> 0
<a> } </a> 0
<a> return hView ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> class ViewHolder { </a> 0
<a> TextView name ; </a> 0
<a> TextView location ; </a> 0
<a> } </a> 0
<a> class MyLocationListener implements LocationListener { </a> 0
<a> @ Override </a> 0
<a> public void onLocationChanged ( Location loc ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> if ( loc != null ) { </a> 0
<a> try { </a> 0
<a> location . put ( "latitude" , new Double ( loc . getLatitude ( ) ) ) ; </a> 0
<a> location . put ( "longitude" , new Double ( loc . getLongitude ( ) ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> } </a> 0
<a> showToast ( "Location acquired: " + String . valueOf ( loc . getLatitude ( ) ) + " " </a> 0
<a> + String . valueOf ( loc . getLongitude ( ) ) ) ; </a> 0
<a> lm . removeUpdates ( this ) ; </a> 0
<a> fetchPlaces ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onProviderDisabled ( String provider ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onProviderEnabled ( String provider ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onStatusChanged ( String provider , int status , Bundle extras ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import java . util . LinkedList ; </a> 0
<a> public class SessionEvents { </a> 0
<a> private static LinkedList < AuthListener > mAuthListeners = new LinkedList < AuthListener > ( ) ; </a> 0
<a> private static LinkedList < LogoutListener > mLogoutListeners = new LinkedList < LogoutListener > ( ) ; </a> 0
<a> public static void addAuthListener ( AuthListener listener ) { </a> 0
<a> mAuthListeners . add ( listener ) ; </a> 0
<a> } </a> 0
<a> public static void removeAuthListener ( AuthListener listener ) { </a> 0
<a> mAuthListeners . remove ( listener ) ; </a> 0
<a> } </a> 0
<a> public static void addLogoutListener ( LogoutListener listener ) { </a> 0
<a> mLogoutListeners . add ( listener ) ; </a> 0
<a> } </a> 0
<a> public static void removeLogoutListener ( LogoutListener listener ) { </a> 0
<a> mLogoutListeners . remove ( listener ) ; </a> 0
<a> } </a> 0
<a> public static void onLoginSuccess ( ) { </a> 0
<a> for ( AuthListener listener : mAuthListeners ) { </a> 0
<a> listener . onAuthSucceed ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void onLoginError ( String error ) { </a> 0
<a> for ( AuthListener listener : mAuthListeners ) { </a> 0
<a> listener . onAuthFail ( error ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void onLogoutBegin ( ) { </a> 0
<a> for ( LogoutListener l : mLogoutListeners ) { </a> 0
<a> l . onLogoutBegin ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void onLogoutFinish ( ) { </a> 0
<a> for ( LogoutListener l : mLogoutListeners ) { </a> 0
<a> l . onLogoutFinish ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static interface AuthListener { </a> 0
<a> public void onAuthSucceed ( ) ; </a> 0
<a> public void onAuthFail ( String error ) ; </a> 0
<a> } </a> 0
<a> public static interface LogoutListener { </a> 0
<a> public void onLogoutBegin ( ) ; </a> 0
<a> public void onLogoutFinish ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . app . Dialog ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . text . method . LinkMovementMethod ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> import android . widget . EditText ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> import java . text . DateFormat ; </a> 0
<a> import java . util . Date ; </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public class TokenRefreshDialog extends Dialog { </a> 0
<a> private EditText tokenEdit , tokenExpiresEdit ; </a> 0
<a> private TextView mUsefulTip ; </a> 0
<a> private Button mRefreshButton ; </a> 0
<a> private Activity activity ; </a> 0
<a> public TokenRefreshDialog ( Activity activity ) { </a> 0
<a> super ( activity ) ; </a> 0
<a> this . activity = activity ; </a> 0
<a> setTitle ( R . string . refresh_token_title ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . token_refresh ) ; </a> 0
<a> tokenEdit = ( EditText ) findViewById ( R . id . tokenEdit ) ; </a> 0
<a> tokenEdit . setText ( Utility . mFacebook . getAccessToken ( ) ) ; </a> 0
<a> tokenExpiresEdit = ( EditText ) findViewById ( R . id . tokenExpiresEdit ) ; </a> 0
<a> setExpiresAt ( Utility . mFacebook . getAccessExpires ( ) ) ; </a> 0
<a> mUsefulTip = ( TextView ) findViewById ( R . id . usefulTip ) ; </a> 0
<a> mUsefulTip . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; </a> 0
<a> mRefreshButton = ( Button ) findViewById ( R . id . refresh_button ) ; </a> 0
<a> mRefreshButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> changeButtonState ( false ) ; </a> 0
<a> RefreshTokenListener listener = new RefreshTokenListener ( ) ; </a> 0
<a> if ( ! Utility . mFacebook . extendAccessToken ( activity , listener ) ) { </a> 0
<a> listener . onError ( new Error ( </a> 0
<a> activity . getString ( R . string . refresh_token_binding_error ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private class RefreshTokenListener implements Facebook . ServiceListener { </a> 0
<a> @ Override </a> 0
<a> public void onFacebookError ( FacebookError e ) { </a> 0
<a> changeButtonState ( true ) ; </a> 0
<a> String title = String . format ( activity . getString ( R . string . facebook_error ) + "%d" , </a> 0
<a> e . getErrorCode ( ) ) ; </a> 0
<a> Util . showAlert ( activity , title , e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onError ( Error e ) { </a> 0
<a> changeButtonState ( true ) ; </a> 0
<a> Util . showAlert ( activity , activity . getString ( R . string . error ) , e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( Bundle values ) { </a> 0
<a> changeButtonState ( true ) ; </a> 0
<a> tokenEdit . setText ( values . getString ( Facebook . TOKEN ) ) ; </a> 0
<a> setExpiresAt ( values . getLong ( Facebook . EXPIRES ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void changeButtonState ( boolean enabled ) { </a> 0
<a> mRefreshButton . setEnabled ( enabled ) ; </a> 0
<a> mRefreshButton . setText ( enabled ? R . string . refresh_button : R . string . refresh_button_pending ) ; </a> 0
<a> } </a> 0
<a> private void setExpiresAt ( long time ) { </a> 0
<a> DateFormat dateFormat = DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . SHORT ) ; </a> 0
<a> tokenExpiresEdit . setText ( dateFormat . format ( new Date ( time ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . app . Dialog ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . text . method . LinkMovementMethod ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup . LayoutParams ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public class UpdateStatusResultDialog extends Dialog { </a> 0
<a> private Bundle values ; </a> 0
<a> private TextView mOutput , mUsefulTip ; </a> 0
<a> private Button mViewPostButton , mDeletePostButton ; </a> 0
<a> private Activity activity ; </a> 0
<a> private Handler mHandler ; </a> 0
<a> public UpdateStatusResultDialog ( Activity activity , String title , Bundle values ) { </a> 0
<a> super ( activity ) ; </a> 0
<a> this . activity = activity ; </a> 0
<a> this . values = values ; </a> 0
<a> setTitle ( title ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> mHandler = new Handler ( ) ; </a> 0
<a> setContentView ( R . layout . update_post_response ) ; </a> 0
<a> LayoutParams params = getWindow ( ) . getAttributes ( ) ; </a> 0
<a> params . width = LayoutParams . FILL_PARENT ; </a> 0
<a> params . height = LayoutParams . FILL_PARENT ; </a> 0
<a> getWindow ( ) . setAttributes ( ( android . view . WindowManager . LayoutParams ) params ) ; </a> 0
<a> mOutput = ( TextView ) findViewById ( R . id . apiOutput ) ; </a> 0
<a> mOutput . setText ( values . toString ( ) ) ; </a> 0
<a> mUsefulTip = ( TextView ) findViewById ( R . id . usefulTip ) ; </a> 0
<a> mUsefulTip . setMovementMethod ( LinkMovementMethod . getInstance ( ) ) ; </a> 0
<a> mViewPostButton = ( Button ) findViewById ( R . id . view_post_button ) ; </a> 0
<a> mDeletePostButton = ( Button ) findViewById ( R . id . delete_post_button ) ; </a> 0
<a> final String postId = values . getString ( "post_id" ) ; </a> 0
<a> mViewPostButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> Utility . mAsyncRunner . request ( postId , new WallPostRequestListener ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> mDeletePostButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> Utility . mAsyncRunner . request ( postId , new Bundle ( ) , "DELETE" , </a> 0
<a> new WallPostDeleteListener ( ) , null ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> public class WallPostRequestListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> try { </a> 0
<a> JSONObject json = new JSONObject ( response ) ; </a> 0
<a> setText ( json . toString ( 2 ) ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> setText ( activity . getString ( R . string . exception ) + e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> setText ( activity . getString ( R . string . facebook_error ) + error . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class WallPostDeleteListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> if ( response . equals ( "true" ) ) { </a> 0
<a> String message = "Wall Post deleted" + "\n" ; </a> 0
<a> message += "Api Response: " + response ; </a> 0
<a> setText ( message ) ; </a> 0
<a> } else { </a> 0
<a> setText ( "wall post could not be deleted" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> setText ( activity . getString ( R . string . facebook_error ) + error . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void setText ( final String txt ) { </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> mOutput . setText ( txt ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . app . Dialog ; </a> 0
<a> import android . app . ProgressDialog ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . os . AsyncTask ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . os . Handler ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import android . text . util . Linkify ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup . LayoutParams ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> import android . widget . ImageView ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public class UploadPhotoResultDialog extends Dialog { </a> 0
<a> private String response , photo_id ; </a> 0
<a> private TextView mOutput , mUsefulTip ; </a> 0
<a> private Button mViewPhotoButton , mTagPhotoButton ; </a> 0
<a> private ImageView mUploadedPhoto ; </a> 0
<a> private Activity activity ; </a> 0
<a> private ProgressDialog dialog ; </a> 0
<a> private boolean hidePhoto = false ; </a> 0
<a> private Handler mHandler ; </a> 0
<a> public UploadPhotoResultDialog ( Activity activity , String title , String response ) { </a> 0
<a> super ( activity ) ; </a> 0
<a> this . activity = activity ; </a> 0
<a> this . response = response ; </a> 0
<a> setTitle ( title ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> mHandler = new Handler ( ) ; </a> 0
<a> setContentView ( R . layout . upload_photo_response ) ; </a> 0
<a> LayoutParams params = getWindow ( ) . getAttributes ( ) ; </a> 0
<a> params . width = LayoutParams . FILL_PARENT ; </a> 0
<a> params . height = LayoutParams . FILL_PARENT ; </a> 0
<a> getWindow ( ) . setAttributes ( ( android . view . WindowManager . LayoutParams ) params ) ; </a> 0
<a> mOutput = ( TextView ) findViewById ( R . id . apiOutput ) ; </a> 0
<a> mUsefulTip = ( TextView ) findViewById ( R . id . usefulTip ) ; </a> 0
<a> mViewPhotoButton = ( Button ) findViewById ( R . id . view_photo_button ) ; </a> 0
<a> mTagPhotoButton = ( Button ) findViewById ( R . id . tag_photo_button ) ; </a> 0
<a> mUploadedPhoto = ( ImageView ) findViewById ( R . id . uploadedPhoto ) ; </a> 0
<a> JSONObject json ; </a> 0
<a> try { </a> 0
<a> json = Util . parseJson ( response ) ; </a> 0
<a> final String photo_id = json . getString ( "id" ) ; </a> 0
<a> this . photo_id = photo_id ; </a> 0
<a> mOutput . setText ( json . toString ( 2 ) ) ; </a> 0
<a> mUsefulTip . setText ( activity . getString ( R . string . photo_tip ) ) ; </a> 0
<a> Linkify . addLinks ( mUsefulTip , Linkify . WEB_URLS ) ; </a> 0
<a> mViewPhotoButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> if ( hidePhoto ) { </a> 0
<a> mViewPhotoButton . setText ( R . string . view_photo ) ; </a> 0
<a> hidePhoto = false ; </a> 0
<a> mUploadedPhoto . setImageBitmap ( null ) ; </a> 0
<a> } else { </a> 0
<a> hidePhoto = true ; </a> 0
<a> mViewPhotoButton . setText ( R . string . hide_photo ) ; </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "fields" , "picture" ) ; </a> 0
<a> dialog = ProgressDialog . show ( activity , "" , </a> 0
<a> activity . getString ( R . string . please_wait ) , true , true ) ; </a> 0
<a> dialog . show ( ) ; </a> 0
<a> Utility . mAsyncRunner . request ( photo_id , params , </a> 0
<a> new ViewPhotoRequestListener ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> mTagPhotoButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> setTag ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> setText ( activity . getString ( R . string . exception ) + e . getMessage ( ) ) ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> setText ( activity . getString ( R . string . facebook_error ) + e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void setTag ( ) { </a> 0
<a> String relativePath = photo_id + "/tags/" + Utility . userUID ; </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "x" , "5" ) ; </a> 0
<a> params . putString ( "y" , "5" ) ; </a> 0
<a> Utility . mAsyncRunner . request ( relativePath , params , "POST" , new TagPhotoRequestListener ( ) , </a> 0
<a> null ) ; </a> 0
<a> } </a> 0
<a> public class ViewPhotoRequestListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> try { </a> 0
<a> JSONObject json = Util . parseJson ( response ) ; </a> 0
<a> final String pictureURL = json . getString ( "picture" ) ; </a> 0
<a> if ( TextUtils . isEmpty ( pictureURL ) ) { </a> 0
<a> setText ( "Error getting \'picture\' field of the photo" ) ; </a> 0
<a> } else { </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> new FetchImage ( ) . execute ( pictureURL ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> setText ( activity . getString ( R . string . exception ) + e . getMessage ( ) ) ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> setText ( activity . getString ( R . string . facebook_error ) + e . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> setText ( activity . getString ( R . string . facebook_error ) + error . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class TagPhotoRequestListener extends BaseRequestListener { </a> 0
<a> @ Override </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> if ( response . equals ( "true" ) ) { </a> 0
<a> String message = "User tagged in photo at (5, 5)" + "\n" ; </a> 0
<a> message += "Api Response: " + response ; </a> 0
<a> setText ( message ) ; </a> 0
<a> } else { </a> 0
<a> setText ( "User could not be tagged." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError error ) { </a> 0
<a> setText ( activity . getString ( R . string . facebook_error ) + error . getMessage ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void setText ( final String txt ) { </a> 0
<a> mHandler . post ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> mOutput . setText ( txt ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private class FetchImage extends AsyncTask < String , Void , Bitmap > { </a> 0
<a> @ Override </a> 0
<a> protected Bitmap doInBackground ( String ... urls ) { </a> 0
<a> return Utility . getBitmap ( urls [ 0 ] ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onPostExecute ( Bitmap result ) { </a> 0
<a> dialog . dismiss ( ) ; </a> 0
<a> mUploadedPhoto . setImageBitmap ( result ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android ; </a> 0
<a> import android . app . Application ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . database . Cursor ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . graphics . BitmapFactory ; </a> 0
<a> import android . graphics . Matrix ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . net . http . AndroidHttpClient ; </a> 0
<a> import android . provider . MediaStore ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . io . * ; </a> 0
<a> import java . net . URL ; </a> 0
<a> import java . net . URLConnection ; </a> 0
<a> import java . util . Hashtable ; </a> 0
<a> public class Utility extends Application { </a> 0
<a> public static Facebook mFacebook ; </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public static AsyncFacebookRunner mAsyncRunner ; </a> 0
<a> public static JSONObject mFriendsList ; </a> 0
<a> public static String userUID = null ; </a> 0
<a> public static String objectID = null ; </a> 0
<a> public static FriendsGetProfilePics model ; </a> 0
<a> public static AndroidHttpClient httpclient = null ; </a> 0
<a> public static Hashtable < String , String > currentPermissions = new Hashtable < String , String > ( ) ; </a> 0
<a> private static int MAX_IMAGE_DIMENSION = 720 ; </a> 0
<a> public static final String HACK_ICON_URL = "http://www.facebookmobileweb.com/hackbook/img/facebook_icon_large.png" ; </a> 0
<a> public static Bitmap getBitmap ( String url ) { </a> 0
<a> Bitmap bm = null ; </a> 0
<a> try { </a> 0
<a> URL aURL = new URL ( url ) ; </a> 0
<a> URLConnection conn = aURL . openConnection ( ) ; </a> 0
<a> conn . connect ( ) ; </a> 0
<a> InputStream is = conn . getInputStream ( ) ; </a> 0
<a> BufferedInputStream bis = new BufferedInputStream ( is ) ; </a> 0
<a> bm = BitmapFactory . decodeStream ( new FlushedInputStream ( is ) ) ; </a> 0
<a> bis . close ( ) ; </a> 0
<a> is . close ( ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } finally { </a> 0
<a> if ( httpclient != null ) { </a> 0
<a> httpclient . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return bm ; </a> 0
<a> } </a> 0
<a> static class FlushedInputStream extends FilterInputStream { </a> 0
<a> public FlushedInputStream ( InputStream inputStream ) { </a> 0
<a> super ( inputStream ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long skip ( long n ) throws IOException { </a> 0
<a> long totalBytesSkipped = 0L ; </a> 0
<a> while ( totalBytesSkipped < n ) { </a> 0
<a> long bytesSkipped = in . skip ( n - totalBytesSkipped ) ; </a> 0
<a> if ( bytesSkipped == 0L ) { </a> 0
<a> int b = read ( ) ; </a> 0
<a> if ( b < 0 ) { </a> 0
<a> break ; </a> 0
<a> } else { </a> 0
<a> bytesSkipped = 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> totalBytesSkipped += bytesSkipped ; </a> 0
<a> } </a> 0
<a> return totalBytesSkipped ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static byte [ ] scaleImage ( Context context , Uri photoUri ) throws IOException { </a> 0
<a> InputStream is = context . getContentResolver ( ) . openInputStream ( photoUri ) ; </a> 0
<a> BitmapFactory . Options dbo = new BitmapFactory . Options ( ) ; </a> 0
<a> dbo . inJustDecodeBounds = true ; </a> 0
<a> BitmapFactory . decodeStream ( is , null , dbo ) ; </a> 0
<a> is . close ( ) ; </a> 0
<a> int rotatedWidth , rotatedHeight ; </a> 0
<a> int orientation = getOrientation ( context , photoUri ) ; </a> 0
<a> if ( orientation == 90 || orientation == 270 ) { </a> 0
<a> rotatedWidth = dbo . outHeight ; </a> 0
<a> rotatedHeight = dbo . outWidth ; </a> 0
<a> } else { </a> 0
<a> rotatedWidth = dbo . outWidth ; </a> 0
<a> rotatedHeight = dbo . outHeight ; </a> 0
<a> } </a> 0
<a> Bitmap srcBitmap ; </a> 0
<a> is = context . getContentResolver ( ) . openInputStream ( photoUri ) ; </a> 0
<a> if ( rotatedWidth > MAX_IMAGE_DIMENSION || rotatedHeight > MAX_IMAGE_DIMENSION ) { </a> 0
<a> float widthRatio = ( ( float ) rotatedWidth ) / ( ( float ) MAX_IMAGE_DIMENSION ) ; </a> 0
<a> float heightRatio = ( ( float ) rotatedHeight ) / ( ( float ) MAX_IMAGE_DIMENSION ) ; </a> 0
<a> float maxRatio = Math . max ( widthRatio , heightRatio ) ; </a> 0
<a> BitmapFactory . Options options = new BitmapFactory . Options ( ) ; </a> 0
<a> options . inSampleSize = ( int ) maxRatio ; </a> 0
<a> srcBitmap = BitmapFactory . decodeStream ( is , null , options ) ; </a> 0
<a> } else { </a> 0
<a> srcBitmap = BitmapFactory . decodeStream ( is ) ; </a> 0
<a> } </a> 0
<a> is . close ( ) ; </a> 0
<a> if ( orientation > 0 ) { </a> 0
<a> Matrix matrix = new Matrix ( ) ; </a> 0
<a> matrix . postRotate ( orientation ) ; </a> 0
<a> srcBitmap = Bitmap . createBitmap ( srcBitmap , 0 , 0 , srcBitmap . getWidth ( ) , </a> 0
<a> srcBitmap . getHeight ( ) , matrix , true ) ; </a> 0
<a> } </a> 0
<a> String type = context . getContentResolver ( ) . getType ( photoUri ) ; </a> 0
<a> ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; </a> 0
<a> if ( type . equals ( "image/png" ) ) { </a> 0
<a> srcBitmap . compress ( Bitmap . CompressFormat . PNG , 100 , baos ) ; </a> 0
<a> } else if ( type . equals ( "image/jpg" ) || type . equals ( "image/jpeg" ) ) { </a> 0
<a> srcBitmap . compress ( Bitmap . CompressFormat . JPEG , 100 , baos ) ; </a> 0
<a> } </a> 0
<a> byte [ ] bMapArray = baos . toByteArray ( ) ; </a> 0
<a> baos . close ( ) ; </a> 0
<a> return bMapArray ; </a> 0
<a> } </a> 0
<a> public static int getOrientation ( Context context , Uri photoUri ) { </a> 0
<a> Cursor cursor = context . getContentResolver ( ) . query ( photoUri , </a> 0
<a> new String [ ] { MediaStore . Images . ImageColumns . ORIENTATION } , null , null , null ) ; </a> 0
<a> if ( cursor . getCount ( ) != 1 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> cursor . moveToFirst ( ) ; </a> 0
<a> int orientation = cursor . getInt ( 0 ) ; </a> 0
<a> cursor . close ( ) ; </a> 0
<a> return orientation ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . hellofacebook ; </a> 0
<a> import android . app . AlertDialog ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . graphics . Bitmap ; </a> 0
<a> import android . graphics . BitmapFactory ; </a> 0
<a> import android . location . Location ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> import android . support . v4 . app . FragmentManager ; </a> 0
<a> import android . text . TextUtils ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . model . GraphObject ; </a> 0
<a> import com . facebook . model . GraphPlace ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import com . facebook . widget . * ; </a> 0
<a> import java . util . * ; </a> 0
<a> public class HelloFacebookSampleActivity extends FragmentActivity { </a> 0
<a> private static final List < String > PERMISSIONS = Arrays . asList ( "publish_actions" ) ; </a> 0
<a> private static final Location SEATTLE_LOCATION = new Location ( "" ) { </a> 0
<a> { </a> 0
<a> setLatitude ( 47.6097 ) ; </a> 0
<a> setLongitude ( - 122.3331 ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private final String PENDING_ACTION_BUNDLE_KEY = "com.facebook.samples.hellofacebook:PendingAction" ; </a> 0
<a> private Button postStatusUpdateButton ; </a> 0
<a> private Button postPhotoButton ; </a> 0
<a> private Button pickFriendsButton ; </a> 0
<a> private Button pickPlaceButton ; </a> 0
<a> private LoginButton loginButton ; </a> 0
<a> private ProfilePictureView profilePictureView ; </a> 0
<a> private TextView greeting ; </a> 0
<a> private PendingAction pendingAction = PendingAction . NONE ; </a> 0
<a> private ViewGroup controlsContainer ; </a> 0
<a> private GraphUser user ; </a> 0
<a> private enum PendingAction { </a> 0
<a> NONE , </a> 0
<a> POST_PHOTO , </a> 0
<a> POST_STATUS_UPDATE </a> 0
<a> } </a> 0
<a> private UiLifecycleHelper uiHelper ; </a> 0
<a> private Session . StatusCallback callback = new Session . StatusCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> onSessionStateChange ( session , state , exception ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> uiHelper = new UiLifecycleHelper ( this , callback ) ; </a> 0
<a> uiHelper . onCreate ( savedInstanceState ) ; </a> 0
<a> if ( savedInstanceState != null ) { </a> 0
<a> String name = savedInstanceState . getString ( PENDING_ACTION_BUNDLE_KEY ) ; </a> 0
<a> pendingAction = PendingAction . valueOf ( name ) ; </a> 0
<a> } </a> 0
<a> setContentView ( R . layout . main ) ; </a> 0
<a> loginButton = ( LoginButton ) findViewById ( R . id . login_button ) ; </a> 0
<a> loginButton . setUserInfoChangedCallback ( new LoginButton . UserInfoChangedCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onUserInfoFetched ( GraphUser user ) { </a> 0
<a> HelloFacebookSampleActivity . this . user = user ; </a> 0
<a> updateUI ( ) ; </a> 0
<a> handlePendingAction ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> profilePictureView = ( ProfilePictureView ) findViewById ( R . id . profilePicture ) ; </a> 0
<a> greeting = ( TextView ) findViewById ( R . id . greeting ) ; </a> 0
<a> postStatusUpdateButton = ( Button ) findViewById ( R . id . postStatusUpdateButton ) ; </a> 0
<a> postStatusUpdateButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> onClickPostStatusUpdate ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> postPhotoButton = ( Button ) findViewById ( R . id . postPhotoButton ) ; </a> 0
<a> postPhotoButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> onClickPostPhoto ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> pickFriendsButton = ( Button ) findViewById ( R . id . pickFriendsButton ) ; </a> 0
<a> pickFriendsButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> onClickPickFriends ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> pickPlaceButton = ( Button ) findViewById ( R . id . pickPlaceButton ) ; </a> 0
<a> pickPlaceButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> onClickPickPlace ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> controlsContainer = ( ViewGroup ) findViewById ( R . id . main_ui_container ) ; </a> 0
<a> final FragmentManager fm = getSupportFragmentManager ( ) ; </a> 0
<a> Fragment fragment = fm . findFragmentById ( R . id . fragment_container ) ; </a> 0
<a> if ( fragment != null ) { </a> 0
<a> controlsContainer . setVisibility ( View . GONE ) ; </a> 0
<a> if ( fragment instanceof FriendPickerFragment ) { </a> 0
<a> setFriendPickerListeners ( ( FriendPickerFragment ) fragment ) ; </a> 0
<a> } else if ( fragment instanceof PlacePickerFragment ) { </a> 0
<a> setPlacePickerListeners ( ( PlacePickerFragment ) fragment ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> fm . addOnBackStackChangedListener ( new FragmentManager . OnBackStackChangedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onBackStackChanged ( ) { </a> 0
<a> if ( fm . getBackStackEntryCount ( ) == 0 ) { </a> 0
<a> controlsContainer . setVisibility ( View . VISIBLE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onResume ( ) { </a> 0
<a> super . onResume ( ) ; </a> 0
<a> uiHelper . onResume ( ) ; </a> 0
<a> updateUI ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onSaveInstanceState ( Bundle outState ) { </a> 0
<a> super . onSaveInstanceState ( outState ) ; </a> 0
<a> uiHelper . onSaveInstanceState ( outState ) ; </a> 0
<a> outState . putString ( PENDING_ACTION_BUNDLE_KEY , pendingAction . name ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> super . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> uiHelper . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onPause ( ) { </a> 0
<a> super . onPause ( ) ; </a> 0
<a> uiHelper . onPause ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDestroy ( ) { </a> 0
<a> super . onDestroy ( ) ; </a> 0
<a> uiHelper . onDestroy ( ) ; </a> 0
<a> } </a> 0
<a> private void onSessionStateChange ( Session session , SessionState state , Exception exception ) { </a> 0
<a> if ( pendingAction != PendingAction . NONE && </a> 0
<a> ( exception instanceof FacebookOperationCanceledException || </a> 0
<a> exception instanceof FacebookAuthorizationException ) ) { </a> 0
<a> new AlertDialog . Builder ( HelloFacebookSampleActivity . this ) </a> 0
<a> . setTitle ( R . string . cancelled ) </a> 0
<a> . setMessage ( R . string . permission_not_granted ) </a> 0
<a> . setPositiveButton ( R . string . ok , null ) </a> 0
<a> . show ( ) ; </a> 0
<a> pendingAction = PendingAction . NONE ; </a> 0
<a> } else if ( state == SessionState . OPENED_TOKEN_UPDATED ) { </a> 0
<a> handlePendingAction ( ) ; </a> 0
<a> } </a> 0
<a> updateUI ( ) ; </a> 0
<a> } </a> 0
<a> private void updateUI ( ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> boolean enableButtons = ( session != null && session . isOpened ( ) ) ; </a> 0
<a> postStatusUpdateButton . setEnabled ( enableButtons ) ; </a> 0
<a> postPhotoButton . setEnabled ( enableButtons ) ; </a> 0
<a> pickFriendsButton . setEnabled ( enableButtons ) ; </a> 0
<a> pickPlaceButton . setEnabled ( enableButtons ) ; </a> 0
<a> if ( enableButtons && user != null ) { </a> 0
<a> profilePictureView . setProfileId ( user . getId ( ) ) ; </a> 0
<a> greeting . setText ( getString ( R . string . hello_user , user . getFirstName ( ) ) ) ; </a> 0
<a> } else { </a> 0
<a> profilePictureView . setProfileId ( null ) ; </a> 0
<a> greeting . setText ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "incomplete-switch" ) </a> 0
<a> private void handlePendingAction ( ) { </a> 0
<a> PendingAction previouslyPendingAction = pendingAction ; </a> 0
<a> pendingAction = PendingAction . NONE ; </a> 0
<a> switch ( previouslyPendingAction ) { </a> 0
<a> case POST_PHOTO : </a> 0
<a> postPhoto ( ) ; </a> 0
<a> break ; </a> 0
<a> case POST_STATUS_UPDATE : </a> 0
<a> postStatusUpdate ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private interface GraphObjectWithId extends GraphObject { </a> 0
<a> String getId ( ) ; </a> 0
<a> } </a> 0
<a> private void showPublishResult ( String message , GraphObject result , FacebookRequestError error ) { </a> 0
<a> String title = null ; </a> 0
<a> String alertMessage = null ; </a> 0
<a> if ( error == null ) { </a> 0
<a> title = getString ( R . string . success ) ; </a> 0
<a> String id = result . cast ( GraphObjectWithId . class ) . getId ( ) ; </a> 0
<a> alertMessage = getString ( R . string . successfully_posted_post , message , id ) ; </a> 0
<a> } else { </a> 0
<a> title = getString ( R . string . error ) ; </a> 0
<a> alertMessage = error . getErrorMessage ( ) ; </a> 0
<a> } </a> 0
<a> new AlertDialog . Builder ( this ) </a> 0
<a> . setTitle ( title ) </a> 0
<a> . setMessage ( alertMessage ) </a> 0
<a> . setPositiveButton ( R . string . ok , null ) </a> 0
<a> . show ( ) ; </a> 0
<a> } </a> 0
<a> private void onClickPostStatusUpdate ( ) { </a> 0
<a> performPublish ( PendingAction . POST_STATUS_UPDATE ) ; </a> 0
<a> } </a> 0
<a> private void postStatusUpdate ( ) { </a> 0
<a> if ( user != null && hasPublishPermission ( ) ) { </a> 0
<a> final String message = getString ( R . string . status_update , user . getFirstName ( ) , ( new Date ( ) . toString ( ) ) ) ; </a> 0
<a> Request request = Request </a> 0
<a> . newStatusUpdateRequest ( Session . getActiveSession ( ) , message , new Request . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> showPublishResult ( message , response . getGraphObject ( ) , response . getError ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> request . executeAsync ( ) ; </a> 0
<a> } else { </a> 0
<a> pendingAction = PendingAction . POST_STATUS_UPDATE ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onClickPostPhoto ( ) { </a> 0
<a> performPublish ( PendingAction . POST_PHOTO ) ; </a> 0
<a> } </a> 0
<a> private void postPhoto ( ) { </a> 0
<a> if ( hasPublishPermission ( ) ) { </a> 0
<a> Bitmap image = BitmapFactory . decodeResource ( this . getResources ( ) , R . drawable . icon ) ; </a> 0
<a> Request request = Request . newUploadPhotoRequest ( Session . getActiveSession ( ) , image , new Request . Callback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( Response response ) { </a> 0
<a> showPublishResult ( getString ( R . string . photo_post ) , response . getGraphObject ( ) , response . getError ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> request . executeAsync ( ) ; </a> 0
<a> } else { </a> 0
<a> pendingAction = PendingAction . POST_PHOTO ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void showPickerFragment ( PickerFragment < ? > fragment ) { </a> 0
<a> fragment . setOnErrorListener ( new PickerFragment . OnErrorListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onError ( PickerFragment < ? > pickerFragment , FacebookException error ) { </a> 0
<a> showAlert ( getString ( R . string . error ) , error . getMessage ( ) ) ; </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> FragmentManager fm = getSupportFragmentManager ( ) ; </a> 0
<a> fm . beginTransaction ( ) </a> 0
<a> . replace ( R . id . fragment_container , fragment ) </a> 0
<a> . addToBackStack ( null ) </a> 0
<a> . commit ( ) ; </a> 0
<a> controlsContainer . setVisibility ( View . GONE ) ; </a> 0
<a> fm . executePendingTransactions ( ) ; </a> 0
<a> fragment . loadData ( false ) ; </a> 0
<a> } </a> 0
<a> private void onClickPickFriends ( ) { </a> 0
<a> final FriendPickerFragment fragment = new FriendPickerFragment ( ) ; </a> 0
<a> setFriendPickerListeners ( fragment ) ; </a> 0
<a> showPickerFragment ( fragment ) ; </a> 0
<a> } </a> 0
<a> private void setFriendPickerListeners ( final FriendPickerFragment fragment ) { </a> 0
<a> fragment . setOnDoneButtonClickedListener ( new FriendPickerFragment . OnDoneButtonClickedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onDoneButtonClicked ( PickerFragment < ? > pickerFragment ) { </a> 0
<a> onFriendPickerDone ( fragment ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private void onFriendPickerDone ( FriendPickerFragment fragment ) { </a> 0
<a> FragmentManager fm = getSupportFragmentManager ( ) ; </a> 0
<a> fm . popBackStack ( ) ; </a> 0
<a> String results = "" ; </a> 0
<a> Collection < GraphUser > selection = fragment . getSelection ( ) ; </a> 0
<a> if ( selection != null && selection . size ( ) > 0 ) { </a> 0
<a> ArrayList < String > names = new ArrayList < String > ( ) ; </a> 0
<a> for ( GraphUser user : selection ) { </a> 0
<a> names . add ( user . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> results = TextUtils . join ( ", " , names ) ; </a> 0
<a> } else { </a> 0
<a> results = getString ( R . string . no_friends_selected ) ; </a> 0
<a> } </a> 0
<a> showAlert ( getString ( R . string . you_picked ) , results ) ; </a> 0
<a> } </a> 0
<a> private void onPlacePickerDone ( PlacePickerFragment fragment ) { </a> 0
<a> FragmentManager fm = getSupportFragmentManager ( ) ; </a> 0
<a> fm . popBackStack ( ) ; </a> 0
<a> String result = "" ; </a> 0
<a> GraphPlace selection = fragment . getSelection ( ) ; </a> 0
<a> if ( selection != null ) { </a> 0
<a> result = selection . getName ( ) ; </a> 0
<a> } else { </a> 0
<a> result = getString ( R . string . no_place_selected ) ; </a> 0
<a> } </a> 0
<a> showAlert ( getString ( R . string . you_picked ) , result ) ; </a> 0
<a> } </a> 0
<a> private void onClickPickPlace ( ) { </a> 0
<a> final PlacePickerFragment fragment = new PlacePickerFragment ( ) ; </a> 0
<a> fragment . setLocation ( SEATTLE_LOCATION ) ; </a> 0
<a> fragment . setTitleText ( getString ( R . string . pick_seattle_place ) ) ; </a> 0
<a> setPlacePickerListeners ( fragment ) ; </a> 0
<a> showPickerFragment ( fragment ) ; </a> 0
<a> } </a> 0
<a> private void setPlacePickerListeners ( final PlacePickerFragment fragment ) { </a> 0
<a> fragment . setOnDoneButtonClickedListener ( new PlacePickerFragment . OnDoneButtonClickedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onDoneButtonClicked ( PickerFragment < ? > pickerFragment ) { </a> 0
<a> onPlacePickerDone ( fragment ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> fragment . setOnSelectionChangedListener ( new PlacePickerFragment . OnSelectionChangedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onSelectionChanged ( PickerFragment < ? > pickerFragment ) { </a> 0
<a> if ( fragment . getSelection ( ) != null ) { </a> 0
<a> onPlacePickerDone ( fragment ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private void showAlert ( String title , String message ) { </a> 0
<a> new AlertDialog . Builder ( this ) </a> 0
<a> . setTitle ( title ) </a> 0
<a> . setMessage ( message ) </a> 0
<a> . setPositiveButton ( R . string . ok , null ) </a> 0
<a> . show ( ) ; </a> 0
<a> } </a> 0
<a> private boolean hasPublishPermission ( ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> return session != null && session . getPermissions ( ) . contains ( "publish_actions" ) ; </a> 0
<a> } </a> 0
<a> private void performPublish ( PendingAction action ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session != null ) { </a> 0
<a> pendingAction = action ; </a> 0
<a> if ( hasPublishPermission ( ) ) { </a> 0
<a> handlePendingAction ( ) ; </a> 0
<a> } else { </a> 0
<a> session . requestNewPublishPermissions ( new Session . NewPermissionsRequest ( this , PERMISSIONS ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . placepicker ; </a> 0
<a> import android . app . AlertDialog ; </a> 1
<a> import android . content . Intent ; </a> 0
<a> import android . location . Location ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> import android . support . v4 . app . FragmentManager ; </a> 0
<a> import com . facebook . FacebookException ; </a> 0
<a> import com . facebook . widget . PickerFragment ; </a> 0
<a> import com . facebook . widget . PlacePickerFragment ; </a> 0
<a> public class PickPlaceActivity extends FragmentActivity { </a> 0
<a> PlacePickerFragment placePickerFragment ; </a> 0
<a> public static void populateParameters ( Intent intent , Location location , String searchText ) { </a> 0
<a> intent . putExtra ( PlacePickerFragment . LOCATION_BUNDLE_KEY , location ) ; </a> 0
<a> intent . putExtra ( PlacePickerFragment . SEARCH_TEXT_BUNDLE_KEY , searchText ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . pick_place_activity ) ; </a> 0
<a> FragmentManager fm = getSupportFragmentManager ( ) ; </a> 0
<a> placePickerFragment = ( PlacePickerFragment ) fm . findFragmentById ( R . id . place_picker_fragment ) ; </a> 0
<a> if ( savedInstanceState == null ) { </a> 0
<a> placePickerFragment . setSettingsFromBundle ( getIntent ( ) . getExtras ( ) ) ; </a> 0
<a> } </a> 0
<a> placePickerFragment . setOnErrorListener ( new PickerFragment . OnErrorListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onError ( PickerFragment < ? > fragment , FacebookException error ) { </a> 0
<a> PickPlaceActivity . this . onError ( error ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> placePickerFragment . setOnSelectionChangedListener ( new PickerFragment . OnSelectionChangedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onSelectionChanged ( PickerFragment < ? > fragment ) { </a> 0
<a> if ( placePickerFragment . getSelection ( ) != null ) { </a> 0
<a> finishActivity ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> placePickerFragment . setOnDoneButtonClickedListener ( new PickerFragment . OnDoneButtonClickedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onDoneButtonClicked ( PickerFragment < ? > fragment ) { </a> 0
<a> finishActivity ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private void finishActivity ( ) { </a> 0
<a> PlacePickerApplication application = ( PlacePickerApplication ) getApplication ( ) ; </a> 0
<a> application . setSelectedPlace ( placePickerFragment . getSelection ( ) ) ; </a> 0
<a> setResult ( RESULT_OK , null ) ; </a> 0
<a> finish ( ) ; </a> 0
<a> } </a> 0
<a> private void onError ( Exception error ) { </a> 0
<a> new AlertDialog . Builder ( this ) </a> 1
<a> . setTitle ( R . string . error_dialog_title ) </a> 1
<a> . setMessage ( error . getMessage ( ) ) </a> 1
<a> . setPositiveButton ( R . string . ok_button , null ) </a> 1
<a> . show ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onStart ( ) { </a> 0
<a> super . onStart ( ) ; </a> 0
<a> try { </a> 0
<a> placePickerFragment . loadData ( false ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> onError ( ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . placepicker ; </a> 0
<a> import android . app . Application ; </a> 0
<a> import com . facebook . model . GraphPlace ; </a> 0
<a> public class PlacePickerApplication extends Application { </a> 0
<a> public GraphPlace getSelectedPlace ( ) { </a> 0
<a> return selectedPlace ; </a> 0
<a> } </a> 0
<a> public void setSelectedPlace ( GraphPlace selectedPlace ) { </a> 0
<a> this . selectedPlace = selectedPlace ; </a> 0
<a> } </a> 0
<a> private GraphPlace selectedPlace ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . placepicker ; </a> 0
<a> import android . app . AlertDialog ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . location . Criteria ; </a> 0
<a> import android . location . Location ; </a> 0
<a> import android . location . LocationListener ; </a> 0
<a> import android . location . LocationManager ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> import com . facebook . model . GraphLocation ; </a> 0
<a> import com . facebook . model . GraphPlace ; </a> 0
<a> import com . facebook . Session ; </a> 0
<a> public class PlacePickerSampleActivity extends FragmentActivity implements LocationListener { </a> 0
<a> private static final int PLACE_ACTIVITY = 1 ; </a> 0
<a> private static final Location SEATTLE_LOCATION = new Location ( "" ) { </a> 0
<a> { </a> 0
<a> setLatitude ( 47.6097 ) ; </a> 0
<a> setLongitude ( - 122.3331 ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private static final Location SAN_FRANCISCO_LOCATION = new Location ( "" ) { </a> 0
<a> { </a> 0
<a> setLatitude ( 37.7750 ) ; </a> 0
<a> setLongitude ( - 122.4183 ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private static final Location PARIS_LOCATION = new Location ( "" ) { </a> 0
<a> { </a> 0
<a> setLatitude ( 48.857875 ) ; </a> 0
<a> setLongitude ( 2.294635 ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private TextView resultsTextView ; </a> 0
<a> private LocationManager locationManager ; </a> 0
<a> private Location lastKnownLocation ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . main ) ; </a> 0
<a> resultsTextView = ( TextView ) findViewById ( R . id . resultsTextView ) ; </a> 0
<a> Button button = ( Button ) findViewById ( R . id . seattleButton ) ; </a> 0
<a> button . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> onClickSeattle ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> button = ( Button ) findViewById ( R . id . sanFranciscoButton ) ; </a> 0
<a> button . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> onClickSanFrancisco ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> button = ( Button ) findViewById ( R . id . gpsButton ) ; </a> 0
<a> button . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> onClickGPS ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> if ( Session . getActiveSession ( ) == null || </a> 1
<a> Session . getActiveSession ( ) . isClosed ( ) ) { </a> 1
<a> Session . openActiveSession ( this , true , null ) ; </a> 1
<a> } </a> 0
<a> locationManager = ( LocationManager ) getSystemService ( Context . LOCATION_SERVICE ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onStart ( ) { </a> 0
<a> super . onStart ( ) ; </a> 0
<a> displaySelectedPlace ( RESULT_OK ) ; </a> 0
<a> } </a> 0
<a> private void onError ( Exception exception ) { </a> 0
<a> AlertDialog . Builder builder = new AlertDialog . Builder ( this ) ; </a> 0
<a> builder . setTitle ( "Error" ) . setMessage ( exception . getMessage ( ) ) . setPositiveButton ( "OK" , null ) ; </a> 0
<a> builder . show ( ) ; </a> 0
<a> } </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> switch ( requestCode ) { </a> 0
<a> case PLACE_ACTIVITY : </a> 0
<a> displaySelectedPlace ( resultCode ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> Session . getActiveSession ( ) . onActivityResult ( this , requestCode , resultCode , data ) ; </a> 1
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void displaySelectedPlace ( int resultCode ) { </a> 0
<a> String results = "" ; </a> 0
<a> PlacePickerApplication application = ( PlacePickerApplication ) getApplication ( ) ; </a> 0
<a> GraphPlace selection = application . getSelectedPlace ( ) ; </a> 0
<a> if ( selection != null ) { </a> 0
<a> GraphLocation location = selection . getLocation ( ) ; </a> 0
<a> results = String . format ( "Name: %s\nCategory: %s\nLocation: (%f,%f)\nStreet: %s, %s, %s, %s, %s" , </a> 0
<a> selection . getName ( ) , selection . getCategory ( ) , </a> 0
<a> location . getLatitude ( ) , location . getLongitude ( ) , </a> 0
<a> location . getStreet ( ) , location . getCity ( ) , location . getState ( ) , location . getZip ( ) , </a> 0
<a> location . getCountry ( ) ) ; </a> 0
<a> } else { </a> 0
<a> results = "<No place selected>" ; </a> 0
<a> } </a> 0
<a> resultsTextView . setText ( results ) ; </a> 0
<a> } </a> 0
<a> public void onLocationChanged ( Location location ) { </a> 0
<a> lastKnownLocation = location ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onStatusChanged ( String provider , int status , Bundle extras ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onProviderEnabled ( String provider ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onProviderDisabled ( String provider ) { </a> 0
<a> } </a> 0
<a> private void startPickPlaceActivity ( Location location ) { </a> 0
<a> PlacePickerApplication application = ( PlacePickerApplication ) getApplication ( ) ; </a> 0
<a> application . setSelectedPlace ( null ) ; </a> 0
<a> Intent intent = new Intent ( this , PickPlaceActivity . class ) ; </a> 0
<a> PickPlaceActivity . populateParameters ( intent , location , null ) ; </a> 0
<a> startActivityForResult ( intent , PLACE_ACTIVITY ) ; </a> 0
<a> } </a> 0
<a> private void onClickSeattle ( ) { </a> 0
<a> try { </a> 0
<a> startPickPlaceActivity ( SEATTLE_LOCATION ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> onError ( ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onClickSanFrancisco ( ) { </a> 0
<a> try { </a> 0
<a> startPickPlaceActivity ( SAN_FRANCISCO_LOCATION ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> onError ( ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onClickGPS ( ) { </a> 0
<a> try { </a> 0
<a> if ( lastKnownLocation == null ) { </a> 0
<a> Criteria criteria = new Criteria ( ) ; </a> 0
<a> String bestProvider = locationManager . getBestProvider ( criteria , false ) ; </a> 0
<a> if ( bestProvider != null ) { </a> 0
<a> lastKnownLocation = locationManager . getLastKnownLocation ( bestProvider ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( lastKnownLocation == null ) { </a> 0
<a> String model = android . os . Build . MODEL ; </a> 0
<a> if ( model . equals ( "sdk" ) || model . equals ( "google_sdk" ) || model . contains ( "x86" ) ) { </a> 0
<a> lastKnownLocation = PARIS_LOCATION ; </a> 0
<a> } else { </a> 0
<a> new AlertDialog . Builder ( this ) </a> 1
<a> . setTitle ( R . string . error_dialog_title ) </a> 1
<a> . setMessage ( R . string . no_location ) </a> 1
<a> . setPositiveButton ( R . string . ok_button , null ) </a> 1
<a> . show ( ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> startPickPlaceActivity ( lastKnownLocation ) ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> onError ( ex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . profilepicture ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> public class ProfilePictureSampleActivity extends FragmentActivity { </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . activity_profile_picture_sample ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . profilepicture ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . view . LayoutInflater ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . widget . * ; </a> 0
<a> import com . facebook . widget . ProfilePictureView ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . Random ; </a> 0
<a> public class ProfilePictureSampleFragment extends Fragment { </a> 0
<a> private static final int MAX_CUSTOM_SIZES = 6 ; </a> 0
<a> private static final int DEFAULT_SIZE_INCREMENT = MAX_CUSTOM_SIZES / 2 ; </a> 0
<a> private static final String PICTURE_SIZE_TYPE_KEY = "PictureSizeType" ; </a> 0
<a> private static final String [ ] INTERESTING_IDS = { </a> 0
<a> "zuck" , </a> 0
<a> "barackobama" , </a> 0
<a> "mittromney" , </a> 0
<a> "johnmccain" , </a> 0
<a> "johnkerry" , </a> 0
<a> "georgewbush" , </a> 0
<a> "algore" , </a> 0
<a> "Disneyland" , </a> 0
<a> "SpaceNeedle" , </a> 0
<a> "TourEiffel" , </a> 0
<a> "sydneyoperahouse" , </a> 0
<a> "166020963458360" , </a> 0
<a> "108084865880237" , </a> 0
<a> "140447466087679" , </a> 0
<a> "111825495501392" , </a> 0
<a> "108168249210849" , </a> 0
<a> "TiffaniThiessen" , </a> 0
<a> "108126672542534" , </a> 0
<a> "112886105391693" , </a> 0
<a> "MarioLopezExtra" , </a> 0
<a> "108504145837165" , </a> 0
<a> "dennishaskins" , </a> 0
<a> "7220821999" , </a> 0
<a> "31938132882" , </a> 0
<a> "108023262558391" , </a> 0
<a> "209263392372" , </a> 0
<a> "104132506290482" , </a> 0
<a> "9721897972" , </a> 0
<a> "5461947317" , </a> 0
<a> "57084011597" , </a> 0
<a> "24408579964" , </a> 0
<a> "111980872152571" , </a> 0
<a> "112427772106500" , </a> 0
<a> "113415525338717" , </a> 0
<a> "105628452803615" , </a> 0
<a> "105533779480538" , </a> 0
<a> } ; </a> 0
<a> private int pictureSizeType = ProfilePictureView . CUSTOM ; </a> 0
<a> private String firstUserId ; </a> 0
<a> private Random randomGenerator ; </a> 0
<a> private ProfilePictureView profilePic ; </a> 0
<a> private Button smallerButton ; </a> 0
<a> private Button largerButton ; </a> 0
<a> private TextView sizeLabel ; </a> 0
<a> private View presetSizeView ; </a> 0
<a> private SeekBar customSizeView ; </a> 0
<a> private CheckBox cropToggle ; </a> 0
<a> @ Override </a> 0
<a> public View onCreateView ( LayoutInflater inflater , ViewGroup parent , Bundle savedInstanceState ) { </a> 0
<a> View fragmentView = inflater . inflate ( R . layout . fragment_profile_picture_sample , parent , false ) ; </a> 0
<a> randomGenerator = new Random ( ( new Date ( ) ) . getTime ( ) ) ; </a> 0
<a> profilePic = ( ProfilePictureView ) fragmentView . findViewById ( R . id . profilepic ) ; </a> 0
<a> smallerButton = ( Button ) fragmentView . findViewById ( R . id . smallerButton ) ; </a> 0
<a> largerButton = ( Button ) fragmentView . findViewById ( R . id . largerButton ) ; </a> 0
<a> sizeLabel = ( TextView ) fragmentView . findViewById ( R . id . sizeLabel ) ; </a> 0
<a> presetSizeView = fragmentView . findViewById ( R . id . presetSizeView ) ; </a> 0
<a> customSizeView = ( SeekBar ) fragmentView . findViewById ( R . id . customSizeView ) ; </a> 0
<a> cropToggle = ( CheckBox ) fragmentView . findViewById ( R . id . squareCropToggle ) ; </a> 0
<a> LinearLayout container = ( LinearLayout ) fragmentView . findViewById ( R . id . userbuttoncontainer ) ; </a> 0
<a> int numChildren = container . getChildCount ( ) ; </a> 0
<a> for ( int i = 0 ; i < numChildren ; i ++ ) { </a> 0
<a> View childView = container . getChildAt ( i ) ; </a> 0
<a> Object tag = childView . getTag ( ) ; </a> 0
<a> if ( childView instanceof Button ) { </a> 0
<a> setupUserButton ( ( Button ) childView ) ; </a> 0
<a> if ( i == 0 ) { </a> 0
<a> firstUserId = tag . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> cropToggle . setOnCheckedChangeListener ( new CheckBox . OnCheckedChangeListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCheckedChanged ( CompoundButton checkbox , boolean checked ) { </a> 0
<a> profilePic . setCropped ( checked ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> final Button sizeToggle = ( Button ) fragmentView . findViewById ( R . id . sizeToggle ) ; </a> 0
<a> sizeToggle . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> if ( pictureSizeType != ProfilePictureView . CUSTOM ) { </a> 0
<a> sizeToggle . setText ( R . string . preset_size_button_text ) ; </a> 0
<a> switchToCustomSize ( ) ; </a> 0
<a> } else { </a> 0
<a> sizeToggle . setText ( R . string . custom_size_button_text ) ; </a> 0
<a> switchToPresetSize ( ProfilePictureView . LARGE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> smallerButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> switch ( profilePic . getPresetSize ( ) ) { </a> 0
<a> case ProfilePictureView . LARGE : </a> 0
<a> switchToPresetSize ( ProfilePictureView . NORMAL ) ; </a> 0
<a> break ; </a> 0
<a> case ProfilePictureView . NORMAL : </a> 0
<a> switchToPresetSize ( ProfilePictureView . SMALL ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> largerButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> switch ( profilePic . getPresetSize ( ) ) { </a> 0
<a> case ProfilePictureView . NORMAL : </a> 0
<a> switchToPresetSize ( ProfilePictureView . LARGE ) ; </a> 0
<a> break ; </a> 0
<a> case ProfilePictureView . SMALL : </a> 0
<a> switchToPresetSize ( ProfilePictureView . NORMAL ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> customSizeView . setMax ( MAX_CUSTOM_SIZES ) ; </a> 0
<a> customSizeView . setOnSeekBarChangeListener ( new SeekBar . OnSeekBarChangeListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onProgressChanged ( SeekBar seekBar , int i , boolean b ) { </a> 0
<a> updateProfilePicForCustomSizeIncrement ( i ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onStartTrackingTouch ( SeekBar seekBar ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onStopTrackingTouch ( SeekBar seekBar ) { </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> restoreState ( savedInstanceState ) ; </a> 0
<a> return fragmentView ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onSaveInstanceState ( Bundle outState ) { </a> 0
<a> super . onSaveInstanceState ( outState ) ; </a> 0
<a> outState . putInt ( PICTURE_SIZE_TYPE_KEY , pictureSizeType ) ; </a> 0
<a> } </a> 0
<a> private void restoreState ( Bundle savedInstanceState ) { </a> 0
<a> if ( savedInstanceState != null ) { </a> 0
<a> pictureSizeType = savedInstanceState . getInt ( </a> 0
<a> PICTURE_SIZE_TYPE_KEY , ProfilePictureView . LARGE ) ; </a> 0
<a> if ( pictureSizeType == ProfilePictureView . CUSTOM ) { </a> 0
<a> switchToCustomSize ( ) ; </a> 0
<a> } else { </a> 0
<a> switchToPresetSize ( pictureSizeType ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> switchToPresetSize ( ProfilePictureView . LARGE ) ; </a> 0
<a> profilePic . setCropped ( cropToggle . isChecked ( ) ) ; </a> 0
<a> profilePic . setProfileId ( firstUserId ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void setupUserButton ( Button b ) { </a> 0
<a> b . setOnClickListener ( new Button . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> Object tag = v . getTag ( ) ; </a> 0
<a> String userId = null ; </a> 0
<a> if ( tag != null ) { </a> 0
<a> userId = tag . toString ( ) ; </a> 0
<a> } else { </a> 0
<a> userId = INTERESTING_IDS [ randomGenerator . nextInt ( INTERESTING_IDS . length ) ] ; </a> 0
<a> } </a> 0
<a> profilePic . setProfileId ( userId ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private void switchToCustomSize ( ) { </a> 0
<a> pictureSizeType = ProfilePictureView . CUSTOM ; </a> 0
<a> presetSizeView . setVisibility ( View . GONE ) ; </a> 0
<a> customSizeView . setVisibility ( View . VISIBLE ) ; </a> 0
<a> profilePic . setPresetSize ( pictureSizeType ) ; </a> 0
<a> customSizeView . setProgress ( DEFAULT_SIZE_INCREMENT ) ; </a> 0
<a> updateProfilePicForCustomSizeIncrement ( DEFAULT_SIZE_INCREMENT ) ; </a> 0
<a> } </a> 0
<a> private void switchToPresetSize ( int sizeType ) { </a> 0
<a> customSizeView . setVisibility ( View . GONE ) ; </a> 0
<a> presetSizeView . setVisibility ( View . VISIBLE ) ; </a> 0
<a> switch ( sizeType ) { </a> 0
<a> case ProfilePictureView . SMALL : </a> 0
<a> largerButton . setEnabled ( true ) ; </a> 0
<a> smallerButton . setEnabled ( false ) ; </a> 0
<a> sizeLabel . setText ( R . string . small_image_size ) ; </a> 0
<a> pictureSizeType = sizeType ; </a> 0
<a> break ; </a> 0
<a> case ProfilePictureView . NORMAL : </a> 0
<a> largerButton . setEnabled ( true ) ; </a> 0
<a> smallerButton . setEnabled ( true ) ; </a> 0
<a> sizeLabel . setText ( R . string . normal_image_size ) ; </a> 0
<a> pictureSizeType = sizeType ; </a> 0
<a> break ; </a> 0
<a> case ProfilePictureView . LARGE : </a> 0
<a> default : </a> 0
<a> largerButton . setEnabled ( false ) ; </a> 0
<a> smallerButton . setEnabled ( true ) ; </a> 0
<a> sizeLabel . setText ( R . string . large_image_size ) ; </a> 0
<a> pictureSizeType = ProfilePictureView . LARGE ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> LinearLayout . LayoutParams params = new LinearLayout . LayoutParams ( </a> 0
<a> 0 , </a> 0
<a> ViewGroup . LayoutParams . WRAP_CONTENT , </a> 0
<a> 1 </a> 0
<a> ) ; </a> 0
<a> profilePic . setLayoutParams ( params ) ; </a> 0
<a> profilePic . setPresetSize ( pictureSizeType ) ; </a> 0
<a> } </a> 0
<a> private void updateProfilePicForCustomSizeIncrement ( int i ) { </a> 0
<a> if ( pictureSizeType != ProfilePictureView . CUSTOM ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> float width = ( i * 21 ) + 51 ; </a> 0
<a> float height = ( i * 28 ) + 68 ; </a> 0
<a> LinearLayout . LayoutParams params = new LinearLayout . LayoutParams ( </a> 0
<a> ( int ) ( width * getResources ( ) . getDisplayMetrics ( ) . density ) , </a> 0
<a> ( int ) ( height * getResources ( ) . getDisplayMetrics ( ) . density ) ) ; </a> 0
<a> profilePic . setLayoutParams ( params ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . scrumptious ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . graphics . drawable . Drawable ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . widget . BaseAdapter ; </a> 0
<a> import com . facebook . model . OpenGraphAction ; </a> 0
<a> public abstract class BaseListElement { </a> 0
<a> private Drawable icon ; </a> 0
<a> private String text1 ; </a> 0
<a> private String text2 ; </a> 0
<a> private BaseAdapter adapter ; </a> 0
<a> private int requestCode ; </a> 0
<a> public BaseListElement ( Drawable icon , String text1 , String text2 , int requestCode ) { </a> 0
<a> this . icon = icon ; </a> 0
<a> this . text1 = text1 ; </a> 0
<a> this . text2 = text2 ; </a> 0
<a> this . requestCode = requestCode ; </a> 0
<a> } </a> 0
<a> public void setAdapter ( BaseAdapter adapter ) { </a> 0
<a> this . adapter = adapter ; </a> 0
<a> } </a> 0
<a> public Drawable getIcon ( ) { </a> 0
<a> return icon ; </a> 0
<a> } </a> 0
<a> public String getText1 ( ) { </a> 0
<a> return text1 ; </a> 0
<a> } </a> 0
<a> public String getText2 ( ) { </a> 0
<a> return text2 ; </a> 0
<a> } </a> 0
<a> public int getRequestCode ( ) { </a> 0
<a> return requestCode ; </a> 0
<a> } </a> 0
<a> public void setText1 ( String text1 ) { </a> 0
<a> this . text1 = text1 ; </a> 0
<a> if ( adapter != null ) { </a> 0
<a> adapter . notifyDataSetChanged ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void setText2 ( String text2 ) { </a> 0
<a> this . text2 = text2 ; </a> 0
<a> if ( adapter != null ) { </a> 0
<a> adapter . notifyDataSetChanged ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected abstract View . OnClickListener getOnClickListener ( ) ; </a> 0
<a> protected abstract void populateOGAction ( OpenGraphAction action ) ; </a> 0
<a> protected void onActivityResult ( Intent data ) { } </a> 0
<a> protected void onSaveInstanceState ( Bundle bundle ) { } </a> 0
<a> protected boolean restoreState ( Bundle savedState ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> protected void notifyDataChanged ( ) { </a> 0
<a> adapter . notifyDataSetChanged ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . scrumptious ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . graphics . Rect ; </a> 0
<a> import android . util . AttributeSet ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . widget . ListAdapter ; </a> 0
<a> import android . widget . ListView ; </a> 0
<a> public class FullListView extends ListView { </a> 0
<a> public FullListView ( Context context ) { </a> 0
<a> super ( context ) ; </a> 0
<a> } </a> 0
<a> public FullListView ( Context context , AttributeSet attributeSet ) { </a> 0
<a> super ( context , attributeSet ) ; </a> 0
<a> } </a> 0
<a> public FullListView ( Context context , AttributeSet attributeSet , int defStyle ) { </a> 0
<a> super ( context , attributeSet , defStyle ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { </a> 0
<a> super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; </a> 0
<a> int width = getMeasuredWidth ( ) ; </a> 0
<a> int height = 0 ; </a> 0
<a> ListAdapter adapter = getAdapter ( ) ; </a> 0
<a> int count = adapter . getCount ( ) ; </a> 0
<a> for ( int i = 0 ; i < count ; i ++ ) { </a> 0
<a> View childView = adapter . getView ( i , null , this ) ; </a> 0
<a> childView . measure ( MeasureSpec . makeMeasureSpec ( 0 , MeasureSpec . UNSPECIFIED ) , </a> 0
<a> MeasureSpec . makeMeasureSpec ( 0 , MeasureSpec . UNSPECIFIED ) ) ; </a> 0
<a> height += childView . getMeasuredHeight ( ) ; </a> 0
<a> } </a> 0
<a> Rect bgPadding = new Rect ( ) ; </a> 0
<a> getBackground ( ) . getPadding ( bgPadding ) ; </a> 0
<a> height += ( count - 1 ) * getDividerHeight ( ) + bgPadding . top + bgPadding . bottom ; </a> 0
<a> setMeasuredDimension ( width , height ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . scrumptious ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> import android . support . v4 . app . FragmentManager ; </a> 0
<a> import android . support . v4 . app . FragmentTransaction ; </a> 0
<a> import android . view . Menu ; </a> 0
<a> import android . view . MenuItem ; </a> 0
<a> import com . facebook . Session ; </a> 0
<a> import com . facebook . SessionState ; </a> 0
<a> import com . facebook . UiLifecycleHelper ; </a> 0
<a> public class MainActivity extends FragmentActivity { </a> 0
<a> private static final int SPLASH = 0 ; </a> 0
<a> private static final int SELECTION = 1 ; </a> 0
<a> private static final int SETTINGS = 2 ; </a> 0
<a> private static final int FRAGMENT_COUNT = SETTINGS + 1 ; </a> 0
<a> private Fragment [ ] fragments = new Fragment [ FRAGMENT_COUNT ] ; </a> 0
<a> private MenuItem settings ; </a> 0
<a> private boolean isResumed = false ; </a> 0
<a> private UiLifecycleHelper uiHelper ; </a> 0
<a> private Session . StatusCallback callback = new Session . StatusCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> onSessionStateChange ( session , state , exception ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> uiHelper = new UiLifecycleHelper ( this , callback ) ; </a> 0
<a> uiHelper . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . main ) ; </a> 0
<a> FragmentManager fm = getSupportFragmentManager ( ) ; </a> 0
<a> fragments [ SPLASH ] = fm . findFragmentById ( R . id . splashFragment ) ; </a> 0
<a> fragments [ SELECTION ] = fm . findFragmentById ( R . id . selectionFragment ) ; </a> 0
<a> fragments [ SETTINGS ] = fm . findFragmentById ( R . id . userSettingsFragment ) ; </a> 0
<a> FragmentTransaction transaction = fm . beginTransaction ( ) ; </a> 0
<a> for ( int i = 0 ; i < fragments . length ; i ++ ) { </a> 0
<a> transaction . hide ( fragments [ i ] ) ; </a> 0
<a> } </a> 0
<a> transaction . commit ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onResume ( ) { </a> 0
<a> super . onResume ( ) ; </a> 0
<a> uiHelper . onResume ( ) ; </a> 0
<a> isResumed = true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onPause ( ) { </a> 0
<a> super . onPause ( ) ; </a> 0
<a> uiHelper . onPause ( ) ; </a> 0
<a> isResumed = false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> super . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> uiHelper . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDestroy ( ) { </a> 0
<a> super . onDestroy ( ) ; </a> 0
<a> uiHelper . onDestroy ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onSaveInstanceState ( Bundle outState ) { </a> 0
<a> super . onSaveInstanceState ( outState ) ; </a> 0
<a> uiHelper . onSaveInstanceState ( outState ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onResumeFragments ( ) { </a> 0
<a> super . onResumeFragments ( ) ; </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session != null && session . isOpened ( ) ) { </a> 0
<a> showFragment ( SELECTION , false ) ; </a> 0
<a> } else { </a> 0
<a> showFragment ( SPLASH , false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean onPrepareOptionsMenu ( Menu menu ) { </a> 0
<a> if ( fragments [ SELECTION ] . isVisible ( ) ) { </a> 0
<a> if ( menu . size ( ) == 0 ) { </a> 0
<a> settings = menu . add ( R . string . settings ) ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } else { </a> 0
<a> menu . clear ( ) ; </a> 0
<a> settings = null ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean onOptionsItemSelected ( MenuItem item ) { </a> 0
<a> if ( item . equals ( settings ) ) { </a> 0
<a> showFragment ( SETTINGS , true ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private void onSessionStateChange ( Session session , SessionState state , Exception exception ) { </a> 0
<a> if ( isResumed ) { </a> 0
<a> FragmentManager manager = getSupportFragmentManager ( ) ; </a> 0
<a> int backStackSize = manager . getBackStackEntryCount ( ) ; </a> 0
<a> for ( int i = 0 ; i < backStackSize ; i ++ ) { </a> 0
<a> manager . popBackStack ( ) ; </a> 0
<a> } </a> 0
<a> if ( state . equals ( SessionState . OPENED ) ) { </a> 0
<a> showFragment ( SELECTION , false ) ; </a> 0
<a> } else if ( state . isClosed ( ) ) { </a> 0
<a> showFragment ( SPLASH , false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void showFragment ( int fragmentIndex , boolean addToBackStack ) { </a> 0
<a> FragmentManager fm = getSupportFragmentManager ( ) ; </a> 0
<a> FragmentTransaction transaction = fm . beginTransaction ( ) ; </a> 0
<a> for ( int i = 0 ; i < fragments . length ; i ++ ) { </a> 0
<a> if ( i == fragmentIndex ) { </a> 0
<a> transaction . show ( fragments [ i ] ) ; </a> 0
<a> } else { </a> 0
<a> transaction . hide ( fragments [ i ] ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( addToBackStack ) { </a> 0
<a> transaction . addToBackStack ( null ) ; </a> 0
<a> } </a> 0
<a> transaction . commit ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . scrumptious ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . app . AlertDialog ; </a> 0
<a> import android . app . ProgressDialog ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . DialogInterface ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . net . Uri ; </a> 0
<a> import android . os . AsyncTask ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import android . view . LayoutInflater ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . widget . * ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . model . * ; </a> 0
<a> import com . facebook . widget . ProfilePictureView ; </a> 0
<a> import org . json . JSONException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import java . io . * ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class SelectionFragment extends Fragment { </a> 0
<a> private static final String TAG = "SelectionFragment" ; </a> 0
<a> private static final String POST_ACTION_PATH = "me/fb_sample_scrumps:eat" ; </a> 0
<a> private static final String PENDING_ANNOUNCE_KEY = "pendingAnnounce" ; </a> 0
<a> private static final Uri M_FACEBOOK_URL = Uri . parse ( "http://m.facebook.com" ) ; </a> 0
<a> private static final int REAUTH_ACTIVITY_CODE = 100 ; </a> 0
<a> private static final List < String > PERMISSIONS = Arrays . asList ( "publish_actions" ) ; </a> 0
<a> private Button announceButton ; </a> 0
<a> private ListView listView ; </a> 0
<a> private ProgressDialog progressDialog ; </a> 0
<a> private List < BaseListElement > listElements ; </a> 0
<a> private ProfilePictureView profilePictureView ; </a> 0
<a> private TextView userNameView ; </a> 0
<a> private boolean pendingAnnounce ; </a> 0
<a> private UiLifecycleHelper uiHelper ; </a> 0
<a> private Session . StatusCallback callback = new Session . StatusCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void call ( final Session session , final SessionState state , final Exception exception ) { </a> 0
<a> onSessionStateChange ( session , state , exception ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> uiHelper = new UiLifecycleHelper ( getActivity ( ) , callback ) ; </a> 0
<a> uiHelper . onCreate ( savedInstanceState ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onResume ( ) { </a> 0
<a> super . onResume ( ) ; </a> 0
<a> uiHelper . onResume ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { </a> 0
<a> super . onCreateView ( inflater , container , savedInstanceState ) ; </a> 0
<a> View view = inflater . inflate ( R . layout . selection , container , false ) ; </a> 0
<a> profilePictureView = ( ProfilePictureView ) view . findViewById ( R . id . selection_profile_pic ) ; </a> 0
<a> profilePictureView . setCropped ( true ) ; </a> 0
<a> userNameView = ( TextView ) view . findViewById ( R . id . selection_user_name ) ; </a> 0
<a> announceButton = ( Button ) view . findViewById ( R . id . announce_button ) ; </a> 0
<a> listView = ( ListView ) view . findViewById ( R . id . selection_list ) ; </a> 0
<a> announceButton . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> handleAnnounce ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> init ( savedInstanceState ) ; </a> 0
<a> return view ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> super . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> if ( requestCode == REAUTH_ACTIVITY_CODE ) { </a> 0
<a> uiHelper . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> } else if ( resultCode == Activity . RESULT_OK && requestCode >= 0 && requestCode < listElements . size ( ) ) { </a> 0
<a> listElements . get ( requestCode ) . onActivityResult ( data ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onSaveInstanceState ( Bundle bundle ) { </a> 0
<a> super . onSaveInstanceState ( bundle ) ; </a> 0
<a> for ( BaseListElement listElement : listElements ) { </a> 0
<a> listElement . onSaveInstanceState ( bundle ) ; </a> 0
<a> } </a> 0
<a> bundle . putBoolean ( PENDING_ANNOUNCE_KEY , pendingAnnounce ) ; </a> 0
<a> uiHelper . onSaveInstanceState ( bundle ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onPause ( ) { </a> 0
<a> super . onPause ( ) ; </a> 0
<a> uiHelper . onPause ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onDestroy ( ) { </a> 0
<a> super . onDestroy ( ) ; </a> 0
<a> uiHelper . onDestroy ( ) ; </a> 0
<a> } </a> 0
<a> private void tokenUpdated ( ) { </a> 0
<a> if ( pendingAnnounce ) { </a> 0
<a> handleAnnounce ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onSessionStateChange ( final Session session , SessionState state , Exception exception ) { </a> 0
<a> if ( session != null && session . isOpened ( ) ) { </a> 0
<a> if ( state . equals ( SessionState . OPENED_TOKEN_UPDATED ) ) { </a> 0
<a> tokenUpdated ( ) ; </a> 0
<a> } else { </a> 0
<a> makeMeRequest ( session ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void makeMeRequest ( final Session session ) { </a> 0
<a> Request request = Request . newMeRequest ( session , new Request . GraphUserCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( GraphUser user , Response response ) { </a> 0
<a> if ( session == Session . getActiveSession ( ) ) { </a> 0
<a> if ( user != null ) { </a> 0
<a> profilePictureView . setProfileId ( user . getId ( ) ) ; </a> 0
<a> userNameView . setText ( user . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( response . getError ( ) != null ) { </a> 0
<a> handleError ( response . getError ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> request . executeAsync ( ) ; </a> 0
<a> } </a> 0
<a> private void init ( Bundle savedInstanceState ) { </a> 0
<a> announceButton . setEnabled ( false ) ; </a> 0
<a> listElements = new ArrayList < BaseListElement > ( ) ; </a> 0
<a> listElements . add ( new EatListElement ( 0 ) ) ; </a> 0
<a> listElements . add ( new LocationListElement ( 1 ) ) ; </a> 0
<a> listElements . add ( new PeopleListElement ( 2 ) ) ; </a> 0
<a> if ( savedInstanceState != null ) { </a> 0
<a> for ( BaseListElement listElement : listElements ) { </a> 0
<a> listElement . restoreState ( savedInstanceState ) ; </a> 0
<a> } </a> 0
<a> pendingAnnounce = savedInstanceState . getBoolean ( PENDING_ANNOUNCE_KEY , false ) ; </a> 0
<a> } </a> 0
<a> listView . setAdapter ( new ActionListAdapter ( getActivity ( ) , R . id . selection_list , listElements ) ) ; </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session != null && session . isOpened ( ) ) { </a> 0
<a> makeMeRequest ( session ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void handleAnnounce ( ) { </a> 0
<a> pendingAnnounce = false ; </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session == null || ! session . isOpened ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> List < String > permissions = session . getPermissions ( ) ; </a> 0
<a> if ( ! permissions . containsAll ( PERMISSIONS ) ) { </a> 0
<a> pendingAnnounce = true ; </a> 0
<a> requestPublishPermissions ( session ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> progressDialog = ProgressDialog . show ( getActivity ( ) , "" , </a> 0
<a> getActivity ( ) . getResources ( ) . getString ( R . string . progress_dialog_text ) , true ) ; </a> 0
<a> AsyncTask < Void , Void , Response > task = new AsyncTask < Void , Void , Response > ( ) { </a> 0
<a> @ Override </a> 0
<a> protected Response doInBackground ( Void ... voids ) { </a> 0
<a> EatAction eatAction = GraphObject . Factory . create ( EatAction . class ) ; </a> 0
<a> for ( BaseListElement element : listElements ) { </a> 0
<a> element . populateOGAction ( eatAction ) ; </a> 0
<a> } </a> 0
<a> Request request = new Request ( Session . getActiveSession ( ) , </a> 0
<a> POST_ACTION_PATH , null , HttpMethod . POST ) ; </a> 0
<a> request . setGraphObject ( eatAction ) ; </a> 0
<a> return request . executeAndWait ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onPostExecute ( Response response ) { </a> 0
<a> onPostActionResponse ( response ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> task . execute ( ) ; </a> 0
<a> } </a> 0
<a> private void requestPublishPermissions ( Session session ) { </a> 0
<a> if ( session != null ) { </a> 0
<a> Session . NewPermissionsRequest newPermissionsRequest = new Session . NewPermissionsRequest ( this , PERMISSIONS ) </a> 0
<a> . setDefaultAudience ( SessionDefaultAudience . FRIENDS ) </a> 0
<a> . setRequestCode ( REAUTH_ACTIVITY_CODE ) ; </a> 0
<a> session . requestNewPublishPermissions ( newPermissionsRequest ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onPostActionResponse ( Response response ) { </a> 0
<a> if ( progressDialog != null ) { </a> 0
<a> progressDialog . dismiss ( ) ; </a> 0
<a> progressDialog = null ; </a> 0
<a> } </a> 0
<a> if ( getActivity ( ) == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> PostResponse postResponse = response . getGraphObjectAs ( PostResponse . class ) ; </a> 0
<a> if ( postResponse != null && postResponse . getId ( ) != null ) { </a> 0
<a> String dialogBody = String . format ( getString ( R . string . result_dialog_text ) , postResponse . getId ( ) ) ; </a> 0
<a> new AlertDialog . Builder ( getActivity ( ) ) </a> 0
<a> . setPositiveButton ( R . string . result_dialog_button_text , null ) </a> 0
<a> . setTitle ( R . string . result_dialog_title ) </a> 0
<a> . setMessage ( dialogBody ) </a> 0
<a> . show ( ) ; </a> 0
<a> init ( null ) ; </a> 0
<a> } else { </a> 0
<a> handleError ( response . getError ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void handleError ( FacebookRequestError error ) { </a> 0
<a> DialogInterface . OnClickListener listener = null ; </a> 0
<a> String dialogBody = null ; </a> 0
<a> if ( error == null ) { </a> 0
<a> dialogBody = getString ( R . string . error_dialog_default_text ) ; </a> 0
<a> } else { </a> 0
<a> switch ( error . getCategory ( ) ) { </a> 0
<a> case AUTHENTICATION_RETRY : </a> 0
<a> String userAction = ( error . shouldNotifyUser ( ) ) ? "" : </a> 0
<a> getString ( error . getUserActionMessageId ( ) ) ; </a> 0
<a> dialogBody = getString ( R . string . error_authentication_retry , userAction ) ; </a> 0
<a> listener = new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialogInterface , int i ) { </a> 0
<a> Intent intent = new Intent ( Intent . ACTION_VIEW , M_FACEBOOK_URL ) ; </a> 0
<a> startActivity ( intent ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> break ; </a> 0
<a> case AUTHENTICATION_REOPEN_SESSION : </a> 0
<a> dialogBody = getString ( R . string . error_authentication_reopen ) ; </a> 0
<a> listener = new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialogInterface , int i ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session != null && ! session . isClosed ( ) ) { </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> break ; </a> 0
<a> case PERMISSION : </a> 0
<a> dialogBody = getString ( R . string . error_permission ) ; </a> 0
<a> listener = new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialogInterface , int i ) { </a> 0
<a> pendingAnnounce = true ; </a> 0
<a> requestPublishPermissions ( Session . getActiveSession ( ) ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> break ; </a> 0
<a> case SERVER : </a> 0
<a> case THROTTLING : </a> 0
<a> dialogBody = getString ( R . string . error_server ) ; </a> 0
<a> break ; </a> 0
<a> case BAD_REQUEST : </a> 0
<a> dialogBody = getString ( R . string . error_bad_request , error . getErrorMessage ( ) ) ; </a> 0
<a> break ; </a> 0
<a> case OTHER : </a> 0
<a> case CLIENT : </a> 0
<a> default : </a> 0
<a> dialogBody = getString ( R . string . error_unknown , error . getErrorMessage ( ) ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> new AlertDialog . Builder ( getActivity ( ) ) </a> 0
<a> . setPositiveButton ( R . string . error_dialog_button_text , listener ) </a> 0
<a> . setTitle ( R . string . error_dialog_title ) </a> 0
<a> . setMessage ( dialogBody ) </a> 0
<a> . show ( ) ; </a> 0
<a> } </a> 0
<a> private void startPickerActivity ( Uri data , int requestCode ) { </a> 0
<a> Intent intent = new Intent ( ) ; </a> 0
<a> intent . setData ( data ) ; </a> 0
<a> intent . setClass ( getActivity ( ) , PickerActivity . class ) ; </a> 0
<a> startActivityForResult ( intent , requestCode ) ; </a> 0
<a> } </a> 0
<a> private interface MealGraphObject extends GraphObject { </a> 0
<a> public String getUrl ( ) ; </a> 0
<a> public void setUrl ( String url ) ; </a> 0
<a> public String getId ( ) ; </a> 0
<a> public void setId ( String id ) ; </a> 0
<a> } </a> 0
<a> private interface EatAction extends OpenGraphAction { </a> 0
<a> public MealGraphObject getMeal ( ) ; </a> 0
<a> public void setMeal ( MealGraphObject meal ) ; </a> 0
<a> } </a> 0
<a> private interface PostResponse extends GraphObject { </a> 0
<a> String getId ( ) ; </a> 0
<a> } </a> 0
<a> private class EatListElement extends BaseListElement { </a> 0
<a> private static final String FOOD_KEY = "food" ; </a> 0
<a> private static final String FOOD_URL_KEY = "food_url" ; </a> 0
<a> private final String [ ] foodChoices ; </a> 0
<a> private final String [ ] foodUrls ; </a> 0
<a> private String foodChoiceUrl = null ; </a> 0
<a> private String foodChoice = null ; </a> 0
<a> public EatListElement ( int requestCode ) { </a> 0
<a> super ( getActivity ( ) . getResources ( ) . getDrawable ( R . drawable . action_eating ) , </a> 0
<a> getActivity ( ) . getResources ( ) . getString ( R . string . action_eating ) , </a> 0
<a> getActivity ( ) . getResources ( ) . getString ( R . string . action_eating_default ) , </a> 0
<a> requestCode ) ; </a> 0
<a> foodChoices = getActivity ( ) . getResources ( ) . getStringArray ( R . array . food_types ) ; </a> 0
<a> foodUrls = getActivity ( ) . getResources ( ) . getStringArray ( R . array . food_og_urls ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected View . OnClickListener getOnClickListener ( ) { </a> 0
<a> return new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> showMealOptions ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void populateOGAction ( OpenGraphAction action ) { </a> 0
<a> if ( foodChoiceUrl != null ) { </a> 0
<a> EatAction eatAction = action . cast ( EatAction . class ) ; </a> 0
<a> MealGraphObject meal = GraphObject . Factory . create ( MealGraphObject . class ) ; </a> 0
<a> meal . setUrl ( foodChoiceUrl ) ; </a> 0
<a> eatAction . setMeal ( meal ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onSaveInstanceState ( Bundle bundle ) { </a> 0
<a> if ( foodChoice != null && foodChoiceUrl != null ) { </a> 0
<a> bundle . putString ( FOOD_KEY , foodChoice ) ; </a> 0
<a> bundle . putString ( FOOD_URL_KEY , foodChoiceUrl ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean restoreState ( Bundle savedState ) { </a> 0
<a> String food = savedState . getString ( FOOD_KEY ) ; </a> 0
<a> String foodUrl = savedState . getString ( FOOD_URL_KEY ) ; </a> 0
<a> if ( food != null && foodUrl != null ) { </a> 0
<a> foodChoice = food ; </a> 0
<a> foodChoiceUrl = foodUrl ; </a> 0
<a> setFoodText ( ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private void showMealOptions ( ) { </a> 0
<a> String title = getActivity ( ) . getResources ( ) . getString ( R . string . select_meal ) ; </a> 0
<a> AlertDialog . Builder builder = new AlertDialog . Builder ( getActivity ( ) ) ; </a> 0
<a> builder . setTitle ( title ) . </a> 0
<a> setCancelable ( true ) . </a> 0
<a> setItems ( foodChoices , new DialogInterface . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( DialogInterface dialogInterface , int i ) { </a> 0
<a> foodChoice = foodChoices [ i ] ; </a> 0
<a> foodChoiceUrl = foodUrls [ i ] ; </a> 0
<a> setFoodText ( ) ; </a> 0
<a> notifyDataChanged ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> builder . show ( ) ; </a> 0
<a> } </a> 0
<a> private void setFoodText ( ) { </a> 0
<a> if ( foodChoice != null && foodChoiceUrl != null ) { </a> 0
<a> setText2 ( foodChoice ) ; </a> 0
<a> announceButton . setEnabled ( true ) ; </a> 0
<a> } else { </a> 0
<a> setText2 ( getActivity ( ) . getResources ( ) . getString ( R . string . action_eating_default ) ) ; </a> 0
<a> announceButton . setEnabled ( false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class PeopleListElement extends BaseListElement { </a> 0
<a> private static final String FRIENDS_KEY = "friends" ; </a> 0
<a> private List < GraphUser > selectedUsers ; </a> 0
<a> public PeopleListElement ( int requestCode ) { </a> 0
<a> super ( getActivity ( ) . getResources ( ) . getDrawable ( R . drawable . action_people ) , </a> 0
<a> getActivity ( ) . getResources ( ) . getString ( R . string . action_people ) , </a> 0
<a> getActivity ( ) . getResources ( ) . getString ( R . string . action_people_default ) , </a> 0
<a> requestCode ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected View . OnClickListener getOnClickListener ( ) { </a> 0
<a> return new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> startPickerActivity ( PickerActivity . FRIEND_PICKER , getRequestCode ( ) ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onActivityResult ( Intent data ) { </a> 0
<a> selectedUsers = ( ( ScrumptiousApplication ) getActivity ( ) . getApplication ( ) ) . getSelectedUsers ( ) ; </a> 0
<a> setUsersText ( ) ; </a> 0
<a> notifyDataChanged ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void populateOGAction ( OpenGraphAction action ) { </a> 0
<a> if ( selectedUsers != null ) { </a> 0
<a> action . setTags ( selectedUsers ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onSaveInstanceState ( Bundle bundle ) { </a> 0
<a> if ( selectedUsers != null ) { </a> 0
<a> bundle . putByteArray ( FRIENDS_KEY , getByteArray ( selectedUsers ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean restoreState ( Bundle savedState ) { </a> 0
<a> byte [ ] bytes = savedState . getByteArray ( FRIENDS_KEY ) ; </a> 0
<a> if ( bytes != null ) { </a> 0
<a> selectedUsers = restoreByteArray ( bytes ) ; </a> 0
<a> setUsersText ( ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private void setUsersText ( ) { </a> 0
<a> String text = null ; </a> 0
<a> if ( selectedUsers != null ) { </a> 0
<a> if ( selectedUsers . size ( ) == 1 ) { </a> 0
<a> text = String . format ( getResources ( ) . getString ( R . string . single_user_selected ) , </a> 0
<a> selectedUsers . get ( 0 ) . getName ( ) ) ; </a> 0
<a> } else if ( selectedUsers . size ( ) == 2 ) { </a> 0
<a> text = String . format ( getResources ( ) . getString ( R . string . two_users_selected ) , </a> 0
<a> selectedUsers . get ( 0 ) . getName ( ) , selectedUsers . get ( 1 ) . getName ( ) ) ; </a> 0
<a> } else if ( selectedUsers . size ( ) > 2 ) { </a> 0
<a> text = String . format ( getResources ( ) . getString ( R . string . multiple_users_selected ) , </a> 0
<a> selectedUsers . get ( 0 ) . getName ( ) , ( selectedUsers . size ( ) - 1 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( text == null ) { </a> 0
<a> text = getResources ( ) . getString ( R . string . action_people_default ) ; </a> 0
<a> } </a> 0
<a> setText2 ( text ) ; </a> 0
<a> } </a> 0
<a> private byte [ ] getByteArray ( List < GraphUser > users ) { </a> 0
<a> List < String > usersAsString = new ArrayList < String > ( users . size ( ) ) ; </a> 0
<a> for ( GraphUser user : users ) { </a> 0
<a> usersAsString . add ( user . getInnerJSONObject ( ) . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; </a> 0
<a> new ObjectOutputStream ( outputStream ) . writeObject ( usersAsString ) ; </a> 0
<a> return outputStream . toByteArray ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> Log . e ( TAG , "Unable to serialize users." , e ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> private List < GraphUser > restoreByteArray ( byte [ ] bytes ) { </a> 0
<a> try { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> List < String > usersAsString = </a> 0
<a> ( List < String > ) ( new ObjectInputStream ( new ByteArrayInputStream ( bytes ) ) ) . readObject ( ) ; </a> 0
<a> if ( usersAsString != null ) { </a> 0
<a> List < GraphUser > users = new ArrayList < GraphUser > ( usersAsString . size ( ) ) ; </a> 0
<a> for ( String user : usersAsString ) { </a> 0
<a> GraphUser graphUser = GraphObject . Factory </a> 0
<a> . create ( new JSONObject ( user ) , GraphUser . class ) ; </a> 0
<a> users . add ( graphUser ) ; </a> 0
<a> } </a> 0
<a> return users ; </a> 0
<a> } </a> 0
<a> } catch ( ClassNotFoundException e ) { </a> 0
<a> Log . e ( TAG , "Unable to deserialize users." , e ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> Log . e ( TAG , "Unable to deserialize users." , e ) ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> Log . e ( TAG , "Unable to deserialize users." , e ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class LocationListElement extends BaseListElement { </a> 0
<a> private static final String PLACE_KEY = "place" ; </a> 0
<a> private GraphPlace selectedPlace = null ; </a> 0
<a> public LocationListElement ( int requestCode ) { </a> 0
<a> super ( getActivity ( ) . getResources ( ) . getDrawable ( R . drawable . action_location ) , </a> 0
<a> getActivity ( ) . getResources ( ) . getString ( R . string . action_location ) , </a> 0
<a> getActivity ( ) . getResources ( ) . getString ( R . string . action_location_default ) , </a> 0
<a> requestCode ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected View . OnClickListener getOnClickListener ( ) { </a> 0
<a> return new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View view ) { </a> 0
<a> startPickerActivity ( PickerActivity . PLACE_PICKER , getRequestCode ( ) ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onActivityResult ( Intent data ) { </a> 0
<a> selectedPlace = ( ( ScrumptiousApplication ) getActivity ( ) . getApplication ( ) ) . getSelectedPlace ( ) ; </a> 0
<a> setPlaceText ( ) ; </a> 0
<a> notifyDataChanged ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void populateOGAction ( OpenGraphAction action ) { </a> 0
<a> if ( selectedPlace != null ) { </a> 0
<a> action . setPlace ( selectedPlace ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onSaveInstanceState ( Bundle bundle ) { </a> 0
<a> if ( selectedPlace != null ) { </a> 0
<a> bundle . putString ( PLACE_KEY , selectedPlace . getInnerJSONObject ( ) . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean restoreState ( Bundle savedState ) { </a> 0
<a> String place = savedState . getString ( PLACE_KEY ) ; </a> 0
<a> if ( place != null ) { </a> 0
<a> try { </a> 0
<a> selectedPlace = GraphObject . Factory </a> 0
<a> . create ( new JSONObject ( place ) , GraphPlace . class ) ; </a> 0
<a> setPlaceText ( ) ; </a> 0
<a> return true ; </a> 0
<a> } catch ( JSONException e ) { </a> 0
<a> Log . e ( TAG , "Unable to deserialize place." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private void setPlaceText ( ) { </a> 0
<a> String text = null ; </a> 0
<a> if ( selectedPlace != null ) { </a> 0
<a> text = selectedPlace . getName ( ) ; </a> 0
<a> } </a> 0
<a> if ( text == null ) { </a> 0
<a> text = getResources ( ) . getString ( R . string . action_location_default ) ; </a> 0
<a> } </a> 0
<a> setText2 ( text ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class ActionListAdapter extends ArrayAdapter < BaseListElement > { </a> 0
<a> private List < BaseListElement > listElements ; </a> 0
<a> public ActionListAdapter ( Context context , int resourceId , List < BaseListElement > listElements ) { </a> 0
<a> super ( context , resourceId , listElements ) ; </a> 0
<a> this . listElements = listElements ; </a> 0
<a> for ( int i = 0 ; i < listElements . size ( ) ; i ++ ) { </a> 0
<a> listElements . get ( i ) . setAdapter ( this ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View getView ( int position , View convertView , ViewGroup parent ) { </a> 0
<a> View view = convertView ; </a> 0
<a> if ( view == null ) { </a> 0
<a> LayoutInflater inflater = </a> 0
<a> ( LayoutInflater ) getActivity ( ) . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; </a> 0
<a> view = inflater . inflate ( R . layout . listitem , null ) ; </a> 0
<a> } </a> 0
<a> BaseListElement listElement = listElements . get ( position ) ; </a> 0
<a> if ( listElement != null ) { </a> 0
<a> view . setOnClickListener ( listElement . getOnClickListener ( ) ) ; </a> 0
<a> ImageView icon = ( ImageView ) view . findViewById ( R . id . icon ) ; </a> 0
<a> TextView text1 = ( TextView ) view . findViewById ( R . id . text1 ) ; </a> 0
<a> TextView text2 = ( TextView ) view . findViewById ( R . id . text2 ) ; </a> 0
<a> if ( icon != null ) { </a> 0
<a> icon . setImageDrawable ( listElement . getIcon ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( text1 != null ) { </a> 0
<a> text1 . setText ( listElement . getText1 ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( text2 != null ) { </a> 0
<a> text2 . setText ( listElement . getText2 ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return view ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . scrumptious ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . view . LayoutInflater ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> public class SplashFragment extends Fragment { </a> 0
<a> @ Override </a> 0
<a> public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { </a> 0
<a> View view = inflater . inflate ( R . layout . splash , container , false ) ; </a> 0
<a> return view ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . sessionlogin ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . View . OnClickListener ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> import com . facebook . LoggingBehavior ; </a> 0
<a> import com . facebook . Session ; </a> 0
<a> import com . facebook . SessionState ; </a> 0
<a> import com . facebook . Settings ; </a> 0
<a> public class LoginUsingActivityActivity extends Activity { </a> 0
<a> private static final String URL_PREFIX_FRIENDS = "https://graph.facebook.com/me/friends?access_token=" ; </a> 0
<a> private TextView textInstructionsOrLink ; </a> 0
<a> private Button buttonLoginLogout ; </a> 0
<a> private Session . StatusCallback statusCallback = new SessionStatusCallback ( ) ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . activity ) ; </a> 0
<a> buttonLoginLogout = ( Button ) findViewById ( R . id . buttonLoginLogout ) ; </a> 0
<a> textInstructionsOrLink = ( TextView ) findViewById ( R . id . instructionsOrLink ) ; </a> 0
<a> Settings . addLoggingBehavior ( LoggingBehavior . INCLUDE_ACCESS_TOKENS ) ; </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session == null ) { </a> 0
<a> if ( savedInstanceState != null ) { </a> 0
<a> session = Session . restoreSession ( this , null , statusCallback , savedInstanceState ) ; </a> 0
<a> } </a> 0
<a> if ( session == null ) { </a> 0
<a> session = new Session ( this ) ; </a> 0
<a> } </a> 0
<a> Session . setActiveSession ( session ) ; </a> 0
<a> if ( session . getState ( ) . equals ( SessionState . CREATED_TOKEN_LOADED ) ) { </a> 0
<a> session . openForRead ( new Session . OpenRequest ( this ) . setCallback ( statusCallback ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> updateView ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onStart ( ) { </a> 0
<a> super . onStart ( ) ; </a> 0
<a> Session . getActiveSession ( ) . addCallback ( statusCallback ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onStop ( ) { </a> 0
<a> super . onStop ( ) ; </a> 0
<a> Session . getActiveSession ( ) . removeCallback ( statusCallback ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> super . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> Session . getActiveSession ( ) . onActivityResult ( this , requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onSaveInstanceState ( Bundle outState ) { </a> 0
<a> super . onSaveInstanceState ( outState ) ; </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> Session . saveSession ( session , outState ) ; </a> 0
<a> } </a> 0
<a> private void updateView ( ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session . isOpened ( ) ) { </a> 0
<a> textInstructionsOrLink . setText ( URL_PREFIX_FRIENDS + session . getAccessToken ( ) ) ; </a> 0
<a> buttonLoginLogout . setText ( R . string . logout ) ; </a> 0
<a> buttonLoginLogout . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { onClickLogout ( ) ; } </a> 0
<a> } ) ; </a> 0
<a> } else { </a> 0
<a> textInstructionsOrLink . setText ( R . string . instructions ) ; </a> 0
<a> buttonLoginLogout . setText ( R . string . login ) ; </a> 0
<a> buttonLoginLogout . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { onClickLogin ( ) ; } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onClickLogin ( ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( ! session . isOpened ( ) && ! session . isClosed ( ) ) { </a> 0
<a> session . openForRead ( new Session . OpenRequest ( this ) . setCallback ( statusCallback ) ) ; </a> 0
<a> } else { </a> 0
<a> Session . openActiveSession ( this , true , statusCallback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onClickLogout ( ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( ! session . isClosed ( ) ) { </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class SessionStatusCallback implements Session . StatusCallback { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> updateView ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . sessionlogin ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> public class LoginUsingCustomFragmentActivity extends FragmentActivity { </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . custom_fragment_activity ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . sessionlogin ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> import android . support . v4 . app . FragmentManager ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import com . facebook . Session ; </a> 0
<a> import com . facebook . SessionState ; </a> 0
<a> import com . facebook . widget . UserSettingsFragment ; </a> 0
<a> public class LoginUsingLoginFragmentActivity extends FragmentActivity { </a> 0
<a> private UserSettingsFragment userSettingsFragment ; </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . login_fragment_activity ) ; </a> 0
<a> FragmentManager fragmentManager = getSupportFragmentManager ( ) ; </a> 0
<a> userSettingsFragment = ( UserSettingsFragment ) fragmentManager . findFragmentById ( R . id . login_fragment ) ; </a> 0
<a> userSettingsFragment . setSessionStatusCallback ( new Session . StatusCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> Log . d ( "LoginUsingLoginFragmentActivity" , String . format ( "New session state: %s" , state . toString ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> userSettingsFragment . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> super . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . sessionlogin ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . view . LayoutInflater ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . ViewGroup ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> import com . facebook . LoggingBehavior ; </a> 0
<a> import com . facebook . Session ; </a> 0
<a> import com . facebook . SessionState ; </a> 0
<a> import com . facebook . Settings ; </a> 0
<a> public class SessionLoginFragment extends Fragment { </a> 0
<a> private static final String URL_PREFIX_FRIENDS = "https://graph.facebook.com/me/friends?access_token=" ; </a> 0
<a> private TextView textInstructionsOrLink ; </a> 0
<a> private Button buttonLoginLogout ; </a> 0
<a> private Session . StatusCallback statusCallback = new SessionStatusCallback ( ) ; </a> 0
<a> @ Override </a> 0
<a> public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { </a> 0
<a> View view = inflater . inflate ( R . layout . fragment , container , false ) ; </a> 0
<a> buttonLoginLogout = ( Button ) view . findViewById ( R . id . buttonLoginLogout ) ; </a> 0
<a> textInstructionsOrLink = ( TextView ) view . findViewById ( R . id . instructionsOrLink ) ; </a> 0
<a> Settings . addLoggingBehavior ( LoggingBehavior . INCLUDE_ACCESS_TOKENS ) ; </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session == null ) { </a> 0
<a> if ( savedInstanceState != null ) { </a> 0
<a> session = Session . restoreSession ( getActivity ( ) , null , statusCallback , savedInstanceState ) ; </a> 0
<a> } </a> 0
<a> if ( session == null ) { </a> 0
<a> session = new Session ( getActivity ( ) ) ; </a> 0
<a> } </a> 0
<a> Session . setActiveSession ( session ) ; </a> 0
<a> if ( session . getState ( ) . equals ( SessionState . CREATED_TOKEN_LOADED ) ) { </a> 0
<a> session . openForRead ( new Session . OpenRequest ( this ) . setCallback ( statusCallback ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> updateView ( ) ; </a> 0
<a> return view ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onStart ( ) { </a> 0
<a> super . onStart ( ) ; </a> 0
<a> Session . getActiveSession ( ) . addCallback ( statusCallback ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onStop ( ) { </a> 0
<a> super . onStop ( ) ; </a> 0
<a> Session . getActiveSession ( ) . removeCallback ( statusCallback ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> super . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> Session . getActiveSession ( ) . onActivityResult ( getActivity ( ) , requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onSaveInstanceState ( Bundle outState ) { </a> 0
<a> super . onSaveInstanceState ( outState ) ; </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> Session . saveSession ( session , outState ) ; </a> 0
<a> } </a> 0
<a> private void updateView ( ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( session . isOpened ( ) ) { </a> 0
<a> textInstructionsOrLink . setText ( URL_PREFIX_FRIENDS + session . getAccessToken ( ) ) ; </a> 0
<a> buttonLoginLogout . setText ( R . string . logout ) ; </a> 0
<a> buttonLoginLogout . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { onClickLogout ( ) ; } </a> 0
<a> } ) ; </a> 0
<a> } else { </a> 0
<a> textInstructionsOrLink . setText ( R . string . instructions ) ; </a> 0
<a> buttonLoginLogout . setText ( R . string . login ) ; </a> 0
<a> buttonLoginLogout . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> public void onClick ( View view ) { onClickLogin ( ) ; } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onClickLogin ( ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( ! session . isOpened ( ) && ! session . isClosed ( ) ) { </a> 0
<a> session . openForRead ( new Session . OpenRequest ( this ) . setCallback ( statusCallback ) ) ; </a> 0
<a> } else { </a> 0
<a> Session . openActiveSession ( getActivity ( ) , this , true , statusCallback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onClickLogout ( ) { </a> 0
<a> Session session = Session . getActiveSession ( ) ; </a> 0
<a> if ( ! session . isClosed ( ) ) { </a> 0
<a> session . closeAndClearTokenInformation ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class SessionStatusCallback implements Session . StatusCallback { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> updateView ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . sessionlogin ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> public class SessionLoginSampleActivity extends Activity { </a> 0
<a> private Button buttonLoginActivity ; </a> 0
<a> private Button buttonCustomFragment ; </a> 0
<a> private Button buttonLoginFragment ; </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . main ) ; </a> 0
<a> buttonLoginActivity = ( Button ) findViewById ( R . id . buttonLoginActivity ) ; </a> 0
<a> buttonLoginActivity . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> Intent intent = new Intent ( SessionLoginSampleActivity . this , LoginUsingActivityActivity . class ) ; </a> 0
<a> startActivity ( intent ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> buttonCustomFragment = ( Button ) findViewById ( R . id . buttonLoginCustomFragment ) ; </a> 0
<a> buttonCustomFragment . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> Intent intent = new Intent ( SessionLoginSampleActivity . this , LoginUsingCustomFragmentActivity . class ) ; </a> 0
<a> startActivity ( intent ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> buttonLoginFragment = ( Button ) findViewById ( R . id . buttonLoginFragment ) ; </a> 0
<a> buttonLoginFragment . setOnClickListener ( new View . OnClickListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> Intent intent = new Intent ( SessionLoginSampleActivity . this , LoginUsingLoginFragmentActivity . class ) ; </a> 0
<a> startActivity ( intent ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . switchuser ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . FragmentActivity ; </a> 0
<a> import android . support . v4 . app . FragmentManager ; </a> 0
<a> import android . support . v4 . app . FragmentTransaction ; </a> 0
<a> import android . view . MenuItem ; </a> 0
<a> import com . facebook . * ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> public class MainActivity extends FragmentActivity { </a> 0
<a> private static final String SHOWING_SETTINGS_KEY = "Showing settings" ; </a> 0
<a> private static final String TOKEN_CACHE_NAME_KEY = "TokenCacheName" ; </a> 0
<a> private ProfileFragment profileFragment ; </a> 0
<a> private SettingsFragment settingsFragment ; </a> 0
<a> private boolean isShowingSettings ; </a> 0
<a> private Slot currentSlot ; </a> 0
<a> private Session currentSession ; </a> 0
<a> private Session . StatusCallback sessionStatusCallback ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . main ) ; </a> 0
<a> restoreFragments ( savedInstanceState ) ; </a> 0
<a> sessionStatusCallback = new Session . StatusCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void call ( Session session , SessionState state , Exception exception ) { </a> 0
<a> onSessionStateChange ( session , state , exception ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> if ( savedInstanceState != null ) { </a> 0
<a> if ( savedInstanceState . getBoolean ( SHOWING_SETTINGS_KEY ) ) { </a> 0
<a> showSettings ( ) ; </a> 0
<a> } else { </a> 0
<a> showProfile ( ) ; </a> 0
<a> } </a> 0
<a> SharedPreferencesTokenCachingStrategy restoredCache = new SharedPreferencesTokenCachingStrategy ( </a> 0
<a> this , </a> 0
<a> savedInstanceState . getString ( TOKEN_CACHE_NAME_KEY ) ) ; </a> 0
<a> currentSession = Session . restoreSession ( </a> 0
<a> this , </a> 0
<a> restoredCache , </a> 0
<a> sessionStatusCallback , </a> 0
<a> savedInstanceState ) ; </a> 0
<a> } else { </a> 0
<a> showProfile ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onBackPressed ( ) { </a> 0
<a> if ( isShowingSettings ( ) ) { </a> 0
<a> showProfile ( ) ; </a> 0
<a> } else { </a> 0
<a> super . onBackPressed ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onSaveInstanceState ( Bundle outState ) { </a> 0
<a> super . onSaveInstanceState ( outState ) ; </a> 0
<a> outState . putBoolean ( SHOWING_SETTINGS_KEY , isShowingSettings ( ) ) ; </a> 0
<a> if ( currentSlot != null ) { </a> 0
<a> outState . putString ( TOKEN_CACHE_NAME_KEY , currentSlot . getTokenCacheName ( ) ) ; </a> 0
<a> } </a> 0
<a> FragmentManager manager = getSupportFragmentManager ( ) ; </a> 0
<a> manager . putFragment ( outState , SettingsFragment . TAG , settingsFragment ) ; </a> 0
<a> manager . putFragment ( outState , ProfileFragment . TAG , profileFragment ) ; </a> 0
<a> Session . saveSession ( currentSession , outState ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onResume ( ) { </a> 0
<a> super . onResume ( ) ; </a> 0
<a> settingsFragment . setSlotChangedListener ( new SettingsFragment . OnSlotChangedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onSlotChanged ( Slot newSlot ) { </a> 0
<a> handleSlotChange ( newSlot ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> profileFragment . setOnOptionsItemSelectedListener ( new ProfileFragment . OnOptionsItemSelectedListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean onOptionsItemSelected ( MenuItem item ) { </a> 0
<a> return handleOptionsItemSelected ( item ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> if ( currentSession != null ) { </a> 0
<a> currentSession . addCallback ( sessionStatusCallback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void onPause ( ) { </a> 0
<a> super . onPause ( ) ; </a> 0
<a> settingsFragment . setSlotChangedListener ( null ) ; </a> 0
<a> profileFragment . setOnOptionsItemSelectedListener ( null ) ; </a> 0
<a> if ( currentSession != null ) { </a> 0
<a> currentSession . removeCallback ( sessionStatusCallback ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> super . onActivityResult ( requestCode , resultCode , data ) ; </a> 0
<a> if ( currentSession != null ) { </a> 0
<a> currentSession . onActivityResult ( this , requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void onSessionStateChange ( Session session , SessionState state , Exception exception ) { </a> 0
<a> if ( session != currentSession ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( state . isOpened ( ) ) { </a> 0
<a> fetchUserInfo ( ) ; </a> 0
<a> showProfile ( ) ; </a> 0
<a> } else if ( state . isClosed ( ) ) { </a> 0
<a> updateFragments ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void restoreFragments ( Bundle savedInstanceState ) { </a> 0
<a> FragmentManager manager = getSupportFragmentManager ( ) ; </a> 0
<a> FragmentTransaction transaction = manager . beginTransaction ( ) ; </a> 0
<a> if ( savedInstanceState != null ) { </a> 0
<a> profileFragment = ( ProfileFragment ) manager . getFragment ( savedInstanceState , ProfileFragment . TAG ) ; </a> 0
<a> settingsFragment = ( SettingsFragment ) manager . getFragment ( savedInstanceState , SettingsFragment . TAG ) ; </a> 0
<a> } </a> 0
<a> if ( profileFragment == null ) { </a> 0
<a> profileFragment = new ProfileFragment ( ) ; </a> 0
<a> transaction . add ( R . id . fragmentContainer , profileFragment , ProfileFragment . TAG ) ; </a> 0
<a> } </a> 0
<a> if ( settingsFragment == null ) { </a> 0
<a> settingsFragment = new SettingsFragment ( ) ; </a> 0
<a> transaction . add ( R . id . fragmentContainer , settingsFragment , SettingsFragment . TAG ) ; </a> 0
<a> } </a> 0
<a> transaction . commit ( ) ; </a> 0
<a> } </a> 0
<a> private void showSettings ( ) { </a> 0
<a> isShowingSettings = true ; </a> 0
<a> FragmentTransaction transaction = getSupportFragmentManager ( ) . beginTransaction ( ) ; </a> 0
<a> transaction . hide ( profileFragment ) </a> 0
<a> . show ( settingsFragment ) </a> 0
<a> . commit ( ) ; </a> 0
<a> } </a> 0
<a> private boolean isShowingSettings ( ) { </a> 0
<a> return isShowingSettings ; </a> 0
<a> } </a> 0
<a> private void showProfile ( ) { </a> 0
<a> isShowingSettings = false ; </a> 0
<a> FragmentTransaction transaction = getSupportFragmentManager ( ) . beginTransaction ( ) ; </a> 0
<a> transaction . hide ( settingsFragment ) </a> 0
<a> . show ( profileFragment ) </a> 0
<a> . commit ( ) ; </a> 0
<a> } </a> 0
<a> private void fetchUserInfo ( ) { </a> 0
<a> if ( currentSession != null && currentSession . isOpened ( ) ) { </a> 0
<a> Request request = Request . newMeRequest ( currentSession , new Request . GraphUserCallback ( ) { </a> 0
<a> @ Override </a> 0
<a> public void onCompleted ( GraphUser me , Response response ) { </a> 0
<a> if ( response . getRequest ( ) . getSession ( ) == currentSession ) { </a> 0
<a> updateFragments ( me ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> request . executeAsync ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void handleSlotChange ( Slot newSlot ) { </a> 0
<a> if ( currentSession != null ) { </a> 0
<a> currentSession . close ( ) ; </a> 0
<a> currentSession = null ; </a> 0
<a> } </a> 0
<a> if ( newSlot != null ) { </a> 0
<a> currentSlot = newSlot ; </a> 0
<a> currentSession = new Session . Builder ( this ) </a> 0
<a> . setTokenCachingStrategy ( currentSlot . getTokenCache ( ) ) </a> 0
<a> . build ( ) ; </a> 0
<a> currentSession . addCallback ( sessionStatusCallback ) ; </a> 0
<a> Session . OpenRequest openRequest = new Session . OpenRequest ( this ) ; </a> 0
<a> openRequest . setLoginBehavior ( newSlot . getLoginBehavior ( ) ) ; </a> 0
<a> openRequest . setRequestCode ( Session . DEFAULT_AUTHORIZE_ACTIVITY_CODE ) ; </a> 0
<a> currentSession . openForRead ( openRequest ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean handleOptionsItemSelected ( MenuItem item ) { </a> 0
<a> switch ( item . getItemId ( ) ) { </a> 0
<a> case R . id . menu_item_switch : </a> 0
<a> showSettings ( ) ; </a> 0
<a> return true ; </a> 0
<a> default : </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void updateFragments ( GraphUser user ) { </a> 0
<a> settingsFragment . updateViewForUser ( user ) ; </a> 0
<a> profileFragment . updateViewForUser ( user ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . switchuser ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . Fragment ; </a> 0
<a> import android . view . * ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import com . facebook . widget . ProfilePictureView ; </a> 0
<a> public class ProfileFragment extends Fragment { </a> 0
<a> public static final String TAG = "ProfileFragment" ; </a> 0
<a> private TextView userNameView ; </a> 0
<a> private ProfilePictureView profilePictureView ; </a> 0
<a> private OnOptionsItemSelectedListener onOptionsItemSelectedListener ; </a> 0
<a> private GraphUser pendingUpdateForUser ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setHasOptionsMenu ( true ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { </a> 0
<a> super . onCreateOptionsMenu ( menu , inflater ) ; </a> 0
<a> inflater . inflate ( R . menu . options_profile , menu ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean onOptionsItemSelected ( MenuItem item ) { </a> 0
<a> boolean handled = false ; </a> 0
<a> OnOptionsItemSelectedListener listener = onOptionsItemSelectedListener ; </a> 0
<a> if ( listener != null ) { </a> 0
<a> handled = listener . onOptionsItemSelected ( item ) ; </a> 0
<a> } </a> 0
<a> if ( ! handled ) { </a> 0
<a> handled = super . onOptionsItemSelected ( item ) ; </a> 0
<a> } </a> 0
<a> return handled ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View onCreateView ( LayoutInflater inflater , ViewGroup parent , Bundle savedInstanceState ) { </a> 0
<a> View v = inflater . inflate ( R . layout . fragment_profile , parent , false ) ; </a> 0
<a> userNameView = ( TextView ) v . findViewById ( R . id . profileUserName ) ; </a> 0
<a> profilePictureView = ( ProfilePictureView ) v . findViewById ( R . id . profilePic ) ; </a> 0
<a> if ( pendingUpdateForUser != null ) { </a> 0
<a> updateViewForUser ( pendingUpdateForUser ) ; </a> 0
<a> pendingUpdateForUser = null ; </a> 0
<a> } </a> 0
<a> return v ; </a> 0
<a> } </a> 0
<a> public void setOnOptionsItemSelectedListener ( OnOptionsItemSelectedListener listener ) { </a> 0
<a> this . onOptionsItemSelectedListener = listener ; </a> 0
<a> } </a> 0
<a> public void updateViewForUser ( GraphUser user ) { </a> 0
<a> if ( userNameView == null || profilePictureView == null || ! isAdded ( ) ) { </a> 0
<a> pendingUpdateForUser = user ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( user == null ) { </a> 0
<a> profilePictureView . setProfileId ( null ) ; </a> 0
<a> userNameView . setText ( R . string . greeting_no_user ) ; </a> 0
<a> } else { </a> 0
<a> profilePictureView . setProfileId ( user . getId ( ) ) ; </a> 0
<a> userNameView . setText ( </a> 0
<a> String . format ( getString ( R . string . greeting_format ) , user . getFirstName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public interface OnOptionsItemSelectedListener { </a> 0
<a> boolean onOptionsItemSelected ( MenuItem item ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . samples . switchuser ; </a> 0
<a> import android . content . Context ; </a> 0
<a> import android . content . SharedPreferences ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . support . v4 . app . ListFragment ; </a> 0
<a> import android . view . * ; </a> 0
<a> import android . widget . * ; </a> 0
<a> import com . facebook . model . GraphUser ; </a> 0
<a> import com . facebook . widget . ProfilePictureView ; </a> 0
<a> import com . facebook . SessionLoginBehavior ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> public class SettingsFragment extends ListFragment { </a> 0
<a> public static final String TAG = "SettingsFragment" ; </a> 0
<a> private static final String CURRENT_SLOT_KEY = "CurrentSlot" ; </a> 0
<a> private SlotManager slotManager ; </a> 0
<a> private OnSlotChangedListener slotChangedListener ; </a> 0
<a> private boolean hasPendingNotifySlotChanged ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> slotManager = new SlotManager ( ) ; </a> 0
<a> slotManager . restore ( </a> 0
<a> getActivity ( ) , </a> 0
<a> savedInstanceState != null ? </a> 0
<a> savedInstanceState . getInt ( CURRENT_SLOT_KEY , SlotManager . NO_SLOT ) : </a> 0
<a> SlotManager . NO_SLOT ) ; </a> 0
<a> ArrayList < Slot > slotList = new ArrayList < Slot > ( </a> 0
<a> Arrays . asList ( slotManager . getAllSlots ( ) ) ) ; </a> 0
<a> setListAdapter ( new SlotAdapter ( slotList ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View onCreateView ( LayoutInflater inflater , ViewGroup parent , Bundle savedInstanceState ) { </a> 0
<a> View view = super . onCreateView ( inflater , parent , savedInstanceState ) ; </a> 0
<a> registerForContextMenu ( view . findViewById ( android . R . id . list ) ) ; </a> 0
<a> return view ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onCreateContextMenu ( ContextMenu menu , View view , ContextMenu . ContextMenuInfo menuInfo ) { </a> 0
<a> super . onCreateContextMenu ( menu , view , menuInfo ) ; </a> 0
<a> getActivity ( ) . getMenuInflater ( ) . inflate ( R . menu . context_settings , menu ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onListItemClick ( ListView l , View view , int position , long id ) { </a> 0
<a> slotManager . toggleSlot ( position ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean onContextItemSelected ( MenuItem item ) { </a> 0
<a> AdapterView . AdapterContextMenuInfo info = ( AdapterView . AdapterContextMenuInfo ) item . getMenuInfo ( ) ; </a> 0
<a> SlotAdapter adapter = ( SlotAdapter ) getListAdapter ( ) ; </a> 0
<a> Slot slot = adapter . getItem ( info . position ) ; </a> 0
<a> switch ( item . getItemId ( ) ) { </a> 0
<a> case R . id . menu_item_clear_slot : </a> 0
<a> if ( slot . getUserId ( ) != null ) { </a> 0
<a> slot . clear ( ) ; </a> 0
<a> if ( slot == slotManager . getSelectedSlot ( ) ) { </a> 0
<a> slotManager . toggleSlot ( info . position ) ; </a> 0
<a> } </a> 0
<a> updateListView ( ) ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> return super . onContextItemSelected ( item ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onSaveInstanceState ( Bundle outState ) { </a> 0
<a> super . onSaveInstanceState ( outState ) ; </a> 0
<a> outState . putInt ( CURRENT_SLOT_KEY , slotManager . getSelectedSlotNumber ( ) ) ; </a> 0
<a> } </a> 0
<a> public void setSlotChangedListener ( OnSlotChangedListener listener ) { </a> 0
<a> slotChangedListener = listener ; </a> 0
<a> if ( listener != null && hasPendingNotifySlotChanged ) { </a> 0
<a> notifySlotChanged ( ) ; </a> 0
<a> hasPendingNotifySlotChanged = false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void updateViewForUser ( GraphUser user ) { </a> 0
<a> if ( slotManager == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( user != null ) { </a> 0
<a> Slot s = slotManager . getSelectedSlot ( ) ; </a> 0
<a> if ( s != null ) { </a> 0
<a> s . update ( user ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> slotManager . setSelectedSlotNumber ( SlotManager . NO_SLOT ) ; </a> 0
<a> } </a> 0
<a> updateListView ( ) ; </a> 0
<a> } </a> 0
<a> private void notifySlotChanged ( ) { </a> 0
<a> OnSlotChangedListener listener = slotChangedListener ; </a> 0
<a> if ( listener != null ) { </a> 0
<a> Slot newSlot = slotManager . getSelectedSlot ( ) ; </a> 0
<a> listener . onSlotChanged ( newSlot ) ; </a> 0
<a> } else { </a> 0
<a> hasPendingNotifySlotChanged = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void updateListView ( ) { </a> 0
<a> SlotAdapter adapter = ( SlotAdapter ) getListAdapter ( ) ; </a> 0
<a> adapter . notifyDataSetChanged ( ) ; </a> 0
<a> } </a> 0
<a> public interface OnSlotChangedListener { </a> 0
<a> void onSlotChanged ( Slot newSlot ) ; </a> 0
<a> } </a> 0
<a> private class SlotAdapter extends ArrayAdapter < Slot > { </a> 0
<a> public SlotAdapter ( ArrayList < Slot > slots ) { </a> 0
<a> super ( getActivity ( ) , android . R . layout . simple_list_item_1 , slots ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public View getView ( int position , View convertView , ViewGroup parent ) { </a> 0
<a> if ( null == convertView ) { </a> 0
<a> convertView = getActivity ( ) . getLayoutInflater ( ) </a> 0
<a> . inflate ( R . layout . list_item_user , null ) ; </a> 0
<a> } </a> 0
<a> Slot slot = getItem ( position ) ; </a> 0
<a> String userName = slot . getUserName ( ) ; </a> 0
<a> if ( userName == null ) { </a> 0
<a> userName = getString ( R . string . empty_slot ) ; </a> 0
<a> } </a> 0
<a> ProfilePictureView profilePictureView = ( ProfilePictureView ) convertView . findViewById ( </a> 0
<a> R . id . slotPic ) ; </a> 0
<a> profilePictureView . setCropped ( true ) ; </a> 0
<a> profilePictureView . setProfileId ( slot . getUserId ( ) ) ; </a> 0
<a> TextView userNameTextView = ( TextView ) convertView . findViewById ( </a> 0
<a> R . id . slotUserName ) ; </a> 0
<a> userNameTextView . setText ( userName ) ; </a> 0
<a> CheckBox currentUserCheckBox = ( CheckBox ) convertView . findViewById ( </a> 0
<a> R . id . currentUserIndicator ) ; </a> 0
<a> currentUserCheckBox . setChecked ( slotManager . getSelectedSlot ( ) == slot ) ; </a> 0
<a> return convertView ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class SlotManager { </a> 0
<a> static final int NO_SLOT = - 1 ; </a> 0
<a> private final static int MAX_SLOTS = 4 ; </a> 0
<a> private static final String SETTINGS_CURRENT_SLOT_KEY = "CurrentSlot" ; </a> 0
<a> private static final String SETTINGS_NAME = "UserManagerSettings" ; </a> 0
<a> private SharedPreferences settings ; </a> 0
<a> private int selectedSlotNumber = NO_SLOT ; </a> 0
<a> private Slot [ ] slots ; </a> 0
<a> void restore ( Context context , int oldSelectedSlot ) { </a> 0
<a> if ( context == null ) { </a> 0
<a> throw new IllegalArgumentException ( "context cannot be null" ) ; </a> 0
<a> } </a> 0
<a> Context applicationContext = context . getApplicationContext ( ) ; </a> 0
<a> applicationContext = ( applicationContext == null ) ? context : applicationContext ; </a> 0
<a> slots = new Slot [ MAX_SLOTS ] ; </a> 0
<a> for ( int i = 0 ; i < MAX_SLOTS ; i ++ ) { </a> 0
<a> SessionLoginBehavior loginBehavior = ( i == 0 ) ? </a> 0
<a> SessionLoginBehavior . SSO_WITH_FALLBACK : </a> 0
<a> SessionLoginBehavior . SUPPRESS_SSO ; </a> 0
<a> slots [ i ] = new Slot ( applicationContext , i , loginBehavior ) ; </a> 0
<a> } </a> 0
<a> settings = applicationContext . getSharedPreferences ( SETTINGS_NAME , Context . MODE_PRIVATE ) ; </a> 0
<a> int savedSlotNumber = settings . getInt ( SETTINGS_CURRENT_SLOT_KEY , NO_SLOT ) ; </a> 0
<a> if ( savedSlotNumber != NO_SLOT && savedSlotNumber != oldSelectedSlot ) { </a> 0
<a> toggleSlot ( savedSlotNumber ) ; </a> 0
<a> } else { </a> 0
<a> setSelectedSlotNumber ( savedSlotNumber ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void toggleSlot ( int slot ) { </a> 0
<a> validateSlot ( slot ) ; </a> 0
<a> if ( slot == selectedSlotNumber ) { </a> 0
<a> setSelectedSlotNumber ( NO_SLOT ) ; </a> 0
<a> } else { </a> 0
<a> setSelectedSlotNumber ( slot ) ; </a> 0
<a> } </a> 0
<a> notifySlotChanged ( ) ; </a> 0
<a> } </a> 0
<a> Slot getSelectedSlot ( ) { </a> 0
<a> if ( selectedSlotNumber == NO_SLOT ) { </a> 0
<a> return null ; </a> 0
<a> } else { </a> 0
<a> return getSlot ( selectedSlotNumber ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int getSelectedSlotNumber ( ) { </a> 0
<a> return selectedSlotNumber ; </a> 0
<a> } </a> 0
<a> Slot [ ] getAllSlots ( ) { </a> 0
<a> return slots ; </a> 0
<a> } </a> 0
<a> Slot getSlot ( int slot ) { </a> 0
<a> validateSlot ( slot ) ; </a> 0
<a> return slots [ slot ] ; </a> 0
<a> } </a> 0
<a> private void setSelectedSlotNumber ( int slot ) { </a> 0
<a> settings . edit ( ) . putInt ( SETTINGS_CURRENT_SLOT_KEY , slot ) . commit ( ) ; </a> 0
<a> selectedSlotNumber = slot ; </a> 0
<a> } </a> 0
<a> private void validateSlot ( int slot ) { </a> 0
<a> if ( slot <= NO_SLOT || slot >= MAX_SLOTS ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> String . format ( "Choose a slot between 0 and %d inclusively" , MAX_SLOTS - 1 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package com . facebook . android . tests ; </a> 0
<a> import java . io . FileNotFoundException ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . MalformedURLException ; </a> 0
<a> import org . json . JSONObject ; </a> 0
<a> import com . facebook . android . AsyncFacebookRunner ; </a> 0
<a> import com . facebook . android . DialogError ; </a> 0
<a> import com . facebook . android . Facebook ; </a> 0
<a> import com . facebook . android . FacebookError ; </a> 0
<a> import com . facebook . android . Util ; </a> 0
<a> import com . facebook . android . AsyncFacebookRunner . RequestListener ; </a> 0
<a> import com . facebook . android . Facebook . DialogListener ; </a> 0
<a> import android . app . Activity ; </a> 0
<a> import android . content . Intent ; </a> 0
<a> import android . graphics . Color ; </a> 0
<a> import android . os . Bundle ; </a> 0
<a> import android . util . Log ; </a> 0
<a> import android . view . View ; </a> 0
<a> import android . view . View . OnClickListener ; </a> 0
<a> import android . widget . Button ; </a> 0
<a> import android . widget . TextView ; </a> 0
<a> public class Tests extends Activity { </a> 0
<a> public static final String APP_ID = "110862205611506" ; </a> 0
<a> private static final String [ ] PERMISSIONS = </a> 0
<a> new String [ ] { "publish_stream" , "read_stream" , "offline_access" } ; </a> 0
<a> TextView publicTestsText ; </a> 0
<a> TextView publicErrorsText ; </a> 0
<a> Button loginButton ; </a> 0
<a> TextView authenticatedTestsText ; </a> 0
<a> TextView authenticatedErrorsText ; </a> 0
<a> Button postButton ; </a> 0
<a> TextView wallPostText ; </a> 0
<a> TextView deletedPostText ; </a> 0
<a> Button logoutButton ; </a> 0
<a> TextView logoutText ; </a> 0
<a> Facebook authenticatedFacebook = new Facebook ( APP_ID ) ; </a> 0
<a> @ Override </a> 0
<a> public void onCreate ( Bundle savedInstanceState ) { </a> 0
<a> super . onCreate ( savedInstanceState ) ; </a> 0
<a> setContentView ( R . layout . main ) ; </a> 0
<a> publicTestsText = ( TextView ) findViewById ( R . id . publicTests ) ; </a> 0
<a> publicErrorsText = ( TextView ) findViewById ( R . id . publicErrors ) ; </a> 0
<a> loginButton = ( Button ) findViewById ( R . id . login ) ; </a> 0
<a> authenticatedTestsText = ( TextView ) findViewById ( </a> 0
<a> R . id . authenticatedTests ) ; </a> 0
<a> authenticatedErrorsText = ( TextView ) findViewById ( </a> 0
<a> R . id . authenticatedErrors ) ; </a> 0
<a> postButton = ( Button ) findViewById ( R . id . post ) ; </a> 0
<a> wallPostText = ( TextView ) findViewById ( R . id . wallPost ) ; </a> 0
<a> deletedPostText = ( TextView ) findViewById ( R . id . deletedPost ) ; </a> 0
<a> logoutButton = ( Button ) findViewById ( R . id . logout ) ; </a> 0
<a> logoutText = ( TextView ) findViewById ( R . id . logoutTest ) ; </a> 0
<a> loginButton . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> authenticatedFacebook . authorize ( Tests . this , PERMISSIONS , </a> 0
<a> new TestLoginListener ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> postButton . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> authenticatedFacebook . dialog ( Tests . this , "stream.publish" , </a> 0
<a> new TestUiServerListener ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> logoutButton . setOnClickListener ( new OnClickListener ( ) { </a> 0
<a> public void onClick ( View v ) { </a> 0
<a> runTestLogout ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> runTestPublicApi ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void onActivityResult ( int requestCode , int resultCode , Intent data ) { </a> 0
<a> authenticatedFacebook . authorizeCallback ( requestCode , resultCode , data ) ; </a> 0
<a> } </a> 0
<a> public void runTestPublicApi ( ) { </a> 0
<a> if ( testPublicApi ( ) ) { </a> 0
<a> publicTestsText . setText ( "Public API tests passed" ) ; </a> 0
<a> publicTestsText . setTextColor ( Color . GREEN ) ; </a> 0
<a> } else { </a> 0
<a> publicTestsText . setText ( "Public API tests failed" ) ; </a> 0
<a> publicTestsText . setTextColor ( Color . RED ) ; </a> 0
<a> } </a> 0
<a> if ( testPublicErrors ( ) ) { </a> 0
<a> publicErrorsText . setText ( "Public API errors passed" ) ; </a> 0
<a> publicErrorsText . setTextColor ( Color . GREEN ) ; </a> 0
<a> } else { </a> 0
<a> publicErrorsText . setText ( "Public API errors failed" ) ; </a> 0
<a> publicErrorsText . setTextColor ( Color . RED ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public boolean testPublicApi ( ) { </a> 0
<a> Facebook fb = new Facebook ( APP_ID ) ; </a> 0
<a> try { </a> 0
<a> Log . d ( "Tests" , "Testing standard API call" ) ; </a> 0
<a> JSONObject response = Util . parseJson ( fb . request ( "4" ) ) ; </a> 0
<a> if ( ! response . getString ( "name" ) . equals ( "Mark Zuckerberg" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing an API call with a specific method" ) ; </a> 0
<a> response = Util . parseJson ( </a> 0
<a> fb . request ( "soneff" , new Bundle ( ) , "GET" ) ) ; </a> 0
<a> if ( ! response . getString ( "name" ) . equals ( "Steven Soneff" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing a public search query" ) ; </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "q" , "facebook" ) ; </a> 0
<a> response = Util . parseJson ( fb . request ( "search" , params ) ) ; </a> 0
<a> if ( response . getJSONArray ( "data" ) . length ( ) == 0 ) return false ; </a> 0
<a> Log . d ( "Tests" , "Public API Tests passed" ) ; </a> 0
<a> return true ; </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public boolean testPublicErrors ( ) { </a> 0
<a> Facebook fb = new Facebook ( APP_ID ) ; </a> 0
<a> try { </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> Log . d ( "Tests" , "Testing illegal post" ) ; </a> 0
<a> params . putString ( "message" , "Hello World" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( fb . request ( "4" , params , "POST" ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( ! e . getMessage ( ) . equals ( "Unsupported post request." ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing illegal delete" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( fb . request ( "4" , new Bundle ( ) , "DELETE" ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( ! e . getMessage ( ) . equals ( </a> 0
<a> "An access token is required to request this " + </a> 0
<a> "resource." ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing illegal post to Zuck's feed" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( fb . request ( "4/feed" , new Bundle ( ) , "POST" ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( ! e . getMessage ( ) . equals ( "(#200) The user hasn't " + </a> 0
<a> "authorized the application to perform this action" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing invalidly specified parameters" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( fb . request ( "bgolub?fields=id,name,picture" ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( ! e . getMessage ( ) . startsWith ( "Unknown fields: picture?" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing request for 'me' is rejected without " + </a> 0
<a> "access_token" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( fb . request ( "me" ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( ! e . getMessage ( ) . equals ( </a> 0
<a> "An active access token must be used to " + </a> 0
<a> "query information about the current user." ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing empty request" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( fb . request ( "" ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( ! e . getMessage ( ) . equals ( "Unsupported get request." ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing an invalid path" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( fb . request ( "invalidinvalidinvalidinvalid" ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( ! e . getMessage ( ) . equals ( </a> 0
<a> "(#803) Some of the aliases you requested do not " + </a> 0
<a> "exist: invalidinvalidinvalidinvalid" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing missing query parameter" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( fb . request ( "search" , new Bundle ( ) , "GET" ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( ! e . getMessage ( ) . equals ( "No node specified" ) ) return false ; </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing that API method is specified" ) ; </a> 0
<a> try { </a> 0
<a> fb . request ( new Bundle ( ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( IllegalArgumentException e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( ! e . getMessage ( ) . equals ( </a> 0
<a> "API method must be specified. " + </a> 0
<a> "(parameters must contain key \"method\" " + </a> 0
<a> "and value). See http://developers.facebook." + </a> 0
<a> "com/docs/reference/rest/" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing that old API request cannot be made " + </a> 0
<a> "without access token" ) ; </a> 0
<a> params . putString ( "method" , "stream.publish" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( fb . request ( params ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( e . getErrorCode ( ) != 101 || </a> 0
<a> ! e . getMessage ( ) . equals ( "Invalid API key" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing invalid access token" ) ; </a> 0
<a> try { </a> 0
<a> fb . setAccessToken ( "invalid" ) ; </a> 0
<a> Util . parseJson ( fb . request ( "me" , new Bundle ( ) , "GET" ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( ! e . getMessage ( ) . equals ( "Invalid OAuth access token." ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Public API Error Tests passed" ) ; </a> 0
<a> return true ; </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class TestLoginListener implements DialogListener { </a> 0
<a> public void onComplete ( Bundle values ) { </a> 0
<a> if ( testAuthenticatedApi ( ) ) { </a> 0
<a> authenticatedTestsText . setText ( </a> 0
<a> "Authenticated API tests passed" ) ; </a> 0
<a> authenticatedTestsText . setTextColor ( Color . GREEN ) ; </a> 0
<a> } else { </a> 0
<a> authenticatedTestsText . setText ( </a> 0
<a> "Authenticated API tests failed" ) ; </a> 0
<a> authenticatedTestsText . setTextColor ( Color . RED ) ; </a> 0
<a> } </a> 0
<a> if ( testAuthenticatedErrors ( ) ) { </a> 0
<a> authenticatedErrorsText . setText ( </a> 0
<a> "Authenticated API errors passed" ) ; </a> 0
<a> authenticatedErrorsText . setTextColor ( Color . GREEN ) ; </a> 0
<a> } else { </a> 0
<a> authenticatedErrorsText . setText ( </a> 0
<a> "Authenticated API errors failed" ) ; </a> 0
<a> authenticatedErrorsText . setTextColor ( Color . RED ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onCancel ( ) { </a> 0
<a> } </a> 0
<a> public void onError ( DialogError e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public boolean testAuthenticatedApi ( ) { </a> 0
<a> if ( ! authenticatedFacebook . isSessionValid ( ) ) return false ; </a> 0
<a> try { </a> 0
<a> Log . d ( "Tests" , "Testing request for 'me'" ) ; </a> 0
<a> String response = authenticatedFacebook . request ( "me" ) ; </a> 0
<a> JSONObject obj = Util . parseJson ( response ) ; </a> 0
<a> if ( obj . getString ( "name" ) == null || </a> 0
<a> obj . getString ( "name" ) . equals ( "" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing graph API wall post" ) ; </a> 0
<a> Bundle parameters = new Bundle ( ) ; </a> 0
<a> parameters . putString ( "message" , "hello world" ) ; </a> 0
<a> parameters . putString ( "description" , "test test test" ) ; </a> 0
<a> response = authenticatedFacebook . request ( "me/feed" , parameters , </a> 0
<a> "POST" ) ; </a> 0
<a> Log . d ( "Tests" , "got response: " + response ) ; </a> 0
<a> if ( response == null || response . equals ( "" ) || </a> 0
<a> response . equals ( "false" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing graph API delete" ) ; </a> 0
<a> response = response . replaceAll ( "\\{\"id\":\"" , "" ) ; </a> 0
<a> response = response . replaceAll ( "\"\\}" , "" ) ; </a> 0
<a> response = authenticatedFacebook . request ( response , new Bundle ( ) , </a> 0
<a> "DELETE" ) ; </a> 0
<a> if ( ! response . equals ( "true" ) ) return false ; </a> 0
<a> Log . d ( "Tests" , "Testing old API wall post" ) ; </a> 0
<a> parameters = new Bundle ( ) ; </a> 0
<a> parameters . putString ( "method" , "stream.publish" ) ; </a> 0
<a> parameters . putString ( "attachment" , </a> 0
<a> "{\"name\":\"Name=Title\"," + </a> 0
<a> "\"href\":\"http://www.google.fr/\",\"" + </a> 0
<a> "caption\":\"Caption\",\"description\":\"Description" + </a> 0
<a> "\",\"media\":[{\"type\":\"image\",\"src\":" + </a> 0
<a> "\"http://www.kratiroff.com/logo-facebook.jpg\"," + </a> 0
<a> "\"href\":\"http://developers.facebook.com/\"}]," + </a> 0
<a> "\"properties\":{\"another link\":{\"text\":\"" + </a> 0
<a> "Facebook homepage\",\"href\":\"http://www.facebook." + </a> 0
<a> "com\"}}}" ) ; ; </a> 0
<a> response = authenticatedFacebook . request ( parameters ) ; </a> 0
<a> Log . d ( "Tests" , "got response: " + response ) ; </a> 0
<a> if ( response == null || response . equals ( "" ) || </a> 0
<a> response . equals ( "false" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing wall post delete" ) ; </a> 0
<a> response = response . replaceAll ( "\"" , "" ) ; </a> 0
<a> response = authenticatedFacebook . request ( </a> 0
<a> response , new Bundle ( ) , "DELETE" ) ; </a> 0
<a> if ( ! response . equals ( "true" ) ) return false ; </a> 0
<a> Log . d ( "Tests" , "All Authenticated Tests Passed" ) ; </a> 0
<a> return true ; </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public boolean testAuthenticatedErrors ( ) { </a> 0
<a> if ( ! authenticatedFacebook . isSessionValid ( ) ) return false ; </a> 0
<a> Log . d ( "Tests" , "Testing that request for 'me/invalid' is rejected" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( authenticatedFacebook . request ( "me/invalid" ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( ! e . getMessage ( ) . equals ( "Unknown path components: /invalid" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing that old API call with invalid method fails" ) ; </a> 0
<a> Bundle params = new Bundle ( ) ; </a> 0
<a> params . putString ( "method" , "something_invalid" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( authenticatedFacebook . request ( params ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> Log . d ( "Tests" , "*" + e . getMessage ( ) + "*" ) ; </a> 0
<a> if ( ! e . getMessage ( ) . equals ( "Unknown method" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "All Authenticated Error Tests Passed" ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public class TestUiServerListener implements DialogListener { </a> 0
<a> public void onComplete ( Bundle values ) { </a> 0
<a> final String postId = values . getString ( "post_id" ) ; </a> 0
<a> if ( postId != null ) { </a> 0
<a> Log . d ( "Facebook-Example" , "Dialog Success! post_id=" + postId ) ; </a> 0
<a> new AsyncFacebookRunner ( authenticatedFacebook ) . request ( postId , </a> 0
<a> new TestPostRequestListener ( ) ) ; </a> 0
<a> } else { </a> 0
<a> Tests . this . runOnUiThread ( new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> wallPostText . setText ( "Wall Post Failure" ) ; </a> 0
<a> wallPostText . setTextColor ( Color . RED ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onCancel ( ) { } </a> 0
<a> public void onError ( DialogError e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public class TestPostRequestListener implements RequestListener { </a> 0
<a> public void onComplete ( final String response , final Object state ) { </a> 0
<a> Log . d ( "Tests" , "Got response: " + response ) ; </a> 0
<a> try { </a> 0
<a> JSONObject json = Util . parseJson ( response ) ; </a> 0
<a> String postId = json . getString ( "id" ) ; </a> 0
<a> Tests . this . runOnUiThread ( new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> wallPostText . setText ( "Wall Post Success" ) ; </a> 0
<a> wallPostText . setTextColor ( Color . GREEN ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Log . d ( "Tests" , "Testing wall post delete" ) ; </a> 0
<a> if ( testPostDelete ( postId ) ) { </a> 0
<a> Tests . this . runOnUiThread ( new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> deletedPostText . setText ( "Deleted Post Success" ) ; </a> 0
<a> deletedPostText . setTextColor ( Color . GREEN ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } else { </a> 0
<a> Tests . this . runOnUiThread ( new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> deletedPostText . setText ( "Deleted Post Failure" ) ; </a> 0
<a> deletedPostText . setTextColor ( Color . RED ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> Tests . this . runOnUiThread ( new Runnable ( ) { </a> 0
<a> public void run ( ) { </a> 0
<a> wallPostText . setText ( "Wall Post Failure" ) ; </a> 0
<a> wallPostText . setTextColor ( Color . RED ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void onFacebookError ( FacebookError e , final Object state ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> public void onFileNotFoundException ( FileNotFoundException e , </a> 0
<a> final Object state ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> public void onIOException ( IOException e , final Object state ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> public void onMalformedURLException ( MalformedURLException e , </a> 0
<a> final Object state ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public boolean testPostDelete ( String postId ) { </a> 0
<a> try { </a> 0
<a> String deleteResponse = </a> 0
<a> authenticatedFacebook . request ( postId , new Bundle ( ) , "DELETE" ) ; </a> 0
<a> return deleteResponse . equals ( "true" ) ; </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void runTestLogout ( ) { </a> 0
<a> if ( testLogout ( ) ) { </a> 0
<a> logoutText . setText ( "Logout Tests Passed" ) ; </a> 0
<a> logoutText . setTextColor ( Color . GREEN ) ; </a> 0
<a> } else { </a> 0
<a> logoutText . setText ( "Logout Tests Failed" ) ; </a> 0
<a> logoutText . setTextColor ( Color . RED ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public boolean testLogout ( ) { </a> 0
<a> try { </a> 0
<a> Log . d ( "Tests" , "Testing logout" ) ; </a> 0
<a> String response = authenticatedFacebook . logout ( this ) ; </a> 0
<a> Log . d ( "Tests" , "Got logout response: *" + response + "*" ) ; </a> 0
<a> if ( ! response . equals ( "true" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing logout on logged out facebook session" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( authenticatedFacebook . logout ( this ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> if ( e . getErrorCode ( ) != 101 || </a> 0
<a> ! e . getMessage ( ) . equals ( "Invalid API key" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "Testing logout on unauthenticated object" ) ; </a> 0
<a> try { </a> 0
<a> Util . parseJson ( new Facebook ( APP_ID ) . logout ( this ) ) ; </a> 0
<a> return false ; </a> 0
<a> } catch ( FacebookError e ) { </a> 0
<a> if ( e . getErrorCode ( ) != 101 || </a> 0
<a> ! e . getMessage ( ) . equals ( "Invalid API key" ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Log . d ( "Tests" , "All Logout Tests Passed" ) ; </a> 0
<a> return true ; </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> e . printStackTrace ( ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . ByteOrder ; </a> 0
<a> import java . nio . channels . GatheringByteChannel ; </a> 0
<a> import java . nio . channels . ScatteringByteChannel ; </a> 0
<a> import java . nio . charset . Charset ; </a> 0
<a> public abstract class AbstractByteBuf implements ByteBuf { </a> 1
<a> private final SwappedByteBuf swappedBuf ; </a> 1
<a> private final ByteOrder order ; </a> 1
<a> private final int maxCapacity ; </a> 1
<a> private int readerIndex ; </a> 1
<a> private int writerIndex ; </a> 0
<a> private int markedReaderIndex ; </a> 0
<a> private int markedWriterIndex ; </a> 0
<a> int refCnt = 1 ; </a> 1
<a> protected AbstractByteBuf ( ByteOrder endianness , int maxCapacity ) { </a> 1
<a> if ( endianness == null ) { </a> 0
<a> throw new NullPointerException ( "endianness" ) ; </a> 0
<a> } </a> 0
<a> if ( maxCapacity < 0 ) { </a> 1
<a> throw new IllegalArgumentException ( "maxCapacity: " + maxCapacity + " (expected: >= 0)" ) ; </a> 1
<a> } </a> 1
<a> order = endianness ; </a> 1
<a> swappedBuf = new SwappedByteBuf ( this ) ; </a> 1
<a> this . maxCapacity = maxCapacity ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isPooled ( ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelBufType type ( ) { </a> 1
<a> return ChannelBufType . BYTE ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int maxCapacity ( ) { </a> 0
<a> return maxCapacity ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readerIndex ( ) { </a> 0
<a> return readerIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readerIndex ( int readerIndex ) { </a> 0
<a> if ( readerIndex < 0 || readerIndex > writerIndex ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Invalid readerIndex: " </a> 0
<a> + readerIndex + " - Maximum is " + writerIndex ) ; </a> 0
<a> } </a> 0
<a> this . readerIndex = readerIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int writerIndex ( ) { </a> 0
<a> return writerIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writerIndex ( int writerIndex ) { </a> 0
<a> if ( writerIndex < readerIndex || writerIndex > capacity ( ) ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Invalid writerIndex: " </a> 0
<a> + writerIndex + " - Maximum is " + readerIndex + " or " + capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> this . writerIndex = writerIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setIndex ( int readerIndex , int writerIndex ) { </a> 0
<a> if ( readerIndex < 0 || readerIndex > writerIndex || writerIndex > capacity ( ) ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Invalid indexes: readerIndex is " </a> 0
<a> + readerIndex + ", writerIndex is " </a> 0
<a> + writerIndex + ", capacity is " + capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> this . readerIndex = readerIndex ; </a> 0
<a> this . writerIndex = writerIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clear ( ) { </a> 0
<a> readerIndex = writerIndex = 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readable ( ) { </a> 0
<a> return writerIndex > readerIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean writable ( ) { </a> 0
<a> return writableBytes ( ) > 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readableBytes ( ) { </a> 0
<a> return writerIndex - readerIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int writableBytes ( ) { </a> 0
<a> return capacity ( ) - writerIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void markReaderIndex ( ) { </a> 0
<a> markedReaderIndex = readerIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void resetReaderIndex ( ) { </a> 0
<a> readerIndex ( markedReaderIndex ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void markWriterIndex ( ) { </a> 0
<a> markedWriterIndex = writerIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void resetWriterIndex ( ) { </a> 0
<a> writerIndex = markedWriterIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void discardReadBytes ( ) { </a> 0
<a> if ( readerIndex == 0 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( readerIndex != writerIndex ) { </a> 0
<a> setBytes ( 0 , this , readerIndex , writerIndex - readerIndex ) ; </a> 0
<a> writerIndex -= readerIndex ; </a> 0
<a> adjustMarkers ( readerIndex ) ; </a> 0
<a> readerIndex = 0 ; </a> 0
<a> } else { </a> 0
<a> adjustMarkers ( readerIndex ) ; </a> 0
<a> writerIndex = readerIndex = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void adjustMarkers ( int decrement ) { </a> 0
<a> markedReaderIndex = Math . max ( markedReaderIndex - decrement , 0 ) ; </a> 0
<a> markedWriterIndex = Math . max ( markedWriterIndex - decrement , 0 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void ensureWritableBytes ( int minWritableBytes ) { </a> 0
<a> if ( minWritableBytes < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( String . format ( </a> 0
<a> "minWritableBytes: %d (expected: >= 0)" , minWritableBytes ) ) ; </a> 0
<a> } </a> 0
<a> if ( minWritableBytes <= writableBytes ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( minWritableBytes > maxCapacity - writerIndex ) { </a> 0
<a> throw new IndexOutOfBoundsException ( String . format ( </a> 0
<a> "writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d)" , </a> 0
<a> writerIndex , minWritableBytes , maxCapacity ) ) ; </a> 0
<a> } </a> 0
<a> int newCapacity = calculateNewCapacity ( writerIndex + minWritableBytes ) ; </a> 0
<a> capacity ( newCapacity ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int ensureWritableBytes ( int minWritableBytes , boolean force ) { </a> 0
<a> if ( minWritableBytes < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( String . format ( </a> 0
<a> "minWritableBytes: %d (expected: >= 0)" , minWritableBytes ) ) ; </a> 0
<a> } </a> 0
<a> if ( minWritableBytes <= writableBytes ( ) ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> if ( minWritableBytes > maxCapacity - writerIndex ) { </a> 0
<a> if ( force ) { </a> 0
<a> if ( capacity ( ) == maxCapacity ( ) ) { </a> 0
<a> return 1 ; </a> 0
<a> } </a> 0
<a> capacity ( maxCapacity ( ) ) ; </a> 0
<a> return 3 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int newCapacity = calculateNewCapacity ( writerIndex + minWritableBytes ) ; </a> 0
<a> capacity ( newCapacity ) ; </a> 0
<a> return 2 ; </a> 0
<a> } </a> 0
<a> private int calculateNewCapacity ( int minNewCapacity ) { </a> 0
<a> final int maxCapacity = this . maxCapacity ; </a> 0
<a> final int threshold = 1048576 * 4 ; </a> 0
<a> if ( minNewCapacity == threshold ) { </a> 0
<a> return minNewCapacity ; </a> 0
<a> } </a> 0
<a> if ( minNewCapacity > threshold ) { </a> 0
<a> int newCapacity = minNewCapacity / threshold * threshold ; </a> 0
<a> if ( newCapacity > maxCapacity - threshold ) { </a> 0
<a> newCapacity = maxCapacity ; </a> 0
<a> } else { </a> 0
<a> newCapacity += threshold ; </a> 0
<a> } </a> 0
<a> return newCapacity ; </a> 0
<a> } </a> 0
<a> int newCapacity = 64 ; </a> 0
<a> while ( newCapacity < minNewCapacity ) { </a> 0
<a> newCapacity <<= 1 ; </a> 0
<a> } </a> 0
<a> return Math . min ( newCapacity , maxCapacity ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final ByteOrder order ( ) { </a> 1
<a> return order ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf order ( ByteOrder endianness ) { </a> 0
<a> if ( endianness == null ) { </a> 0
<a> throw new NullPointerException ( "endianness" ) ; </a> 0
<a> } </a> 0
<a> if ( endianness == order ( ) ) { </a> 1
<a> return this ; </a> 0
<a> } </a> 0
<a> return swappedBuf ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean getBoolean ( int index ) { </a> 0
<a> return getByte ( index ) != 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short getUnsignedByte ( int index ) { </a> 0
<a> return ( short ) ( getByte ( index ) & 0xFF ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getUnsignedShort ( int index ) { </a> 0
<a> return getShort ( index ) & 0xFFFF ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getMedium ( int index ) { </a> 0
<a> int value = getUnsignedMedium ( index ) ; </a> 0
<a> if ( ( value & 0x800000 ) != 0 ) { </a> 0
<a> value |= 0xff000000 ; </a> 0
<a> } </a> 0
<a> return value ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getUnsignedInt ( int index ) { </a> 0
<a> return getInt ( index ) & 0xFFFFFFFFL ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public char getChar ( int index ) { </a> 0
<a> return ( char ) getShort ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public float getFloat ( int index ) { </a> 0
<a> return Float . intBitsToFloat ( getInt ( index ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public double getDouble ( int index ) { </a> 0
<a> return Double . longBitsToDouble ( getLong ( index ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , byte [ ] dst ) { </a> 0
<a> getBytes ( index , dst , 0 , dst . length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuf dst ) { </a> 0
<a> getBytes ( index , dst , dst . writableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuf dst , int length ) { </a> 0
<a> if ( length > dst . writableBytes ( ) ) { </a> 1
<a> throw new IndexOutOfBoundsException ( "Too many bytes to be read: Need " </a> 0
<a> + length + ", maximum is " + dst . writableBytes ( ) ) ; </a> 0
<a> } </a> 1
<a> getBytes ( index , dst , dst . writerIndex ( ) , length ) ; </a> 0
<a> dst . writerIndex ( dst . writerIndex ( ) + length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBoolean ( int index , boolean value ) { </a> 0
<a> setByte ( index , value ? 1 : 0 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setChar ( int index , int value ) { </a> 0
<a> setShort ( index , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setFloat ( int index , float value ) { </a> 0
<a> setInt ( index , Float . floatToRawIntBits ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setDouble ( int index , double value ) { </a> 0
<a> setLong ( index , Double . doubleToRawLongBits ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , byte [ ] src ) { </a> 0
<a> setBytes ( index , src , 0 , src . length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuf src ) { </a> 0
<a> setBytes ( index , src , src . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuf src , int length ) { </a> 0
<a> if ( length > src . readableBytes ( ) ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to write: Need " </a> 0
<a> + length + ", maximum is " + src . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> setBytes ( index , src , src . readerIndex ( ) , length ) ; </a> 0
<a> src . readerIndex ( src . readerIndex ( ) + length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setZero ( int index , int length ) { </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( length < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "length must be 0 or greater than 0." ) ; </a> 0
<a> } </a> 0
<a> int nLong = length > > > 3 ; </a> 0
<a> int nBytes = length & 7 ; </a> 0
<a> for ( int i = nLong ; i > 0 ; i -- ) { </a> 0
<a> setLong ( index , 0 ) ; </a> 0
<a> index += 8 ; </a> 0
<a> } </a> 0
<a> if ( nBytes == 4 ) { </a> 0
<a> setInt ( index , 0 ) ; </a> 0
<a> } else if ( nBytes < 4 ) { </a> 0
<a> for ( int i = nBytes ; i > 0 ; i -- ) { </a> 0
<a> setByte ( index , ( byte ) 0 ) ; </a> 0
<a> index ++ ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> setInt ( index , 0 ) ; </a> 0
<a> index += 4 ; </a> 0
<a> for ( int i = nBytes - 4 ; i > 0 ; i -- ) { </a> 0
<a> setByte ( index , ( byte ) 0 ) ; </a> 0
<a> index ++ ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte readByte ( ) { </a> 0
<a> if ( readerIndex == writerIndex ) { </a> 1
<a> throw new IndexOutOfBoundsException ( "Readable byte limit exceeded: " </a> 0
<a> + readerIndex ) ; </a> 0
<a> } </a> 1
<a> return getByte ( readerIndex ++ ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readBoolean ( ) { </a> 0
<a> return readByte ( ) != 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short readUnsignedByte ( ) { </a> 0
<a> return ( short ) ( readByte ( ) & 0xFF ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short readShort ( ) { </a> 0
<a> checkReadableBytes ( 2 ) ; </a> 0
<a> short v = getShort ( readerIndex ) ; </a> 0
<a> readerIndex += 2 ; </a> 0
<a> return v ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readUnsignedShort ( ) { </a> 0
<a> return readShort ( ) & 0xFFFF ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readMedium ( ) { </a> 0
<a> int value = readUnsignedMedium ( ) ; </a> 0
<a> if ( ( value & 0x800000 ) != 0 ) { </a> 0
<a> value |= 0xff000000 ; </a> 0
<a> } </a> 0
<a> return value ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readUnsignedMedium ( ) { </a> 0
<a> checkReadableBytes ( 3 ) ; </a> 0
<a> int v = getUnsignedMedium ( readerIndex ) ; </a> 0
<a> readerIndex += 3 ; </a> 0
<a> return v ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readInt ( ) { </a> 0
<a> checkReadableBytes ( 4 ) ; </a> 0
<a> int v = getInt ( readerIndex ) ; </a> 0
<a> readerIndex += 4 ; </a> 0
<a> return v ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long readUnsignedInt ( ) { </a> 0
<a> return readInt ( ) & 0xFFFFFFFFL ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long readLong ( ) { </a> 0
<a> checkReadableBytes ( 8 ) ; </a> 0
<a> long v = getLong ( readerIndex ) ; </a> 0
<a> readerIndex += 8 ; </a> 0
<a> return v ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public char readChar ( ) { </a> 0
<a> return ( char ) readShort ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public float readFloat ( ) { </a> 0
<a> return Float . intBitsToFloat ( readInt ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public double readDouble ( ) { </a> 0
<a> return Double . longBitsToDouble ( readLong ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf readBytes ( int length ) { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return Unpooled . EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> ByteBuf buf = unsafe ( ) . newBuffer ( length ) ; </a> 1
<a> buf . writeBytes ( this , readerIndex , length ) ; </a> 0
<a> readerIndex += length ; </a> 0
<a> return buf ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf readSlice ( int length ) { </a> 0
<a> ByteBuf slice = slice ( readerIndex , length ) ; </a> 0
<a> readerIndex += length ; </a> 0
<a> return slice ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( byte [ ] dst , int dstIndex , int length ) { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> getBytes ( readerIndex , dst , dstIndex , length ) ; </a> 0
<a> readerIndex += length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( byte [ ] dst ) { </a> 0
<a> readBytes ( dst , 0 , dst . length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( ByteBuf dst ) { </a> 0
<a> readBytes ( dst , dst . writableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( ByteBuf dst , int length ) { </a> 0
<a> if ( length > dst . writableBytes ( ) ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to be read: Need " </a> 0
<a> + length + ", maximum is " + dst . writableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> readBytes ( dst , dst . writerIndex ( ) , length ) ; </a> 0
<a> dst . writerIndex ( dst . writerIndex ( ) + length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( ByteBuf dst , int dstIndex , int length ) { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> getBytes ( readerIndex , dst , dstIndex , length ) ; </a> 0
<a> readerIndex += length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( ByteBuffer dst ) { </a> 0
<a> int length = dst . remaining ( ) ; </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> getBytes ( readerIndex , dst ) ; </a> 0
<a> readerIndex += length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readBytes ( GatheringByteChannel out , int length ) </a> 0
<a> throws IOException { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> int readBytes = getBytes ( readerIndex , out , length ) ; </a> 0
<a> readerIndex += readBytes ; </a> 0
<a> return readBytes ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( OutputStream out , int length ) throws IOException { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> getBytes ( readerIndex , out , length ) ; </a> 0
<a> readerIndex += length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void skipBytes ( int length ) { </a> 0
<a> int newReaderIndex = readerIndex + length ; </a> 0
<a> if ( newReaderIndex > writerIndex ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Readable bytes exceeded - Need " </a> 0
<a> + newReaderIndex + ", maximum is " + writerIndex ) ; </a> 0
<a> } </a> 0
<a> readerIndex = newReaderIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBoolean ( boolean value ) { </a> 0
<a> writeByte ( value ? 1 : 0 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeByte ( int value ) { </a> 0
<a> ensureWritableBytes ( 1 ) ; </a> 0
<a> setByte ( writerIndex ++ , value ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeShort ( int value ) { </a> 0
<a> ensureWritableBytes ( 2 ) ; </a> 0
<a> setShort ( writerIndex , value ) ; </a> 0
<a> writerIndex += 2 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeMedium ( int value ) { </a> 0
<a> ensureWritableBytes ( 3 ) ; </a> 0
<a> setMedium ( writerIndex , value ) ; </a> 0
<a> writerIndex += 3 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeInt ( int value ) { </a> 0
<a> ensureWritableBytes ( 4 ) ; </a> 0
<a> setInt ( writerIndex , value ) ; </a> 0
<a> writerIndex += 4 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeLong ( long value ) { </a> 0
<a> ensureWritableBytes ( 8 ) ; </a> 0
<a> setLong ( writerIndex , value ) ; </a> 0
<a> writerIndex += 8 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeChar ( int value ) { </a> 0
<a> writeShort ( value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeFloat ( float value ) { </a> 0
<a> writeInt ( Float . floatToRawIntBits ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeDouble ( double value ) { </a> 0
<a> writeLong ( Double . doubleToRawLongBits ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( byte [ ] src , int srcIndex , int length ) { </a> 0
<a> ensureWritableBytes ( length ) ; </a> 0
<a> setBytes ( writerIndex , src , srcIndex , length ) ; </a> 0
<a> writerIndex += length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( byte [ ] src ) { </a> 0
<a> writeBytes ( src , 0 , src . length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( ByteBuf src ) { </a> 0
<a> writeBytes ( src , src . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( ByteBuf src , int length ) { </a> 0
<a> if ( length > src . readableBytes ( ) ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to write - Need " </a> 0
<a> + length + ", maximum is " + src . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> writeBytes ( src , src . readerIndex ( ) , length ) ; </a> 0
<a> src . readerIndex ( src . readerIndex ( ) + length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( ByteBuf src , int srcIndex , int length ) { </a> 0
<a> ensureWritableBytes ( length ) ; </a> 0
<a> setBytes ( writerIndex , src , srcIndex , length ) ; </a> 0
<a> writerIndex += length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( ByteBuffer src ) { </a> 0
<a> int length = src . remaining ( ) ; </a> 0
<a> ensureWritableBytes ( length ) ; </a> 0
<a> setBytes ( writerIndex , src ) ; </a> 0
<a> writerIndex += length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int writeBytes ( InputStream in , int length ) </a> 0
<a> throws IOException { </a> 0
<a> ensureWritableBytes ( length ) ; </a> 0
<a> int writtenBytes = setBytes ( writerIndex , in , length ) ; </a> 0
<a> if ( writtenBytes > 0 ) { </a> 0
<a> writerIndex += writtenBytes ; </a> 0
<a> } </a> 0
<a> return writtenBytes ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int writeBytes ( ScatteringByteChannel in , int length ) </a> 1
<a> throws IOException { </a> 1
<a> ensureWritableBytes ( length ) ; </a> 0
<a> int writtenBytes = setBytes ( writerIndex , in , length ) ; </a> 0
<a> if ( writtenBytes > 0 ) { </a> 0
<a> writerIndex += writtenBytes ; </a> 0
<a> } </a> 0
<a> return writtenBytes ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeZero ( int length ) { </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( length < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "length must be 0 or greater than 0." ) ; </a> 0
<a> } </a> 0
<a> int nLong = length > > > 3 ; </a> 0
<a> int nBytes = length & 7 ; </a> 0
<a> for ( int i = nLong ; i > 0 ; i -- ) { </a> 0
<a> writeLong ( 0 ) ; </a> 0
<a> } </a> 0
<a> if ( nBytes == 4 ) { </a> 0
<a> writeInt ( 0 ) ; </a> 0
<a> } else if ( nBytes < 4 ) { </a> 0
<a> for ( int i = nBytes ; i > 0 ; i -- ) { </a> 0
<a> writeByte ( ( byte ) 0 ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> writeInt ( 0 ) ; </a> 0
<a> for ( int i = nBytes - 4 ; i > 0 ; i -- ) { </a> 0
<a> writeByte ( ( byte ) 0 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf copy ( ) { </a> 0
<a> return copy ( readerIndex , readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf duplicate ( ) { </a> 0
<a> return new DuplicatedByteBuf ( this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf slice ( ) { </a> 0
<a> return slice ( readerIndex , readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf slice ( int index , int length ) { </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return Unpooled . EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> return new SlicedByteBuf ( this , index , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuffer nioBuffer ( ) { </a> 0
<a> return nioBuffer ( readerIndex , readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuffer [ ] nioBuffers ( ) { </a> 0
<a> return nioBuffers ( readerIndex , readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( Charset charset ) { </a> 0
<a> return toString ( readerIndex , readableBytes ( ) , charset ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( int index , int length , Charset charset ) { </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> ByteBuffer nioBuffer ; </a> 0
<a> if ( hasNioBuffer ( ) ) { </a> 1
<a> nioBuffer = nioBuffer ( index , length ) ; </a> 0
<a> } else { </a> 0
<a> nioBuffer = ByteBuffer . allocate ( length ) ; </a> 0
<a> getBytes ( index , nioBuffer ) ; </a> 0
<a> nioBuffer . flip ( ) ; </a> 0
<a> } </a> 0
<a> return ByteBufUtil . decodeString ( nioBuffer , charset ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int indexOf ( int fromIndex , int toIndex , byte value ) { </a> 0
<a> return ByteBufUtil . indexOf ( this , fromIndex , toIndex , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int indexOf ( int fromIndex , int toIndex , ByteBufIndexFinder indexFinder ) { </a> 0
<a> return ByteBufUtil . indexOf ( this , fromIndex , toIndex , indexFinder ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( byte value ) { </a> 0
<a> return bytesBefore ( readerIndex ( ) , readableBytes ( ) , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( ByteBufIndexFinder indexFinder ) { </a> 0
<a> return bytesBefore ( readerIndex ( ) , readableBytes ( ) , indexFinder ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( int length , byte value ) { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> return bytesBefore ( readerIndex ( ) , length , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( int length , ByteBufIndexFinder indexFinder ) { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> return bytesBefore ( readerIndex ( ) , length , indexFinder ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( int index , int length , byte value ) { </a> 0
<a> int endIndex = indexOf ( index , index + length , value ) ; </a> 0
<a> if ( endIndex < 0 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> return endIndex - index ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( int index , int length , </a> 0
<a> ByteBufIndexFinder indexFinder ) { </a> 0
<a> int endIndex = indexOf ( index , index + length , indexFinder ) ; </a> 0
<a> if ( endIndex < 0 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> return endIndex - index ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return ByteBufUtil . hashCode ( this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object o ) { </a> 0
<a> if ( this == o ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( o instanceof ByteBuf ) { </a> 0
<a> return ByteBufUtil . equals ( this , ( ByteBuf ) o ) ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( ByteBuf that ) { </a> 0
<a> return ByteBufUtil . compare ( this , that ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getClass ( ) . getSimpleName ( ) + '(' + </a> 0
<a> "ridx=" + readerIndex + ", " + </a> 0
<a> "widx=" + writerIndex + ", " + </a> 0
<a> "cap=" + capacity ( ) + </a> 0
<a> ')' ; </a> 0
<a> } </a> 0
<a> protected void checkReadableBytes ( int minimumReadableBytes ) { </a> 1
<a> if ( readableBytes ( ) < minimumReadableBytes ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Not enough readable bytes - Need " </a> 0
<a> + minimumReadableBytes + ", maximum is " + readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . ByteOrder ; </a> 0
<a> import java . nio . channels . GatheringByteChannel ; </a> 0
<a> import java . nio . channels . ScatteringByteChannel ; </a> 0
<a> import java . nio . charset . Charset ; </a> 0
<a> import java . nio . charset . UnsupportedCharsetException ; </a> 0
<a> public interface ByteBuf extends ChannelBuf , Comparable < ByteBuf > { </a> 1
<a> int capacity ( ) ; </a> 1
<a> void capacity ( int newCapacity ) ; </a> 0
<a> int maxCapacity ( ) ; </a> 1
<a> ByteOrder order ( ) ; </a> 1
<a> ByteBuf order ( ByteOrder endianness ) ; </a> 1
<a> boolean isDirect ( ) ; </a> 1
<a> int readerIndex ( ) ; </a> 1
<a> void readerIndex ( int readerIndex ) ; </a> 0
<a> int writerIndex ( ) ; </a> 1
<a> void writerIndex ( int writerIndex ) ; </a> 0
<a> void setIndex ( int readerIndex , int writerIndex ) ; </a> 0
<a> int readableBytes ( ) ; </a> 1
<a> int writableBytes ( ) ; </a> 1
<a> boolean readable ( ) ; </a> 0
<a> boolean writable ( ) ; </a> 0
<a> void clear ( ) ; </a> 0
<a> void markReaderIndex ( ) ; </a> 0
<a> void resetReaderIndex ( ) ; </a> 0
<a> void markWriterIndex ( ) ; </a> 0
<a> void resetWriterIndex ( ) ; </a> 0
<a> void discardReadBytes ( ) ; </a> 0
<a> void ensureWritableBytes ( int minWritableBytes ) ; </a> 0
<a> int ensureWritableBytes ( int minWritableBytes , boolean force ) ; </a> 0
<a> boolean getBoolean ( int index ) ; </a> 1
<a> byte getByte ( int index ) ; </a> 1
<a> short getUnsignedByte ( int index ) ; </a> 1
<a> short getShort ( int index ) ; </a> 1
<a> int getUnsignedShort ( int index ) ; </a> 1
<a> int getMedium ( int index ) ; </a> 1
<a> int getUnsignedMedium ( int index ) ; </a> 1
<a> int getInt ( int index ) ; </a> 1
<a> long getUnsignedInt ( int index ) ; </a> 1
<a> long getLong ( int index ) ; </a> 1
<a> char getChar ( int index ) ; </a> 1
<a> float getFloat ( int index ) ; </a> 1
<a> double getDouble ( int index ) ; </a> 1
<a> void getBytes ( int index , ByteBuf dst ) ; </a> 0
<a> void getBytes ( int index , ByteBuf dst , int length ) ; </a> 0
<a> void getBytes ( int index , ByteBuf dst , int dstIndex , int length ) ; </a> 0
<a> void getBytes ( int index , byte [ ] dst ) ; </a> 0
<a> void getBytes ( int index , byte [ ] dst , int dstIndex , int length ) ; </a> 0
<a> void getBytes ( int index , ByteBuffer dst ) ; </a> 0
<a> void getBytes ( int index , OutputStream out , int length ) throws IOException ; </a> 0
<a> int getBytes ( int index , GatheringByteChannel out , int length ) throws IOException ; </a> 1
<a> void setBoolean ( int index , boolean value ) ; </a> 0
<a> void setByte ( int index , int value ) ; </a> 0
<a> void setShort ( int index , int value ) ; </a> 0
<a> void setMedium ( int index , int value ) ; </a> 0
<a> void setInt ( int index , int value ) ; </a> 0
<a> void setLong ( int index , long value ) ; </a> 0
<a> void setChar ( int index , int value ) ; </a> 0
<a> void setFloat ( int index , float value ) ; </a> 0
<a> void setDouble ( int index , double value ) ; </a> 0
<a> void setBytes ( int index , ByteBuf src ) ; </a> 0
<a> void setBytes ( int index , ByteBuf src , int length ) ; </a> 0
<a> void setBytes ( int index , ByteBuf src , int srcIndex , int length ) ; </a> 0
<a> void setBytes ( int index , byte [ ] src ) ; </a> 0
<a> void setBytes ( int index , byte [ ] src , int srcIndex , int length ) ; </a> 0
<a> void setBytes ( int index , ByteBuffer src ) ; </a> 0
<a> int setBytes ( int index , InputStream in , int length ) throws IOException ; </a> 1
<a> int setBytes ( int index , ScatteringByteChannel in , int length ) throws IOException ; </a> 1
<a> void setZero ( int index , int length ) ; </a> 0
<a> boolean readBoolean ( ) ; </a> 1
<a> byte readByte ( ) ; </a> 1
<a> short readUnsignedByte ( ) ; </a> 1
<a> short readShort ( ) ; </a> 1
<a> int readUnsignedShort ( ) ; </a> 1
<a> int readMedium ( ) ; </a> 1
<a> int readUnsignedMedium ( ) ; </a> 1
<a> int readInt ( ) ; </a> 1
<a> long readUnsignedInt ( ) ; </a> 1
<a> long readLong ( ) ; </a> 1
<a> char readChar ( ) ; </a> 1
<a> float readFloat ( ) ; </a> 1
<a> double readDouble ( ) ; </a> 1
<a> ByteBuf readBytes ( int length ) ; </a> 1
<a> ByteBuf readSlice ( int length ) ; </a> 1
<a> void readBytes ( ByteBuf dst ) ; </a> 0
<a> void readBytes ( ByteBuf dst , int length ) ; </a> 0
<a> void readBytes ( ByteBuf dst , int dstIndex , int length ) ; </a> 0
<a> void readBytes ( byte [ ] dst ) ; </a> 0
<a> void readBytes ( byte [ ] dst , int dstIndex , int length ) ; </a> 0
<a> void readBytes ( ByteBuffer dst ) ; </a> 0
<a> void readBytes ( OutputStream out , int length ) throws IOException ; </a> 0
<a> int readBytes ( GatheringByteChannel out , int length ) throws IOException ; </a> 1
<a> void skipBytes ( int length ) ; </a> 0
<a> void writeBoolean ( boolean value ) ; </a> 0
<a> void writeByte ( int value ) ; </a> 0
<a> void writeShort ( int value ) ; </a> 0
<a> void writeMedium ( int value ) ; </a> 0
<a> void writeInt ( int value ) ; </a> 0
<a> void writeLong ( long value ) ; </a> 0
<a> void writeChar ( int value ) ; </a> 0
<a> void writeFloat ( float value ) ; </a> 0
<a> void writeDouble ( double value ) ; </a> 0
<a> void writeBytes ( ByteBuf src ) ; </a> 0
<a> void writeBytes ( ByteBuf src , int length ) ; </a> 0
<a> void writeBytes ( ByteBuf src , int srcIndex , int length ) ; </a> 0
<a> void writeBytes ( byte [ ] src ) ; </a> 0
<a> void writeBytes ( byte [ ] src , int srcIndex , int length ) ; </a> 0
<a> void writeBytes ( ByteBuffer src ) ; </a> 0
<a> int writeBytes ( InputStream in , int length ) throws IOException ; </a> 1
<a> int writeBytes ( ScatteringByteChannel in , int length ) throws IOException ; </a> 1
<a> void writeZero ( int length ) ; </a> 0
<a> int indexOf ( int fromIndex , int toIndex , byte value ) ; </a> 1
<a> int indexOf ( int fromIndex , int toIndex , ByteBufIndexFinder indexFinder ) ; </a> 0
<a> int bytesBefore ( byte value ) ; </a> 1
<a> int bytesBefore ( ByteBufIndexFinder indexFinder ) ; </a> 0
<a> int bytesBefore ( int length , byte value ) ; </a> 1
<a> int bytesBefore ( int length , ByteBufIndexFinder indexFinder ) ; </a> 0
<a> int bytesBefore ( int index , int length , byte value ) ; </a> 1
<a> int bytesBefore ( int index , int length , ByteBufIndexFinder indexFinder ) ; </a> 0
<a> ByteBuf copy ( ) ; </a> 1
<a> ByteBuf copy ( int index , int length ) ; </a> 1
<a> ByteBuf slice ( ) ; </a> 1
<a> ByteBuf slice ( int index , int length ) ; </a> 1
<a> ByteBuf duplicate ( ) ; </a> 1
<a> boolean hasNioBuffer ( ) ; </a> 1
<a> ByteBuffer nioBuffer ( ) ; </a> 1
<a> ByteBuffer nioBuffer ( int index , int length ) ; </a> 1
<a> boolean hasNioBuffers ( ) ; </a> 1
<a> ByteBuffer [ ] nioBuffers ( ) ; </a> 1
<a> ByteBuffer [ ] nioBuffers ( int offset , int length ) ; </a> 1
<a> boolean hasArray ( ) ; </a> 1
<a> byte [ ] array ( ) ; </a> 1
<a> int arrayOffset ( ) ; </a> 1
<a> String toString ( Charset charset ) ; </a> 1
<a> String toString ( int index , int length , Charset charset ) ; </a> 1
<a> @ Override </a> 0
<a> int hashCode ( ) ; </a> 1
<a> @ Override </a> 0
<a> boolean equals ( Object obj ) ; </a> 1
<a> @ Override </a> 0
<a> int compareTo ( ByteBuf buffer ) ; </a> 1
<a> @ Override </a> 0
<a> String toString ( ) ; </a> 1
<a> Unsafe unsafe ( ) ; </a> 1
<a> interface Unsafe { </a> 1
<a> ByteBuffer nioBuffer ( ) ; </a> 1
<a> ByteBuffer [ ] nioBuffers ( ) ; </a> 1
<a> ByteBuf newBuffer ( int initialCapacity ) ; </a> 1
<a> void discardSomeReadBytes ( ) ; </a> 1
<a> void acquire ( ) ; </a> 1
<a> void release ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> public interface ByteBufIndexFinder { </a> 0
<a> boolean find ( ByteBuf buffer , int guessedIndex ) ; </a> 0
<a> ByteBufIndexFinder NUL = new ByteBufIndexFinder ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean find ( ByteBuf buffer , int guessedIndex ) { </a> 0
<a> return buffer . getByte ( guessedIndex ) == 0 ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> ByteBufIndexFinder NOT_NUL = new ByteBufIndexFinder ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean find ( ByteBuf buffer , int guessedIndex ) { </a> 0
<a> return buffer . getByte ( guessedIndex ) != 0 ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> ByteBufIndexFinder CR = new ByteBufIndexFinder ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean find ( ByteBuf buffer , int guessedIndex ) { </a> 0
<a> return buffer . getByte ( guessedIndex ) == '\r' ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> ByteBufIndexFinder NOT_CR = new ByteBufIndexFinder ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean find ( ByteBuf buffer , int guessedIndex ) { </a> 0
<a> return buffer . getByte ( guessedIndex ) != '\r' ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> ByteBufIndexFinder LF = new ByteBufIndexFinder ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean find ( ByteBuf buffer , int guessedIndex ) { </a> 0
<a> return buffer . getByte ( guessedIndex ) == '\n' ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> ByteBufIndexFinder NOT_LF = new ByteBufIndexFinder ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean find ( ByteBuf buffer , int guessedIndex ) { </a> 0
<a> return buffer . getByte ( guessedIndex ) != '\n' ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> ByteBufIndexFinder CRLF = new ByteBufIndexFinder ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean find ( ByteBuf buffer , int guessedIndex ) { </a> 0
<a> byte b = buffer . getByte ( guessedIndex ) ; </a> 0
<a> return b == '\r' || b == '\n' ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> ByteBufIndexFinder NOT_CRLF = new ByteBufIndexFinder ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean find ( ByteBuf buffer , int guessedIndex ) { </a> 0
<a> byte b = buffer . getByte ( guessedIndex ) ; </a> 0
<a> return b != '\r' && b != '\n' ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> ByteBufIndexFinder LINEAR_WHITESPACE = new ByteBufIndexFinder ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean find ( ByteBuf buffer , int guessedIndex ) { </a> 0
<a> byte b = buffer . getByte ( guessedIndex ) ; </a> 0
<a> return b == ' ' || b == '\t' ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> ByteBufIndexFinder NOT_LINEAR_WHITESPACE = new ByteBufIndexFinder ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean find ( ByteBuf buffer , int guessedIndex ) { </a> 0
<a> byte b = buffer . getByte ( guessedIndex ) ; </a> 0
<a> return b != ' ' && b != '\t' ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . io . DataInput ; </a> 0
<a> import java . io . DataInputStream ; </a> 0
<a> import java . io . EOFException ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> public class ByteBufInputStream extends InputStream implements DataInput { </a> 0
<a> private final ByteBuf buffer ; </a> 0
<a> private final int startIndex ; </a> 0
<a> private final int endIndex ; </a> 0
<a> public ByteBufInputStream ( ByteBuf buffer ) { </a> 0
<a> this ( buffer , buffer . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> public ByteBufInputStream ( ByteBuf buffer , int length ) { </a> 0
<a> if ( buffer == null ) { </a> 0
<a> throw new NullPointerException ( "buffer" ) ; </a> 0
<a> } </a> 0
<a> if ( length < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "length: " + length ) ; </a> 0
<a> } </a> 0
<a> if ( length > buffer . readableBytes ( ) ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to be read - Needs " </a> 0
<a> + length + ", maximum is " + buffer . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> this . buffer = buffer ; </a> 0
<a> startIndex = buffer . readerIndex ( ) ; </a> 0
<a> endIndex = startIndex + length ; </a> 0
<a> buffer . markReaderIndex ( ) ; </a> 0
<a> } </a> 0
<a> public int readBytes ( ) { </a> 0
<a> return buffer . readerIndex ( ) - startIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int available ( ) throws IOException { </a> 0
<a> return endIndex - buffer . readerIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void mark ( int readlimit ) { </a> 0
<a> buffer . markReaderIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean markSupported ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int read ( ) throws IOException { </a> 0
<a> if ( ! buffer . readable ( ) ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> return buffer . readByte ( ) & 0xff ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int read ( byte [ ] b , int off , int len ) throws IOException { </a> 0
<a> int available = available ( ) ; </a> 0
<a> if ( available == 0 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> len = Math . min ( available , len ) ; </a> 0
<a> buffer . readBytes ( b , off , len ) ; </a> 0
<a> return len ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void reset ( ) throws IOException { </a> 0
<a> buffer . resetReaderIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long skip ( long n ) throws IOException { </a> 0
<a> if ( n > Integer . MAX_VALUE ) { </a> 0
<a> return skipBytes ( Integer . MAX_VALUE ) ; </a> 0
<a> } else { </a> 0
<a> return skipBytes ( ( int ) n ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readBoolean ( ) throws IOException { </a> 0
<a> checkAvailable ( 1 ) ; </a> 0
<a> return read ( ) != 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte readByte ( ) throws IOException { </a> 0
<a> if ( ! buffer . readable ( ) ) { </a> 0
<a> throw new EOFException ( ) ; </a> 0
<a> } </a> 0
<a> return buffer . readByte ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public char readChar ( ) throws IOException { </a> 0
<a> return ( char ) readShort ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public double readDouble ( ) throws IOException { </a> 0
<a> return Double . longBitsToDouble ( readLong ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public float readFloat ( ) throws IOException { </a> 0
<a> return Float . intBitsToFloat ( readInt ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readFully ( byte [ ] b ) throws IOException { </a> 0
<a> readFully ( b , 0 , b . length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readFully ( byte [ ] b , int off , int len ) throws IOException { </a> 0
<a> checkAvailable ( len ) ; </a> 0
<a> buffer . readBytes ( b , off , len ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readInt ( ) throws IOException { </a> 0
<a> checkAvailable ( 4 ) ; </a> 0
<a> return buffer . readInt ( ) ; </a> 0
<a> } </a> 0
<a> private final StringBuilder lineBuf = new StringBuilder ( ) ; </a> 0
<a> @ Override </a> 0
<a> public String readLine ( ) throws IOException { </a> 0
<a> lineBuf . setLength ( 0 ) ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> int b = read ( ) ; </a> 0
<a> if ( b < 0 || b == '\n' ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> lineBuf . append ( ( char ) b ) ; </a> 0
<a> } </a> 0
<a> if ( lineBuf . length ( ) > 0 ) { </a> 0
<a> while ( lineBuf . charAt ( lineBuf . length ( ) - 1 ) == '\r' ) { </a> 0
<a> lineBuf . setLength ( lineBuf . length ( ) - 1 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return lineBuf . toString ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long readLong ( ) throws IOException { </a> 0
<a> checkAvailable ( 8 ) ; </a> 0
<a> return buffer . readLong ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short readShort ( ) throws IOException { </a> 0
<a> checkAvailable ( 2 ) ; </a> 0
<a> return buffer . readShort ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String readUTF ( ) throws IOException { </a> 0
<a> return DataInputStream . readUTF ( this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readUnsignedByte ( ) throws IOException { </a> 0
<a> return readByte ( ) & 0xff ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readUnsignedShort ( ) throws IOException { </a> 0
<a> return readShort ( ) & 0xffff ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int skipBytes ( int n ) throws IOException { </a> 0
<a> int nBytes = Math . min ( available ( ) , n ) ; </a> 0
<a> buffer . skipBytes ( nBytes ) ; </a> 0
<a> return nBytes ; </a> 0
<a> } </a> 0
<a> private void checkAvailable ( int fieldSize ) throws IOException { </a> 0
<a> if ( fieldSize < 0 ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "fieldSize cannot be a negative number" ) ; </a> 0
<a> } </a> 0
<a> if ( fieldSize > available ( ) ) { </a> 0
<a> throw new EOFException ( "fieldSize is too long! Length is " + fieldSize </a> 0
<a> + ", but maximum is " + available ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . io . DataOutput ; </a> 0
<a> import java . io . DataOutputStream ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> public class ByteBufOutputStream extends OutputStream implements DataOutput { </a> 0
<a> private final ByteBuf buffer ; </a> 0
<a> private final int startIndex ; </a> 0
<a> private final DataOutputStream utf8out = new DataOutputStream ( this ) ; </a> 0
<a> public ByteBufOutputStream ( ByteBuf buffer ) { </a> 0
<a> if ( buffer == null ) { </a> 0
<a> throw new NullPointerException ( "buffer" ) ; </a> 0
<a> } </a> 0
<a> this . buffer = buffer ; </a> 0
<a> startIndex = buffer . writerIndex ( ) ; </a> 0
<a> } </a> 0
<a> public int writtenBytes ( ) { </a> 0
<a> return buffer . writerIndex ( ) - startIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( byte [ ] b , int off , int len ) throws IOException { </a> 0
<a> if ( len == 0 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> buffer . writeBytes ( b , off , len ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( byte [ ] b ) throws IOException { </a> 0
<a> buffer . writeBytes ( b ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( int b ) throws IOException { </a> 0
<a> buffer . writeByte ( ( byte ) b ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBoolean ( boolean v ) throws IOException { </a> 0
<a> write ( v ? ( byte ) 1 : ( byte ) 0 ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeByte ( int v ) throws IOException { </a> 0
<a> write ( v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( String s ) throws IOException { </a> 0
<a> int len = s . length ( ) ; </a> 0
<a> for ( int i = 0 ; i < len ; i ++ ) { </a> 0
<a> write ( ( byte ) s . charAt ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeChar ( int v ) throws IOException { </a> 0
<a> writeShort ( ( short ) v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeChars ( String s ) throws IOException { </a> 0
<a> int len = s . length ( ) ; </a> 0
<a> for ( int i = 0 ; i < len ; i ++ ) { </a> 0
<a> writeChar ( s . charAt ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeDouble ( double v ) throws IOException { </a> 0
<a> writeLong ( Double . doubleToLongBits ( v ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeFloat ( float v ) throws IOException { </a> 0
<a> writeInt ( Float . floatToIntBits ( v ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeInt ( int v ) throws IOException { </a> 0
<a> buffer . writeInt ( v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeLong ( long v ) throws IOException { </a> 0
<a> buffer . writeLong ( v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeShort ( int v ) throws IOException { </a> 0
<a> buffer . writeShort ( ( short ) v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeUTF ( String s ) throws IOException { </a> 0
<a> utf8out . writeUTF ( s ) ; </a> 0
<a> } </a> 0
<a> public ByteBuf buffer ( ) { </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . ByteOrder ; </a> 0
<a> import java . nio . CharBuffer ; </a> 0
<a> import java . nio . charset . CharacterCodingException ; </a> 0
<a> import java . nio . charset . Charset ; </a> 0
<a> import java . nio . charset . CharsetDecoder ; </a> 0
<a> import java . nio . charset . CharsetEncoder ; </a> 0
<a> import java . nio . charset . CoderResult ; </a> 0
<a> public final class ByteBufUtil { </a> 0
<a> private static final char [ ] HEXDUMP_TABLE = new char [ 256 * 4 ] ; </a> 0
<a> static { </a> 0
<a> final char [ ] DIGITS = "0123456789abcdef" . toCharArray ( ) ; </a> 0
<a> for ( int i = 0 ; i < 256 ; i ++ ) { </a> 0
<a> HEXDUMP_TABLE [ ( i < < 1 ) + 0 ] = DIGITS [ i > > > 4 & 0x0F ] ; </a> 0
<a> HEXDUMP_TABLE [ ( i < < 1 ) + 1 ] = DIGITS [ i > > > 0 & 0x0F ] ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> public static String hexDump ( ByteBuf buffer ) { </a> 0
<a> return hexDump ( buffer , buffer . readerIndex ( ) , buffer . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> public static String hexDump ( ByteBuf buffer , int fromIndex , int length ) { </a> 0
<a> if ( length < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "length: " + length ) ; </a> 0
<a> } </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> int endIndex = fromIndex + length ; </a> 0
<a> char [ ] buf = new char [ length < < 1 ] ; </a> 0
<a> int srcIdx = fromIndex ; </a> 0
<a> int dstIdx = 0 ; </a> 0
<a> for ( ; srcIdx < endIndex ; srcIdx ++ , dstIdx += 2 ) { </a> 0
<a> System . arraycopy ( </a> 0
<a> HEXDUMP_TABLE , buffer . getUnsignedByte ( srcIdx ) < < 1 , </a> 0
<a> buf , dstIdx , 2 ) ; </a> 0
<a> } </a> 0
<a> return new String ( buf ) ; </a> 0
<a> } </a> 0
<a> public static int hashCode ( ByteBuf buffer ) { </a> 0
<a> final int aLen = buffer . readableBytes ( ) ; </a> 0
<a> final int intCount = aLen > > > 2 ; </a> 0
<a> final int byteCount = aLen & 3 ; </a> 0
<a> int hashCode = 1 ; </a> 0
<a> int arrayIndex = buffer . readerIndex ( ) ; </a> 0
<a> if ( buffer . order ( ) == ByteOrder . BIG_ENDIAN ) { </a> 1
<a> for ( int i = intCount ; i > 0 ; i -- ) { </a> 0
<a> hashCode = 31 * hashCode + buffer . getInt ( arrayIndex ) ; </a> 0
<a> arrayIndex += 4 ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> for ( int i = intCount ; i > 0 ; i -- ) { </a> 0
<a> hashCode = 31 * hashCode + swapInt ( buffer . getInt ( arrayIndex ) ) ; </a> 0
<a> arrayIndex += 4 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( int i = byteCount ; i > 0 ; i -- ) { </a> 0
<a> hashCode = 31 * hashCode + buffer . getByte ( arrayIndex ++ ) ; </a> 0
<a> } </a> 0
<a> if ( hashCode == 0 ) { </a> 0
<a> hashCode = 1 ; </a> 0
<a> } </a> 0
<a> return hashCode ; </a> 0
<a> } </a> 0
<a> public static boolean equals ( ByteBuf bufferA , ByteBuf bufferB ) { </a> 0
<a> final int aLen = bufferA . readableBytes ( ) ; </a> 0
<a> if ( aLen != bufferB . readableBytes ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> final int longCount = aLen > > > 3 ; </a> 0
<a> final int byteCount = aLen & 7 ; </a> 0
<a> int aIndex = bufferA . readerIndex ( ) ; </a> 0
<a> int bIndex = bufferB . readerIndex ( ) ; </a> 0
<a> if ( bufferA . order ( ) == bufferB . order ( ) ) { </a> 0
<a> for ( int i = longCount ; i > 0 ; i -- ) { </a> 0
<a> if ( bufferA . getLong ( aIndex ) != bufferB . getLong ( bIndex ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> aIndex += 8 ; </a> 0
<a> bIndex += 8 ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> for ( int i = longCount ; i > 0 ; i -- ) { </a> 0
<a> if ( bufferA . getLong ( aIndex ) != swapLong ( bufferB . getLong ( bIndex ) ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> aIndex += 8 ; </a> 0
<a> bIndex += 8 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( int i = byteCount ; i > 0 ; i -- ) { </a> 0
<a> if ( bufferA . getByte ( aIndex ) != bufferB . getByte ( bIndex ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> aIndex ++ ; </a> 0
<a> bIndex ++ ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public static int compare ( ByteBuf bufferA , ByteBuf bufferB ) { </a> 0
<a> final int aLen = bufferA . readableBytes ( ) ; </a> 0
<a> final int bLen = bufferB . readableBytes ( ) ; </a> 0
<a> final int minLength = Math . min ( aLen , bLen ) ; </a> 0
<a> final int uintCount = minLength > > > 2 ; </a> 0
<a> final int byteCount = minLength & 3 ; </a> 0
<a> int aIndex = bufferA . readerIndex ( ) ; </a> 0
<a> int bIndex = bufferB . readerIndex ( ) ; </a> 0
<a> if ( bufferA . order ( ) == bufferB . order ( ) ) { </a> 0
<a> for ( int i = uintCount ; i > 0 ; i -- ) { </a> 0
<a> long va = bufferA . getUnsignedInt ( aIndex ) ; </a> 0
<a> long vb = bufferB . getUnsignedInt ( bIndex ) ; </a> 0
<a> if ( va > vb ) { </a> 0
<a> return 1 ; </a> 0
<a> } else if ( va < vb ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> aIndex += 4 ; </a> 0
<a> bIndex += 4 ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> for ( int i = uintCount ; i > 0 ; i -- ) { </a> 0
<a> long va = bufferA . getUnsignedInt ( aIndex ) ; </a> 0
<a> long vb = swapInt ( bufferB . getInt ( bIndex ) ) & 0xFFFFFFFFL ; </a> 0
<a> if ( va > vb ) { </a> 0
<a> return 1 ; </a> 0
<a> } else if ( va < vb ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> aIndex += 4 ; </a> 0
<a> bIndex += 4 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( int i = byteCount ; i > 0 ; i -- ) { </a> 0
<a> short va = bufferA . getUnsignedByte ( aIndex ) ; </a> 0
<a> short vb = bufferB . getUnsignedByte ( bIndex ) ; </a> 0
<a> if ( va > vb ) { </a> 0
<a> return 1 ; </a> 0
<a> } else if ( va < vb ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> aIndex ++ ; </a> 0
<a> bIndex ++ ; </a> 0
<a> } </a> 0
<a> return aLen - bLen ; </a> 0
<a> } </a> 0
<a> public static int indexOf ( ByteBuf buffer , int fromIndex , int toIndex , byte value ) { </a> 0
<a> if ( fromIndex <= toIndex ) { </a> 0
<a> return firstIndexOf ( buffer , fromIndex , toIndex , value ) ; </a> 0
<a> } else { </a> 0
<a> return lastIndexOf ( buffer , fromIndex , toIndex , value ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static int indexOf ( ByteBuf buffer , int fromIndex , int toIndex , ByteBufIndexFinder indexFinder ) { </a> 0
<a> if ( fromIndex <= toIndex ) { </a> 0
<a> return firstIndexOf ( buffer , fromIndex , toIndex , indexFinder ) ; </a> 0
<a> } else { </a> 0
<a> return lastIndexOf ( buffer , fromIndex , toIndex , indexFinder ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static short swapShort ( short value ) { </a> 0
<a> return ( short ) ( value < < 8 | value > > > 8 & 0xff ) ; </a> 0
<a> } </a> 0
<a> public static int swapMedium ( int value ) { </a> 0
<a> int swapped = value < < 16 & 0xff0000 | value & 0xff00 | value > > > 16 & 0xff ; </a> 0
<a> if ( ( swapped & 0x800000 ) != 0 ) { </a> 0
<a> swapped |= 0xff000000 ; </a> 0
<a> } </a> 0
<a> return swapped ; </a> 0
<a> } </a> 0
<a> public static int swapInt ( int value ) { </a> 0
<a> return swapShort ( ( short ) value ) < < 16 | </a> 0
<a> swapShort ( ( short ) ( value > > > 16 ) ) & 0xffff ; </a> 0
<a> } </a> 0
<a> public static long swapLong ( long value ) { </a> 0
<a> return ( long ) swapInt ( ( int ) value ) < < 32 | </a> 0
<a> swapInt ( ( int ) ( value > > > 32 ) ) & 0xffffffffL ; </a> 0
<a> } </a> 0
<a> private static int firstIndexOf ( ByteBuf buffer , int fromIndex , int toIndex , byte value ) { </a> 0
<a> fromIndex = Math . max ( fromIndex , 0 ) ; </a> 0
<a> if ( fromIndex >= toIndex || buffer . capacity ( ) == 0 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> for ( int i = fromIndex ; i < toIndex ; i ++ ) { </a> 0
<a> if ( buffer . getByte ( i ) == value ) { </a> 0
<a> return i ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> private static int lastIndexOf ( ByteBuf buffer , int fromIndex , int toIndex , byte value ) { </a> 0
<a> fromIndex = Math . min ( fromIndex , buffer . capacity ( ) ) ; </a> 0
<a> if ( fromIndex < 0 || buffer . capacity ( ) == 0 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> for ( int i = fromIndex - 1 ; i >= toIndex ; i -- ) { </a> 0
<a> if ( buffer . getByte ( i ) == value ) { </a> 0
<a> return i ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> private static int firstIndexOf ( </a> 0
<a> ByteBuf buffer , int fromIndex , int toIndex , ByteBufIndexFinder indexFinder ) { </a> 0
<a> fromIndex = Math . max ( fromIndex , 0 ) ; </a> 0
<a> if ( fromIndex >= toIndex || buffer . capacity ( ) == 0 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> for ( int i = fromIndex ; i < toIndex ; i ++ ) { </a> 0
<a> if ( indexFinder . find ( buffer , i ) ) { </a> 0
<a> return i ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> private static int lastIndexOf ( </a> 0
<a> ByteBuf buffer , int fromIndex , int toIndex , ByteBufIndexFinder indexFinder ) { </a> 0
<a> fromIndex = Math . min ( fromIndex , buffer . capacity ( ) ) ; </a> 0
<a> if ( fromIndex < 0 || buffer . capacity ( ) == 0 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> for ( int i = fromIndex - 1 ; i >= toIndex ; i -- ) { </a> 0
<a> if ( indexFinder . find ( buffer , i ) ) { </a> 0
<a> return i ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> static ByteBuffer encodeString ( CharBuffer src , Charset charset ) { </a> 0
<a> final CharsetEncoder encoder = CharsetUtil . getEncoder ( charset ) ; </a> 0
<a> final ByteBuffer dst = ByteBuffer . allocate ( </a> 0
<a> ( int ) ( ( double ) src . remaining ( ) * encoder . maxBytesPerChar ( ) ) ) ; </a> 0
<a> try { </a> 0
<a> CoderResult cr = encoder . encode ( src , dst , true ) ; </a> 0
<a> if ( ! cr . isUnderflow ( ) ) { </a> 0
<a> cr . throwException ( ) ; </a> 0
<a> } </a> 0
<a> cr = encoder . flush ( dst ) ; </a> 0
<a> if ( ! cr . isUnderflow ( ) ) { </a> 0
<a> cr . throwException ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( CharacterCodingException x ) { </a> 0
<a> throw new IllegalStateException ( x ) ; </a> 0
<a> } </a> 0
<a> dst . flip ( ) ; </a> 0
<a> return dst ; </a> 0
<a> } </a> 0
<a> static String decodeString ( ByteBuffer src , Charset charset ) { </a> 0
<a> final CharsetDecoder decoder = CharsetUtil . getDecoder ( charset ) ; </a> 0
<a> final CharBuffer dst = CharBuffer . allocate ( </a> 0
<a> ( int ) ( ( double ) src . remaining ( ) * decoder . maxCharsPerByte ( ) ) ) ; </a> 0
<a> try { </a> 0
<a> CoderResult cr = decoder . decode ( src , dst , true ) ; </a> 0
<a> if ( ! cr . isUnderflow ( ) ) { </a> 0
<a> cr . throwException ( ) ; </a> 0
<a> } </a> 0
<a> cr = decoder . flush ( dst ) ; </a> 0
<a> if ( ! cr . isUnderflow ( ) ) { </a> 0
<a> cr . throwException ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( CharacterCodingException x ) { </a> 0
<a> throw new IllegalStateException ( x ) ; </a> 0
<a> } </a> 0
<a> return dst . flip ( ) . toString ( ) ; </a> 0
<a> } </a> 0
<a> private ByteBufUtil ( ) { } </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> public interface ChannelBuf { </a> 1
<a> ChannelBufType type ( ) ; </a> 1
<a> boolean isPooled ( ) ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> public enum ChannelBufType { </a> 0
<a> BYTE , </a> 0
<a> MESSAGE </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . util . List ; </a> 0
<a> public interface CompositeByteBuf extends ByteBuf , Iterable < ByteBuf > { </a> 1
<a> void addComponent ( ByteBuf buffer ) ; </a> 0
<a> void addComponent ( int cIndex , ByteBuf buffer ) ; </a> 0
<a> void addComponents ( ByteBuf ... buffers ) ; </a> 0
<a> void addComponents ( Iterable < ByteBuf > buffers ) ; </a> 0
<a> void addComponents ( int cIndex , ByteBuf ... buffers ) ; </a> 0
<a> void addComponents ( int cIndex , Iterable < ByteBuf > buffers ) ; </a> 0
<a> void removeComponent ( int cIndex ) ; </a> 0
<a> void removeComponents ( int cIndex , int numComponents ) ; </a> 0
<a> int numComponents ( ) ; </a> 1
<a> int maxNumComponents ( ) ; </a> 1
<a> ByteBuf component ( int cIndex ) ; </a> 1
<a> ByteBuf componentAtOffset ( int offset ) ; </a> 1
<a> void discardReadComponents ( ) ; </a> 0
<a> void consolidate ( ) ; </a> 0
<a> void consolidate ( int cIndex , int numComponents ) ; </a> 0
<a> int toComponentIndex ( int offset ) ; </a> 1
<a> int toByteIndex ( int cIndex ) ; </a> 1
<a> List < ByteBuf > decompose ( int offset , int length ) ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import io . netty . util . internal . DetectionUtil ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . ByteOrder ; </a> 0
<a> import java . nio . channels . GatheringByteChannel ; </a> 0
<a> import java . nio . channels . ScatteringByteChannel ; </a> 0
<a> import java . util . ArrayList ; </a> 1
<a> import java . util . Collection ; </a> 1
<a> import java . util . Collections ; </a> 1
<a> import java . util . Iterator ; </a> 1
<a> import java . util . List ; </a> 1
<a> import java . util . ListIterator ; </a> 1
<a> public class DefaultCompositeByteBuf extends AbstractByteBuf implements CompositeByteBuf { </a> 0
<a> private final List < Component > components = new ArrayList < Component > ( ) ; </a> 1
<a> private final int maxNumComponents ; </a> 1
<a> private final Unsafe unsafe = new CompositeUnsafe ( ) ; </a> 1
<a> private Component lastAccessed ; </a> 1
<a> private int lastAccessedId ; </a> 1
<a> public DefaultCompositeByteBuf ( int maxNumComponents ) { </a> 1
<a> super ( ByteOrder . BIG_ENDIAN , Integer . MAX_VALUE ) ; </a> 1
<a> this . maxNumComponents = maxNumComponents ; </a> 1
<a> } </a> 1
<a> public DefaultCompositeByteBuf ( int maxNumComponents , ByteBuf ... buffers ) { </a> 1
<a> super ( ByteOrder . BIG_ENDIAN , Integer . MAX_VALUE ) ; </a> 1
<a> if ( maxNumComponents < 2 ) { </a> 1
<a> throw new IllegalArgumentException ( </a> 1
<a> "maxNumComponents: " + maxNumComponents + " (expected: >= 2)" ) ; </a> 1
<a> } </a> 1
<a> this . maxNumComponents = maxNumComponents ; </a> 1
<a> addComponents ( 0 , buffers ) ; </a> 1
<a> setIndex ( 0 , capacity ( ) ) ; </a> 1
<a> } </a> 1
<a> public DefaultCompositeByteBuf ( int maxNumComponents , Iterable < ByteBuf > buffers ) { </a> 1
<a> super ( ByteOrder . BIG_ENDIAN , Integer . MAX_VALUE ) ; </a> 1
<a> if ( maxNumComponents < 2 ) { </a> 1
<a> throw new IllegalArgumentException ( </a> 1
<a> "maxNumComponents: " + maxNumComponents + " (expected: >= 2)" ) ; </a> 1
<a> } </a> 1
<a> this . maxNumComponents = maxNumComponents ; </a> 1
<a> addComponents ( 0 , buffers ) ; </a> 1
<a> setIndex ( 0 , capacity ( ) ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void addComponent ( ByteBuf buffer ) { </a> 0
<a> addComponent ( components . size ( ) , buffer ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void addComponents ( ByteBuf ... buffers ) { </a> 1
<a> addComponents ( components . size ( ) , buffers ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void addComponents ( Iterable < ByteBuf > buffers ) { </a> 1
<a> addComponents ( components . size ( ) , buffers ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void addComponent ( int cIndex , ByteBuf buffer ) { </a> 0
<a> checkComponentIndex ( cIndex ) ; </a> 1
<a> if ( buffer == null ) { </a> 1
<a> throw new NullPointerException ( "buffer" ) ; </a> 1
<a> } </a> 1
<a> if ( buffer instanceof Iterable ) { </a> 1
<a> @ SuppressWarnings ( "unchecked" ) </a> 1
<a> Iterable < ByteBuf > composite = ( Iterable < ByteBuf > ) buffer ; </a> 1
<a> addComponents ( cIndex , composite ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> int readableBytes = buffer . readableBytes ( ) ; </a> 1
<a> if ( readableBytes == 0 ) { </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> final int numComponents = components . size ( ) ; </a> 1
<a> if ( numComponents >= maxNumComponents ) { </a> 1
<a> final int capacity = components . get ( numComponents - 1 ) . endOffset + readableBytes ; </a> 1
<a> ByteBuf consolidated = buffer . unsafe ( ) . newBuffer ( capacity ) ; </a> 1
<a> for ( int i = 0 ; i < numComponents ; i ++ ) { </a> 1
<a> ByteBuf b = components . get ( i ) . buf ; </a> 0
<a> consolidated . writeBytes ( b ) ; </a> 0
<a> b . unsafe ( ) . release ( ) ; </a> 0
<a> } </a> 1
<a> consolidated . writeBytes ( buffer , buffer . readerIndex ( ) , readableBytes ) ; </a> 1
<a> Component c = new Component ( consolidated ) ; </a> 1
<a> c . endOffset = c . length ; </a> 1
<a> components . clear ( ) ; </a> 1
<a> components . add ( c ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> Component c = new Component ( buffer . order ( ByteOrder . BIG_ENDIAN ) . slice ( ) ) ; </a> 1
<a> if ( cIndex == components . size ( ) ) { </a> 1
<a> components . add ( c ) ; </a> 1
<a> if ( cIndex == 0 ) { </a> 1
<a> c . endOffset = readableBytes ; </a> 1
<a> } else { </a> 1
<a> Component prev = components . get ( cIndex - 1 ) ; </a> 1
<a> c . offset = prev . endOffset ; </a> 1
<a> c . endOffset = c . offset + readableBytes ; </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> components . add ( cIndex , c ) ; </a> 1
<a> updateComponentOffsets ( cIndex ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void addComponents ( int cIndex , ByteBuf ... buffers ) { </a> 0
<a> checkComponentIndex ( cIndex ) ; </a> 1
<a> if ( buffers == null ) { </a> 0
<a> throw new NullPointerException ( "buffers" ) ; </a> 0
<a> } </a> 0
<a> ByteBuf lastBuf = null ; </a> 1
<a> int cnt = 0 ; </a> 1
<a> int readableBytes = 0 ; </a> 1
<a> for ( ByteBuf b : buffers ) { </a> 0
<a> if ( b == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> lastBuf = b ; </a> 1
<a> cnt ++ ; </a> 1
<a> readableBytes += b . readableBytes ( ) ; </a> 1
<a> } </a> 1
<a> if ( readableBytes == 0 ) { </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> final int numComponents = components . size ( ) ; </a> 1
<a> if ( numComponents + cnt > maxNumComponents ) { </a> 1
<a> final ByteBuf consolidated ; </a> 1
<a> if ( numComponents != 0 ) { </a> 1
<a> final int capacity = components . get ( numComponents - 1 ) . endOffset + readableBytes ; </a> 1
<a> consolidated = lastBuf . unsafe ( ) . newBuffer ( capacity ) ; </a> 1
<a> for ( int i = 0 ; i < cIndex ; i ++ ) { </a> 1
<a> ByteBuf b = components . get ( i ) . buf ; </a> 0
<a> consolidated . writeBytes ( b ) ; </a> 0
<a> b . unsafe ( ) . release ( ) ; </a> 0
<a> } </a> 0
<a> for ( ByteBuf b : buffers ) { </a> 0
<a> if ( b == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> consolidated . writeBytes ( b , b . readerIndex ( ) , b . readableBytes ( ) ) ; </a> 1
<a> } </a> 0
<a> for ( int i = cIndex ; i < numComponents ; i ++ ) { </a> 1
<a> ByteBuf b = components . get ( i ) . buf ; </a> 0
<a> consolidated . writeBytes ( b ) ; </a> 0
<a> b . unsafe ( ) . release ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 1
<a> consolidated = lastBuf . unsafe ( ) . newBuffer ( readableBytes ) ; </a> 1
<a> for ( ByteBuf b : buffers ) { </a> 0
<a> if ( b == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> consolidated . writeBytes ( b , b . readerIndex ( ) , b . readableBytes ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> Component c = new Component ( consolidated ) ; </a> 0
<a> c . endOffset = c . length ; </a> 0
<a> components . clear ( ) ; </a> 0
<a> components . add ( c ) ; </a> 0
<a> updateComponentOffsets ( 0 ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> for ( ByteBuf b : buffers ) { </a> 0
<a> if ( b == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( b . readable ( ) ) { </a> 1
<a> addComponent ( cIndex ++ , b ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void addComponents ( int cIndex , Iterable < ByteBuf > buffers ) { </a> 0
<a> if ( buffers == null ) { </a> 0
<a> throw new NullPointerException ( "buffers" ) ; </a> 0
<a> } </a> 0
<a> if ( buffers instanceof DefaultCompositeByteBuf ) { </a> 1
<a> List < Component > list = ( ( DefaultCompositeByteBuf ) buffers ) . components ; </a> 1
<a> ByteBuf [ ] array = new ByteBuf [ list . size ( ) ] ; </a> 1
<a> for ( int i = 0 ; i < array . length ; i ++ ) { </a> 1
<a> array [ i ] = list . get ( i ) . buf ; </a> 1
<a> } </a> 1
<a> addComponents ( cIndex , array ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> if ( buffers instanceof List ) { </a> 1
<a> List < ByteBuf > list = ( List < ByteBuf > ) buffers ; </a> 1
<a> ByteBuf [ ] array = new ByteBuf [ list . size ( ) ] ; </a> 1
<a> for ( int i = 0 ; i < array . length ; i ++ ) { </a> 1
<a> array [ i ] = list . get ( i ) ; </a> 1
<a> } </a> 0
<a> addComponents ( cIndex , array ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> if ( buffers instanceof Collection ) { </a> 1
<a> Collection < ByteBuf > col = ( Collection < ByteBuf > ) buffers ; </a> 0
<a> ByteBuf [ ] array = new ByteBuf [ col . size ( ) ] ; </a> 1
<a> int i = 0 ; </a> 1
<a> for ( ByteBuf b : col ) { </a> 1
<a> array [ i ++ ] = b ; </a> 1
<a> } </a> 1
<a> addComponents ( cIndex , array ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> List < ByteBuf > list = new ArrayList < ByteBuf > ( ) ; </a> 1
<a> for ( ByteBuf b : buffers ) { </a> 1
<a> list . add ( b ) ; </a> 1
<a> } </a> 1
<a> addComponents ( cIndex , list . toArray ( new ByteBuf [ list . size ( ) ] ) ) ; </a> 1
<a> } </a> 1
<a> private void checkComponentIndex ( int cIndex ) { </a> 1
<a> if ( cIndex < 0 || cIndex > components . size ( ) ) { </a> 1
<a> throw new IndexOutOfBoundsException ( String . format ( </a> 1
<a> "cIndex: %d (expected: >= 0 && <= numComponents(%d))" , </a> 1
<a> cIndex , components . size ( ) ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private void checkComponentIndex ( int cIndex , int numComponents ) { </a> 1
<a> if ( cIndex < 0 || cIndex + numComponents > components . size ( ) ) { </a> 1
<a> throw new IndexOutOfBoundsException ( String . format ( </a> 1
<a> "cIndex: %d, numComponents: %d " + </a> 1
<a> "(expected: cIndex >= 0 && cIndex + numComponents <= totalNumComponents(%d))" , </a> 1
<a> cIndex , numComponents , components . size ( ) ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private void updateComponentOffsets ( int cIndex ) { </a> 1
<a> Component c = components . get ( cIndex ) ; </a> 1
<a> lastAccessed = c ; </a> 1
<a> lastAccessedId = cIndex ; </a> 1
<a> if ( cIndex == 0 ) { </a> 1
<a> c . offset = 0 ; </a> 1
<a> c . endOffset = c . length ; </a> 1
<a> cIndex ++ ; </a> 1
<a> } </a> 1
<a> for ( int i = cIndex ; i < components . size ( ) ; i ++ ) { </a> 1
<a> Component prev = components . get ( i - 1 ) ; </a> 1
<a> Component cur = components . get ( i ) ; </a> 1
<a> cur . offset = prev . endOffset ; </a> 1
<a> cur . endOffset = cur . offset + cur . length ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void removeComponent ( int cIndex ) { </a> 0
<a> checkComponentIndex ( cIndex ) ; </a> 1
<a> components . remove ( cIndex ) ; </a> 0
<a> updateComponentOffsets ( cIndex ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void removeComponents ( int cIndex , int numComponents ) { </a> 0
<a> checkComponentIndex ( cIndex , numComponents ) ; </a> 1
<a> components . subList ( cIndex , cIndex + numComponents ) . clear ( ) ; </a> 0
<a> updateComponentOffsets ( cIndex ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public Iterator < ByteBuf > iterator ( ) { </a> 1
<a> List < ByteBuf > list = new ArrayList < ByteBuf > ( components . size ( ) ) ; </a> 1
<a> for ( Component c : components ) { </a> 1
<a> list . add ( c . buf ) ; </a> 1
<a> } </a> 1
<a> return list . iterator ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public List < ByteBuf > decompose ( int offset , int length ) { </a> 1
<a> if ( length == 0 ) { </a> 1
<a> return Collections . emptyList ( ) ; </a> 1
<a> } </a> 1
<a> if ( offset + length > capacity ( ) ) { </a> 1
<a> throw new IndexOutOfBoundsException ( "Too many bytes to decompose - Need " </a> 1
<a> + ( offset + length ) + ", capacity is " + capacity ( ) ) ; </a> 1
<a> } </a> 1
<a> int componentId = toComponentIndex ( offset ) ; </a> 1
<a> List < ByteBuf > slice = new ArrayList < ByteBuf > ( components . size ( ) ) ; </a> 1
<a> Component firstC = components . get ( componentId ) ; </a> 1
<a> ByteBuf first = firstC . buf . duplicate ( ) ; </a> 1
<a> first . readerIndex ( offset - firstC . offset ) ; </a> 1
<a> ByteBuf buf = first ; </a> 0
<a> int bytesToSlice = length ; </a> 0
<a> do { </a> 0
<a> int readableBytes = buf . readableBytes ( ) ; </a> 0
<a> if ( bytesToSlice <= readableBytes ) { </a> 0
<a> buf . writerIndex ( buf . readerIndex ( ) + bytesToSlice ) ; </a> 0
<a> slice . add ( buf ) ; </a> 0
<a> break ; </a> 0
<a> } else { </a> 0
<a> slice . add ( buf ) ; </a> 0
<a> bytesToSlice -= readableBytes ; </a> 0
<a> componentId ++ ; </a> 0
<a> buf = components . get ( componentId ) . buf . duplicate ( ) ; </a> 1
<a> } </a> 0
<a> } while ( bytesToSlice > 0 ) ; </a> 0
<a> for ( int i = 0 ; i < slice . size ( ) ; i ++ ) { </a> 0
<a> slice . set ( i , slice . get ( i ) . slice ( ) ) ; </a> 0
<a> } </a> 0
<a> return slice ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public boolean isDirect ( ) { </a> 1
<a> if ( components . size ( ) == 1 ) { </a> 1
<a> return components . get ( 0 ) . buf . isDirect ( ) ; </a> 1
<a> } </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean hasArray ( ) { </a> 1
<a> if ( components . size ( ) == 1 ) { </a> 1
<a> return components . get ( 0 ) . buf . hasArray ( ) ; </a> 1
<a> } </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public byte [ ] array ( ) { </a> 1
<a> if ( components . size ( ) == 1 ) { </a> 1
<a> return components . get ( 0 ) . buf . array ( ) ; </a> 1
<a> } </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int arrayOffset ( ) { </a> 1
<a> if ( components . size ( ) == 1 ) { </a> 1
<a> return components . get ( 0 ) . buf . arrayOffset ( ) ; </a> 1
<a> } </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int capacity ( ) { </a> 1
<a> if ( components . isEmpty ( ) ) { </a> 1
<a> return 0 ; </a> 1
<a> } </a> 1
<a> return components . get ( components . size ( ) - 1 ) . endOffset ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void capacity ( int newCapacity ) { </a> 0
<a> if ( newCapacity < 0 || newCapacity > maxCapacity ( ) ) { </a> 1
<a> throw new IllegalArgumentException ( "newCapacity: " + newCapacity ) ; </a> 1
<a> } </a> 1
<a> int oldCapacity = capacity ( ) ; </a> 1
<a> if ( newCapacity > oldCapacity ) { </a> 1
<a> final int paddingLength = newCapacity - oldCapacity ; </a> 1
<a> ByteBuf padding ; </a> 1
<a> if ( components . isEmpty ( ) ) { </a> 1
<a> padding = new HeapByteBuf ( paddingLength , paddingLength ) ; </a> 1
<a> } else { </a> 1
<a> Component last = components . get ( components . size ( ) - 1 ) ; </a> 1
<a> padding = last . buf . unsafe ( ) . newBuffer ( paddingLength ) ; </a> 1
<a> } </a> 0
<a> padding . setIndex ( 0 , paddingLength ) ; </a> 1
<a> addComponent ( padding ) ; </a> 1
<a> } else if ( newCapacity < oldCapacity ) { </a> 1
<a> int bytesToTrim = oldCapacity - newCapacity ; </a> 1
<a> for ( ListIterator < Component > i = components . listIterator ( components . size ( ) ) ; i . hasPrevious ( ) ; ) { </a> 1
<a> Component c = i . previous ( ) ; </a> 1
<a> if ( bytesToTrim >= c . length ) { </a> 1
<a> bytesToTrim -= c . length ; </a> 1
<a> i . remove ( ) ; </a> 1
<a> continue ; </a> 1
<a> } </a> 1
<a> Component newC = new Component ( c . buf . slice ( 0 , c . length - bytesToTrim ) ) ; </a> 1
<a> newC . offset = c . offset ; </a> 1
<a> newC . endOffset = newC . offset + newC . length ; </a> 1
<a> c . buf . unsafe ( ) . release ( ) ; </a> 1
<a> i . set ( newC ) ; </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> if ( readerIndex ( ) > newCapacity ) { </a> 1
<a> setIndex ( newCapacity , newCapacity ) ; </a> 1
<a> } else if ( writerIndex ( ) > newCapacity ) { </a> 1
<a> writerIndex ( newCapacity ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int numComponents ( ) { </a> 1
<a> return components . size ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int maxNumComponents ( ) { </a> 1
<a> return maxNumComponents ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int toComponentIndex ( int offset ) { </a> 1
<a> if ( offset < 0 || offset >= capacity ( ) ) { </a> 1
<a> throw new IndexOutOfBoundsException ( String . format ( </a> 1
<a> "offset: %d (expected: >= 0 && < capacity(%d))" , offset , capacity ( ) ) ) ; </a> 1
<a> } </a> 1
<a> Component c = lastAccessed ; </a> 1
<a> if ( c == null ) { </a> 1
<a> lastAccessed = c = components . get ( 0 ) ; </a> 1
<a> } </a> 1
<a> if ( offset >= c . offset ) { </a> 1
<a> if ( offset < c . endOffset ) { </a> 1
<a> return lastAccessedId ; </a> 1
<a> } </a> 1
<a> for ( int i = lastAccessedId + 1 ; i < components . size ( ) ; i ++ ) { </a> 1
<a> c = components . get ( i ) ; </a> 1
<a> if ( offset < c . endOffset ) { </a> 1
<a> lastAccessedId = i ; </a> 1
<a> lastAccessed = c ; </a> 1
<a> return i ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> for ( int i = lastAccessedId - 1 ; i >= 0 ; i -- ) { </a> 1
<a> c = components . get ( i ) ; </a> 1
<a> if ( offset >= c . offset ) { </a> 1
<a> lastAccessedId = i ; </a> 1
<a> lastAccessed = c ; </a> 1
<a> return i ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> throw new IllegalStateException ( "should not reach here - concurrent modification?" ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int toByteIndex ( int cIndex ) { </a> 1
<a> checkComponentIndex ( cIndex ) ; </a> 1
<a> return components . get ( cIndex ) . offset ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public byte getByte ( int index ) { </a> 1
<a> Component c = findComponent ( index ) ; </a> 1
<a> return c . buf . getByte ( index - c . offset ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public short getShort ( int index ) { </a> 0
<a> Component c = findComponent ( index ) ; </a> 1
<a> if ( index + 2 <= c . endOffset ) { </a> 1
<a> return c . buf . getShort ( index - c . offset ) ; </a> 1
<a> } else if ( order ( ) == ByteOrder . BIG_ENDIAN ) { </a> 1
<a> return ( short ) ( ( getByte ( index ) & 0xff ) < < 8 | getByte ( index + 1 ) & 0xff ) ; </a> 0
<a> } else { </a> 1
<a> return ( short ) ( getByte ( index ) & 0xff | ( getByte ( index + 1 ) & 0xff ) < < 8 ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getUnsignedMedium ( int index ) { </a> 0
<a> Component c = findComponent ( index ) ; </a> 1
<a> if ( index + 3 <= c . endOffset ) { </a> 1
<a> return c . buf . getUnsignedMedium ( index - c . offset ) ; </a> 1
<a> } else if ( order ( ) == ByteOrder . BIG_ENDIAN ) { </a> 1
<a> return ( getShort ( index ) & 0xffff ) < < 8 | getByte ( index + 2 ) & 0xff ; </a> 0
<a> } else { </a> 1
<a> return getShort ( index ) & 0xFFFF | ( getByte ( index + 2 ) & 0xFF ) < < 16 ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getInt ( int index ) { </a> 0
<a> Component c = findComponent ( index ) ; </a> 1
<a> if ( index + 4 <= c . endOffset ) { </a> 1
<a> return c . buf . getInt ( index - c . offset ) ; </a> 1
<a> } else if ( order ( ) == ByteOrder . BIG_ENDIAN ) { </a> 1
<a> return ( getShort ( index ) & 0xffff ) < < 16 | getShort ( index + 2 ) & 0xffff ; </a> 0
<a> } else { </a> 1
<a> return getShort ( index ) & 0xFFFF | ( getShort ( index + 2 ) & 0xFFFF ) < < 16 ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public long getLong ( int index ) { </a> 0
<a> Component c = findComponent ( index ) ; </a> 1
<a> if ( index + 8 <= c . endOffset ) { </a> 1
<a> return c . buf . getLong ( index - c . offset ) ; </a> 1
<a> } else if ( order ( ) == ByteOrder . BIG_ENDIAN ) { </a> 1
<a> return ( getInt ( index ) & 0xffffffffL ) < < 32 | getInt ( index + 4 ) & 0xffffffffL ; </a> 0
<a> } else { </a> 1
<a> return getInt ( index ) & 0xFFFFFFFFL | ( getInt ( index + 4 ) & 0xFFFFFFFFL ) < < 32 ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void getBytes ( int index , byte [ ] dst , int dstIndex , int length ) { </a> 0
<a> int componentId = toComponentIndex ( index ) ; </a> 1
<a> if ( index > capacity ( ) - length || dstIndex > dst . length - length ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to read - Needs " </a> 0
<a> + ( index + length ) + ", maximum is " + capacity ( ) + " or " </a> 0
<a> + dst . length ) ; </a> 0
<a> } </a> 0
<a> int i = componentId ; </a> 1
<a> while ( length > 0 ) { </a> 1
<a> Component c = components . get ( i ) ; </a> 1
<a> ByteBuf s = c . buf ; </a> 1
<a> int adjustment = c . offset ; </a> 1
<a> int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; </a> 0
<a> s . getBytes ( index - adjustment , dst , dstIndex , localLength ) ; </a> 0
<a> index += localLength ; </a> 0
<a> dstIndex += localLength ; </a> 0
<a> length -= localLength ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void getBytes ( int index , ByteBuffer dst ) { </a> 0
<a> int componentId = toComponentIndex ( index ) ; </a> 1
<a> int limit = dst . limit ( ) ; </a> 1
<a> int length = dst . remaining ( ) ; </a> 1
<a> if ( index > capacity ( ) - length ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to be read - Needs " </a> 0
<a> + ( index + length ) + ", maximum is " + capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> int i = componentId ; </a> 1
<a> try { </a> 1
<a> while ( length > 0 ) { </a> 1
<a> Component c = components . get ( i ) ; </a> 1
<a> ByteBuf s = c . buf ; </a> 1
<a> int adjustment = c . offset ; </a> 1
<a> int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; </a> 0
<a> dst . limit ( dst . position ( ) + localLength ) ; </a> 0
<a> s . getBytes ( index - adjustment , dst ) ; </a> 0
<a> index += localLength ; </a> 0
<a> length -= localLength ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> dst . limit ( limit ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void getBytes ( int index , ByteBuf dst , int dstIndex , int length ) { </a> 0
<a> int componentId = toComponentIndex ( index ) ; </a> 1
<a> if ( index > capacity ( ) - length || dstIndex > dst . capacity ( ) - length ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to be read - Needs " </a> 0
<a> + ( index + length ) + " or " + ( dstIndex + length ) + ", maximum is " </a> 0
<a> + capacity ( ) + " or " + dst . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> int i = componentId ; </a> 1
<a> while ( length > 0 ) { </a> 1
<a> Component c = components . get ( i ) ; </a> 1
<a> ByteBuf s = c . buf ; </a> 1
<a> int adjustment = c . offset ; </a> 1
<a> int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; </a> 0
<a> s . getBytes ( index - adjustment , dst , dstIndex , localLength ) ; </a> 0
<a> index += localLength ; </a> 0
<a> dstIndex += localLength ; </a> 0
<a> length -= localLength ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getBytes ( int index , GatheringByteChannel out , int length ) </a> 0
<a> throws IOException { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 1
<a> return out . write ( copiedNioBuffer ( index , length ) ) ; </a> 0
<a> } else { </a> 0
<a> long writtenBytes = out . write ( nioBuffers ( index , length ) ) ; </a> 0
<a> if ( writtenBytes > Integer . MAX_VALUE ) { </a> 0
<a> return Integer . MAX_VALUE ; </a> 0
<a> } else { </a> 0
<a> return ( int ) writtenBytes ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , OutputStream out , int length ) </a> 0
<a> throws IOException { </a> 1
<a> int componentId = toComponentIndex ( index ) ; </a> 1
<a> if ( index > capacity ( ) - length ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to be read - needs " </a> 0
<a> + ( index + length ) + ", maximum of " + capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> int i = componentId ; </a> 1
<a> while ( length > 0 ) { </a> 1
<a> Component c = components . get ( i ) ; </a> 1
<a> ByteBuf s = c . buf ; </a> 1
<a> int adjustment = c . offset ; </a> 1
<a> int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; </a> 0
<a> s . getBytes ( index - adjustment , out , localLength ) ; </a> 0
<a> index += localLength ; </a> 0
<a> length -= localLength ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setByte ( int index , int value ) { </a> 0
<a> Component c = findComponent ( index ) ; </a> 1
<a> c . buf . setByte ( index - c . offset , value ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setShort ( int index , int value ) { </a> 0
<a> Component c = findComponent ( index ) ; </a> 1
<a> if ( index + 2 <= c . endOffset ) { </a> 1
<a> c . buf . setShort ( index - c . offset , value ) ; </a> 1
<a> } else if ( order ( ) == ByteOrder . BIG_ENDIAN ) { </a> 1
<a> setByte ( index , ( byte ) ( value > > > 8 ) ) ; </a> 0
<a> setByte ( index + 1 , ( byte ) value ) ; </a> 0
<a> } else { </a> 1
<a> setByte ( index , ( byte ) value ) ; </a> 0
<a> setByte ( index + 1 , ( byte ) ( value > > > 8 ) ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setMedium ( int index , int value ) { </a> 0
<a> Component c = findComponent ( index ) ; </a> 1
<a> if ( index + 3 <= c . endOffset ) { </a> 1
<a> c . buf . setMedium ( index - c . offset , value ) ; </a> 1
<a> } else if ( order ( ) == ByteOrder . BIG_ENDIAN ) { </a> 1
<a> setShort ( index , ( short ) ( value > > 8 ) ) ; </a> 0
<a> setByte ( index + 2 , ( byte ) value ) ; </a> 0
<a> } else { </a> 1
<a> setShort ( index , ( short ) value ) ; </a> 0
<a> setByte ( index + 2 , ( byte ) ( value > > > 16 ) ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setInt ( int index , int value ) { </a> 0
<a> Component c = findComponent ( index ) ; </a> 1
<a> if ( index + 4 <= c . endOffset ) { </a> 1
<a> c . buf . setInt ( index - c . offset , value ) ; </a> 1
<a> } else if ( order ( ) == ByteOrder . BIG_ENDIAN ) { </a> 1
<a> setShort ( index , ( short ) ( value > > > 16 ) ) ; </a> 0
<a> setShort ( index + 2 , ( short ) value ) ; </a> 0
<a> } else { </a> 1
<a> setShort ( index , ( short ) value ) ; </a> 0
<a> setShort ( index + 2 , ( short ) ( value > > > 16 ) ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setLong ( int index , long value ) { </a> 0
<a> Component c = findComponent ( index ) ; </a> 1
<a> if ( index + 8 <= c . endOffset ) { </a> 1
<a> c . buf . setLong ( index - c . offset , value ) ; </a> 1
<a> } else if ( order ( ) == ByteOrder . BIG_ENDIAN ) { </a> 1
<a> setInt ( index , ( int ) ( value > > > 32 ) ) ; </a> 0
<a> setInt ( index + 4 , ( int ) value ) ; </a> 0
<a> } else { </a> 1
<a> setInt ( index , ( int ) value ) ; </a> 0
<a> setInt ( index + 4 , ( int ) ( value > > > 32 ) ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setBytes ( int index , byte [ ] src , int srcIndex , int length ) { </a> 0
<a> int componentId = toComponentIndex ( index ) ; </a> 1
<a> if ( index > capacity ( ) - length || srcIndex > src . length - length ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to read - needs " </a> 0
<a> + ( index + length ) + " or " + ( srcIndex + length ) + ", maximum is " </a> 0
<a> + capacity ( ) + " or " + src . length ) ; </a> 0
<a> } </a> 0
<a> int i = componentId ; </a> 1
<a> while ( length > 0 ) { </a> 1
<a> Component c = components . get ( i ) ; </a> 1
<a> ByteBuf s = c . buf ; </a> 1
<a> int adjustment = c . offset ; </a> 1
<a> int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; </a> 0
<a> s . setBytes ( index - adjustment , src , srcIndex , localLength ) ; </a> 0
<a> index += localLength ; </a> 0
<a> srcIndex += localLength ; </a> 0
<a> length -= localLength ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setBytes ( int index , ByteBuffer src ) { </a> 0
<a> int componentId = toComponentIndex ( index ) ; </a> 1
<a> int limit = src . limit ( ) ; </a> 1
<a> int length = src . remaining ( ) ; </a> 1
<a> if ( index > capacity ( ) - length ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to be written - Needs " </a> 0
<a> + ( index + length ) + ", maximum is " + capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> int i = componentId ; </a> 1
<a> try { </a> 1
<a> while ( length > 0 ) { </a> 1
<a> Component c = components . get ( i ) ; </a> 1
<a> ByteBuf s = c . buf ; </a> 1
<a> int adjustment = c . offset ; </a> 1
<a> int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; </a> 0
<a> src . limit ( src . position ( ) + localLength ) ; </a> 0
<a> s . setBytes ( index - adjustment , src ) ; </a> 0
<a> index += localLength ; </a> 0
<a> length -= localLength ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> src . limit ( limit ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setBytes ( int index , ByteBuf src , int srcIndex , int length ) { </a> 0
<a> int componentId = toComponentIndex ( index ) ; </a> 1
<a> if ( index > capacity ( ) - length || srcIndex > src . capacity ( ) - length ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to be written - Needs " </a> 0
<a> + ( index + length ) + " or " + ( srcIndex + length ) + ", maximum is " </a> 0
<a> + capacity ( ) + " or " + src . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> int i = componentId ; </a> 1
<a> while ( length > 0 ) { </a> 1
<a> Component c = components . get ( i ) ; </a> 1
<a> ByteBuf s = c . buf ; </a> 1
<a> int adjustment = c . offset ; </a> 1
<a> int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; </a> 0
<a> s . setBytes ( index - adjustment , src , srcIndex , localLength ) ; </a> 0
<a> index += localLength ; </a> 0
<a> srcIndex += localLength ; </a> 0
<a> length -= localLength ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public int setBytes ( int index , InputStream in , int length ) </a> 1
<a> throws IOException { </a> 1
<a> int componentId = toComponentIndex ( index ) ; </a> 1
<a> if ( index > capacity ( ) - length ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to write - Needs " </a> 0
<a> + ( index + length ) + ", maximum is " + capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> int i = componentId ; </a> 1
<a> int readBytes = 0 ; </a> 1
<a> do { </a> 1
<a> Component c = components . get ( i ) ; </a> 1
<a> ByteBuf s = c . buf ; </a> 1
<a> int adjustment = c . offset ; </a> 1
<a> int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; </a> 0
<a> int localReadBytes = s . setBytes ( index - adjustment , in , localLength ) ; </a> 0
<a> if ( localReadBytes < 0 ) { </a> 0
<a> if ( readBytes == 0 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } else { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( localReadBytes == localLength ) { </a> 0
<a> index += localLength ; </a> 0
<a> length -= localLength ; </a> 0
<a> readBytes += localLength ; </a> 0
<a> i ++ ; </a> 0
<a> } else { </a> 0
<a> index += localReadBytes ; </a> 0
<a> length -= localReadBytes ; </a> 0
<a> readBytes += localReadBytes ; </a> 0
<a> } </a> 0
<a> } while ( length > 0 ) ; </a> 0
<a> return readBytes ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , ScatteringByteChannel in , int length ) </a> 1
<a> throws IOException { </a> 1
<a> int componentId = toComponentIndex ( index ) ; </a> 1
<a> if ( index > capacity ( ) - length ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to write - Needs " </a> 0
<a> + ( index + length ) + ", maximum is " + capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> int i = componentId ; </a> 1
<a> int readBytes = 0 ; </a> 1
<a> do { </a> 1
<a> Component c = components . get ( i ) ; </a> 1
<a> ByteBuf s = c . buf ; </a> 1
<a> int adjustment = c . offset ; </a> 1
<a> int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; </a> 1
<a> int localReadBytes = s . setBytes ( index - adjustment , in , localLength ) ; </a> 1
<a> if ( localReadBytes == 0 ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> if ( localReadBytes < 0 ) { </a> 0
<a> if ( readBytes == 0 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } else { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( localReadBytes == localLength ) { </a> 0
<a> index += localLength ; </a> 0
<a> length -= localLength ; </a> 0
<a> readBytes += localLength ; </a> 0
<a> i ++ ; </a> 0
<a> } else { </a> 0
<a> index += localReadBytes ; </a> 0
<a> length -= localReadBytes ; </a> 0
<a> readBytes += localReadBytes ; </a> 0
<a> } </a> 0
<a> } while ( length > 0 ) ; </a> 0
<a> return readBytes ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf copy ( int index , int length ) { </a> 1
<a> int componentId = toComponentIndex ( index ) ; </a> 1
<a> if ( index > capacity ( ) - length ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to copy - Needs " </a> 0
<a> + ( index + length ) + ", maximum is " + capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> ByteBuf dst = unsafe ( ) . newBuffer ( length ) ; </a> 1
<a> copyTo ( index , length , componentId , dst ) ; </a> 1
<a> return dst ; </a> 0
<a> } </a> 0
<a> private void copyTo ( int index , int length , int componentId , ByteBuf dst ) { </a> 0
<a> int dstIndex = 0 ; </a> 0
<a> int i = componentId ; </a> 0
<a> while ( length > 0 ) { </a> 0
<a> Component c = components . get ( i ) ; </a> 1
<a> ByteBuf s = c . buf ; </a> 1
<a> int adjustment = c . offset ; </a> 1
<a> int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; </a> 0
<a> s . getBytes ( index - adjustment , dst , dstIndex , localLength ) ; </a> 0
<a> index += localLength ; </a> 0
<a> dstIndex += localLength ; </a> 0
<a> length -= localLength ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> dst . writerIndex ( dst . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public ByteBuf component ( int cIndex ) { </a> 1
<a> checkComponentIndex ( cIndex ) ; </a> 1
<a> return components . get ( cIndex ) . buf ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf componentAtOffset ( int offset ) { </a> 1
<a> return findComponent ( offset ) . buf ; </a> 1
<a> } </a> 1
<a> private Component findComponent ( int offset ) { </a> 1
<a> if ( offset < 0 || offset >= capacity ( ) ) { </a> 1
<a> throw new IndexOutOfBoundsException ( String . format ( </a> 1
<a> "offset: %d (expected: >= 0 && < capacity(%d))" , offset , capacity ( ) ) ) ; </a> 1
<a> } </a> 1
<a> Component c = lastAccessed ; </a> 1
<a> if ( c == null ) { </a> 1
<a> lastAccessed = c = components . get ( 0 ) ; </a> 1
<a> } </a> 1
<a> if ( offset >= c . offset ) { </a> 1
<a> if ( offset < c . endOffset ) { </a> 1
<a> return c ; </a> 1
<a> } </a> 1
<a> for ( int i = lastAccessedId + 1 ; i < components . size ( ) ; i ++ ) { </a> 1
<a> c = components . get ( i ) ; </a> 1
<a> if ( offset < c . endOffset ) { </a> 1
<a> lastAccessedId = i ; </a> 1
<a> lastAccessed = c ; </a> 1
<a> return c ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> for ( int i = lastAccessedId - 1 ; i >= 0 ; i -- ) { </a> 1
<a> c = components . get ( i ) ; </a> 1
<a> if ( offset >= c . offset ) { </a> 1
<a> lastAccessedId = i ; </a> 1
<a> lastAccessed = c ; </a> 1
<a> return c ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> throw new IllegalStateException ( "should not reach here - concurrent modification?" ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean hasNioBuffer ( ) { </a> 1
<a> if ( components . size ( ) == 1 ) { </a> 1
<a> return components . get ( 0 ) . buf . hasNioBuffer ( ) ; </a> 1
<a> } </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer nioBuffer ( int index , int length ) { </a> 0
<a> if ( components . size ( ) == 1 ) { </a> 1
<a> return components . get ( 0 ) . buf . nioBuffer ( index , length ) ; </a> 0
<a> } </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> private ByteBuffer copiedNioBuffer ( int index , int length ) { </a> 0
<a> if ( components . size ( ) == 1 ) { </a> 1
<a> return toNioBuffer ( components . get ( 0 ) . buf , index , length ) ; </a> 1
<a> } </a> 0
<a> ByteBuffer [ ] buffers = nioBuffers ( index , length ) ; </a> 0
<a> ByteBuffer merged = ByteBuffer . allocate ( length ) . order ( order ( ) ) ; </a> 0
<a> for ( ByteBuffer b : buffers ) { </a> 0
<a> merged . put ( b ) ; </a> 0
<a> } </a> 0
<a> merged . flip ( ) ; </a> 0
<a> return merged ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public boolean hasNioBuffers ( ) { </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( int index , int length ) { </a> 1
<a> int componentId = toComponentIndex ( index ) ; </a> 1
<a> if ( index + length > capacity ( ) ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to convert - Needs" </a> 0
<a> + ( index + length ) + ", maximum is " + capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> List < ByteBuffer > buffers = new ArrayList < ByteBuffer > ( components . size ( ) ) ; </a> 1
<a> int i = componentId ; </a> 1
<a> while ( length > 0 ) { </a> 1
<a> Component c = components . get ( i ) ; </a> 1
<a> ByteBuf s = c . buf ; </a> 1
<a> int adjustment = c . offset ; </a> 1
<a> int localLength = Math . min ( length , s . capacity ( ) - ( index - adjustment ) ) ; </a> 1
<a> buffers . add ( toNioBuffer ( s , index - adjustment , localLength ) ) ; </a> 1
<a> index += localLength ; </a> 0
<a> length -= localLength ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> return buffers . toArray ( new ByteBuffer [ buffers . size ( ) ] ) ; </a> 0
<a> } </a> 0
<a> private static ByteBuffer toNioBuffer ( ByteBuf buf , int index , int length ) { </a> 0
<a> if ( buf . hasNioBuffer ( ) ) { </a> 1
<a> return buf . nioBuffer ( index , length ) ; </a> 0
<a> } else { </a> 0
<a> return buf . copy ( index , length ) . nioBuffer ( 0 , length ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void consolidate ( ) { </a> 0
<a> final int numComponents = numComponents ( ) ; </a> 1
<a> if ( numComponents <= 1 ) { </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> final Component last = components . get ( numComponents - 1 ) ; </a> 1
<a> final int capacity = last . endOffset ; </a> 1
<a> final ByteBuf consolidated = last . buf . unsafe ( ) . newBuffer ( capacity ) ; </a> 1
<a> for ( int i = 0 ; i < numComponents ; i ++ ) { </a> 1
<a> ByteBuf b = components . get ( i ) . buf ; </a> 1
<a> consolidated . writeBytes ( b ) ; </a> 1
<a> b . unsafe ( ) . release ( ) ; </a> 1
<a> } </a> 1
<a> components . clear ( ) ; </a> 1
<a> components . add ( new Component ( consolidated ) ) ; </a> 1
<a> updateComponentOffsets ( 0 ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void consolidate ( int cIndex , int numComponents ) { </a> 0
<a> checkComponentIndex ( cIndex , numComponents ) ; </a> 1
<a> if ( numComponents <= 1 ) { </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> final int endCIndex = cIndex + numComponents ; </a> 1
<a> final Component last = components . get ( endCIndex - 1 ) ; </a> 1
<a> final int capacity = last . endOffset - components . get ( cIndex ) . offset ; </a> 1
<a> final ByteBuf consolidated = last . buf . unsafe ( ) . newBuffer ( capacity ) ; </a> 1
<a> for ( int i = cIndex ; i < endCIndex ; i ++ ) { </a> 1
<a> ByteBuf b = components . get ( i ) . buf ; </a> 1
<a> consolidated . writeBytes ( b ) ; </a> 1
<a> b . unsafe ( ) . release ( ) ; </a> 1
<a> } </a> 1
<a> components . subList ( cIndex + 1 , endCIndex ) . clear ( ) ; </a> 1
<a> components . set ( cIndex , new Component ( consolidated ) ) ; </a> 1
<a> updateComponentOffsets ( cIndex ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void discardReadComponents ( ) { </a> 0
<a> final int readerIndex = readerIndex ( ) ; </a> 1
<a> if ( readerIndex == 0 ) { </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> int writerIndex = writerIndex ( ) ; </a> 1
<a> if ( readerIndex == writerIndex && writerIndex == capacity ( ) ) { </a> 1
<a> for ( Component c : components ) { </a> 1
<a> c . buf . unsafe ( ) . release ( ) ; </a> 1
<a> } </a> 1
<a> components . clear ( ) ; </a> 1
<a> setIndex ( 0 , 0 ) ; </a> 1
<a> adjustMarkers ( readerIndex ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> int firstComponentId = toComponentIndex ( readerIndex ) ; </a> 1
<a> for ( int i = 0 ; i < firstComponentId ; i ++ ) { </a> 1
<a> components . get ( i ) . buf . unsafe ( ) . release ( ) ; </a> 1
<a> } </a> 1
<a> components . subList ( 0 , firstComponentId ) . clear ( ) ; </a> 1
<a> Component first = components . get ( 0 ) ; </a> 1
<a> updateComponentOffsets ( 0 ) ; </a> 1
<a> setIndex ( readerIndex - first . offset , writerIndex - first . offset ) ; </a> 1
<a> adjustMarkers ( first . offset ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void discardReadBytes ( ) { </a> 0
<a> final int readerIndex = readerIndex ( ) ; </a> 1
<a> if ( readerIndex == 0 ) { </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> int writerIndex = writerIndex ( ) ; </a> 1
<a> if ( readerIndex == writerIndex && writerIndex == capacity ( ) ) { </a> 1
<a> for ( Component c : components ) { </a> 1
<a> c . buf . unsafe ( ) . release ( ) ; </a> 1
<a> } </a> 1
<a> components . clear ( ) ; </a> 1
<a> setIndex ( 0 , 0 ) ; </a> 1
<a> adjustMarkers ( readerIndex ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> int firstComponentId = toComponentIndex ( readerIndex ) ; </a> 1
<a> for ( int i = 0 ; i < firstComponentId ; i ++ ) { </a> 1
<a> components . get ( i ) . buf . unsafe ( ) . release ( ) ; </a> 1
<a> } </a> 1
<a> components . subList ( 0 , firstComponentId ) . clear ( ) ; </a> 1
<a> Component c = components . get ( 0 ) ; </a> 1
<a> int adjustment = readerIndex - c . offset ; </a> 1
<a> if ( adjustment == c . length ) { </a> 1
<a> components . remove ( 0 ) ; </a> 1
<a> } else { </a> 1
<a> Component newC = new Component ( c . buf . slice ( adjustment , c . length - adjustment ) ) ; </a> 1
<a> c . buf . unsafe ( ) . release ( ) ; </a> 1
<a> components . set ( 0 , newC ) ; </a> 1
<a> } </a> 1
<a> updateComponentOffsets ( 0 ) ; </a> 1
<a> setIndex ( 0 , writerIndex - readerIndex ) ; </a> 1
<a> adjustMarkers ( readerIndex ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> String result = super . toString ( ) ; </a> 0
<a> result = result . substring ( 0 , result . length ( ) - 1 ) ; </a> 0
<a> return result + ", components=" + components . size ( ) + ")" ; </a> 0
<a> } </a> 1
<a> private static final class Component { </a> 1
<a> final ByteBuf buf ; </a> 1
<a> final int length ; </a> 1
<a> int offset ; </a> 1
<a> int endOffset ; </a> 1
<a> Component ( ByteBuf buf ) { </a> 1
<a> this . buf = buf ; </a> 1
<a> length = buf . readableBytes ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public Unsafe unsafe ( ) { </a> 1
<a> return unsafe ; </a> 1
<a> } </a> 1
<a> private final class CompositeUnsafe implements Unsafe { </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer nioBuffer ( ) { </a> 1
<a> if ( components . size ( ) == 1 ) { </a> 1
<a> return components . get ( 0 ) . buf . unsafe ( ) . nioBuffer ( ) ; </a> 1
<a> } </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( ) { </a> 1
<a> ByteBuffer [ ] nioBuffers = new ByteBuffer [ components . size ( ) ] ; </a> 1
<a> int index = 0 ; </a> 1
<a> for ( Component component : components ) { </a> 1
<a> nioBuffers [ index ++ ] = component . buf . unsafe ( ) . nioBuffer ( ) ; </a> 1
<a> } </a> 1
<a> return nioBuffers ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf newBuffer ( int initialCapacity ) { </a> 1
<a> CompositeByteBuf buf = new DefaultCompositeByteBuf ( maxNumComponents ) ; </a> 1
<a> buf . addComponent ( new HeapByteBuf ( new byte [ initialCapacity ] , initialCapacity ) ) ; </a> 1
<a> return buf ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void discardSomeReadBytes ( ) { </a> 1
<a> discardReadComponents ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public void acquire ( ) { </a> 1
<a> if ( refCnt <= 0 ) { </a> 1
<a> throw new IllegalStateException ( ) ; </a> 1
<a> } </a> 1
<a> refCnt ++ ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void release ( ) { </a> 1
<a> if ( refCnt <= 0 ) { </a> 1
<a> throw new IllegalStateException ( ) ; </a> 1
<a> } </a> 1
<a> refCnt -- ; </a> 1
<a> if ( refCnt == 0 ) { </a> 1
<a> for ( Component c : components ) { </a> 1
<a> c . buf . unsafe ( ) . release ( ) ; </a> 1
<a> } </a> 1
<a> components . clear ( ) ; </a> 1
<a> lastAccessed = null ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( ) { </a> 1
<a> return nioBuffers ( readerIndex ( ) , readableBytes ( ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . util . ArrayDeque ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> public class DefaultMessageBuf < T > extends ArrayDeque < T > implements MessageBuf < T > { </a> 0
<a> private static final long serialVersionUID = 1229808623624907552L ; </a> 0
<a> public DefaultMessageBuf ( ) { } </a> 0
<a> public DefaultMessageBuf ( Collection < ? extends T > c ) { </a> 0
<a> super ( c ) ; </a> 0
<a> } </a> 0
<a> public DefaultMessageBuf ( int initialCapacity ) { </a> 0
<a> super ( initialCapacity ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public boolean isPooled ( ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelBufType type ( ) { </a> 1
<a> return ChannelBufType . MESSAGE ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public int drainTo ( Collection < ? super T > c ) { </a> 0
<a> int cnt = 0 ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> T o = poll ( ) ; </a> 0
<a> if ( o == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 1
<a> c . add ( o ) ; </a> 0
<a> cnt ++ ; </a> 0
<a> } </a> 1
<a> return cnt ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public int drainTo ( Collection < ? super T > c , int maxElements ) { </a> 0
<a> int cnt = 0 ; </a> 0
<a> while ( cnt < maxElements ) { </a> 0
<a> T o = poll ( ) ; </a> 0
<a> if ( o == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 1
<a> c . add ( o ) ; </a> 0
<a> cnt ++ ; </a> 0
<a> } </a> 1
<a> return cnt ; </a> 0
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . lang . reflect . Field ; </a> 1
<a> import java . nio . ByteBuffer ; </a> 1
<a> import java . nio . ByteOrder ; </a> 1
<a> import java . nio . channels . ClosedChannelException ; </a> 0
<a> import java . nio . channels . GatheringByteChannel ; </a> 0
<a> import java . nio . channels . ScatteringByteChannel ; </a> 0
<a> import sun . misc . Cleaner ; </a> 0
<a> @ SuppressWarnings ( "restriction" ) </a> 1
<a> public class DirectByteBuf extends AbstractByteBuf { </a> 1
<a> private static final Field CLEANER_FIELD ; </a> 1
<a> static { </a> 1
<a> ByteBuffer direct = ByteBuffer . allocateDirect ( 1 ) ; </a> 1
<a> Field cleanerField ; </a> 1
<a> try { </a> 1
<a> cleanerField = direct . getClass ( ) . getDeclaredField ( "cleaner" ) ; </a> 1
<a> cleanerField . setAccessible ( true ) ; </a> 1
<a> Cleaner cleaner = ( Cleaner ) cleanerField . get ( direct ) ; </a> 1
<a> cleaner . clean ( ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> cleanerField = null ; </a> 1
<a> } </a> 1
<a> CLEANER_FIELD = cleanerField ; </a> 1
<a> } </a> 1
<a> private static void freeDirect ( ByteBuffer buffer ) { </a> 1
<a> Cleaner cleaner ; </a> 1
<a> try { </a> 1
<a> cleaner = ( Cleaner ) CLEANER_FIELD . get ( buffer ) ; </a> 1
<a> cleaner . clean ( ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private final Unsafe unsafe = new DirectUnsafe ( ) ; </a> 1
<a> private boolean doNotFree ; </a> 1
<a> private ByteBuffer buffer ; </a> 1
<a> private ByteBuffer tmpBuf ; </a> 1
<a> private int capacity ; </a> 1
<a> public DirectByteBuf ( int initialCapacity , int maxCapacity ) { </a> 1
<a> super ( ByteOrder . BIG_ENDIAN , maxCapacity ) ; </a> 1
<a> if ( initialCapacity < 0 ) { </a> 1
<a> throw new IllegalArgumentException ( "initialCapacity: " + initialCapacity ) ; </a> 1
<a> } </a> 1
<a> if ( maxCapacity < 0 ) { </a> 1
<a> throw new IllegalArgumentException ( "maxCapacity: " + maxCapacity ) ; </a> 1
<a> } </a> 1
<a> if ( initialCapacity > maxCapacity ) { </a> 1
<a> throw new IllegalArgumentException ( String . format ( </a> 1
<a> "initialCapacity(%d) > maxCapacity(%d)" , initialCapacity , maxCapacity ) ) ; </a> 1
<a> } </a> 1
<a> setByteBuffer ( ByteBuffer . allocateDirect ( initialCapacity ) ) ; </a> 1
<a> } </a> 1
<a> public DirectByteBuf ( ByteBuffer initialBuffer , int maxCapacity ) { </a> 1
<a> super ( ByteOrder . BIG_ENDIAN , maxCapacity ) ; </a> 1
<a> if ( initialBuffer == null ) { </a> 1
<a> throw new NullPointerException ( "initialBuffer" ) ; </a> 1
<a> } </a> 1
<a> if ( ! initialBuffer . isDirect ( ) ) { </a> 1
<a> throw new IllegalArgumentException ( "initialBuffer is not a direct buffer." ) ; </a> 1
<a> } </a> 1
<a> if ( initialBuffer . isReadOnly ( ) ) { </a> 1
<a> throw new IllegalArgumentException ( "initialBuffer is a read-only buffer." ) ; </a> 1
<a> } </a> 1
<a> int initialCapacity = initialBuffer . remaining ( ) ; </a> 1
<a> if ( initialCapacity > maxCapacity ) { </a> 1
<a> throw new IllegalArgumentException ( String . format ( </a> 1
<a> "initialCapacity(%d) > maxCapacity(%d)" , initialCapacity , maxCapacity ) ) ; </a> 1
<a> } </a> 1
<a> doNotFree = true ; </a> 1
<a> setByteBuffer ( initialBuffer . slice ( ) . order ( ByteOrder . BIG_ENDIAN ) ) ; </a> 1
<a> writerIndex ( initialCapacity ) ; </a> 1
<a> } </a> 1
<a> private void setByteBuffer ( ByteBuffer buffer ) { </a> 1
<a> ByteBuffer oldBuffer = this . buffer ; </a> 1
<a> if ( oldBuffer != null ) { </a> 1
<a> if ( doNotFree ) { </a> 1
<a> doNotFree = false ; </a> 1
<a> } else { </a> 1
<a> freeDirect ( oldBuffer ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> this . buffer = buffer ; </a> 1
<a> tmpBuf = buffer . duplicate ( ) ; </a> 1
<a> capacity = buffer . remaining ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isDirect ( ) { </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int capacity ( ) { </a> 1
<a> return capacity ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void capacity ( int newCapacity ) { </a> 0
<a> if ( newCapacity < 0 || newCapacity > maxCapacity ( ) ) { </a> 1
<a> throw new IllegalArgumentException ( "newCapacity: " + newCapacity ) ; </a> 1
<a> } </a> 1
<a> int readerIndex = readerIndex ( ) ; </a> 1
<a> int writerIndex = writerIndex ( ) ; </a> 1
<a> int oldCapacity = capacity ; </a> 1
<a> if ( newCapacity > oldCapacity ) { </a> 1
<a> ByteBuffer oldBuffer = buffer ; </a> 1
<a> ByteBuffer newBuffer = ByteBuffer . allocateDirect ( newCapacity ) ; </a> 1
<a> oldBuffer . position ( readerIndex ) . limit ( writerIndex ) ; </a> 1
<a> newBuffer . position ( readerIndex ) . limit ( writerIndex ) ; </a> 1
<a> newBuffer . put ( oldBuffer ) ; </a> 1
<a> newBuffer . clear ( ) ; </a> 1
<a> setByteBuffer ( newBuffer ) ; </a> 1
<a> } else if ( newCapacity < oldCapacity ) { </a> 1
<a> ByteBuffer oldBuffer = buffer ; </a> 1
<a> ByteBuffer newBuffer = ByteBuffer . allocateDirect ( newCapacity ) ; </a> 1
<a> if ( readerIndex < newCapacity ) { </a> 1
<a> if ( writerIndex > newCapacity ) { </a> 1
<a> writerIndex ( writerIndex = newCapacity ) ; </a> 1
<a> } </a> 1
<a> oldBuffer . position ( readerIndex ) . limit ( writerIndex ) ; </a> 1
<a> newBuffer . position ( readerIndex ) . limit ( writerIndex ) ; </a> 1
<a> newBuffer . put ( oldBuffer ) ; </a> 1
<a> newBuffer . clear ( ) ; </a> 1
<a> } else { </a> 1
<a> setIndex ( newCapacity , newCapacity ) ; </a> 1
<a> } </a> 1
<a> setByteBuffer ( newBuffer ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasArray ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte [ ] array ( ) { </a> 0
<a> throw new UnsupportedOperationException ( "direct buffer" ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int arrayOffset ( ) { </a> 1
<a> throw new UnsupportedOperationException ( "direct buffer" ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public byte getByte ( int index ) { </a> 0
<a> return buffer . get ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short getShort ( int index ) { </a> 0
<a> return buffer . getShort ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getUnsignedMedium ( int index ) { </a> 0
<a> return ( getByte ( index ) & 0xff ) < < 16 | ( getByte ( index + 1 ) & 0xff ) < < 8 | </a> 0
<a> ( getByte ( index + 2 ) & 0xff ) < < 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getInt ( int index ) { </a> 0
<a> return buffer . getInt ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getLong ( int index ) { </a> 0
<a> return buffer . getLong ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuf dst , int dstIndex , int length ) { </a> 0
<a> if ( dst instanceof DirectByteBuf ) { </a> 1
<a> DirectByteBuf bbdst = ( DirectByteBuf ) dst ; </a> 1
<a> ByteBuffer data = bbdst . tmpBuf ; </a> 0
<a> data . clear ( ) . position ( dstIndex ) . limit ( dstIndex + length ) ; </a> 1
<a> getBytes ( index , data ) ; </a> 1
<a> } else if ( buffer . hasArray ( ) ) { </a> 1
<a> dst . setBytes ( dstIndex , buffer . array ( ) , index + buffer . arrayOffset ( ) , length ) ; </a> 1
<a> } else { </a> 0
<a> dst . setBytes ( dstIndex , this , index , length ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void getBytes ( int index , byte [ ] dst , int dstIndex , int length ) { </a> 0
<a> try { </a> 0
<a> tmpBuf . clear ( ) . position ( index ) . limit ( index + length ) ; </a> 0
<a> } catch ( IllegalArgumentException e ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to read - Need " + </a> 1
<a> ( index + length ) + ", maximum is " + buffer . limit ( ) ) ; </a> 1
<a> } </a> 1
<a> tmpBuf . get ( dst , dstIndex , length ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void getBytes ( int index , ByteBuffer dst ) { </a> 0
<a> int bytesToCopy = Math . min ( capacity ( ) - index , dst . remaining ( ) ) ; </a> 1
<a> try { </a> 0
<a> tmpBuf . clear ( ) . position ( index ) . limit ( index + bytesToCopy ) ; </a> 1
<a> } catch ( IllegalArgumentException e ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Too many bytes to read - Need " + </a> 1
<a> ( index + bytesToCopy ) + ", maximum is " + buffer . limit ( ) ) ; </a> 1
<a> } </a> 1
<a> dst . put ( tmpBuf ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setByte ( int index , int value ) { </a> 0
<a> buffer . put ( index , ( byte ) value ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setShort ( int index , int value ) { </a> 0
<a> buffer . putShort ( index , ( short ) value ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setMedium ( int index , int value ) { </a> 0
<a> setByte ( index , ( byte ) ( value > > > 16 ) ) ; </a> 1
<a> setByte ( index + 1 , ( byte ) ( value > > > 8 ) ) ; </a> 1
<a> setByte ( index + 2 , ( byte ) ( value > > > 0 ) ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setInt ( int index , int value ) { </a> 0
<a> buffer . putInt ( index , value ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setLong ( int index , long value ) { </a> 0
<a> buffer . putLong ( index , value ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setBytes ( int index , ByteBuf src , int srcIndex , int length ) { </a> 0
<a> if ( src instanceof DirectByteBuf ) { </a> 1
<a> DirectByteBuf bbsrc = ( DirectByteBuf ) src ; </a> 1
<a> ByteBuffer data = bbsrc . tmpBuf ; </a> 0
<a> data . clear ( ) . position ( srcIndex ) . limit ( srcIndex + length ) ; </a> 0
<a> setBytes ( index , data ) ; </a> 0
<a> } else if ( buffer . hasArray ( ) ) { </a> 0
<a> src . getBytes ( srcIndex , buffer . array ( ) , index + buffer . arrayOffset ( ) , length ) ; </a> 0
<a> } else { </a> 0
<a> src . getBytes ( srcIndex , this , index , length ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setBytes ( int index , byte [ ] src , int srcIndex , int length ) { </a> 0
<a> tmpBuf . clear ( ) . position ( index ) . limit ( index + length ) ; </a> 1
<a> tmpBuf . put ( src , srcIndex , length ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setBytes ( int index , ByteBuffer src ) { </a> 0
<a> if ( src == tmpBuf ) { </a> 0
<a> src = src . duplicate ( ) ; </a> 0
<a> } </a> 0
<a> tmpBuf . clear ( ) . position ( index ) . limit ( index + src . remaining ( ) ) ; </a> 0
<a> tmpBuf . put ( src ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void getBytes ( int index , OutputStream out , int length ) throws IOException { </a> 0
<a> if ( length == 0 ) { </a> 1
<a> return ; </a> 0
<a> } </a> 1
<a> if ( buffer . hasArray ( ) ) { </a> 1
<a> out . write ( buffer . array ( ) , index + buffer . arrayOffset ( ) , length ) ; </a> 1
<a> } else { </a> 0
<a> byte [ ] tmp = new byte [ length ] ; </a> 0
<a> tmpBuf . clear ( ) . position ( index ) ; </a> 0
<a> tmpBuf . get ( tmp ) ; </a> 0
<a> out . write ( tmp ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getBytes ( int index , GatheringByteChannel out , int length ) throws IOException { </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> tmpBuf . clear ( ) . position ( index ) . limit ( index + length ) ; </a> 0
<a> return out . write ( tmpBuf ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , InputStream in , int length ) throws IOException { </a> 1
<a> if ( buffer . hasArray ( ) ) { </a> 0
<a> return in . read ( buffer . array ( ) , buffer . arrayOffset ( ) + index , length ) ; </a> 0
<a> } else { </a> 0
<a> byte [ ] tmp = new byte [ length ] ; </a> 0
<a> int readBytes = in . read ( tmp ) ; </a> 0
<a> tmpBuf . clear ( ) . position ( index ) ; </a> 0
<a> tmpBuf . put ( tmp ) ; </a> 0
<a> return readBytes ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , ScatteringByteChannel in , int length ) throws IOException { </a> 1
<a> tmpBuf . clear ( ) . position ( index ) . limit ( index + length ) ; </a> 0
<a> try { </a> 0
<a> return in . read ( tmpBuf ) ; </a> 0
<a> } catch ( ClosedChannelException e ) { </a> 1
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean hasNioBuffer ( ) { </a> 1
<a> return true ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuffer nioBuffer ( int index , int length ) { </a> 0
<a> if ( index == 0 && length == capacity ( ) ) { </a> 1
<a> return buffer . duplicate ( ) ; </a> 1
<a> } else { </a> 1
<a> return ( ( ByteBuffer ) tmpBuf . clear ( ) . position ( index ) . limit ( index + length ) ) . slice ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean hasNioBuffers ( ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( int offset , int length ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf copy ( int index , int length ) { </a> 1
<a> ByteBuffer src ; </a> 1
<a> try { </a> 1
<a> src = ( ByteBuffer ) tmpBuf . clear ( ) . position ( index ) . limit ( index + length ) ; </a> 1
<a> } catch ( IllegalArgumentException e ) { </a> 1
<a> throw new IndexOutOfBoundsException ( "Too many bytes to read - Need " + ( index + length ) ) ; </a> 1
<a> } </a> 1
<a> ByteBuffer dst = </a> 1
<a> src . isDirect ( ) ? ByteBuffer . allocateDirect ( length ) : ByteBuffer . allocate ( length ) ; </a> 1
<a> dst . put ( src ) ; </a> 1
<a> dst . order ( order ( ) ) ; </a> 1
<a> dst . clear ( ) ; </a> 1
<a> return new DirectByteBuf ( dst , maxCapacity ( ) ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public Unsafe unsafe ( ) { </a> 1
<a> return unsafe ; </a> 1
<a> } </a> 1
<a> private class DirectUnsafe implements Unsafe { </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer nioBuffer ( ) { </a> 1
<a> return tmpBuf ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf newBuffer ( int initialCapacity ) { </a> 1
<a> return new DirectByteBuf ( initialCapacity , Math . max ( initialCapacity , maxCapacity ( ) ) ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void discardSomeReadBytes ( ) { </a> 1
<a> final int readerIndex = readerIndex ( ) ; </a> 1
<a> if ( readerIndex == writerIndex ( ) ) { </a> 1
<a> discardReadBytes ( ) ; </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> if ( readerIndex > 0 && readerIndex >= capacity > > > 1 ) { </a> 1
<a> discardReadBytes ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void acquire ( ) { </a> 1
<a> if ( refCnt <= 0 ) { </a> 1
<a> throw new IllegalStateException ( ) ; </a> 1
<a> } </a> 1
<a> refCnt ++ ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void release ( ) { </a> 1
<a> if ( refCnt <= 0 ) { </a> 1
<a> throw new IllegalStateException ( ) ; </a> 1
<a> } </a> 1
<a> refCnt -- ; </a> 1
<a> if ( refCnt == 0 ) { </a> 1
<a> if ( doNotFree ) { </a> 1
<a> doNotFree = false ; </a> 1
<a> } else { </a> 1
<a> freeDirect ( buffer ) ; </a> 1
<a> } </a> 1
<a> buffer = null ; </a> 1
<a> tmpBuf = null ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . channels . GatheringByteChannel ; </a> 0
<a> import java . nio . channels . ScatteringByteChannel ; </a> 0
<a> public class DuplicatedByteBuf extends AbstractByteBuf implements WrappedByteBuf { </a> 0
<a> private final Unsafe unsafe = new DuplicatedUnsafe ( ) ; </a> 1
<a> final ByteBuf buffer ; </a> 1
<a> public DuplicatedByteBuf ( ByteBuf buffer ) { </a> 1
<a> super ( buffer . order ( ) , buffer . maxCapacity ( ) ) ; </a> 1
<a> if ( buffer instanceof DuplicatedByteBuf ) { </a> 0
<a> this . buffer = ( ( DuplicatedByteBuf ) buffer ) . buffer ; </a> 0
<a> } else { </a> 0
<a> this . buffer = buffer ; </a> 0
<a> } </a> 0
<a> setIndex ( buffer . readerIndex ( ) , buffer . writerIndex ( ) ) ; </a> 0
<a> buffer . unsafe ( ) . acquire ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf unwrap ( ) { </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDirect ( ) { </a> 0
<a> return buffer . isDirect ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int capacity ( ) { </a> 0
<a> return buffer . capacity ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void capacity ( int newCapacity ) { </a> 0
<a> buffer . capacity ( newCapacity ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasArray ( ) { </a> 0
<a> return buffer . hasArray ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte [ ] array ( ) { </a> 0
<a> return buffer . array ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int arrayOffset ( ) { </a> 0
<a> return buffer . arrayOffset ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte getByte ( int index ) { </a> 0
<a> return buffer . getByte ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short getShort ( int index ) { </a> 0
<a> return buffer . getShort ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getUnsignedMedium ( int index ) { </a> 0
<a> return buffer . getUnsignedMedium ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getInt ( int index ) { </a> 0
<a> return buffer . getInt ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getLong ( int index ) { </a> 0
<a> return buffer . getLong ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf duplicate ( ) { </a> 0
<a> return new DuplicatedByteBuf ( this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf copy ( int index , int length ) { </a> 0
<a> return buffer . copy ( index , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf slice ( int index , int length ) { </a> 0
<a> return buffer . slice ( index , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuf dst , int dstIndex , int length ) { </a> 0
<a> buffer . getBytes ( index , dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , byte [ ] dst , int dstIndex , int length ) { </a> 0
<a> buffer . getBytes ( index , dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuffer dst ) { </a> 0
<a> buffer . getBytes ( index , dst ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setByte ( int index , int value ) { </a> 0
<a> buffer . setByte ( index , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setShort ( int index , int value ) { </a> 0
<a> buffer . setShort ( index , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setMedium ( int index , int value ) { </a> 0
<a> buffer . setMedium ( index , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setInt ( int index , int value ) { </a> 0
<a> buffer . setInt ( index , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setLong ( int index , long value ) { </a> 0
<a> buffer . setLong ( index , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , byte [ ] src , int srcIndex , int length ) { </a> 0
<a> buffer . setBytes ( index , src , srcIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuf src , int srcIndex , int length ) { </a> 0
<a> buffer . setBytes ( index , src , srcIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuffer src ) { </a> 0
<a> buffer . setBytes ( index , src ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , OutputStream out , int length ) </a> 0
<a> throws IOException { </a> 0
<a> buffer . getBytes ( index , out , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getBytes ( int index , GatheringByteChannel out , int length ) </a> 0
<a> throws IOException { </a> 0
<a> return buffer . getBytes ( index , out , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , InputStream in , int length ) </a> 0
<a> throws IOException { </a> 0
<a> return buffer . setBytes ( index , in , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , ScatteringByteChannel in , int length ) </a> 0
<a> throws IOException { </a> 0
<a> return buffer . setBytes ( index , in , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNioBuffer ( ) { </a> 1
<a> return buffer . hasNioBuffer ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuffer nioBuffer ( int index , int length ) { </a> 0
<a> return buffer . nioBuffer ( index , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNioBuffers ( ) { </a> 1
<a> return buffer . hasNioBuffers ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( int offset , int length ) { </a> 1
<a> return buffer . nioBuffers ( offset , length ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Unsafe unsafe ( ) { </a> 1
<a> return unsafe ; </a> 1
<a> } </a> 0
<a> private final class DuplicatedUnsafe implements Unsafe { </a> 1
<a> @ Override </a> 0
<a> public ByteBuffer nioBuffer ( ) { </a> 1
<a> return buffer . unsafe ( ) . nioBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( ) { </a> 1
<a> return buffer . unsafe ( ) . nioBuffers ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf newBuffer ( int initialCapacity ) { </a> 1
<a> return buffer . unsafe ( ) . newBuffer ( initialCapacity ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void discardSomeReadBytes ( ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void acquire ( ) { </a> 1
<a> buffer . unsafe ( ) . acquire ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void release ( ) { </a> 1
<a> buffer . unsafe ( ) . release ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . util . Collection ; </a> 1
<a> import java . util . Queue ; </a> 1
<a> public interface MessageBuf < T > extends ChannelBuf , Queue < T > { </a> 1
<a> int drainTo ( Collection < ? super T > c ) ; </a> 1
<a> int drainTo ( Collection < ? super T > c , int maxElements ) ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . util . Collection ; </a> 1
<a> import java . util . Iterator ; </a> 0
<a> import java . util . Queue ; </a> 0
<a> public class QueueBackedMessageBuf < T > implements MessageBuf < T > { </a> 0
<a> private final Queue < T > queue ; </a> 0
<a> public QueueBackedMessageBuf ( Queue < T > queue ) { </a> 0
<a> if ( queue == null ) { </a> 1
<a> throw new NullPointerException ( "queue" ) ; </a> 1
<a> } </a> 1
<a> this . queue = queue ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isPooled ( ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelBufType type ( ) { </a> 1
<a> return ChannelBufType . MESSAGE ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean add ( T e ) { </a> 0
<a> return queue . add ( e ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean offer ( T e ) { </a> 1
<a> return queue . offer ( e ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public T remove ( ) { </a> 0
<a> return queue . remove ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public T poll ( ) { </a> 1
<a> return queue . poll ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public T element ( ) { </a> 0
<a> return queue . element ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public T peek ( ) { </a> 1
<a> return queue . peek ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int size ( ) { </a> 1
<a> return queue . size ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isEmpty ( ) { </a> 1
<a> return queue . isEmpty ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean contains ( Object o ) { </a> 1
<a> return queue . contains ( o ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public Iterator < T > iterator ( ) { </a> 1
<a> return queue . iterator ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public Object [ ] toArray ( ) { </a> 1
<a> return queue . toArray ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public < E > E [ ] toArray ( E [ ] a ) { </a> 1
<a> return queue . toArray ( a ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean remove ( Object o ) { </a> 1
<a> return queue . remove ( o ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean containsAll ( Collection < ? > c ) { </a> 1
<a> return queue . containsAll ( c ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean addAll ( Collection < ? extends T > c ) { </a> 1
<a> return queue . addAll ( c ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean removeAll ( Collection < ? > c ) { </a> 1
<a> return queue . removeAll ( c ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean retainAll ( Collection < ? > c ) { </a> 1
<a> return queue . retainAll ( c ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void clear ( ) { </a> 1
<a> queue . clear ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int drainTo ( Collection < ? super T > c ) { </a> 0
<a> int cnt = 0 ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> T o = poll ( ) ; </a> 1
<a> if ( o == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> c . add ( o ) ; </a> 1
<a> cnt ++ ; </a> 1
<a> } </a> 1
<a> return cnt ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int drainTo ( Collection < ? super T > c , int maxElements ) { </a> 1
<a> int cnt = 0 ; </a> 1
<a> while ( cnt < maxElements ) { </a> 1
<a> T o = poll ( ) ; </a> 1
<a> if ( o == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> c . add ( o ) ; </a> 1
<a> cnt ++ ; </a> 1
<a> } </a> 1
<a> return cnt ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String toString ( ) { </a> 0
<a> return queue . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . channels . GatheringByteChannel ; </a> 0
<a> import java . nio . channels . ScatteringByteChannel ; </a> 0
<a> public class SlicedByteBuf extends AbstractByteBuf implements WrappedByteBuf { </a> 0
<a> private final Unsafe unsafe = new SlicedUnsafe ( ) ; </a> 1
<a> private final ByteBuf buffer ; </a> 1
<a> private final int adjustment ; </a> 0
<a> private final int length ; </a> 0
<a> public SlicedByteBuf ( ByteBuf buffer , int index , int length ) { </a> 1
<a> super ( buffer . order ( ) , length ) ; </a> 1
<a> if ( index < 0 || index > buffer . capacity ( ) ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Invalid index of " + index </a> 0
<a> + ", maximum is " + buffer . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( index + length > buffer . capacity ( ) ) { </a> 0
<a> throw new IndexOutOfBoundsException ( "Invalid combined index of " </a> 0
<a> + ( index + length ) + ", maximum is " + buffer . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( buffer instanceof SlicedByteBuf ) { </a> 0
<a> this . buffer = ( ( SlicedByteBuf ) buffer ) . buffer ; </a> 0
<a> adjustment = ( ( SlicedByteBuf ) buffer ) . adjustment + index ; </a> 0
<a> } else if ( buffer instanceof DuplicatedByteBuf ) { </a> 0
<a> this . buffer = ( ( DuplicatedByteBuf ) buffer ) . buffer ; </a> 1
<a> adjustment = index ; </a> 0
<a> } else { </a> 0
<a> this . buffer = buffer ; </a> 0
<a> adjustment = index ; </a> 0
<a> } </a> 0
<a> this . length = length ; </a> 0
<a> writerIndex ( length ) ; </a> 0
<a> buffer . unsafe ( ) . acquire ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf unwrap ( ) { </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDirect ( ) { </a> 0
<a> return buffer . isDirect ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int capacity ( ) { </a> 0
<a> return length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void capacity ( int newCapacity ) { </a> 0
<a> throw new UnsupportedOperationException ( "sliced buffer" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasArray ( ) { </a> 0
<a> return buffer . hasArray ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte [ ] array ( ) { </a> 0
<a> return buffer . array ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int arrayOffset ( ) { </a> 0
<a> return buffer . arrayOffset ( ) + adjustment ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte getByte ( int index ) { </a> 0
<a> checkIndex ( index ) ; </a> 0
<a> return buffer . getByte ( index + adjustment ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short getShort ( int index ) { </a> 0
<a> checkIndex ( index , 2 ) ; </a> 0
<a> return buffer . getShort ( index + adjustment ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getUnsignedMedium ( int index ) { </a> 0
<a> checkIndex ( index , 3 ) ; </a> 0
<a> return buffer . getUnsignedMedium ( index + adjustment ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getInt ( int index ) { </a> 0
<a> checkIndex ( index , 4 ) ; </a> 0
<a> return buffer . getInt ( index + adjustment ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getLong ( int index ) { </a> 0
<a> checkIndex ( index , 8 ) ; </a> 0
<a> return buffer . getLong ( index + adjustment ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf duplicate ( ) { </a> 0
<a> ByteBuf duplicate = new SlicedByteBuf ( buffer , adjustment , length ) ; </a> 1
<a> duplicate . setIndex ( readerIndex ( ) , writerIndex ( ) ) ; </a> 0
<a> return duplicate ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf copy ( int index , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> return buffer . copy ( index + adjustment , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf slice ( int index , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return Unpooled . EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> return new SlicedByteBuf ( buffer , index + adjustment , length ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuf dst , int dstIndex , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> buffer . getBytes ( index + adjustment , dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , byte [ ] dst , int dstIndex , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> buffer . getBytes ( index + adjustment , dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuffer dst ) { </a> 0
<a> checkIndex ( index , dst . remaining ( ) ) ; </a> 0
<a> buffer . getBytes ( index + adjustment , dst ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setByte ( int index , int value ) { </a> 0
<a> checkIndex ( index ) ; </a> 0
<a> buffer . setByte ( index + adjustment , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setShort ( int index , int value ) { </a> 0
<a> checkIndex ( index , 2 ) ; </a> 0
<a> buffer . setShort ( index + adjustment , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setMedium ( int index , int value ) { </a> 0
<a> checkIndex ( index , 3 ) ; </a> 0
<a> buffer . setMedium ( index + adjustment , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setInt ( int index , int value ) { </a> 0
<a> checkIndex ( index , 4 ) ; </a> 0
<a> buffer . setInt ( index + adjustment , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setLong ( int index , long value ) { </a> 0
<a> checkIndex ( index , 8 ) ; </a> 0
<a> buffer . setLong ( index + adjustment , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , byte [ ] src , int srcIndex , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> buffer . setBytes ( index + adjustment , src , srcIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuf src , int srcIndex , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> buffer . setBytes ( index + adjustment , src , srcIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuffer src ) { </a> 0
<a> checkIndex ( index , src . remaining ( ) ) ; </a> 0
<a> buffer . setBytes ( index + adjustment , src ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , OutputStream out , int length ) </a> 0
<a> throws IOException { </a> 1
<a> checkIndex ( index , length ) ; </a> 0
<a> buffer . getBytes ( index + adjustment , out , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getBytes ( int index , GatheringByteChannel out , int length ) </a> 1
<a> throws IOException { </a> 1
<a> checkIndex ( index , length ) ; </a> 0
<a> return buffer . getBytes ( index + adjustment , out , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , InputStream in , int length ) </a> 1
<a> throws IOException { </a> 1
<a> checkIndex ( index , length ) ; </a> 0
<a> return buffer . setBytes ( index + adjustment , in , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , ScatteringByteChannel in , int length ) </a> 1
<a> throws IOException { </a> 1
<a> checkIndex ( index , length ) ; </a> 0
<a> return buffer . setBytes ( index + adjustment , in , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNioBuffer ( ) { </a> 1
<a> return buffer . hasNioBuffer ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuffer nioBuffer ( int index , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> return buffer . nioBuffer ( index + adjustment , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNioBuffers ( ) { </a> 1
<a> return buffer . hasNioBuffers ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( int index , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> return buffer . nioBuffers ( index , length ) ; </a> 0
<a> } </a> 0
<a> private void checkIndex ( int index ) { </a> 1
<a> if ( index < 0 || index >= capacity ( ) ) { </a> 1
<a> throw new IndexOutOfBoundsException ( "Invalid index: " + index </a> 1
<a> + ", maximum is " + capacity ( ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private void checkIndex ( int startIndex , int length ) { </a> 1
<a> if ( length < 0 ) { </a> 1
<a> throw new IllegalArgumentException ( </a> 1
<a> "length is negative: " + length ) ; </a> 1
<a> } </a> 1
<a> if ( startIndex < 0 ) { </a> 1
<a> throw new IndexOutOfBoundsException ( "startIndex cannot be negative" ) ; </a> 1
<a> } </a> 1
<a> if ( startIndex + length > capacity ( ) ) { </a> 1
<a> throw new IndexOutOfBoundsException ( "Index too big - Bytes needed: " </a> 1
<a> + ( startIndex + length ) + ", maximum is " + capacity ( ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public Unsafe unsafe ( ) { </a> 1
<a> return unsafe ; </a> 1
<a> } </a> 1
<a> private final class SlicedUnsafe implements Unsafe { </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer nioBuffer ( ) { </a> 1
<a> return buffer . nioBuffer ( adjustment , length ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuffer [ ] nioBuffers ( ) { </a> 1
<a> return buffer . nioBuffers ( adjustment , length ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf newBuffer ( int initialCapacity ) { </a> 1
<a> return buffer . unsafe ( ) . newBuffer ( initialCapacity ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void discardSomeReadBytes ( ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void acquire ( ) { </a> 1
<a> buffer . unsafe ( ) . acquire ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void release ( ) { </a> 1
<a> buffer . unsafe ( ) . release ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . ByteOrder ; </a> 0
<a> import java . nio . channels . GatheringByteChannel ; </a> 0
<a> import java . nio . channels . ScatteringByteChannel ; </a> 0
<a> import java . nio . charset . Charset ; </a> 0
<a> public class SwappedByteBuf implements WrappedByteBuf { </a> 1
<a> private final ByteBuf buf ; </a> 1
<a> private final ByteOrder order ; </a> 0
<a> public SwappedByteBuf ( ByteBuf buf ) { </a> 1
<a> if ( buf == null ) { </a> 0
<a> throw new NullPointerException ( "buf" ) ; </a> 0
<a> } </a> 0
<a> this . buf = buf ; </a> 0
<a> if ( buf . order ( ) == ByteOrder . BIG_ENDIAN ) { </a> 0
<a> order = ByteOrder . LITTLE_ENDIAN ; </a> 0
<a> } else { </a> 0
<a> order = ByteOrder . BIG_ENDIAN ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteOrder order ( ) { </a> 0
<a> return order ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf order ( ByteOrder endianness ) { </a> 0
<a> if ( endianness == null ) { </a> 0
<a> throw new NullPointerException ( "endianness" ) ; </a> 0
<a> } </a> 0
<a> if ( endianness == order ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> return buf ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf unwrap ( ) { </a> 0
<a> return buf ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isPooled ( ) { </a> 1
<a> return buf . isPooled ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelBufType type ( ) { </a> 1
<a> return ChannelBufType . MESSAGE ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int capacity ( ) { </a> 0
<a> return buf . capacity ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void capacity ( int newCapacity ) { </a> 0
<a> buf . capacity ( newCapacity ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int maxCapacity ( ) { </a> 0
<a> return buf . maxCapacity ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDirect ( ) { </a> 0
<a> return buf . isDirect ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readerIndex ( ) { </a> 0
<a> return buf . readerIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readerIndex ( int readerIndex ) { </a> 0
<a> buf . readerIndex ( readerIndex ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int writerIndex ( ) { </a> 0
<a> return buf . writerIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writerIndex ( int writerIndex ) { </a> 0
<a> buf . writerIndex ( writerIndex ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setIndex ( int readerIndex , int writerIndex ) { </a> 0
<a> buf . setIndex ( readerIndex , writerIndex ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readableBytes ( ) { </a> 0
<a> return buf . readableBytes ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int writableBytes ( ) { </a> 0
<a> return buf . writableBytes ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readable ( ) { </a> 0
<a> return buf . readable ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean writable ( ) { </a> 0
<a> return buf . writable ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clear ( ) { </a> 0
<a> buf . clear ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void markReaderIndex ( ) { </a> 0
<a> buf . markReaderIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void resetReaderIndex ( ) { </a> 0
<a> buf . resetReaderIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void markWriterIndex ( ) { </a> 0
<a> buf . markWriterIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void resetWriterIndex ( ) { </a> 0
<a> buf . resetWriterIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void discardReadBytes ( ) { </a> 0
<a> buf . discardReadBytes ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void ensureWritableBytes ( int writableBytes ) { </a> 0
<a> buf . ensureWritableBytes ( writableBytes ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int ensureWritableBytes ( int minWritableBytes , boolean force ) { </a> 0
<a> return buf . ensureWritableBytes ( minWritableBytes , force ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean getBoolean ( int index ) { </a> 0
<a> return buf . getBoolean ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte getByte ( int index ) { </a> 0
<a> return buf . getByte ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short getUnsignedByte ( int index ) { </a> 0
<a> return buf . getUnsignedByte ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short getShort ( int index ) { </a> 0
<a> return ByteBufUtil . swapShort ( buf . getShort ( index ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getUnsignedShort ( int index ) { </a> 0
<a> return getShort ( index ) & 0xFFFF ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getMedium ( int index ) { </a> 0
<a> return ByteBufUtil . swapMedium ( buf . getMedium ( index ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getUnsignedMedium ( int index ) { </a> 0
<a> return getMedium ( index ) & 0xFFFFFF ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getInt ( int index ) { </a> 0
<a> return ByteBufUtil . swapInt ( buf . getInt ( index ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getUnsignedInt ( int index ) { </a> 0
<a> return getInt ( index ) & 0xFFFFFFFFL ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getLong ( int index ) { </a> 0
<a> return ByteBufUtil . swapLong ( buf . getLong ( index ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public char getChar ( int index ) { </a> 0
<a> return ( char ) getShort ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public float getFloat ( int index ) { </a> 0
<a> return Float . intBitsToFloat ( getInt ( index ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public double getDouble ( int index ) { </a> 0
<a> return Double . longBitsToDouble ( getLong ( index ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuf dst ) { </a> 0
<a> buf . getBytes ( index , dst ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuf dst , int length ) { </a> 0
<a> buf . getBytes ( index , dst , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuf dst , int dstIndex , int length ) { </a> 0
<a> buf . getBytes ( index , dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , byte [ ] dst ) { </a> 0
<a> buf . getBytes ( index , dst ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , byte [ ] dst , int dstIndex , int length ) { </a> 0
<a> buf . getBytes ( index , dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuffer dst ) { </a> 0
<a> buf . getBytes ( index , dst ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , OutputStream out , int length ) throws IOException { </a> 0
<a> buf . getBytes ( index , out , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getBytes ( int index , GatheringByteChannel out , int length ) throws IOException { </a> 0
<a> return buf . getBytes ( index , out , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBoolean ( int index , boolean value ) { </a> 0
<a> buf . setBoolean ( index , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setByte ( int index , int value ) { </a> 0
<a> buf . setByte ( index , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setShort ( int index , int value ) { </a> 0
<a> buf . setShort ( index , ByteBufUtil . swapShort ( ( short ) value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setMedium ( int index , int value ) { </a> 0
<a> buf . setMedium ( index , ByteBufUtil . swapMedium ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setInt ( int index , int value ) { </a> 0
<a> buf . setInt ( index , ByteBufUtil . swapInt ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setLong ( int index , long value ) { </a> 0
<a> buf . setLong ( index , ByteBufUtil . swapLong ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setChar ( int index , int value ) { </a> 0
<a> setShort ( index , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setFloat ( int index , float value ) { </a> 0
<a> setInt ( index , Float . floatToRawIntBits ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setDouble ( int index , double value ) { </a> 0
<a> setLong ( index , Double . doubleToRawLongBits ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuf src ) { </a> 0
<a> buf . setBytes ( index , src ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuf src , int length ) { </a> 0
<a> buf . setBytes ( index , src , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuf src , int srcIndex , int length ) { </a> 0
<a> buf . setBytes ( index , src , srcIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , byte [ ] src ) { </a> 0
<a> buf . setBytes ( index , src ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , byte [ ] src , int srcIndex , int length ) { </a> 0
<a> buf . setBytes ( index , src , srcIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuffer src ) { </a> 0
<a> buf . setBytes ( index , src ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , InputStream in , int length ) throws IOException { </a> 0
<a> return buf . setBytes ( index , in , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , ScatteringByteChannel in , int length ) throws IOException { </a> 0
<a> return buf . setBytes ( index , in , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setZero ( int index , int length ) { </a> 0
<a> buf . setZero ( index , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readBoolean ( ) { </a> 0
<a> return buf . readBoolean ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte readByte ( ) { </a> 0
<a> return buf . readByte ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short readUnsignedByte ( ) { </a> 0
<a> return buf . readUnsignedByte ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short readShort ( ) { </a> 0
<a> return ByteBufUtil . swapShort ( buf . readShort ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readUnsignedShort ( ) { </a> 0
<a> return readShort ( ) & 0xFFFF ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readMedium ( ) { </a> 0
<a> return ByteBufUtil . swapMedium ( buf . readMedium ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readUnsignedMedium ( ) { </a> 0
<a> return readMedium ( ) & 0xFFFFFF ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readInt ( ) { </a> 0
<a> return ByteBufUtil . swapInt ( buf . readInt ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long readUnsignedInt ( ) { </a> 0
<a> return readInt ( ) & 0xFFFFFFFFL ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long readLong ( ) { </a> 0
<a> return ByteBufUtil . swapLong ( buf . readLong ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public char readChar ( ) { </a> 0
<a> return ( char ) readShort ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public float readFloat ( ) { </a> 0
<a> return Float . intBitsToFloat ( readInt ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public double readDouble ( ) { </a> 0
<a> return Double . longBitsToDouble ( readLong ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf readBytes ( int length ) { </a> 0
<a> return buf . readBytes ( length ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf readSlice ( int length ) { </a> 0
<a> return buf . readSlice ( length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( ByteBuf dst ) { </a> 0
<a> buf . readBytes ( dst ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( ByteBuf dst , int length ) { </a> 0
<a> buf . readBytes ( dst , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( ByteBuf dst , int dstIndex , int length ) { </a> 0
<a> buf . readBytes ( dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( byte [ ] dst ) { </a> 0
<a> buf . readBytes ( dst ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( byte [ ] dst , int dstIndex , int length ) { </a> 0
<a> buf . readBytes ( dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( ByteBuffer dst ) { </a> 0
<a> buf . readBytes ( dst ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( OutputStream out , int length ) throws IOException { </a> 0
<a> buf . readBytes ( out , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readBytes ( GatheringByteChannel out , int length ) throws IOException { </a> 0
<a> return buf . readBytes ( out , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void skipBytes ( int length ) { </a> 0
<a> buf . skipBytes ( length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBoolean ( boolean value ) { </a> 0
<a> buf . writeBoolean ( value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeByte ( int value ) { </a> 0
<a> buf . writeByte ( value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeShort ( int value ) { </a> 0
<a> buf . writeShort ( ByteBufUtil . swapShort ( ( short ) value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeMedium ( int value ) { </a> 0
<a> buf . writeMedium ( ByteBufUtil . swapMedium ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeInt ( int value ) { </a> 0
<a> buf . writeInt ( ByteBufUtil . swapInt ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeLong ( long value ) { </a> 0
<a> buf . writeLong ( ByteBufUtil . swapLong ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeChar ( int value ) { </a> 0
<a> writeShort ( value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeFloat ( float value ) { </a> 0
<a> writeInt ( Float . floatToRawIntBits ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeDouble ( double value ) { </a> 0
<a> writeLong ( Double . doubleToRawLongBits ( value ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( ByteBuf src ) { </a> 0
<a> buf . writeBytes ( src ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( ByteBuf src , int length ) { </a> 0
<a> buf . writeBytes ( src , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( ByteBuf src , int srcIndex , int length ) { </a> 0
<a> buf . writeBytes ( src , srcIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( byte [ ] src ) { </a> 0
<a> buf . writeBytes ( src ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( byte [ ] src , int srcIndex , int length ) { </a> 0
<a> buf . writeBytes ( src , srcIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( ByteBuffer src ) { </a> 0
<a> buf . writeBytes ( src ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int writeBytes ( InputStream in , int length ) throws IOException { </a> 0
<a> return buf . writeBytes ( in , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int writeBytes ( ScatteringByteChannel in , int length ) throws IOException { </a> 0
<a> return buf . writeBytes ( in , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeZero ( int length ) { </a> 0
<a> buf . writeZero ( length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int indexOf ( int fromIndex , int toIndex , byte value ) { </a> 0
<a> return buf . indexOf ( fromIndex , toIndex , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int indexOf ( int fromIndex , int toIndex , ByteBufIndexFinder indexFinder ) { </a> 0
<a> return buf . indexOf ( fromIndex , toIndex , indexFinder ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( byte value ) { </a> 0
<a> return buf . bytesBefore ( value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( ByteBufIndexFinder indexFinder ) { </a> 0
<a> return buf . bytesBefore ( indexFinder ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( int length , byte value ) { </a> 0
<a> return buf . bytesBefore ( length , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( int length , ByteBufIndexFinder indexFinder ) { </a> 0
<a> return buf . bytesBefore ( length , indexFinder ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( int index , int length , byte value ) { </a> 0
<a> return buf . bytesBefore ( index , length , value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( int index , int length , ByteBufIndexFinder indexFinder ) { </a> 0
<a> return buf . bytesBefore ( index , length , indexFinder ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf copy ( ) { </a> 0
<a> return buf . copy ( ) . order ( order ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf copy ( int index , int length ) { </a> 0
<a> return buf . copy ( index , length ) . order ( order ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf slice ( ) { </a> 0
<a> return buf . slice ( ) . order ( order ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf slice ( int index , int length ) { </a> 0
<a> return buf . slice ( index , length ) . order ( order ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf duplicate ( ) { </a> 0
<a> return buf . duplicate ( ) . order ( order ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNioBuffer ( ) { </a> 1
<a> return buf . hasNioBuffer ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuffer nioBuffer ( ) { </a> 0
<a> return buf . nioBuffer ( ) . order ( order ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuffer nioBuffer ( int index , int length ) { </a> 0
<a> return buf . nioBuffer ( index , length ) . order ( order ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNioBuffers ( ) { </a> 1
<a> return buf . hasNioBuffers ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( ) { </a> 0
<a> ByteBuffer [ ] nioBuffers = buf . nioBuffers ( ) ; </a> 0
<a> for ( int i = 0 ; i < nioBuffers . length ; i ++ ) { </a> 0
<a> nioBuffers [ i ] = nioBuffers [ i ] . order ( order ) ; </a> 0
<a> } </a> 0
<a> return nioBuffers ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuffer [ ] nioBuffers ( int offset , int length ) { </a> 1
<a> ByteBuffer [ ] nioBuffers = buf . nioBuffers ( offset , length ) ; </a> 1
<a> for ( int i = 0 ; i < nioBuffers . length ; i ++ ) { </a> 0
<a> nioBuffers [ i ] = nioBuffers [ i ] . order ( order ) ; </a> 0
<a> } </a> 0
<a> return nioBuffers ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasArray ( ) { </a> 0
<a> return buf . hasArray ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte [ ] array ( ) { </a> 0
<a> return buf . array ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int arrayOffset ( ) { </a> 0
<a> return buf . arrayOffset ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( Charset charset ) { </a> 0
<a> return buf . toString ( charset ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( int index , int length , Charset charset ) { </a> 0
<a> return buf . toString ( index , length , charset ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Unsafe unsafe ( ) { </a> 1
<a> return buf . unsafe ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int hashCode ( ) { </a> 0
<a> return buf . hashCode ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object obj ) { </a> 0
<a> if ( this == obj ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( obj instanceof ByteBuf ) { </a> 0
<a> return ByteBufUtil . equals ( this , ( ByteBuf ) obj ) ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( ByteBuf buffer ) { </a> 0
<a> return ByteBufUtil . compare ( this , buffer ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return "Swapped(" + buf . toString ( ) + ')' ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 1
<a> import java . nio . ByteOrder ; </a> 1
<a> import java . nio . CharBuffer ; </a> 1
<a> import java . nio . charset . Charset ; </a> 1
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 1
<a> import java . util . Queue ; </a> 1
<a> public final class Unpooled { </a> 0
<a> public static final ByteOrder BIG_ENDIAN = ByteOrder . BIG_ENDIAN ; </a> 0
<a> public static final ByteOrder LITTLE_ENDIAN = ByteOrder . LITTLE_ENDIAN ; </a> 0
<a> public static final ByteBuf EMPTY_BUFFER = new HeapByteBuf ( 0 , 0 ) { </a> 1
<a> @ Override </a> 1
<a> public ByteBuf order ( ByteOrder endianness ) { </a> 1
<a> if ( endianness == null ) { </a> 0
<a> throw new NullPointerException ( "endianness" ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> public static < T > MessageBuf < T > messageBuffer ( ) { </a> 1
<a> return new DefaultMessageBuf < T > ( ) ; </a> 1
<a> } </a> 1
<a> public static < T > MessageBuf < T > messageBuffer ( int initialCapacity ) { </a> 1
<a> return new DefaultMessageBuf < T > ( initialCapacity ) ; </a> 0
<a> } </a> 0
<a> public static < T > MessageBuf < T > wrappedBuffer ( Queue < T > queue ) { </a> 1
<a> if ( queue instanceof MessageBuf ) { </a> 1
<a> return ( MessageBuf < T > ) queue ; </a> 1
<a> } </a> 1
<a> return new QueueBackedMessageBuf < T > ( queue ) ; </a> 1
<a> } </a> 1
<a> public static ByteBuf buffer ( ) { </a> 0
<a> return buffer ( 256 , Integer . MAX_VALUE ) ; </a> 1
<a> } </a> 0
<a> public static ByteBuf directBuffer ( ) { </a> 0
<a> return directBuffer ( 256 , Integer . MAX_VALUE ) ; </a> 1
<a> } </a> 0
<a> public static ByteBuf buffer ( int initialCapacity ) { </a> 0
<a> return buffer ( initialCapacity , Integer . MAX_VALUE ) ; </a> 1
<a> } </a> 0
<a> public static ByteBuf directBuffer ( int initialCapacity ) { </a> 0
<a> return directBuffer ( initialCapacity , Integer . MAX_VALUE ) ; </a> 1
<a> } </a> 0
<a> public static ByteBuf buffer ( int initialCapacity , int maxCapacity ) { </a> 0
<a> if ( initialCapacity == 0 && maxCapacity == 0 ) { </a> 1
<a> return EMPTY_BUFFER ; </a> 1
<a> } </a> 1
<a> return new HeapByteBuf ( initialCapacity , maxCapacity ) ; </a> 1
<a> } </a> 0
<a> public static ByteBuf directBuffer ( int initialCapacity , int maxCapacity ) { </a> 0
<a> if ( initialCapacity == 0 && maxCapacity == 0 ) { </a> 1
<a> return EMPTY_BUFFER ; </a> 1
<a> } </a> 1
<a> return new DirectByteBuf ( initialCapacity , maxCapacity ) ; </a> 1
<a> } </a> 1
<a> public static ByteBuf wrappedBuffer ( byte [ ] array ) { </a> 0
<a> if ( array . length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> return new HeapByteBuf ( array , array . length ) ; </a> 1
<a> } </a> 0
<a> public static ByteBuf wrappedBuffer ( byte [ ] array , int offset , int length ) { </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> if ( offset == 0 && length == array . length ) { </a> 0
<a> return wrappedBuffer ( array ) ; </a> 0
<a> } </a> 0
<a> return new SlicedByteBuf ( wrappedBuffer ( array ) , offset , length ) ; </a> 1
<a> } </a> 0
<a> public static ByteBuf wrappedBuffer ( ByteBuffer buffer ) { </a> 0
<a> if ( ! buffer . hasRemaining ( ) ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> if ( buffer . hasArray ( ) ) { </a> 0
<a> return wrappedBuffer ( </a> 0
<a> buffer . array ( ) , </a> 0
<a> buffer . arrayOffset ( ) + buffer . position ( ) , </a> 0
<a> buffer . remaining ( ) ) . order ( buffer . order ( ) ) ; </a> 0
<a> } else { </a> 0
<a> return new DirectByteBuf ( buffer , buffer . remaining ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> public static ByteBuf wrappedBuffer ( ByteBuf buffer ) { </a> 0
<a> if ( buffer . readable ( ) ) { </a> 0
<a> return buffer . slice ( ) ; </a> 0
<a> } else { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static ByteBuf wrappedBuffer ( byte [ ] ... arrays ) { </a> 0
<a> return wrappedBuffer ( 16 , arrays ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf wrappedBuffer ( ByteBuf ... buffers ) { </a> 0
<a> return wrappedBuffer ( 16 , buffers ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf wrappedBuffer ( ByteBuffer ... buffers ) { </a> 0
<a> return wrappedBuffer ( 16 , buffers ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf wrappedBuffer ( int maxNumComponents , byte [ ] ... arrays ) { </a> 0
<a> switch ( arrays . length ) { </a> 0
<a> case 0 : </a> 0
<a> break ; </a> 0
<a> case 1 : </a> 0
<a> if ( arrays [ 0 ] . length != 0 ) { </a> 0
<a> return wrappedBuffer ( arrays [ 0 ] ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> final List < ByteBuf > components = new ArrayList < ByteBuf > ( arrays . length ) ; </a> 0
<a> for ( byte [ ] a : arrays ) { </a> 0
<a> if ( a == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( a . length > 0 ) { </a> 0
<a> components . add ( wrappedBuffer ( a ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! components . isEmpty ( ) ) { </a> 0
<a> return new DefaultCompositeByteBuf ( maxNumComponents , components ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> public static ByteBuf wrappedBuffer ( int maxNumComponents , ByteBuf ... buffers ) { </a> 0
<a> switch ( buffers . length ) { </a> 0
<a> case 0 : </a> 0
<a> break ; </a> 0
<a> case 1 : </a> 0
<a> if ( buffers [ 0 ] . readable ( ) ) { </a> 0
<a> return wrappedBuffer ( buffers [ 0 ] . order ( BIG_ENDIAN ) ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> for ( ByteBuf b : buffers ) { </a> 0
<a> if ( b . readable ( ) ) { </a> 0
<a> return new DefaultCompositeByteBuf ( maxNumComponents , buffers ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> public static ByteBuf wrappedBuffer ( int maxNumComponents , ByteBuffer ... buffers ) { </a> 0
<a> switch ( buffers . length ) { </a> 0
<a> case 0 : </a> 0
<a> break ; </a> 0
<a> case 1 : </a> 0
<a> if ( buffers [ 0 ] . hasRemaining ( ) ) { </a> 0
<a> return wrappedBuffer ( buffers [ 0 ] . order ( BIG_ENDIAN ) ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> final List < ByteBuf > components = new ArrayList < ByteBuf > ( buffers . length ) ; </a> 0
<a> for ( ByteBuffer b : buffers ) { </a> 0
<a> if ( b == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( b . remaining ( ) > 0 ) { </a> 0
<a> components . add ( wrappedBuffer ( b . order ( BIG_ENDIAN ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! components . isEmpty ( ) ) { </a> 0
<a> return new DefaultCompositeByteBuf ( maxNumComponents , components ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> public static CompositeByteBuf compositeBuffer ( ) { </a> 0
<a> return compositeBuffer ( 16 ) ; </a> 0
<a> } </a> 0
<a> public static CompositeByteBuf compositeBuffer ( int maxNumComponents ) { </a> 0
<a> return new DefaultCompositeByteBuf ( maxNumComponents ) ; </a> 1
<a> } </a> 0
<a> public static ByteBuf copiedBuffer ( byte [ ] array ) { </a> 0
<a> if ( array . length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> return wrappedBuffer ( array . clone ( ) ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copiedBuffer ( byte [ ] array , int offset , int length ) { </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> byte [ ] copy = new byte [ length ] ; </a> 0
<a> System . arraycopy ( array , offset , copy , 0 , length ) ; </a> 0
<a> return wrappedBuffer ( copy ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copiedBuffer ( ByteBuffer buffer ) { </a> 0
<a> int length = buffer . remaining ( ) ; </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> byte [ ] copy = new byte [ length ] ; </a> 0
<a> int position = buffer . position ( ) ; </a> 0
<a> try { </a> 0
<a> buffer . get ( copy ) ; </a> 0
<a> } finally { </a> 0
<a> buffer . position ( position ) ; </a> 0
<a> } </a> 0
<a> return wrappedBuffer ( copy ) . order ( buffer . order ( ) ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copiedBuffer ( ByteBuf buffer ) { </a> 0
<a> if ( buffer . readable ( ) ) { </a> 0
<a> return buffer . copy ( ) ; </a> 0
<a> } else { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static ByteBuf copiedBuffer ( byte [ ] ... arrays ) { </a> 0
<a> switch ( arrays . length ) { </a> 0
<a> case 0 : </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> case 1 : </a> 0
<a> if ( arrays [ 0 ] . length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } else { </a> 0
<a> return copiedBuffer ( arrays [ 0 ] ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int length = 0 ; </a> 0
<a> for ( byte [ ] a : arrays ) { </a> 0
<a> if ( Integer . MAX_VALUE - length < a . length ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "The total length of the specified arrays is too big." ) ; </a> 0
<a> } </a> 0
<a> length += a . length ; </a> 0
<a> } </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> byte [ ] mergedArray = new byte [ length ] ; </a> 0
<a> for ( int i = 0 , j = 0 ; i < arrays . length ; i ++ ) { </a> 0
<a> byte [ ] a = arrays [ i ] ; </a> 0
<a> System . arraycopy ( a , 0 , mergedArray , j , a . length ) ; </a> 0
<a> j += a . length ; </a> 0
<a> } </a> 0
<a> return wrappedBuffer ( mergedArray ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copiedBuffer ( ByteBuf ... buffers ) { </a> 0
<a> switch ( buffers . length ) { </a> 0
<a> case 0 : </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> case 1 : </a> 0
<a> return copiedBuffer ( buffers [ 0 ] ) ; </a> 0
<a> } </a> 0
<a> ByteOrder order = null ; </a> 0
<a> int length = 0 ; </a> 0
<a> for ( ByteBuf b : buffers ) { </a> 0
<a> int bLen = b . readableBytes ( ) ; </a> 0
<a> if ( bLen <= 0 ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> if ( Integer . MAX_VALUE - length < bLen ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "The total length of the specified buffers is too big." ) ; </a> 0
<a> } </a> 0
<a> length += bLen ; </a> 0
<a> if ( order != null ) { </a> 0
<a> if ( ! order . equals ( b . order ( ) ) ) { </a> 0
<a> throw new IllegalArgumentException ( "inconsistent byte order" ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> order = b . order ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> byte [ ] mergedArray = new byte [ length ] ; </a> 0
<a> for ( int i = 0 , j = 0 ; i < buffers . length ; i ++ ) { </a> 0
<a> ByteBuf b = buffers [ i ] ; </a> 0
<a> int bLen = b . readableBytes ( ) ; </a> 0
<a> b . getBytes ( b . readerIndex ( ) , mergedArray , j , bLen ) ; </a> 0
<a> j += bLen ; </a> 0
<a> } </a> 0
<a> return wrappedBuffer ( mergedArray ) . order ( order ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copiedBuffer ( ByteBuffer ... buffers ) { </a> 0
<a> switch ( buffers . length ) { </a> 0
<a> case 0 : </a> 0
<a> return EMPTY_BUFFER ; </a> 1
<a> case 1 : </a> 1
<a> return copiedBuffer ( buffers [ 0 ] ) ; </a> 1
<a> } </a> 0
<a> ByteOrder order = null ; </a> 0
<a> int length = 0 ; </a> 0
<a> for ( ByteBuffer b : buffers ) { </a> 0
<a> int bLen = b . remaining ( ) ; </a> 0
<a> if ( bLen <= 0 ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> if ( Integer . MAX_VALUE - length < bLen ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "The total length of the specified buffers is too big." ) ; </a> 0
<a> } </a> 0
<a> length += bLen ; </a> 0
<a> if ( order != null ) { </a> 0
<a> if ( ! order . equals ( b . order ( ) ) ) { </a> 0
<a> throw new IllegalArgumentException ( "inconsistent byte order" ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> order = b . order ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> byte [ ] mergedArray = new byte [ length ] ; </a> 0
<a> for ( int i = 0 , j = 0 ; i < buffers . length ; i ++ ) { </a> 0
<a> ByteBuffer b = buffers [ i ] ; </a> 0
<a> int bLen = b . remaining ( ) ; </a> 0
<a> int oldPos = b . position ( ) ; </a> 0
<a> b . get ( mergedArray , j , bLen ) ; </a> 0
<a> b . position ( oldPos ) ; </a> 0
<a> j += bLen ; </a> 0
<a> } </a> 0
<a> return wrappedBuffer ( mergedArray ) . order ( order ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copiedBuffer ( CharSequence string , Charset charset ) { </a> 0
<a> if ( string == null ) { </a> 0
<a> throw new NullPointerException ( "string" ) ; </a> 0
<a> } </a> 0
<a> if ( string instanceof CharBuffer ) { </a> 0
<a> return copiedBuffer ( ( CharBuffer ) string , charset ) ; </a> 0
<a> } </a> 0
<a> return copiedBuffer ( CharBuffer . wrap ( string ) , charset ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copiedBuffer ( </a> 0
<a> CharSequence string , int offset , int length , Charset charset ) { </a> 0
<a> if ( string == null ) { </a> 0
<a> throw new NullPointerException ( "string" ) ; </a> 0
<a> } </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> if ( string instanceof CharBuffer ) { </a> 0
<a> CharBuffer buf = ( CharBuffer ) string ; </a> 0
<a> if ( buf . hasArray ( ) ) { </a> 0
<a> return copiedBuffer ( </a> 0
<a> buf . array ( ) , </a> 0
<a> buf . arrayOffset ( ) + buf . position ( ) + offset , </a> 0
<a> length , charset ) ; </a> 0
<a> } </a> 0
<a> buf = buf . slice ( ) ; </a> 0
<a> buf . limit ( length ) ; </a> 0
<a> buf . position ( offset ) ; </a> 0
<a> return copiedBuffer ( buf , charset ) ; </a> 0
<a> } </a> 0
<a> return copiedBuffer ( CharBuffer . wrap ( string , offset , offset + length ) , charset ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copiedBuffer ( char [ ] array , Charset charset ) { </a> 0
<a> return copiedBuffer ( array , 0 , array . length , charset ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copiedBuffer ( char [ ] array , int offset , int length , Charset charset ) { </a> 0
<a> if ( array == null ) { </a> 0
<a> throw new NullPointerException ( "array" ) ; </a> 0
<a> } </a> 0
<a> if ( length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> return copiedBuffer ( CharBuffer . wrap ( array , offset , length ) , charset ) ; </a> 0
<a> } </a> 0
<a> private static ByteBuf copiedBuffer ( CharBuffer buffer , Charset charset ) { </a> 0
<a> ByteBuffer dst = ByteBufUtil . encodeString ( buffer , charset ) ; </a> 0
<a> ByteBuf result = wrappedBuffer ( dst . array ( ) ) ; </a> 0
<a> result . writerIndex ( dst . remaining ( ) ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> public static ByteBuf unmodifiableBuffer ( ByteBuf buffer ) { </a> 0
<a> if ( buffer instanceof ReadOnlyByteBuf ) { </a> 1
<a> buffer = ( ( ReadOnlyByteBuf ) buffer ) . unwrap ( ) ; </a> 1
<a> } </a> 1
<a> return new ReadOnlyByteBuf ( buffer ) ; </a> 1
<a> } </a> 0
<a> public static ByteBuf copyInt ( int value ) { </a> 0
<a> ByteBuf buf = buffer ( 4 ) ; </a> 0
<a> buf . writeInt ( value ) ; </a> 0
<a> return buf ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyInt ( int ... values ) { </a> 0
<a> if ( values == null || values . length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> ByteBuf buffer = buffer ( values . length * 4 ) ; </a> 0
<a> for ( int v : values ) { </a> 0
<a> buffer . writeInt ( v ) ; </a> 0
<a> } </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyShort ( int value ) { </a> 0
<a> ByteBuf buf = buffer ( 2 ) ; </a> 0
<a> buf . writeShort ( value ) ; </a> 0
<a> return buf ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyShort ( short ... values ) { </a> 0
<a> if ( values == null || values . length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> ByteBuf buffer = buffer ( values . length * 2 ) ; </a> 0
<a> for ( int v : values ) { </a> 0
<a> buffer . writeShort ( v ) ; </a> 0
<a> } </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyShort ( int ... values ) { </a> 0
<a> if ( values == null || values . length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> ByteBuf buffer = buffer ( values . length * 2 ) ; </a> 0
<a> for ( int v : values ) { </a> 0
<a> buffer . writeShort ( v ) ; </a> 0
<a> } </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyMedium ( int value ) { </a> 0
<a> ByteBuf buf = buffer ( 3 ) ; </a> 0
<a> buf . writeMedium ( value ) ; </a> 0
<a> return buf ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyMedium ( int ... values ) { </a> 0
<a> if ( values == null || values . length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> ByteBuf buffer = buffer ( values . length * 3 ) ; </a> 0
<a> for ( int v : values ) { </a> 0
<a> buffer . writeMedium ( v ) ; </a> 0
<a> } </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyLong ( long value ) { </a> 0
<a> ByteBuf buf = buffer ( 8 ) ; </a> 0
<a> buf . writeLong ( value ) ; </a> 0
<a> return buf ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyLong ( long ... values ) { </a> 0
<a> if ( values == null || values . length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> ByteBuf buffer = buffer ( values . length * 8 ) ; </a> 0
<a> for ( long v : values ) { </a> 0
<a> buffer . writeLong ( v ) ; </a> 0
<a> } </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyBoolean ( boolean value ) { </a> 0
<a> ByteBuf buf = buffer ( 1 ) ; </a> 0
<a> buf . writeBoolean ( value ) ; </a> 0
<a> return buf ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyBoolean ( boolean ... values ) { </a> 0
<a> if ( values == null || values . length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> ByteBuf buffer = buffer ( values . length ) ; </a> 0
<a> for ( boolean v : values ) { </a> 0
<a> buffer . writeBoolean ( v ) ; </a> 0
<a> } </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyFloat ( float value ) { </a> 0
<a> ByteBuf buf = buffer ( 4 ) ; </a> 0
<a> buf . writeFloat ( value ) ; </a> 0
<a> return buf ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyFloat ( float ... values ) { </a> 0
<a> if ( values == null || values . length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> ByteBuf buffer = buffer ( values . length * 4 ) ; </a> 0
<a> for ( float v : values ) { </a> 0
<a> buffer . writeFloat ( v ) ; </a> 0
<a> } </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyDouble ( double value ) { </a> 0
<a> ByteBuf buf = buffer ( 8 ) ; </a> 0
<a> buf . writeDouble ( value ) ; </a> 0
<a> return buf ; </a> 0
<a> } </a> 0
<a> public static ByteBuf copyDouble ( double ... values ) { </a> 0
<a> if ( values == null || values . length == 0 ) { </a> 0
<a> return EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> ByteBuf buffer = buffer ( values . length * 8 ) ; </a> 0
<a> for ( double v : values ) { </a> 0
<a> buffer . writeDouble ( v ) ; </a> 0
<a> } </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> private Unpooled ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> public interface WrappedByteBuf extends ByteBuf { </a> 1
<a> ByteBuf unwrap ( ) ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import static io . netty . buffer . Unpooled . * ; </a> 1
<a> import static org . junit . Assert . * ; </a> 1
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . ByteOrder ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public abstract class AbstractCompositeChannelBufferTest extends </a> 0
<a> AbstractChannelBufferTest { </a> 0
<a> private final ByteOrder order ; </a> 0
<a> protected AbstractCompositeChannelBufferTest ( ByteOrder order ) { </a> 0
<a> if ( order == null ) { </a> 0
<a> throw new NullPointerException ( "order" ) ; </a> 0
<a> } </a> 0
<a> this . order = order ; </a> 0
<a> } </a> 0
<a> private List < ByteBuf > buffers ; </a> 0
<a> private ByteBuf buffer ; </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf newBuffer ( int length ) { </a> 0
<a> buffers = new ArrayList < ByteBuf > ( ) ; </a> 0
<a> for ( int i = 0 ; i < length + 45 ; i += 45 ) { </a> 0
<a> buffers . add ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> buffers . add ( Unpooled . wrappedBuffer ( new byte [ 1 ] ) ) ; </a> 0
<a> buffers . add ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> buffers . add ( Unpooled . wrappedBuffer ( new byte [ 2 ] ) ) ; </a> 0
<a> buffers . add ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> buffers . add ( Unpooled . wrappedBuffer ( new byte [ 3 ] ) ) ; </a> 0
<a> buffers . add ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> buffers . add ( Unpooled . wrappedBuffer ( new byte [ 4 ] ) ) ; </a> 0
<a> buffers . add ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> buffers . add ( Unpooled . wrappedBuffer ( new byte [ 5 ] ) ) ; </a> 0
<a> buffers . add ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> buffers . add ( Unpooled . wrappedBuffer ( new byte [ 6 ] ) ) ; </a> 0
<a> buffers . add ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> buffers . add ( Unpooled . wrappedBuffer ( new byte [ 7 ] ) ) ; </a> 0
<a> buffers . add ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> buffers . add ( Unpooled . wrappedBuffer ( new byte [ 8 ] ) ) ; </a> 0
<a> buffers . add ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> buffers . add ( Unpooled . wrappedBuffer ( new byte [ 9 ] ) ) ; </a> 0
<a> buffers . add ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> } </a> 0
<a> buffer = Unpooled . wrappedBuffer ( </a> 1
<a> Integer . MAX_VALUE , buffers . toArray ( new ByteBuf [ buffers . size ( ) ] ) ) . order ( order ) ; </a> 1
<a> buffer . capacity ( length ) ; </a> 0
<a> assertEquals ( length , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( length , buffer . readableBytes ( ) ) ; </a> 0
<a> assertFalse ( buffer . writable ( ) ) ; </a> 0
<a> buffer . writerIndex ( 0 ) ; </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf [ ] components ( ) { </a> 0
<a> return buffers . toArray ( new ByteBuf [ buffers . size ( ) ] ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean discardReadBytesDoesNotMoveWritableBytes ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testComponentAtOffset ( ) { </a> 0
<a> CompositeByteBuf buf = ( CompositeByteBuf ) Unpooled . wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 } , new byte [ ] { 4 , 5 , 6 , 7 , 8 , 9 , 26 } ) ; </a> 0
<a> assertEquals ( buf . componentAtOffset ( 2 ) . capacity ( ) , 5 ) ; </a> 1
<a> byte index = 0 ; </a> 0
<a> while ( index < buf . capacity ( ) ) { </a> 0
<a> ByteBuf _buf = buf . componentAtOffset ( index ++ ) ; </a> 0
<a> assertNotNull ( _buf ) ; </a> 0
<a> assertTrue ( _buf . capacity ( ) > 0 ) ; </a> 0
<a> assertNotNull ( _buf . getByte ( 0 ) ) ; </a> 0
<a> assertNotNull ( _buf . getByte ( _buf . readableBytes ( ) - 1 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDiscardReadBytes3 ( ) { </a> 0
<a> ByteBuf a , b ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) . order ( order ) ; </a> 0
<a> b = wrappedBuffer ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } , 0 , 5 ) . order ( order ) , </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } , 5 , 5 ) . order ( order ) ) ; </a> 1
<a> a . skipBytes ( 6 ) ; </a> 0
<a> a . markReaderIndex ( ) ; </a> 0
<a> b . skipBytes ( 6 ) ; </a> 0
<a> b . markReaderIndex ( ) ; </a> 0
<a> assertEquals ( a . readerIndex ( ) , b . readerIndex ( ) ) ; </a> 0
<a> a . readerIndex ( a . readerIndex ( ) - 1 ) ; </a> 0
<a> b . readerIndex ( b . readerIndex ( ) - 1 ) ; </a> 0
<a> assertEquals ( a . readerIndex ( ) , b . readerIndex ( ) ) ; </a> 0
<a> a . writerIndex ( a . writerIndex ( ) - 1 ) ; </a> 0
<a> a . markWriterIndex ( ) ; </a> 0
<a> b . writerIndex ( b . writerIndex ( ) - 1 ) ; </a> 0
<a> b . markWriterIndex ( ) ; </a> 0
<a> assertEquals ( a . writerIndex ( ) , b . writerIndex ( ) ) ; </a> 0
<a> a . writerIndex ( a . writerIndex ( ) + 1 ) ; </a> 0
<a> b . writerIndex ( b . writerIndex ( ) + 1 ) ; </a> 0
<a> assertEquals ( a . writerIndex ( ) , b . writerIndex ( ) ) ; </a> 0
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a . discardReadBytes ( ) ; </a> 0
<a> b . discardReadBytes ( ) ; </a> 0
<a> assertEquals ( a . readerIndex ( ) , b . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( a . writerIndex ( ) , b . writerIndex ( ) ) ; </a> 0
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a . resetReaderIndex ( ) ; </a> 0
<a> b . resetReaderIndex ( ) ; </a> 0
<a> assertEquals ( a . readerIndex ( ) , b . readerIndex ( ) ) ; </a> 0
<a> a . resetWriterIndex ( ) ; </a> 0
<a> b . resetWriterIndex ( ) ; </a> 0
<a> assertEquals ( a . writerIndex ( ) , b . writerIndex ( ) ) ; </a> 0
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testAutoConsolidation ( ) { </a> 0
<a> CompositeByteBuf buf = compositeBuffer ( 2 ) ; </a> 1
<a> buf . addComponent ( wrappedBuffer ( new byte [ ] { 1 } ) ) ; </a> 0
<a> assertEquals ( 1 , buf . numComponents ( ) ) ; </a> 0
<a> buf . addComponent ( wrappedBuffer ( new byte [ ] { 2 , 3 } ) ) ; </a> 0
<a> assertEquals ( 2 , buf . numComponents ( ) ) ; </a> 0
<a> buf . addComponent ( wrappedBuffer ( new byte [ ] { 4 , 5 , 6 } ) ) ; </a> 0
<a> assertEquals ( 1 , buf . numComponents ( ) ) ; </a> 0
<a> assertTrue ( buf . hasArray ( ) ) ; </a> 0
<a> assertNotNull ( buf . array ( ) ) ; </a> 0
<a> assertEquals ( 0 , buf . arrayOffset ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testFullConsolidation ( ) { </a> 0
<a> CompositeByteBuf buf = compositeBuffer ( Integer . MAX_VALUE ) ; </a> 1
<a> buf . addComponent ( wrappedBuffer ( new byte [ ] { 1 } ) ) ; </a> 0
<a> buf . addComponent ( wrappedBuffer ( new byte [ ] { 2 , 3 } ) ) ; </a> 0
<a> buf . addComponent ( wrappedBuffer ( new byte [ ] { 4 , 5 , 6 } ) ) ; </a> 0
<a> buf . consolidate ( ) ; </a> 0
<a> assertEquals ( 1 , buf . numComponents ( ) ) ; </a> 0
<a> assertTrue ( buf . hasArray ( ) ) ; </a> 0
<a> assertNotNull ( buf . array ( ) ) ; </a> 0
<a> assertEquals ( 0 , buf . arrayOffset ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRangedConsolidation ( ) { </a> 0
<a> CompositeByteBuf buf = compositeBuffer ( Integer . MAX_VALUE ) ; </a> 1
<a> buf . addComponent ( wrappedBuffer ( new byte [ ] { 1 } ) ) ; </a> 0
<a> buf . addComponent ( wrappedBuffer ( new byte [ ] { 2 , 3 } ) ) ; </a> 0
<a> buf . addComponent ( wrappedBuffer ( new byte [ ] { 4 , 5 , 6 } ) ) ; </a> 0
<a> buf . addComponent ( wrappedBuffer ( new byte [ ] { 7 , 8 , 9 , 10 } ) ) ; </a> 0
<a> buf . consolidate ( 1 , 2 ) ; </a> 0
<a> assertEquals ( 3 , buf . numComponents ( ) ) ; </a> 0
<a> assertEquals ( wrappedBuffer ( new byte [ ] { 1 } ) , buf . component ( 0 ) ) ; </a> 0
<a> assertEquals ( wrappedBuffer ( new byte [ ] { 2 , 3 , 4 , 5 , 6 } ) , buf . component ( 1 ) ) ; </a> 0
<a> assertEquals ( wrappedBuffer ( new byte [ ] { 7 , 8 , 9 , 10 } ) , buf . component ( 2 ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testCompositeWrappedBuffer ( ) { </a> 0
<a> ByteBuf header = buffer ( 12 ) . order ( order ) ; </a> 1
<a> ByteBuf payload = buffer ( 512 ) . order ( order ) ; </a> 1
<a> header . writeBytes ( new byte [ 12 ] ) ; </a> 0
<a> payload . writeBytes ( new byte [ 512 ] ) ; </a> 0
<a> ByteBuf buffer = wrappedBuffer ( header , payload ) ; </a> 1
<a> assertTrue ( header . readableBytes ( ) == 12 ) ; </a> 1
<a> assertTrue ( payload . readableBytes ( ) == 512 ) ; </a> 1
<a> assertEquals ( 12 + 512 , buffer . readableBytes ( ) ) ; </a> 0
<a> assertFalse ( buffer . hasNioBuffer ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSeveralBuffersEquals ( ) { </a> 0
<a> ByteBuf a , b ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 } ) . order ( order ) , </a> 1
<a> wrappedBuffer ( new byte [ ] { 2 } ) . order ( order ) ) ; </a> 1
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 } ) . order ( order ) , </a> 1
<a> wrappedBuffer ( new byte [ ] { 2 } ) . order ( order ) , </a> 0
<a> wrappedBuffer ( new byte [ ] { 3 } ) . order ( order ) ) ; </a> 1
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 } , 1 , 2 ) . order ( order ) , </a> 1
<a> wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 } , 3 , 1 ) . order ( order ) ) ; </a> 1
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 , 2 } ) . order ( order ) , </a> 1
<a> wrappedBuffer ( new byte [ ] { 4 } ) . order ( order ) ) ; </a> 1
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 4 , 5 } , 1 , 2 ) . order ( order ) , </a> 1
<a> wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 4 , 5 } , 3 , 1 ) . order ( order ) ) ; </a> 1
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) , </a> 1
<a> wrappedBuffer ( new byte [ ] { 4 , 5 , 6 } ) . order ( order ) , </a> 0
<a> wrappedBuffer ( new byte [ ] { 7 , 8 , 9 , 10 } ) . order ( order ) ) ; </a> 1
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 } , 1 , 5 ) . order ( order ) , </a> 1
<a> wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 } , 6 , 5 ) . order ( order ) ) ; </a> 1
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 6 } ) . order ( order ) , </a> 1
<a> wrappedBuffer ( new byte [ ] { 7 , 8 , 5 , 9 , 10 } ) . order ( order ) ) ; </a> 1
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 6 , 7 , 8 , 5 , 9 , 10 , 11 } , 1 , 5 ) . order ( order ) , </a> 1
<a> wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 6 , 7 , 8 , 5 , 9 , 10 , 11 } , 6 , 5 ) . order ( order ) ) ; </a> 1
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrappedBuffer ( ) { </a> 0
<a> assertEquals ( 16 , wrappedBuffer ( wrappedBuffer ( ByteBuffer . allocateDirect ( 16 ) ) ) . capacity ( ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ) , </a> 0
<a> wrappedBuffer ( wrappedBuffer ( new byte [ ] [ ] { new byte [ ] { 1 , 2 , 3 } } ) . order ( order ) ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ) , </a> 0
<a> wrappedBuffer ( wrappedBuffer ( </a> 1
<a> new byte [ ] { 1 } , </a> 0
<a> new byte [ ] { 2 } , </a> 0
<a> new byte [ ] { 3 } ) . order ( order ) ) ) ; </a> 1
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ) , </a> 0
<a> wrappedBuffer ( new ByteBuf [ ] { </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) </a> 0
<a> } ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ) , </a> 0
<a> wrappedBuffer ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 1 } ) . order ( order ) , </a> 0
<a> wrappedBuffer ( new byte [ ] { 2 } ) . order ( order ) , </a> 0
<a> wrappedBuffer ( new byte [ ] { 3 } ) . order ( order ) ) ) ; </a> 1
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ) , </a> 0
<a> wrappedBuffer ( wrappedBuffer ( new ByteBuffer [ ] { </a> 0
<a> ByteBuffer . wrap ( new byte [ ] { 1 , 2 , 3 } ) </a> 0
<a> } ) ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ) , </a> 0
<a> wrappedBuffer ( wrappedBuffer ( </a> 1
<a> ByteBuffer . wrap ( new byte [ ] { 1 } ) , </a> 0
<a> ByteBuffer . wrap ( new byte [ ] { 2 } ) , </a> 0
<a> ByteBuffer . wrap ( new byte [ ] { 3 } ) ) ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrittenBuffersEquals ( ) { </a> 0
<a> ByteBuf a , b ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 } , new byte [ 1 ] ) . order ( order ) ) ; </a> 1
<a> b . writerIndex ( b . writerIndex ( ) - 1 ) ; </a> 0
<a> b . writeBytes ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 2 } ) . order ( order ) ) ; </a> 1
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 } , new byte [ 2 ] ) . order ( order ) ) ; </a> 1
<a> b . writerIndex ( b . writerIndex ( ) - 2 ) ; </a> 0
<a> b . writeBytes ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 2 } ) . order ( order ) ) ; </a> 1
<a> b . writeBytes ( wrappedBuffer ( new byte [ ] { 3 } ) . order ( order ) ) ; </a> 1
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 } , 1 , 3 ) . order ( order ) ) ; </a> 1
<a> b . writerIndex ( b . writerIndex ( ) - 1 ) ; </a> 0
<a> b . writeBytes ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 } , 3 , 1 ) . order ( order ) ) ; </a> 1
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 , 2 } , new byte [ 1 ] ) . order ( order ) ) ; </a> 1
<a> b . writerIndex ( b . writerIndex ( ) - 1 ) ; </a> 0
<a> b . writeBytes ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 4 } ) . order ( order ) ) ; </a> 1
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 4 , 5 } , 1 , 3 ) . order ( order ) ) ; </a> 1
<a> b . writerIndex ( b . writerIndex ( ) - 1 ) ; </a> 0
<a> b . writeBytes ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 4 , 5 } , 3 , 1 ) . order ( order ) ) ; </a> 1
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } , new byte [ 7 ] ) . order ( order ) ) ; </a> 1
<a> b . writerIndex ( b . writerIndex ( ) - 7 ) ; </a> 0
<a> b . writeBytes ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 4 , 5 , 6 } ) . order ( order ) ) ; </a> 1
<a> b . writeBytes ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 7 , 8 , 9 , 10 } ) . order ( order ) ) ; </a> 1
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 } , 1 , 10 ) . order ( order ) ) ; </a> 1
<a> b . writerIndex ( b . writerIndex ( ) - 5 ) ; </a> 0
<a> b . writeBytes ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 } , 6 , 5 ) . order ( order ) ) ; </a> 1
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 6 } , new byte [ 5 ] ) . order ( order ) ) ; </a> 1
<a> b . writerIndex ( b . writerIndex ( ) - 5 ) ; </a> 0
<a> b . writeBytes ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 7 , 8 , 5 , 9 , 10 } ) . order ( order ) ) ; </a> 1
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) . order ( order ) ; </a> 1
<a> b = wrappedBuffer ( wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 6 , 7 , 8 , 5 , 9 , 10 , 11 } , 1 , 10 ) . order ( order ) ) ; </a> 1
<a> b . writerIndex ( b . writerIndex ( ) - 5 ) ; </a> 0
<a> b . writeBytes ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 6 , 7 , 8 , 5 , 9 , 10 , 11 } , 6 , 5 ) . order ( order ) ) ; </a> 1
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import java . nio . ByteOrder ; </a> 0
<a> public class BigEndianDirectChannelBufferTest extends AbstractChannelBufferTest { </a> 0
<a> private ByteBuf buffer ; </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf newBuffer ( int length ) { </a> 0
<a> buffer = Unpooled . directBuffer ( length ) ; </a> 1
<a> assertSame ( ByteOrder . BIG_ENDIAN , buffer . order ( ) ) ; </a> 0
<a> assertEquals ( 0 , buffer . writerIndex ( ) ) ; </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf [ ] components ( ) { </a> 0
<a> return new ByteBuf [ ] { buffer } ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class BigEndianHeapChannelBufferTest extends AbstractChannelBufferTest { </a> 0
<a> private ByteBuf buffer ; </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf newBuffer ( int length ) { </a> 0
<a> buffer = Unpooled . buffer ( length ) ; </a> 0
<a> assertEquals ( 0 , buffer . writerIndex ( ) ) ; </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf [ ] components ( ) { </a> 0
<a> return new ByteBuf [ ] { buffer } ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = NullPointerException . class ) </a> 0
<a> public void shouldNotAllowNullInConstructor ( ) { </a> 1
<a> new HeapByteBuf ( null , 0 ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import java . io . EOFException ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class ChannelBufferStreamTest { </a> 0
<a> @ Test </a> 0
<a> public void testAll ( ) throws Exception { </a> 0
<a> ByteBuf buf = Unpooled . buffer ( 0 , 65536 ) ; </a> 0
<a> try { </a> 0
<a> new ByteBufOutputStream ( null ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( NullPointerException e ) { </a> 0
<a> } </a> 0
<a> ByteBufOutputStream out = new ByteBufOutputStream ( buf ) ; </a> 0
<a> assertSame ( buf , out . buffer ( ) ) ; </a> 0
<a> out . writeBoolean ( true ) ; </a> 0
<a> out . writeBoolean ( false ) ; </a> 0
<a> out . writeByte ( 42 ) ; </a> 0
<a> out . writeByte ( 224 ) ; </a> 0
<a> out . writeBytes ( "Hello, World!" ) ; </a> 0
<a> out . writeChars ( "Hello, World" ) ; </a> 0
<a> out . writeChar ( '!' ) ; </a> 0
<a> out . writeDouble ( 42.0 ) ; </a> 0
<a> out . writeFloat ( 42.0f ) ; </a> 0
<a> out . writeInt ( 42 ) ; </a> 0
<a> out . writeLong ( 42 ) ; </a> 0
<a> out . writeShort ( 42 ) ; </a> 0
<a> out . writeShort ( 49152 ) ; </a> 0
<a> out . writeUTF ( "Hello, World!" ) ; </a> 0
<a> out . writeBytes ( "The first line\r\r\n" ) ; </a> 0
<a> out . write ( new byte [ 0 ] ) ; </a> 0
<a> out . write ( new byte [ ] { 1 , 2 , 3 , 4 } ) ; </a> 0
<a> out . write ( new byte [ ] { 1 , 3 , 3 , 4 } , 0 , 0 ) ; </a> 0
<a> out . close ( ) ; </a> 0
<a> try { </a> 0
<a> new ByteBufInputStream ( null ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( NullPointerException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> new ByteBufInputStream ( null , 0 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( NullPointerException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> new ByteBufInputStream ( buf , - 1 ) ; </a> 0
<a> } catch ( IllegalArgumentException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> new ByteBufInputStream ( buf , buf . capacity ( ) + 1 ) ; </a> 0
<a> } catch ( IndexOutOfBoundsException e ) { </a> 0
<a> } </a> 0
<a> ByteBufInputStream in = new ByteBufInputStream ( buf ) ; </a> 0
<a> assertTrue ( in . markSupported ( ) ) ; </a> 0
<a> in . mark ( Integer . MAX_VALUE ) ; </a> 0
<a> assertEquals ( buf . writerIndex ( ) , in . skip ( Long . MAX_VALUE ) ) ; </a> 0
<a> assertFalse ( buf . readable ( ) ) ; </a> 0
<a> in . reset ( ) ; </a> 0
<a> assertEquals ( 0 , buf . readerIndex ( ) ) ; </a> 0
<a> assertEquals ( 4 , in . skip ( 4 ) ) ; </a> 0
<a> assertEquals ( 4 , buf . readerIndex ( ) ) ; </a> 0
<a> in . reset ( ) ; </a> 0
<a> assertTrue ( in . readBoolean ( ) ) ; </a> 0
<a> assertFalse ( in . readBoolean ( ) ) ; </a> 0
<a> assertEquals ( 42 , in . readByte ( ) ) ; </a> 0
<a> assertEquals ( 224 , in . readUnsignedByte ( ) ) ; </a> 0
<a> byte [ ] tmp = new byte [ 13 ] ; </a> 0
<a> in . readFully ( tmp ) ; </a> 0
<a> assertEquals ( "Hello, World!" , new String ( tmp , "ISO-8859-1" ) ) ; </a> 0
<a> assertEquals ( 'H' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( 'e' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( 'l' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( 'l' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( 'o' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( ',' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( ' ' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( 'W' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( 'o' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( 'r' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( 'l' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( 'd' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( '!' , in . readChar ( ) ) ; </a> 0
<a> assertEquals ( 42.0 , in . readDouble ( ) , 0.0 ) ; </a> 0
<a> assertEquals ( 42.0f , in . readFloat ( ) , 0.0 ) ; </a> 0
<a> assertEquals ( 42 , in . readInt ( ) ) ; </a> 0
<a> assertEquals ( 42 , in . readLong ( ) ) ; </a> 0
<a> assertEquals ( 42 , in . readShort ( ) ) ; </a> 0
<a> assertEquals ( 49152 , in . readUnsignedShort ( ) ) ; </a> 0
<a> assertEquals ( "Hello, World!" , in . readUTF ( ) ) ; </a> 0
<a> assertEquals ( "The first line" , in . readLine ( ) ) ; </a> 0
<a> assertEquals ( 4 , in . read ( tmp ) ) ; </a> 0
<a> assertEquals ( 1 , tmp [ 0 ] ) ; </a> 0
<a> assertEquals ( 2 , tmp [ 1 ] ) ; </a> 0
<a> assertEquals ( 3 , tmp [ 2 ] ) ; </a> 0
<a> assertEquals ( 4 , tmp [ 3 ] ) ; </a> 0
<a> assertEquals ( - 1 , in . read ( ) ) ; </a> 0
<a> assertEquals ( - 1 , in . read ( tmp ) ) ; </a> 0
<a> try { </a> 0
<a> in . readByte ( ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( EOFException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> in . readFully ( tmp , 0 , - 1 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( IndexOutOfBoundsException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> in . readFully ( tmp ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( EOFException e ) { </a> 0
<a> } </a> 0
<a> in . close ( ) ; </a> 0
<a> assertEquals ( buf . readerIndex ( ) , in . readBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testEmptyReadLine ( ) throws Exception { </a> 0
<a> ByteBuf buf = Unpooled . buffer ( 0 ) ; </a> 0
<a> ByteBufInputStream in = new ByteBufInputStream ( buf ) ; </a> 0
<a> String s = in . readLine ( ) ; </a> 0
<a> assertEquals ( 0 , s . length ( ) ) ; </a> 0
<a> in . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import static io . netty . buffer . Unpooled . * ; </a> 1
<a> import static org . junit . Assert . * ; </a> 1
<a> import java . io . InputStream ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . channels . ScatteringByteChannel ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . LinkedHashMap ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> import org . easymock . EasyMock ; </a> 1
<a> import org . junit . Test ; </a> 1
<a> public class ChannelBuffersTest { </a> 0
<a> @ Test </a> 0
<a> public void testCompositeWrappedBuffer ( ) { </a> 0
<a> ByteBuf header = buffer ( 12 ) ; </a> 0
<a> ByteBuf payload = buffer ( 512 ) ; </a> 0
<a> header . writeBytes ( new byte [ 12 ] ) ; </a> 0
<a> payload . writeBytes ( new byte [ 512 ] ) ; </a> 0
<a> ByteBuf buffer = wrappedBuffer ( header , payload ) ; </a> 0
<a> assertTrue ( header . readableBytes ( ) == 12 ) ; </a> 1
<a> assertTrue ( payload . readableBytes ( ) == 512 ) ; </a> 1
<a> assertEquals ( 12 + 512 , buffer . readableBytes ( ) ) ; </a> 0
<a> assertFalse ( buffer . hasNioBuffer ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testHashCode ( ) { </a> 0
<a> Map < byte [ ] , Integer > map = new LinkedHashMap < byte [ ] , Integer > ( ) ; </a> 0
<a> map . put ( new byte [ 0 ] , 1 ) ; </a> 0
<a> map . put ( new byte [ ] { 1 } , 32 ) ; </a> 0
<a> map . put ( new byte [ ] { 2 } , 33 ) ; </a> 0
<a> map . put ( new byte [ ] { 0 , 1 } , 962 ) ; </a> 0
<a> map . put ( new byte [ ] { 1 , 2 } , 994 ) ; </a> 0
<a> map . put ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 5 } , 63504931 ) ; </a> 0
<a> map . put ( new byte [ ] { 6 , 7 , 8 , 9 , 0 , 1 } , ( int ) 97180294697L ) ; </a> 0
<a> map . put ( new byte [ ] { - 1 , - 1 , - 1 , ( byte ) 0xE1 } , 1 ) ; </a> 0
<a> for ( Entry < byte [ ] , Integer > e : map . entrySet ( ) ) { </a> 0
<a> assertEquals ( </a> 0
<a> e . getValue ( ) . intValue ( ) , </a> 0
<a> ByteBufUtil . hashCode ( wrappedBuffer ( e . getKey ( ) ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testEquals ( ) { </a> 0
<a> ByteBuf a , b ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 } ) ; </a> 0
<a> b = wrappedBuffer ( new byte [ ] { 1 , 2 } ) ; </a> 0
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) ; </a> 0
<a> b = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) ; </a> 0
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) ; </a> 0
<a> b = wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 } , 1 , 3 ) ; </a> 0
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) ; </a> 0
<a> b = wrappedBuffer ( new byte [ ] { 1 , 2 , 4 } ) ; </a> 0
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) ; </a> 0
<a> b = wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 4 , 5 } , 1 , 3 ) ; </a> 0
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) ; </a> 0
<a> b = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) ; </a> 0
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) ; </a> 0
<a> b = wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 } , 1 , 10 ) ; </a> 0
<a> assertTrue ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) ; </a> 0
<a> b = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 6 , 7 , 8 , 5 , 9 , 10 } ) ; </a> 0
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> a = wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) ; </a> 0
<a> b = wrappedBuffer ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 6 , 7 , 8 , 5 , 9 , 10 , 11 } , 1 , 10 ) ; </a> 0
<a> assertFalse ( ByteBufUtil . equals ( a , b ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testCompare ( ) { </a> 0
<a> List < ByteBuf > expected = new ArrayList < ByteBuf > ( ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 1 } ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 1 , 2 } ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 } ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 2 } ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 2 , 3 } ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 } ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 } ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 2 , 3 , 4 } , 1 , 1 ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 } , 2 , 2 ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 } , 1 , 10 ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 } , 2 , 12 ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 2 , 3 , 4 , 5 } , 2 , 1 ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 } , 3 , 2 ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 } , 2 , 10 ) ) ; </a> 0
<a> expected . add ( wrappedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } , 3 , 12 ) ) ; </a> 0
<a> for ( int i = 0 ; i < expected . size ( ) ; i ++ ) { </a> 0
<a> for ( int j = 0 ; j < expected . size ( ) ; j ++ ) { </a> 0
<a> if ( i == j ) { </a> 0
<a> assertEquals ( 0 , ByteBufUtil . compare ( expected . get ( i ) , expected . get ( j ) ) ) ; </a> 0
<a> } else if ( i < j ) { </a> 0
<a> assertTrue ( ByteBufUtil . compare ( expected . get ( i ) , expected . get ( j ) ) < 0 ) ; </a> 0
<a> } else { </a> 0
<a> assertTrue ( ByteBufUtil . compare ( expected . get ( i ) , expected . get ( j ) ) > 0 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void shouldReturnEmptyBufferWhenLengthIsZero ( ) { </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( new byte [ 0 ] ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( new byte [ 0 ] ) . order ( LITTLE_ENDIAN ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( new byte [ 8 ] , 0 , 0 ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( new byte [ 8 ] , 0 , 0 ) . order ( LITTLE_ENDIAN ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( new byte [ 8 ] , 8 , 0 ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( new byte [ 8 ] , 8 , 0 ) . order ( LITTLE_ENDIAN ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( ByteBuffer . allocateDirect ( 0 ) ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( EMPTY_BUFFER ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( new byte [ 0 ] [ ] ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( new byte [ ] [ ] { new byte [ 0 ] } ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( new ByteBuffer [ 0 ] ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( new ByteBuffer [ ] { ByteBuffer . allocate ( 0 ) } ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( ByteBuffer . allocate ( 0 ) , ByteBuffer . allocate ( 0 ) ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( new ByteBuf [ 0 ] ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( new ByteBuf [ ] { buffer ( 0 ) } ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , wrappedBuffer ( buffer ( 0 ) , buffer ( 0 ) ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( new byte [ 0 ] ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( new byte [ 0 ] ) . order ( LITTLE_ENDIAN ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( new byte [ 8 ] , 0 , 0 ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( new byte [ 8 ] , 0 , 0 ) . order ( LITTLE_ENDIAN ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( new byte [ 8 ] , 8 , 0 ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( new byte [ 8 ] , 8 , 0 ) . order ( LITTLE_ENDIAN ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( ByteBuffer . allocateDirect ( 0 ) ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( EMPTY_BUFFER ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( new byte [ 0 ] [ ] ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( new byte [ ] [ ] { new byte [ 0 ] } ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( new ByteBuffer [ 0 ] ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( new ByteBuffer [ ] { ByteBuffer . allocate ( 0 ) } ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( ByteBuffer . allocate ( 0 ) , ByteBuffer . allocate ( 0 ) ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( new ByteBuf [ 0 ] ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( new ByteBuf [ ] { buffer ( 0 ) } ) ) ; </a> 0
<a> assertSame ( EMPTY_BUFFER , copiedBuffer ( buffer ( 0 ) , buffer ( 0 ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testCompare2 ( ) { </a> 0
<a> assertTrue ( ByteBufUtil . compare ( </a> 0
<a> Unpooled . wrappedBuffer ( new byte [ ] { ( byte ) 0xFF , ( byte ) 0xFF , ( byte ) 0xFF , ( byte ) 0xFF } ) , </a> 0
<a> Unpooled . wrappedBuffer ( new byte [ ] { ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 , ( byte ) 0x00 } ) ) </a> 0
<a> > 0 ) ; </a> 0
<a> assertTrue ( ByteBufUtil . compare ( </a> 0
<a> Unpooled . wrappedBuffer ( new byte [ ] { ( byte ) 0xFF } ) , </a> 0
<a> Unpooled . wrappedBuffer ( new byte [ ] { ( byte ) 0x00 } ) ) </a> 0
<a> > 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void shouldAllowEmptyBufferToCreateCompositeBuffer ( ) { </a> 0
<a> ByteBuf buf = wrappedBuffer ( </a> 0
<a> EMPTY_BUFFER , </a> 0
<a> wrappedBuffer ( new byte [ 16 ] ) . order ( LITTLE_ENDIAN ) , </a> 0
<a> EMPTY_BUFFER ) ; </a> 0
<a> assertEquals ( 16 , buf . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrappedBuffer ( ) { </a> 0
<a> assertEquals ( 16 , wrappedBuffer ( ByteBuffer . allocateDirect ( 16 ) ) . capacity ( ) ) ; </a> 1
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) , </a> 0
<a> wrappedBuffer ( new byte [ ] [ ] { new byte [ ] { 1 , 2 , 3 } } ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) , </a> 0
<a> wrappedBuffer ( </a> 1
<a> new byte [ ] { 1 } , </a> 0
<a> new byte [ ] { 2 } , </a> 0
<a> new byte [ ] { 3 } ) ) ; </a> 1
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) , </a> 0
<a> wrappedBuffer ( new ByteBuf [ ] { </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) </a> 0
<a> } ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) , </a> 0
<a> wrappedBuffer ( </a> 1
<a> wrappedBuffer ( new byte [ ] { 1 } ) , </a> 0
<a> wrappedBuffer ( new byte [ ] { 2 } ) , </a> 0
<a> wrappedBuffer ( new byte [ ] { 3 } ) ) ) ; </a> 1
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) , </a> 0
<a> wrappedBuffer ( new ByteBuffer [ ] { </a> 0
<a> ByteBuffer . wrap ( new byte [ ] { 1 , 2 , 3 } ) </a> 0
<a> } ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) , </a> 0
<a> wrappedBuffer ( </a> 1
<a> ByteBuffer . wrap ( new byte [ ] { 1 } ) , </a> 0
<a> ByteBuffer . wrap ( new byte [ ] { 2 } ) , </a> 0
<a> ByteBuffer . wrap ( new byte [ ] { 3 } ) ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testCopiedBuffer ( ) { </a> 0
<a> assertEquals ( 16 , copiedBuffer ( ByteBuffer . allocateDirect ( 16 ) ) . capacity ( ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) , </a> 0
<a> copiedBuffer ( new byte [ ] [ ] { new byte [ ] { 1 , 2 , 3 } } ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) , </a> 0
<a> copiedBuffer ( </a> 0
<a> new byte [ ] { 1 } , </a> 0
<a> new byte [ ] { 2 } , </a> 0
<a> new byte [ ] { 3 } ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) , </a> 0
<a> copiedBuffer ( new ByteBuf [ ] { </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) </a> 0
<a> } ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) , </a> 0
<a> copiedBuffer ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 } ) , </a> 0
<a> wrappedBuffer ( new byte [ ] { 2 } ) , </a> 0
<a> wrappedBuffer ( new byte [ ] { 3 } ) ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) , </a> 0
<a> copiedBuffer ( new ByteBuffer [ ] { </a> 0
<a> ByteBuffer . wrap ( new byte [ ] { 1 , 2 , 3 } ) </a> 0
<a> } ) ) ; </a> 0
<a> assertEquals ( </a> 0
<a> wrappedBuffer ( new byte [ ] { 1 , 2 , 3 } ) , </a> 0
<a> copiedBuffer ( </a> 0
<a> ByteBuffer . wrap ( new byte [ ] { 1 } ) , </a> 0
<a> ByteBuffer . wrap ( new byte [ ] { 2 } ) , </a> 0
<a> ByteBuffer . wrap ( new byte [ ] { 3 } ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testHexDump ( ) { </a> 0
<a> assertEquals ( "" , ByteBufUtil . hexDump ( EMPTY_BUFFER ) ) ; </a> 0
<a> assertEquals ( "123456" , ByteBufUtil . hexDump ( wrappedBuffer ( </a> 0
<a> new byte [ ] { </a> 0
<a> 0x12 , 0x34 , 0x56 </a> 0
<a> } ) ) ) ; </a> 0
<a> assertEquals ( "1234567890abcdef" , ByteBufUtil . hexDump ( wrappedBuffer ( </a> 0
<a> new byte [ ] { </a> 0
<a> 0x12 , 0x34 , 0x56 , 0x78 , </a> 0
<a> ( byte ) 0x90 , ( byte ) 0xAB , ( byte ) 0xCD , ( byte ) 0xEF </a> 0
<a> } ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSwapMedium ( ) { </a> 0
<a> assertEquals ( 0x563412 , ByteBufUtil . swapMedium ( 0x123456 ) ) ; </a> 0
<a> assertEquals ( 0x80 , ByteBufUtil . swapMedium ( 0x800000 ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testUnmodifiableBuffer ( ) throws Exception { </a> 0
<a> ByteBuf buf = unmodifiableBuffer ( buffer ( 16 ) ) ; </a> 0
<a> try { </a> 0
<a> buf . discardReadBytes ( ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( UnsupportedOperationException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> buf . setByte ( 0 , ( byte ) 0 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( UnsupportedOperationException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> buf . setBytes ( 0 , EMPTY_BUFFER , 0 , 0 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( UnsupportedOperationException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> buf . setBytes ( 0 , new byte [ 0 ] , 0 , 0 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( UnsupportedOperationException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> buf . setBytes ( 0 , ByteBuffer . allocate ( 0 ) ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( UnsupportedOperationException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> buf . setShort ( 0 , ( short ) 0 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( UnsupportedOperationException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> buf . setMedium ( 0 , 0 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( UnsupportedOperationException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> buf . setInt ( 0 , 0 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( UnsupportedOperationException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> buf . setLong ( 0 , 0 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( UnsupportedOperationException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> buf . setBytes ( 0 , EasyMock . createMock ( InputStream . class ) , 0 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( UnsupportedOperationException e ) { </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> buf . setBytes ( 0 , EasyMock . createMock ( ScatteringByteChannel . class ) , 0 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( UnsupportedOperationException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapSingleInt ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyInt ( 42 ) ; </a> 0
<a> assertEquals ( 4 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 42 , buffer . readInt ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapInt ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyInt ( 1 , 4 ) ; </a> 0
<a> assertEquals ( 8 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 1 , buffer . readInt ( ) ) ; </a> 0
<a> assertEquals ( 4 , buffer . readInt ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( 0 , Unpooled . copyInt ( null ) . capacity ( ) ) ; </a> 1
<a> assertEquals ( 0 , Unpooled . copyInt ( new int [ 0 ] ) . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapSingleShort ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyShort ( 42 ) ; </a> 0
<a> assertEquals ( 2 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 42 , buffer . readShort ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapShortFromShortArray ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyShort ( new short [ ] { 1 , 4 } ) ; </a> 0
<a> assertEquals ( 4 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 1 , buffer . readShort ( ) ) ; </a> 0
<a> assertEquals ( 4 , buffer . readShort ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( 0 , Unpooled . copyShort ( ( short [ ] ) null ) . capacity ( ) ) ; </a> 1
<a> assertEquals ( 0 , Unpooled . copyShort ( new short [ 0 ] ) . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapShortFromIntArray ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyShort ( 1 , 4 ) ; </a> 0
<a> assertEquals ( 4 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 1 , buffer . readShort ( ) ) ; </a> 0
<a> assertEquals ( 4 , buffer . readShort ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( 0 , Unpooled . copyShort ( ( int [ ] ) null ) . capacity ( ) ) ; </a> 1
<a> assertEquals ( 0 , Unpooled . copyShort ( new int [ 0 ] ) . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapSingleMedium ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyMedium ( 42 ) ; </a> 0
<a> assertEquals ( 3 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 42 , buffer . readMedium ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapMedium ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyMedium ( 1 , 4 ) ; </a> 0
<a> assertEquals ( 6 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 1 , buffer . readMedium ( ) ) ; </a> 0
<a> assertEquals ( 4 , buffer . readMedium ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( 0 , Unpooled . copyMedium ( null ) . capacity ( ) ) ; </a> 1
<a> assertEquals ( 0 , Unpooled . copyMedium ( new int [ 0 ] ) . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapSingleLong ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyLong ( 42 ) ; </a> 0
<a> assertEquals ( 8 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 42 , buffer . readLong ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapLong ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyLong ( 1 , 4 ) ; </a> 0
<a> assertEquals ( 16 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 1 , buffer . readLong ( ) ) ; </a> 0
<a> assertEquals ( 4 , buffer . readLong ( ) ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( 0 , Unpooled . copyLong ( null ) . capacity ( ) ) ; </a> 1
<a> assertEquals ( 0 , Unpooled . copyLong ( new long [ 0 ] ) . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapSingleFloat ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyFloat ( 42 ) ; </a> 0
<a> assertEquals ( 4 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 42 , buffer . readFloat ( ) , 0.01 ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapFloat ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyFloat ( 1 , 4 ) ; </a> 0
<a> assertEquals ( 8 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 1 , buffer . readFloat ( ) , 0.01 ) ; </a> 0
<a> assertEquals ( 4 , buffer . readFloat ( ) , 0.01 ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( 0 , Unpooled . copyFloat ( null ) . capacity ( ) ) ; </a> 1
<a> assertEquals ( 0 , Unpooled . copyFloat ( new float [ 0 ] ) . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapSingleDouble ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyDouble ( 42 ) ; </a> 0
<a> assertEquals ( 8 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 42 , buffer . readDouble ( ) , 0.01 ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapDouble ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyDouble ( 1 , 4 ) ; </a> 0
<a> assertEquals ( 16 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 1 , buffer . readDouble ( ) , 0.01 ) ; </a> 0
<a> assertEquals ( 4 , buffer . readDouble ( ) , 0.01 ) ; </a> 0
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( 0 , Unpooled . copyDouble ( null ) . capacity ( ) ) ; </a> 1
<a> assertEquals ( 0 , Unpooled . copyDouble ( new double [ 0 ] ) . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWrapBoolean ( ) { </a> 0
<a> ByteBuf buffer = Unpooled . copyBoolean ( true , false ) ; </a> 0
<a> assertEquals ( 2 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( true , buffer . readBoolean ( ) ) ; </a> 1
<a> assertEquals ( false , buffer . readBoolean ( ) ) ; </a> 1
<a> assertFalse ( buffer . readable ( ) ) ; </a> 0
<a> assertEquals ( 0 , Unpooled . copyBoolean ( null ) . capacity ( ) ) ; </a> 1
<a> assertEquals ( 0 , Unpooled . copyBoolean ( new boolean [ 0 ] ) . capacity ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import java . nio . ByteOrder ; </a> 0
<a> public class LittleEndianHeapChannelBufferTest extends AbstractChannelBufferTest { </a> 0
<a> private ByteBuf buffer ; </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf newBuffer ( int length ) { </a> 0
<a> buffer = Unpooled . buffer ( length ) . order ( ByteOrder . LITTLE_ENDIAN ) ; </a> 0
<a> assertEquals ( 0 , buffer . writerIndex ( ) ) ; </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf [ ] components ( ) { </a> 0
<a> return new ByteBuf [ ] { buffer } ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import static io . netty . buffer . Unpooled . * ; </a> 1
<a> import static org . easymock . EasyMock . * ; </a> 1
<a> import static org . junit . Assert . * ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . channels . GatheringByteChannel ; </a> 0
<a> import java . nio . channels . ScatteringByteChannel ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class ReadOnlyChannelBufferTest { </a> 0
<a> @ Test ( expected = NullPointerException . class ) </a> 0
<a> public void shouldNotAllowNullInConstructor ( ) { </a> 0
<a> new ReadOnlyByteBuf ( null ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testUnmodifiableBuffer ( ) { </a> 0
<a> assertTrue ( Unpooled . unmodifiableBuffer ( Unpooled . buffer ( 1 ) ) instanceof ReadOnlyByteBuf ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testUnwrap ( ) { </a> 0
<a> ByteBuf buf = Unpooled . buffer ( 1 ) ; </a> 0
<a> assertSame ( buf , ( ( WrappedByteBuf ) Unpooled . unmodifiableBuffer ( buf ) ) . unwrap ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void shouldHaveSameByteOrder ( ) { </a> 0
<a> ByteBuf buf = Unpooled . buffer ( 1 ) ; </a> 0
<a> assertSame ( Unpooled . BIG_ENDIAN , Unpooled . unmodifiableBuffer ( buf ) . order ( ) ) ; </a> 0
<a> buf = buf . order ( LITTLE_ENDIAN ) ; </a> 0
<a> assertSame ( Unpooled . LITTLE_ENDIAN , Unpooled . unmodifiableBuffer ( buf ) . order ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void shouldReturnReadOnlyDerivedBuffer ( ) { </a> 0
<a> ByteBuf buf = Unpooled . unmodifiableBuffer ( Unpooled . buffer ( 1 ) ) ; </a> 0
<a> assertTrue ( buf . duplicate ( ) instanceof ReadOnlyByteBuf ) ; </a> 0
<a> assertTrue ( buf . slice ( ) instanceof ReadOnlyByteBuf ) ; </a> 0
<a> assertTrue ( buf . slice ( 0 , 1 ) instanceof ReadOnlyByteBuf ) ; </a> 0
<a> assertTrue ( buf . duplicate ( ) instanceof ReadOnlyByteBuf ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void shouldReturnWritableCopy ( ) { </a> 0
<a> ByteBuf buf = Unpooled . unmodifiableBuffer ( Unpooled . buffer ( 1 ) ) ; </a> 0
<a> assertFalse ( buf . copy ( ) instanceof ReadOnlyByteBuf ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void shouldForwardReadCallsBlindly ( ) throws Exception { </a> 0
<a> ByteBuf buf = createStrictMock ( ByteBuf . class ) ; </a> 1
<a> expect ( buf . order ( ) ) . andReturn ( BIG_ENDIAN ) . anyTimes ( ) ; </a> 0
<a> expect ( buf . maxCapacity ( ) ) . andReturn ( 65536 ) . anyTimes ( ) ; </a> 0
<a> expect ( buf . readerIndex ( ) ) . andReturn ( 0 ) . anyTimes ( ) ; </a> 0
<a> expect ( buf . writerIndex ( ) ) . andReturn ( 0 ) . anyTimes ( ) ; </a> 0
<a> expect ( buf . capacity ( ) ) . andReturn ( 0 ) . anyTimes ( ) ; </a> 0
<a> expect ( buf . getBytes ( 1 , ( GatheringByteChannel ) null , 2 ) ) . andReturn ( 3 ) ; </a> 0
<a> buf . getBytes ( 4 , ( OutputStream ) null , 5 ) ; </a> 0
<a> buf . getBytes ( 6 , ( byte [ ] ) null , 7 , 8 ) ; </a> 0
<a> buf . getBytes ( 9 , ( ByteBuf ) null , 10 , 11 ) ; </a> 0
<a> buf . getBytes ( 12 , ( ByteBuffer ) null ) ; </a> 0
<a> expect ( buf . getByte ( 13 ) ) . andReturn ( Byte . valueOf ( ( byte ) 14 ) ) ; </a> 0
<a> expect ( buf . getShort ( 15 ) ) . andReturn ( Short . valueOf ( ( short ) 16 ) ) ; </a> 0
<a> expect ( buf . getUnsignedMedium ( 17 ) ) . andReturn ( 18 ) ; </a> 0
<a> expect ( buf . getInt ( 19 ) ) . andReturn ( 20 ) ; </a> 0
<a> expect ( buf . getLong ( 21 ) ) . andReturn ( 22L ) ; </a> 0
<a> ByteBuffer bb = ByteBuffer . allocate ( 100 ) ; </a> 0
<a> expect ( buf . nioBuffer ( 23 , 24 ) ) . andReturn ( bb ) ; </a> 0
<a> expect ( buf . capacity ( ) ) . andReturn ( 27 ) ; </a> 0
<a> replay ( buf ) ; </a> 0
<a> ByteBuf roBuf = unmodifiableBuffer ( buf ) ; </a> 0
<a> assertEquals ( 3 , roBuf . getBytes ( 1 , ( GatheringByteChannel ) null , 2 ) ) ; </a> 0
<a> roBuf . getBytes ( 4 , ( OutputStream ) null , 5 ) ; </a> 0
<a> roBuf . getBytes ( 6 , ( byte [ ] ) null , 7 , 8 ) ; </a> 0
<a> roBuf . getBytes ( 9 , ( ByteBuf ) null , 10 , 11 ) ; </a> 0
<a> roBuf . getBytes ( 12 , ( ByteBuffer ) null ) ; </a> 0
<a> assertEquals ( ( byte ) 14 , roBuf . getByte ( 13 ) ) ; </a> 0
<a> assertEquals ( ( short ) 16 , roBuf . getShort ( 15 ) ) ; </a> 0
<a> assertEquals ( 18 , roBuf . getUnsignedMedium ( 17 ) ) ; </a> 0
<a> assertEquals ( 20 , roBuf . getInt ( 19 ) ) ; </a> 0
<a> assertEquals ( 22L , roBuf . getLong ( 21 ) ) ; </a> 0
<a> ByteBuffer roBB = roBuf . nioBuffer ( 23 , 24 ) ; </a> 0
<a> assertEquals ( 100 , roBB . capacity ( ) ) ; </a> 0
<a> assertTrue ( roBB . isReadOnly ( ) ) ; </a> 0
<a> assertEquals ( 27 , roBuf . capacity ( ) ) ; </a> 0
<a> verify ( buf ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = UnsupportedOperationException . class ) </a> 0
<a> public void shouldRejectDiscardReadBytes ( ) { </a> 0
<a> unmodifiableBuffer ( EMPTY_BUFFER ) . discardReadBytes ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = UnsupportedOperationException . class ) </a> 0
<a> public void shouldRejectSetByte ( ) { </a> 0
<a> unmodifiableBuffer ( EMPTY_BUFFER ) . setByte ( 0 , ( byte ) 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = UnsupportedOperationException . class ) </a> 0
<a> public void shouldRejectSetShort ( ) { </a> 0
<a> unmodifiableBuffer ( EMPTY_BUFFER ) . setShort ( 0 , ( short ) 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = UnsupportedOperationException . class ) </a> 0
<a> public void shouldRejectSetMedium ( ) { </a> 0
<a> unmodifiableBuffer ( EMPTY_BUFFER ) . setMedium ( 0 , 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = UnsupportedOperationException . class ) </a> 0
<a> public void shouldRejectSetInt ( ) { </a> 0
<a> unmodifiableBuffer ( EMPTY_BUFFER ) . setInt ( 0 , 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = UnsupportedOperationException . class ) </a> 0
<a> public void shouldRejectSetLong ( ) { </a> 0
<a> unmodifiableBuffer ( EMPTY_BUFFER ) . setLong ( 0 , 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = UnsupportedOperationException . class ) </a> 0
<a> public void shouldRejectSetBytes1 ( ) throws IOException { </a> 0
<a> unmodifiableBuffer ( EMPTY_BUFFER ) . setBytes ( 0 , ( InputStream ) null , 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = UnsupportedOperationException . class ) </a> 0
<a> public void shouldRejectSetBytes2 ( ) throws IOException { </a> 0
<a> unmodifiableBuffer ( EMPTY_BUFFER ) . setBytes ( 0 , ( ScatteringByteChannel ) null , 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = UnsupportedOperationException . class ) </a> 0
<a> public void shouldRejectSetBytes3 ( ) { </a> 0
<a> unmodifiableBuffer ( EMPTY_BUFFER ) . setBytes ( 0 , ( byte [ ] ) null , 0 , 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = UnsupportedOperationException . class ) </a> 0
<a> public void shouldRejectSetBytes4 ( ) { </a> 0
<a> unmodifiableBuffer ( EMPTY_BUFFER ) . setBytes ( 0 , ( ByteBuf ) null , 0 , 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = UnsupportedOperationException . class ) </a> 0
<a> public void shouldRejectSetBytes5 ( ) { </a> 0
<a> unmodifiableBuffer ( EMPTY_BUFFER ) . setBytes ( 0 , ( ByteBuffer ) null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . buffer ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import java . util . Random ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class SlicedChannelBufferTest extends AbstractChannelBufferTest { </a> 0
<a> private final Random random = new Random ( ) ; </a> 0
<a> private ByteBuf buffer ; </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf newBuffer ( int length ) { </a> 0
<a> buffer = Unpooled . wrappedBuffer ( </a> 0
<a> new byte [ length * 2 ] , random . nextInt ( length - 1 ) + 1 , length ) ; </a> 0
<a> assertEquals ( length , buffer . writerIndex ( ) ) ; </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf [ ] components ( ) { </a> 0
<a> return new ByteBuf [ ] { buffer } ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = NullPointerException . class ) </a> 0
<a> public void shouldNotAllowNullInConstructor ( ) { </a> 0
<a> new SlicedByteBuf ( null , 0 , 0 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import static io . netty . handler . codec . http . CookieEncoderUtil . * ; </a> 0
<a> public final class ClientCookieEncoder { </a> 0
<a> public static String encode ( String name , String value ) { </a> 0
<a> return encode ( new DefaultCookie ( name , value ) ) ; </a> 0
<a> } </a> 0
<a> public static String encode ( Cookie cookie ) { </a> 0
<a> if ( cookie == null ) { </a> 0
<a> throw new NullPointerException ( "cookie" ) ; </a> 0
<a> } </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 0
<a> encode ( buf , cookie ) ; </a> 0
<a> return stripTrailingSeparator ( buf ) ; </a> 0
<a> } </a> 0
<a> public static String encode ( Cookie ... cookies ) { </a> 0
<a> if ( cookies == null ) { </a> 0
<a> throw new NullPointerException ( "cookies" ) ; </a> 0
<a> } </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 0
<a> for ( Cookie c : cookies ) { </a> 0
<a> if ( c == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> encode ( buf , c ) ; </a> 0
<a> } </a> 0
<a> return stripTrailingSeparator ( buf ) ; </a> 0
<a> } </a> 0
<a> public static String encode ( Iterable < Cookie > cookies ) { </a> 0
<a> if ( cookies == null ) { </a> 0
<a> throw new NullPointerException ( "cookies" ) ; </a> 0
<a> } </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 0
<a> for ( Cookie c : cookies ) { </a> 0
<a> if ( c == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> encode ( buf , c ) ; </a> 0
<a> } </a> 0
<a> return stripTrailingSeparator ( buf ) ; </a> 0
<a> } </a> 0
<a> private static void encode ( StringBuilder buf , Cookie c ) { </a> 0
<a> if ( c . getVersion ( ) >= 1 ) { </a> 0
<a> add ( buf , '$' + CookieHeaderNames . VERSION , 1 ) ; </a> 0
<a> } </a> 0
<a> add ( buf , c . getName ( ) , c . getValue ( ) ) ; </a> 0
<a> if ( c . getPath ( ) != null ) { </a> 0
<a> add ( buf , '$' + CookieHeaderNames . PATH , c . getPath ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( c . getDomain ( ) != null ) { </a> 0
<a> add ( buf , '$' + CookieHeaderNames . DOMAIN , c . getDomain ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( c . getVersion ( ) >= 1 ) { </a> 0
<a> if ( ! c . getPorts ( ) . isEmpty ( ) ) { </a> 0
<a> buf . append ( '$' ) ; </a> 0
<a> buf . append ( CookieHeaderNames . PORT ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . EQUALS ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . DOUBLE_QUOTE ) ; </a> 0
<a> for ( int port : c . getPorts ( ) ) { </a> 0
<a> buf . append ( port ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . COMMA ) ; </a> 0
<a> } </a> 0
<a> buf . setCharAt ( buf . length ( ) - 1 , ( char ) HttpConstants . DOUBLE_QUOTE ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . SEMICOLON ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . SP ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private ClientCookieEncoder ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import java . text . ParseException ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . TreeSet ; </a> 0
<a> public final class CookieDecoder { </a> 0
<a> private static final String COMMA = "," ; </a> 0
<a> public static Set < Cookie > decode ( String header ) { </a> 0
<a> List < String > names = new ArrayList < String > ( 8 ) ; </a> 0
<a> List < String > values = new ArrayList < String > ( 8 ) ; </a> 0
<a> extractKeyValuePairs ( header , names , values ) ; </a> 0
<a> if ( names . isEmpty ( ) ) { </a> 0
<a> return Collections . emptySet ( ) ; </a> 0
<a> } </a> 0
<a> int i ; </a> 0
<a> int version = 0 ; </a> 0
<a> if ( names . get ( 0 ) . equalsIgnoreCase ( CookieHeaderNames . VERSION ) ) { </a> 0
<a> try { </a> 0
<a> version = Integer . parseInt ( values . get ( 0 ) ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> } </a> 0
<a> i = 1 ; </a> 0
<a> } else { </a> 0
<a> i = 0 ; </a> 0
<a> } </a> 0
<a> if ( names . size ( ) <= i ) { </a> 0
<a> return Collections . emptySet ( ) ; </a> 0
<a> } </a> 0
<a> Set < Cookie > cookies = new TreeSet < Cookie > ( ) ; </a> 0
<a> for ( ; i < names . size ( ) ; i ++ ) { </a> 0
<a> String name = names . get ( i ) ; </a> 0
<a> String value = values . get ( i ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> value = "" ; </a> 0
<a> } </a> 0
<a> Cookie c = new DefaultCookie ( name , value ) ; </a> 0
<a> boolean discard = false ; </a> 0
<a> boolean secure = false ; </a> 0
<a> boolean httpOnly = false ; </a> 0
<a> String comment = null ; </a> 0
<a> String commentURL = null ; </a> 0
<a> String domain = null ; </a> 0
<a> String path = null ; </a> 0
<a> long maxAge = Long . MIN_VALUE ; </a> 0
<a> List < Integer > ports = new ArrayList < Integer > ( 2 ) ; </a> 0
<a> for ( int j = i + 1 ; j < names . size ( ) ; j ++ , i ++ ) { </a> 0
<a> name = names . get ( j ) ; </a> 0
<a> value = values . get ( j ) ; </a> 0
<a> if ( CookieHeaderNames . DISCARD . equalsIgnoreCase ( name ) ) { </a> 0
<a> discard = true ; </a> 0
<a> } else if ( CookieHeaderNames . SECURE . equalsIgnoreCase ( name ) ) { </a> 0
<a> secure = true ; </a> 0
<a> } else if ( CookieHeaderNames . HTTPONLY . equalsIgnoreCase ( name ) ) { </a> 0
<a> httpOnly = true ; </a> 0
<a> } else if ( CookieHeaderNames . COMMENT . equalsIgnoreCase ( name ) ) { </a> 0
<a> comment = value ; </a> 0
<a> } else if ( CookieHeaderNames . COMMENTURL . equalsIgnoreCase ( name ) ) { </a> 0
<a> commentURL = value ; </a> 0
<a> } else if ( CookieHeaderNames . DOMAIN . equalsIgnoreCase ( name ) ) { </a> 0
<a> domain = value ; </a> 0
<a> } else if ( CookieHeaderNames . PATH . equalsIgnoreCase ( name ) ) { </a> 0
<a> path = value ; </a> 0
<a> } else if ( CookieHeaderNames . EXPIRES . equalsIgnoreCase ( name ) ) { </a> 0
<a> try { </a> 0
<a> long maxAgeMillis = </a> 0
<a> new HttpHeaderDateFormat ( ) . parse ( value ) . getTime ( ) - </a> 0
<a> System . currentTimeMillis ( ) ; </a> 0
<a> if ( maxAgeMillis <= 0 ) { </a> 1
<a> maxAge = 0 ; </a> 1
<a> } else { </a> 1
<a> maxAge = maxAgeMillis / 1000 + ( maxAgeMillis % 1000 != 0 ? 1 : 0 ) ; </a> 0
<a> } </a> 1
<a> } catch ( ParseException e ) { </a> 0
<a> } </a> 0
<a> } else if ( CookieHeaderNames . MAX_AGE . equalsIgnoreCase ( name ) ) { </a> 0
<a> maxAge = Integer . parseInt ( value ) ; </a> 0
<a> } else if ( CookieHeaderNames . VERSION . equalsIgnoreCase ( name ) ) { </a> 0
<a> version = Integer . parseInt ( value ) ; </a> 0
<a> } else if ( CookieHeaderNames . PORT . equalsIgnoreCase ( name ) ) { </a> 0
<a> String [ ] portList = value . split ( COMMA ) ; </a> 0
<a> for ( String s1 : portList ) { </a> 0
<a> try { </a> 0
<a> ports . add ( Integer . valueOf ( s1 ) ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> c . setVersion ( version ) ; </a> 0
<a> c . setMaxAge ( maxAge ) ; </a> 0
<a> c . setPath ( path ) ; </a> 0
<a> c . setDomain ( domain ) ; </a> 0
<a> c . setSecure ( secure ) ; </a> 0
<a> c . setHttpOnly ( httpOnly ) ; </a> 0
<a> if ( version > 0 ) { </a> 0
<a> c . setComment ( comment ) ; </a> 0
<a> } </a> 0
<a> if ( version > 1 ) { </a> 0
<a> c . setCommentUrl ( commentURL ) ; </a> 0
<a> c . setPorts ( ports ) ; </a> 0
<a> c . setDiscard ( discard ) ; </a> 0
<a> } </a> 0
<a> cookies . add ( c ) ; </a> 0
<a> } </a> 0
<a> return cookies ; </a> 0
<a> } </a> 0
<a> private static void extractKeyValuePairs ( </a> 0
<a> final String header , final List < String > names , final List < String > values ) { </a> 0
<a> final int headerLen = header . length ( ) ; </a> 0
<a> loop : for ( int i = 0 ; ; ) { </a> 0
<a> for ( ; ; ) { </a> 0
<a> if ( i == headerLen ) { </a> 0
<a> break loop ; </a> 0
<a> } </a> 0
<a> switch ( header . charAt ( i ) ) { </a> 0
<a> case '\t' : case '\n' : case 0x0b : case '\f' : case '\r' : </a> 0
<a> case ' ' : case ',' : case ';' : </a> 0
<a> i ++ ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> for ( ; ; ) { </a> 0
<a> if ( i == headerLen ) { </a> 0
<a> break loop ; </a> 0
<a> } </a> 0
<a> if ( header . charAt ( i ) == '$' ) { </a> 0
<a> i ++ ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> String name ; </a> 0
<a> String value ; </a> 0
<a> if ( i == headerLen ) { </a> 0
<a> name = null ; </a> 0
<a> value = null ; </a> 0
<a> } else { </a> 0
<a> int newNameStart = i ; </a> 0
<a> keyValLoop : for ( ; ; ) { </a> 0
<a> switch ( header . charAt ( i ) ) { </a> 0
<a> case ';' : </a> 0
<a> name = header . substring ( newNameStart , i ) ; </a> 0
<a> value = null ; </a> 0
<a> break keyValLoop ; </a> 0
<a> case '=' : </a> 0
<a> name = header . substring ( newNameStart , i ) ; </a> 0
<a> i ++ ; </a> 0
<a> if ( i == headerLen ) { </a> 0
<a> value = "" ; </a> 0
<a> break keyValLoop ; </a> 0
<a> } </a> 0
<a> int newValueStart = i ; </a> 0
<a> char c = header . charAt ( i ) ; </a> 0
<a> if ( c == '"' || c == '\'' ) { </a> 0
<a> StringBuilder newValueBuf = new StringBuilder ( header . length ( ) - i ) ; </a> 0
<a> final char q = c ; </a> 0
<a> boolean hadBackslash = false ; </a> 0
<a> i ++ ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> if ( i == headerLen ) { </a> 0
<a> value = newValueBuf . toString ( ) ; </a> 0
<a> break keyValLoop ; </a> 0
<a> } </a> 0
<a> if ( hadBackslash ) { </a> 0
<a> hadBackslash = false ; </a> 0
<a> c = header . charAt ( i ++ ) ; </a> 0
<a> switch ( c ) { </a> 0
<a> case '\\' : case '"' : case '\'' : </a> 0
<a> newValueBuf . setCharAt ( newValueBuf . length ( ) - 1 , c ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> newValueBuf . append ( c ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> c = header . charAt ( i ++ ) ; </a> 0
<a> if ( c == q ) { </a> 0
<a> value = newValueBuf . toString ( ) ; </a> 0
<a> break keyValLoop ; </a> 0
<a> } </a> 0
<a> newValueBuf . append ( c ) ; </a> 0
<a> if ( c == '\\' ) { </a> 0
<a> hadBackslash = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> int semiPos = header . indexOf ( ';' , i ) ; </a> 0
<a> if ( semiPos > 0 ) { </a> 0
<a> value = header . substring ( newValueStart , semiPos ) ; </a> 0
<a> i = semiPos ; </a> 0
<a> } else { </a> 0
<a> value = header . substring ( newValueStart ) ; </a> 0
<a> i = headerLen ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> break keyValLoop ; </a> 0
<a> default : </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> if ( i == headerLen ) { </a> 0
<a> name = header . substring ( newNameStart ) ; </a> 0
<a> value = null ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> names . add ( name ) ; </a> 0
<a> values . add ( value ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private CookieDecoder ( ) { </a> 0
<a> } </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> final class CookieEncoderUtil { </a> 0
<a> static String stripTrailingSeparator ( StringBuilder buf ) { </a> 0
<a> if ( buf . length ( ) > 0 ) { </a> 0
<a> buf . setLength ( buf . length ( ) - 2 ) ; </a> 0
<a> } </a> 0
<a> return buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> static void add ( StringBuilder sb , String name , String val ) { </a> 0
<a> if ( val == null ) { </a> 0
<a> addQuoted ( sb , name , "" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < val . length ( ) ; i ++ ) { </a> 0
<a> char c = val . charAt ( i ) ; </a> 0
<a> switch ( c ) { </a> 0
<a> case '\t' : case ' ' : case '"' : case '(' : case ')' : case ',' : </a> 0
<a> case '/' : case ':' : case ';' : case '<' : case '=' : case '>' : </a> 0
<a> case '?' : case '@' : case '[' : case '\\' : case ']' : </a> 0
<a> case '{' : case '}' : </a> 0
<a> addQuoted ( sb , name , val ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> addUnquoted ( sb , name , val ) ; </a> 0
<a> } </a> 0
<a> static void addUnquoted ( StringBuilder sb , String name , String val ) { </a> 0
<a> sb . append ( name ) ; </a> 0
<a> sb . append ( ( char ) HttpConstants . EQUALS ) ; </a> 0
<a> sb . append ( val ) ; </a> 0
<a> sb . append ( ( char ) HttpConstants . SEMICOLON ) ; </a> 0
<a> sb . append ( ( char ) HttpConstants . SP ) ; </a> 0
<a> } </a> 0
<a> static void addQuoted ( StringBuilder sb , String name , String val ) { </a> 0
<a> if ( val == null ) { </a> 0
<a> val = "" ; </a> 0
<a> } </a> 0
<a> sb . append ( name ) ; </a> 0
<a> sb . append ( ( char ) HttpConstants . EQUALS ) ; </a> 0
<a> sb . append ( ( char ) HttpConstants . DOUBLE_QUOTE ) ; </a> 0
<a> sb . append ( val . replace ( "\\" , "\\\\" ) . replace ( "\"" , "\\\"" ) ) ; </a> 0
<a> sb . append ( ( char ) HttpConstants . DOUBLE_QUOTE ) ; </a> 0
<a> sb . append ( ( char ) HttpConstants . SEMICOLON ) ; </a> 0
<a> sb . append ( ( char ) HttpConstants . SP ) ; </a> 0
<a> } </a> 0
<a> static void add ( StringBuilder sb , String name , long val ) { </a> 0
<a> sb . append ( name ) ; </a> 0
<a> sb . append ( ( char ) HttpConstants . EQUALS ) ; </a> 0
<a> sb . append ( val ) ; </a> 0
<a> sb . append ( ( char ) HttpConstants . SEMICOLON ) ; </a> 0
<a> sb . append ( ( char ) HttpConstants . SP ) ; </a> 0
<a> } </a> 0
<a> private CookieEncoderUtil ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> final class CookieHeaderNames { </a> 1
<a> static final String PATH = "Path" ; </a> 1
<a> static final String EXPIRES = "Expires" ; </a> 1
<a> static final String MAX_AGE = "Max-Age" ; </a> 1
<a> static final String DOMAIN = "Domain" ; </a> 1
<a> static final String SECURE = "Secure" ; </a> 1
<a> static final String HTTPONLY = "HTTPOnly" ; </a> 1
<a> static final String COMMENT = "Comment" ; </a> 1
<a> static final String COMMENTURL = "CommentURL" ; </a> 1
<a> static final String DISCARD = "Discard" ; </a> 1
<a> static final String PORT = "Port" ; </a> 1
<a> static final String VERSION = "Version" ; </a> 1
<a> private CookieHeaderNames ( ) { </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import java . util . Collections ; </a> 1
<a> import java . util . Set ; </a> 1
<a> import java . util . TreeSet ; </a> 1
<a> public class DefaultCookie implements Cookie { </a> 1
<a> private final String name ; </a> 1
<a> private String value ; </a> 1
<a> private String domain ; </a> 1
<a> private String path ; </a> 1
<a> private String comment ; </a> 1
<a> private String commentUrl ; </a> 1
<a> private boolean discard ; </a> 1
<a> private Set < Integer > ports = Collections . emptySet ( ) ; </a> 1
<a> private Set < Integer > unmodifiablePorts = ports ; </a> 1
<a> private long maxAge = Long . MIN_VALUE ; </a> 1
<a> private int version ; </a> 1
<a> private boolean secure ; </a> 1
<a> private boolean httpOnly ; </a> 1
<a> public DefaultCookie ( String name , String value ) { </a> 1
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> name = name . trim ( ) ; </a> 1
<a> if ( name . length ( ) == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "empty name" ) ; </a> 1
<a> } </a> 1
<a> for ( int i = 0 ; i < name . length ( ) ; i ++ ) { </a> 1
<a> char c = name . charAt ( i ) ; </a> 1
<a> if ( c > 127 ) { </a> 1
<a> throw new IllegalArgumentException ( </a> 1
<a> "name contains non-ascii character: " + name ) ; </a> 1
<a> } </a> 1
<a> switch ( c ) { </a> 1
<a> case '\t' : case '\n' : case 0x0b : case '\f' : case '\r' : </a> 1
<a> case ' ' : case ',' : case ';' : case '=' : </a> 1
<a> throw new IllegalArgumentException ( </a> 1
<a> "name contains one of the following prohibited characters: " + </a> 1
<a> "=,; \\t\\r\\n\\v\\f: " + name ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> if ( name . charAt ( 0 ) == '$' ) { </a> 0
<a> throw new IllegalArgumentException ( "name starting with '$' not allowed: " + name ) ; </a> 0
<a> } </a> 1
<a> this . name = name ; </a> 1
<a> setValue ( value ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getName ( ) { </a> 0
<a> return name ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getValue ( ) { </a> 0
<a> return value ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setValue ( String value ) { </a> 1
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( "value" ) ; </a> 0
<a> } </a> 0
<a> this . value = value ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getDomain ( ) { </a> 0
<a> return domain ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setDomain ( String domain ) { </a> 1
<a> this . domain = validateValue ( "domain" , domain ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getPath ( ) { </a> 0
<a> return path ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setPath ( String path ) { </a> 1
<a> this . path = validateValue ( "path" , path ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getComment ( ) { </a> 0
<a> return comment ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setComment ( String comment ) { </a> 1
<a> this . comment = validateValue ( "comment" , comment ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getCommentUrl ( ) { </a> 0
<a> return commentUrl ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setCommentUrl ( String commentUrl ) { </a> 1
<a> this . commentUrl = validateValue ( "commentUrl" , commentUrl ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isDiscard ( ) { </a> 1
<a> return discard ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setDiscard ( boolean discard ) { </a> 1
<a> this . discard = discard ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public Set < Integer > getPorts ( ) { </a> 0
<a> if ( unmodifiablePorts == null ) { </a> 1
<a> unmodifiablePorts = Collections . unmodifiableSet ( ports ) ; </a> 1
<a> } </a> 1
<a> return unmodifiablePorts ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setPorts ( int ... ports ) { </a> 1
<a> if ( ports == null ) { </a> 1
<a> throw new NullPointerException ( "ports" ) ; </a> 1
<a> } </a> 1
<a> int [ ] portsCopy = ports . clone ( ) ; </a> 1
<a> if ( portsCopy . length == 0 ) { </a> 1
<a> unmodifiablePorts = this . ports = Collections . emptySet ( ) ; </a> 1
<a> } else { </a> 1
<a> Set < Integer > newPorts = new TreeSet < Integer > ( ) ; </a> 1
<a> for ( int p : portsCopy ) { </a> 1
<a> if ( p <= 0 || p > 65535 ) { </a> 1
<a> throw new IllegalArgumentException ( "port out of range: " + p ) ; </a> 1
<a> } </a> 1
<a> newPorts . add ( Integer . valueOf ( p ) ) ; </a> 1
<a> } </a> 1
<a> this . ports = newPorts ; </a> 1
<a> unmodifiablePorts = null ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setPorts ( Iterable < Integer > ports ) { </a> 1
<a> Set < Integer > newPorts = new TreeSet < Integer > ( ) ; </a> 1
<a> for ( int p : ports ) { </a> 1
<a> if ( p <= 0 || p > 65535 ) { </a> 0
<a> throw new IllegalArgumentException ( "port out of range: " + p ) ; </a> 0
<a> } </a> 0
<a> newPorts . add ( Integer . valueOf ( p ) ) ; </a> 1
<a> } </a> 1
<a> if ( newPorts . isEmpty ( ) ) { </a> 1
<a> unmodifiablePorts = this . ports = Collections . emptySet ( ) ; </a> 1
<a> } else { </a> 1
<a> this . ports = newPorts ; </a> 1
<a> unmodifiablePorts = null ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public long getMaxAge ( ) { </a> 0
<a> return maxAge ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setMaxAge ( long maxAge ) { </a> 1
<a> this . maxAge = maxAge ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getVersion ( ) { </a> 0
<a> return version ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setVersion ( int version ) { </a> 1
<a> this . version = version ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isSecure ( ) { </a> 1
<a> return secure ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setSecure ( boolean secure ) { </a> 1
<a> this . secure = secure ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isHttpOnly ( ) { </a> 1
<a> return httpOnly ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setHttpOnly ( boolean httpOnly ) { </a> 1
<a> this . httpOnly = httpOnly ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int hashCode ( ) { </a> 1
<a> return getName ( ) . hashCode ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean equals ( Object o ) { </a> 1
<a> if ( ! ( o instanceof Cookie ) ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> Cookie that = ( Cookie ) o ; </a> 1
<a> if ( ! getName ( ) . equalsIgnoreCase ( that . getName ( ) ) ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> if ( getPath ( ) == null ) { </a> 1
<a> if ( that . getPath ( ) != null ) { </a> 1
<a> return false ; </a> 0
<a> } </a> 0
<a> } else if ( that . getPath ( ) == null ) { </a> 1
<a> return false ; </a> 1
<a> } else if ( ! getPath ( ) . equals ( that . getPath ( ) ) ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> if ( getDomain ( ) == null ) { </a> 1
<a> if ( that . getDomain ( ) != null ) { </a> 1
<a> return false ; </a> 0
<a> } </a> 0
<a> } else if ( that . getDomain ( ) == null ) { </a> 1
<a> return false ; </a> 1
<a> } else { </a> 1
<a> return getDomain ( ) . equalsIgnoreCase ( that . getDomain ( ) ) ; </a> 0
<a> } </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int compareTo ( Cookie c ) { </a> 1
<a> int v ; </a> 1
<a> v = getName ( ) . compareToIgnoreCase ( c . getName ( ) ) ; </a> 1
<a> if ( v != 0 ) { </a> 1
<a> return v ; </a> 1
<a> } </a> 1
<a> if ( getPath ( ) == null ) { </a> 1
<a> if ( c . getPath ( ) != null ) { </a> 1
<a> return - 1 ; </a> 1
<a> } </a> 0
<a> } else if ( c . getPath ( ) == null ) { </a> 1
<a> return 1 ; </a> 1
<a> } else { </a> 1
<a> v = getPath ( ) . compareTo ( c . getPath ( ) ) ; </a> 1
<a> if ( v != 0 ) { </a> 1
<a> return v ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> if ( getDomain ( ) == null ) { </a> 1
<a> if ( c . getDomain ( ) != null ) { </a> 1
<a> return - 1 ; </a> 1
<a> } </a> 0
<a> } else if ( c . getDomain ( ) == null ) { </a> 1
<a> return 1 ; </a> 1
<a> } else { </a> 1
<a> v = getDomain ( ) . compareToIgnoreCase ( c . getDomain ( ) ) ; </a> 1
<a> return v ; </a> 1
<a> } </a> 1
<a> return 0 ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String toString ( ) { </a> 1
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getName ( ) ) ; </a> 1
<a> buf . append ( '=' ) ; </a> 1
<a> buf . append ( getValue ( ) ) ; </a> 1
<a> if ( getDomain ( ) != null ) { </a> 1
<a> buf . append ( ", domain=" ) ; </a> 1
<a> buf . append ( getDomain ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( getPath ( ) != null ) { </a> 1
<a> buf . append ( ", path=" ) ; </a> 1
<a> buf . append ( getPath ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( getComment ( ) != null ) { </a> 1
<a> buf . append ( ", comment=" ) ; </a> 1
<a> buf . append ( getComment ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( getMaxAge ( ) >= 0 ) { </a> 1
<a> buf . append ( ", maxAge=" ) ; </a> 1
<a> buf . append ( getMaxAge ( ) ) ; </a> 1
<a> buf . append ( 's' ) ; </a> 1
<a> } </a> 1
<a> if ( isSecure ( ) ) { </a> 1
<a> buf . append ( ", secure" ) ; </a> 1
<a> } </a> 1
<a> if ( isHttpOnly ( ) ) { </a> 1
<a> buf . append ( ", HTTPOnly" ) ; </a> 1
<a> } </a> 1
<a> return buf . toString ( ) ; </a> 1
<a> } </a> 1
<a> private static String validateValue ( String name , String value ) { </a> 1
<a> if ( value == null ) { </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> value = value . trim ( ) ; </a> 1
<a> if ( value . length ( ) == 0 ) { </a> 0
<a> return null ; </a> 1
<a> } </a> 1
<a> for ( int i = 0 ; i < value . length ( ) ; i ++ ) { </a> 1
<a> char c = value . charAt ( i ) ; </a> 1
<a> switch ( c ) { </a> 1
<a> case '\r' : case '\n' : case '\f' : case 0x0b : case ';' : </a> 1
<a> throw new IllegalArgumentException ( </a> 1
<a> name + " contains one of the following prohibited characters: " + </a> 1
<a> ";\\r\\n\\f\\v (" + value + ')' ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return value ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import java . util . List ; </a> 1
<a> import java . util . Map ; </a> 0
<a> import java . util . Set ; </a> 1
<a> public class DefaultHttpChunkTrailer implements HttpChunkTrailer { </a> 0
<a> private final HttpHeaders headers = new HttpHeaders ( ) { </a> 1
<a> @ Override </a> 0
<a> void validateHeaderName ( String name ) { </a> 0
<a> super . validateHeaderName ( name ) ; </a> 0
<a> if ( name . equalsIgnoreCase ( HttpHeaders . Names . CONTENT_LENGTH ) || </a> 0
<a> name . equalsIgnoreCase ( HttpHeaders . Names . TRANSFER_ENCODING ) || </a> 0
<a> name . equalsIgnoreCase ( HttpHeaders . Names . TRAILER ) ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "prohibited trailing header: " + name ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> @ Override </a> 0
<a> public boolean isLast ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void addHeader ( final String name , final Object value ) { </a> 1
<a> headers . addHeader ( name , value ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setHeader ( final String name , final Object value ) { </a> 1
<a> headers . setHeader ( name , value ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setHeader ( final String name , final Iterable < ? > values ) { </a> 1
<a> headers . setHeader ( name , values ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void removeHeader ( final String name ) { </a> 1
<a> headers . removeHeader ( name ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void clearHeaders ( ) { </a> 1
<a> headers . clearHeaders ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public String getHeader ( final String name ) { </a> 1
<a> return headers . getHeader ( name ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public List < String > getHeaders ( final String name ) { </a> 1
<a> return headers . getHeaders ( name ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public List < Map . Entry < String , String > > getHeaders ( ) { </a> 1
<a> return headers . getHeaders ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean containsHeader ( final String name ) { </a> 1
<a> return headers . containsHeader ( name ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public Set < String > getHeaderNames ( ) { </a> 1
<a> return headers . getHeaderNames ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf getContent ( ) { </a> 0
<a> return Unpooled . EMPTY_BUFFER ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setContent ( ByteBuf content ) { </a> 0
<a> throw new IllegalStateException ( "read-only" ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . util . internal . StringUtil ; </a> 1
<a> public class DefaultHttpResponse extends DefaultHttpMessage implements HttpResponse { </a> 0
<a> private HttpResponseStatus status ; </a> 1
<a> public DefaultHttpResponse ( HttpVersion version , HttpResponseStatus status ) { </a> 0
<a> super ( version ) ; </a> 1
<a> setStatus ( status ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public HttpResponseStatus getStatus ( ) { </a> 1
<a> return status ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setStatus ( HttpResponseStatus status ) { </a> 1
<a> if ( status == null ) { </a> 0
<a> throw new NullPointerException ( "status" ) ; </a> 0
<a> } </a> 0
<a> this . status = status ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public String toString ( ) { </a> 1
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 1
<a> buf . append ( "(transferEncoding: " ) ; </a> 0
<a> buf . append ( getTransferEncoding ( ) ) ; </a> 0
<a> buf . append ( ')' ) ; </a> 1
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( getProtocolVersion ( ) . getText ( ) ) ; </a> 1
<a> buf . append ( ' ' ) ; </a> 1
<a> buf . append ( getStatus ( ) . toString ( ) ) ; </a> 1
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> appendHeaders ( buf ) ; </a> 1
<a> buf . setLength ( buf . length ( ) - StringUtil . NEWLINE . length ( ) ) ; </a> 1
<a> return buf . toString ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import java . util . Collections ; </a> 1
<a> import java . util . List ; </a> 1
<a> import java . util . Map ; </a> 1
<a> import java . util . Set ; </a> 1
<a> public interface HttpChunk { </a> 0
<a> HttpChunkTrailer LAST_CHUNK = new HttpChunkTrailer ( ) { </a> 0
<a> @ Override </a> 1
<a> public ByteBuf getContent ( ) { </a> 1
<a> return Unpooled . EMPTY_BUFFER ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setContent ( ByteBuf content ) { </a> 1
<a> throw new IllegalStateException ( "read-only" ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> public boolean isLast ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void addHeader ( String name , Object value ) { </a> 1
<a> throw new IllegalStateException ( "read-only" ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void clearHeaders ( ) { </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean containsHeader ( String name ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public String getHeader ( String name ) { </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public Set < String > getHeaderNames ( ) { </a> 1
<a> return Collections . emptySet ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public List < String > getHeaders ( String name ) { </a> 1
<a> return Collections . emptyList ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public List < Map . Entry < String , String > > getHeaders ( ) { </a> 1
<a> return Collections . emptyList ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void removeHeader ( String name ) { </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setHeader ( String name , Object value ) { </a> 1
<a> throw new IllegalStateException ( "read-only" ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setHeader ( String name , Iterable < ? > values ) { </a> 1
<a> throw new IllegalStateException ( "read-only" ) ; </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> boolean isLast ( ) ; </a> 0
<a> ByteBuf getContent ( ) ; </a> 1
<a> void setContent ( ByteBuf content ) ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . CompositeByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . MessageToMessageDecoder ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 1
<a> import java . util . Map . Entry ; </a> 0
<a> public class HttpChunkAggregator extends MessageToMessageDecoder < Object , HttpMessage > { </a> 0
<a> public static final int DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS = 1024 ; </a> 0
<a> private static final ByteBuf CONTINUE = Unpooled . copiedBuffer ( </a> 0
<a> "HTTP/1.1 100 Continue\r\n\r\n" , CharsetUtil . US_ASCII ) ; </a> 0
<a> private final int maxContentLength ; </a> 0
<a> private HttpMessage currentMessage ; </a> 1
<a> private int maxCumulationBufferComponents = DEFAULT_MAX_COMPOSITEBUFFER_COMPONENTS ; </a> 0
<a> private ChannelHandlerContext ctx ; </a> 0
<a> public HttpChunkAggregator ( int maxContentLength ) { </a> 0
<a> if ( maxContentLength <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxContentLength must be a positive integer: " + </a> 0
<a> maxContentLength ) ; </a> 0
<a> } </a> 0
<a> this . maxContentLength = maxContentLength ; </a> 0
<a> } </a> 0
<a> public final int getMaxCumulationBufferComponents ( ) { </a> 0
<a> return maxCumulationBufferComponents ; </a> 0
<a> } </a> 0
<a> public final void setMaxCumulationBufferComponents ( int maxCumulationBufferComponents ) { </a> 0
<a> if ( maxCumulationBufferComponents < 2 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxCumulationBufferComponents: " + maxCumulationBufferComponents + </a> 0
<a> " (expected: >= 2)" ) ; </a> 0
<a> } </a> 0
<a> if ( ctx == null ) { </a> 0
<a> this . maxCumulationBufferComponents = maxCumulationBufferComponents ; </a> 0
<a> } else { </a> 0
<a> throw new IllegalStateException ( </a> 0
<a> "decoder properties cannot be changed once the decoder is added to a pipeline." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDecodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof HttpMessage || msg instanceof HttpChunk ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public HttpMessage decode ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 0
<a> HttpMessage currentMessage = this . currentMessage ; </a> 0
<a> if ( msg instanceof HttpMessage ) { </a> 0
<a> HttpMessage m = ( HttpMessage ) msg ; </a> 0
<a> if ( is100ContinueExpected ( m ) ) { </a> 0
<a> ctx . write ( CONTINUE . duplicate ( ) ) ; </a> 1
<a> } </a> 0
<a> switch ( m . getTransferEncoding ( ) ) { </a> 0
<a> case SINGLE : </a> 0
<a> this . currentMessage = null ; </a> 0
<a> return m ; </a> 0
<a> case STREAMED : </a> 0
<a> case CHUNKED : </a> 0
<a> m . setTransferEncoding ( HttpTransferEncoding . SINGLE ) ; </a> 0
<a> m . setContent ( Unpooled . compositeBuffer ( maxCumulationBufferComponents ) ) ; </a> 0
<a> this . currentMessage = m ; </a> 0
<a> return null ; </a> 1
<a> default : </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof HttpChunk ) { </a> 0
<a> if ( currentMessage == null ) { </a> 1
<a> throw new IllegalStateException ( </a> 1
<a> "received " + HttpChunk . class . getSimpleName ( ) + </a> 0
<a> " without " + HttpMessage . class . getSimpleName ( ) + </a> 0
<a> " or last message's transfer encoding was 'SINGLE'" ) ; </a> 1
<a> } </a> 1
<a> HttpChunk chunk = ( HttpChunk ) msg ; </a> 0
<a> ByteBuf content = currentMessage . getContent ( ) ; </a> 1
<a> if ( content . readableBytes ( ) > maxContentLength - chunk . getContent ( ) . readableBytes ( ) ) { </a> 1
<a> throw new TooLongFrameException ( </a> 0
<a> "HTTP content length exceeded " + maxContentLength + </a> 0
<a> " bytes." ) ; </a> 0
<a> } </a> 0
<a> appendToCumulation ( chunk . getContent ( ) ) ; </a> 0
<a> if ( chunk . isLast ( ) ) { </a> 0
<a> this . currentMessage = null ; </a> 0
<a> if ( chunk instanceof HttpChunkTrailer ) { </a> 0
<a> HttpChunkTrailer trailer = ( HttpChunkTrailer ) chunk ; </a> 0
<a> for ( Entry < String , String > header : trailer . getHeaders ( ) ) { </a> 1
<a> currentMessage . setHeader ( header . getKey ( ) , header . getValue ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> currentMessage . setHeader ( </a> 1
<a> HttpHeaders . Names . CONTENT_LENGTH , </a> 0
<a> String . valueOf ( content . readableBytes ( ) ) ) ; </a> 0
<a> return currentMessage ; </a> 1
<a> } else { </a> 1
<a> return null ; </a> 1
<a> } </a> 0
<a> } else { </a> 0
<a> throw new IllegalStateException ( </a> 1
<a> "Only " + HttpMessage . class . getSimpleName ( ) + " and " + </a> 0
<a> HttpChunk . class . getSimpleName ( ) + " are accepted: " + msg . getClass ( ) . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void appendToCumulation ( ByteBuf input ) { </a> 1
<a> CompositeByteBuf cumulation = ( CompositeByteBuf ) currentMessage . getContent ( ) ; </a> 1
<a> cumulation . addComponent ( input ) ; </a> 1
<a> cumulation . writerIndex ( cumulation . capacity ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> this . ctx = ctx ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . CombinedChannelHandler ; </a> 0
<a> import io . netty . handler . codec . PrematureChannelClosureException ; </a> 0
<a> import java . util . ArrayDeque ; </a> 0
<a> import java . util . Queue ; </a> 0
<a> import java . util . concurrent . atomic . AtomicLong ; </a> 0
<a> public class HttpClientCodec extends CombinedChannelHandler { </a> 0
<a> final Queue < HttpMethod > queue = new ArrayDeque < HttpMethod > ( ) ; </a> 0
<a> volatile boolean done ; </a> 0
<a> private final AtomicLong requestResponseCounter = new AtomicLong ( ) ; </a> 0
<a> private final boolean failOnMissingResponse ; </a> 0
<a> public HttpClientCodec ( ) { </a> 0
<a> this ( 4096 , 8192 , 8192 , false ) ; </a> 0
<a> } </a> 0
<a> public HttpClientCodec ( </a> 0
<a> int maxInitialLineLength , int maxHeaderSize , int maxChunkSize ) { </a> 0
<a> this ( maxInitialLineLength , maxHeaderSize , maxChunkSize , false ) ; </a> 0
<a> } </a> 0
<a> public HttpClientCodec ( </a> 0
<a> int maxInitialLineLength , int maxHeaderSize , int maxChunkSize , </a> 0
<a> boolean failOnMissingResponse ) { </a> 0
<a> init ( </a> 0
<a> new Decoder ( maxInitialLineLength , maxHeaderSize , maxChunkSize ) , </a> 0
<a> new Encoder ( ) ) ; </a> 0
<a> this . failOnMissingResponse = failOnMissingResponse ; </a> 0
<a> } </a> 0
<a> private final class Encoder extends HttpRequestEncoder { </a> 0
<a> @ Override </a> 0
<a> public void encode ( </a> 0
<a> ChannelHandlerContext ctx , Object msg , ByteBuf out ) throws Exception { </a> 0
<a> if ( msg instanceof HttpRequest && ! done ) { </a> 0
<a> queue . offer ( ( ( HttpRequest ) msg ) . getMethod ( ) ) ; </a> 0
<a> } </a> 0
<a> super . encode ( ctx , msg , out ) ; </a> 0
<a> if ( failOnMissingResponse ) { </a> 0
<a> if ( msg instanceof HttpRequest && ( ( HttpMessage ) msg ) . getTransferEncoding ( ) . isSingle ( ) ) { </a> 0
<a> requestResponseCounter . incrementAndGet ( ) ; </a> 0
<a> } else if ( msg instanceof HttpChunk && ( ( HttpChunk ) msg ) . isLast ( ) ) { </a> 0
<a> requestResponseCounter . incrementAndGet ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final class Decoder extends HttpResponseDecoder { </a> 0
<a> Decoder ( int maxInitialLineLength , int maxHeaderSize , int maxChunkSize ) { </a> 0
<a> super ( maxInitialLineLength , maxHeaderSize , maxChunkSize ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decode ( </a> 0
<a> ChannelHandlerContext ctx , ByteBuf buffer ) throws Exception { </a> 1
<a> if ( done ) { </a> 0
<a> return buffer . readBytes ( actualReadableBytes ( ) ) ; </a> 0
<a> } else { </a> 0
<a> Object msg = super . decode ( ctx , buffer ) ; </a> 1
<a> if ( failOnMissingResponse ) { </a> 0
<a> decrement ( msg ) ; </a> 1
<a> } </a> 0
<a> return msg ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private void decrement ( Object msg ) { </a> 0
<a> if ( msg == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( msg instanceof HttpMessage && ( ( HttpMessage ) msg ) . getTransferEncoding ( ) . isSingle ( ) ) { </a> 0
<a> requestResponseCounter . decrementAndGet ( ) ; </a> 0
<a> } else if ( msg instanceof HttpChunk && ( ( HttpChunk ) msg ) . isLast ( ) ) { </a> 0
<a> requestResponseCounter . decrementAndGet ( ) ; </a> 0
<a> } else if ( msg instanceof Object [ ] ) { </a> 1
<a> requestResponseCounter . decrementAndGet ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isContentAlwaysEmpty ( HttpMessage msg ) { </a> 0
<a> final int statusCode = ( ( HttpResponse ) msg ) . getStatus ( ) . getCode ( ) ; </a> 0
<a> if ( statusCode == 100 ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> HttpMethod method = queue . poll ( ) ; </a> 0
<a> char firstChar = method . getName ( ) . charAt ( 0 ) ; </a> 1
<a> switch ( firstChar ) { </a> 0
<a> case 'H' : </a> 0
<a> if ( HttpMethod . HEAD . equals ( method ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> case 'C' : </a> 0
<a> if ( statusCode == 200 ) { </a> 0
<a> if ( HttpMethod . CONNECT . equals ( method ) ) { </a> 0
<a> done = true ; </a> 0
<a> queue . clear ( ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> return super . isContentAlwaysEmpty ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) </a> 0
<a> throws Exception { </a> 0
<a> super . channelInactive ( ctx ) ; </a> 0
<a> if ( failOnMissingResponse ) { </a> 0
<a> long missingResponses = requestResponseCounter . get ( ) ; </a> 0
<a> if ( missingResponses > 0 ) { </a> 0
<a> ctx . fireExceptionCaught ( new PrematureChannelClosureException ( </a> 0
<a> "channel gone inactive with " + missingResponses + </a> 0
<a> " missing response(s)" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . nio . charset . Charset ; </a> 0
<a> public final class HttpConstants { </a> 0
<a> public static final byte SP = 32 ; </a> 0
<a> public static final byte HT = 9 ; </a> 0
<a> public static final byte CR = 13 ; </a> 0
<a> public static final byte EQUALS = 61 ; </a> 0
<a> public static final byte LF = 10 ; </a> 0
<a> public static final byte COLON = 58 ; </a> 0
<a> public static final byte SEMICOLON = 59 ; </a> 0
<a> public static final byte COMMA = 44 ; </a> 0
<a> public static final byte DOUBLE_QUOTE = '"' ; </a> 0
<a> public static final Charset DEFAULT_CHARSET = CharsetUtil . UTF_8 ; </a> 0
<a> private HttpConstants ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import io . netty . handler . codec . compression . ZlibCodecFactory ; </a> 0
<a> import io . netty . handler . codec . compression . ZlibWrapper ; </a> 0
<a> public class HttpContentCompressor extends HttpContentEncoder { </a> 0
<a> private final int compressionLevel ; </a> 0
<a> private final int windowBits ; </a> 0
<a> private final int memLevel ; </a> 0
<a> public HttpContentCompressor ( ) { </a> 0
<a> this ( 6 ) ; </a> 0
<a> } </a> 0
<a> public HttpContentCompressor ( int compressionLevel ) { </a> 0
<a> this ( compressionLevel , 15 , 8 ) ; </a> 0
<a> } </a> 0
<a> public HttpContentCompressor ( int compressionLevel , int windowBits , int memLevel ) { </a> 0
<a> if ( compressionLevel < 0 || compressionLevel > 9 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "compressionLevel: " + compressionLevel + </a> 0
<a> " (expected: 0-9)" ) ; </a> 0
<a> } </a> 0
<a> if ( windowBits < 9 || windowBits > 15 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "windowBits: " + windowBits + " (expected: 9-15)" ) ; </a> 0
<a> } </a> 0
<a> if ( memLevel < 1 || memLevel > 9 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "memLevel: " + memLevel + " (expected: 1-9)" ) ; </a> 0
<a> } </a> 0
<a> this . compressionLevel = compressionLevel ; </a> 0
<a> this . windowBits = windowBits ; </a> 0
<a> this . memLevel = memLevel ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected Result beginEncode ( HttpMessage msg , String acceptEncoding ) throws Exception { </a> 0
<a> String contentEncoding = msg . getHeader ( HttpHeaders . Names . CONTENT_ENCODING ) ; </a> 0
<a> if ( contentEncoding != null && </a> 0
<a> ! HttpHeaders . Values . IDENTITY . equalsIgnoreCase ( contentEncoding ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> ZlibWrapper wrapper = determineWrapper ( acceptEncoding ) ; </a> 0
<a> if ( wrapper == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> String targetContentEncoding ; </a> 0
<a> switch ( wrapper ) { </a> 0
<a> case GZIP : </a> 0
<a> targetContentEncoding = "gzip" ; </a> 0
<a> break ; </a> 0
<a> case ZLIB : </a> 0
<a> targetContentEncoding = "deflate" ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> return new Result ( </a> 0
<a> targetContentEncoding , </a> 0
<a> new EmbeddedByteChannel ( ZlibCodecFactory . newZlibEncoder ( </a> 0
<a> wrapper , compressionLevel , windowBits , memLevel ) ) ) ; </a> 0
<a> } </a> 0
<a> protected ZlibWrapper determineWrapper ( String acceptEncoding ) { </a> 0
<a> float starQ = - 1.0f ; </a> 0
<a> float gzipQ = - 1.0f ; </a> 0
<a> float deflateQ = - 1.0f ; </a> 0
<a> for ( String encoding : acceptEncoding . split ( "," ) ) { </a> 0
<a> float q = 1.0f ; </a> 0
<a> int equalsPos = encoding . indexOf ( '=' ) ; </a> 0
<a> if ( equalsPos != - 1 ) { </a> 0
<a> try { </a> 0
<a> q = Float . valueOf ( encoding . substring ( equalsPos + 1 ) ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> q = 0.0f ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( encoding . contains ( "*" ) ) { </a> 0
<a> starQ = q ; </a> 0
<a> } else if ( encoding . contains ( "gzip" ) && q > gzipQ ) { </a> 0
<a> gzipQ = q ; </a> 0
<a> } else if ( encoding . contains ( "deflate" ) && q > deflateQ ) { </a> 0
<a> deflateQ = q ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( gzipQ > 0.0f || deflateQ > 0.0f ) { </a> 0
<a> if ( gzipQ >= deflateQ ) { </a> 0
<a> return ZlibWrapper . GZIP ; </a> 0
<a> } else { </a> 0
<a> return ZlibWrapper . ZLIB ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( starQ > 0.0f ) { </a> 0
<a> if ( gzipQ == - 1.0f ) { </a> 0
<a> return ZlibWrapper . GZIP ; </a> 0
<a> } </a> 0
<a> if ( deflateQ == - 1.0f ) { </a> 0
<a> return ZlibWrapper . ZLIB ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import io . netty . handler . codec . MessageToMessageDecoder ; </a> 0
<a> public abstract class HttpContentDecoder extends MessageToMessageDecoder < Object , Object > { </a> 0
<a> private EmbeddedByteChannel decoder ; </a> 1
<a> protected HttpContentDecoder ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDecodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof HttpMessage || msg instanceof HttpChunk ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decode ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 0
<a> if ( msg instanceof HttpResponse && ( ( HttpResponse ) msg ) . getStatus ( ) . getCode ( ) == 100 ) { </a> 0
<a> return msg ; </a> 1
<a> } else if ( msg instanceof HttpMessage ) { </a> 0
<a> HttpMessage m = ( HttpMessage ) msg ; </a> 0
<a> cleanup ( ) ; </a> 0
<a> String contentEncoding = m . getHeader ( HttpHeaders . Names . CONTENT_ENCODING ) ; </a> 0
<a> if ( contentEncoding != null ) { </a> 0
<a> contentEncoding = contentEncoding . trim ( ) ; </a> 0
<a> } else { </a> 0
<a> contentEncoding = HttpHeaders . Values . IDENTITY ; </a> 0
<a> } </a> 0
<a> boolean hasContent = </a> 0
<a> m . getTransferEncoding ( ) . isMultiple ( ) || m . getContent ( ) . readable ( ) ; </a> 0
<a> if ( hasContent && ( decoder = newContentDecoder ( contentEncoding ) ) != null ) { </a> 0
<a> m . setHeader ( </a> 1
<a> HttpHeaders . Names . CONTENT_ENCODING , </a> 1
<a> getTargetContentEncoding ( contentEncoding ) ) ; </a> 1
<a> if ( m . getTransferEncoding ( ) . isSingle ( ) ) { </a> 0
<a> ByteBuf content = m . getContent ( ) ; </a> 0
<a> ByteBuf newContent = Unpooled . buffer ( ) ; </a> 0
<a> decode ( content , newContent ) ; </a> 0
<a> finishDecode ( newContent ) ; </a> 0
<a> m . setContent ( newContent ) ; </a> 0
<a> if ( m . containsHeader ( HttpHeaders . Names . CONTENT_LENGTH ) ) { </a> 0
<a> m . setHeader ( </a> 0
<a> HttpHeaders . Names . CONTENT_LENGTH , </a> 0
<a> Integer . toString ( newContent . readableBytes ( ) ) ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof HttpChunk ) { </a> 0
<a> HttpChunk c = ( HttpChunk ) msg ; </a> 0
<a> ByteBuf content = c . getContent ( ) ; </a> 0
<a> if ( decoder != null ) { </a> 0
<a> if ( ! c . isLast ( ) ) { </a> 0
<a> ByteBuf newContent = Unpooled . buffer ( ) ; </a> 0
<a> decode ( content , newContent ) ; </a> 0
<a> if ( newContent . readable ( ) ) { </a> 0
<a> c . setContent ( newContent ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> ByteBuf lastProduct = Unpooled . buffer ( ) ; </a> 0
<a> finishDecode ( lastProduct ) ; </a> 0
<a> if ( lastProduct . readable ( ) ) { </a> 0
<a> return new Object [ ] { new DefaultHttpChunk ( lastProduct ) , c } ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return msg ; </a> 0
<a> } </a> 0
<a> protected abstract EmbeddedByteChannel newContentDecoder ( String contentEncoding ) throws Exception ; </a> 1
<a> protected String getTargetContentEncoding ( String contentEncoding ) throws Exception { </a> 0
<a> return HttpHeaders . Values . IDENTITY ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void afterRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> cleanup ( ) ; </a> 0
<a> super . afterRemove ( ctx ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> cleanup ( ) ; </a> 0
<a> super . channelInactive ( ctx ) ; </a> 0
<a> } </a> 0
<a> private void cleanup ( ) { </a> 0
<a> if ( decoder != null ) { </a> 0
<a> finishDecode ( Unpooled . buffer ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private void decode ( ByteBuf in , ByteBuf out ) { </a> 0
<a> decoder . writeInbound ( in ) ; </a> 0
<a> fetchDecoderOutput ( out ) ; </a> 0
<a> } </a> 0
<a> private void finishDecode ( ByteBuf out ) { </a> 0
<a> if ( decoder . finish ( ) ) { </a> 0
<a> fetchDecoderOutput ( out ) ; </a> 0
<a> } </a> 0
<a> decoder = null ; </a> 0
<a> } </a> 0
<a> private void fetchDecoderOutput ( ByteBuf out ) { </a> 0
<a> for ( ; ; ) { </a> 0
<a> ByteBuf buf = ( ByteBuf ) decoder . readInbound ( ) ; </a> 0
<a> if ( buf == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> out . writeBytes ( buf ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import java . text . ParsePosition ; </a> 0
<a> import java . text . SimpleDateFormat ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . Locale ; </a> 0
<a> import java . util . TimeZone ; </a> 0
<a> final class HttpHeaderDateFormat extends SimpleDateFormat { </a> 1
<a> private static final long serialVersionUID = - 925286159755905325L ; </a> 0
<a> private final SimpleDateFormat format1 = new HttpHeaderDateFormatObsolete1 ( ) ; </a> 0
<a> private final SimpleDateFormat format2 = new HttpHeaderDateFormatObsolete2 ( ) ; </a> 0
<a> HttpHeaderDateFormat ( ) { </a> 0
<a> super ( "E, dd MMM yyyy HH:mm:ss z" , Locale . ENGLISH ) ; </a> 0
<a> setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Date parse ( String text , ParsePosition pos ) { </a> 0
<a> Date date = super . parse ( text , pos ) ; </a> 0
<a> if ( date == null ) { </a> 0
<a> date = format1 . parse ( text , pos ) ; </a> 0
<a> } </a> 0
<a> if ( date == null ) { </a> 0
<a> date = format2 . parse ( text , pos ) ; </a> 0
<a> } </a> 0
<a> return date ; </a> 0
<a> } </a> 0
<a> private static final class HttpHeaderDateFormatObsolete1 extends SimpleDateFormat { </a> 0
<a> private static final long serialVersionUID = - 3178072504225114298L ; </a> 0
<a> HttpHeaderDateFormatObsolete1 ( ) { </a> 0
<a> super ( "E, dd-MMM-y HH:mm:ss z" , Locale . ENGLISH ) ; </a> 0
<a> setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static final class HttpHeaderDateFormatObsolete2 extends SimpleDateFormat { </a> 0
<a> private static final long serialVersionUID = 3010674519968303714L ; </a> 0
<a> HttpHeaderDateFormatObsolete2 ( ) { </a> 0
<a> super ( "E MMM d HH:mm:ss yyyy" , Locale . ENGLISH ) ; </a> 0
<a> setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import java . util . Calendar ; </a> 1
<a> import java . util . Date ; </a> 1
<a> import java . util . List ; </a> 1
<a> import java . util . Map ; </a> 1
<a> import java . util . Set ; </a> 1
<a> public interface HttpMessage { </a> 0
<a> String getHeader ( String name ) ; </a> 1
<a> List < String > getHeaders ( String name ) ; </a> 1
<a> List < Map . Entry < String , String > > getHeaders ( ) ; </a> 1
<a> boolean containsHeader ( String name ) ; </a> 1
<a> Set < String > getHeaderNames ( ) ; </a> 1
<a> HttpVersion getProtocolVersion ( ) ; </a> 1
<a> void setProtocolVersion ( HttpVersion version ) ; </a> 1
<a> ByteBuf getContent ( ) ; </a> 0
<a> void setContent ( ByteBuf content ) ; </a> 0
<a> void addHeader ( String name , Object value ) ; </a> 1
<a> void setHeader ( String name , Object value ) ; </a> 1
<a> void setHeader ( String name , Iterable < ? > values ) ; </a> 1
<a> void removeHeader ( String name ) ; </a> 1
<a> void clearHeaders ( ) ; </a> 0
<a> HttpTransferEncoding getTransferEncoding ( ) ; </a> 0
<a> void setTransferEncoding ( HttpTransferEncoding te ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . ReplayingDecoder ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import java . util . List ; </a> 0
<a> public abstract class HttpMessageDecoder extends ReplayingDecoder < Object , HttpMessageDecoder . State > { </a> 0
<a> private final int maxInitialLineLength ; </a> 0
<a> private final int maxHeaderSize ; </a> 0
<a> private final int maxChunkSize ; </a> 0
<a> private HttpMessage message ; </a> 0
<a> private ByteBuf content ; </a> 0
<a> private long chunkSize ; </a> 0
<a> private int headerSize ; </a> 0
<a> private int contentRead ; </a> 0
<a> protected enum State { </a> 0
<a> SKIP_CONTROL_CHARS , </a> 0
<a> READ_INITIAL , </a> 0
<a> READ_HEADER , </a> 0
<a> READ_VARIABLE_LENGTH_CONTENT , </a> 0
<a> READ_VARIABLE_LENGTH_CONTENT_AS_CHUNKS , </a> 0
<a> READ_FIXED_LENGTH_CONTENT , </a> 0
<a> READ_FIXED_LENGTH_CONTENT_AS_CHUNKS , </a> 0
<a> READ_CHUNK_SIZE , </a> 0
<a> READ_CHUNKED_CONTENT , </a> 0
<a> READ_CHUNKED_CONTENT_AS_CHUNKS , </a> 0
<a> READ_CHUNK_DELIMITER , </a> 0
<a> READ_CHUNK_FOOTER </a> 0
<a> } </a> 0
<a> protected HttpMessageDecoder ( ) { </a> 0
<a> this ( 4096 , 8192 , 8192 ) ; </a> 0
<a> } </a> 0
<a> protected HttpMessageDecoder ( </a> 0
<a> int maxInitialLineLength , int maxHeaderSize , int maxChunkSize ) { </a> 0
<a> super ( State . SKIP_CONTROL_CHARS ) ; </a> 0
<a> if ( maxInitialLineLength <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxInitialLineLength must be a positive integer: " + </a> 0
<a> maxInitialLineLength ) ; </a> 0
<a> } </a> 0
<a> if ( maxHeaderSize <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxHeaderSize must be a positive integer: " + </a> 0
<a> maxHeaderSize ) ; </a> 0
<a> } </a> 0
<a> if ( maxChunkSize < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxChunkSize must be a positive integer: " + </a> 0
<a> maxChunkSize ) ; </a> 0
<a> } </a> 0
<a> this . maxInitialLineLength = maxInitialLineLength ; </a> 0
<a> this . maxHeaderSize = maxHeaderSize ; </a> 0
<a> this . maxChunkSize = maxChunkSize ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decode ( ChannelHandlerContext ctx , ByteBuf buffer ) throws Exception { </a> 0
<a> switch ( state ( ) ) { </a> 0
<a> case SKIP_CONTROL_CHARS : { </a> 0
<a> try { </a> 0
<a> skipControlCharacters ( buffer ) ; </a> 0
<a> checkpoint ( State . READ_INITIAL ) ; </a> 0
<a> } finally { </a> 0
<a> checkpoint ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> case READ_INITIAL : { </a> 0
<a> String [ ] initialLine = splitInitialLine ( readLine ( buffer , maxInitialLineLength ) ) ; </a> 0
<a> if ( initialLine . length < 3 ) { </a> 0
<a> checkpoint ( State . SKIP_CONTROL_CHARS ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> message = createMessage ( initialLine ) ; </a> 0
<a> checkpoint ( State . READ_HEADER ) ; </a> 0
<a> } </a> 0
<a> case READ_HEADER : { </a> 0
<a> State nextState = readHeaders ( buffer ) ; </a> 0
<a> checkpoint ( nextState ) ; </a> 0
<a> if ( nextState == State . READ_CHUNK_SIZE ) { </a> 0
<a> return message ; </a> 1
<a> } else if ( nextState == State . SKIP_CONTROL_CHARS ) { </a> 0
<a> return message ; </a> 0
<a> } else { </a> 0
<a> long contentLength = HttpHeaders . getContentLength ( message , - 1 ) ; </a> 0
<a> if ( contentLength == 0 || contentLength == - 1 && isDecodingRequest ( ) ) { </a> 0
<a> content = Unpooled . EMPTY_BUFFER ; </a> 0
<a> return reset ( ) ; </a> 1
<a> } </a> 0
<a> switch ( nextState ) { </a> 0
<a> case READ_FIXED_LENGTH_CONTENT : </a> 0
<a> if ( contentLength > maxChunkSize || HttpHeaders . is100ContinueExpected ( message ) ) { </a> 0
<a> checkpoint ( State . READ_FIXED_LENGTH_CONTENT_AS_CHUNKS ) ; </a> 0
<a> message . setTransferEncoding ( HttpTransferEncoding . STREAMED ) ; </a> 0
<a> chunkSize = HttpHeaders . getContentLength ( message , - 1 ) ; </a> 0
<a> return message ; </a> 1
<a> } </a> 0
<a> break ; </a> 0
<a> case READ_VARIABLE_LENGTH_CONTENT : </a> 0
<a> if ( buffer . readableBytes ( ) > maxChunkSize || HttpHeaders . is100ContinueExpected ( message ) ) { </a> 0
<a> checkpoint ( State . READ_VARIABLE_LENGTH_CONTENT_AS_CHUNKS ) ; </a> 0
<a> message . setTransferEncoding ( HttpTransferEncoding . STREAMED ) ; </a> 0
<a> return message ; </a> 1
<a> } </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new IllegalStateException ( "Unexpected state: " + nextState ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> case READ_VARIABLE_LENGTH_CONTENT : { </a> 0
<a> int toRead = actualReadableBytes ( ) ; </a> 0
<a> if ( toRead > maxChunkSize ) { </a> 0
<a> toRead = maxChunkSize ; </a> 0
<a> } </a> 0
<a> if ( message . getTransferEncoding ( ) != HttpTransferEncoding . STREAMED ) { </a> 0
<a> message . setTransferEncoding ( HttpTransferEncoding . STREAMED ) ; </a> 0
<a> return new Object [ ] { message , new DefaultHttpChunk ( buffer . readBytes ( toRead ) ) } ; </a> 0
<a> } else { </a> 0
<a> return new DefaultHttpChunk ( buffer . readBytes ( toRead ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> case READ_VARIABLE_LENGTH_CONTENT_AS_CHUNKS : { </a> 0
<a> int toRead = actualReadableBytes ( ) ; </a> 0
<a> if ( toRead > maxChunkSize ) { </a> 0
<a> toRead = maxChunkSize ; </a> 0
<a> } </a> 0
<a> HttpChunk chunk = new DefaultHttpChunk ( buffer . readBytes ( toRead ) ) ; </a> 0
<a> if ( ! buffer . readable ( ) ) { </a> 0
<a> reset ( ) ; </a> 0
<a> if ( ! chunk . isLast ( ) ) { </a> 0
<a> return new Object [ ] { chunk , HttpChunk . LAST_CHUNK } ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return chunk ; </a> 0
<a> } </a> 0
<a> case READ_FIXED_LENGTH_CONTENT : { </a> 0
<a> return readFixedLengthContent ( buffer ) ; </a> 1
<a> } </a> 0
<a> case READ_FIXED_LENGTH_CONTENT_AS_CHUNKS : { </a> 0
<a> assert chunkSize <= Integer . MAX_VALUE ; </a> 0
<a> int chunkSize = ( int ) this . chunkSize ; </a> 0
<a> int readLimit = actualReadableBytes ( ) ; </a> 0
<a> if ( readLimit == 0 ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> int toRead = chunkSize ; </a> 0
<a> if ( toRead > maxChunkSize ) { </a> 0
<a> toRead = maxChunkSize ; </a> 0
<a> } </a> 0
<a> if ( toRead > readLimit ) { </a> 0
<a> toRead = readLimit ; </a> 0
<a> } </a> 0
<a> HttpChunk chunk = new DefaultHttpChunk ( buffer . readBytes ( toRead ) ) ; </a> 0
<a> if ( chunkSize > toRead ) { </a> 0
<a> chunkSize -= toRead ; </a> 0
<a> } else { </a> 0
<a> chunkSize = 0 ; </a> 0
<a> } </a> 0
<a> this . chunkSize = chunkSize ; </a> 0
<a> if ( chunkSize == 0 ) { </a> 0
<a> reset ( ) ; </a> 0
<a> if ( ! chunk . isLast ( ) ) { </a> 0
<a> return new Object [ ] { chunk , HttpChunk . LAST_CHUNK } ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return chunk ; </a> 0
<a> } </a> 0
<a> case READ_CHUNK_SIZE : { </a> 0
<a> String line = readLine ( buffer , maxInitialLineLength ) ; </a> 0
<a> int chunkSize = getChunkSize ( line ) ; </a> 0
<a> this . chunkSize = chunkSize ; </a> 0
<a> if ( chunkSize == 0 ) { </a> 0
<a> checkpoint ( State . READ_CHUNK_FOOTER ) ; </a> 0
<a> return null ; </a> 1
<a> } else if ( chunkSize > maxChunkSize ) { </a> 0
<a> checkpoint ( State . READ_CHUNKED_CONTENT_AS_CHUNKS ) ; </a> 0
<a> } else { </a> 0
<a> checkpoint ( State . READ_CHUNKED_CONTENT ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> case READ_CHUNKED_CONTENT : { </a> 0
<a> assert chunkSize <= Integer . MAX_VALUE ; </a> 0
<a> HttpChunk chunk = new DefaultHttpChunk ( buffer . readBytes ( ( int ) chunkSize ) ) ; </a> 0
<a> checkpoint ( State . READ_CHUNK_DELIMITER ) ; </a> 0
<a> return chunk ; </a> 1
<a> } </a> 0
<a> case READ_CHUNKED_CONTENT_AS_CHUNKS : { </a> 0
<a> assert chunkSize <= Integer . MAX_VALUE ; </a> 0
<a> int chunkSize = ( int ) this . chunkSize ; </a> 0
<a> int readLimit = actualReadableBytes ( ) ; </a> 0
<a> if ( readLimit == 0 ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> int toRead = chunkSize ; </a> 0
<a> if ( toRead > maxChunkSize ) { </a> 0
<a> toRead = maxChunkSize ; </a> 0
<a> } </a> 0
<a> if ( toRead > readLimit ) { </a> 0
<a> toRead = readLimit ; </a> 0
<a> } </a> 0
<a> HttpChunk chunk = new DefaultHttpChunk ( buffer . readBytes ( toRead ) ) ; </a> 0
<a> if ( chunkSize > toRead ) { </a> 0
<a> chunkSize -= toRead ; </a> 0
<a> } else { </a> 0
<a> chunkSize = 0 ; </a> 0
<a> } </a> 0
<a> this . chunkSize = chunkSize ; </a> 0
<a> if ( chunkSize == 0 ) { </a> 0
<a> checkpoint ( State . READ_CHUNK_DELIMITER ) ; </a> 0
<a> } </a> 0
<a> if ( ! chunk . isLast ( ) ) { </a> 0
<a> return chunk ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> case READ_CHUNK_DELIMITER : { </a> 0
<a> for ( ; ; ) { </a> 0
<a> byte next = buffer . readByte ( ) ; </a> 0
<a> if ( next == HttpConstants . CR ) { </a> 0
<a> if ( buffer . readByte ( ) == HttpConstants . LF ) { </a> 0
<a> checkpoint ( State . READ_CHUNK_SIZE ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> } else if ( next == HttpConstants . LF ) { </a> 0
<a> checkpoint ( State . READ_CHUNK_SIZE ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> case READ_CHUNK_FOOTER : { </a> 0
<a> HttpChunkTrailer trailer = readTrailingHeaders ( buffer ) ; </a> 0
<a> if ( maxChunkSize == 0 ) { </a> 0
<a> return reset ( ) ; </a> 1
<a> } else { </a> 0
<a> reset ( ) ; </a> 0
<a> return trailer ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> default : { </a> 0
<a> throw new Error ( "Shouldn't reach here." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected boolean isContentAlwaysEmpty ( HttpMessage msg ) { </a> 0
<a> if ( msg instanceof HttpResponse ) { </a> 0
<a> HttpResponse res = ( HttpResponse ) msg ; </a> 0
<a> int code = res . getStatus ( ) . getCode ( ) ; </a> 1
<a> if ( code >= 100 && code < 200 ) { </a> 0
<a> if ( code == 101 && ! res . containsHeader ( HttpHeaders . Names . SEC_WEBSOCKET_ACCEPT ) ) { </a> 1
<a> return false ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> switch ( code ) { </a> 0
<a> case 204 : case 205 : case 304 : </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private Object reset ( ) { </a> 1
<a> HttpMessage message = this . message ; </a> 0
<a> ByteBuf content = this . content ; </a> 0
<a> if ( content != null ) { </a> 0
<a> message . setContent ( content ) ; </a> 0
<a> this . content = null ; </a> 0
<a> } </a> 0
<a> this . message = null ; </a> 0
<a> checkpoint ( State . SKIP_CONTROL_CHARS ) ; </a> 0
<a> return message ; </a> 0
<a> } </a> 0
<a> private static void skipControlCharacters ( ByteBuf buffer ) { </a> 0
<a> for ( ; ; ) { </a> 0
<a> char c = ( char ) buffer . readUnsignedByte ( ) ; </a> 0
<a> if ( ! Character . isISOControl ( c ) && </a> 0
<a> ! Character . isWhitespace ( c ) ) { </a> 0
<a> buffer . readerIndex ( buffer . readerIndex ( ) - 1 ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private Object readFixedLengthContent ( ByteBuf buffer ) { </a> 1
<a> long length = HttpHeaders . getContentLength ( message , - 1 ) ; </a> 0
<a> assert length <= Integer . MAX_VALUE ; </a> 0
<a> int toRead = ( int ) length - contentRead ; </a> 0
<a> if ( toRead > actualReadableBytes ( ) ) { </a> 0
<a> toRead = actualReadableBytes ( ) ; </a> 0
<a> } </a> 0
<a> contentRead += toRead ; </a> 0
<a> if ( length < contentRead ) { </a> 0
<a> if ( message . getTransferEncoding ( ) != HttpTransferEncoding . STREAMED ) { </a> 0
<a> message . setTransferEncoding ( HttpTransferEncoding . STREAMED ) ; </a> 0
<a> return new Object [ ] { message , new DefaultHttpChunk ( read ( buffer , toRead ) ) } ; </a> 0
<a> } else { </a> 0
<a> return new DefaultHttpChunk ( read ( buffer , toRead ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( content == null ) { </a> 0
<a> content = read ( buffer , ( int ) length ) ; </a> 0
<a> } else { </a> 0
<a> content . writeBytes ( buffer . readBytes ( ( int ) length ) ) ; </a> 0
<a> } </a> 0
<a> return reset ( ) ; </a> 0
<a> } </a> 0
<a> private ByteBuf read ( ByteBuf buffer , int len ) { </a> 0
<a> ByteBuf internal = internalBuffer ( ) ; </a> 0
<a> if ( internal . readableBytes ( ) >= len ) { </a> 0
<a> int index = internal . readerIndex ( ) ; </a> 0
<a> ByteBuf buf = internal . slice ( index , len ) ; </a> 0
<a> buffer . readerIndex ( index + len ) ; </a> 0
<a> return buf ; </a> 0
<a> } else { </a> 0
<a> return buffer . readBytes ( len ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private State readHeaders ( ByteBuf buffer ) throws TooLongFrameException { </a> 0
<a> headerSize = 0 ; </a> 0
<a> final HttpMessage message = this . message ; </a> 0
<a> String line = readHeader ( buffer ) ; </a> 0
<a> String name = null ; </a> 0
<a> String value = null ; </a> 0
<a> if ( line . length ( ) != 0 ) { </a> 0
<a> message . clearHeaders ( ) ; </a> 1
<a> do { </a> 0
<a> char firstChar = line . charAt ( 0 ) ; </a> 0
<a> if ( name != null && ( firstChar == ' ' || firstChar == '\t' ) ) { </a> 0
<a> value = value + ' ' + line . trim ( ) ; </a> 0
<a> } else { </a> 0
<a> if ( name != null ) { </a> 0
<a> message . addHeader ( name , value ) ; </a> 1
<a> } </a> 0
<a> String [ ] header = splitHeader ( line ) ; </a> 0
<a> name = header [ 0 ] ; </a> 0
<a> value = header [ 1 ] ; </a> 0
<a> } </a> 0
<a> line = readHeader ( buffer ) ; </a> 0
<a> } while ( line . length ( ) != 0 ) ; </a> 0
<a> if ( name != null ) { </a> 0
<a> message . addHeader ( name , value ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> State nextState ; </a> 0
<a> if ( isContentAlwaysEmpty ( message ) ) { </a> 0
<a> message . setTransferEncoding ( HttpTransferEncoding . SINGLE ) ; </a> 0
<a> nextState = State . SKIP_CONTROL_CHARS ; </a> 0
<a> } else if ( HttpCodecUtil . isTransferEncodingChunked ( message ) ) { </a> 0
<a> message . setTransferEncoding ( HttpTransferEncoding . CHUNKED ) ; </a> 0
<a> nextState = State . READ_CHUNK_SIZE ; </a> 0
<a> } else if ( HttpHeaders . getContentLength ( message , - 1 ) >= 0 ) { </a> 0
<a> nextState = State . READ_FIXED_LENGTH_CONTENT ; </a> 0
<a> } else { </a> 0
<a> nextState = State . READ_VARIABLE_LENGTH_CONTENT ; </a> 0
<a> } </a> 0
<a> return nextState ; </a> 0
<a> } </a> 0
<a> private HttpChunkTrailer readTrailingHeaders ( ByteBuf buffer ) throws TooLongFrameException { </a> 0
<a> headerSize = 0 ; </a> 0
<a> String line = readHeader ( buffer ) ; </a> 0
<a> String lastHeader = null ; </a> 0
<a> if ( line . length ( ) != 0 ) { </a> 0
<a> HttpChunkTrailer trailer = new DefaultHttpChunkTrailer ( ) ; </a> 0
<a> do { </a> 0
<a> char firstChar = line . charAt ( 0 ) ; </a> 0
<a> if ( lastHeader != null && ( firstChar == ' ' || firstChar == '\t' ) ) { </a> 0
<a> List < String > current = trailer . getHeaders ( lastHeader ) ; </a> 1
<a> if ( current . size ( ) != 0 ) { </a> 0
<a> int lastPos = current . size ( ) - 1 ; </a> 0
<a> String newString = current . get ( lastPos ) + line . trim ( ) ; </a> 0
<a> current . set ( lastPos , newString ) ; </a> 0
<a> } else { </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> String [ ] header = splitHeader ( line ) ; </a> 0
<a> String name = header [ 0 ] ; </a> 0
<a> if ( ! name . equalsIgnoreCase ( HttpHeaders . Names . CONTENT_LENGTH ) && </a> 0
<a> ! name . equalsIgnoreCase ( HttpHeaders . Names . TRANSFER_ENCODING ) && </a> 0
<a> ! name . equalsIgnoreCase ( HttpHeaders . Names . TRAILER ) ) { </a> 0
<a> trailer . addHeader ( name , header [ 1 ] ) ; </a> 1
<a> } </a> 0
<a> lastHeader = name ; </a> 0
<a> } </a> 0
<a> line = readHeader ( buffer ) ; </a> 0
<a> } while ( line . length ( ) != 0 ) ; </a> 0
<a> return trailer ; </a> 0
<a> } </a> 0
<a> return HttpChunk . LAST_CHUNK ; </a> 0
<a> } </a> 0
<a> private String readHeader ( ByteBuf buffer ) throws TooLongFrameException { </a> 0
<a> StringBuilder sb = new StringBuilder ( 64 ) ; </a> 0
<a> int headerSize = this . headerSize ; </a> 0
<a> loop : </a> 0
<a> for ( ; ; ) { </a> 0
<a> char nextByte = ( char ) buffer . readByte ( ) ; </a> 0
<a> headerSize ++ ; </a> 0
<a> switch ( nextByte ) { </a> 0
<a> case HttpConstants . CR : </a> 0
<a> nextByte = ( char ) buffer . readByte ( ) ; </a> 0
<a> headerSize ++ ; </a> 0
<a> if ( nextByte == HttpConstants . LF ) { </a> 0
<a> break loop ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> case HttpConstants . LF : </a> 0
<a> break loop ; </a> 0
<a> } </a> 0
<a> if ( headerSize >= maxHeaderSize ) { </a> 0
<a> throw new TooLongFrameException ( </a> 0
<a> "HTTP header is larger than " + </a> 0
<a> maxHeaderSize + " bytes." ) ; </a> 0
<a> } </a> 0
<a> sb . append ( nextByte ) ; </a> 0
<a> } </a> 0
<a> this . headerSize = headerSize ; </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> protected abstract boolean isDecodingRequest ( ) ; </a> 0
<a> protected abstract HttpMessage createMessage ( String [ ] initialLine ) throws Exception ; </a> 0
<a> private static int getChunkSize ( String hex ) { </a> 0
<a> hex = hex . trim ( ) ; </a> 0
<a> for ( int i = 0 ; i < hex . length ( ) ; i ++ ) { </a> 0
<a> char c = hex . charAt ( i ) ; </a> 0
<a> if ( c == ';' || Character . isWhitespace ( c ) || Character . isISOControl ( c ) ) { </a> 0
<a> hex = hex . substring ( 0 , i ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return Integer . parseInt ( hex , 16 ) ; </a> 0
<a> } </a> 0
<a> private static String readLine ( ByteBuf buffer , int maxLineLength ) throws TooLongFrameException { </a> 0
<a> StringBuilder sb = new StringBuilder ( 64 ) ; </a> 0
<a> int lineLength = 0 ; </a> 0
<a> while ( true ) { </a> 0
<a> byte nextByte = buffer . readByte ( ) ; </a> 0
<a> if ( nextByte == HttpConstants . CR ) { </a> 0
<a> nextByte = buffer . readByte ( ) ; </a> 0
<a> if ( nextByte == HttpConstants . LF ) { </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> } else if ( nextByte == HttpConstants . LF ) { </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } else { </a> 0
<a> if ( lineLength >= maxLineLength ) { </a> 0
<a> throw new TooLongFrameException ( </a> 0
<a> "An HTTP line is larger than " + maxLineLength + </a> 0
<a> " bytes." ) ; </a> 0
<a> } </a> 0
<a> lineLength ++ ; </a> 0
<a> sb . append ( ( char ) nextByte ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static String [ ] splitInitialLine ( String sb ) { </a> 0
<a> int aStart ; </a> 0
<a> int aEnd ; </a> 0
<a> int bStart ; </a> 0
<a> int bEnd ; </a> 0
<a> int cStart ; </a> 0
<a> int cEnd ; </a> 0
<a> aStart = findNonWhitespace ( sb , 0 ) ; </a> 0
<a> aEnd = findWhitespace ( sb , aStart ) ; </a> 0
<a> bStart = findNonWhitespace ( sb , aEnd ) ; </a> 0
<a> bEnd = findWhitespace ( sb , bStart ) ; </a> 0
<a> cStart = findNonWhitespace ( sb , bEnd ) ; </a> 0
<a> cEnd = findEndOfString ( sb ) ; </a> 0
<a> return new String [ ] { </a> 0
<a> sb . substring ( aStart , aEnd ) , </a> 0
<a> sb . substring ( bStart , bEnd ) , </a> 0
<a> cStart < cEnd ? sb . substring ( cStart , cEnd ) : "" } ; </a> 0
<a> } </a> 0
<a> private static String [ ] splitHeader ( String sb ) { </a> 0
<a> final int length = sb . length ( ) ; </a> 0
<a> int nameStart ; </a> 0
<a> int nameEnd ; </a> 0
<a> int colonEnd ; </a> 0
<a> int valueStart ; </a> 0
<a> int valueEnd ; </a> 0
<a> nameStart = findNonWhitespace ( sb , 0 ) ; </a> 0
<a> for ( nameEnd = nameStart ; nameEnd < length ; nameEnd ++ ) { </a> 0
<a> char ch = sb . charAt ( nameEnd ) ; </a> 0
<a> if ( ch == ':' || Character . isWhitespace ( ch ) ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( colonEnd = nameEnd ; colonEnd < length ; colonEnd ++ ) { </a> 0
<a> if ( sb . charAt ( colonEnd ) == ':' ) { </a> 0
<a> colonEnd ++ ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> valueStart = findNonWhitespace ( sb , colonEnd ) ; </a> 0
<a> if ( valueStart == length ) { </a> 0
<a> return new String [ ] { </a> 0
<a> sb . substring ( nameStart , nameEnd ) , </a> 0
<a> "" </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> valueEnd = findEndOfString ( sb ) ; </a> 0
<a> return new String [ ] { </a> 0
<a> sb . substring ( nameStart , nameEnd ) , </a> 0
<a> sb . substring ( valueStart , valueEnd ) </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> private static int findNonWhitespace ( String sb , int offset ) { </a> 0
<a> int result ; </a> 0
<a> for ( result = offset ; result < sb . length ( ) ; result ++ ) { </a> 0
<a> if ( ! Character . isWhitespace ( sb . charAt ( result ) ) ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> private static int findWhitespace ( String sb , int offset ) { </a> 0
<a> int result ; </a> 0
<a> for ( result = offset ; result < sb . length ( ) ; result ++ ) { </a> 0
<a> if ( Character . isWhitespace ( sb . charAt ( result ) ) ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> private static int findEndOfString ( String sb ) { </a> 0
<a> int result ; </a> 0
<a> for ( result = sb . length ( ) ; result > 0 ; result -- ) { </a> 0
<a> if ( ! Character . isWhitespace ( sb . charAt ( result - 1 ) ) ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import static io . netty . buffer . Unpooled . * ; </a> 1
<a> import static io . netty . handler . codec . http . HttpConstants . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . MessageToByteEncoder ; </a> 0
<a> import io . netty . handler . codec . UnsupportedMessageTypeException ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public abstract class HttpMessageEncoder extends MessageToByteEncoder < Object > { </a> 0
<a> private static final ByteBuf LAST_CHUNK = </a> 0
<a> copiedBuffer ( "0\r\n\r\n" , CharsetUtil . US_ASCII ) ; </a> 0
<a> private HttpTransferEncoding lastTE ; </a> 0
<a> protected HttpMessageEncoder ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof HttpMessage || msg instanceof HttpChunk ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void encode ( ChannelHandlerContext ctx , Object msg , ByteBuf out ) throws Exception { </a> 0
<a> if ( msg instanceof HttpMessage ) { </a> 0
<a> HttpMessage m = ( HttpMessage ) msg ; </a> 0
<a> HttpTransferEncoding te = m . getTransferEncoding ( ) ; </a> 0
<a> lastTE = te ; </a> 0
<a> m . setTransferEncoding ( te ) ; </a> 0
<a> out . markWriterIndex ( ) ; </a> 1
<a> encodeInitialLine ( out , m ) ; </a> 0
<a> encodeHeaders ( out , m ) ; </a> 0
<a> out . writeByte ( CR ) ; </a> 0
<a> out . writeByte ( LF ) ; </a> 0
<a> ByteBuf content = m . getContent ( ) ; </a> 0
<a> out . writeBytes ( content , content . readerIndex ( ) , content . readableBytes ( ) ) ; </a> 0
<a> } else if ( msg instanceof HttpChunk ) { </a> 0
<a> HttpChunk chunk = ( HttpChunk ) msg ; </a> 0
<a> HttpTransferEncoding te = lastTE ; </a> 0
<a> if ( te == null ) { </a> 0
<a> throw new IllegalArgumentException ( "HttpChunk must follow an HttpMessage." ) ; </a> 0
<a> } </a> 0
<a> switch ( te ) { </a> 0
<a> case SINGLE : </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "The transfer encoding of the last encoded HttpMessage is SINGLE." ) ; </a> 0
<a> case STREAMED : { </a> 0
<a> ByteBuf content = chunk . getContent ( ) ; </a> 1
<a> out . writeBytes ( content , content . readerIndex ( ) , content . readableBytes ( ) ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case CHUNKED : </a> 0
<a> if ( chunk . isLast ( ) ) { </a> 0
<a> if ( chunk instanceof HttpChunkTrailer ) { </a> 0
<a> out . writeByte ( ( byte ) '0' ) ; </a> 1
<a> out . writeByte ( CR ) ; </a> 0
<a> out . writeByte ( LF ) ; </a> 0
<a> encodeTrailingHeaders ( out , ( HttpChunkTrailer ) chunk ) ; </a> 0
<a> out . writeByte ( CR ) ; </a> 0
<a> out . writeByte ( LF ) ; </a> 0
<a> } else { </a> 1
<a> out . writeBytes ( LAST_CHUNK , LAST_CHUNK . readerIndex ( ) , LAST_CHUNK . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> ByteBuf content = chunk . getContent ( ) ; </a> 1
<a> int contentLength = content . readableBytes ( ) ; </a> 1
<a> out . writeBytes ( copiedBuffer ( Integer . toHexString ( contentLength ) , CharsetUtil . US_ASCII ) ) ; </a> 1
<a> out . writeByte ( CR ) ; </a> 0
<a> out . writeByte ( LF ) ; </a> 0
<a> out . writeBytes ( content , content . readerIndex ( ) , contentLength ) ; </a> 1
<a> out . writeByte ( CR ) ; </a> 0
<a> out . writeByte ( LF ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedMessageTypeException ( msg , HttpMessage . class , HttpChunk . class ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void encodeHeaders ( ByteBuf buf , HttpMessage message ) { </a> 0
<a> for ( Map . Entry < String , String > h : message . getHeaders ( ) ) { </a> 1
<a> encodeHeader ( buf , h . getKey ( ) , h . getValue ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void encodeTrailingHeaders ( ByteBuf buf , HttpChunkTrailer trailer ) { </a> 0
<a> for ( Map . Entry < String , String > h : trailer . getHeaders ( ) ) { </a> 1
<a> encodeHeader ( buf , h . getKey ( ) , h . getValue ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void encodeHeader ( ByteBuf buf , String header , String value ) { </a> 0
<a> buf . writeBytes ( header . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 0
<a> buf . writeByte ( COLON ) ; </a> 0
<a> buf . writeByte ( SP ) ; </a> 0
<a> buf . writeBytes ( value . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 0
<a> buf . writeByte ( CR ) ; </a> 0
<a> buf . writeByte ( LF ) ; </a> 0
<a> } </a> 0
<a> protected abstract void encodeInitialLine ( ByteBuf buf , HttpMessage message ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class HttpMethod implements Comparable < HttpMethod > { </a> 0
<a> public static final HttpMethod OPTIONS = new HttpMethod ( "OPTIONS" ) ; </a> 0
<a> public static final HttpMethod GET = new HttpMethod ( "GET" ) ; </a> 0
<a> public static final HttpMethod HEAD = new HttpMethod ( "HEAD" ) ; </a> 0
<a> public static final HttpMethod POST = new HttpMethod ( "POST" ) ; </a> 0
<a> public static final HttpMethod PUT = new HttpMethod ( "PUT" ) ; </a> 0
<a> public static final HttpMethod PATCH = new HttpMethod ( "PATCH" ) ; </a> 0
<a> public static final HttpMethod DELETE = new HttpMethod ( "DELETE" ) ; </a> 0
<a> public static final HttpMethod TRACE = new HttpMethod ( "TRACE" ) ; </a> 0
<a> public static final HttpMethod CONNECT = new HttpMethod ( "CONNECT" ) ; </a> 0
<a> private static final Map < String , HttpMethod > methodMap = </a> 0
<a> new HashMap < String , HttpMethod > ( ) ; </a> 0
<a> static { </a> 0
<a> methodMap . put ( OPTIONS . toString ( ) , OPTIONS ) ; </a> 0
<a> methodMap . put ( GET . toString ( ) , GET ) ; </a> 0
<a> methodMap . put ( HEAD . toString ( ) , HEAD ) ; </a> 0
<a> methodMap . put ( POST . toString ( ) , POST ) ; </a> 0
<a> methodMap . put ( PUT . toString ( ) , PUT ) ; </a> 0
<a> methodMap . put ( PATCH . toString ( ) , PATCH ) ; </a> 0
<a> methodMap . put ( DELETE . toString ( ) , DELETE ) ; </a> 0
<a> methodMap . put ( TRACE . toString ( ) , TRACE ) ; </a> 0
<a> methodMap . put ( CONNECT . toString ( ) , CONNECT ) ; </a> 0
<a> } </a> 0
<a> public static HttpMethod valueOf ( String name ) { </a> 0
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> name = name . trim ( ) . toUpperCase ( ) ; </a> 0
<a> if ( name . length ( ) == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "empty name" ) ; </a> 0
<a> } </a> 0
<a> HttpMethod result = methodMap . get ( name ) ; </a> 0
<a> if ( result != null ) { </a> 0
<a> return result ; </a> 0
<a> } else { </a> 0
<a> return new HttpMethod ( name ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final String name ; </a> 0
<a> public HttpMethod ( String name ) { </a> 0
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> name = name . trim ( ) . toUpperCase ( ) ; </a> 0
<a> if ( name . length ( ) == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "empty name" ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < name . length ( ) ; i ++ ) { </a> 0
<a> if ( Character . isISOControl ( name . charAt ( i ) ) || </a> 1
<a> Character . isWhitespace ( name . charAt ( i ) ) ) { </a> 1
<a> throw new IllegalArgumentException ( "invalid character in name" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> this . name = name ; </a> 0
<a> } </a> 0
<a> public String getName ( ) { </a> 1
<a> return name ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return getName ( ) . hashCode ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object o ) { </a> 0
<a> if ( ! ( o instanceof HttpMethod ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> HttpMethod that = ( HttpMethod ) o ; </a> 0
<a> return getName ( ) . equals ( that . getName ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getName ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( HttpMethod o ) { </a> 0
<a> return getName ( ) . compareTo ( o . getName ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> public interface HttpRequest extends HttpMessage { </a> 0
<a> HttpMethod getMethod ( ) ; </a> 0
<a> void setMethod ( HttpMethod method ) ; </a> 1
<a> String getUri ( ) ; </a> 1
<a> void setUri ( String uri ) ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> public class HttpRequestDecoder extends HttpMessageDecoder { </a> 0
<a> public HttpRequestDecoder ( ) { </a> 0
<a> } </a> 0
<a> public HttpRequestDecoder ( </a> 0
<a> int maxInitialLineLength , int maxHeaderSize , int maxChunkSize ) { </a> 0
<a> super ( maxInitialLineLength , maxHeaderSize , maxChunkSize ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected HttpMessage createMessage ( String [ ] initialLine ) throws Exception { </a> 0
<a> return new DefaultHttpRequest ( </a> 0
<a> HttpVersion . valueOf ( initialLine [ 2 ] ) , HttpMethod . valueOf ( initialLine [ 0 ] ) , initialLine [ 1 ] ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isDecodingRequest ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import static io . netty . handler . codec . http . HttpConstants . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class HttpRequestEncoder extends HttpMessageEncoder { </a> 0
<a> public HttpRequestEncoder ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void encodeInitialLine ( ByteBuf buf , HttpMessage message ) throws Exception { </a> 0
<a> HttpRequest request = ( HttpRequest ) message ; </a> 0
<a> buf . writeBytes ( request . getMethod ( ) . toString ( ) . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 1
<a> buf . writeByte ( SP ) ; </a> 0
<a> buf . writeBytes ( request . getUri ( ) . getBytes ( CharsetUtil . UTF_8 ) ) ; </a> 0
<a> buf . writeByte ( SP ) ; </a> 1
<a> buf . writeBytes ( request . getProtocolVersion ( ) . toString ( ) . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 1
<a> buf . writeByte ( CR ) ; </a> 0
<a> buf . writeByte ( LF ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> public interface HttpResponse extends HttpMessage { </a> 0
<a> HttpResponseStatus getStatus ( ) ; </a> 0
<a> void setStatus ( HttpResponseStatus status ) ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> public class HttpResponseDecoder extends HttpMessageDecoder { </a> 0
<a> public HttpResponseDecoder ( ) { </a> 0
<a> } </a> 0
<a> public HttpResponseDecoder ( </a> 0
<a> int maxInitialLineLength , int maxHeaderSize , int maxChunkSize ) { </a> 0
<a> super ( maxInitialLineLength , maxHeaderSize , maxChunkSize ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected HttpMessage createMessage ( String [ ] initialLine ) { </a> 0
<a> return new DefaultHttpResponse ( </a> 0
<a> HttpVersion . valueOf ( initialLine [ 0 ] ) , </a> 0
<a> new HttpResponseStatus ( Integer . valueOf ( initialLine [ 1 ] ) , initialLine [ 2 ] ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isDecodingRequest ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import static io . netty . handler . codec . http . HttpConstants . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 1
<a> public class HttpResponseEncoder extends HttpMessageEncoder { </a> 0
<a> public HttpResponseEncoder ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void encodeInitialLine ( ByteBuf buf , HttpMessage message ) throws Exception { </a> 0
<a> HttpResponse response = ( HttpResponse ) message ; </a> 0
<a> buf . writeBytes ( response . getProtocolVersion ( ) . toString ( ) . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 1
<a> buf . writeByte ( SP ) ; </a> 0
<a> buf . writeBytes ( String . valueOf ( response . getStatus ( ) . getCode ( ) ) . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 1
<a> buf . writeByte ( SP ) ; </a> 0
<a> buf . writeBytes ( String . valueOf ( response . getStatus ( ) . getReasonPhrase ( ) ) . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 1
<a> buf . writeByte ( CR ) ; </a> 0
<a> buf . writeByte ( LF ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> public enum HttpTransferEncoding { </a> 0
<a> CHUNKED ( false ) , </a> 0
<a> STREAMED ( false ) , </a> 0
<a> SINGLE ( true ) ; </a> 0
<a> private final boolean single ; </a> 0
<a> private HttpTransferEncoding ( boolean single ) { </a> 0
<a> this . single = single ; </a> 0
<a> } </a> 0
<a> public boolean isMultiple ( ) { </a> 0
<a> return ! single ; </a> 0
<a> } </a> 0
<a> public boolean isSingle ( ) { </a> 0
<a> return single ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import java . util . regex . Matcher ; </a> 0
<a> import java . util . regex . Pattern ; </a> 0
<a> public class HttpVersion implements Comparable < HttpVersion > { </a> 0
<a> private static final Pattern VERSION_PATTERN = </a> 0
<a> Pattern . compile ( "(\\S+)/(\\d+)\\.(\\d+)" ) ; </a> 0
<a> public static final HttpVersion HTTP_1_0 = new HttpVersion ( "HTTP" , 1 , 0 , false ) ; </a> 0
<a> public static final HttpVersion HTTP_1_1 = new HttpVersion ( "HTTP" , 1 , 1 , true ) ; </a> 0
<a> public static HttpVersion valueOf ( String text ) { </a> 0
<a> if ( text == null ) { </a> 0
<a> throw new NullPointerException ( "text" ) ; </a> 0
<a> } </a> 0
<a> text = text . trim ( ) . toUpperCase ( ) ; </a> 0
<a> if ( text . equals ( "HTTP/1.1" ) ) { </a> 0
<a> return HTTP_1_1 ; </a> 0
<a> } </a> 0
<a> if ( text . equals ( "HTTP/1.0" ) ) { </a> 0
<a> return HTTP_1_0 ; </a> 0
<a> } </a> 0
<a> return new HttpVersion ( text , true ) ; </a> 0
<a> } </a> 0
<a> private final String protocolName ; </a> 1
<a> private final int majorVersion ; </a> 0
<a> private final int minorVersion ; </a> 0
<a> private final String text ; </a> 1
<a> private final boolean keepAliveDefault ; </a> 0
<a> public HttpVersion ( String text , boolean keepAliveDefault ) { </a> 0
<a> if ( text == null ) { </a> 0
<a> throw new NullPointerException ( "text" ) ; </a> 0
<a> } </a> 0
<a> text = text . trim ( ) . toUpperCase ( ) ; </a> 0
<a> if ( text . length ( ) == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "empty text" ) ; </a> 0
<a> } </a> 0
<a> Matcher m = VERSION_PATTERN . matcher ( text ) ; </a> 0
<a> if ( ! m . matches ( ) ) { </a> 0
<a> throw new IllegalArgumentException ( "invalid version format: " + text ) ; </a> 0
<a> } </a> 0
<a> protocolName = m . group ( 1 ) ; </a> 1
<a> majorVersion = Integer . parseInt ( m . group ( 2 ) ) ; </a> 0
<a> minorVersion = Integer . parseInt ( m . group ( 3 ) ) ; </a> 0
<a> this . text = protocolName + '/' + majorVersion + '.' + minorVersion ; </a> 1
<a> this . keepAliveDefault = keepAliveDefault ; </a> 0
<a> } </a> 0
<a> public HttpVersion ( </a> 1
<a> String protocolName , int majorVersion , int minorVersion , </a> 1
<a> boolean keepAliveDefault ) { </a> 1
<a> if ( protocolName == null ) { </a> 0
<a> throw new NullPointerException ( "protocolName" ) ; </a> 0
<a> } </a> 0
<a> protocolName = protocolName . trim ( ) . toUpperCase ( ) ; </a> 0
<a> if ( protocolName . length ( ) == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "empty protocolName" ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < protocolName . length ( ) ; i ++ ) { </a> 0
<a> if ( Character . isISOControl ( protocolName . charAt ( i ) ) || </a> 0
<a> Character . isWhitespace ( protocolName . charAt ( i ) ) ) { </a> 0
<a> throw new IllegalArgumentException ( "invalid character in protocolName" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( majorVersion < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "negative majorVersion" ) ; </a> 0
<a> } </a> 0
<a> if ( minorVersion < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "negative minorVersion" ) ; </a> 0
<a> } </a> 0
<a> this . protocolName = protocolName ; </a> 1
<a> this . majorVersion = majorVersion ; </a> 0
<a> this . minorVersion = minorVersion ; </a> 0
<a> text = protocolName + '/' + majorVersion + '.' + minorVersion ; </a> 1
<a> this . keepAliveDefault = keepAliveDefault ; </a> 0
<a> } </a> 0
<a> public String getProtocolName ( ) { </a> 0
<a> return protocolName ; </a> 0
<a> } </a> 0
<a> public int getMajorVersion ( ) { </a> 0
<a> return majorVersion ; </a> 0
<a> } </a> 0
<a> public int getMinorVersion ( ) { </a> 0
<a> return minorVersion ; </a> 0
<a> } </a> 0
<a> public String getText ( ) { </a> 0
<a> return text ; </a> 0
<a> } </a> 0
<a> public boolean isKeepAliveDefault ( ) { </a> 0
<a> return keepAliveDefault ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getText ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return ( getProtocolName ( ) . hashCode ( ) * 31 + getMajorVersion ( ) ) * 31 + </a> 0
<a> getMinorVersion ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object o ) { </a> 0
<a> if ( ! ( o instanceof HttpVersion ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> HttpVersion that = ( HttpVersion ) o ; </a> 0
<a> return getMinorVersion ( ) == that . getMinorVersion ( ) && </a> 0
<a> getMajorVersion ( ) == that . getMajorVersion ( ) && </a> 0
<a> getProtocolName ( ) . equals ( that . getProtocolName ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( HttpVersion o ) { </a> 0
<a> int v = getProtocolName ( ) . compareTo ( o . getProtocolName ( ) ) ; </a> 0
<a> if ( v != 0 ) { </a> 0
<a> return v ; </a> 0
<a> } </a> 0
<a> v = getMajorVersion ( ) - o . getMajorVersion ( ) ; </a> 0
<a> if ( v != 0 ) { </a> 0
<a> return v ; </a> 0
<a> } </a> 0
<a> return getMinorVersion ( ) - o . getMinorVersion ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . net . URI ; </a> 0
<a> import java . net . URLDecoder ; </a> 0
<a> import java . nio . charset . Charset ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . LinkedHashMap ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class QueryStringDecoder { </a> 0
<a> private static final int DEFAULT_MAX_PARAMS = 1024 ; </a> 0
<a> private final Charset charset ; </a> 0
<a> private final String uri ; </a> 0
<a> private final boolean hasPath ; </a> 0
<a> private final int maxParams ; </a> 0
<a> private String path ; </a> 0
<a> private Map < String , List < String > > params ; </a> 0
<a> private int nParams ; </a> 0
<a> public QueryStringDecoder ( String uri ) { </a> 0
<a> this ( uri , HttpConstants . DEFAULT_CHARSET ) ; </a> 0
<a> } </a> 0
<a> public QueryStringDecoder ( String uri , boolean hasPath ) { </a> 0
<a> this ( uri , HttpConstants . DEFAULT_CHARSET , hasPath ) ; </a> 0
<a> } </a> 0
<a> public QueryStringDecoder ( String uri , Charset charset ) { </a> 0
<a> this ( uri , charset , true ) ; </a> 0
<a> } </a> 0
<a> public QueryStringDecoder ( String uri , Charset charset , boolean hasPath ) { </a> 0
<a> this ( uri , charset , hasPath , DEFAULT_MAX_PARAMS ) ; </a> 0
<a> } </a> 0
<a> public QueryStringDecoder ( String uri , Charset charset , boolean hasPath , int maxParams ) { </a> 0
<a> if ( uri == null ) { </a> 0
<a> throw new NullPointerException ( "uri" ) ; </a> 1
<a> } </a> 0
<a> if ( charset == null ) { </a> 0
<a> throw new NullPointerException ( "charset" ) ; </a> 0
<a> } </a> 0
<a> if ( maxParams <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxParams: " + maxParams + " (expected: a positive integer)" ) ; </a> 0
<a> } </a> 0
<a> this . uri = uri . replace ( ';' , '&' ) ; </a> 0
<a> this . charset = charset ; </a> 0
<a> this . maxParams = maxParams ; </a> 0
<a> this . hasPath = hasPath ; </a> 0
<a> } </a> 0
<a> public QueryStringDecoder ( URI uri ) { </a> 0
<a> this ( uri , HttpConstants . DEFAULT_CHARSET ) ; </a> 0
<a> } </a> 0
<a> public QueryStringDecoder ( URI uri , Charset charset ) { </a> 0
<a> this ( uri , charset , DEFAULT_MAX_PARAMS ) ; </a> 0
<a> } </a> 0
<a> public QueryStringDecoder ( URI uri , Charset charset , int maxParams ) { </a> 0
<a> if ( uri == null ) { </a> 0
<a> throw new NullPointerException ( "uri" ) ; </a> 1
<a> } </a> 0
<a> if ( charset == null ) { </a> 0
<a> throw new NullPointerException ( "charset" ) ; </a> 0
<a> } </a> 0
<a> if ( maxParams <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxParams: " + maxParams + " (expected: a positive integer)" ) ; </a> 0
<a> } </a> 0
<a> String rawPath = uri . getRawPath ( ) ; </a> 0
<a> if ( rawPath != null ) { </a> 0
<a> hasPath = true ; </a> 0
<a> } else { </a> 0
<a> rawPath = "" ; </a> 0
<a> hasPath = false ; </a> 0
<a> } </a> 0
<a> String newUri = rawPath + "?" + uri . getRawQuery ( ) ; </a> 0
<a> this . uri = newUri . replace ( ';' , '&' ) ; </a> 0
<a> this . charset = charset ; </a> 0
<a> this . maxParams = maxParams ; </a> 0
<a> } </a> 0
<a> public String getPath ( ) { </a> 0
<a> if ( path == null ) { </a> 0
<a> if ( ! hasPath ) { </a> 0
<a> return path = "" ; </a> 0
<a> } </a> 0
<a> int pathEndPos = uri . indexOf ( '?' ) ; </a> 0
<a> if ( pathEndPos < 0 ) { </a> 0
<a> path = uri ; </a> 0
<a> } else { </a> 0
<a> return path = uri . substring ( 0 , pathEndPos ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return path ; </a> 0
<a> } </a> 0
<a> public Map < String , List < String > > getParameters ( ) { </a> 0
<a> if ( params == null ) { </a> 0
<a> if ( hasPath ) { </a> 0
<a> int pathLength = getPath ( ) . length ( ) ; </a> 0
<a> if ( uri . length ( ) == pathLength ) { </a> 0
<a> return Collections . emptyMap ( ) ; </a> 0
<a> } </a> 0
<a> decodeParams ( uri . substring ( pathLength + 1 ) ) ; </a> 0
<a> } else { </a> 0
<a> if ( uri . isEmpty ( ) ) { </a> 0
<a> return Collections . emptyMap ( ) ; </a> 0
<a> } </a> 0
<a> decodeParams ( uri ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return params ; </a> 0
<a> } </a> 0
<a> private void decodeParams ( String s ) { </a> 0
<a> Map < String , List < String > > params = this . params = new LinkedHashMap < String , List < String > > ( ) ; </a> 0
<a> nParams = 0 ; </a> 0
<a> String name = null ; </a> 0
<a> int pos = 0 ; </a> 0
<a> int i ; </a> 0
<a> char c ; </a> 0
<a> for ( i = 0 ; i < s . length ( ) ; i ++ ) { </a> 0
<a> c = s . charAt ( i ) ; </a> 0
<a> if ( c == '=' && name == null ) { </a> 0
<a> if ( pos != i ) { </a> 0
<a> name = decodeComponent ( s . substring ( pos , i ) , charset ) ; </a> 0
<a> } </a> 0
<a> pos = i + 1 ; </a> 0
<a> } else if ( c == '&' ) { </a> 0
<a> if ( name == null && pos != i ) { </a> 0
<a> if ( ! addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , "" ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } else if ( name != null ) { </a> 0
<a> if ( ! addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> name = null ; </a> 0
<a> } </a> 0
<a> pos = i + 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( pos != i ) { </a> 0
<a> if ( name == null ) { </a> 0
<a> addParam ( params , decodeComponent ( s . substring ( pos , i ) , charset ) , "" ) ; </a> 0
<a> } else { </a> 0
<a> addParam ( params , name , decodeComponent ( s . substring ( pos , i ) , charset ) ) ; </a> 0
<a> } </a> 0
<a> } else if ( name != null ) { </a> 0
<a> addParam ( params , name , "" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean addParam ( Map < String , List < String > > params , String name , String value ) { </a> 0
<a> if ( nParams >= maxParams ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> List < String > values = params . get ( name ) ; </a> 0
<a> if ( values == null ) { </a> 0
<a> values = new ArrayList < String > ( 1 ) ; </a> 0
<a> params . put ( name , values ) ; </a> 0
<a> } </a> 0
<a> values . add ( value ) ; </a> 0
<a> nParams ++ ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public static String decodeComponent ( final String s ) { </a> 0
<a> return decodeComponent ( s , HttpConstants . DEFAULT_CHARSET ) ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "fallthrough" ) </a> 1
<a> public static String decodeComponent ( final String s , </a> 1
<a> final Charset charset ) { </a> 1
<a> if ( s == null ) { </a> 0
<a> return "" ; </a> 0
<a> } </a> 0
<a> final int size = s . length ( ) ; </a> 0
<a> boolean modified = false ; </a> 0
<a> for ( int i = 0 ; i < size ; i ++ ) { </a> 0
<a> final char c = s . charAt ( i ) ; </a> 0
<a> switch ( c ) { </a> 1
<a> case '%' : </a> 1
<a> i ++ ; </a> 1
<a> case '+' : </a> 1
<a> modified = true ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! modified ) { </a> 0
<a> return s ; </a> 0
<a> } </a> 0
<a> final byte [ ] buf = new byte [ size ] ; </a> 0
<a> int pos = 0 ; </a> 0
<a> for ( int i = 0 ; i < size ; i ++ ) { </a> 0
<a> char c = s . charAt ( i ) ; </a> 0
<a> switch ( c ) { </a> 0
<a> case '+' : </a> 0
<a> buf [ pos ++ ] = ' ' ; </a> 0
<a> break ; </a> 0
<a> case '%' : </a> 0
<a> if ( i == size - 1 ) { </a> 0
<a> throw new IllegalArgumentException ( "unterminated escape" </a> 0
<a> + " sequence at end of string: " + s ) ; </a> 0
<a> } </a> 0
<a> c = s . charAt ( ++ i ) ; </a> 0
<a> if ( c == '%' ) { </a> 0
<a> buf [ pos ++ ] = '%' ; </a> 0
<a> break ; </a> 0
<a> } else if ( i == size - 1 ) { </a> 0
<a> throw new IllegalArgumentException ( "partial escape" </a> 0
<a> + " sequence at end of string: " + s ) ; </a> 0
<a> } </a> 0
<a> c = decodeHexNibble ( c ) ; </a> 0
<a> final char c2 = decodeHexNibble ( s . charAt ( ++ i ) ) ; </a> 0
<a> if ( c == Character . MAX_VALUE || c2 == Character . MAX_VALUE ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "invalid escape sequence `%" + s . charAt ( i - 1 ) </a> 0
<a> + s . charAt ( i ) + "' at index " + ( i - 2 ) </a> 0
<a> + " of: " + s ) ; </a> 0
<a> } </a> 0
<a> c = ( char ) ( c * 16 + c2 ) ; </a> 0
<a> default : </a> 0
<a> buf [ pos ++ ] = ( byte ) c ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return new String ( buf , 0 , pos , charset ) ; </a> 0
<a> } </a> 0
<a> private static char decodeHexNibble ( final char c ) { </a> 0
<a> if ( '0' <= c && c <= '9' ) { </a> 0
<a> return ( char ) ( c - '0' ) ; </a> 0
<a> } else if ( 'a' <= c && c <= 'f' ) { </a> 0
<a> return ( char ) ( c - 'a' + 10 ) ; </a> 0
<a> } else if ( 'A' <= c && c <= 'F' ) { </a> 0
<a> return ( char ) ( c - 'A' + 10 ) ; </a> 0
<a> } else { </a> 0
<a> return Character . MAX_VALUE ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import java . io . UnsupportedEncodingException ; </a> 0
<a> import java . net . URI ; </a> 0
<a> import java . net . URISyntaxException ; </a> 0
<a> import java . net . URLEncoder ; </a> 0
<a> import java . nio . charset . Charset ; </a> 0
<a> import java . nio . charset . UnsupportedCharsetException ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> public class QueryStringEncoder { </a> 0
<a> private final Charset charset ; </a> 0
<a> private final String uri ; </a> 0
<a> private final List < Param > params = new ArrayList < Param > ( ) ; </a> 0
<a> public QueryStringEncoder ( String uri ) { </a> 0
<a> this ( uri , HttpConstants . DEFAULT_CHARSET ) ; </a> 0
<a> } </a> 0
<a> public QueryStringEncoder ( String uri , Charset charset ) { </a> 0
<a> if ( uri == null ) { </a> 0
<a> throw new NullPointerException ( "uri" ) ; </a> 1
<a> } </a> 0
<a> if ( charset == null ) { </a> 0
<a> throw new NullPointerException ( "charset" ) ; </a> 0
<a> } </a> 0
<a> this . uri = uri ; </a> 0
<a> this . charset = charset ; </a> 0
<a> } </a> 0
<a> public void addParam ( String name , String value ) { </a> 0
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( "value" ) ; </a> 0
<a> } </a> 0
<a> params . add ( new Param ( name , value ) ) ; </a> 0
<a> } </a> 0
<a> public URI toUri ( ) throws URISyntaxException { </a> 0
<a> return new URI ( toString ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> if ( params . isEmpty ( ) ) { </a> 0
<a> return uri ; </a> 0
<a> } else { </a> 0
<a> StringBuilder sb = new StringBuilder ( uri ) . append ( "?" ) ; </a> 0
<a> for ( int i = 0 ; i < params . size ( ) ; i ++ ) { </a> 0
<a> Param param = params . get ( i ) ; </a> 0
<a> sb . append ( encodeComponent ( param . name , charset ) ) ; </a> 0
<a> sb . append ( "=" ) ; </a> 0
<a> sb . append ( encodeComponent ( param . value , charset ) ) ; </a> 0
<a> if ( i != params . size ( ) - 1 ) { </a> 0
<a> sb . append ( "&" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return sb . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static String encodeComponent ( String s , Charset charset ) { </a> 0
<a> try { </a> 0
<a> return URLEncoder . encode ( s , charset . name ( ) ) . replaceAll ( "\\+" , "%20" ) ; </a> 0
<a> } catch ( UnsupportedEncodingException e ) { </a> 1
<a> throw new UnsupportedCharsetException ( charset . name ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static final class Param { </a> 0
<a> final String name ; </a> 0
<a> final String value ; </a> 0
<a> Param ( String name , String value ) { </a> 0
<a> this . value = value ; </a> 0
<a> this . name = name ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import static io . netty . handler . codec . http . CookieEncoderUtil . * ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . List ; </a> 0
<a> public final class ServerCookieEncoder { </a> 0
<a> public static String encode ( String name , String value ) { </a> 0
<a> return encode ( new DefaultCookie ( name , value ) ) ; </a> 0
<a> } </a> 0
<a> public static String encode ( Cookie cookie ) { </a> 0
<a> if ( cookie == null ) { </a> 0
<a> throw new NullPointerException ( "cookie" ) ; </a> 0
<a> } </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 0
<a> add ( buf , cookie . getName ( ) , cookie . getValue ( ) ) ; </a> 0
<a> if ( cookie . getMaxAge ( ) != Long . MIN_VALUE ) { </a> 1
<a> if ( cookie . getVersion ( ) == 0 ) { </a> 0
<a> addUnquoted ( buf , CookieHeaderNames . EXPIRES , </a> 0
<a> new HttpHeaderDateFormat ( ) . format ( </a> 0
<a> new Date ( System . currentTimeMillis ( ) + </a> 0
<a> cookie . getMaxAge ( ) * 1000L ) ) ) ; </a> 0
<a> } else { </a> 0
<a> add ( buf , CookieHeaderNames . MAX_AGE , cookie . getMaxAge ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( cookie . getPath ( ) != null ) { </a> 0
<a> if ( cookie . getVersion ( ) > 0 ) { </a> 0
<a> add ( buf , CookieHeaderNames . PATH , cookie . getPath ( ) ) ; </a> 0
<a> } else { </a> 0
<a> addUnquoted ( buf , CookieHeaderNames . PATH , cookie . getPath ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( cookie . getDomain ( ) != null ) { </a> 0
<a> if ( cookie . getVersion ( ) > 0 ) { </a> 0
<a> add ( buf , CookieHeaderNames . DOMAIN , cookie . getDomain ( ) ) ; </a> 0
<a> } else { </a> 0
<a> addUnquoted ( buf , CookieHeaderNames . DOMAIN , cookie . getDomain ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( cookie . isSecure ( ) ) { </a> 0
<a> buf . append ( CookieHeaderNames . SECURE ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . SEMICOLON ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . SP ) ; </a> 0
<a> } </a> 0
<a> if ( cookie . isHttpOnly ( ) ) { </a> 0
<a> buf . append ( CookieHeaderNames . HTTPONLY ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . SEMICOLON ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . SP ) ; </a> 0
<a> } </a> 0
<a> if ( cookie . getVersion ( ) >= 1 ) { </a> 0
<a> if ( cookie . getComment ( ) != null ) { </a> 0
<a> add ( buf , CookieHeaderNames . COMMENT , cookie . getComment ( ) ) ; </a> 0
<a> } </a> 0
<a> add ( buf , CookieHeaderNames . VERSION , 1 ) ; </a> 0
<a> if ( cookie . getCommentUrl ( ) != null ) { </a> 0
<a> addQuoted ( buf , CookieHeaderNames . COMMENTURL , cookie . getCommentUrl ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( ! cookie . getPorts ( ) . isEmpty ( ) ) { </a> 0
<a> buf . append ( CookieHeaderNames . PORT ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . EQUALS ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . DOUBLE_QUOTE ) ; </a> 0
<a> for ( int port : cookie . getPorts ( ) ) { </a> 0
<a> buf . append ( port ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . COMMA ) ; </a> 0
<a> } </a> 0
<a> buf . setCharAt ( buf . length ( ) - 1 , ( char ) HttpConstants . DOUBLE_QUOTE ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . SEMICOLON ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . SP ) ; </a> 0
<a> } </a> 0
<a> if ( cookie . isDiscard ( ) ) { </a> 0
<a> buf . append ( CookieHeaderNames . DISCARD ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . SEMICOLON ) ; </a> 0
<a> buf . append ( ( char ) HttpConstants . SP ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return stripTrailingSeparator ( buf ) ; </a> 0
<a> } </a> 0
<a> public static List < String > encode ( Cookie ... cookies ) { </a> 0
<a> if ( cookies == null ) { </a> 0
<a> throw new NullPointerException ( "cookies" ) ; </a> 0
<a> } </a> 0
<a> List < String > encoded = new ArrayList < String > ( cookies . length ) ; </a> 0
<a> for ( Cookie c : cookies ) { </a> 0
<a> if ( c == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> encoded . add ( encode ( c ) ) ; </a> 0
<a> } </a> 0
<a> return encoded ; </a> 0
<a> } </a> 0
<a> public static List < String > encode ( Collection < Cookie > cookies ) { </a> 0
<a> if ( cookies == null ) { </a> 0
<a> throw new NullPointerException ( "cookies" ) ; </a> 0
<a> } </a> 0
<a> List < String > encoded = new ArrayList < String > ( cookies . size ( ) ) ; </a> 0
<a> for ( Cookie c : cookies ) { </a> 0
<a> if ( c == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> encoded . add ( encode ( c ) ) ; </a> 0
<a> } </a> 0
<a> return encoded ; </a> 0
<a> } </a> 0
<a> public static List < String > encode ( Iterable < Cookie > cookies ) { </a> 0
<a> if ( cookies == null ) { </a> 0
<a> throw new NullPointerException ( "cookies" ) ; </a> 0
<a> } </a> 0
<a> List < String > encoded = new ArrayList < String > ( ) ; </a> 0
<a> for ( Cookie c : cookies ) { </a> 0
<a> if ( c == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> encoded . add ( encode ( c ) ) ; </a> 0
<a> } </a> 0
<a> return encoded ; </a> 0
<a> } </a> 0
<a> private ServerCookieEncoder ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> public class BinaryWebSocketFrame extends WebSocketFrame { </a> 0
<a> public BinaryWebSocketFrame ( ) { </a> 0
<a> setBinaryData ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> } </a> 0
<a> public BinaryWebSocketFrame ( ByteBuf binaryData ) { </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> } </a> 0
<a> public BinaryWebSocketFrame ( boolean finalFragment , int rsv , ByteBuf binaryData ) { </a> 0
<a> setFinalFragment ( finalFragment ) ; </a> 0
<a> setRsv ( rsv ) ; </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getClass ( ) . getSimpleName ( ) + "(data: " + getBinaryData ( ) + ')' ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class ContinuationWebSocketFrame extends WebSocketFrame { </a> 0
<a> private String aggregatedText ; </a> 0
<a> public ContinuationWebSocketFrame ( ) { </a> 0
<a> setBinaryData ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> } </a> 0
<a> public ContinuationWebSocketFrame ( ByteBuf binaryData ) { </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> } </a> 0
<a> public ContinuationWebSocketFrame ( boolean finalFragment , int rsv , ByteBuf binaryData ) { </a> 0
<a> setFinalFragment ( finalFragment ) ; </a> 0
<a> setRsv ( rsv ) ; </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> } </a> 0
<a> public ContinuationWebSocketFrame ( </a> 0
<a> boolean finalFragment , int rsv , ByteBuf binaryData , String aggregatedText ) { </a> 0
<a> setFinalFragment ( finalFragment ) ; </a> 0
<a> setRsv ( rsv ) ; </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> this . aggregatedText = aggregatedText ; </a> 0
<a> } </a> 0
<a> public ContinuationWebSocketFrame ( boolean finalFragment , int rsv , String text ) { </a> 0
<a> setFinalFragment ( finalFragment ) ; </a> 0
<a> setRsv ( rsv ) ; </a> 0
<a> setText ( text ) ; </a> 0
<a> } </a> 0
<a> public String getText ( ) { </a> 0
<a> if ( getBinaryData ( ) == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return getBinaryData ( ) . toString ( CharsetUtil . UTF_8 ) ; </a> 0
<a> } </a> 0
<a> public void setText ( String text ) { </a> 0
<a> if ( text == null || text . isEmpty ( ) ) { </a> 0
<a> setBinaryData ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> } else { </a> 0
<a> setBinaryData ( Unpooled . copiedBuffer ( text , CharsetUtil . UTF_8 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getClass ( ) . getSimpleName ( ) + "(data: " + getBinaryData ( ) + ')' ; </a> 0
<a> } </a> 0
<a> public String getAggregatedText ( ) { </a> 0
<a> return aggregatedText ; </a> 0
<a> } </a> 0
<a> public void setAggregatedText ( String aggregatedText ) { </a> 0
<a> this . aggregatedText = aggregatedText ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> public class PingWebSocketFrame extends WebSocketFrame { </a> 0
<a> public PingWebSocketFrame ( ) { </a> 0
<a> setFinalFragment ( true ) ; </a> 0
<a> setBinaryData ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> } </a> 0
<a> public PingWebSocketFrame ( ByteBuf binaryData ) { </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> } </a> 0
<a> public PingWebSocketFrame ( boolean finalFragment , int rsv , ByteBuf binaryData ) { </a> 0
<a> setFinalFragment ( finalFragment ) ; </a> 0
<a> setRsv ( rsv ) ; </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getClass ( ) . getSimpleName ( ) + "(data: " + getBinaryData ( ) + ')' ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> public class PongWebSocketFrame extends WebSocketFrame { </a> 0
<a> public PongWebSocketFrame ( ) { </a> 0
<a> setBinaryData ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> } </a> 0
<a> public PongWebSocketFrame ( ByteBuf binaryData ) { </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> } </a> 0
<a> public PongWebSocketFrame ( boolean finalFragment , int rsv , ByteBuf binaryData ) { </a> 0
<a> setFinalFragment ( finalFragment ) ; </a> 0
<a> setRsv ( rsv ) ; </a> 0
<a> setBinaryData ( binaryData ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getClass ( ) . getSimpleName ( ) + "(data: " + getBinaryData ( ) + ')' ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> final class UTF8Exception extends RuntimeException { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> UTF8Exception ( String reason ) { </a> 0
<a> super ( reason ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> final class UTF8Output { </a> 0
<a> private static final int UTF8_ACCEPT = 0 ; </a> 0
<a> private static final int UTF8_REJECT = 12 ; </a> 0
<a> private static final byte [ ] TYPES = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , </a> 0
<a> 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , </a> 0
<a> 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , </a> 0
<a> 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , </a> 0
<a> 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , </a> 0
<a> 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 7 , 7 , 7 , 7 , </a> 0
<a> 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 8 , </a> 0
<a> 8 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , </a> 0
<a> 2 , 2 , 10 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 4 , 3 , 3 , 11 , 6 , 6 , 6 , 5 , 8 , 8 , 8 , 8 , 8 , </a> 0
<a> 8 , 8 , 8 , 8 , 8 , 8 } ; </a> 0
<a> private static final byte [ ] STATES = { 0 , 12 , 24 , 36 , 60 , 96 , 84 , 12 , 12 , 12 , 48 , 72 , 12 , 12 , </a> 0
<a> 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 0 , 12 , 12 , 12 , 12 , 12 , 0 , 12 , 0 , 12 , 12 , </a> 0
<a> 12 , 24 , 12 , 12 , 12 , 12 , 12 , 24 , 12 , 24 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 24 , 12 , 12 , </a> 0
<a> 12 , 12 , 12 , 24 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 24 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 36 , </a> 0
<a> 12 , 36 , 12 , 12 , 12 , 36 , 12 , 12 , 12 , 12 , 12 , 36 , 12 , 36 , 12 , 12 , 12 , 36 , 12 , 12 , 12 , 12 , </a> 0
<a> 12 , 12 , 12 , 12 , 12 , 12 } ; </a> 0
<a> private int state = UTF8_ACCEPT ; </a> 0
<a> private int codep ; </a> 0
<a> private final StringBuilder stringBuilder ; </a> 0
<a> UTF8Output ( byte [ ] bytes ) { </a> 0
<a> stringBuilder = new StringBuilder ( bytes . length ) ; </a> 0
<a> write ( bytes ) ; </a> 0
<a> } </a> 0
<a> public void write ( byte [ ] bytes ) { </a> 0
<a> for ( byte b : bytes ) { </a> 0
<a> write ( b ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void write ( int b ) { </a> 0
<a> byte type = TYPES [ b & 0xFF ] ; </a> 0
<a> codep = state != UTF8_ACCEPT ? b & 0x3f | codep < < 6 : 0xff > > type & b ; </a> 0
<a> state = STATES [ state + type ] ; </a> 0
<a> if ( state == UTF8_ACCEPT ) { </a> 0
<a> stringBuilder . append ( ( char ) codep ) ; </a> 0
<a> } else if ( state == UTF8_REJECT ) { </a> 0
<a> throw new UTF8Exception ( "bytes are not UTF-8" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> if ( state != UTF8_ACCEPT ) { </a> 0
<a> throw new UTF8Exception ( "bytes are not UTF-8" ) ; </a> 0
<a> } </a> 0
<a> return stringBuilder . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . MessageToByteEncoder ; </a> 0
<a> @ Sharable </a> 0
<a> public class WebSocket00FrameEncoder extends MessageToByteEncoder < WebSocketFrame > { </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof WebSocketFrame ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( </a> 0
<a> ChannelHandlerContext ctx , </a> 0
<a> WebSocketFrame msg , ByteBuf out ) throws Exception { </a> 0
<a> if ( msg instanceof TextWebSocketFrame ) { </a> 0
<a> ByteBuf data = msg . getBinaryData ( ) ; </a> 0
<a> out . writeByte ( ( byte ) 0x00 ) ; </a> 0
<a> out . writeBytes ( data , data . readerIndex ( ) , data . readableBytes ( ) ) ; </a> 0
<a> out . writeByte ( ( byte ) 0xFF ) ; </a> 0
<a> } else if ( msg instanceof CloseWebSocketFrame ) { </a> 0
<a> out . writeByte ( ( byte ) 0xFF ) ; </a> 0
<a> out . writeByte ( ( byte ) 0x00 ) ; </a> 0
<a> } else { </a> 0
<a> ByteBuf data = msg . getBinaryData ( ) ; </a> 0
<a> int dataLen = data . readableBytes ( ) ; </a> 0
<a> out . ensureWritableBytes ( dataLen + 5 ) ; </a> 0
<a> out . writeByte ( ( byte ) 0x80 ) ; </a> 0
<a> int b1 = dataLen > > > 28 & 0x7F ; </a> 0
<a> int b2 = dataLen > > > 14 & 0x7F ; </a> 0
<a> int b3 = dataLen > > > 7 & 0x7F ; </a> 0
<a> int b4 = dataLen & 0x7F ; </a> 0
<a> if ( b1 == 0 ) { </a> 0
<a> if ( b2 == 0 ) { </a> 0
<a> if ( b3 == 0 ) { </a> 0
<a> out . writeByte ( b4 ) ; </a> 0
<a> } else { </a> 0
<a> out . writeByte ( b3 | 0x80 ) ; </a> 0
<a> out . writeByte ( b4 ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> out . writeByte ( b2 | 0x80 ) ; </a> 0
<a> out . writeByte ( b3 | 0x80 ) ; </a> 0
<a> out . writeByte ( b4 ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> out . writeByte ( b1 | 0x80 ) ; </a> 0
<a> out . writeByte ( b2 | 0x80 ) ; </a> 0
<a> out . writeByte ( b3 | 0x80 ) ; </a> 0
<a> out . writeByte ( b4 ) ; </a> 0
<a> } </a> 0
<a> out . writeBytes ( data , data . readerIndex ( ) , dataLen ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . MessageToByteEncoder ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> public class WebSocket08FrameEncoder extends MessageToByteEncoder < WebSocketFrame > { </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocket08FrameEncoder . class ) ; </a> 0
<a> private static final byte OPCODE_CONT = 0x0 ; </a> 0
<a> private static final byte OPCODE_TEXT = 0x1 ; </a> 0
<a> private static final byte OPCODE_BINARY = 0x2 ; </a> 0
<a> private static final byte OPCODE_CLOSE = 0x8 ; </a> 0
<a> private static final byte OPCODE_PING = 0x9 ; </a> 0
<a> private static final byte OPCODE_PONG = 0xA ; </a> 0
<a> private final boolean maskPayload ; </a> 0
<a> public WebSocket08FrameEncoder ( boolean maskPayload ) { </a> 0
<a> this . maskPayload = maskPayload ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof WebSocketFrame ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( ChannelHandlerContext ctx , </a> 0
<a> WebSocketFrame msg , ByteBuf out ) throws Exception { </a> 0
<a> byte [ ] mask ; </a> 0
<a> ByteBuf data = msg . getBinaryData ( ) ; </a> 0
<a> if ( data == null ) { </a> 1
<a> data = Unpooled . EMPTY_BUFFER ; </a> 1
<a> } </a> 1
<a> byte opcode ; </a> 0
<a> if ( msg instanceof TextWebSocketFrame ) { </a> 0
<a> opcode = OPCODE_TEXT ; </a> 0
<a> } else if ( msg instanceof PingWebSocketFrame ) { </a> 0
<a> opcode = OPCODE_PING ; </a> 0
<a> } else if ( msg instanceof PongWebSocketFrame ) { </a> 0
<a> opcode = OPCODE_PONG ; </a> 0
<a> } else if ( msg instanceof CloseWebSocketFrame ) { </a> 0
<a> opcode = OPCODE_CLOSE ; </a> 0
<a> } else if ( msg instanceof BinaryWebSocketFrame ) { </a> 0
<a> opcode = OPCODE_BINARY ; </a> 0
<a> } else if ( msg instanceof ContinuationWebSocketFrame ) { </a> 0
<a> opcode = OPCODE_CONT ; </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( "Cannot encode frame of type: " + msg . getClass ( ) . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> int length = data . readableBytes ( ) ; </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( "Encoding WebSocket Frame opCode=" + opcode + " length=" + length ) ; </a> 0
<a> } </a> 0
<a> int b0 = 0 ; </a> 0
<a> if ( msg . isFinalFragment ( ) ) { </a> 0
<a> b0 |= 1 < < 7 ; </a> 0
<a> } </a> 0
<a> b0 |= msg . getRsv ( ) % 8 < < 4 ; </a> 0
<a> b0 |= opcode % 128 ; </a> 0
<a> if ( opcode == OPCODE_PING && length > 125 ) { </a> 0
<a> throw new TooLongFrameException ( "invalid payload for PING (payload length must be <= 125, was " </a> 0
<a> + length ) ; </a> 0
<a> } </a> 0
<a> int maskLength = maskPayload ? 4 : 0 ; </a> 0
<a> if ( length <= 125 ) { </a> 0
<a> out . ensureWritableBytes ( 2 + maskLength + length ) ; </a> 0
<a> out . writeByte ( b0 ) ; </a> 0
<a> byte b = ( byte ) ( maskPayload ? 0x80 | ( byte ) length : ( byte ) length ) ; </a> 0
<a> out . writeByte ( b ) ; </a> 0
<a> } else if ( length <= 0xFFFF ) { </a> 0
<a> out . ensureWritableBytes ( 4 + maskLength + length ) ; </a> 0
<a> out . writeByte ( b0 ) ; </a> 0
<a> out . writeByte ( maskPayload ? 0xFE : 126 ) ; </a> 0
<a> out . writeByte ( length > > > 8 & 0xFF ) ; </a> 0
<a> out . writeByte ( length & 0xFF ) ; </a> 0
<a> } else { </a> 0
<a> out . ensureWritableBytes ( 10 + maskLength + length ) ; </a> 0
<a> out . writeByte ( b0 ) ; </a> 0
<a> out . writeByte ( maskPayload ? 0xFF : 127 ) ; </a> 0
<a> out . writeLong ( length ) ; </a> 0
<a> } </a> 0
<a> if ( maskPayload ) { </a> 0
<a> int random = ( int ) ( Math . random ( ) * Integer . MAX_VALUE ) ; </a> 0
<a> mask = ByteBuffer . allocate ( 4 ) . putInt ( random ) . array ( ) ; </a> 0
<a> out . writeBytes ( mask ) ; </a> 0
<a> int counter = 0 ; </a> 0
<a> for ( int i = data . readerIndex ( ) ; i < data . writerIndex ( ) ; i ++ ) { </a> 0
<a> byte byteData = data . getByte ( i ) ; </a> 0
<a> out . writeByte ( byteData ^ mask [ + counter ++ % 4 ] ) ; </a> 1
<a> } </a> 0
<a> } else { </a> 0
<a> out . writeBytes ( data , data . readerIndex ( ) , data . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> public class WebSocket13FrameDecoder extends WebSocket08FrameDecoder { </a> 0
<a> public WebSocket13FrameDecoder ( boolean maskedPayload , boolean allowExtensions , int maxFramePayloadLength ) { </a> 0
<a> super ( maskedPayload , allowExtensions , maxFramePayloadLength ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> public class WebSocket13FrameEncoder extends WebSocket08FrameEncoder { </a> 0
<a> public WebSocket13FrameEncoder ( boolean maskPayload ) { </a> 0
<a> super ( maskPayload ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import java . net . URI ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public abstract class WebSocketClientHandshaker { </a> 0
<a> private final URI webSocketUrl ; </a> 0
<a> private final WebSocketVersion version ; </a> 0
<a> private boolean handshakeComplete ; </a> 1
<a> private final String expectedSubprotocol ; </a> 0
<a> private String actualSubprotocol ; </a> 1
<a> protected final Map < String , String > customHeaders ; </a> 0
<a> private final int maxFramePayloadLength ; </a> 0
<a> public WebSocketClientHandshaker ( URI webSocketUrl , WebSocketVersion version , String subprotocol , </a> 0
<a> Map < String , String > customHeaders , int maxFramePayloadLength ) { </a> 0
<a> this . webSocketUrl = webSocketUrl ; </a> 0
<a> this . version = version ; </a> 0
<a> expectedSubprotocol = subprotocol ; </a> 0
<a> this . customHeaders = customHeaders ; </a> 0
<a> this . maxFramePayloadLength = maxFramePayloadLength ; </a> 0
<a> } </a> 0
<a> public URI getWebSocketUrl ( ) { </a> 0
<a> return webSocketUrl ; </a> 0
<a> } </a> 0
<a> public WebSocketVersion getVersion ( ) { </a> 0
<a> return version ; </a> 0
<a> } </a> 0
<a> public int getMaxFramePayloadLength ( ) { </a> 0
<a> return maxFramePayloadLength ; </a> 0
<a> } </a> 0
<a> public boolean isHandshakeComplete ( ) { </a> 0
<a> return handshakeComplete ; </a> 0
<a> } </a> 0
<a> protected void setHandshakeComplete ( ) { </a> 1
<a> handshakeComplete = true ; </a> 0
<a> } </a> 0
<a> public String getExpectedSubprotocol ( ) { </a> 0
<a> return expectedSubprotocol ; </a> 0
<a> } </a> 0
<a> public String getActualSubprotocol ( ) { </a> 0
<a> return actualSubprotocol ; </a> 0
<a> } </a> 0
<a> protected void setActualSubprotocol ( String actualSubprotocol ) { </a> 1
<a> this . actualSubprotocol = actualSubprotocol ; </a> 0
<a> } </a> 0
<a> public abstract ChannelFuture handshake ( Channel channel ) ; </a> 1
<a> public abstract void finishHandshake ( Channel channel , HttpResponse response ) ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . Channel ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 1
<a> import io . netty . handler . codec . http . DefaultHttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpHeaders . Names ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders . Values ; </a> 0
<a> import io . netty . handler . codec . http . HttpMethod ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpRequestEncoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseDecoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseStatus ; </a> 0
<a> import io . netty . handler . codec . http . HttpVersion ; </a> 0
<a> import java . net . URI ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . util . Arrays ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class WebSocketClientHandshaker00 extends WebSocketClientHandshaker { </a> 0
<a> private byte [ ] expectedChallengeResponseBytes ; </a> 0
<a> public WebSocketClientHandshaker00 ( URI webSocketURL , WebSocketVersion version , String subprotocol , </a> 0
<a> Map < String , String > customHeaders , int maxFramePayloadLength ) { </a> 0
<a> super ( webSocketURL , version , subprotocol , customHeaders , maxFramePayloadLength ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture handshake ( Channel channel ) { </a> 1
<a> int spaces1 = WebSocketUtil . randomNumber ( 1 , 12 ) ; </a> 0
<a> int spaces2 = WebSocketUtil . randomNumber ( 1 , 12 ) ; </a> 0
<a> int max1 = Integer . MAX_VALUE / spaces1 ; </a> 0
<a> int max2 = Integer . MAX_VALUE / spaces2 ; </a> 0
<a> int number1 = WebSocketUtil . randomNumber ( 0 , max1 ) ; </a> 0
<a> int number2 = WebSocketUtil . randomNumber ( 0 , max2 ) ; </a> 0
<a> int product1 = number1 * spaces1 ; </a> 0
<a> int product2 = number2 * spaces2 ; </a> 0
<a> String key1 = Integer . toString ( product1 ) ; </a> 0
<a> String key2 = Integer . toString ( product2 ) ; </a> 0
<a> key1 = insertRandomCharacters ( key1 ) ; </a> 0
<a> key2 = insertRandomCharacters ( key2 ) ; </a> 0
<a> key1 = insertSpaces ( key1 , spaces1 ) ; </a> 0
<a> key2 = insertSpaces ( key2 , spaces2 ) ; </a> 0
<a> byte [ ] key3 = WebSocketUtil . randomBytes ( 8 ) ; </a> 0
<a> ByteBuffer buffer = ByteBuffer . allocate ( 4 ) ; </a> 0
<a> buffer . putInt ( number1 ) ; </a> 0
<a> byte [ ] number1Array = buffer . array ( ) ; </a> 0
<a> buffer = ByteBuffer . allocate ( 4 ) ; </a> 0
<a> buffer . putInt ( number2 ) ; </a> 0
<a> byte [ ] number2Array = buffer . array ( ) ; </a> 0
<a> byte [ ] challenge = new byte [ 16 ] ; </a> 0
<a> System . arraycopy ( number1Array , 0 , challenge , 0 , 4 ) ; </a> 0
<a> System . arraycopy ( number2Array , 0 , challenge , 4 , 4 ) ; </a> 0
<a> System . arraycopy ( key3 , 0 , challenge , 8 , 8 ) ; </a> 0
<a> expectedChallengeResponseBytes = WebSocketUtil . md5 ( challenge ) ; </a> 0
<a> URI wsURL = getWebSocketUrl ( ) ; </a> 0
<a> String path = wsURL . getPath ( ) ; </a> 0
<a> if ( wsURL . getQuery ( ) != null && wsURL . getQuery ( ) . length ( ) > 0 ) { </a> 0
<a> path = wsURL . getPath ( ) + "?" + wsURL . getQuery ( ) ; </a> 0
<a> } </a> 0
<a> HttpRequest request = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , path ) ; </a> 1
<a> request . addHeader ( Names . UPGRADE , Values . WEBSOCKET ) ; </a> 1
<a> request . addHeader ( Names . CONNECTION , Values . UPGRADE ) ; </a> 1
<a> request . addHeader ( Names . HOST , wsURL . getHost ( ) ) ; </a> 1
<a> int wsPort = wsURL . getPort ( ) ; </a> 0
<a> String originValue = "http://" + wsURL . getHost ( ) ; </a> 0
<a> if ( wsPort != 80 && wsPort != 443 ) { </a> 0
<a> originValue = originValue + ":" + wsPort ; </a> 0
<a> } </a> 0
<a> request . addHeader ( Names . ORIGIN , originValue ) ; </a> 1
<a> request . addHeader ( Names . SEC_WEBSOCKET_KEY1 , key1 ) ; </a> 1
<a> request . addHeader ( Names . SEC_WEBSOCKET_KEY2 , key2 ) ; </a> 1
<a> String expectedSubprotocol = getExpectedSubprotocol ( ) ; </a> 0
<a> if ( expectedSubprotocol != null && ! expectedSubprotocol . equals ( "" ) ) { </a> 0
<a> request . addHeader ( Names . SEC_WEBSOCKET_PROTOCOL , expectedSubprotocol ) ; </a> 1
<a> } </a> 0
<a> if ( customHeaders != null ) { </a> 0
<a> for ( String header : customHeaders . keySet ( ) ) { </a> 0
<a> request . addHeader ( header , customHeaders . get ( header ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> request . setContent ( Unpooled . copiedBuffer ( key3 ) ) ; </a> 1
<a> ChannelFuture future = channel . write ( request ) ; </a> 1
<a> channel . pipeline ( ) . replace ( HttpRequestEncoder . class , "ws-encoder" , new WebSocket00FrameEncoder ( ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void finishHandshake ( Channel channel , HttpResponse response ) throws WebSocketHandshakeException { </a> 0
<a> final HttpResponseStatus status = new HttpResponseStatus ( 101 , "WebSocket Protocol Handshake" ) ; </a> 0
<a> if ( ! response . getStatus ( ) . equals ( status ) ) { </a> 1
<a> throw new WebSocketHandshakeException ( "Invalid handshake response status: " + response . getStatus ( ) ) ; </a> 1
<a> } </a> 0
<a> String upgrade = response . getHeader ( Names . UPGRADE ) ; </a> 1
<a> if ( upgrade == null || ! upgrade . equalsIgnoreCase ( Values . WEBSOCKET ) ) { </a> 0
<a> throw new WebSocketHandshakeException ( "Invalid handshake response upgrade: " </a> 0
<a> + response . getHeader ( Names . UPGRADE ) ) ; </a> 1
<a> } </a> 0
<a> String connection = response . getHeader ( Names . CONNECTION ) ; </a> 1
<a> if ( connection == null || ! connection . equalsIgnoreCase ( Values . UPGRADE ) ) { </a> 0
<a> throw new WebSocketHandshakeException ( "Invalid handshake response connection: " </a> 0
<a> + response . getHeader ( Names . CONNECTION ) ) ; </a> 1
<a> } </a> 0
<a> byte [ ] challenge = response . getContent ( ) . array ( ) ; </a> 1
<a> if ( ! Arrays . equals ( challenge , expectedChallengeResponseBytes ) ) { </a> 0
<a> throw new WebSocketHandshakeException ( "Invalid challenge" ) ; </a> 0
<a> } </a> 0
<a> String subprotocol = response . getHeader ( Names . SEC_WEBSOCKET_PROTOCOL ) ; </a> 1
<a> setActualSubprotocol ( subprotocol ) ; </a> 1
<a> setHandshakeComplete ( ) ; </a> 1
<a> channel . pipeline ( ) . get ( HttpResponseDecoder . class ) . replace ( </a> 1
<a> "ws-decoder" , new WebSocket00FrameDecoder ( getMaxFramePayloadLength ( ) ) ) ; </a> 0
<a> } </a> 0
<a> private static String insertRandomCharacters ( String key ) { </a> 0
<a> int count = WebSocketUtil . randomNumber ( 1 , 12 ) ; </a> 0
<a> char [ ] randomChars = new char [ count ] ; </a> 0
<a> int randCount = 0 ; </a> 0
<a> while ( randCount < count ) { </a> 0
<a> int rand = ( int ) ( Math . random ( ) * 0x7e + 0x21 ) ; </a> 0
<a> if ( 0x21 < rand && rand < 0x2f || 0x3a < rand && rand < 0x7e ) { </a> 0
<a> randomChars [ randCount ] = ( char ) rand ; </a> 0
<a> randCount += 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < count ; i ++ ) { </a> 0
<a> int split = WebSocketUtil . randomNumber ( 0 , key . length ( ) ) ; </a> 0
<a> String part1 = key . substring ( 0 , split ) ; </a> 0
<a> String part2 = key . substring ( split ) ; </a> 0
<a> key = part1 + randomChars [ i ] + part2 ; </a> 0
<a> } </a> 0
<a> return key ; </a> 0
<a> } </a> 0
<a> private static String insertSpaces ( String key , int spaces ) { </a> 0
<a> for ( int i = 0 ; i < spaces ; i ++ ) { </a> 0
<a> int split = WebSocketUtil . randomNumber ( 1 , key . length ( ) - 1 ) ; </a> 0
<a> String part1 = key . substring ( 0 , split ) ; </a> 0
<a> String part2 = key . substring ( split ) ; </a> 0
<a> key = part1 + " " + part2 ; </a> 0
<a> } </a> 0
<a> return key ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . channel . Channel ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 1
<a> import io . netty . handler . codec . http . DefaultHttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpHeaders . Names ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders . Values ; </a> 0
<a> import io . netty . handler . codec . http . HttpMethod ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpRequestEncoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseDecoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseStatus ; </a> 0
<a> import io . netty . handler . codec . http . HttpVersion ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . net . URI ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class WebSocketClientHandshaker08 extends WebSocketClientHandshaker { </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocketClientHandshaker08 . class ) ; </a> 0
<a> public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; </a> 0
<a> private String expectedChallengeResponseString ; </a> 0
<a> private final boolean allowExtensions ; </a> 0
<a> public WebSocketClientHandshaker08 ( URI webSocketURL , WebSocketVersion version , String subprotocol , </a> 0
<a> boolean allowExtensions , Map < String , String > customHeaders , int maxFramePayloadLength ) { </a> 0
<a> super ( webSocketURL , version , subprotocol , customHeaders , maxFramePayloadLength ) ; </a> 0
<a> this . allowExtensions = allowExtensions ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture handshake ( Channel channel ) { </a> 1
<a> URI wsURL = getWebSocketUrl ( ) ; </a> 0
<a> String path = wsURL . getPath ( ) ; </a> 0
<a> if ( wsURL . getQuery ( ) != null && wsURL . getQuery ( ) . length ( ) > 0 ) { </a> 0
<a> path = wsURL . getPath ( ) + "?" + wsURL . getQuery ( ) ; </a> 0
<a> } </a> 0
<a> byte [ ] nonce = WebSocketUtil . randomBytes ( 16 ) ; </a> 0
<a> String key = WebSocketUtil . base64 ( nonce ) ; </a> 0
<a> String acceptSeed = key + MAGIC_GUID ; </a> 0
<a> byte [ ] sha1 = WebSocketUtil . sha1 ( acceptSeed . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 0
<a> expectedChallengeResponseString = WebSocketUtil . base64 ( sha1 ) ; </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( String . format ( "WS Version 08 Client Handshake key: %s. Expected response: %s." , key , </a> 0
<a> expectedChallengeResponseString ) ) ; </a> 0
<a> } </a> 0
<a> HttpRequest request = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , path ) ; </a> 0
<a> request . addHeader ( Names . UPGRADE , Values . WEBSOCKET . toLowerCase ( ) ) ; </a> 0
<a> request . addHeader ( Names . CONNECTION , Values . UPGRADE ) ; </a> 0
<a> request . addHeader ( Names . SEC_WEBSOCKET_KEY , key ) ; </a> 0
<a> request . addHeader ( Names . HOST , wsURL . getHost ( ) ) ; </a> 0
<a> int wsPort = wsURL . getPort ( ) ; </a> 0
<a> String originValue = "http://" + wsURL . getHost ( ) ; </a> 0
<a> if ( wsPort != 80 && wsPort != 443 ) { </a> 0
<a> originValue = originValue + ":" + wsPort ; </a> 0
<a> } </a> 0
<a> request . addHeader ( Names . SEC_WEBSOCKET_ORIGIN , originValue ) ; </a> 1
<a> String expectedSubprotocol = getExpectedSubprotocol ( ) ; </a> 0
<a> if ( expectedSubprotocol != null && ! expectedSubprotocol . equals ( "" ) ) { </a> 0
<a> request . addHeader ( Names . SEC_WEBSOCKET_PROTOCOL , expectedSubprotocol ) ; </a> 1
<a> } </a> 0
<a> request . addHeader ( Names . SEC_WEBSOCKET_VERSION , "8" ) ; </a> 1
<a> if ( customHeaders != null ) { </a> 0
<a> for ( String header : customHeaders . keySet ( ) ) { </a> 0
<a> request . addHeader ( header , customHeaders . get ( header ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ChannelFuture future = channel . write ( request ) ; </a> 1
<a> channel . pipeline ( ) . replace ( HttpRequestEncoder . class , "ws-encoder" , new WebSocket08FrameEncoder ( true ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void finishHandshake ( Channel channel , HttpResponse response ) { </a> 1
<a> final HttpResponseStatus status = HttpResponseStatus . SWITCHING_PROTOCOLS ; </a> 0
<a> if ( ! response . getStatus ( ) . equals ( status ) ) { </a> 1
<a> throw new WebSocketHandshakeException ( "Invalid handshake response status: " + response . getStatus ( ) ) ; </a> 1
<a> } </a> 0
<a> String upgrade = response . getHeader ( Names . UPGRADE ) ; </a> 1
<a> if ( upgrade == null || ! upgrade . equalsIgnoreCase ( Values . WEBSOCKET ) ) { </a> 0
<a> throw new WebSocketHandshakeException ( "Invalid handshake response upgrade: " </a> 0
<a> + response . getHeader ( Names . UPGRADE ) ) ; </a> 1
<a> } </a> 0
<a> String connection = response . getHeader ( Names . CONNECTION ) ; </a> 1
<a> if ( connection == null || ! connection . equalsIgnoreCase ( Values . UPGRADE ) ) { </a> 0
<a> throw new WebSocketHandshakeException ( "Invalid handshake response connection: " </a> 0
<a> + response . getHeader ( Names . CONNECTION ) ) ; </a> 1
<a> } </a> 0
<a> String accept = response . getHeader ( Names . SEC_WEBSOCKET_ACCEPT ) ; </a> 1
<a> if ( accept == null || ! accept . equals ( expectedChallengeResponseString ) ) { </a> 0
<a> throw new WebSocketHandshakeException ( String . format ( "Invalid challenge. Actual: %s. Expected: %s" , accept , </a> 0
<a> expectedChallengeResponseString ) ) ; </a> 0
<a> } </a> 0
<a> String subprotocol = response . getHeader ( Names . SEC_WEBSOCKET_PROTOCOL ) ; </a> 1
<a> setActualSubprotocol ( subprotocol ) ; </a> 1
<a> setHandshakeComplete ( ) ; </a> 1
<a> channel . pipeline ( ) . get ( HttpResponseDecoder . class ) . replace ( </a> 1
<a> "ws-decoder" , </a> 1
<a> new WebSocket08FrameDecoder ( false , allowExtensions , getMaxFramePayloadLength ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . channel . Channel ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 1
<a> import io . netty . handler . codec . http . DefaultHttpRequest ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders . Names ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders . Values ; </a> 0
<a> import io . netty . handler . codec . http . HttpMethod ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequestEncoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseDecoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseStatus ; </a> 0
<a> import io . netty . handler . codec . http . HttpVersion ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . net . URI ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class WebSocketClientHandshaker13 extends WebSocketClientHandshaker { </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocketClientHandshaker13 . class ) ; </a> 0
<a> public static final String MAGIC_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; </a> 0
<a> private String expectedChallengeResponseString ; </a> 0
<a> private final boolean allowExtensions ; </a> 0
<a> public WebSocketClientHandshaker13 ( URI webSocketURL , WebSocketVersion version , String subprotocol , </a> 0
<a> boolean allowExtensions , Map < String , String > customHeaders , int maxFramePayloadLength ) { </a> 0
<a> super ( webSocketURL , version , subprotocol , customHeaders , maxFramePayloadLength ) ; </a> 0
<a> this . allowExtensions = allowExtensions ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture handshake ( Channel channel ) { </a> 1
<a> URI wsURL = getWebSocketUrl ( ) ; </a> 0
<a> String path = wsURL . getPath ( ) ; </a> 0
<a> if ( wsURL . getQuery ( ) != null && wsURL . getQuery ( ) . length ( ) > 0 ) { </a> 0
<a> path = wsURL . getPath ( ) + "?" + wsURL . getQuery ( ) ; </a> 0
<a> } </a> 0
<a> byte [ ] nonce = WebSocketUtil . randomBytes ( 16 ) ; </a> 0
<a> String key = WebSocketUtil . base64 ( nonce ) ; </a> 0
<a> String acceptSeed = key + MAGIC_GUID ; </a> 0
<a> byte [ ] sha1 = WebSocketUtil . sha1 ( acceptSeed . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 0
<a> expectedChallengeResponseString = WebSocketUtil . base64 ( sha1 ) ; </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( String . format ( "WS Version 13 Client Handshake key: %s. Expected response: %s." , key , </a> 0
<a> expectedChallengeResponseString ) ) ; </a> 0
<a> } </a> 0
<a> HttpRequest request = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , path ) ; </a> 1
<a> request . addHeader ( Names . UPGRADE , Values . WEBSOCKET . toLowerCase ( ) ) ; </a> 1
<a> request . addHeader ( Names . CONNECTION , Values . UPGRADE ) ; </a> 1
<a> request . addHeader ( Names . SEC_WEBSOCKET_KEY , key ) ; </a> 1
<a> request . addHeader ( Names . HOST , wsURL . getHost ( ) ) ; </a> 1
<a> int wsPort = wsURL . getPort ( ) ; </a> 0
<a> String originValue = "http://" + wsURL . getHost ( ) ; </a> 0
<a> if ( wsPort != 80 && wsPort != 443 ) { </a> 0
<a> originValue = originValue + ":" + wsPort ; </a> 0
<a> } </a> 0
<a> request . addHeader ( Names . SEC_WEBSOCKET_ORIGIN , originValue ) ; </a> 1
<a> String expectedSubprotocol = getExpectedSubprotocol ( ) ; </a> 0
<a> if ( expectedSubprotocol != null && ! expectedSubprotocol . equals ( "" ) ) { </a> 0
<a> request . addHeader ( Names . SEC_WEBSOCKET_PROTOCOL , expectedSubprotocol ) ; </a> 1
<a> } </a> 0
<a> request . addHeader ( Names . SEC_WEBSOCKET_VERSION , "13" ) ; </a> 1
<a> if ( customHeaders != null ) { </a> 0
<a> for ( String header : customHeaders . keySet ( ) ) { </a> 0
<a> request . addHeader ( header , customHeaders . get ( header ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ChannelFuture future = channel . write ( request ) ; </a> 1
<a> channel . pipeline ( ) . replace ( HttpRequestEncoder . class , "ws-encoder" , new WebSocket13FrameEncoder ( true ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void finishHandshake ( Channel channel , HttpResponse response ) throws WebSocketHandshakeException { </a> 0
<a> final HttpResponseStatus status = HttpResponseStatus . SWITCHING_PROTOCOLS ; </a> 0
<a> if ( ! response . getStatus ( ) . equals ( status ) ) { </a> 1
<a> throw new WebSocketHandshakeException ( "Invalid handshake response status: " + response . getStatus ( ) ) ; </a> 1
<a> } </a> 0
<a> String upgrade = response . getHeader ( Names . UPGRADE ) ; </a> 1
<a> if ( upgrade == null || ! upgrade . equalsIgnoreCase ( Values . WEBSOCKET ) ) { </a> 0
<a> throw new WebSocketHandshakeException ( "Invalid handshake response upgrade: " </a> 0
<a> + response . getHeader ( Names . UPGRADE ) ) ; </a> 1
<a> } </a> 0
<a> String connection = response . getHeader ( Names . CONNECTION ) ; </a> 1
<a> if ( connection == null || ! connection . equalsIgnoreCase ( Values . UPGRADE ) ) { </a> 0
<a> throw new WebSocketHandshakeException ( "Invalid handshake response connection: " </a> 0
<a> + response . getHeader ( Names . CONNECTION ) ) ; </a> 1
<a> } </a> 0
<a> String accept = response . getHeader ( Names . SEC_WEBSOCKET_ACCEPT ) ; </a> 1
<a> if ( accept == null || ! accept . equals ( expectedChallengeResponseString ) ) { </a> 0
<a> throw new WebSocketHandshakeException ( String . format ( "Invalid challenge. Actual: %s. Expected: %s" , accept , </a> 0
<a> expectedChallengeResponseString ) ) ; </a> 0
<a> } </a> 0
<a> String subprotocol = response . getHeader ( Names . SEC_WEBSOCKET_PROTOCOL ) ; </a> 1
<a> setActualSubprotocol ( subprotocol ) ; </a> 1
<a> setHandshakeComplete ( ) ; </a> 1
<a> channel . pipeline ( ) . get ( HttpResponseDecoder . class ) . replace ( </a> 1
<a> "ws-decoder" , </a> 1
<a> new WebSocket13FrameDecoder ( false , allowExtensions , getMaxFramePayloadLength ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import java . net . URI ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class WebSocketClientHandshakerFactory { </a> 0
<a> public WebSocketClientHandshaker newHandshaker ( </a> 0
<a> URI webSocketURL , WebSocketVersion version , String subprotocol , </a> 0
<a> boolean allowExtensions , Map < String , String > customHeaders ) { </a> 0
<a> return newHandshaker ( webSocketURL , version , subprotocol , allowExtensions , customHeaders , 65536 ) ; </a> 0
<a> } </a> 0
<a> public WebSocketClientHandshaker newHandshaker ( </a> 0
<a> URI webSocketURL , WebSocketVersion version , String subprotocol , </a> 0
<a> boolean allowExtensions , Map < String , String > customHeaders , int maxFramePayloadLength ) { </a> 0
<a> if ( version == WebSocketVersion . V13 ) { </a> 0
<a> return new WebSocketClientHandshaker13 ( </a> 0
<a> webSocketURL , version , subprotocol , allowExtensions , customHeaders , maxFramePayloadLength ) ; </a> 0
<a> } </a> 0
<a> if ( version == WebSocketVersion . V08 ) { </a> 0
<a> return new WebSocketClientHandshaker08 ( </a> 0
<a> webSocketURL , version , subprotocol , allowExtensions , customHeaders , maxFramePayloadLength ) ; </a> 0
<a> } </a> 0
<a> if ( version == WebSocketVersion . V00 ) { </a> 0
<a> return new WebSocketClientHandshaker00 ( </a> 0
<a> webSocketURL , version , subprotocol , customHeaders , maxFramePayloadLength ) ; </a> 0
<a> } </a> 0
<a> throw new WebSocketHandshakeException ( "Protocol version " + version . toString ( ) + " not supported." ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> public enum WebSocketFrameType { </a> 0
<a> TEXT , BINARY , PING , PONG , CLOSE , CONTINUATION </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> public class WebSocketHandshakeException extends RuntimeException { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> public WebSocketHandshakeException ( String s ) { </a> 0
<a> super ( s ) ; </a> 0
<a> } </a> 0
<a> public WebSocketHandshakeException ( String s , Throwable throwable ) { </a> 0
<a> super ( s , throwable ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . LinkedHashSet ; </a> 0
<a> import java . util . Set ; </a> 0
<a> public abstract class WebSocketServerHandshaker { </a> 0
<a> private final String webSocketUrl ; </a> 0
<a> private final String [ ] subprotocols ; </a> 0
<a> private final WebSocketVersion version ; </a> 0
<a> private final int maxFramePayloadLength ; </a> 0
<a> private String selectedSubprotocol ; </a> 0
<a> protected WebSocketServerHandshaker ( </a> 0
<a> WebSocketVersion version , String webSocketUrl , String subprotocols , </a> 0
<a> int maxFramePayloadLength ) { </a> 0
<a> this . version = version ; </a> 0
<a> this . webSocketUrl = webSocketUrl ; </a> 0
<a> if ( subprotocols != null ) { </a> 0
<a> String [ ] subprotocolArray = subprotocols . split ( "," ) ; </a> 0
<a> for ( int i = 0 ; i < subprotocolArray . length ; i ++ ) { </a> 0
<a> subprotocolArray [ i ] = subprotocolArray [ i ] . trim ( ) ; </a> 0
<a> } </a> 0
<a> this . subprotocols = subprotocolArray ; </a> 0
<a> } else { </a> 0
<a> this . subprotocols = new String [ 0 ] ; </a> 1
<a> } </a> 0
<a> this . maxFramePayloadLength = maxFramePayloadLength ; </a> 0
<a> } </a> 0
<a> public String getWebSocketUrl ( ) { </a> 0
<a> return webSocketUrl ; </a> 0
<a> } </a> 0
<a> public Set < String > getSubprotocols ( ) { </a> 0
<a> Set < String > ret = new LinkedHashSet < String > ( ) ; </a> 0
<a> Collections . addAll ( ret , subprotocols ) ; </a> 0
<a> return ret ; </a> 0
<a> } </a> 0
<a> public WebSocketVersion getVersion ( ) { </a> 0
<a> return version ; </a> 0
<a> } </a> 0
<a> public int getMaxFramePayloadLength ( ) { </a> 0
<a> return maxFramePayloadLength ; </a> 0
<a> } </a> 0
<a> public abstract ChannelFuture handshake ( Channel channel , HttpRequest req ) ; </a> 1
<a> public abstract ChannelFuture close ( Channel channel , CloseWebSocketFrame frame ) ; </a> 1
<a> protected String selectSubprotocol ( String requestedSubprotocols ) { </a> 0
<a> if ( requestedSubprotocols == null || subprotocols . length == 0 ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> String [ ] requestedSubprotocolArray = requestedSubprotocols . split ( "," ) ; </a> 0
<a> for ( String p : requestedSubprotocolArray ) { </a> 0
<a> String requestedSubprotocol = p . trim ( ) ; </a> 0
<a> for ( String supportedSubprotocol : subprotocols ) { </a> 0
<a> if ( requestedSubprotocol . equals ( supportedSubprotocol ) ) { </a> 0
<a> return requestedSubprotocol ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> public String getSelectedSubprotocol ( ) { </a> 0
<a> return selectedSubprotocol ; </a> 0
<a> } </a> 0
<a> protected void setSelectedSubprotocol ( String value ) { </a> 0
<a> selectedSubprotocol = value ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . Names . * ; </a> 1
<a> import static io . netty . handler . codec . http . HttpHeaders . Values . * ; </a> 1
<a> import static io . netty . handler . codec . http . HttpVersion . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 1
<a> import io . netty . handler . codec . http . DefaultHttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpChunkAggregator ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders . Names ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders . Values ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpRequestDecoder ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseEncoder ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseStatus ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> public class WebSocketServerHandshaker00 extends WebSocketServerHandshaker { </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocketServerHandshaker00 . class ) ; </a> 1
<a> public WebSocketServerHandshaker00 ( String webSocketURL , String subprotocols , int maxFramePayloadLength ) { </a> 0
<a> super ( WebSocketVersion . V00 , webSocketURL , subprotocols , maxFramePayloadLength ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture handshake ( Channel channel , HttpRequest req ) { </a> 1
<a> if ( logger . isDebugEnabled ( ) ) { </a> 1
<a> logger . debug ( String . format ( "Channel %s WS Version 00 server handshake" , channel . id ( ) ) ) ; </a> 1
<a> } </a> 1
<a> if ( ! Values . UPGRADE . equalsIgnoreCase ( req . getHeader ( CONNECTION ) ) </a> 1
<a> || ! WEBSOCKET . equalsIgnoreCase ( req . getHeader ( Names . UPGRADE ) ) ) { </a> 1
<a> throw new WebSocketHandshakeException ( "not a WebSocket handshake request: missing upgrade" ) ; </a> 0
<a> } </a> 0
<a> boolean isHixie76 = req . containsHeader ( SEC_WEBSOCKET_KEY1 ) && req . containsHeader ( SEC_WEBSOCKET_KEY2 ) ; </a> 1
<a> HttpResponse res = new DefaultHttpResponse ( HTTP_1_1 , new HttpResponseStatus ( 101 , </a> 1
<a> isHixie76 ? "WebSocket Protocol Handshake" : "Web Socket Protocol Handshake" ) ) ; </a> 0
<a> res . addHeader ( Names . UPGRADE , WEBSOCKET ) ; </a> 1
<a> res . addHeader ( CONNECTION , Values . UPGRADE ) ; </a> 1
<a> if ( isHixie76 ) { </a> 0
<a> res . addHeader ( SEC_WEBSOCKET_ORIGIN , req . getHeader ( ORIGIN ) ) ; </a> 1
<a> res . addHeader ( SEC_WEBSOCKET_LOCATION , getWebSocketUrl ( ) ) ; </a> 1
<a> String subprotocols = req . getHeader ( Names . SEC_WEBSOCKET_PROTOCOL ) ; </a> 0
<a> if ( subprotocols != null ) { </a> 0
<a> String selectedSubprotocol = selectSubprotocol ( subprotocols ) ; </a> 0
<a> if ( selectedSubprotocol == null ) { </a> 0
<a> throw new WebSocketHandshakeException ( "Requested subprotocol(s) not supported: " + subprotocols ) ; </a> 0
<a> } else { </a> 0
<a> res . addHeader ( Names . SEC_WEBSOCKET_PROTOCOL , selectedSubprotocol ) ; </a> 0
<a> setSelectedSubprotocol ( selectedSubprotocol ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> String key1 = req . getHeader ( SEC_WEBSOCKET_KEY1 ) ; </a> 1
<a> String key2 = req . getHeader ( SEC_WEBSOCKET_KEY2 ) ; </a> 1
<a> int a = ( int ) ( Long . parseLong ( key1 . replaceAll ( "[^0-9]" , "" ) ) / key1 . replaceAll ( "[^ ]" , "" ) . length ( ) ) ; </a> 1
<a> int b = ( int ) ( Long . parseLong ( key2 . replaceAll ( "[^0-9]" , "" ) ) / key2 . replaceAll ( "[^ ]" , "" ) . length ( ) ) ; </a> 1
<a> long c = req . getContent ( ) . readLong ( ) ; </a> 1
<a> ByteBuf input = Unpooled . buffer ( 16 ) ; </a> 0
<a> input . writeInt ( a ) ; </a> 0
<a> input . writeInt ( b ) ; </a> 0
<a> input . writeLong ( c ) ; </a> 0
<a> ByteBuf output = Unpooled . wrappedBuffer ( WebSocketUtil . md5 ( input . array ( ) ) ) ; </a> 1
<a> res . setContent ( output ) ; </a> 1
<a> } else { </a> 0
<a> res . addHeader ( WEBSOCKET_ORIGIN , req . getHeader ( ORIGIN ) ) ; </a> 1
<a> res . addHeader ( WEBSOCKET_LOCATION , getWebSocketUrl ( ) ) ; </a> 1
<a> String protocol = req . getHeader ( WEBSOCKET_PROTOCOL ) ; </a> 1
<a> if ( protocol != null ) { </a> 0
<a> res . addHeader ( WEBSOCKET_PROTOCOL , selectSubprotocol ( protocol ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> ChannelPipeline p = channel . pipeline ( ) ; </a> 0
<a> if ( p . get ( HttpChunkAggregator . class ) != null ) { </a> 0
<a> p . remove ( HttpChunkAggregator . class ) ; </a> 0
<a> } </a> 1
<a> p . replace ( HttpRequestDecoder . class , "wsdecoder" , </a> 1
<a> new WebSocket00FrameDecoder ( getMaxFramePayloadLength ( ) ) ) ; </a> 0
<a> ChannelFuture future = channel . write ( res ) ; </a> 0
<a> p . replace ( HttpResponseEncoder . class , "wsencoder" , new WebSocket00FrameEncoder ( ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture close ( Channel channel , CloseWebSocketFrame frame ) { </a> 1
<a> return channel . write ( frame ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . Values . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpVersion . * ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . http . DefaultHttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpChunkAggregator ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders . Names ; </a> 1
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpRequestDecoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseEncoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseStatus ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class WebSocketServerHandshaker08 extends WebSocketServerHandshaker { </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocketServerHandshaker08 . class ) ; </a> 1
<a> public static final String WEBSOCKET_08_ACCEPT_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; </a> 0
<a> private final boolean allowExtensions ; </a> 0
<a> public WebSocketServerHandshaker08 ( </a> 0
<a> String webSocketURL , String subprotocols , boolean allowExtensions , int maxFramePayloadLength ) { </a> 0
<a> super ( WebSocketVersion . V08 , webSocketURL , subprotocols , maxFramePayloadLength ) ; </a> 0
<a> this . allowExtensions = allowExtensions ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture handshake ( Channel channel , HttpRequest req ) { </a> 1
<a> if ( logger . isDebugEnabled ( ) ) { </a> 1
<a> logger . debug ( String . format ( "Channel %s WS Version 8 server handshake" , channel . id ( ) ) ) ; </a> 1
<a> } </a> 1
<a> HttpResponse res = new DefaultHttpResponse ( HTTP_1_1 , HttpResponseStatus . SWITCHING_PROTOCOLS ) ; </a> 0
<a> String key = req . getHeader ( Names . SEC_WEBSOCKET_KEY ) ; </a> 1
<a> if ( key == null ) { </a> 0
<a> throw new WebSocketHandshakeException ( "not a WebSocket request: missing key" ) ; </a> 0
<a> } </a> 0
<a> String acceptSeed = key + WEBSOCKET_08_ACCEPT_GUID ; </a> 0
<a> byte [ ] sha1 = WebSocketUtil . sha1 ( acceptSeed . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 0
<a> String accept = WebSocketUtil . base64 ( sha1 ) ; </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( String . format ( "WS Version 8 Server Handshake key: %s. Response: %s." , key , accept ) ) ; </a> 0
<a> } </a> 0
<a> res . setStatus ( HttpResponseStatus . SWITCHING_PROTOCOLS ) ; </a> 1
<a> res . addHeader ( Names . UPGRADE , WEBSOCKET . toLowerCase ( ) ) ; </a> 0
<a> res . addHeader ( Names . CONNECTION , Names . UPGRADE ) ; </a> 0
<a> res . addHeader ( Names . SEC_WEBSOCKET_ACCEPT , accept ) ; </a> 0
<a> String subprotocols = req . getHeader ( Names . SEC_WEBSOCKET_PROTOCOL ) ; </a> 1
<a> if ( subprotocols != null ) { </a> 0
<a> String selectedSubprotocol = selectSubprotocol ( subprotocols ) ; </a> 0
<a> if ( selectedSubprotocol == null ) { </a> 0
<a> throw new WebSocketHandshakeException ( "Requested subprotocol(s) not supported: " + subprotocols ) ; </a> 0
<a> } else { </a> 0
<a> res . addHeader ( Names . SEC_WEBSOCKET_PROTOCOL , selectedSubprotocol ) ; </a> 1
<a> setSelectedSubprotocol ( selectedSubprotocol ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ChannelFuture future = channel . write ( res ) ; </a> 1
<a> ChannelPipeline p = channel . pipeline ( ) ; </a> 0
<a> if ( p . get ( HttpChunkAggregator . class ) != null ) { </a> 0
<a> p . remove ( HttpChunkAggregator . class ) ; </a> 0
<a> } </a> 0
<a> p . replace ( HttpRequestDecoder . class , "wsdecoder" , </a> 1
<a> new WebSocket08FrameDecoder ( true , allowExtensions , getMaxFramePayloadLength ( ) ) ) ; </a> 0
<a> p . replace ( HttpResponseEncoder . class , "wsencoder" , new WebSocket08FrameEncoder ( false ) ) ; </a> 1
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture close ( Channel channel , CloseWebSocketFrame frame ) { </a> 1
<a> ChannelFuture f = channel . write ( frame ) ; </a> 1
<a> f . addListener ( ChannelFutureListener . CLOSE ) ; </a> 1
<a> return f ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . Values . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpVersion . * ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 1
<a> import io . netty . channel . ChannelFutureListener ; </a> 1
<a> import io . netty . channel . ChannelPipeline ; </a> 1
<a> import io . netty . handler . codec . http . DefaultHttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpChunkAggregator ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders . Names ; </a> 1
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpRequestDecoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseEncoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseStatus ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class WebSocketServerHandshaker13 extends WebSocketServerHandshaker { </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocketServerHandshaker13 . class ) ; </a> 1
<a> public static final String WEBSOCKET_13_ACCEPT_GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; </a> 0
<a> private final boolean allowExtensions ; </a> 0
<a> public WebSocketServerHandshaker13 ( </a> 0
<a> String webSocketURL , String subprotocols , boolean allowExtensions , int maxFramePayloadLength ) { </a> 0
<a> super ( WebSocketVersion . V13 , webSocketURL , subprotocols , maxFramePayloadLength ) ; </a> 0
<a> this . allowExtensions = allowExtensions ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture handshake ( Channel channel , HttpRequest req ) { </a> 1
<a> if ( logger . isDebugEnabled ( ) ) { </a> 1
<a> logger . debug ( String . format ( "Channel %s WS Version 13 server handshake" , channel . id ( ) ) ) ; </a> 1
<a> } </a> 1
<a> HttpResponse res = new DefaultHttpResponse ( HTTP_1_1 , HttpResponseStatus . SWITCHING_PROTOCOLS ) ; </a> 0
<a> String key = req . getHeader ( Names . SEC_WEBSOCKET_KEY ) ; </a> 1
<a> if ( key == null ) { </a> 0
<a> throw new WebSocketHandshakeException ( "not a WebSocket request: missing key" ) ; </a> 0
<a> } </a> 0
<a> String acceptSeed = key + WEBSOCKET_13_ACCEPT_GUID ; </a> 0
<a> byte [ ] sha1 = WebSocketUtil . sha1 ( acceptSeed . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 0
<a> String accept = WebSocketUtil . base64 ( sha1 ) ; </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( String . format ( "WS Version 13 Server Handshake key: %s. Response: %s." , key , accept ) ) ; </a> 0
<a> } </a> 0
<a> res . setStatus ( HttpResponseStatus . SWITCHING_PROTOCOLS ) ; </a> 1
<a> res . addHeader ( Names . UPGRADE , WEBSOCKET . toLowerCase ( ) ) ; </a> 1
<a> res . addHeader ( Names . CONNECTION , Names . UPGRADE ) ; </a> 1
<a> res . addHeader ( Names . SEC_WEBSOCKET_ACCEPT , accept ) ; </a> 1
<a> String subprotocols = req . getHeader ( Names . SEC_WEBSOCKET_PROTOCOL ) ; </a> 1
<a> if ( subprotocols != null ) { </a> 0
<a> String selectedSubprotocol = selectSubprotocol ( subprotocols ) ; </a> 0
<a> if ( selectedSubprotocol == null ) { </a> 0
<a> throw new WebSocketHandshakeException ( </a> 0
<a> "Requested subprotocol(s) not supported: " + subprotocols ) ; </a> 0
<a> } else { </a> 0
<a> res . addHeader ( Names . SEC_WEBSOCKET_PROTOCOL , selectedSubprotocol ) ; </a> 1
<a> setSelectedSubprotocol ( selectedSubprotocol ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ChannelFuture future = channel . write ( res ) ; </a> 1
<a> ChannelPipeline p = channel . pipeline ( ) ; </a> 0
<a> if ( p . get ( HttpChunkAggregator . class ) != null ) { </a> 0
<a> p . remove ( HttpChunkAggregator . class ) ; </a> 0
<a> } </a> 0
<a> p . replace ( HttpRequestDecoder . class , "wsdecoder" , </a> 1
<a> new WebSocket13FrameDecoder ( true , allowExtensions , getMaxFramePayloadLength ( ) ) ) ; </a> 0
<a> p . replace ( HttpResponseEncoder . class , "wsencoder" , new WebSocket13FrameEncoder ( false ) ) ; </a> 1
<a> return future ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public ChannelFuture close ( Channel channel , CloseWebSocketFrame frame ) { </a> 1
<a> ChannelFuture f = channel . write ( frame ) ; </a> 1
<a> f . addListener ( ChannelFutureListener . CLOSE ) ; </a> 1
<a> return f ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . handler . codec . http . DefaultHttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders . Names ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseStatus ; </a> 0
<a> import io . netty . handler . codec . http . HttpVersion ; </a> 0
<a> public class WebSocketServerHandshakerFactory { </a> 0
<a> private final String webSocketURL ; </a> 0
<a> private final String subprotocols ; </a> 0
<a> private final boolean allowExtensions ; </a> 0
<a> private final int maxFramePayloadLength ; </a> 0
<a> public WebSocketServerHandshakerFactory ( </a> 0
<a> String webSocketURL , String subprotocols , boolean allowExtensions ) { </a> 0
<a> this ( webSocketURL , subprotocols , allowExtensions , 65536 ) ; </a> 0
<a> } </a> 0
<a> public WebSocketServerHandshakerFactory ( </a> 0
<a> String webSocketURL , String subprotocols , boolean allowExtensions , </a> 0
<a> int maxFramePayloadLength ) { </a> 0
<a> this . webSocketURL = webSocketURL ; </a> 0
<a> this . subprotocols = subprotocols ; </a> 0
<a> this . allowExtensions = allowExtensions ; </a> 0
<a> this . maxFramePayloadLength = maxFramePayloadLength ; </a> 0
<a> } </a> 0
<a> public WebSocketServerHandshaker newHandshaker ( HttpRequest req ) { </a> 0
<a> String version = req . getHeader ( Names . SEC_WEBSOCKET_VERSION ) ; </a> 0
<a> if ( version != null ) { </a> 0
<a> if ( version . equals ( WebSocketVersion . V13 . toHttpHeaderValue ( ) ) ) { </a> 0
<a> return new WebSocketServerHandshaker13 ( </a> 0
<a> webSocketURL , subprotocols , allowExtensions , maxFramePayloadLength ) ; </a> 0
<a> } else if ( version . equals ( WebSocketVersion . V08 . toHttpHeaderValue ( ) ) ) { </a> 0
<a> return new WebSocketServerHandshaker08 ( </a> 0
<a> webSocketURL , subprotocols , allowExtensions , maxFramePayloadLength ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> return new WebSocketServerHandshaker00 ( webSocketURL , subprotocols , maxFramePayloadLength ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void sendUnsupportedWebSocketVersionResponse ( Channel channel ) { </a> 0
<a> HttpResponse res = new DefaultHttpResponse ( </a> 0
<a> HttpVersion . HTTP_1_1 , </a> 0
<a> HttpResponseStatus . SWITCHING_PROTOCOLS ) ; </a> 1
<a> res . setStatus ( HttpResponseStatus . UPGRADE_REQUIRED ) ; </a> 0
<a> res . setHeader ( Names . SEC_WEBSOCKET_VERSION , WebSocketVersion . V13 . toHttpHeaderValue ( ) ) ; </a> 1
<a> channel . write ( res ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . handler . codec . base64 . Base64 ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . security . MessageDigest ; </a> 0
<a> import java . security . NoSuchAlgorithmException ; </a> 0
<a> final class WebSocketUtil { </a> 0
<a> static byte [ ] md5 ( byte [ ] data ) { </a> 0
<a> try { </a> 0
<a> MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; </a> 0
<a> return md . digest ( data ) ; </a> 0
<a> } catch ( NoSuchAlgorithmException e ) { </a> 0
<a> throw new InternalError ( "MD5 not supported on this platform - Outdated?" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static byte [ ] sha1 ( byte [ ] data ) { </a> 0
<a> try { </a> 0
<a> MessageDigest md = MessageDigest . getInstance ( "SHA1" ) ; </a> 0
<a> return md . digest ( data ) ; </a> 0
<a> } catch ( NoSuchAlgorithmException e ) { </a> 0
<a> throw new InternalError ( "SHA-1 is not supported on this platform - Outdated?" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static String base64 ( byte [ ] data ) { </a> 0
<a> ByteBuf encodedData = Unpooled . wrappedBuffer ( data ) ; </a> 0
<a> return Base64 . encode ( encodedData ) . toString ( CharsetUtil . UTF_8 ) ; </a> 0
<a> } </a> 0
<a> static byte [ ] randomBytes ( int size ) { </a> 0
<a> byte [ ] bytes = new byte [ size ] ; </a> 0
<a> for ( int index = 0 ; index < size ; index ++ ) { </a> 0
<a> bytes [ index ] = ( byte ) randomNumber ( 0 , 255 ) ; </a> 0
<a> } </a> 0
<a> return bytes ; </a> 0
<a> } </a> 0
<a> static int randomNumber ( int minimum , int maximum ) { </a> 0
<a> return ( int ) ( Math . random ( ) * maximum + minimum ) ; </a> 0
<a> } </a> 0
<a> private WebSocketUtil ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> public enum WebSocketVersion { </a> 0
<a> UNKNOWN , </a> 0
<a> V00 , </a> 0
<a> V08 , </a> 0
<a> V13 ; </a> 0
<a> public String toHttpHeaderValue ( ) { </a> 0
<a> if ( this == V00 ) { </a> 0
<a> return "0" ; </a> 0
<a> } else if ( this == V08 ) { </a> 0
<a> return "8" ; </a> 0
<a> } else if ( this == V13 ) { </a> 0
<a> return "13" ; </a> 0
<a> } </a> 0
<a> throw new IllegalStateException ( "Unknown web socket version: " + this ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . rtsp ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders ; </a> 0
<a> public final class RtspHeaders { </a> 0
<a> public static final class Names { </a> 0
<a> public static final String ACCEPT = HttpHeaders . Names . ACCEPT ; </a> 0
<a> public static final String ACCEPT_ENCODING = HttpHeaders . Names . ACCEPT_ENCODING ; </a> 0
<a> public static final String ACCEPT_LANGUAGE = HttpHeaders . Names . ACCEPT_LANGUAGE ; </a> 0
<a> public static final String ALLOW = "Allow" ; </a> 0
<a> public static final String AUTHORIZATION = HttpHeaders . Names . AUTHORIZATION ; </a> 0
<a> public static final String BANDWIDTH = "Bandwidth" ; </a> 0
<a> public static final String BLOCKSIZE = "Blocksize" ; </a> 0
<a> public static final String CACHE_CONTROL = HttpHeaders . Names . CACHE_CONTROL ; </a> 0
<a> public static final String CONFERENCE = "Conference" ; </a> 0
<a> public static final String CONNECTION = HttpHeaders . Names . CONNECTION ; </a> 0
<a> public static final String CONTENT_BASE = HttpHeaders . Names . CONTENT_BASE ; </a> 0
<a> public static final String CONTENT_ENCODING = HttpHeaders . Names . CONTENT_ENCODING ; </a> 0
<a> public static final String CONTENT_LANGUAGE = HttpHeaders . Names . CONTENT_LANGUAGE ; </a> 0
<a> public static final String CONTENT_LENGTH = HttpHeaders . Names . CONTENT_LENGTH ; </a> 0
<a> public static final String CONTENT_LOCATION = HttpHeaders . Names . CONTENT_LOCATION ; </a> 0
<a> public static final String CONTENT_TYPE = HttpHeaders . Names . CONTENT_TYPE ; </a> 0
<a> public static final String CSEQ = "CSeq" ; </a> 0
<a> public static final String DATE = HttpHeaders . Names . DATE ; </a> 0
<a> public static final String EXPIRES = HttpHeaders . Names . EXPIRES ; </a> 0
<a> public static final String FROM = HttpHeaders . Names . FROM ; </a> 0
<a> public static final String HOST = HttpHeaders . Names . HOST ; </a> 0
<a> public static final String IF_MATCH = HttpHeaders . Names . IF_MATCH ; </a> 0
<a> public static final String IF_MODIFIED_SINCE = HttpHeaders . Names . IF_MODIFIED_SINCE ; </a> 0
<a> public static final String KEYMGMT = "KeyMgmt" ; </a> 0
<a> public static final String LAST_MODIFIED = HttpHeaders . Names . LAST_MODIFIED ; </a> 0
<a> public static final String PROXY_AUTHENTICATE = HttpHeaders . Names . PROXY_AUTHENTICATE ; </a> 0
<a> public static final String PROXY_REQUIRE = "Proxy-Require" ; </a> 0
<a> public static final String PUBLIC = "Public" ; </a> 0
<a> public static final String RANGE = HttpHeaders . Names . RANGE ; </a> 0
<a> public static final String REFERER = HttpHeaders . Names . REFERER ; </a> 0
<a> public static final String REQUIRE = "Require" ; </a> 0
<a> public static final String RETRT_AFTER = HttpHeaders . Names . RETRY_AFTER ; </a> 0
<a> public static final String RTP_INFO = "RTP-Info" ; </a> 0
<a> public static final String SCALE = "Scale" ; </a> 0
<a> public static final String SESSION = "Session" ; </a> 0
<a> public static final String SERVER = HttpHeaders . Names . SERVER ; </a> 0
<a> public static final String SPEED = "Speed" ; </a> 0
<a> public static final String TIMESTAMP = "Timestamp" ; </a> 0
<a> public static final String TRANSPORT = "Transport" ; </a> 0
<a> public static final String UNSUPPORTED = "Unsupported" ; </a> 0
<a> public static final String USER_AGENT = HttpHeaders . Names . USER_AGENT ; </a> 0
<a> public static final String VARY = HttpHeaders . Names . VARY ; </a> 0
<a> public static final String VIA = HttpHeaders . Names . VIA ; </a> 0
<a> public static final String WWW_AUTHENTICATE = HttpHeaders . Names . WWW_AUTHENTICATE ; </a> 0
<a> private Names ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static final class Values { </a> 0
<a> public static final String APPEND = "append" ; </a> 0
<a> public static final String AVP = "AVP" ; </a> 0
<a> public static final String BYTES = HttpHeaders . Values . BYTES ; </a> 0
<a> public static final String CHARSET = HttpHeaders . Values . CHARSET ; </a> 0
<a> public static final String CLIENT_PORT = "client_port" ; </a> 0
<a> public static final String CLOCK = "clock" ; </a> 0
<a> public static final String CLOSE = HttpHeaders . Values . CLOSE ; </a> 0
<a> public static final String COMPRESS = HttpHeaders . Values . COMPRESS ; </a> 0
<a> public static final String CONTINUE = HttpHeaders . Values . CONTINUE ; </a> 0
<a> public static final String DEFLATE = HttpHeaders . Values . DEFLATE ; </a> 0
<a> public static final String DESTINATION = "destination" ; </a> 0
<a> public static final String GZIP = HttpHeaders . Values . GZIP ; </a> 0
<a> public static final String IDENTITY = HttpHeaders . Values . IDENTITY ; </a> 0
<a> public static final String INTERLEAVED = "interleaved" ; </a> 0
<a> public static final String KEEP_ALIVE = HttpHeaders . Values . KEEP_ALIVE ; </a> 0
<a> public static final String LAYERS = "layers" ; </a> 0
<a> public static final String MAX_AGE = HttpHeaders . Values . MAX_AGE ; </a> 0
<a> public static final String MAX_STALE = HttpHeaders . Values . MAX_STALE ; </a> 0
<a> public static final String MIN_FRESH = HttpHeaders . Values . MIN_FRESH ; </a> 0
<a> public static final String MODE = "mode" ; </a> 0
<a> public static final String MULTICAST = "multicast" ; </a> 0
<a> public static final String MUST_REVALIDATE = HttpHeaders . Values . MUST_REVALIDATE ; </a> 0
<a> public static final String NONE = HttpHeaders . Values . NONE ; </a> 0
<a> public static final String NO_CACHE = HttpHeaders . Values . NO_CACHE ; </a> 0
<a> public static final String NO_TRANSFORM = HttpHeaders . Values . NO_TRANSFORM ; </a> 0
<a> public static final String ONLY_IF_CACHED = HttpHeaders . Values . ONLY_IF_CACHED ; </a> 0
<a> public static final String PORT = "port" ; </a> 0
<a> public static final String PRIVATE = HttpHeaders . Values . PRIVATE ; </a> 0
<a> public static final String PROXY_REVALIDATE = HttpHeaders . Values . PROXY_REVALIDATE ; </a> 0
<a> public static final String PUBLIC = HttpHeaders . Values . PUBLIC ; </a> 0
<a> public static final String RTP = "RTP" ; </a> 0
<a> public static final String RTPTIME = "rtptime" ; </a> 0
<a> public static final String SEQ = "seq" ; </a> 0
<a> public static final String SERVER_PORT = "server_port" ; </a> 0
<a> public static final String SSRC = "ssrc" ; </a> 0
<a> public static final String TCP = "TCP" ; </a> 0
<a> public static final String TIME = "time" ; </a> 0
<a> public static final String TIMEOUT = "timeout" ; </a> 0
<a> public static final String TTL = "ttl" ; </a> 0
<a> public static final String UDP = "UDP" ; </a> 0
<a> public static final String UNICAST = "unicast" ; </a> 0
<a> public static final String URL = "url" ; </a> 0
<a> private Values ( ) { } </a> 0
<a> } </a> 0
<a> private RtspHeaders ( ) { } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . rtsp ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedMessageChannel ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import io . netty . handler . codec . http . HttpChunkAggregator ; </a> 0
<a> import io . netty . handler . codec . http . HttpMessage ; </a> 0
<a> import io . netty . handler . codec . http . HttpMessageDecoder ; </a> 0
<a> public abstract class RtspMessageDecoder extends HttpMessageDecoder { </a> 0
<a> private final EmbeddedMessageChannel aggregator ; </a> 0
<a> protected RtspMessageDecoder ( ) { </a> 0
<a> this ( 4096 , 8192 , 8192 ) ; </a> 0
<a> } </a> 0
<a> protected RtspMessageDecoder ( int maxInitialLineLength , int maxHeaderSize , int maxContentLength ) { </a> 0
<a> super ( maxInitialLineLength , maxHeaderSize , maxContentLength * 2 ) ; </a> 0
<a> aggregator = new EmbeddedMessageChannel ( new HttpChunkAggregator ( maxContentLength ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decode ( ChannelHandlerContext ctx , ByteBuf buffer ) throws Exception { </a> 0
<a> Object o = super . decode ( ctx , buffer ) ; </a> 0
<a> if ( o != null && aggregator . writeInbound ( o ) ) { </a> 0
<a> return aggregator . readInbound ( ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isContentAlwaysEmpty ( HttpMessage msg ) { </a> 0
<a> boolean empty = super . isContentAlwaysEmpty ( msg ) ; </a> 0
<a> if ( empty ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( ! msg . containsHeader ( RtspHeaders . Names . CONTENT_LENGTH ) ) { </a> 1
<a> return true ; </a> 0
<a> } </a> 0
<a> return empty ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . rtsp ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 1
<a> import io . netty . handler . codec . UnsupportedMessageTypeException ; </a> 1
<a> import io . netty . handler . codec . http . HttpMessage ; </a> 0
<a> import io . netty . handler . codec . http . HttpMessageEncoder ; </a> 0
<a> @ Sharable </a> 0
<a> public abstract class RtspMessageEncoder extends HttpMessageEncoder { </a> 0
<a> protected RtspMessageEncoder ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( ChannelHandlerContext ctx , Object msg , </a> 0
<a> ByteBuf out ) throws Exception { </a> 1
<a> if ( ! ( msg instanceof HttpMessage ) ) { </a> 0
<a> throw new UnsupportedMessageTypeException ( msg , HttpMessage . class ) ; </a> 0
<a> } </a> 1
<a> super . encode ( ctx , msg , out ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . rtsp ; </a> 0
<a> import io . netty . handler . codec . http . HttpMethod ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public final class RtspMethods { </a> 0
<a> public static final HttpMethod OPTIONS = HttpMethod . OPTIONS ; </a> 0
<a> public static final HttpMethod DESCRIBE = new HttpMethod ( "DESCRIBE" ) ; </a> 0
<a> public static final HttpMethod ANNOUNCE = new HttpMethod ( "ANNOUNCE" ) ; </a> 0
<a> public static final HttpMethod SETUP = new HttpMethod ( "SETUP" ) ; </a> 0
<a> public static final HttpMethod PLAY = new HttpMethod ( "PLAY" ) ; </a> 0
<a> public static final HttpMethod PAUSE = new HttpMethod ( "PAUSE" ) ; </a> 0
<a> public static final HttpMethod TEARDOWN = new HttpMethod ( "TEARDOWN" ) ; </a> 0
<a> public static final HttpMethod GET_PARAMETER = new HttpMethod ( "GET_PARAMETER" ) ; </a> 0
<a> public static final HttpMethod SET_PARAMETER = new HttpMethod ( "SET_PARAMETER" ) ; </a> 0
<a> public static final HttpMethod REDIRECT = new HttpMethod ( "REDIRECT" ) ; </a> 0
<a> public static final HttpMethod RECORD = new HttpMethod ( "RECORD" ) ; </a> 0
<a> private static final Map < String , HttpMethod > methodMap = new HashMap < String , HttpMethod > ( ) ; </a> 0
<a> static { </a> 0
<a> methodMap . put ( DESCRIBE . toString ( ) , DESCRIBE ) ; </a> 0
<a> methodMap . put ( ANNOUNCE . toString ( ) , ANNOUNCE ) ; </a> 0
<a> methodMap . put ( GET_PARAMETER . toString ( ) , GET_PARAMETER ) ; </a> 0
<a> methodMap . put ( OPTIONS . toString ( ) , OPTIONS ) ; </a> 0
<a> methodMap . put ( PAUSE . toString ( ) , PAUSE ) ; </a> 0
<a> methodMap . put ( PLAY . toString ( ) , PLAY ) ; </a> 0
<a> methodMap . put ( RECORD . toString ( ) , RECORD ) ; </a> 0
<a> methodMap . put ( REDIRECT . toString ( ) , REDIRECT ) ; </a> 0
<a> methodMap . put ( SETUP . toString ( ) , SETUP ) ; </a> 0
<a> methodMap . put ( SET_PARAMETER . toString ( ) , SET_PARAMETER ) ; </a> 0
<a> methodMap . put ( TEARDOWN . toString ( ) , TEARDOWN ) ; </a> 0
<a> } </a> 0
<a> public static HttpMethod valueOf ( String name ) { </a> 0
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> name = name . trim ( ) . toUpperCase ( ) ; </a> 0
<a> if ( name . length ( ) == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "empty name" ) ; </a> 0
<a> } </a> 0
<a> HttpMethod result = methodMap . get ( name ) ; </a> 0
<a> if ( result != null ) { </a> 0
<a> return result ; </a> 0
<a> } else { </a> 0
<a> return new HttpMethod ( name ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private RtspMethods ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . rtsp ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import io . netty . handler . codec . http . DefaultHttpRequest ; </a> 0
<a> import io . netty . handler . codec . http . HttpMessage ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 0
<a> public class RtspRequestDecoder extends RtspMessageDecoder { </a> 0
<a> public RtspRequestDecoder ( ) { </a> 0
<a> } </a> 0
<a> public RtspRequestDecoder ( int maxInitialLineLength , int maxHeaderSize , int maxContentLength ) { </a> 0
<a> super ( maxInitialLineLength , maxHeaderSize , maxContentLength ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected HttpMessage createMessage ( String [ ] initialLine ) throws Exception { </a> 0
<a> return new DefaultHttpRequest ( RtspVersions . valueOf ( initialLine [ 2 ] ) , </a> 0
<a> RtspMethods . valueOf ( initialLine [ 0 ] ) , initialLine [ 1 ] ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isDecodingRequest ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . rtsp ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . handler . codec . http . HttpMessage ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class RtspRequestEncoder extends RtspMessageEncoder { </a> 0
<a> @ Override </a> 0
<a> protected void encodeInitialLine ( ByteBuf buf , HttpMessage message ) </a> 0
<a> throws Exception { </a> 0
<a> HttpRequest request = ( HttpRequest ) message ; </a> 0
<a> buf . writeBytes ( request . getMethod ( ) . toString ( ) . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 1
<a> buf . writeByte ( ( byte ) ' ' ) ; </a> 0
<a> buf . writeBytes ( request . getUri ( ) . getBytes ( CharsetUtil . UTF_8 ) ) ; </a> 1
<a> buf . writeByte ( ( byte ) ' ' ) ; </a> 0
<a> buf . writeBytes ( request . getProtocolVersion ( ) . toString ( ) . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 1
<a> buf . writeByte ( ( byte ) '\r' ) ; </a> 0
<a> buf . writeByte ( ( byte ) '\n' ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . rtsp ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import io . netty . handler . codec . http . DefaultHttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpMessage ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseStatus ; </a> 0
<a> public class RtspResponseDecoder extends RtspMessageDecoder { </a> 0
<a> public RtspResponseDecoder ( ) { </a> 0
<a> } </a> 0
<a> public RtspResponseDecoder ( int maxInitialLineLength , int maxHeaderSize , </a> 0
<a> int maxContentLength ) { </a> 0
<a> super ( maxInitialLineLength , maxHeaderSize , maxContentLength ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected HttpMessage createMessage ( String [ ] initialLine ) throws Exception { </a> 0
<a> return new DefaultHttpResponse ( </a> 0
<a> RtspVersions . valueOf ( initialLine [ 0 ] ) , </a> 0
<a> new HttpResponseStatus ( Integer . valueOf ( initialLine [ 1 ] ) , initialLine [ 2 ] ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isDecodingRequest ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . rtsp ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . handler . codec . http . HttpMessage ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 1
<a> public class RtspResponseEncoder extends RtspMessageEncoder { </a> 0
<a> @ Override </a> 0
<a> protected void encodeInitialLine ( ByteBuf buf , HttpMessage message ) </a> 0
<a> throws Exception { </a> 0
<a> HttpResponse response = ( HttpResponse ) message ; </a> 0
<a> buf . writeBytes ( response . getProtocolVersion ( ) . toString ( ) . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 1
<a> buf . writeByte ( ( byte ) ' ' ) ; </a> 0
<a> buf . writeBytes ( String . valueOf ( response . getStatus ( ) . getCode ( ) ) . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 1
<a> buf . writeByte ( ( byte ) ' ' ) ; </a> 0
<a> buf . writeBytes ( String . valueOf ( response . getStatus ( ) . getReasonPhrase ( ) ) . getBytes ( CharsetUtil . US_ASCII ) ) ; </a> 1
<a> buf . writeByte ( ( byte ) '\r' ) ; </a> 0
<a> buf . writeByte ( ( byte ) '\n' ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . rtsp ; </a> 0
<a> import io . netty . handler . codec . http . HttpVersion ; </a> 0
<a> public final class RtspVersions { </a> 0
<a> public static final HttpVersion RTSP_1_0 = new HttpVersion ( "RTSP" , 1 , 0 , true ) ; </a> 0
<a> public static HttpVersion valueOf ( String text ) { </a> 0
<a> if ( text == null ) { </a> 0
<a> throw new NullPointerException ( "text" ) ; </a> 0
<a> } </a> 0
<a> text = text . trim ( ) . toUpperCase ( ) ; </a> 0
<a> if ( text . equals ( "RTSP/1.0" ) ) { </a> 0
<a> return RTSP_1_0 ; </a> 0
<a> } </a> 0
<a> return new HttpVersion ( text , true ) ; </a> 0
<a> } </a> 0
<a> private RtspVersions ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . rtsp ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . util . internal . StringUtil ; </a> 0
<a> public class DefaultSpdyGoAwayFrame implements SpdyGoAwayFrame { </a> 0
<a> private int lastGoodStreamId ; </a> 0
<a> private SpdySessionStatus status ; </a> 0
<a> public DefaultSpdyGoAwayFrame ( int lastGoodStreamId ) { </a> 0
<a> this ( lastGoodStreamId , 0 ) ; </a> 0
<a> } </a> 0
<a> public DefaultSpdyGoAwayFrame ( int lastGoodStreamId , int statusCode ) { </a> 0
<a> this ( lastGoodStreamId , SpdySessionStatus . valueOf ( statusCode ) ) ; </a> 0
<a> } </a> 0
<a> public DefaultSpdyGoAwayFrame ( int lastGoodStreamId , SpdySessionStatus status ) { </a> 0
<a> setLastGoodStreamId ( lastGoodStreamId ) ; </a> 0
<a> setStatus ( status ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getLastGoodStreamId ( ) { </a> 0
<a> return lastGoodStreamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setLastGoodStreamId ( int lastGoodStreamId ) { </a> 0
<a> if ( lastGoodStreamId < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "Last-good-stream-ID" </a> 0
<a> + " cannot be negative: " + lastGoodStreamId ) ; </a> 0
<a> } </a> 0
<a> this . lastGoodStreamId = lastGoodStreamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public SpdySessionStatus getStatus ( ) { </a> 0
<a> return status ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setStatus ( SpdySessionStatus status ) { </a> 0
<a> this . status = status ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Last-good-stream-ID = " ) ; </a> 1
<a> buf . append ( lastGoodStreamId ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Status: " ) ; </a> 1
<a> buf . append ( status . toString ( ) ) ; </a> 0
<a> return buf . toString ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . util . internal . StringUtil ; </a> 0
<a> public class DefaultSpdyHeadersFrame extends DefaultSpdyHeaderBlock </a> 0
<a> implements SpdyHeadersFrame { </a> 0
<a> private int streamId ; </a> 0
<a> private boolean last ; </a> 0
<a> public DefaultSpdyHeadersFrame ( int streamId ) { </a> 0
<a> setStreamId ( streamId ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getStreamId ( ) { </a> 0
<a> return streamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setStreamId ( int streamId ) { </a> 0
<a> if ( streamId <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Stream-ID must be positive: " + streamId ) ; </a> 0
<a> } </a> 0
<a> this . streamId = streamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isLast ( ) { </a> 0
<a> return last ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setLast ( boolean last ) { </a> 0
<a> this . last = last ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> buf . append ( "(last: " ) ; </a> 1
<a> buf . append ( isLast ( ) ) ; </a> 1
<a> buf . append ( ')' ) ; </a> 1
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Stream-ID = " ) ; </a> 1
<a> buf . append ( streamId ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Headers:" ) ; </a> 1
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> appendHeaders ( buf ) ; </a> 0
<a> buf . setLength ( buf . length ( ) - StringUtil . NEWLINE . length ( ) ) ; </a> 0
<a> return buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public class DefaultSpdyNoOpFrame implements SpdyNoOpFrame { </a> 0
<a> public DefaultSpdyNoOpFrame ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getClass ( ) . getSimpleName ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . util . internal . StringUtil ; </a> 0
<a> public class DefaultSpdyPingFrame implements SpdyPingFrame { </a> 0
<a> private int id ; </a> 0
<a> public DefaultSpdyPingFrame ( int id ) { </a> 0
<a> setId ( id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getId ( ) { </a> 0
<a> return id ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setId ( int id ) { </a> 0
<a> this . id = id ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> ID = " ) ; </a> 1
<a> buf . append ( id ) ; </a> 0
<a> return buf . toString ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . util . internal . StringUtil ; </a> 0
<a> public class DefaultSpdyRstStreamFrame implements SpdyRstStreamFrame { </a> 0
<a> private int streamId ; </a> 0
<a> private SpdyStreamStatus status ; </a> 0
<a> public DefaultSpdyRstStreamFrame ( int streamId , int statusCode ) { </a> 0
<a> this ( streamId , SpdyStreamStatus . valueOf ( statusCode ) ) ; </a> 0
<a> } </a> 0
<a> public DefaultSpdyRstStreamFrame ( int streamId , SpdyStreamStatus status ) { </a> 0
<a> setStreamId ( streamId ) ; </a> 0
<a> setStatus ( status ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getStreamId ( ) { </a> 0
<a> return streamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setStreamId ( int streamId ) { </a> 0
<a> if ( streamId <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Stream-ID must be positive: " + streamId ) ; </a> 0
<a> } </a> 0
<a> this . streamId = streamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public SpdyStreamStatus getStatus ( ) { </a> 0
<a> return status ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setStatus ( SpdyStreamStatus status ) { </a> 0
<a> this . status = status ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Stream-ID = " ) ; </a> 1
<a> buf . append ( streamId ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Status: " ) ; </a> 1
<a> buf . append ( status . toString ( ) ) ; </a> 0
<a> return buf . toString ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . util . internal . StringUtil ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . TreeMap ; </a> 0
<a> public class DefaultSpdySettingsFrame implements SpdySettingsFrame { </a> 0
<a> private boolean clear ; </a> 0
<a> private final Map < Integer , Setting > settingsMap = new TreeMap < Integer , Setting > ( ) ; </a> 0
<a> public DefaultSpdySettingsFrame ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Set < Integer > getIds ( ) { </a> 0
<a> return settingsMap . keySet ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isSet ( int ID ) { </a> 1
<a> Integer key = new Integer ( ID ) ; </a> 1
<a> return settingsMap . containsKey ( key ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getValue ( int ID ) { </a> 1
<a> Integer key = new Integer ( ID ) ; </a> 1
<a> if ( settingsMap . containsKey ( key ) ) { </a> 0
<a> return settingsMap . get ( key ) . getValue ( ) ; </a> 0
<a> } else { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setValue ( int ID , int value ) { </a> 1
<a> setValue ( ID , value , false , false ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setValue ( int ID , int value , boolean persistValue , boolean persisted ) { </a> 1
<a> if ( ID <= 0 || ID > SpdyCodecUtil . SPDY_SETTINGS_MAX_ID ) { </a> 1
<a> throw new IllegalArgumentException ( "Setting ID is not valid: " + ID ) ; </a> 1
<a> } </a> 0
<a> Integer key = new Integer ( ID ) ; </a> 1
<a> if ( settingsMap . containsKey ( key ) ) { </a> 0
<a> Setting setting = settingsMap . get ( key ) ; </a> 0
<a> setting . setValue ( value ) ; </a> 0
<a> setting . setPersist ( persistValue ) ; </a> 0
<a> setting . setPersisted ( persisted ) ; </a> 0
<a> } else { </a> 0
<a> settingsMap . put ( key , new Setting ( value , persistValue , persisted ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void removeValue ( int ID ) { </a> 1
<a> Integer key = new Integer ( ID ) ; </a> 1
<a> if ( settingsMap . containsKey ( key ) ) { </a> 0
<a> settingsMap . remove ( key ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isPersistValue ( int ID ) { </a> 1
<a> Integer key = new Integer ( ID ) ; </a> 1
<a> if ( settingsMap . containsKey ( key ) ) { </a> 0
<a> return settingsMap . get ( key ) . isPersist ( ) ; </a> 0
<a> } else { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setPersistValue ( int ID , boolean persistValue ) { </a> 1
<a> Integer key = new Integer ( ID ) ; </a> 1
<a> if ( settingsMap . containsKey ( key ) ) { </a> 0
<a> settingsMap . get ( key ) . setPersist ( persistValue ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isPersisted ( int ID ) { </a> 1
<a> Integer key = new Integer ( ID ) ; </a> 1
<a> if ( settingsMap . containsKey ( key ) ) { </a> 0
<a> return settingsMap . get ( key ) . isPersisted ( ) ; </a> 0
<a> } else { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setPersisted ( int ID , boolean persisted ) { </a> 1
<a> Integer key = new Integer ( ID ) ; </a> 1
<a> if ( settingsMap . containsKey ( key ) ) { </a> 0
<a> settingsMap . get ( key ) . setPersisted ( persisted ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean clearPreviouslyPersistedSettings ( ) { </a> 0
<a> return clear ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setClearPreviouslyPersistedSettings ( boolean clear ) { </a> 0
<a> this . clear = clear ; </a> 0
<a> } </a> 0
<a> private Set < Map . Entry < Integer , Setting > > getSettings ( ) { </a> 0
<a> return settingsMap . entrySet ( ) ; </a> 0
<a> } </a> 0
<a> private void appendSettings ( StringBuilder buf ) { </a> 0
<a> for ( Map . Entry < Integer , Setting > e : getSettings ( ) ) { </a> 0
<a> Setting setting = e . getValue ( ) ; </a> 0
<a> buf . append ( "--> " ) ; </a> 0
<a> buf . append ( e . getKey ( ) . toString ( ) ) ; </a> 1
<a> buf . append ( ":" ) ; </a> 0
<a> buf . append ( setting . getValue ( ) ) ; </a> 0
<a> buf . append ( " (persist value: " ) ; </a> 0
<a> buf . append ( setting . isPersist ( ) ) ; </a> 0
<a> buf . append ( "; persisted: " ) ; </a> 0
<a> buf . append ( setting . isPersisted ( ) ) ; </a> 0
<a> buf . append ( ')' ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> appendSettings ( buf ) ; </a> 0
<a> buf . setLength ( buf . length ( ) - StringUtil . NEWLINE . length ( ) ) ; </a> 0
<a> return buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> private static final class Setting { </a> 0
<a> private int value ; </a> 0
<a> private boolean persist ; </a> 0
<a> private boolean persisted ; </a> 0
<a> Setting ( int value , boolean persist , boolean persisted ) { </a> 0
<a> this . value = value ; </a> 0
<a> this . persist = persist ; </a> 0
<a> this . persisted = persisted ; </a> 0
<a> } </a> 0
<a> int getValue ( ) { </a> 0
<a> return value ; </a> 0
<a> } </a> 0
<a> void setValue ( int value ) { </a> 0
<a> this . value = value ; </a> 0
<a> } </a> 0
<a> boolean isPersist ( ) { </a> 0
<a> return persist ; </a> 0
<a> } </a> 0
<a> void setPersist ( boolean persist ) { </a> 0
<a> this . persist = persist ; </a> 0
<a> } </a> 0
<a> boolean isPersisted ( ) { </a> 0
<a> return persisted ; </a> 0
<a> } </a> 0
<a> void setPersisted ( boolean persisted ) { </a> 0
<a> this . persisted = persisted ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . util . internal . StringUtil ; </a> 0
<a> public class DefaultSpdySynReplyFrame extends DefaultSpdyHeaderBlock </a> 0
<a> implements SpdySynReplyFrame { </a> 0
<a> private int streamId ; </a> 0
<a> private boolean last ; </a> 0
<a> public DefaultSpdySynReplyFrame ( int streamId ) { </a> 0
<a> setStreamId ( streamId ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getStreamId ( ) { </a> 0
<a> return streamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setStreamId ( int streamId ) { </a> 0
<a> if ( streamId <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Stream-ID must be positive: " + streamId ) ; </a> 0
<a> } </a> 0
<a> this . streamId = streamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isLast ( ) { </a> 0
<a> return last ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setLast ( boolean last ) { </a> 0
<a> this . last = last ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> buf . append ( "(last: " ) ; </a> 1
<a> buf . append ( isLast ( ) ) ; </a> 1
<a> buf . append ( ')' ) ; </a> 1
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Stream-ID = " ) ; </a> 1
<a> buf . append ( streamId ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Headers:" ) ; </a> 1
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> appendHeaders ( buf ) ; </a> 0
<a> buf . setLength ( buf . length ( ) - StringUtil . NEWLINE . length ( ) ) ; </a> 0
<a> return buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . util . internal . StringUtil ; </a> 0
<a> public class DefaultSpdySynStreamFrame extends DefaultSpdyHeaderBlock </a> 0
<a> implements SpdySynStreamFrame { </a> 0
<a> private int streamId ; </a> 0
<a> private int associatedToStreamId ; </a> 1
<a> private byte priority ; </a> 0
<a> private boolean last ; </a> 0
<a> private boolean unidirectional ; </a> 0
<a> public DefaultSpdySynStreamFrame ( </a> 1
<a> int streamId , int associatedToStreamId , byte priority ) { </a> 1
<a> setStreamId ( streamId ) ; </a> 0
<a> setAssociatedToStreamId ( associatedToStreamId ) ; </a> 1
<a> setPriority ( priority ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getStreamId ( ) { </a> 0
<a> return streamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setStreamId ( int streamId ) { </a> 0
<a> if ( streamId <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Stream-ID must be positive: " + streamId ) ; </a> 0
<a> } </a> 0
<a> this . streamId = streamId ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getAssociatedToStreamId ( ) { </a> 0
<a> return associatedToStreamId ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setAssociatedToStreamId ( int associatedToStreamId ) { </a> 0
<a> if ( associatedToStreamId < 0 ) { </a> 1
<a> throw new IllegalArgumentException ( </a> 0
<a> "Associated-To-Stream-ID cannot be negative: " + </a> 0
<a> associatedToStreamId ) ; </a> 1
<a> } </a> 0
<a> this . associatedToStreamId = associatedToStreamId ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte getPriority ( ) { </a> 0
<a> return priority ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setPriority ( byte priority ) { </a> 0
<a> if ( priority < 0 || priority > 7 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "Priority must be between 0 and 7 inclusive: " + priority ) ; </a> 0
<a> } </a> 0
<a> this . priority = priority ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isLast ( ) { </a> 0
<a> return last ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setLast ( boolean last ) { </a> 0
<a> this . last = last ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isUnidirectional ( ) { </a> 0
<a> return unidirectional ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setUnidirectional ( boolean unidirectional ) { </a> 0
<a> this . unidirectional = unidirectional ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> buf . append ( "(last: " ) ; </a> 1
<a> buf . append ( isLast ( ) ) ; </a> 1
<a> buf . append ( "; unidirectional: " ) ; </a> 1
<a> buf . append ( isUnidirectional ( ) ) ; </a> 1
<a> buf . append ( ')' ) ; </a> 1
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Stream-ID = " ) ; </a> 1
<a> buf . append ( streamId ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> if ( associatedToStreamId != 0 ) { </a> 1
<a> buf . append ( "--> Associated-To-Stream-ID = " ) ; </a> 1
<a> buf . append ( associatedToStreamId ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> } </a> 0
<a> buf . append ( "--> Priority = " ) ; </a> 1
<a> buf . append ( priority ) ; </a> 0
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> buf . append ( "--> Headers:" ) ; </a> 1
<a> buf . append ( StringUtil . NEWLINE ) ; </a> 1
<a> appendHeaders ( buf ) ; </a> 0
<a> buf . setLength ( buf . length ( ) - StringUtil . NEWLINE . length ( ) ) ; </a> 0
<a> return buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public final class SpdyConstants { </a> 0
<a> public static final int SPDY_MIN_VERSION = 2 ; </a> 0
<a> public static final int SPDY_MAX_VERSION = 3 ; </a> 0
<a> private SpdyConstants ( ) { } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> public interface SpdyDataFrame { </a> 0
<a> int getStreamId ( ) ; </a> 0
<a> void setStreamId ( int streamID ) ; </a> 0
<a> boolean isLast ( ) ; </a> 0
<a> void setLast ( boolean last ) ; </a> 0
<a> ByteBuf getData ( ) ; </a> 0
<a> void setData ( ByteBuf data ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . channel . CombinedChannelHandler ; </a> 0
<a> public class SpdyFrameCodec extends CombinedChannelHandler { </a> 0
<a> public SpdyFrameCodec ( int version ) { </a> 0
<a> this ( version , 8192 , 16384 , 6 , 15 , 8 ) ; </a> 0
<a> } </a> 0
<a> public SpdyFrameCodec ( </a> 0
<a> int version , int maxChunkSize , int maxHeaderSize , </a> 0
<a> int compressionLevel , int windowBits , int memLevel ) { </a> 0
<a> super ( </a> 0
<a> new SpdyFrameDecoder ( version , maxChunkSize , maxHeaderSize ) , </a> 0
<a> new SpdyFrameEncoder ( version , compressionLevel , windowBits , memLevel ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import static io . netty . handler . codec . spdy . SpdyCodecUtil . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . ByteToMessageDecoder ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> public class SpdyFrameDecoder extends ByteToMessageDecoder < Object > { </a> 0
<a> private final int spdyVersion ; </a> 0
<a> private final int maxChunkSize ; </a> 0
<a> private final int maxHeaderSize ; </a> 0
<a> private final SpdyHeaderBlockDecompressor headerBlockDecompressor ; </a> 0
<a> private State state ; </a> 0
<a> private SpdySettingsFrame spdySettingsFrame ; </a> 0
<a> private SpdyHeaderBlock spdyHeaderBlock ; </a> 0
<a> private byte flags ; </a> 0
<a> private int length ; </a> 0
<a> private int version ; </a> 0
<a> private int type ; </a> 0
<a> private int streamID ; </a> 0
<a> private int headerSize ; </a> 0
<a> private int numHeaders ; </a> 0
<a> private ByteBuf decompressed ; </a> 0
<a> private enum State { </a> 0
<a> READ_COMMON_HEADER , </a> 0
<a> READ_CONTROL_FRAME , </a> 0
<a> READ_SETTINGS_FRAME , </a> 0
<a> READ_HEADER_BLOCK_FRAME , </a> 0
<a> READ_HEADER_BLOCK , </a> 0
<a> READ_DATA_FRAME , </a> 0
<a> DISCARD_FRAME , </a> 0
<a> FRAME_ERROR </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public SpdyFrameDecoder ( ) { </a> 0
<a> this ( 2 ) ; </a> 0
<a> } </a> 0
<a> public SpdyFrameDecoder ( int version ) { </a> 0
<a> this ( version , 8192 , 16384 ) ; </a> 0
<a> } </a> 0
<a> public SpdyFrameDecoder ( int version , int maxChunkSize , int maxHeaderSize ) { </a> 0
<a> if ( version < SpdyConstants . SPDY_MIN_VERSION || version > SpdyConstants . SPDY_MAX_VERSION ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "unsupported version: " + version ) ; </a> 0
<a> } </a> 0
<a> if ( maxChunkSize <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxChunkSize must be a positive integer: " + maxChunkSize ) ; </a> 0
<a> } </a> 0
<a> if ( maxHeaderSize <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxHeaderSize must be a positive integer: " + maxHeaderSize ) ; </a> 0
<a> } </a> 0
<a> spdyVersion = version ; </a> 0
<a> this . maxChunkSize = maxChunkSize ; </a> 0
<a> this . maxHeaderSize = maxHeaderSize ; </a> 0
<a> headerBlockDecompressor = SpdyHeaderBlockDecompressor . newInstance ( version ) ; </a> 0
<a> state = State . READ_COMMON_HEADER ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decodeLast ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 1
<a> try { </a> 0
<a> return decode ( ctx , in ) ; </a> 1
<a> } finally { </a> 0
<a> headerBlockDecompressor . end ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decode ( ChannelHandlerContext ctx , ByteBuf buffer ) throws Exception { </a> 0
<a> switch ( state ) { </a> 0
<a> case READ_COMMON_HEADER : </a> 0
<a> state = readCommonHeader ( buffer ) ; </a> 0
<a> if ( state == State . FRAME_ERROR ) { </a> 0
<a> if ( version != spdyVersion ) { </a> 0
<a> fireProtocolException ( ctx , "Unsupported version: " + version ) ; </a> 0
<a> } else { </a> 0
<a> fireInvalidControlFrameException ( ctx ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( length == 0 ) { </a> 0
<a> if ( state == State . READ_DATA_FRAME ) { </a> 0
<a> if ( streamID == 0 ) { </a> 0
<a> state = State . FRAME_ERROR ; </a> 0
<a> fireProtocolException ( ctx , "Received invalid data frame" ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame ( streamID ) ; </a> 0
<a> spdyDataFrame . setLast ( ( flags & SPDY_DATA_FLAG_FIN ) != 0 ) ; </a> 0
<a> state = State . READ_COMMON_HEADER ; </a> 0
<a> return spdyDataFrame ; </a> 1
<a> } </a> 0
<a> state = State . READ_COMMON_HEADER ; </a> 0
<a> } </a> 0
<a> return null ; </a> 1
<a> case READ_CONTROL_FRAME : </a> 0
<a> try { </a> 0
<a> Object frame = readControlFrame ( buffer ) ; </a> 0
<a> if ( frame != null ) { </a> 0
<a> state = State . READ_COMMON_HEADER ; </a> 0
<a> } </a> 0
<a> return frame ; </a> 1
<a> } catch ( IllegalArgumentException e ) { </a> 0
<a> state = State . FRAME_ERROR ; </a> 0
<a> fireInvalidControlFrameException ( ctx ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 1
<a> case READ_SETTINGS_FRAME : </a> 0
<a> if ( spdySettingsFrame == null ) { </a> 0
<a> if ( buffer . readableBytes ( ) < 4 ) { </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> int numEntries = getUnsignedInt ( buffer , buffer . readerIndex ( ) ) ; </a> 0
<a> buffer . skipBytes ( 4 ) ; </a> 0
<a> length -= 4 ; </a> 0
<a> if ( ( length & 0x07 ) != 0 || length > > 3 != numEntries ) { </a> 0
<a> state = State . FRAME_ERROR ; </a> 0
<a> fireInvalidControlFrameException ( ctx ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> spdySettingsFrame = new DefaultSpdySettingsFrame ( ) ; </a> 0
<a> boolean clear = ( flags & SPDY_SETTINGS_CLEAR ) != 0 ; </a> 0
<a> spdySettingsFrame . setClearPreviouslyPersistedSettings ( clear ) ; </a> 0
<a> } </a> 0
<a> int readableEntries = Math . min ( buffer . readableBytes ( ) > > 3 , length > > 3 ) ; </a> 0
<a> for ( int i = 0 ; i < readableEntries ; i ++ ) { </a> 0
<a> int ID ; </a> 0
<a> byte ID_flags ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> ID = buffer . readByte ( ) & 0xFF | </a> 0
<a> ( buffer . readByte ( ) & 0xFF ) < < 8 | </a> 0
<a> ( buffer . readByte ( ) & 0xFF ) < < 16 ; </a> 0
<a> ID_flags = buffer . readByte ( ) ; </a> 0
<a> } else { </a> 0
<a> ID_flags = buffer . readByte ( ) ; </a> 0
<a> ID = getUnsignedMedium ( buffer , buffer . readerIndex ( ) ) ; </a> 0
<a> buffer . skipBytes ( 3 ) ; </a> 0
<a> } </a> 0
<a> int value = getSignedInt ( buffer , buffer . readerIndex ( ) ) ; </a> 0
<a> buffer . skipBytes ( 4 ) ; </a> 0
<a> if ( ID == 0 ) { </a> 0
<a> state = State . FRAME_ERROR ; </a> 0
<a> spdySettingsFrame = null ; </a> 0
<a> fireInvalidControlFrameException ( ctx ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> if ( ! spdySettingsFrame . isSet ( ID ) ) { </a> 0
<a> boolean persistVal = ( ID_flags & SPDY_SETTINGS_PERSIST_VALUE ) != 0 ; </a> 0
<a> boolean persisted = ( ID_flags & SPDY_SETTINGS_PERSISTED ) != 0 ; </a> 0
<a> spdySettingsFrame . setValue ( ID , value , persistVal , persisted ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> length -= 8 * readableEntries ; </a> 0
<a> if ( length == 0 ) { </a> 0
<a> state = State . READ_COMMON_HEADER ; </a> 0
<a> Object frame = spdySettingsFrame ; </a> 0
<a> spdySettingsFrame = null ; </a> 0
<a> return frame ; </a> 1
<a> } </a> 0
<a> return null ; </a> 1
<a> case READ_HEADER_BLOCK_FRAME : </a> 0
<a> try { </a> 0
<a> spdyHeaderBlock = readHeaderBlockFrame ( buffer ) ; </a> 0
<a> if ( spdyHeaderBlock != null ) { </a> 0
<a> if ( length == 0 ) { </a> 0
<a> state = State . READ_COMMON_HEADER ; </a> 0
<a> Object frame = spdyHeaderBlock ; </a> 0
<a> spdyHeaderBlock = null ; </a> 0
<a> return frame ; </a> 1
<a> } </a> 0
<a> state = State . READ_HEADER_BLOCK ; </a> 0
<a> } </a> 0
<a> return null ; </a> 1
<a> } catch ( IllegalArgumentException e ) { </a> 0
<a> state = State . FRAME_ERROR ; </a> 0
<a> fireInvalidControlFrameException ( ctx ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> case READ_HEADER_BLOCK : </a> 0
<a> int compressedBytes = Math . min ( buffer . readableBytes ( ) , length ) ; </a> 0
<a> length -= compressedBytes ; </a> 0
<a> try { </a> 0
<a> decodeHeaderBlock ( buffer . readSlice ( compressedBytes ) ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> state = State . FRAME_ERROR ; </a> 0
<a> spdyHeaderBlock = null ; </a> 0
<a> decompressed = null ; </a> 0
<a> ctx . fireExceptionCaught ( e ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> if ( spdyHeaderBlock != null && spdyHeaderBlock . isInvalid ( ) ) { </a> 0
<a> Object frame = spdyHeaderBlock ; </a> 0
<a> spdyHeaderBlock = null ; </a> 0
<a> decompressed = null ; </a> 0
<a> if ( length == 0 ) { </a> 0
<a> state = State . READ_COMMON_HEADER ; </a> 0
<a> } </a> 0
<a> return frame ; </a> 1
<a> } </a> 0
<a> if ( length == 0 ) { </a> 0
<a> Object frame = spdyHeaderBlock ; </a> 0
<a> spdyHeaderBlock = null ; </a> 0
<a> state = State . READ_COMMON_HEADER ; </a> 0
<a> return frame ; </a> 1
<a> } </a> 0
<a> return null ; </a> 1
<a> case READ_DATA_FRAME : </a> 0
<a> if ( streamID == 0 ) { </a> 0
<a> state = State . FRAME_ERROR ; </a> 0
<a> fireProtocolException ( ctx , "Received invalid data frame" ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> int dataLength = Math . min ( maxChunkSize , length ) ; </a> 0
<a> if ( buffer . readableBytes ( ) < dataLength ) { </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame ( streamID ) ; </a> 0
<a> spdyDataFrame . setData ( buffer . readBytes ( dataLength ) ) ; </a> 0
<a> length -= dataLength ; </a> 0
<a> if ( length == 0 ) { </a> 0
<a> spdyDataFrame . setLast ( ( flags & SPDY_DATA_FLAG_FIN ) != 0 ) ; </a> 0
<a> state = State . READ_COMMON_HEADER ; </a> 0
<a> } </a> 0
<a> return spdyDataFrame ; </a> 1
<a> case DISCARD_FRAME : </a> 0
<a> int numBytes = Math . min ( buffer . readableBytes ( ) , length ) ; </a> 0
<a> buffer . skipBytes ( numBytes ) ; </a> 0
<a> length -= numBytes ; </a> 0
<a> if ( length == 0 ) { </a> 0
<a> state = State . READ_COMMON_HEADER ; </a> 0
<a> } </a> 0
<a> return null ; </a> 1
<a> case FRAME_ERROR : </a> 0
<a> buffer . skipBytes ( buffer . readableBytes ( ) ) ; </a> 0
<a> return null ; </a> 1
<a> default : </a> 0
<a> throw new Error ( "Shouldn't reach here." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private State readCommonHeader ( ByteBuf buffer ) { </a> 0
<a> if ( buffer . readableBytes ( ) < SPDY_HEADER_SIZE ) { </a> 0
<a> return State . READ_COMMON_HEADER ; </a> 0
<a> } </a> 0
<a> int frameOffset = buffer . readerIndex ( ) ; </a> 0
<a> int flagsOffset = frameOffset + SPDY_HEADER_FLAGS_OFFSET ; </a> 0
<a> int lengthOffset = frameOffset + SPDY_HEADER_LENGTH_OFFSET ; </a> 0
<a> buffer . skipBytes ( SPDY_HEADER_SIZE ) ; </a> 0
<a> boolean control = ( buffer . getByte ( frameOffset ) & 0x80 ) != 0 ; </a> 0
<a> flags = buffer . getByte ( flagsOffset ) ; </a> 0
<a> length = getUnsignedMedium ( buffer , lengthOffset ) ; </a> 0
<a> if ( control ) { </a> 0
<a> version = getUnsignedShort ( buffer , frameOffset ) & 0x7FFF ; </a> 0
<a> int typeOffset = frameOffset + SPDY_HEADER_TYPE_OFFSET ; </a> 0
<a> type = getUnsignedShort ( buffer , typeOffset ) ; </a> 0
<a> if ( version != spdyVersion || ! isValidControlFrameHeader ( ) ) { </a> 0
<a> return State . FRAME_ERROR ; </a> 0
<a> } </a> 0
<a> State nextState ; </a> 0
<a> if ( willGenerateControlFrame ( ) ) { </a> 0
<a> switch ( type ) { </a> 0
<a> case SPDY_SYN_STREAM_FRAME : </a> 0
<a> case SPDY_SYN_REPLY_FRAME : </a> 0
<a> case SPDY_HEADERS_FRAME : </a> 0
<a> nextState = State . READ_HEADER_BLOCK_FRAME ; </a> 0
<a> break ; </a> 0
<a> case SPDY_SETTINGS_FRAME : </a> 0
<a> nextState = State . READ_SETTINGS_FRAME ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> nextState = State . READ_CONTROL_FRAME ; </a> 0
<a> } </a> 0
<a> } else if ( length != 0 ) { </a> 0
<a> nextState = State . DISCARD_FRAME ; </a> 0
<a> } else { </a> 0
<a> nextState = State . READ_COMMON_HEADER ; </a> 0
<a> } </a> 0
<a> return nextState ; </a> 0
<a> } else { </a> 0
<a> streamID = getUnsignedInt ( buffer , frameOffset ) ; </a> 0
<a> return State . READ_DATA_FRAME ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private Object readControlFrame ( ByteBuf buffer ) { </a> 0
<a> int streamID ; </a> 0
<a> int statusCode ; </a> 0
<a> switch ( type ) { </a> 0
<a> case SPDY_RST_STREAM_FRAME : </a> 0
<a> if ( buffer . readableBytes ( ) < 8 ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> streamID = getUnsignedInt ( buffer , buffer . readerIndex ( ) ) ; </a> 0
<a> statusCode = getSignedInt ( buffer , buffer . readerIndex ( ) + 4 ) ; </a> 0
<a> buffer . skipBytes ( 8 ) ; </a> 0
<a> return new DefaultSpdyRstStreamFrame ( streamID , statusCode ) ; </a> 0
<a> case SPDY_PING_FRAME : </a> 0
<a> if ( buffer . readableBytes ( ) < 4 ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> int ID = getSignedInt ( buffer , buffer . readerIndex ( ) ) ; </a> 0
<a> buffer . skipBytes ( 4 ) ; </a> 0
<a> return new DefaultSpdyPingFrame ( ID ) ; </a> 0
<a> case SPDY_GOAWAY_FRAME : </a> 0
<a> int minLength = version < 3 ? 4 : 8 ; </a> 0
<a> if ( buffer . readableBytes ( ) < minLength ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> int lastGoodStreamId = getUnsignedInt ( buffer , buffer . readerIndex ( ) ) ; </a> 0
<a> buffer . skipBytes ( 4 ) ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> return new DefaultSpdyGoAwayFrame ( lastGoodStreamId ) ; </a> 0
<a> } </a> 0
<a> statusCode = getSignedInt ( buffer , buffer . readerIndex ( ) ) ; </a> 0
<a> buffer . skipBytes ( 4 ) ; </a> 0
<a> return new DefaultSpdyGoAwayFrame ( lastGoodStreamId , statusCode ) ; </a> 0
<a> case SPDY_WINDOW_UPDATE_FRAME : </a> 0
<a> if ( buffer . readableBytes ( ) < 8 ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> streamID = getUnsignedInt ( buffer , buffer . readerIndex ( ) ) ; </a> 0
<a> int deltaWindowSize = getUnsignedInt ( buffer , buffer . readerIndex ( ) + 4 ) ; </a> 0
<a> buffer . skipBytes ( 8 ) ; </a> 0
<a> return new DefaultSpdyWindowUpdateFrame ( streamID , deltaWindowSize ) ; </a> 0
<a> default : </a> 0
<a> throw new Error ( "Shouldn't reach here." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private SpdyHeaderBlock readHeaderBlockFrame ( ByteBuf buffer ) { </a> 0
<a> int minLength ; </a> 0
<a> int streamID ; </a> 0
<a> switch ( type ) { </a> 0
<a> case SPDY_SYN_STREAM_FRAME : </a> 0
<a> minLength = version < 3 ? 12 : 10 ; </a> 0
<a> if ( buffer . readableBytes ( ) < minLength ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> int offset = buffer . readerIndex ( ) ; </a> 0
<a> streamID = getUnsignedInt ( buffer , offset ) ; </a> 0
<a> int associatedToStreamId = getUnsignedInt ( buffer , offset + 4 ) ; </a> 0
<a> byte priority = ( byte ) ( buffer . getByte ( offset + 8 ) > > 5 & 0x07 ) ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> priority >>= 1 ; </a> 0
<a> } </a> 0
<a> buffer . skipBytes ( 10 ) ; </a> 0
<a> length -= 10 ; </a> 0
<a> if ( version < 3 && length == 2 && buffer . getShort ( buffer . readerIndex ( ) ) == 0 ) { </a> 0
<a> buffer . skipBytes ( 2 ) ; </a> 0
<a> length = 0 ; </a> 0
<a> } </a> 0
<a> SpdySynStreamFrame spdySynStreamFrame = </a> 0
<a> new DefaultSpdySynStreamFrame ( streamID , associatedToStreamId , priority ) ; </a> 0
<a> spdySynStreamFrame . setLast ( ( flags & SPDY_FLAG_FIN ) != 0 ) ; </a> 0
<a> spdySynStreamFrame . setUnidirectional ( ( flags & SPDY_FLAG_UNIDIRECTIONAL ) != 0 ) ; </a> 0
<a> return spdySynStreamFrame ; </a> 0
<a> case SPDY_SYN_REPLY_FRAME : </a> 0
<a> minLength = version < 3 ? 8 : 4 ; </a> 0
<a> if ( buffer . readableBytes ( ) < minLength ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> streamID = getUnsignedInt ( buffer , buffer . readerIndex ( ) ) ; </a> 0
<a> buffer . skipBytes ( 4 ) ; </a> 0
<a> length -= 4 ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> buffer . skipBytes ( 2 ) ; </a> 0
<a> length -= 2 ; </a> 0
<a> } </a> 0
<a> if ( version < 3 && length == 2 && buffer . getShort ( buffer . readerIndex ( ) ) == 0 ) { </a> 0
<a> buffer . skipBytes ( 2 ) ; </a> 0
<a> length = 0 ; </a> 0
<a> } </a> 0
<a> SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame ( streamID ) ; </a> 0
<a> spdySynReplyFrame . setLast ( ( flags & SPDY_FLAG_FIN ) != 0 ) ; </a> 0
<a> return spdySynReplyFrame ; </a> 0
<a> case SPDY_HEADERS_FRAME : </a> 0
<a> if ( buffer . readableBytes ( ) < 4 ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( version < 3 && length > 4 && buffer . readableBytes ( ) < 8 ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> streamID = getUnsignedInt ( buffer , buffer . readerIndex ( ) ) ; </a> 0
<a> buffer . skipBytes ( 4 ) ; </a> 0
<a> length -= 4 ; </a> 0
<a> if ( version < 3 && length != 0 ) { </a> 0
<a> buffer . skipBytes ( 2 ) ; </a> 0
<a> length -= 2 ; </a> 0
<a> } </a> 0
<a> if ( version < 3 && length == 2 && buffer . getShort ( buffer . readerIndex ( ) ) == 0 ) { </a> 0
<a> buffer . skipBytes ( 2 ) ; </a> 0
<a> length = 0 ; </a> 0
<a> } </a> 0
<a> SpdyHeadersFrame spdyHeadersFrame = new DefaultSpdyHeadersFrame ( streamID ) ; </a> 0
<a> spdyHeadersFrame . setLast ( ( flags & SPDY_FLAG_FIN ) != 0 ) ; </a> 0
<a> return spdyHeadersFrame ; </a> 0
<a> default : </a> 0
<a> throw new Error ( "Shouldn't reach here." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean ensureBytes ( int bytes ) throws Exception { </a> 0
<a> if ( decompressed . readableBytes ( ) >= bytes ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> headerBlockDecompressor . decode ( decompressed ) ; </a> 1
<a> return decompressed . readableBytes ( ) >= bytes ; </a> 1
<a> } </a> 0
<a> private int readLengthField ( ) { </a> 0
<a> if ( version < 3 ) { </a> 0
<a> return decompressed . readUnsignedShort ( ) ; </a> 0
<a> } else { </a> 0
<a> return decompressed . readInt ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void decodeHeaderBlock ( ByteBuf buffer ) throws Exception { </a> 0
<a> if ( decompressed == null ) { </a> 0
<a> headerSize = 0 ; </a> 0
<a> numHeaders = - 1 ; </a> 0
<a> decompressed = Unpooled . buffer ( 8192 ) ; </a> 0
<a> } </a> 0
<a> headerBlockDecompressor . setInput ( buffer ) ; </a> 0
<a> headerBlockDecompressor . decode ( decompressed ) ; </a> 0
<a> if ( spdyHeaderBlock == null ) { </a> 0
<a> decompressed = null ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> int lengthFieldSize = version < 3 ? 2 : 4 ; </a> 0
<a> if ( numHeaders == - 1 ) { </a> 0
<a> if ( decompressed . readableBytes ( ) < lengthFieldSize ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> numHeaders = readLengthField ( ) ; </a> 0
<a> if ( numHeaders < 0 ) { </a> 0
<a> spdyHeaderBlock . setInvalid ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> while ( numHeaders > 0 ) { </a> 0
<a> int headerSize = this . headerSize ; </a> 0
<a> decompressed . markReaderIndex ( ) ; </a> 0
<a> if ( ! ensureBytes ( lengthFieldSize ) ) { </a> 0
<a> decompressed . resetReaderIndex ( ) ; </a> 0
<a> decompressed . discardReadBytes ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> int nameLength = readLengthField ( ) ; </a> 0
<a> if ( nameLength <= 0 ) { </a> 0
<a> spdyHeaderBlock . setInvalid ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> headerSize += nameLength ; </a> 0
<a> if ( headerSize > maxHeaderSize ) { </a> 0
<a> throw new TooLongFrameException ( </a> 0
<a> "Header block exceeds " + maxHeaderSize ) ; </a> 0
<a> } </a> 0
<a> if ( ! ensureBytes ( nameLength ) ) { </a> 0
<a> decompressed . resetReaderIndex ( ) ; </a> 0
<a> decompressed . discardReadBytes ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> byte [ ] nameBytes = new byte [ nameLength ] ; </a> 0
<a> decompressed . readBytes ( nameBytes ) ; </a> 0
<a> String name = new String ( nameBytes , "UTF-8" ) ; </a> 0
<a> if ( spdyHeaderBlock . containsHeader ( name ) ) { </a> 0
<a> spdyHeaderBlock . setInvalid ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( ! ensureBytes ( lengthFieldSize ) ) { </a> 0
<a> decompressed . resetReaderIndex ( ) ; </a> 0
<a> decompressed . discardReadBytes ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> int valueLength = readLengthField ( ) ; </a> 0
<a> if ( valueLength <= 0 ) { </a> 0
<a> spdyHeaderBlock . setInvalid ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> headerSize += valueLength ; </a> 0
<a> if ( headerSize > maxHeaderSize ) { </a> 0
<a> throw new TooLongFrameException ( </a> 0
<a> "Header block exceeds " + maxHeaderSize ) ; </a> 0
<a> } </a> 0
<a> if ( ! ensureBytes ( valueLength ) ) { </a> 0
<a> decompressed . resetReaderIndex ( ) ; </a> 0
<a> decompressed . discardReadBytes ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> byte [ ] valueBytes = new byte [ valueLength ] ; </a> 0
<a> decompressed . readBytes ( valueBytes ) ; </a> 0
<a> int index = 0 ; </a> 0
<a> int offset = 0 ; </a> 0
<a> while ( index < valueLength ) { </a> 0
<a> while ( index < valueBytes . length && valueBytes [ index ] != ( byte ) 0 ) { </a> 0
<a> index ++ ; </a> 0
<a> } </a> 0
<a> if ( index < valueBytes . length && valueBytes [ index + 1 ] == ( byte ) 0 ) { </a> 0
<a> spdyHeaderBlock . setInvalid ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> String value = new String ( valueBytes , offset , index - offset , "UTF-8" ) ; </a> 0
<a> try { </a> 0
<a> spdyHeaderBlock . addHeader ( name , value ) ; </a> 0
<a> } catch ( IllegalArgumentException e ) { </a> 0
<a> spdyHeaderBlock . setInvalid ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> index ++ ; </a> 0
<a> offset = index ; </a> 0
<a> } </a> 0
<a> numHeaders -- ; </a> 0
<a> this . headerSize = headerSize ; </a> 0
<a> } </a> 0
<a> decompressed = null ; </a> 0
<a> } </a> 0
<a> private boolean isValidControlFrameHeader ( ) { </a> 0
<a> switch ( type ) { </a> 0
<a> case SPDY_SYN_STREAM_FRAME : </a> 0
<a> return version < 3 ? length >= 12 : length >= 10 ; </a> 0
<a> case SPDY_SYN_REPLY_FRAME : </a> 0
<a> return version < 3 ? length >= 8 : length >= 4 ; </a> 0
<a> case SPDY_RST_STREAM_FRAME : </a> 0
<a> return flags == 0 && length == 8 ; </a> 0
<a> case SPDY_SETTINGS_FRAME : </a> 0
<a> return length >= 4 ; </a> 0
<a> case SPDY_NOOP_FRAME : </a> 0
<a> return length == 0 ; </a> 0
<a> case SPDY_PING_FRAME : </a> 0
<a> return length == 4 ; </a> 0
<a> case SPDY_GOAWAY_FRAME : </a> 0
<a> return version < 3 ? length == 4 : length == 8 ; </a> 0
<a> case SPDY_HEADERS_FRAME : </a> 0
<a> if ( version < 3 ) { </a> 0
<a> return length == 4 || length >= 8 ; </a> 0
<a> } else { </a> 0
<a> return length >= 4 ; </a> 0
<a> } </a> 0
<a> case SPDY_WINDOW_UPDATE_FRAME : </a> 0
<a> return length == 8 ; </a> 0
<a> case SPDY_CREDENTIAL_FRAME : </a> 0
<a> default : </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean willGenerateControlFrame ( ) { </a> 0
<a> switch ( type ) { </a> 0
<a> case SPDY_SYN_STREAM_FRAME : </a> 0
<a> case SPDY_SYN_REPLY_FRAME : </a> 0
<a> case SPDY_RST_STREAM_FRAME : </a> 0
<a> case SPDY_SETTINGS_FRAME : </a> 0
<a> case SPDY_PING_FRAME : </a> 0
<a> case SPDY_GOAWAY_FRAME : </a> 0
<a> case SPDY_HEADERS_FRAME : </a> 0
<a> case SPDY_WINDOW_UPDATE_FRAME : </a> 0
<a> return true ; </a> 0
<a> case SPDY_NOOP_FRAME : </a> 0
<a> case SPDY_CREDENTIAL_FRAME : </a> 0
<a> default : </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void fireInvalidControlFrameException ( ChannelHandlerContext ctx ) { </a> 0
<a> String message = "Received invalid control frame" ; </a> 0
<a> switch ( type ) { </a> 0
<a> case SPDY_SYN_STREAM_FRAME : </a> 0
<a> message = "Received invalid SYN_STREAM control frame" ; </a> 0
<a> break ; </a> 0
<a> case SPDY_SYN_REPLY_FRAME : </a> 0
<a> message = "Received invalid SYN_REPLY control frame" ; </a> 0
<a> break ; </a> 0
<a> case SPDY_RST_STREAM_FRAME : </a> 0
<a> message = "Received invalid RST_STREAM control frame" ; </a> 0
<a> break ; </a> 0
<a> case SPDY_SETTINGS_FRAME : </a> 0
<a> message = "Received invalid SETTINGS control frame" ; </a> 0
<a> break ; </a> 0
<a> case SPDY_NOOP_FRAME : </a> 0
<a> message = "Received invalid NOOP control frame" ; </a> 0
<a> break ; </a> 0
<a> case SPDY_PING_FRAME : </a> 0
<a> message = "Received invalid PING control frame" ; </a> 0
<a> break ; </a> 0
<a> case SPDY_GOAWAY_FRAME : </a> 0
<a> message = "Received invalid GOAWAY control frame" ; </a> 0
<a> break ; </a> 0
<a> case SPDY_HEADERS_FRAME : </a> 0
<a> message = "Received invalid HEADERS control frame" ; </a> 0
<a> break ; </a> 0
<a> case SPDY_WINDOW_UPDATE_FRAME : </a> 0
<a> message = "Received invalid WINDOW_UPDATE control frame" ; </a> 0
<a> break ; </a> 0
<a> case SPDY_CREDENTIAL_FRAME : </a> 0
<a> message = "Received invalid CREDENTIAL control frame" ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> fireProtocolException ( ctx , message ) ; </a> 0
<a> } </a> 0
<a> private static void fireProtocolException ( ChannelHandlerContext ctx , String message ) { </a> 0
<a> ctx . fireExceptionCaught ( new SpdyProtocolException ( message ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Set ; </a> 0
<a> public interface SpdyHeaderBlock { </a> 0
<a> boolean isInvalid ( ) ; </a> 0
<a> void setInvalid ( ) ; </a> 0
<a> String getHeader ( String name ) ; </a> 0
<a> List < String > getHeaders ( String name ) ; </a> 0
<a> List < Map . Entry < String , String > > getHeaders ( ) ; </a> 0
<a> boolean containsHeader ( String name ) ; </a> 0
<a> Set < String > getHeaderNames ( ) ; </a> 0
<a> void addHeader ( String name , Object value ) ; </a> 0
<a> void setHeader ( String name , Object value ) ; </a> 0
<a> void setHeader ( String name , Iterable < ? > values ) ; </a> 0
<a> void removeHeader ( String name ) ; </a> 0
<a> void clearHeaders ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . util . internal . DetectionUtil ; </a> 1
<a> abstract class SpdyHeaderBlockCompressor { </a> 0
<a> static SpdyHeaderBlockCompressor newInstance ( </a> 0
<a> int version , int compressionLevel , int windowBits , int memLevel ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) >= 7 ) { </a> 1
<a> return new SpdyHeaderBlockZlibCompressor ( </a> 0
<a> version , compressionLevel ) ; </a> 0
<a> } else { </a> 0
<a> return new SpdyHeaderBlockJZlibCompressor ( </a> 0
<a> version , compressionLevel , windowBits , memLevel ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> abstract void setInput ( ByteBuf decompressed ) ; </a> 0
<a> abstract void encode ( ByteBuf compressed ) ; </a> 0
<a> abstract void end ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> abstract class SpdyHeaderBlockDecompressor { </a> 0
<a> static SpdyHeaderBlockDecompressor newInstance ( int version ) { </a> 0
<a> return new SpdyHeaderBlockZlibDecompressor ( version ) ; </a> 0
<a> } </a> 0
<a> abstract void setInput ( ByteBuf compressed ) ; </a> 0
<a> abstract void decode ( ByteBuf decompressed ) throws Exception ; </a> 1
<a> abstract void end ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import static io . netty . handler . codec . spdy . SpdyCodecUtil . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . handler . codec . compression . CompressionException ; </a> 0
<a> import io . netty . util . internal . jzlib . JZlib ; </a> 0
<a> import io . netty . util . internal . jzlib . ZStream ; </a> 0
<a> class SpdyHeaderBlockJZlibCompressor extends SpdyHeaderBlockCompressor { </a> 0
<a> private final ZStream z = new ZStream ( ) ; </a> 0
<a> public SpdyHeaderBlockJZlibCompressor ( </a> 0
<a> int version , int compressionLevel , int windowBits , int memLevel ) { </a> 0
<a> if ( version < SpdyConstants . SPDY_MIN_VERSION || version > SpdyConstants . SPDY_MAX_VERSION ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "unsupported version: " + version ) ; </a> 0
<a> } </a> 0
<a> if ( compressionLevel < 0 || compressionLevel > 9 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "compressionLevel: " + compressionLevel + " (expected: 0-9)" ) ; </a> 0
<a> } </a> 0
<a> if ( windowBits < 9 || windowBits > 15 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "windowBits: " + windowBits + " (expected: 9-15)" ) ; </a> 0
<a> } </a> 0
<a> if ( memLevel < 1 || memLevel > 9 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "memLevel: " + memLevel + " (expected: 1-9)" ) ; </a> 0
<a> } </a> 0
<a> int resultCode = z . deflateInit ( </a> 0
<a> compressionLevel , windowBits , memLevel , JZlib . W_ZLIB ) ; </a> 0
<a> if ( resultCode != JZlib . Z_OK ) { </a> 0
<a> throw new CompressionException ( </a> 0
<a> "failed to initialize an SPDY header block deflater: " + resultCode ) ; </a> 0
<a> } else { </a> 0
<a> if ( version < 3 ) { </a> 0
<a> resultCode = z . deflateSetDictionary ( SPDY2_DICT , SPDY2_DICT . length ) ; </a> 0
<a> } else { </a> 0
<a> resultCode = z . deflateSetDictionary ( SPDY_DICT , SPDY_DICT . length ) ; </a> 0
<a> } </a> 0
<a> if ( resultCode != JZlib . Z_OK ) { </a> 0
<a> throw new CompressionException ( </a> 0
<a> "failed to set the SPDY dictionary: " + resultCode ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setInput ( ByteBuf decompressed ) { </a> 0
<a> byte [ ] in = new byte [ decompressed . readableBytes ( ) ] ; </a> 1
<a> decompressed . readBytes ( in ) ; </a> 1
<a> z . next_in = in ; </a> 0
<a> z . next_in_index = 0 ; </a> 1
<a> z . avail_in = in . length ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( ByteBuf compressed ) { </a> 0
<a> try { </a> 0
<a> byte [ ] out = new byte [ ( int ) Math . ceil ( z . next_in . length * 1.001 ) + 12 ] ; </a> 1
<a> z . next_out = out ; </a> 1
<a> z . next_out_index = 0 ; </a> 1
<a> z . avail_out = out . length ; </a> 1
<a> int resultCode = z . deflate ( JZlib . Z_SYNC_FLUSH ) ; </a> 1
<a> if ( resultCode != JZlib . Z_OK ) { </a> 0
<a> throw new CompressionException ( "compression failure: " + resultCode ) ; </a> 0
<a> } </a> 0
<a> if ( z . next_out_index != 0 ) { </a> 1
<a> compressed . writeBytes ( out , 0 , z . next_out_index ) ; </a> 1
<a> } </a> 0
<a> } finally { </a> 0
<a> z . next_in = null ; </a> 0
<a> z . next_out = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void end ( ) { </a> 0
<a> z . deflateEnd ( ) ; </a> 0
<a> z . next_in = null ; </a> 0
<a> z . next_out = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import static io . netty . handler . codec . spdy . SpdyCodecUtil . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import java . util . zip . Deflater ; </a> 0
<a> class SpdyHeaderBlockZlibCompressor extends SpdyHeaderBlockCompressor { </a> 0
<a> private final byte [ ] out = new byte [ 8192 ] ; </a> 0
<a> private final Deflater compressor ; </a> 0
<a> public SpdyHeaderBlockZlibCompressor ( int version , int compressionLevel ) { </a> 0
<a> if ( version < SpdyConstants . SPDY_MIN_VERSION || version > SpdyConstants . SPDY_MAX_VERSION ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "unsupported version: " + version ) ; </a> 0
<a> } </a> 0
<a> if ( compressionLevel < 0 || compressionLevel > 9 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "compressionLevel: " + compressionLevel + " (expected: 0-9)" ) ; </a> 0
<a> } </a> 0
<a> compressor = new Deflater ( compressionLevel ) ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> compressor . setDictionary ( SPDY2_DICT ) ; </a> 0
<a> } else { </a> 0
<a> compressor . setDictionary ( SPDY_DICT ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setInput ( ByteBuf decompressed ) { </a> 0
<a> byte [ ] in = new byte [ decompressed . readableBytes ( ) ] ; </a> 0
<a> decompressed . readBytes ( in ) ; </a> 0
<a> compressor . setInput ( in ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( ByteBuf compressed ) { </a> 0
<a> while ( ! compressor . needsInput ( ) ) { </a> 1
<a> int numBytes = compressor . deflate ( out , 0 , out . length , Deflater . SYNC_FLUSH ) ; </a> 1
<a> compressed . writeBytes ( out , 0 , numBytes ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void end ( ) { </a> 0
<a> compressor . end ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import static io . netty . handler . codec . spdy . SpdyCodecUtil . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import java . util . zip . DataFormatException ; </a> 0
<a> import java . util . zip . Inflater ; </a> 0
<a> class SpdyHeaderBlockZlibDecompressor extends SpdyHeaderBlockDecompressor { </a> 0
<a> private final int version ; </a> 0
<a> private final byte [ ] out = new byte [ 8192 ] ; </a> 1
<a> private final Inflater decompressor = new Inflater ( ) ; </a> 0
<a> public SpdyHeaderBlockZlibDecompressor ( int version ) { </a> 0
<a> if ( version < SpdyConstants . SPDY_MIN_VERSION || version > SpdyConstants . SPDY_MAX_VERSION ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "unsupported version: " + version ) ; </a> 0
<a> } </a> 0
<a> this . version = version ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setInput ( ByteBuf compressed ) { </a> 0
<a> byte [ ] in = new byte [ compressed . readableBytes ( ) ] ; </a> 1
<a> compressed . readBytes ( in ) ; </a> 1
<a> decompressor . setInput ( in ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void decode ( ByteBuf decompressed ) throws Exception { </a> 1
<a> try { </a> 0
<a> int numBytes = decompressor . inflate ( out ) ; </a> 1
<a> if ( numBytes == 0 && decompressor . needsDictionary ( ) ) { </a> 0
<a> if ( version < 3 ) { </a> 0
<a> decompressor . setDictionary ( SPDY2_DICT ) ; </a> 0
<a> } else { </a> 0
<a> decompressor . setDictionary ( SPDY_DICT ) ; </a> 0
<a> } </a> 0
<a> numBytes = decompressor . inflate ( out ) ; </a> 1
<a> } </a> 0
<a> decompressed . writeBytes ( out , 0 , numBytes ) ; </a> 1
<a> } catch ( DataFormatException e ) { </a> 0
<a> throw new SpdyProtocolException ( </a> 1
<a> "Received invalid header block" , e ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void end ( ) { </a> 0
<a> decompressor . end ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . handler . codec . http . HttpMethod ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseStatus ; </a> 0
<a> import io . netty . handler . codec . http . HttpVersion ; </a> 0
<a> import java . util . LinkedList ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . TreeSet ; </a> 0
<a> public class SpdyHeaders { </a> 0
<a> public static final class HttpNames { </a> 0
<a> public static final String HOST = ":host" ; </a> 0
<a> public static final String METHOD = ":method" ; </a> 1
<a> public static final String PATH = ":path" ; </a> 0
<a> public static final String SCHEME = ":scheme" ; </a> 0
<a> public static final String STATUS = ":status" ; </a> 1
<a> public static final String VERSION = ":version" ; </a> 0
<a> private HttpNames ( ) { } </a> 0
<a> } </a> 0
<a> public static final class Spdy2HttpNames { </a> 0
<a> public static final String METHOD = "method" ; </a> 1
<a> public static final String SCHEME = "scheme" ; </a> 0
<a> public static final String STATUS = "status" ; </a> 1
<a> public static final String URL = "url" ; </a> 0
<a> public static final String VERSION = "version" ; </a> 0
<a> private Spdy2HttpNames ( ) { } </a> 0
<a> } </a> 0
<a> public static String getHeader ( SpdyHeaderBlock block , String name ) { </a> 0
<a> return block . getHeader ( name ) ; </a> 0
<a> } </a> 0
<a> public static String getHeader ( SpdyHeaderBlock block , String name , String defaultValue ) { </a> 0
<a> String value = block . getHeader ( name ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> return defaultValue ; </a> 0
<a> } </a> 0
<a> return value ; </a> 0
<a> } </a> 0
<a> public static void setHeader ( SpdyHeaderBlock block , String name , Object value ) { </a> 0
<a> block . setHeader ( name , value ) ; </a> 0
<a> } </a> 0
<a> public static void setHeader ( SpdyHeaderBlock block , String name , Iterable < ? > values ) { </a> 0
<a> block . setHeader ( name , values ) ; </a> 0
<a> } </a> 0
<a> public static void addHeader ( SpdyHeaderBlock block , String name , Object value ) { </a> 0
<a> block . addHeader ( name , value ) ; </a> 0
<a> } </a> 0
<a> public static void removeHost ( SpdyHeaderBlock block ) { </a> 0
<a> block . removeHeader ( HttpNames . HOST ) ; </a> 0
<a> } </a> 0
<a> public static String getHost ( SpdyHeaderBlock block ) { </a> 0
<a> return block . getHeader ( HttpNames . HOST ) ; </a> 0
<a> } </a> 0
<a> public static void setHost ( SpdyHeaderBlock block , String host ) { </a> 0
<a> block . setHeader ( HttpNames . HOST , host ) ; </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static void removeMethod ( SpdyHeaderBlock block ) { </a> 0
<a> removeMethod ( 2 , block ) ; </a> 0
<a> } </a> 0
<a> public static void removeMethod ( int spdyVersion , SpdyHeaderBlock block ) { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> block . removeHeader ( Spdy2HttpNames . METHOD ) ; </a> 0
<a> } else { </a> 0
<a> block . removeHeader ( HttpNames . METHOD ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static HttpMethod getMethod ( SpdyHeaderBlock block ) { </a> 0
<a> return getMethod ( 2 , block ) ; </a> 0
<a> } </a> 0
<a> public static HttpMethod getMethod ( int spdyVersion , SpdyHeaderBlock block ) { </a> 0
<a> try { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> return HttpMethod . valueOf ( block . getHeader ( Spdy2HttpNames . METHOD ) ) ; </a> 0
<a> } else { </a> 0
<a> return HttpMethod . valueOf ( block . getHeader ( HttpNames . METHOD ) ) ; </a> 0
<a> } </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static void setMethod ( SpdyHeaderBlock block , HttpMethod method ) { </a> 0
<a> setMethod ( 2 , block , method ) ; </a> 0
<a> } </a> 0
<a> public static void setMethod ( int spdyVersion , SpdyHeaderBlock block , HttpMethod method ) { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> block . setHeader ( Spdy2HttpNames . METHOD , method . getName ( ) ) ; </a> 1
<a> } else { </a> 0
<a> block . setHeader ( HttpNames . METHOD , method . getName ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static void removeScheme ( SpdyHeaderBlock block ) { </a> 0
<a> removeMethod ( 2 , block ) ; </a> 0
<a> } </a> 0
<a> public static void removeScheme ( int spdyVersion , SpdyHeaderBlock block ) { </a> 0
<a> if ( spdyVersion < 2 ) { </a> 0
<a> block . removeHeader ( Spdy2HttpNames . SCHEME ) ; </a> 0
<a> } else { </a> 0
<a> block . removeHeader ( HttpNames . SCHEME ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static String getScheme ( SpdyHeaderBlock block ) { </a> 0
<a> return getScheme ( 2 , block ) ; </a> 0
<a> } </a> 0
<a> public static String getScheme ( int spdyVersion , SpdyHeaderBlock block ) { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> return block . getHeader ( Spdy2HttpNames . SCHEME ) ; </a> 0
<a> } else { </a> 0
<a> return block . getHeader ( HttpNames . SCHEME ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static void setScheme ( SpdyHeaderBlock block , String scheme ) { </a> 0
<a> setScheme ( 2 , block , scheme ) ; </a> 0
<a> } </a> 0
<a> public static void setScheme ( int spdyVersion , SpdyHeaderBlock block , String scheme ) { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> block . setHeader ( Spdy2HttpNames . SCHEME , scheme ) ; </a> 0
<a> } else { </a> 0
<a> block . setHeader ( HttpNames . SCHEME , scheme ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static void removeStatus ( SpdyHeaderBlock block ) { </a> 0
<a> removeMethod ( 2 , block ) ; </a> 0
<a> } </a> 0
<a> public static void removeStatus ( int spdyVersion , SpdyHeaderBlock block ) { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> block . removeHeader ( Spdy2HttpNames . STATUS ) ; </a> 0
<a> } else { </a> 0
<a> block . removeHeader ( HttpNames . STATUS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static HttpResponseStatus getStatus ( SpdyHeaderBlock block ) { </a> 0
<a> return getStatus ( 2 , block ) ; </a> 0
<a> } </a> 0
<a> public static HttpResponseStatus getStatus ( int spdyVersion , SpdyHeaderBlock block ) { </a> 0
<a> try { </a> 0
<a> String status ; </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> status = block . getHeader ( Spdy2HttpNames . STATUS ) ; </a> 0
<a> } else { </a> 0
<a> status = block . getHeader ( HttpNames . STATUS ) ; </a> 0
<a> } </a> 0
<a> int space = status . indexOf ( ' ' ) ; </a> 0
<a> if ( space == - 1 ) { </a> 0
<a> return HttpResponseStatus . valueOf ( Integer . parseInt ( status ) ) ; </a> 0
<a> } else { </a> 0
<a> int code = Integer . parseInt ( status . substring ( 0 , space ) ) ; </a> 0
<a> String reasonPhrase = status . substring ( space + 1 ) ; </a> 0
<a> HttpResponseStatus responseStatus = HttpResponseStatus . valueOf ( code ) ; </a> 0
<a> if ( responseStatus . getReasonPhrase ( ) . equals ( reasonPhrase ) ) { </a> 1
<a> return responseStatus ; </a> 0
<a> } else { </a> 0
<a> return new HttpResponseStatus ( code , reasonPhrase ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static void setStatus ( SpdyHeaderBlock block , HttpResponseStatus status ) { </a> 0
<a> setStatus ( 2 , block , status ) ; </a> 0
<a> } </a> 0
<a> public static void setStatus ( int spdyVersion , SpdyHeaderBlock block , HttpResponseStatus status ) { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> block . setHeader ( Spdy2HttpNames . STATUS , status . toString ( ) ) ; </a> 0
<a> } else { </a> 0
<a> block . setHeader ( HttpNames . STATUS , status . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static void removeUrl ( SpdyHeaderBlock block ) { </a> 0
<a> removeUrl ( 2 , block ) ; </a> 0
<a> } </a> 0
<a> public static void removeUrl ( int spdyVersion , SpdyHeaderBlock block ) { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> block . removeHeader ( Spdy2HttpNames . URL ) ; </a> 0
<a> } else { </a> 0
<a> block . removeHeader ( HttpNames . PATH ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static String getUrl ( SpdyHeaderBlock block ) { </a> 0
<a> return getUrl ( 2 , block ) ; </a> 0
<a> } </a> 0
<a> public static String getUrl ( int spdyVersion , SpdyHeaderBlock block ) { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> return block . getHeader ( Spdy2HttpNames . URL ) ; </a> 0
<a> } else { </a> 0
<a> return block . getHeader ( HttpNames . PATH ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static void setUrl ( SpdyHeaderBlock block , String path ) { </a> 0
<a> setUrl ( 2 , block , path ) ; </a> 0
<a> } </a> 0
<a> public static void setUrl ( int spdyVersion , SpdyHeaderBlock block , String path ) { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> block . setHeader ( Spdy2HttpNames . URL , path ) ; </a> 0
<a> } else { </a> 0
<a> block . setHeader ( HttpNames . PATH , path ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static void removeVersion ( SpdyHeaderBlock block ) { </a> 0
<a> removeVersion ( 2 , block ) ; </a> 0
<a> } </a> 0
<a> public static void removeVersion ( int spdyVersion , SpdyHeaderBlock block ) { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> block . removeHeader ( Spdy2HttpNames . VERSION ) ; </a> 0
<a> } else { </a> 0
<a> block . removeHeader ( HttpNames . VERSION ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static HttpVersion getVersion ( SpdyHeaderBlock block ) { </a> 0
<a> return getVersion ( 2 , block ) ; </a> 0
<a> } </a> 0
<a> public static HttpVersion getVersion ( int spdyVersion , SpdyHeaderBlock block ) { </a> 0
<a> try { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> return HttpVersion . valueOf ( block . getHeader ( Spdy2HttpNames . VERSION ) ) ; </a> 0
<a> } else { </a> 0
<a> return HttpVersion . valueOf ( block . getHeader ( HttpNames . VERSION ) ) ; </a> 0
<a> } </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Deprecated </a> 0
<a> public static void setVersion ( SpdyHeaderBlock block , HttpVersion httpVersion ) { </a> 0
<a> setVersion ( 2 , block , httpVersion ) ; </a> 0
<a> } </a> 0
<a> public static void setVersion ( int spdyVersion , SpdyHeaderBlock block , HttpVersion httpVersion ) { </a> 0
<a> if ( spdyVersion < 3 ) { </a> 0
<a> block . setHeader ( Spdy2HttpNames . VERSION , httpVersion . getText ( ) ) ; </a> 0
<a> } else { </a> 0
<a> block . setHeader ( HttpNames . VERSION , httpVersion . getText ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static final int BUCKET_SIZE = 17 ; </a> 0
<a> private static int hash ( String name ) { </a> 0
<a> int h = 0 ; </a> 0
<a> for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { </a> 0
<a> char c = name . charAt ( i ) ; </a> 0
<a> if ( c >= 'A' && c <= 'Z' ) { </a> 0
<a> c += 32 ; </a> 0
<a> } </a> 0
<a> h = 31 * h + c ; </a> 0
<a> } </a> 0
<a> if ( h > 0 ) { </a> 0
<a> return h ; </a> 0
<a> } else if ( h == Integer . MIN_VALUE ) { </a> 0
<a> return Integer . MAX_VALUE ; </a> 0
<a> } else { </a> 0
<a> return - h ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static boolean eq ( String name1 , String name2 ) { </a> 0
<a> int nameLen = name1 . length ( ) ; </a> 0
<a> if ( nameLen != name2 . length ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> for ( int i = nameLen - 1 ; i >= 0 ; i -- ) { </a> 0
<a> char c1 = name1 . charAt ( i ) ; </a> 0
<a> char c2 = name2 . charAt ( i ) ; </a> 0
<a> if ( c1 != c2 ) { </a> 0
<a> if ( c1 >= 'A' && c1 <= 'Z' ) { </a> 0
<a> c1 += 32 ; </a> 0
<a> } </a> 0
<a> if ( c2 >= 'A' && c2 <= 'Z' ) { </a> 0
<a> c2 += 32 ; </a> 0
<a> } </a> 0
<a> if ( c1 != c2 ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> private static int index ( int hash ) { </a> 0
<a> return hash % BUCKET_SIZE ; </a> 0
<a> } </a> 0
<a> private final Entry [ ] entries = new Entry [ BUCKET_SIZE ] ; </a> 1
<a> private final Entry head = new Entry ( - 1 , null , null ) ; </a> 1
<a> SpdyHeaders ( ) { </a> 0
<a> head . before = head . after = head ; </a> 0
<a> } </a> 0
<a> void addHeader ( final String name , final Object value ) { </a> 0
<a> String lowerCaseName = name . toLowerCase ( ) ; </a> 0
<a> SpdyCodecUtil . validateHeaderName ( lowerCaseName ) ; </a> 0
<a> String strVal = toString ( value ) ; </a> 0
<a> SpdyCodecUtil . validateHeaderValue ( strVal ) ; </a> 0
<a> int h = hash ( lowerCaseName ) ; </a> 0
<a> int i = index ( h ) ; </a> 0
<a> addHeader0 ( h , i , lowerCaseName , strVal ) ; </a> 0
<a> } </a> 0
<a> private void addHeader0 ( int h , int i , final String name , final String value ) { </a> 0
<a> Entry e = entries [ i ] ; </a> 1
<a> Entry newEntry ; </a> 1
<a> entries [ i ] = newEntry = new Entry ( h , name , value ) ; </a> 1
<a> newEntry . next = e ; </a> 0
<a> newEntry . addBefore ( head ) ; </a> 0
<a> } </a> 0
<a> void removeHeader ( final String name ) { </a> 0
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> String lowerCaseName = name . toLowerCase ( ) ; </a> 0
<a> int h = hash ( lowerCaseName ) ; </a> 0
<a> int i = index ( h ) ; </a> 0
<a> removeHeader0 ( h , i , lowerCaseName ) ; </a> 0
<a> } </a> 0
<a> private void removeHeader0 ( int h , int i , String name ) { </a> 0
<a> Entry e = entries [ i ] ; </a> 1
<a> if ( e == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> for ( ; ; ) { </a> 0
<a> if ( e . hash == h && eq ( name , e . key ) ) { </a> 0
<a> e . remove ( ) ; </a> 0
<a> Entry next = e . next ; </a> 1
<a> if ( next != null ) { </a> 0
<a> entries [ i ] = next ; </a> 0
<a> e = next ; </a> 0
<a> } else { </a> 0
<a> entries [ i ] = null ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( ; ; ) { </a> 0
<a> Entry next = e . next ; </a> 1
<a> if ( next == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( next . hash == h && eq ( name , next . key ) ) { </a> 0
<a> e . next = next . next ; </a> 0
<a> next . remove ( ) ; </a> 0
<a> } else { </a> 0
<a> e = next ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void setHeader ( final String name , final Object value ) { </a> 0
<a> String lowerCaseName = name . toLowerCase ( ) ; </a> 0
<a> SpdyCodecUtil . validateHeaderName ( lowerCaseName ) ; </a> 0
<a> String strVal = toString ( value ) ; </a> 0
<a> SpdyCodecUtil . validateHeaderValue ( strVal ) ; </a> 0
<a> int h = hash ( lowerCaseName ) ; </a> 0
<a> int i = index ( h ) ; </a> 0
<a> removeHeader0 ( h , i , lowerCaseName ) ; </a> 0
<a> addHeader0 ( h , i , lowerCaseName , strVal ) ; </a> 0
<a> } </a> 0
<a> void setHeader ( final String name , final Iterable < ? > values ) { </a> 0
<a> if ( values == null ) { </a> 0
<a> throw new NullPointerException ( "values" ) ; </a> 0
<a> } </a> 0
<a> String lowerCaseName = name . toLowerCase ( ) ; </a> 0
<a> SpdyCodecUtil . validateHeaderName ( lowerCaseName ) ; </a> 0
<a> int h = hash ( lowerCaseName ) ; </a> 0
<a> int i = index ( h ) ; </a> 0
<a> removeHeader0 ( h , i , lowerCaseName ) ; </a> 0
<a> for ( Object v : values ) { </a> 0
<a> if ( v == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> String strVal = toString ( v ) ; </a> 0
<a> SpdyCodecUtil . validateHeaderValue ( strVal ) ; </a> 0
<a> addHeader0 ( h , i , lowerCaseName , strVal ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void clearHeaders ( ) { </a> 0
<a> for ( int i = 0 ; i < entries . length ; i ++ ) { </a> 0
<a> entries [ i ] = null ; </a> 0
<a> } </a> 0
<a> head . before = head . after = head ; </a> 0
<a> } </a> 0
<a> String getHeader ( final String name ) { </a> 0
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> int h = hash ( name ) ; </a> 0
<a> int i = index ( h ) ; </a> 0
<a> Entry e = entries [ i ] ; </a> 1
<a> while ( e != null ) { </a> 0
<a> if ( e . hash == h && eq ( name , e . key ) ) { </a> 0
<a> return e . value ; </a> 0
<a> } </a> 0
<a> e = e . next ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> List < String > getHeaders ( final String name ) { </a> 0
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> LinkedList < String > values = new LinkedList < String > ( ) ; </a> 0
<a> int h = hash ( name ) ; </a> 0
<a> int i = index ( h ) ; </a> 0
<a> Entry e = entries [ i ] ; </a> 1
<a> while ( e != null ) { </a> 0
<a> if ( e . hash == h && eq ( name , e . key ) ) { </a> 0
<a> values . addFirst ( e . value ) ; </a> 0
<a> } </a> 0
<a> e = e . next ; </a> 0
<a> } </a> 0
<a> return values ; </a> 0
<a> } </a> 0
<a> List < Map . Entry < String , String > > getHeaders ( ) { </a> 0
<a> List < Map . Entry < String , String > > all = </a> 0
<a> new LinkedList < Map . Entry < String , String > > ( ) ; </a> 0
<a> Entry e = head . after ; </a> 1
<a> while ( e != head ) { </a> 0
<a> all . add ( e ) ; </a> 0
<a> e = e . after ; </a> 0
<a> } </a> 0
<a> return all ; </a> 0
<a> } </a> 0
<a> boolean containsHeader ( String name ) { </a> 0
<a> return getHeader ( name ) != null ; </a> 0
<a> } </a> 0
<a> Set < String > getHeaderNames ( ) { </a> 0
<a> Set < String > names = new TreeSet < String > ( ) ; </a> 0
<a> Entry e = head . after ; </a> 1
<a> while ( e != head ) { </a> 0
<a> names . add ( e . key ) ; </a> 0
<a> e = e . after ; </a> 0
<a> } </a> 0
<a> return names ; </a> 0
<a> } </a> 0
<a> private static String toString ( Object value ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return value . toString ( ) ; </a> 0
<a> } </a> 0
<a> private static final class Entry implements Map . Entry < String , String > { </a> 1
<a> final int hash ; </a> 0
<a> final String key ; </a> 0
<a> String value ; </a> 0
<a> Entry next ; </a> 1
<a> Entry before , after ; </a> 1
<a> Entry ( int hash , String key , String value ) { </a> 1
<a> this . hash = hash ; </a> 0
<a> this . key = key ; </a> 0
<a> this . value = value ; </a> 0
<a> } </a> 0
<a> void remove ( ) { </a> 0
<a> before . after = after ; </a> 0
<a> after . before = before ; </a> 0
<a> } </a> 0
<a> void addBefore ( Entry e ) { </a> 1
<a> after = e ; </a> 0
<a> before = e . before ; </a> 0
<a> before . after = this ; </a> 0
<a> after . before = this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String getKey ( ) { </a> 0
<a> return key ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String getValue ( ) { </a> 0
<a> return value ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String setValue ( String value ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( "value" ) ; </a> 0
<a> } </a> 0
<a> SpdyCodecUtil . validateHeaderValue ( value ) ; </a> 0
<a> String oldValue = this . value ; </a> 0
<a> this . value = value ; </a> 0
<a> return oldValue ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return key + "=" + value ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public interface SpdyHeadersFrame extends SpdyHeaderBlock , SpdyControlFrame { </a> 0
<a> int getStreamId ( ) ; </a> 0
<a> void setStreamId ( int streamID ) ; </a> 0
<a> boolean isLast ( ) ; </a> 0
<a> void setLast ( boolean last ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . channel . CombinedChannelHandler ; </a> 0
<a> public class SpdyHttpCodec extends CombinedChannelHandler { </a> 0
<a> public SpdyHttpCodec ( int version , int maxContentLength ) { </a> 0
<a> super ( </a> 0
<a> new SpdyHttpDecoder ( version , maxContentLength ) , </a> 0
<a> new SpdyHttpEncoder ( version ) ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . MessageToMessageDecoder ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import io . netty . handler . codec . http . DefaultHttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . DefaultHttpResponse ; </a> 1
<a> import io . netty . handler . codec . http . HttpHeaders ; </a> 0
<a> import io . netty . handler . codec . http . HttpMessage ; </a> 0
<a> import io . netty . handler . codec . http . HttpMethod ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseStatus ; </a> 0
<a> import io . netty . handler . codec . http . HttpVersion ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class SpdyHttpDecoder extends MessageToMessageDecoder < Object , HttpMessage > { </a> 0
<a> private final int spdyVersion ; </a> 0
<a> private final int maxContentLength ; </a> 0
<a> private final Map < Integer , HttpMessage > messageMap = new HashMap < Integer , HttpMessage > ( ) ; </a> 1
<a> public SpdyHttpDecoder ( int version , int maxContentLength ) { </a> 0
<a> if ( version < SpdyConstants . SPDY_MIN_VERSION || version > SpdyConstants . SPDY_MAX_VERSION ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "unsupported version: " + version ) ; </a> 0
<a> } </a> 0
<a> if ( maxContentLength <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxContentLength must be a positive integer: " + maxContentLength ) ; </a> 0
<a> } </a> 0
<a> spdyVersion = version ; </a> 0
<a> this . maxContentLength = maxContentLength ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public HttpMessage decode ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 0
<a> if ( msg instanceof SpdySynStreamFrame ) { </a> 0
<a> SpdySynStreamFrame spdySynStreamFrame = ( SpdySynStreamFrame ) msg ; </a> 0
<a> int streamID = spdySynStreamFrame . getStreamId ( ) ; </a> 0
<a> if ( SpdyCodecUtil . isServerId ( streamID ) ) { </a> 0
<a> int associatedToStreamId = spdySynStreamFrame . getAssociatedToStreamId ( ) ; </a> 1
<a> if ( associatedToStreamId == 0 ) { </a> 0
<a> SpdyRstStreamFrame spdyRstStreamFrame = </a> 0
<a> new DefaultSpdyRstStreamFrame ( streamID , SpdyStreamStatus . INVALID_STREAM ) ; </a> 0
<a> ctx . write ( spdyRstStreamFrame ) ; </a> 0
<a> } </a> 0
<a> String URL = SpdyHeaders . getUrl ( spdyVersion , spdySynStreamFrame ) ; </a> 0
<a> if ( URL == null ) { </a> 0
<a> SpdyRstStreamFrame spdyRstStreamFrame = </a> 0
<a> new DefaultSpdyRstStreamFrame ( streamID , SpdyStreamStatus . PROTOCOL_ERROR ) ; </a> 0
<a> ctx . write ( spdyRstStreamFrame ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> HttpResponse httpResponse = createHttpResponse ( spdyVersion , spdySynStreamFrame ) ; </a> 1
<a> SpdyHttpHeaders . setStreamId ( httpResponse , streamID ) ; </a> 1
<a> SpdyHttpHeaders . setAssociatedToStreamId ( httpResponse , associatedToStreamId ) ; </a> 1
<a> SpdyHttpHeaders . setPriority ( httpResponse , spdySynStreamFrame . getPriority ( ) ) ; </a> 1
<a> SpdyHttpHeaders . setUrl ( httpResponse , URL ) ; </a> 1
<a> if ( spdySynStreamFrame . isLast ( ) ) { </a> 0
<a> HttpHeaders . setContentLength ( httpResponse , 0 ) ; </a> 1
<a> return httpResponse ; </a> 1
<a> } else { </a> 0
<a> messageMap . put ( new Integer ( streamID ) , httpResponse ) ; </a> 1
<a> } </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> SpdyRstStreamFrame spdyRstStreamFrame = </a> 0
<a> new DefaultSpdyRstStreamFrame ( streamID , SpdyStreamStatus . PROTOCOL_ERROR ) ; </a> 0
<a> ctx . write ( spdyRstStreamFrame ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> try { </a> 0
<a> HttpRequest httpRequest = createHttpRequest ( spdyVersion , spdySynStreamFrame ) ; </a> 1
<a> SpdyHttpHeaders . setStreamId ( httpRequest , streamID ) ; </a> 1
<a> if ( spdySynStreamFrame . isLast ( ) ) { </a> 0
<a> return httpRequest ; </a> 1
<a> } else { </a> 0
<a> messageMap . put ( new Integer ( streamID ) , httpRequest ) ; </a> 1
<a> } </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame ( streamID ) ; </a> 0
<a> spdySynReplyFrame . setLast ( true ) ; </a> 0
<a> SpdyHeaders . setStatus ( spdyVersion , spdySynReplyFrame , HttpResponseStatus . BAD_REQUEST ) ; </a> 0
<a> SpdyHeaders . setVersion ( spdyVersion , spdySynReplyFrame , HttpVersion . HTTP_1_0 ) ; </a> 0
<a> ctx . write ( spdySynReplyFrame ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdySynReplyFrame ) { </a> 0
<a> SpdySynReplyFrame spdySynReplyFrame = ( SpdySynReplyFrame ) msg ; </a> 0
<a> int streamID = spdySynReplyFrame . getStreamId ( ) ; </a> 0
<a> try { </a> 0
<a> HttpResponse httpResponse = createHttpResponse ( spdyVersion , spdySynReplyFrame ) ; </a> 1
<a> SpdyHttpHeaders . setStreamId ( httpResponse , streamID ) ; </a> 1
<a> if ( spdySynReplyFrame . isLast ( ) ) { </a> 0
<a> HttpHeaders . setContentLength ( httpResponse , 0 ) ; </a> 1
<a> return httpResponse ; </a> 1
<a> } else { </a> 0
<a> messageMap . put ( new Integer ( streamID ) , httpResponse ) ; </a> 1
<a> } </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> SpdyRstStreamFrame spdyRstStreamFrame = </a> 0
<a> new DefaultSpdyRstStreamFrame ( streamID , SpdyStreamStatus . PROTOCOL_ERROR ) ; </a> 0
<a> ctx . write ( spdyRstStreamFrame ) ; </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdyHeadersFrame ) { </a> 0
<a> SpdyHeadersFrame spdyHeadersFrame = ( SpdyHeadersFrame ) msg ; </a> 0
<a> Integer streamID = new Integer ( spdyHeadersFrame . getStreamId ( ) ) ; </a> 1
<a> HttpMessage httpMessage = messageMap . get ( streamID ) ; </a> 0
<a> if ( httpMessage == null ) { </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> for ( Map . Entry < String , String > e : spdyHeadersFrame . getHeaders ( ) ) { </a> 0
<a> httpMessage . addHeader ( e . getKey ( ) , e . getValue ( ) ) ; </a> 1
<a> } </a> 0
<a> } else if ( msg instanceof SpdyDataFrame ) { </a> 0
<a> SpdyDataFrame spdyDataFrame = ( SpdyDataFrame ) msg ; </a> 0
<a> Integer streamID = new Integer ( spdyDataFrame . getStreamId ( ) ) ; </a> 1
<a> HttpMessage httpMessage = messageMap . get ( streamID ) ; </a> 1
<a> if ( httpMessage == null ) { </a> 1
<a> return null ; </a> 1
<a> } </a> 0
<a> ByteBuf content = httpMessage . getContent ( ) ; </a> 1
<a> if ( content . readableBytes ( ) > maxContentLength - spdyDataFrame . getData ( ) . readableBytes ( ) ) { </a> 0
<a> messageMap . remove ( streamID ) ; </a> 0
<a> throw new TooLongFrameException ( </a> 0
<a> "HTTP content length exceeded " + maxContentLength + " bytes." ) ; </a> 0
<a> } </a> 0
<a> ByteBuf spdyDataFrameData = spdyDataFrame . getData ( ) ; </a> 0
<a> int spdyDataFrameDataLen = spdyDataFrameData . readableBytes ( ) ; </a> 0
<a> if ( content == Unpooled . EMPTY_BUFFER ) { </a> 1
<a> content = Unpooled . buffer ( spdyDataFrameDataLen ) ; </a> 1
<a> content . writeBytes ( spdyDataFrameData , spdyDataFrameData . readerIndex ( ) , spdyDataFrameDataLen ) ; </a> 0
<a> httpMessage . setContent ( content ) ; </a> 1
<a> } else { </a> 1
<a> content . writeBytes ( spdyDataFrameData , spdyDataFrameData . readerIndex ( ) , spdyDataFrameDataLen ) ; </a> 1
<a> } </a> 1
<a> if ( spdyDataFrame . isLast ( ) ) { </a> 0
<a> HttpHeaders . setContentLength ( httpMessage , content . readableBytes ( ) ) ; </a> 1
<a> messageMap . remove ( streamID ) ; </a> 0
<a> return httpMessage ; </a> 1
<a> } </a> 0
<a> } else if ( msg instanceof SpdyRstStreamFrame ) { </a> 0
<a> SpdyRstStreamFrame spdyRstStreamFrame = ( SpdyRstStreamFrame ) msg ; </a> 0
<a> Integer streamID = new Integer ( spdyRstStreamFrame . getStreamId ( ) ) ; </a> 1
<a> messageMap . remove ( streamID ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> private static HttpRequest createHttpRequest ( int spdyVersion , SpdyHeaderBlock requestFrame ) </a> 1
<a> throws Exception { </a> 0
<a> HttpMethod method = SpdyHeaders . getMethod ( spdyVersion , requestFrame ) ; </a> 0
<a> String url = SpdyHeaders . getUrl ( spdyVersion , requestFrame ) ; </a> 0
<a> HttpVersion httpVersion = SpdyHeaders . getVersion ( spdyVersion , requestFrame ) ; </a> 0
<a> SpdyHeaders . removeMethod ( spdyVersion , requestFrame ) ; </a> 0
<a> SpdyHeaders . removeUrl ( spdyVersion , requestFrame ) ; </a> 0
<a> SpdyHeaders . removeVersion ( spdyVersion , requestFrame ) ; </a> 0
<a> HttpRequest httpRequest = new DefaultHttpRequest ( httpVersion , method , url ) ; </a> 1
<a> SpdyHeaders . removeScheme ( spdyVersion , requestFrame ) ; </a> 0
<a> if ( spdyVersion >= 3 ) { </a> 1
<a> String host = SpdyHeaders . getHost ( requestFrame ) ; </a> 0
<a> SpdyHeaders . removeHost ( requestFrame ) ; </a> 0
<a> HttpHeaders . setHost ( httpRequest , host ) ; </a> 1
<a> } </a> 1
<a> for ( Map . Entry < String , String > e : requestFrame . getHeaders ( ) ) { </a> 0
<a> httpRequest . addHeader ( e . getKey ( ) , e . getValue ( ) ) ; </a> 1
<a> } </a> 0
<a> HttpHeaders . setKeepAlive ( httpRequest , true ) ; </a> 1
<a> httpRequest . removeHeader ( HttpHeaders . Names . TRANSFER_ENCODING ) ; </a> 1
<a> return httpRequest ; </a> 1
<a> } </a> 0
<a> private static HttpResponse createHttpResponse ( int spdyVersion , SpdyHeaderBlock responseFrame ) </a> 1
<a> throws Exception { </a> 0
<a> HttpResponseStatus status = SpdyHeaders . getStatus ( spdyVersion , responseFrame ) ; </a> 0
<a> HttpVersion version = SpdyHeaders . getVersion ( spdyVersion , responseFrame ) ; </a> 0
<a> SpdyHeaders . removeStatus ( spdyVersion , responseFrame ) ; </a> 0
<a> SpdyHeaders . removeVersion ( spdyVersion , responseFrame ) ; </a> 0
<a> HttpResponse httpResponse = new DefaultHttpResponse ( version , status ) ; </a> 1
<a> for ( Map . Entry < String , String > e : responseFrame . getHeaders ( ) ) { </a> 0
<a> httpResponse . addHeader ( e . getKey ( ) , e . getValue ( ) ) ; </a> 1
<a> } </a> 0
<a> HttpHeaders . setKeepAlive ( httpResponse , true ) ; </a> 1
<a> httpResponse . removeHeader ( HttpHeaders . Names . TRANSFER_ENCODING ) ; </a> 1
<a> httpResponse . removeHeader ( HttpHeaders . Names . TRAILER ) ; </a> 1
<a> return httpResponse ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . MessageToMessageEncoder ; </a> 0
<a> import io . netty . handler . codec . UnsupportedMessageTypeException ; </a> 0
<a> import io . netty . handler . codec . http . HttpChunk ; </a> 0
<a> import io . netty . handler . codec . http . HttpChunkTrailer ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders ; </a> 0
<a> import io . netty . handler . codec . http . HttpMessage ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import java . util . ArrayList ; </a> 1
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class SpdyHttpEncoder extends MessageToMessageEncoder < Object , Object > { </a> 0
<a> private final int spdyVersion ; </a> 1
<a> private volatile int currentStreamId ; </a> 0
<a> public SpdyHttpEncoder ( int version ) { </a> 0
<a> if ( version < SpdyConstants . SPDY_MIN_VERSION || version > SpdyConstants . SPDY_MAX_VERSION ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "unsupported version: " + version ) ; </a> 0
<a> } </a> 0
<a> spdyVersion = version ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof HttpRequest || </a> 0
<a> msg instanceof HttpResponse || </a> 0
<a> msg instanceof HttpChunk ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object encode ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 0
<a> List < Object > out = new ArrayList < Object > ( ) ; </a> 1
<a> if ( msg instanceof HttpRequest ) { </a> 0
<a> HttpRequest httpRequest = ( HttpRequest ) msg ; </a> 0
<a> SpdySynStreamFrame spdySynStreamFrame = createSynStreamFrame ( httpRequest ) ; </a> 0
<a> int streamID = spdySynStreamFrame . getStreamId ( ) ; </a> 0
<a> out . add ( spdySynStreamFrame ) ; </a> 0
<a> addContent ( out , streamID , httpRequest ) ; </a> 0
<a> } else if ( msg instanceof HttpResponse ) { </a> 0
<a> HttpResponse httpResponse = ( HttpResponse ) msg ; </a> 0
<a> if ( httpResponse . containsHeader ( SpdyHttpHeaders . Names . ASSOCIATED_TO_STREAM_ID ) ) { </a> 1
<a> SpdySynStreamFrame spdySynStreamFrame = createSynStreamFrame ( httpResponse ) ; </a> 1
<a> int streamID = spdySynStreamFrame . getStreamId ( ) ; </a> 0
<a> out . add ( spdySynStreamFrame ) ; </a> 1
<a> addContent ( out , streamID , httpResponse ) ; </a> 0
<a> } else { </a> 1
<a> SpdySynReplyFrame spdySynReplyFrame = createSynReplyFrame ( httpResponse ) ; </a> 1
<a> int streamID = spdySynReplyFrame . getStreamId ( ) ; </a> 0
<a> out . add ( spdySynReplyFrame ) ; </a> 1
<a> addContent ( out , streamID , httpResponse ) ; </a> 0
<a> } </a> 1
<a> } else if ( msg instanceof HttpChunk ) { </a> 0
<a> HttpChunk chunk = ( HttpChunk ) msg ; </a> 0
<a> SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame ( currentStreamId ) ; </a> 0
<a> spdyDataFrame . setData ( chunk . getContent ( ) ) ; </a> 1
<a> spdyDataFrame . setLast ( chunk . isLast ( ) ) ; </a> 0
<a> if ( chunk instanceof HttpChunkTrailer ) { </a> 0
<a> HttpChunkTrailer trailer = ( HttpChunkTrailer ) chunk ; </a> 0
<a> List < Map . Entry < String , String > > trailers = trailer . getHeaders ( ) ; </a> 1
<a> if ( trailers . isEmpty ( ) ) { </a> 0
<a> out . add ( spdyDataFrame ) ; </a> 0
<a> } else { </a> 0
<a> SpdyHeadersFrame spdyHeadersFrame = new DefaultSpdyHeadersFrame ( currentStreamId ) ; </a> 0
<a> for ( Map . Entry < String , String > entry : trailers ) { </a> 0
<a> spdyHeadersFrame . addHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; </a> 0
<a> } </a> 0
<a> out . add ( spdyHeadersFrame ) ; </a> 0
<a> out . add ( spdyDataFrame ) ; </a> 1
<a> } </a> 0
<a> } else { </a> 0
<a> out . add ( spdyDataFrame ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 1
<a> throw new UnsupportedMessageTypeException ( msg ) ; </a> 0
<a> } </a> 0
<a> return out . toArray ( ) ; </a> 1
<a> } </a> 0
<a> private static void addContent ( List < Object > out , int streamID , HttpMessage httpMessage ) { </a> 0
<a> if ( ! httpMessage . getContent ( ) . readable ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame ( streamID ) ; </a> 0
<a> spdyDataFrame . setData ( httpMessage . getContent ( ) ) ; </a> 0
<a> spdyDataFrame . setLast ( true ) ; </a> 0
<a> out . add ( spdyDataFrame ) ; </a> 0
<a> } </a> 0
<a> private SpdySynStreamFrame createSynStreamFrame ( HttpMessage httpMessage ) </a> 0
<a> throws Exception { </a> 0
<a> boolean chunked = httpMessage . getTransferEncoding ( ) . isMultiple ( ) ; </a> 0
<a> int streamID = SpdyHttpHeaders . getStreamId ( httpMessage ) ; </a> 0
<a> int associatedToStreamId = SpdyHttpHeaders . getAssociatedToStreamId ( httpMessage ) ; </a> 0
<a> byte priority = SpdyHttpHeaders . getPriority ( httpMessage ) ; </a> 0
<a> String URL = SpdyHttpHeaders . getUrl ( httpMessage ) ; </a> 0
<a> String scheme = SpdyHttpHeaders . getScheme ( httpMessage ) ; </a> 0
<a> SpdyHttpHeaders . removeStreamId ( httpMessage ) ; </a> 0
<a> SpdyHttpHeaders . removeAssociatedToStreamId ( httpMessage ) ; </a> 0
<a> SpdyHttpHeaders . removePriority ( httpMessage ) ; </a> 0
<a> SpdyHttpHeaders . removeUrl ( httpMessage ) ; </a> 0
<a> SpdyHttpHeaders . removeScheme ( httpMessage ) ; </a> 0
<a> httpMessage . removeHeader ( HttpHeaders . Names . CONNECTION ) ; </a> 1
<a> httpMessage . removeHeader ( "Keep-Alive" ) ; </a> 1
<a> httpMessage . removeHeader ( "Proxy-Connection" ) ; </a> 1
<a> httpMessage . removeHeader ( HttpHeaders . Names . TRANSFER_ENCODING ) ; </a> 1
<a> SpdySynStreamFrame spdySynStreamFrame = </a> 0
<a> new DefaultSpdySynStreamFrame ( streamID , associatedToStreamId , priority ) ; </a> 1
<a> if ( httpMessage instanceof HttpRequest ) { </a> 1
<a> HttpRequest httpRequest = ( HttpRequest ) httpMessage ; </a> 0
<a> SpdyHeaders . setMethod ( spdyVersion , spdySynStreamFrame , httpRequest . getMethod ( ) ) ; </a> 1
<a> SpdyHeaders . setUrl ( spdyVersion , spdySynStreamFrame , httpRequest . getUri ( ) ) ; </a> 1
<a> SpdyHeaders . setVersion ( spdyVersion , spdySynStreamFrame , httpMessage . getProtocolVersion ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( httpMessage instanceof HttpResponse ) { </a> 0
<a> HttpResponse httpResponse = ( HttpResponse ) httpMessage ; </a> 0
<a> SpdyHeaders . setStatus ( spdyVersion , spdySynStreamFrame , httpResponse . getStatus ( ) ) ; </a> 1
<a> SpdyHeaders . setUrl ( spdyVersion , spdySynStreamFrame , URL ) ; </a> 0
<a> spdySynStreamFrame . setUnidirectional ( true ) ; </a> 1
<a> } </a> 1
<a> if ( spdyVersion >= 3 ) { </a> 1
<a> String host = HttpHeaders . getHost ( httpMessage ) ; </a> 0
<a> httpMessage . removeHeader ( HttpHeaders . Names . HOST ) ; </a> 1
<a> SpdyHeaders . setHost ( spdySynStreamFrame , host ) ; </a> 0
<a> } </a> 1
<a> if ( scheme == null ) { </a> 0
<a> scheme = "https" ; </a> 0
<a> } </a> 0
<a> SpdyHeaders . setScheme ( spdyVersion , spdySynStreamFrame , scheme ) ; </a> 0
<a> for ( Map . Entry < String , String > entry : httpMessage . getHeaders ( ) ) { </a> 1
<a> spdySynStreamFrame . addHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( chunked ) { </a> 0
<a> currentStreamId = streamID ; </a> 0
<a> spdySynStreamFrame . setLast ( false ) ; </a> 0
<a> } else { </a> 0
<a> spdySynStreamFrame . setLast ( httpMessage . getContent ( ) . readableBytes ( ) == 0 ) ; </a> 0
<a> } </a> 0
<a> return spdySynStreamFrame ; </a> 0
<a> } </a> 0
<a> private SpdySynReplyFrame createSynReplyFrame ( HttpResponse httpResponse ) </a> 0
<a> throws Exception { </a> 0
<a> boolean chunked = httpResponse . getTransferEncoding ( ) . isMultiple ( ) ; </a> 0
<a> int streamID = SpdyHttpHeaders . getStreamId ( httpResponse ) ; </a> 0
<a> SpdyHttpHeaders . removeStreamId ( httpResponse ) ; </a> 0
<a> httpResponse . removeHeader ( HttpHeaders . Names . CONNECTION ) ; </a> 1
<a> httpResponse . removeHeader ( "Keep-Alive" ) ; </a> 1
<a> httpResponse . removeHeader ( "Proxy-Connection" ) ; </a> 1
<a> httpResponse . removeHeader ( HttpHeaders . Names . TRANSFER_ENCODING ) ; </a> 1
<a> SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame ( streamID ) ; </a> 1
<a> SpdyHeaders . setStatus ( spdyVersion , spdySynReplyFrame , httpResponse . getStatus ( ) ) ; </a> 1
<a> SpdyHeaders . setVersion ( spdyVersion , spdySynReplyFrame , httpResponse . getProtocolVersion ( ) ) ; </a> 1
<a> for ( Map . Entry < String , String > entry : httpResponse . getHeaders ( ) ) { </a> 1
<a> spdySynReplyFrame . addHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( chunked ) { </a> 1
<a> currentStreamId = streamID ; </a> 1
<a> spdySynReplyFrame . setLast ( false ) ; </a> 0
<a> } else { </a> 0
<a> spdySynReplyFrame . setLast ( httpResponse . getContent ( ) . readableBytes ( ) == 0 ) ; </a> 0
<a> } </a> 1
<a> return spdySynReplyFrame ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders ; </a> 0
<a> import io . netty . handler . codec . http . HttpMessage ; </a> 0
<a> public final class SpdyHttpHeaders { </a> 0
<a> public static final class Names { </a> 0
<a> public static final String STREAM_ID = "X-SPDY-Stream-ID" ; </a> 0
<a> public static final String ASSOCIATED_TO_STREAM_ID = "X-SPDY-Associated-To-Stream-ID" ; </a> 0
<a> public static final String PRIORITY = "X-SPDY-Priority" ; </a> 0
<a> public static final String URL = "X-SPDY-URL" ; </a> 0
<a> public static final String SCHEME = "X-SPDY-Scheme" ; </a> 0
<a> private Names ( ) { } </a> 0
<a> } </a> 0
<a> private SpdyHttpHeaders ( ) { </a> 0
<a> } </a> 0
<a> public static void removeStreamId ( HttpMessage message ) { </a> 0
<a> message . removeHeader ( Names . STREAM_ID ) ; </a> 1
<a> } </a> 0
<a> public static int getStreamId ( HttpMessage message ) { </a> 0
<a> return HttpHeaders . getIntHeader ( message , Names . STREAM_ID ) ; </a> 0
<a> } </a> 0
<a> public static void setStreamId ( HttpMessage message , int streamId ) { </a> 0
<a> HttpHeaders . setIntHeader ( message , Names . STREAM_ID , streamId ) ; </a> 0
<a> } </a> 0
<a> public static void removeAssociatedToStreamId ( HttpMessage message ) { </a> 0
<a> message . removeHeader ( Names . ASSOCIATED_TO_STREAM_ID ) ; </a> 1
<a> } </a> 0
<a> public static int getAssociatedToStreamId ( HttpMessage message ) { </a> 0
<a> return HttpHeaders . getIntHeader ( message , Names . ASSOCIATED_TO_STREAM_ID , 0 ) ; </a> 0
<a> } </a> 0
<a> public static void setAssociatedToStreamId ( HttpMessage message , int associatedToStreamId ) { </a> 0
<a> HttpHeaders . setIntHeader ( message , Names . ASSOCIATED_TO_STREAM_ID , associatedToStreamId ) ; </a> 0
<a> } </a> 0
<a> public static void removePriority ( HttpMessage message ) { </a> 0
<a> message . removeHeader ( Names . PRIORITY ) ; </a> 1
<a> } </a> 0
<a> public static byte getPriority ( HttpMessage message ) { </a> 0
<a> return ( byte ) HttpHeaders . getIntHeader ( message , Names . PRIORITY , 0 ) ; </a> 0
<a> } </a> 0
<a> public static void setPriority ( HttpMessage message , byte priority ) { </a> 0
<a> HttpHeaders . setIntHeader ( message , Names . PRIORITY , priority ) ; </a> 0
<a> } </a> 0
<a> public static void removeUrl ( HttpMessage message ) { </a> 0
<a> message . removeHeader ( Names . URL ) ; </a> 1
<a> } </a> 0
<a> public static String getUrl ( HttpMessage message ) { </a> 0
<a> return message . getHeader ( Names . URL ) ; </a> 1
<a> } </a> 0
<a> public static void setUrl ( HttpMessage message , String url ) { </a> 0
<a> message . setHeader ( Names . URL , url ) ; </a> 1
<a> } </a> 0
<a> public static void removeScheme ( HttpMessage message ) { </a> 0
<a> message . removeHeader ( Names . SCHEME ) ; </a> 1
<a> } </a> 0
<a> public static String getScheme ( HttpMessage message ) { </a> 0
<a> return message . getHeader ( Names . SCHEME ) ; </a> 1
<a> } </a> 0
<a> public static void setScheme ( HttpMessage message , String scheme ) { </a> 0
<a> message . setHeader ( Names . SCHEME , scheme ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public interface SpdyNoOpFrame extends SpdyControlFrame { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public interface SpdyPingFrame extends SpdyControlFrame { </a> 0
<a> int getId ( ) ; </a> 1
<a> void setId ( int id ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public class SpdyProtocolException extends Exception { </a> 0
<a> private static final long serialVersionUID = 7870000537743847264L ; </a> 0
<a> public SpdyProtocolException ( ) { } </a> 0
<a> public SpdyProtocolException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public SpdyProtocolException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public SpdyProtocolException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public interface SpdyRstStreamFrame extends SpdyControlFrame { </a> 0
<a> int getStreamId ( ) ; </a> 0
<a> void setStreamId ( int streamID ) ; </a> 0
<a> SpdyStreamStatus getStatus ( ) ; </a> 0
<a> void setStatus ( SpdyStreamStatus status ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 1
<a> import io . netty . channel . ChannelInboundMessageHandler ; </a> 1
<a> import io . netty . channel . ChannelOutboundMessageHandler ; </a> 1
<a> import java . nio . channels . ClosedChannelException ; </a> 1
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> public class SpdySessionHandler </a> 1
<a> extends ChannelHandlerAdapter </a> 0
<a> implements ChannelInboundMessageHandler < Object > , ChannelOutboundMessageHandler < Object > { </a> 1
<a> private static final SpdyProtocolException PROTOCOL_EXCEPTION = new SpdyProtocolException ( ) ; </a> 0
<a> private static final SpdyProtocolException STREAM_CLOSED = new SpdyProtocolException ( "Stream closed" ) ; </a> 0
<a> static { </a> 0
<a> StackTraceElement [ ] emptyTrace = new StackTraceElement [ 0 ] ; </a> 0
<a> PROTOCOL_EXCEPTION . setStackTrace ( emptyTrace ) ; </a> 0
<a> STREAM_CLOSED . setStackTrace ( emptyTrace ) ; </a> 0
<a> } </a> 0
<a> private final SpdySession spdySession = new SpdySession ( ) ; </a> 0
<a> private volatile int lastGoodStreamId ; </a> 0
<a> private volatile int remoteConcurrentStreams ; </a> 0
<a> private volatile int localConcurrentStreams ; </a> 0
<a> private volatile int maxConcurrentStreams ; </a> 0
<a> private static final int DEFAULT_WINDOW_SIZE = 64 * 1024 ; </a> 0
<a> private volatile int initialSendWindowSize = DEFAULT_WINDOW_SIZE ; </a> 0
<a> private volatile int initialReceiveWindowSize = DEFAULT_WINDOW_SIZE ; </a> 0
<a> private final Object flowControlLock = new Object ( ) ; </a> 1
<a> private final AtomicInteger pings = new AtomicInteger ( ) ; </a> 0
<a> private volatile boolean sentGoAwayFrame ; </a> 0
<a> private volatile boolean receivedGoAwayFrame ; </a> 0
<a> private volatile ChannelFuture closeSessionFuture ; </a> 0
<a> private final boolean server ; </a> 0
<a> private final boolean flowControl ; </a> 0
<a> public SpdySessionHandler ( int version , boolean server ) { </a> 0
<a> if ( version < SpdyConstants . SPDY_MIN_VERSION || version > SpdyConstants . SPDY_MAX_VERSION ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "unsupported version: " + version ) ; </a> 0
<a> } </a> 0
<a> this . server = server ; </a> 0
<a> flowControl = version >= 3 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public MessageBuf < Object > newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . messageBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public MessageBuf < Object > newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return Unpooled . messageBuffer ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> MessageBuf < Object > in = ctx . inboundMessageBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> Object msg = in . poll ( ) ; </a> 1
<a> if ( msg == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( msg instanceof SpdyDataFrame || </a> 0
<a> msg instanceof SpdySynStreamFrame || </a> 0
<a> msg instanceof SpdySynReplyFrame || </a> 0
<a> msg instanceof SpdyRstStreamFrame || </a> 0
<a> msg instanceof SpdySettingsFrame || </a> 0
<a> msg instanceof SpdyPingFrame || </a> 0
<a> msg instanceof SpdyGoAwayFrame || </a> 0
<a> msg instanceof SpdyHeadersFrame || </a> 0
<a> msg instanceof SpdyWindowUpdateFrame ) { </a> 0
<a> handleInboundMessage ( ctx , msg ) ; </a> 1
<a> } else { </a> 0
<a> ctx . nextInboundMessageBuffer ( ) . add ( msg ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> private void handleInboundMessage ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 1
<a> if ( msg instanceof SpdyDataFrame ) { </a> 0
<a> SpdyDataFrame spdyDataFrame = ( SpdyDataFrame ) msg ; </a> 0
<a> int streamID = spdyDataFrame . getStreamId ( ) ; </a> 0
<a> if ( ! spdySession . isActiveStream ( streamID ) ) { </a> 0
<a> if ( streamID <= lastGoodStreamId ) { </a> 0
<a> issueStreamError ( ctx , streamID , SpdyStreamStatus . PROTOCOL_ERROR ) ; </a> 1
<a> } else if ( ! sentGoAwayFrame ) { </a> 0
<a> issueStreamError ( ctx , streamID , SpdyStreamStatus . INVALID_STREAM ) ; </a> 1
<a> } </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( spdySession . isRemoteSideClosed ( streamID ) ) { </a> 0
<a> issueStreamError ( ctx , streamID , SpdyStreamStatus . STREAM_ALREADY_CLOSED ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> if ( ! isRemoteInitiatedID ( streamID ) && ! spdySession . hasReceivedReply ( streamID ) ) { </a> 0
<a> issueStreamError ( ctx , streamID , SpdyStreamStatus . PROTOCOL_ERROR ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> if ( flowControl ) { </a> 0
<a> int deltaWindowSize = - 1 * spdyDataFrame . getData ( ) . readableBytes ( ) ; </a> 0
<a> int newWindowSize = spdySession . updateReceiveWindowSize ( streamID , deltaWindowSize ) ; </a> 0
<a> if ( newWindowSize < spdySession . getReceiveWindowSizeLowerBound ( streamID ) ) { </a> 0
<a> issueStreamError ( ctx , streamID , SpdyStreamStatus . FLOW_CONTROL_ERROR ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> if ( newWindowSize < 0 ) { </a> 0
<a> while ( spdyDataFrame . getData ( ) . readableBytes ( ) > initialReceiveWindowSize ) { </a> 0
<a> SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame ( streamID ) ; </a> 0
<a> partialDataFrame . setData ( spdyDataFrame . getData ( ) . readSlice ( initialReceiveWindowSize ) ) ; </a> 0
<a> ctx . nextOutboundMessageBuffer ( ) . add ( partialDataFrame ) ; </a> 1
<a> ctx . flush ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> if ( newWindowSize <= initialReceiveWindowSize / 2 && ! spdyDataFrame . isLast ( ) ) { </a> 0
<a> deltaWindowSize = initialReceiveWindowSize - newWindowSize ; </a> 0
<a> spdySession . updateReceiveWindowSize ( streamID , deltaWindowSize ) ; </a> 0
<a> SpdyWindowUpdateFrame spdyWindowUpdateFrame = </a> 0
<a> new DefaultSpdyWindowUpdateFrame ( streamID , deltaWindowSize ) ; </a> 0
<a> ctx . write ( spdyWindowUpdateFrame ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( spdyDataFrame . isLast ( ) ) { </a> 0
<a> halfCloseStream ( streamID , true ) ; </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdySynStreamFrame ) { </a> 0
<a> SpdySynStreamFrame spdySynStreamFrame = ( SpdySynStreamFrame ) msg ; </a> 0
<a> int streamID = spdySynStreamFrame . getStreamId ( ) ; </a> 0
<a> if ( spdySynStreamFrame . isInvalid ( ) || </a> 0
<a> ! isRemoteInitiatedID ( streamID ) || </a> 0
<a> spdySession . isActiveStream ( streamID ) ) { </a> 0
<a> issueStreamError ( ctx , streamID , SpdyStreamStatus . PROTOCOL_ERROR ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> if ( streamID <= lastGoodStreamId ) { </a> 0
<a> issueSessionError ( ctx , SpdySessionStatus . PROTOCOL_ERROR ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> byte priority = spdySynStreamFrame . getPriority ( ) ; </a> 1
<a> boolean remoteSideClosed = spdySynStreamFrame . isLast ( ) ; </a> 0
<a> boolean localSideClosed = spdySynStreamFrame . isUnidirectional ( ) ; </a> 0
<a> if ( ! acceptStream ( streamID , priority , remoteSideClosed , localSideClosed ) ) { </a> 0
<a> issueStreamError ( ctx , streamID , SpdyStreamStatus . REFUSED_STREAM ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdySynReplyFrame ) { </a> 0
<a> SpdySynReplyFrame spdySynReplyFrame = ( SpdySynReplyFrame ) msg ; </a> 0
<a> int streamID = spdySynReplyFrame . getStreamId ( ) ; </a> 0
<a> if ( spdySynReplyFrame . isInvalid ( ) || </a> 0
<a> isRemoteInitiatedID ( streamID ) || </a> 0
<a> spdySession . isRemoteSideClosed ( streamID ) ) { </a> 0
<a> issueStreamError ( ctx , streamID , SpdyStreamStatus . INVALID_STREAM ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> if ( spdySession . hasReceivedReply ( streamID ) ) { </a> 0
<a> issueStreamError ( ctx , streamID , SpdyStreamStatus . STREAM_IN_USE ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> spdySession . receivedReply ( streamID ) ; </a> 0
<a> if ( spdySynReplyFrame . isLast ( ) ) { </a> 0
<a> halfCloseStream ( streamID , true ) ; </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdyRstStreamFrame ) { </a> 0
<a> SpdyRstStreamFrame spdyRstStreamFrame = ( SpdyRstStreamFrame ) msg ; </a> 0
<a> removeStream ( ctx , spdyRstStreamFrame . getStreamId ( ) ) ; </a> 0
<a> } else if ( msg instanceof SpdySettingsFrame ) { </a> 0
<a> SpdySettingsFrame spdySettingsFrame = ( SpdySettingsFrame ) msg ; </a> 0
<a> int newConcurrentStreams = </a> 0
<a> spdySettingsFrame . getValue ( SpdySettingsFrame . SETTINGS_MAX_CONCURRENT_STREAMS ) ; </a> 0
<a> if ( newConcurrentStreams >= 0 ) { </a> 0
<a> updateConcurrentStreams ( newConcurrentStreams , true ) ; </a> 0
<a> } </a> 0
<a> if ( spdySettingsFrame . isPersisted ( SpdySettingsFrame . SETTINGS_INITIAL_WINDOW_SIZE ) ) { </a> 0
<a> spdySettingsFrame . removeValue ( SpdySettingsFrame . SETTINGS_INITIAL_WINDOW_SIZE ) ; </a> 0
<a> } </a> 0
<a> spdySettingsFrame . setPersistValue ( SpdySettingsFrame . SETTINGS_INITIAL_WINDOW_SIZE , false ) ; </a> 0
<a> if ( flowControl ) { </a> 0
<a> int newInitialWindowSize = </a> 0
<a> spdySettingsFrame . getValue ( SpdySettingsFrame . SETTINGS_INITIAL_WINDOW_SIZE ) ; </a> 0
<a> if ( newInitialWindowSize >= 0 ) { </a> 0
<a> updateInitialSendWindowSize ( newInitialWindowSize ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdyPingFrame ) { </a> 0
<a> SpdyPingFrame spdyPingFrame = ( SpdyPingFrame ) msg ; </a> 0
<a> if ( isRemoteInitiatedID ( spdyPingFrame . getId ( ) ) ) { </a> 0
<a> ctx . write ( spdyPingFrame ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( pings . get ( ) == 0 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> pings . getAndDecrement ( ) ; </a> 0
<a> } else if ( msg instanceof SpdyGoAwayFrame ) { </a> 0
<a> receivedGoAwayFrame = true ; </a> 0
<a> } else if ( msg instanceof SpdyHeadersFrame ) { </a> 0
<a> SpdyHeadersFrame spdyHeadersFrame = ( SpdyHeadersFrame ) msg ; </a> 0
<a> int streamID = spdyHeadersFrame . getStreamId ( ) ; </a> 0
<a> if ( spdyHeadersFrame . isInvalid ( ) ) { </a> 0
<a> issueStreamError ( ctx , streamID , SpdyStreamStatus . PROTOCOL_ERROR ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> if ( spdySession . isRemoteSideClosed ( streamID ) ) { </a> 0
<a> issueStreamError ( ctx , streamID , SpdyStreamStatus . INVALID_STREAM ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> if ( spdyHeadersFrame . isLast ( ) ) { </a> 0
<a> halfCloseStream ( streamID , true ) ; </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdyWindowUpdateFrame ) { </a> 0
<a> if ( flowControl ) { </a> 0
<a> SpdyWindowUpdateFrame spdyWindowUpdateFrame = ( SpdyWindowUpdateFrame ) msg ; </a> 0
<a> int streamID = spdyWindowUpdateFrame . getStreamId ( ) ; </a> 0
<a> int deltaWindowSize = spdyWindowUpdateFrame . getDeltaWindowSize ( ) ; </a> 1
<a> if ( spdySession . isLocalSideClosed ( streamID ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( spdySession . getSendWindowSize ( streamID ) > Integer . MAX_VALUE - deltaWindowSize ) { </a> 0
<a> issueStreamError ( ctx , streamID , SpdyStreamStatus . FLOW_CONTROL_ERROR ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> updateSendWindowSize ( ctx , streamID , deltaWindowSize ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> ctx . nextInboundMessageBuffer ( ) . add ( msg ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> if ( cause instanceof SpdyProtocolException ) { </a> 0
<a> issueSessionError ( ctx , SpdySessionStatus . PROTOCOL_ERROR ) ; </a> 0
<a> } </a> 0
<a> super . exceptionCaught ( ctx , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> sendGoAwayFrame ( ctx ) ; </a> 1
<a> super . close ( ctx , future ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> MessageBuf < Object > in = ctx . outboundMessageBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> Object msg = in . poll ( ) ; </a> 1
<a> if ( msg == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( msg instanceof SpdyDataFrame || </a> 0
<a> msg instanceof SpdySynStreamFrame || </a> 0
<a> msg instanceof SpdySynReplyFrame || </a> 0
<a> msg instanceof SpdyRstStreamFrame || </a> 0
<a> msg instanceof SpdySettingsFrame || </a> 0
<a> msg instanceof SpdyPingFrame || </a> 0
<a> msg instanceof SpdyGoAwayFrame || </a> 0
<a> msg instanceof SpdyHeadersFrame || </a> 0
<a> msg instanceof SpdyWindowUpdateFrame ) { </a> 0
<a> handleOutboundMessage ( ctx , msg ) ; </a> 0
<a> } else { </a> 0
<a> ctx . nextOutboundMessageBuffer ( ) . add ( msg ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> ctx . flush ( future ) ; </a> 0
<a> } </a> 0
<a> private void handleOutboundMessage ( ChannelHandlerContext ctx , Object msg ) </a> 0
<a> throws Exception { </a> 1
<a> if ( msg instanceof SpdyDataFrame ) { </a> 0
<a> SpdyDataFrame spdyDataFrame = ( SpdyDataFrame ) msg ; </a> 0
<a> final int streamID = spdyDataFrame . getStreamId ( ) ; </a> 0
<a> if ( spdySession . isLocalSideClosed ( streamID ) ) { </a> 0
<a> ctx . fireExceptionCaught ( PROTOCOL_EXCEPTION ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( flowControl ) { </a> 0
<a> synchronized ( flowControlLock ) { </a> 1
<a> int dataLength = spdyDataFrame . getData ( ) . readableBytes ( ) ; </a> 0
<a> int sendWindowSize = spdySession . getSendWindowSize ( streamID ) ; </a> 0
<a> if ( sendWindowSize >= dataLength ) { </a> 0
<a> spdySession . updateSendWindowSize ( streamID , - 1 * dataLength ) ; </a> 0
<a> } else if ( sendWindowSize > 0 ) { </a> 0
<a> spdySession . updateSendWindowSize ( streamID , - 1 * sendWindowSize ) ; </a> 0
<a> SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame ( streamID ) ; </a> 0
<a> partialDataFrame . setData ( spdyDataFrame . getData ( ) . readSlice ( sendWindowSize ) ) ; </a> 0
<a> spdySession . putPendingWrite ( streamID , spdyDataFrame ) ; </a> 0
<a> ctx . nextOutboundMessageBuffer ( ) . add ( partialDataFrame ) ; </a> 0
<a> return ; </a> 0
<a> } else { </a> 0
<a> spdySession . putPendingWrite ( streamID , spdyDataFrame ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } </a> 0
<a> if ( spdyDataFrame . isLast ( ) ) { </a> 0
<a> halfCloseStream ( streamID , false ) ; </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdySynStreamFrame ) { </a> 0
<a> SpdySynStreamFrame spdySynStreamFrame = ( SpdySynStreamFrame ) msg ; </a> 0
<a> int streamID = spdySynStreamFrame . getStreamId ( ) ; </a> 0
<a> if ( isRemoteInitiatedID ( streamID ) ) { </a> 0
<a> ctx . fireExceptionCaught ( PROTOCOL_EXCEPTION ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> byte priority = spdySynStreamFrame . getPriority ( ) ; </a> 1
<a> boolean remoteSideClosed = spdySynStreamFrame . isUnidirectional ( ) ; </a> 0
<a> boolean localSideClosed = spdySynStreamFrame . isLast ( ) ; </a> 0
<a> if ( ! acceptStream ( streamID , priority , remoteSideClosed , localSideClosed ) ) { </a> 0
<a> ctx . fireExceptionCaught ( PROTOCOL_EXCEPTION ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdySynReplyFrame ) { </a> 0
<a> SpdySynReplyFrame spdySynReplyFrame = ( SpdySynReplyFrame ) msg ; </a> 0
<a> int streamID = spdySynReplyFrame . getStreamId ( ) ; </a> 0
<a> if ( ! isRemoteInitiatedID ( streamID ) || spdySession . isLocalSideClosed ( streamID ) ) { </a> 0
<a> ctx . fireExceptionCaught ( PROTOCOL_EXCEPTION ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( spdySynReplyFrame . isLast ( ) ) { </a> 0
<a> halfCloseStream ( streamID , false ) ; </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdyRstStreamFrame ) { </a> 0
<a> SpdyRstStreamFrame spdyRstStreamFrame = ( SpdyRstStreamFrame ) msg ; </a> 0
<a> removeStream ( ctx , spdyRstStreamFrame . getStreamId ( ) ) ; </a> 0
<a> } else if ( msg instanceof SpdySettingsFrame ) { </a> 0
<a> SpdySettingsFrame spdySettingsFrame = ( SpdySettingsFrame ) msg ; </a> 0
<a> int newConcurrentStreams = </a> 0
<a> spdySettingsFrame . getValue ( SpdySettingsFrame . SETTINGS_MAX_CONCURRENT_STREAMS ) ; </a> 0
<a> if ( newConcurrentStreams >= 0 ) { </a> 0
<a> updateConcurrentStreams ( newConcurrentStreams , false ) ; </a> 0
<a> } </a> 0
<a> if ( spdySettingsFrame . isPersisted ( SpdySettingsFrame . SETTINGS_INITIAL_WINDOW_SIZE ) ) { </a> 0
<a> spdySettingsFrame . removeValue ( SpdySettingsFrame . SETTINGS_INITIAL_WINDOW_SIZE ) ; </a> 0
<a> } </a> 0
<a> spdySettingsFrame . setPersistValue ( SpdySettingsFrame . SETTINGS_INITIAL_WINDOW_SIZE , false ) ; </a> 0
<a> if ( flowControl ) { </a> 0
<a> int newInitialWindowSize = </a> 0
<a> spdySettingsFrame . getValue ( SpdySettingsFrame . SETTINGS_INITIAL_WINDOW_SIZE ) ; </a> 0
<a> if ( newInitialWindowSize >= 0 ) { </a> 0
<a> updateInitialReceiveWindowSize ( newInitialWindowSize ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdyPingFrame ) { </a> 0
<a> SpdyPingFrame spdyPingFrame = ( SpdyPingFrame ) msg ; </a> 0
<a> if ( isRemoteInitiatedID ( spdyPingFrame . getId ( ) ) ) { </a> 0
<a> ctx . fireExceptionCaught ( new IllegalArgumentException ( </a> 0
<a> "invalid PING ID: " + spdyPingFrame . getId ( ) ) ) ; </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> pings . getAndIncrement ( ) ; </a> 0
<a> } else if ( msg instanceof SpdyGoAwayFrame ) { </a> 0
<a> ctx . fireExceptionCaught ( PROTOCOL_EXCEPTION ) ; </a> 0
<a> return ; </a> 0
<a> } else if ( msg instanceof SpdyHeadersFrame ) { </a> 0
<a> SpdyHeadersFrame spdyHeadersFrame = ( SpdyHeadersFrame ) msg ; </a> 0
<a> int streamID = spdyHeadersFrame . getStreamId ( ) ; </a> 0
<a> if ( spdySession . isLocalSideClosed ( streamID ) ) { </a> 0
<a> ctx . fireExceptionCaught ( PROTOCOL_EXCEPTION ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( spdyHeadersFrame . isLast ( ) ) { </a> 0
<a> halfCloseStream ( streamID , false ) ; </a> 0
<a> } </a> 0
<a> } else if ( msg instanceof SpdyWindowUpdateFrame ) { </a> 0
<a> ctx . fireExceptionCaught ( PROTOCOL_EXCEPTION ) ; </a> 0
<a> } </a> 0
<a> ctx . nextOutboundMessageBuffer ( ) . add ( msg ) ; </a> 1
<a> } </a> 0
<a> private void issueSessionError ( </a> 0
<a> ChannelHandlerContext ctx , SpdySessionStatus status ) { </a> 0
<a> sendGoAwayFrame ( ctx , status ) ; </a> 1
<a> ctx . flush ( ) . addListener ( ChannelFutureListener . CLOSE ) ; </a> 1
<a> } </a> 0
<a> private void issueStreamError ( </a> 0
<a> ChannelHandlerContext ctx , int streamID , SpdyStreamStatus status ) { </a> 1
<a> boolean fireMessageReceived = ! spdySession . isRemoteSideClosed ( streamID ) ; </a> 0
<a> removeStream ( ctx , streamID ) ; </a> 0
<a> SpdyRstStreamFrame spdyRstStreamFrame = new DefaultSpdyRstStreamFrame ( streamID , status ) ; </a> 0
<a> ctx . write ( spdyRstStreamFrame ) ; </a> 0
<a> if ( fireMessageReceived ) { </a> 0
<a> ctx . nextInboundMessageBuffer ( ) . add ( spdyRstStreamFrame ) ; </a> 1
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private boolean isRemoteInitiatedID ( int ID ) { </a> 1
<a> boolean serverID = SpdyCodecUtil . isServerId ( ID ) ; </a> 1
<a> return server && ! serverID || ! server && serverID ; </a> 0
<a> } </a> 0
<a> private void updateConcurrentStreams ( int newConcurrentStreams , boolean remote ) { </a> 0
<a> if ( remote ) { </a> 0
<a> remoteConcurrentStreams = newConcurrentStreams ; </a> 0
<a> } else { </a> 0
<a> localConcurrentStreams = newConcurrentStreams ; </a> 0
<a> } </a> 0
<a> if ( localConcurrentStreams == remoteConcurrentStreams ) { </a> 0
<a> maxConcurrentStreams = localConcurrentStreams ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( localConcurrentStreams == 0 ) { </a> 0
<a> maxConcurrentStreams = remoteConcurrentStreams ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( remoteConcurrentStreams == 0 ) { </a> 0
<a> maxConcurrentStreams = localConcurrentStreams ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( localConcurrentStreams > remoteConcurrentStreams ) { </a> 0
<a> maxConcurrentStreams = remoteConcurrentStreams ; </a> 0
<a> } else { </a> 0
<a> maxConcurrentStreams = localConcurrentStreams ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private synchronized void updateInitialSendWindowSize ( int newInitialWindowSize ) { </a> 0
<a> int deltaWindowSize = newInitialWindowSize - initialSendWindowSize ; </a> 0
<a> initialSendWindowSize = newInitialWindowSize ; </a> 0
<a> for ( Integer streamId : spdySession . getActiveStreams ( ) ) { </a> 0
<a> spdySession . updateSendWindowSize ( streamId . intValue ( ) , deltaWindowSize ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private synchronized void updateInitialReceiveWindowSize ( int newInitialWindowSize ) { </a> 0
<a> int deltaWindowSize = newInitialWindowSize - initialReceiveWindowSize ; </a> 0
<a> initialReceiveWindowSize = newInitialWindowSize ; </a> 0
<a> spdySession . updateAllReceiveWindowSizes ( deltaWindowSize ) ; </a> 0
<a> } </a> 0
<a> private synchronized boolean acceptStream ( </a> 0
<a> int streamID , byte priority , boolean remoteSideClosed , boolean localSideClosed ) { </a> 0
<a> if ( receivedGoAwayFrame || sentGoAwayFrame ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> int maxConcurrentStreams = this . maxConcurrentStreams ; </a> 0
<a> if ( maxConcurrentStreams != 0 && </a> 0
<a> spdySession . numActiveStreams ( ) >= maxConcurrentStreams ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> spdySession . acceptStream ( </a> 0
<a> streamID , priority , remoteSideClosed , localSideClosed , </a> 0
<a> initialSendWindowSize , initialReceiveWindowSize ) ; </a> 0
<a> if ( isRemoteInitiatedID ( streamID ) ) { </a> 0
<a> lastGoodStreamId = streamID ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> private void halfCloseStream ( int streamID , boolean remote ) { </a> 0
<a> if ( remote ) { </a> 0
<a> spdySession . closeRemoteSide ( streamID ) ; </a> 0
<a> } else { </a> 0
<a> spdySession . closeLocalSide ( streamID ) ; </a> 0
<a> } </a> 0
<a> if ( closeSessionFuture != null && spdySession . noActiveStreams ( ) ) { </a> 0
<a> closeSessionFuture . setSuccess ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void removeStream ( ChannelHandlerContext ctx , int streamID ) { </a> 0
<a> if ( spdySession . removeStream ( streamID ) ) { </a> 0
<a> ctx . fireExceptionCaught ( STREAM_CLOSED ) ; </a> 0
<a> } </a> 0
<a> if ( closeSessionFuture != null && spdySession . noActiveStreams ( ) ) { </a> 0
<a> closeSessionFuture . setSuccess ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void updateSendWindowSize ( ChannelHandlerContext ctx , final int streamID , int deltaWindowSize ) { </a> 1
<a> synchronized ( flowControlLock ) { </a> 1
<a> int newWindowSize = spdySession . updateSendWindowSize ( streamID , deltaWindowSize ) ; </a> 0
<a> while ( newWindowSize > 0 ) { </a> 1
<a> SpdyDataFrame spdyDataFrame = ( SpdyDataFrame ) spdySession . getPendingWrite ( streamID ) ; </a> 0
<a> if ( spdyDataFrame == null ) { </a> 0
<a> break ; </a> 1
<a> } </a> 0
<a> int dataFrameSize = spdyDataFrame . getData ( ) . readableBytes ( ) ; </a> 0
<a> if ( newWindowSize >= dataFrameSize ) { </a> 1
<a> spdySession . removePendingWrite ( streamID ) ; </a> 0
<a> newWindowSize = spdySession . updateSendWindowSize ( streamID , - 1 * dataFrameSize ) ; </a> 0
<a> if ( spdyDataFrame . isLast ( ) ) { </a> 1
<a> halfCloseStream ( streamID , false ) ; </a> 0
<a> } </a> 1
<a> ctx . nextOutboundMessageBuffer ( ) . add ( spdyDataFrame ) ; </a> 1
<a> } else { </a> 0
<a> spdySession . updateSendWindowSize ( streamID , - 1 * newWindowSize ) ; </a> 0
<a> SpdyDataFrame partialDataFrame = new DefaultSpdyDataFrame ( streamID ) ; </a> 0
<a> partialDataFrame . setData ( spdyDataFrame . getData ( ) . readSlice ( newWindowSize ) ) ; </a> 0
<a> ctx . nextOutboundMessageBuffer ( ) . add ( partialDataFrame ) ; </a> 1
<a> newWindowSize = 0 ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void sendGoAwayFrame ( ChannelHandlerContext ctx ) { </a> 1
<a> if ( ! ctx . channel ( ) . isActive ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> sendGoAwayFrame ( ctx , SpdySessionStatus . OK ) ; </a> 1
<a> ChannelFuture f = ctx . flush ( ) ; </a> 1
<a> if ( spdySession . noActiveStreams ( ) ) { </a> 0
<a> f . addListener ( new ClosingChannelFutureListener ( ctx ) ) ; </a> 1
<a> } else { </a> 0
<a> closeSessionFuture = ctx . newFuture ( ) ; </a> 0
<a> closeSessionFuture . addListener ( new ClosingChannelFutureListener ( ctx ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private synchronized void sendGoAwayFrame ( </a> 1
<a> ChannelHandlerContext ctx , SpdySessionStatus status ) { </a> 0
<a> if ( ! sentGoAwayFrame ) { </a> 0
<a> sentGoAwayFrame = true ; </a> 0
<a> SpdyGoAwayFrame spdyGoAwayFrame = new DefaultSpdyGoAwayFrame ( lastGoodStreamId , status ) ; </a> 0
<a> ctx . nextOutboundMessageBuffer ( ) . add ( spdyGoAwayFrame ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private static final class ClosingChannelFutureListener implements ChannelFutureListener { </a> 0
<a> private final ChannelHandlerContext ctx ; </a> 0
<a> ClosingChannelFutureListener ( ChannelHandlerContext ctx ) { </a> 1
<a> this . ctx = ctx ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture sentGoAwayFuture ) throws Exception { </a> 0
<a> if ( ! ( sentGoAwayFuture . cause ( ) instanceof ClosedChannelException ) ) { </a> 1
<a> ctx . close ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public class SpdySessionStatus implements Comparable < SpdySessionStatus > { </a> 0
<a> public static final SpdySessionStatus OK = </a> 0
<a> new SpdySessionStatus ( 0 , "OK" ) ; </a> 0
<a> public static final SpdySessionStatus PROTOCOL_ERROR = </a> 0
<a> new SpdySessionStatus ( 1 , "PROTOCOL_ERROR" ) ; </a> 0
<a> public static final SpdySessionStatus INTERNAL_ERROR = </a> 0
<a> new SpdySessionStatus ( 11 , "INTERNAL_ERROR" ) ; </a> 1
<a> public static SpdySessionStatus valueOf ( int code ) { </a> 0
<a> switch ( code ) { </a> 0
<a> case 0 : </a> 0
<a> return OK ; </a> 0
<a> case 1 : </a> 0
<a> return PROTOCOL_ERROR ; </a> 0
<a> case 11 : </a> 1
<a> return INTERNAL_ERROR ; </a> 0
<a> } </a> 0
<a> return new SpdySessionStatus ( code , "UNKNOWN (" + code + ')' ) ; </a> 0
<a> } </a> 0
<a> private final int code ; </a> 0
<a> private final String statusPhrase ; </a> 0
<a> public SpdySessionStatus ( int code , String statusPhrase ) { </a> 0
<a> if ( statusPhrase == null ) { </a> 0
<a> throw new NullPointerException ( "statusPhrase" ) ; </a> 0
<a> } </a> 0
<a> this . code = code ; </a> 0
<a> this . statusPhrase = statusPhrase ; </a> 0
<a> } </a> 0
<a> public int getCode ( ) { </a> 1
<a> return code ; </a> 0
<a> } </a> 0
<a> public String getStatusPhrase ( ) { </a> 1
<a> return statusPhrase ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return getCode ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object o ) { </a> 0
<a> if ( ! ( o instanceof SpdySessionStatus ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return getCode ( ) == ( ( SpdySessionStatus ) o ) . getCode ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getStatusPhrase ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( SpdySessionStatus o ) { </a> 0
<a> return getCode ( ) - o . getCode ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public class SpdyStreamStatus implements Comparable < SpdyStreamStatus > { </a> 0
<a> public static final SpdyStreamStatus PROTOCOL_ERROR = </a> 0
<a> new SpdyStreamStatus ( 1 , "PROTOCOL_ERROR" ) ; </a> 0
<a> public static final SpdyStreamStatus INVALID_STREAM = </a> 0
<a> new SpdyStreamStatus ( 2 , "INVALID_STREAM" ) ; </a> 0
<a> public static final SpdyStreamStatus REFUSED_STREAM = </a> 0
<a> new SpdyStreamStatus ( 3 , "REFUSED_STREAM" ) ; </a> 0
<a> public static final SpdyStreamStatus UNSUPPORTED_VERSION = </a> 0
<a> new SpdyStreamStatus ( 4 , "UNSUPPORTED_VERSION" ) ; </a> 0
<a> public static final SpdyStreamStatus CANCEL = </a> 0
<a> new SpdyStreamStatus ( 5 , "CANCEL" ) ; </a> 0
<a> public static final SpdyStreamStatus INTERNAL_ERROR = </a> 0
<a> new SpdyStreamStatus ( 6 , "INTERNAL_ERROR" ) ; </a> 0
<a> public static final SpdyStreamStatus FLOW_CONTROL_ERROR = </a> 0
<a> new SpdyStreamStatus ( 7 , "FLOW_CONTROL_ERROR" ) ; </a> 0
<a> public static final SpdyStreamStatus STREAM_IN_USE = </a> 0
<a> new SpdyStreamStatus ( 8 , "STREAM_IN_USE" ) ; </a> 0
<a> public static final SpdyStreamStatus STREAM_ALREADY_CLOSED = </a> 0
<a> new SpdyStreamStatus ( 9 , "STREAM_ALREADY_CLOSED" ) ; </a> 0
<a> public static final SpdyStreamStatus INVALID_CREDENTIALS = </a> 0
<a> new SpdyStreamStatus ( 10 , "INVALID_CREDENTIALS" ) ; </a> 0
<a> public static final SpdyStreamStatus FRAME_TOO_LARGE = </a> 0
<a> new SpdyStreamStatus ( 11 , "FRAME_TOO_LARGE" ) ; </a> 0
<a> public static SpdyStreamStatus valueOf ( int code ) { </a> 0
<a> if ( code == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "0 is not a valid status code for a RST_STREAM" ) ; </a> 1
<a> } </a> 0
<a> switch ( code ) { </a> 0
<a> case 1 : </a> 0
<a> return PROTOCOL_ERROR ; </a> 0
<a> case 2 : </a> 0
<a> return INVALID_STREAM ; </a> 0
<a> case 3 : </a> 0
<a> return REFUSED_STREAM ; </a> 0
<a> case 4 : </a> 0
<a> return UNSUPPORTED_VERSION ; </a> 0
<a> case 5 : </a> 0
<a> return CANCEL ; </a> 0
<a> case 6 : </a> 0
<a> return INTERNAL_ERROR ; </a> 0
<a> case 7 : </a> 0
<a> return FLOW_CONTROL_ERROR ; </a> 0
<a> case 8 : </a> 0
<a> return STREAM_IN_USE ; </a> 0
<a> case 9 : </a> 0
<a> return STREAM_ALREADY_CLOSED ; </a> 0
<a> case 10 : </a> 0
<a> return INVALID_CREDENTIALS ; </a> 0
<a> case 11 : </a> 0
<a> return FRAME_TOO_LARGE ; </a> 0
<a> } </a> 0
<a> return new SpdyStreamStatus ( code , "UNKNOWN (" + code + ')' ) ; </a> 0
<a> } </a> 0
<a> private final int code ; </a> 0
<a> private final String statusPhrase ; </a> 0
<a> public SpdyStreamStatus ( int code , String statusPhrase ) { </a> 0
<a> if ( code == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "0 is not a valid status code for a RST_STREAM" ) ; </a> 1
<a> } </a> 0
<a> if ( statusPhrase == null ) { </a> 0
<a> throw new NullPointerException ( "statusPhrase" ) ; </a> 0
<a> } </a> 0
<a> this . code = code ; </a> 0
<a> this . statusPhrase = statusPhrase ; </a> 0
<a> } </a> 0
<a> public int getCode ( ) { </a> 1
<a> return code ; </a> 0
<a> } </a> 0
<a> public String getStatusPhrase ( ) { </a> 1
<a> return statusPhrase ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return getCode ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object o ) { </a> 0
<a> if ( ! ( o instanceof SpdyStreamStatus ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return getCode ( ) == ( ( SpdyStreamStatus ) o ) . getCode ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getStatusPhrase ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( SpdyStreamStatus o ) { </a> 0
<a> return getCode ( ) - o . getCode ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public interface SpdySynReplyFrame extends SpdyHeaderBlock , SpdyControlFrame { </a> 0
<a> int getStreamId ( ) ; </a> 0
<a> void setStreamId ( int streamID ) ; </a> 0
<a> boolean isLast ( ) ; </a> 0
<a> void setLast ( boolean last ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> public interface SpdyWindowUpdateFrame extends SpdyControlFrame { </a> 0
<a> int getStreamId ( ) ; </a> 1
<a> void setStreamId ( int streamID ) ; </a> 0
<a> int getDeltaWindowSize ( ) ; </a> 1
<a> void setDeltaWindowSize ( int deltaWindowSize ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import java . text . DateFormat ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . List ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class CookieEncoderTest { </a> 0
<a> @ Test </a> 0
<a> public void testEncodingSingleCookieV0 ( ) { </a> 0
<a> String result = "myCookie=myValue; Expires=XXX; Path=/apathsomewhere; Domain=.adomainsomewhere; Secure" ; </a> 0
<a> DateFormat df = new HttpHeaderDateFormat ( ) ; </a> 0
<a> Cookie cookie = new DefaultCookie ( "myCookie" , "myValue" ) ; </a> 0
<a> cookie . setComment ( "this is a Comment" ) ; </a> 0
<a> cookie . setCommentUrl ( "http://aurl.com" ) ; </a> 0
<a> cookie . setDomain ( ".adomainsomewhere" ) ; </a> 0
<a> cookie . setDiscard ( true ) ; </a> 0
<a> cookie . setMaxAge ( 50 ) ; </a> 0
<a> cookie . setPath ( "/apathsomewhere" ) ; </a> 0
<a> cookie . setPorts ( 80 , 8080 ) ; </a> 0
<a> cookie . setSecure ( true ) ; </a> 0
<a> String encodedCookie = ServerCookieEncoder . encode ( cookie ) ; </a> 0
<a> long currentTime = System . currentTimeMillis ( ) ; </a> 0
<a> boolean fail = true ; </a> 0
<a> for ( int delta = 0 ; delta <= 20000 ; delta += 250 ) { </a> 0
<a> if ( encodedCookie . equals ( result . replace ( </a> 0
<a> "XXX" , df . format ( new Date ( currentTime + 40000 + delta ) ) ) ) ) { </a> 0
<a> fail = false ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( fail ) { </a> 0
<a> fail ( "Expected: " + result + ", Actual: " + encodedCookie ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testEncodingSingleCookieV1 ( ) { </a> 0
<a> String result = "myCookie=myValue; Max-Age=50; Path=\"/apathsomewhere\"; Domain=.adomainsomewhere; Secure; Comment=\"this is a Comment\"; Version=1" ; </a> 1
<a> Cookie cookie = new DefaultCookie ( "myCookie" , "myValue" ) ; </a> 0
<a> cookie . setVersion ( 1 ) ; </a> 0
<a> cookie . setComment ( "this is a Comment" ) ; </a> 0
<a> cookie . setDomain ( ".adomainsomewhere" ) ; </a> 0
<a> cookie . setMaxAge ( 50 ) ; </a> 0
<a> cookie . setPath ( "/apathsomewhere" ) ; </a> 0
<a> cookie . setSecure ( true ) ; </a> 0
<a> String encodedCookie = ServerCookieEncoder . encode ( cookie ) ; </a> 0
<a> assertEquals ( result , encodedCookie ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testEncodingSingleCookieV2 ( ) { </a> 0
<a> String result = "myCookie=myValue; Max-Age=50; Path=\"/apathsomewhere\"; Domain=.adomainsomewhere; Secure; Comment=\"this is a Comment\"; Version=1; CommentURL=\"http://aurl.com\"; Port=\"80,8080\"; Discard" ; </a> 1
<a> Cookie cookie = new DefaultCookie ( "myCookie" , "myValue" ) ; </a> 0
<a> cookie . setVersion ( 1 ) ; </a> 0
<a> cookie . setComment ( "this is a Comment" ) ; </a> 0
<a> cookie . setCommentUrl ( "http://aurl.com" ) ; </a> 0
<a> cookie . setDomain ( ".adomainsomewhere" ) ; </a> 0
<a> cookie . setDiscard ( true ) ; </a> 0
<a> cookie . setMaxAge ( 50 ) ; </a> 0
<a> cookie . setPath ( "/apathsomewhere" ) ; </a> 0
<a> cookie . setPorts ( 80 , 8080 ) ; </a> 0
<a> cookie . setSecure ( true ) ; </a> 0
<a> String encodedCookie = ServerCookieEncoder . encode ( cookie ) ; </a> 0
<a> assertEquals ( result , encodedCookie ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testEncodingMultipleClientCookies ( ) { </a> 0
<a> String c1 = "$Version=1; myCookie=myValue; $Path=\"/apathsomewhere\"; $Domain=.adomainsomewhere; $Port=\"80,8080\"; " ; </a> 0
<a> String c2 = "$Version=1; myCookie2=myValue2; $Path=\"/anotherpathsomewhere\"; $Domain=.anotherdomainsomewhere; " ; </a> 0
<a> String c3 = "$Version=1; myCookie3=myValue3" ; </a> 0
<a> Cookie cookie = new DefaultCookie ( "myCookie" , "myValue" ) ; </a> 0
<a> cookie . setVersion ( 1 ) ; </a> 0
<a> cookie . setComment ( "this is a Comment" ) ; </a> 0
<a> cookie . setCommentUrl ( "http://aurl.com" ) ; </a> 0
<a> cookie . setDomain ( ".adomainsomewhere" ) ; </a> 0
<a> cookie . setDiscard ( true ) ; </a> 0
<a> cookie . setMaxAge ( 50 ) ; </a> 0
<a> cookie . setPath ( "/apathsomewhere" ) ; </a> 0
<a> cookie . setPorts ( 80 , 8080 ) ; </a> 0
<a> cookie . setSecure ( true ) ; </a> 0
<a> Cookie cookie2 = new DefaultCookie ( "myCookie2" , "myValue2" ) ; </a> 0
<a> cookie2 . setVersion ( 1 ) ; </a> 0
<a> cookie2 . setComment ( "this is another Comment" ) ; </a> 0
<a> cookie2 . setCommentUrl ( "http://anotherurl.com" ) ; </a> 0
<a> cookie2 . setDomain ( ".anotherdomainsomewhere" ) ; </a> 0
<a> cookie2 . setDiscard ( false ) ; </a> 0
<a> cookie2 . setPath ( "/anotherpathsomewhere" ) ; </a> 0
<a> cookie2 . setSecure ( false ) ; </a> 0
<a> Cookie cookie3 = new DefaultCookie ( "myCookie3" , "myValue3" ) ; </a> 0
<a> cookie3 . setVersion ( 1 ) ; </a> 0
<a> String encodedCookie = ClientCookieEncoder . encode ( cookie , cookie2 , cookie3 ) ; </a> 0
<a> assertEquals ( c1 + c2 + c3 , encodedCookie ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testEncodingWithNoCookies ( ) { </a> 0
<a> String encodedCookie1 = ClientCookieEncoder . encode ( ) ; </a> 0
<a> List < String > encodedCookie2 = ServerCookieEncoder . encode ( ) ; </a> 0
<a> assertNotNull ( encodedCookie1 ) ; </a> 0
<a> assertNotNull ( encodedCookie2 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import org . junit . Assert ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class DefaultHttpMessageTest { </a> 0
<a> @ Test </a> 0
<a> public void testHeaderRemoval ( ) { </a> 0
<a> HttpMessage m = new DefaultHttpRequest ( </a> 0
<a> HttpVersion . HTTP_1_1 , HttpMethod . GET , "/" ) ; </a> 0
<a> for ( int i = 0 ; i < 1000 ; i ++ ) { </a> 0
<a> m . setHeader ( String . valueOf ( i ) , "" ) ; </a> 1
<a> } </a> 0
<a> for ( int i = 999 ; i >= 0 ; i -- ) { </a> 0
<a> m . removeHeader ( String . valueOf ( i ) ) ; </a> 1
<a> } </a> 0
<a> for ( int i = 0 ; i < 1000 ; i ++ ) { </a> 0
<a> Assert . assertNull ( m . getHeader ( String . valueOf ( i ) ) ) ; </a> 1
<a> } </a> 0
<a> Assert . assertTrue ( m . getHeaders ( ) . isEmpty ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . CompositeByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedMessageChannel ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . util . List ; </a> 0
<a> import org . easymock . EasyMock ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class HttpChunkAggregatorTest { </a> 0
<a> @ Test </a> 0
<a> public void testAggregate ( ) { </a> 0
<a> HttpChunkAggregator aggr = new HttpChunkAggregator ( 1024 * 1024 ) ; </a> 0
<a> EmbeddedMessageChannel embedder = new EmbeddedMessageChannel ( aggr ) ; </a> 0
<a> HttpMessage message = new DefaultHttpMessage ( HttpVersion . HTTP_1_1 ) ; </a> 0
<a> HttpHeaders . setHeader ( message , "X-Test" , true ) ; </a> 0
<a> message . setTransferEncoding ( HttpTransferEncoding . STREAMED ) ; </a> 0
<a> HttpChunk chunk1 = new DefaultHttpChunk ( Unpooled . copiedBuffer ( "test" , CharsetUtil . US_ASCII ) ) ; </a> 0
<a> HttpChunk chunk2 = new DefaultHttpChunk ( Unpooled . copiedBuffer ( "test2" , CharsetUtil . US_ASCII ) ) ; </a> 0
<a> HttpChunk chunk3 = new DefaultHttpChunk ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> assertFalse ( embedder . writeInbound ( message ) ) ; </a> 0
<a> assertFalse ( embedder . writeInbound ( chunk1 ) ) ; </a> 0
<a> assertFalse ( embedder . writeInbound ( chunk2 ) ) ; </a> 0
<a> assertTrue ( embedder . writeInbound ( chunk3 ) ) ; </a> 0
<a> assertTrue ( embedder . finish ( ) ) ; </a> 0
<a> HttpMessage aggratedMessage = ( HttpMessage ) embedder . readInbound ( ) ; </a> 0
<a> assertNotNull ( aggratedMessage ) ; </a> 0
<a> assertEquals ( chunk1 . getContent ( ) . readableBytes ( ) + chunk2 . getContent ( ) . readableBytes ( ) , HttpHeaders . getContentLength ( aggratedMessage ) ) ; </a> 0
<a> assertEquals ( aggratedMessage . getHeader ( "X-Test" ) , Boolean . TRUE . toString ( ) ) ; </a> 0
<a> checkContentBuffer ( aggratedMessage ) ; </a> 0
<a> assertNull ( embedder . readInbound ( ) ) ; </a> 0
<a> } </a> 0
<a> private static void checkContentBuffer ( HttpMessage aggregatedMessage ) { </a> 0
<a> CompositeByteBuf buffer = ( CompositeByteBuf ) aggregatedMessage . getContent ( ) ; </a> 0
<a> assertEquals ( 2 , buffer . numComponents ( ) ) ; </a> 0
<a> List < ByteBuf > buffers = buffer . decompose ( 0 , buffer . capacity ( ) ) ; </a> 0
<a> assertEquals ( 2 , buffers . size ( ) ) ; </a> 0
<a> for ( ByteBuf buf : buffers ) { </a> 0
<a> assertFalse ( buf instanceof CompositeByteBuf ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testAggregateWithTrailer ( ) { </a> 0
<a> HttpChunkAggregator aggr = new HttpChunkAggregator ( 1024 * 1024 ) ; </a> 0
<a> EmbeddedMessageChannel embedder = new EmbeddedMessageChannel ( aggr ) ; </a> 0
<a> HttpMessage message = new DefaultHttpMessage ( HttpVersion . HTTP_1_1 ) ; </a> 0
<a> HttpHeaders . setHeader ( message , "X-Test" , true ) ; </a> 0
<a> message . setTransferEncoding ( HttpTransferEncoding . CHUNKED ) ; </a> 0
<a> HttpChunk chunk1 = new DefaultHttpChunk ( Unpooled . copiedBuffer ( "test" , CharsetUtil . US_ASCII ) ) ; </a> 0
<a> HttpChunk chunk2 = new DefaultHttpChunk ( Unpooled . copiedBuffer ( "test2" , CharsetUtil . US_ASCII ) ) ; </a> 0
<a> HttpChunkTrailer trailer = new DefaultHttpChunkTrailer ( ) ; </a> 0
<a> trailer . setHeader ( "X-Trailer" , true ) ; </a> 0
<a> assertFalse ( embedder . writeInbound ( message ) ) ; </a> 0
<a> assertFalse ( embedder . writeInbound ( chunk1 ) ) ; </a> 0
<a> assertFalse ( embedder . writeInbound ( chunk2 ) ) ; </a> 0
<a> assertTrue ( embedder . writeInbound ( trailer ) ) ; </a> 0
<a> assertTrue ( embedder . finish ( ) ) ; </a> 0
<a> HttpMessage aggratedMessage = ( HttpMessage ) embedder . readInbound ( ) ; </a> 0
<a> assertNotNull ( aggratedMessage ) ; </a> 0
<a> assertEquals ( chunk1 . getContent ( ) . readableBytes ( ) + chunk2 . getContent ( ) . readableBytes ( ) , HttpHeaders . getContentLength ( aggratedMessage ) ) ; </a> 0
<a> assertEquals ( aggratedMessage . getHeader ( "X-Test" ) , Boolean . TRUE . toString ( ) ) ; </a> 0
<a> assertEquals ( aggratedMessage . getHeader ( "X-Trailer" ) , Boolean . TRUE . toString ( ) ) ; </a> 0
<a> checkContentBuffer ( aggratedMessage ) ; </a> 0
<a> assertNull ( embedder . readInbound ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = TooLongFrameException . class ) </a> 0
<a> public void testTooLongFrameException ( ) { </a> 0
<a> HttpChunkAggregator aggr = new HttpChunkAggregator ( 4 ) ; </a> 0
<a> EmbeddedMessageChannel embedder = new EmbeddedMessageChannel ( aggr ) ; </a> 0
<a> HttpMessage message = new DefaultHttpMessage ( HttpVersion . HTTP_1_1 ) ; </a> 0
<a> message . setTransferEncoding ( HttpTransferEncoding . STREAMED ) ; </a> 0
<a> HttpChunk chunk1 = new DefaultHttpChunk ( Unpooled . copiedBuffer ( "test" , CharsetUtil . US_ASCII ) ) ; </a> 0
<a> HttpChunk chunk2 = new DefaultHttpChunk ( Unpooled . copiedBuffer ( "test2" , CharsetUtil . US_ASCII ) ) ; </a> 0
<a> assertFalse ( embedder . writeInbound ( message ) ) ; </a> 0
<a> assertFalse ( embedder . writeInbound ( chunk1 ) ) ; </a> 0
<a> embedder . writeInbound ( chunk2 ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IllegalArgumentException . class ) </a> 0
<a> public void testInvalidConstructorUsage ( ) { </a> 0
<a> new HttpChunkAggregator ( 0 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IllegalArgumentException . class ) </a> 0
<a> public void testInvalidMaxCumulationBufferComponents ( ) { </a> 0
<a> HttpChunkAggregator aggr = new HttpChunkAggregator ( Integer . MAX_VALUE ) ; </a> 0
<a> aggr . setMaxCumulationBufferComponents ( 1 ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = IllegalStateException . class ) </a> 0
<a> public void testSetMaxCumulationBufferComponentsAfterInit ( ) throws Exception { </a> 0
<a> HttpChunkAggregator aggr = new HttpChunkAggregator ( Integer . MAX_VALUE ) ; </a> 0
<a> ChannelHandlerContext ctx = EasyMock . createMock ( ChannelHandlerContext . class ) ; </a> 0
<a> EasyMock . replay ( ctx ) ; </a> 0
<a> aggr . beforeAdd ( ctx ) ; </a> 0
<a> aggr . setMaxCumulationBufferComponents ( 10 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import io . netty . handler . codec . CodecException ; </a> 0
<a> import io . netty . handler . codec . PrematureChannelClosureException ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class HttpClientCodecTest { </a> 0
<a> private static final String RESPONSE = "HTTP/1.0 200 OK\r\n" + "Date: Fri, 31 Dec 1999 23:59:59 GMT\r\n" + "Content-Type: text/html\r\n" + "Content-Length: 28\r\n" + "\r\n" </a> 1
<a> + "<html><body></body></html>\r\n" ; </a> 0
<a> private static final String INCOMPLETE_CHUNKED_RESPONSE = "HTTP/1.1 200 OK\r\n" + "Content-Type: text/plain\r\n" + "Transfer-Encoding: chunked\r\n" + "\r\n" </a> 1
<a> + "5\r\n" + "first\r\n" + "6\r\n" + "second\r\n" + "0\r\n" ; </a> 1
<a> private static final String CHUNKED_RESPONSE = INCOMPLETE_CHUNKED_RESPONSE + "\r\n" ; </a> 0
<a> @ Test </a> 0
<a> public void testFailsNotOnRequestResponse ( ) { </a> 0
<a> HttpClientCodec codec = new HttpClientCodec ( 4096 , 8192 , 8192 , true ) ; </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( codec ) ; </a> 1
<a> ch . writeOutbound ( new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , "http://localhost/" ) ) ; </a> 1
<a> ch . writeInbound ( Unpooled . copiedBuffer ( RESPONSE , CharsetUtil . ISO_8859_1 ) ) ; </a> 0
<a> ch . finish ( ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testFailsNotOnRequestResponseChunked ( ) { </a> 0
<a> HttpClientCodec codec = new HttpClientCodec ( 4096 , 8192 , 8192 , true ) ; </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( codec ) ; </a> 1
<a> ch . writeOutbound ( new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , "http://localhost/" ) ) ; </a> 1
<a> ch . writeInbound ( Unpooled . copiedBuffer ( CHUNKED_RESPONSE , CharsetUtil . ISO_8859_1 ) ) ; </a> 0
<a> ch . finish ( ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testFailsOnMissingResponse ( ) { </a> 0
<a> HttpClientCodec codec = new HttpClientCodec ( 4096 , 8192 , 8192 , true ) ; </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( codec ) ; </a> 1
<a> assertTrue ( ch . writeOutbound ( new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , "http://localhost/" ) ) ) ; </a> 1
<a> assertNotNull ( ch . readOutbound ( ) ) ; </a> 1
<a> try { </a> 0
<a> ch . finish ( ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( CodecException e ) { </a> 0
<a> assertTrue ( e instanceof PrematureChannelClosureException ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testFailsOnIncompleteChunkedResponse ( ) { </a> 0
<a> HttpClientCodec codec = new HttpClientCodec ( 4096 , 8192 , 8192 , true ) ; </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( codec ) ; </a> 1
<a> ch . writeOutbound ( new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , "http://localhost/" ) ) ; </a> 1
<a> ch . writeInbound ( Unpooled . copiedBuffer ( INCOMPLETE_CHUNKED_RESPONSE , CharsetUtil . ISO_8859_1 ) ) ; </a> 1
<a> try { </a> 0
<a> ch . finish ( ) ; </a> 0
<a> fail ( ) ; </a> 0
<a> } catch ( CodecException e ) { </a> 0
<a> assertTrue ( e instanceof PrematureChannelClosureException ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import org . junit . Assert ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class HttpServerCodecTest { </a> 0
<a> @ Test </a> 0
<a> public void testUnfinishedChunkedHttpRequestIsLastFlag ( ) throws Exception { </a> 0
<a> int maxChunkSize = 2000 ; </a> 0
<a> HttpServerCodec httpServerCodec = new HttpServerCodec ( 1000 , 1000 , maxChunkSize ) ; </a> 0
<a> EmbeddedByteChannel decoderEmbedder = new EmbeddedByteChannel ( httpServerCodec ) ; </a> 0
<a> int totalContentLength = maxChunkSize * 5 ; </a> 0
<a> decoderEmbedder . writeInbound ( Unpooled . copiedBuffer ( "PUT /test HTTP/1.1\r\n" + </a> 0
<a> "Content-Length: " + totalContentLength + "\r\n" + </a> 0
<a> "\r\n" , CharsetUtil . UTF_8 ) ) ; </a> 0
<a> int offeredContentLength = ( int ) ( maxChunkSize * 2.5 ) ; </a> 0
<a> decoderEmbedder . writeInbound ( prepareDataChunk ( offeredContentLength ) ) ; </a> 0
<a> decoderEmbedder . finish ( ) ; </a> 0
<a> HttpMessage httpMessage = ( HttpMessage ) decoderEmbedder . readInbound ( ) ; </a> 0
<a> Assert . assertSame ( HttpTransferEncoding . STREAMED , httpMessage . getTransferEncoding ( ) ) ; </a> 0
<a> boolean empty = true ; </a> 0
<a> int totalBytesPolled = 0 ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> HttpChunk httpChunk = ( HttpChunk ) decoderEmbedder . readInbound ( ) ; </a> 0
<a> if ( httpChunk == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> empty = false ; </a> 0
<a> totalBytesPolled += httpChunk . getContent ( ) . readableBytes ( ) ; </a> 0
<a> Assert . assertFalse ( httpChunk . isLast ( ) ) ; </a> 0
<a> } </a> 0
<a> Assert . assertFalse ( empty ) ; </a> 0
<a> Assert . assertEquals ( offeredContentLength , totalBytesPolled ) ; </a> 0
<a> } </a> 0
<a> private static ByteBuf prepareDataChunk ( int size ) { </a> 0
<a> StringBuilder sb = new StringBuilder ( ) ; </a> 0
<a> for ( int i = 0 ; i < size ; ++ i ) { </a> 0
<a> sb . append ( "a" ) ; </a> 0
<a> } </a> 0
<a> return Unpooled . copiedBuffer ( sb . toString ( ) , CharsetUtil . UTF_8 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . Values . * ; </a> 1
<a> import static io . netty . handler . codec . http . HttpVersion . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import io . netty . handler . codec . http . DefaultHttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpChunkAggregator ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders . Names ; </a> 0
<a> import io . netty . handler . codec . http . HttpMethod ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpRequestDecoder ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseDecoder ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseEncoder ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import org . junit . Assert ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class WebSocketServerHandshaker00Test { </a> 0
<a> @ Test </a> 0
<a> public void testPerformOpeningHandshake ( ) { </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( </a> 1
<a> new HttpChunkAggregator ( 42 ) , new HttpRequestDecoder ( ) , new HttpResponseEncoder ( ) ) ; </a> 0
<a> HttpRequest req = new DefaultHttpRequest ( HTTP_1_1 , HttpMethod . GET , "/chat" ) ; </a> 0
<a> req . setHeader ( Names . HOST , "server.example.com" ) ; </a> 0
<a> req . setHeader ( Names . UPGRADE , WEBSOCKET . toLowerCase ( ) ) ; </a> 0
<a> req . setHeader ( Names . CONNECTION , "Upgrade" ) ; </a> 0
<a> req . setHeader ( Names . ORIGIN , "http://example.com" ) ; </a> 1
<a> req . setHeader ( Names . SEC_WEBSOCKET_KEY1 , "4 @1 46546xW%0l 1 5" ) ; </a> 1
<a> req . setHeader ( Names . SEC_WEBSOCKET_KEY2 , "12998 5 Y3 1 .P00" ) ; </a> 1
<a> req . setHeader ( Names . SEC_WEBSOCKET_PROTOCOL , "chat, superchat" ) ; </a> 1
<a> ByteBuf buffer = Unpooled . copiedBuffer ( "^n:ds[4U" , CharsetUtil . US_ASCII ) ; </a> 1
<a> req . setContent ( buffer ) ; </a> 1
<a> new WebSocketServerHandshaker00 ( </a> 0
<a> "ws://example.com/chat" , "chat" , Integer . MAX_VALUE ) . handshake ( ch , req ) ; </a> 0
<a> ByteBuf resBuf = ch . readOutbound ( ) ; </a> 1
<a> EmbeddedByteChannel ch2 = new EmbeddedByteChannel ( new HttpResponseDecoder ( ) ) ; </a> 1
<a> ch2 . writeInbound ( resBuf ) ; </a> 0
<a> HttpResponse res = ( HttpResponse ) ch2 . readInbound ( ) ; </a> 0
<a> Assert . assertEquals ( "ws://example.com/chat" , res . getHeader ( Names . SEC_WEBSOCKET_LOCATION ) ) ; </a> 1
<a> Assert . assertEquals ( "chat" , res . getHeader ( Names . SEC_WEBSOCKET_PROTOCOL ) ) ; </a> 1
<a> Assert . assertEquals ( "8jKS'y:G*Co,Wxa-" , res . getContent ( ) . toString ( CharsetUtil . US_ASCII ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . http . websocketx ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . Values . * ; </a> 1
<a> import static io . netty . handler . codec . http . HttpVersion . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import io . netty . handler . codec . http . DefaultHttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpChunkAggregator ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders . Names ; </a> 0
<a> import io . netty . handler . codec . http . HttpMethod ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpRequestDecoder ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseDecoder ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseEncoder ; </a> 0
<a> import org . junit . Assert ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class WebSocketServerHandshaker13Test { </a> 0
<a> @ Test </a> 0
<a> public void testPerformOpeningHandshake ( ) { </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( </a> 1
<a> new HttpChunkAggregator ( 42 ) , new HttpRequestDecoder ( ) , new HttpResponseEncoder ( ) ) ; </a> 0
<a> HttpRequest req = new DefaultHttpRequest ( HTTP_1_1 , HttpMethod . GET , "/chat" ) ; </a> 0
<a> req . setHeader ( Names . HOST , "server.example.com" ) ; </a> 0
<a> req . setHeader ( Names . UPGRADE , WEBSOCKET . toLowerCase ( ) ) ; </a> 0
<a> req . setHeader ( Names . CONNECTION , "Upgrade" ) ; </a> 0
<a> req . setHeader ( Names . SEC_WEBSOCKET_KEY , "dGhlIHNhbXBsZSBub25jZQ==" ) ; </a> 0
<a> req . setHeader ( Names . SEC_WEBSOCKET_ORIGIN , "http://example.com" ) ; </a> 0
<a> req . setHeader ( Names . SEC_WEBSOCKET_PROTOCOL , "chat, superchat" ) ; </a> 0
<a> req . setHeader ( Names . SEC_WEBSOCKET_VERSION , "13" ) ; </a> 0
<a> new WebSocketServerHandshaker13 ( </a> 0
<a> "ws://example.com/chat" , "chat" , false , Integer . MAX_VALUE ) . handshake ( ch , req ) ; </a> 0
<a> ByteBuf resBuf = ch . readOutbound ( ) ; </a> 1
<a> EmbeddedByteChannel ch2 = new EmbeddedByteChannel ( new HttpResponseDecoder ( ) ) ; </a> 1
<a> ch2 . writeInbound ( resBuf ) ; </a> 0
<a> HttpResponse res = ( HttpResponse ) ch2 . readInbound ( ) ; </a> 0
<a> Assert . assertEquals ( </a> 0
<a> "s3pPLMBiTxaQ9kYGzzhZRbK+xOo=" , res . getHeader ( Names . SEC_WEBSOCKET_ACCEPT ) ) ; </a> 1
<a> Assert . assertEquals ( "chat" , res . getHeader ( Names . SEC_WEBSOCKET_PROTOCOL ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . spdy ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . embedded . EmbeddedMessageChannel ; </a> 1
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . util . List ; </a> 1
<a> import java . util . Map ; </a> 0
<a> import org . junit . Assert ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class SpdySessionHandlerTest { </a> 0
<a> private static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( SpdySessionHandlerTest . class ) ; </a> 0
<a> private static final int closeSignal = SpdyCodecUtil . SPDY_SETTINGS_MAX_ID ; </a> 0
<a> private static final SpdySettingsFrame closeMessage = new DefaultSpdySettingsFrame ( ) ; </a> 0
<a> static { </a> 0
<a> closeMessage . setValue ( closeSignal , 0 ) ; </a> 0
<a> } </a> 0
<a> private static void assertHeaderBlock ( SpdyHeaderBlock received , SpdyHeaderBlock expected ) { </a> 0
<a> for ( String name : expected . getHeaderNames ( ) ) { </a> 0
<a> List < String > expectedValues = expected . getHeaders ( name ) ; </a> 0
<a> List < String > receivedValues = received . getHeaders ( name ) ; </a> 0
<a> Assert . assertTrue ( receivedValues . containsAll ( expectedValues ) ) ; </a> 1
<a> receivedValues . removeAll ( expectedValues ) ; </a> 0
<a> Assert . assertTrue ( receivedValues . isEmpty ( ) ) ; </a> 1
<a> received . removeHeader ( name ) ; </a> 0
<a> } </a> 0
<a> Assert . assertTrue ( received . getHeaders ( ) . isEmpty ( ) ) ; </a> 1
<a> } </a> 0
<a> private static void assertDataFrame ( Object msg , int streamID , boolean last ) { </a> 0
<a> Assert . assertNotNull ( msg ) ; </a> 1
<a> Assert . assertTrue ( msg instanceof SpdyDataFrame ) ; </a> 1
<a> SpdyDataFrame spdyDataFrame = ( SpdyDataFrame ) msg ; </a> 0
<a> Assert . assertTrue ( spdyDataFrame . getStreamId ( ) == streamID ) ; </a> 1
<a> Assert . assertTrue ( spdyDataFrame . isLast ( ) == last ) ; </a> 1
<a> } </a> 0
<a> private static void assertSynReply ( Object msg , int streamID , boolean last , SpdyHeaderBlock headers ) { </a> 0
<a> Assert . assertNotNull ( msg ) ; </a> 1
<a> Assert . assertTrue ( msg instanceof SpdySynReplyFrame ) ; </a> 1
<a> SpdySynReplyFrame spdySynReplyFrame = ( SpdySynReplyFrame ) msg ; </a> 0
<a> Assert . assertTrue ( spdySynReplyFrame . getStreamId ( ) == streamID ) ; </a> 1
<a> Assert . assertTrue ( spdySynReplyFrame . isLast ( ) == last ) ; </a> 1
<a> assertHeaderBlock ( spdySynReplyFrame , headers ) ; </a> 0
<a> } </a> 0
<a> private static void assertRstStream ( Object msg , int streamID , SpdyStreamStatus status ) { </a> 0
<a> Assert . assertNotNull ( msg ) ; </a> 1
<a> Assert . assertTrue ( msg instanceof SpdyRstStreamFrame ) ; </a> 1
<a> SpdyRstStreamFrame spdyRstStreamFrame = ( SpdyRstStreamFrame ) msg ; </a> 0
<a> Assert . assertTrue ( spdyRstStreamFrame . getStreamId ( ) == streamID ) ; </a> 1
<a> Assert . assertTrue ( spdyRstStreamFrame . getStatus ( ) . equals ( status ) ) ; </a> 1
<a> } </a> 0
<a> private static void assertPing ( Object msg , int ID ) { </a> 1
<a> Assert . assertNotNull ( msg ) ; </a> 1
<a> Assert . assertTrue ( msg instanceof SpdyPingFrame ) ; </a> 1
<a> SpdyPingFrame spdyPingFrame = ( SpdyPingFrame ) msg ; </a> 0
<a> Assert . assertTrue ( spdyPingFrame . getId ( ) == ID ) ; </a> 1
<a> } </a> 0
<a> private static void assertGoAway ( Object msg , int lastGoodStreamID ) { </a> 0
<a> Assert . assertNotNull ( msg ) ; </a> 1
<a> Assert . assertTrue ( msg instanceof SpdyGoAwayFrame ) ; </a> 1
<a> SpdyGoAwayFrame spdyGoAwayFrame = ( SpdyGoAwayFrame ) msg ; </a> 0
<a> Assert . assertTrue ( spdyGoAwayFrame . getLastGoodStreamId ( ) == lastGoodStreamID ) ; </a> 1
<a> } </a> 0
<a> private static void assertHeaders ( Object msg , int streamID , SpdyHeaderBlock headers ) { </a> 0
<a> Assert . assertNotNull ( msg ) ; </a> 1
<a> Assert . assertTrue ( msg instanceof SpdyHeadersFrame ) ; </a> 1
<a> SpdyHeadersFrame spdyHeadersFrame = ( SpdyHeadersFrame ) msg ; </a> 0
<a> Assert . assertTrue ( spdyHeadersFrame . getStreamId ( ) == streamID ) ; </a> 1
<a> assertHeaderBlock ( spdyHeadersFrame , headers ) ; </a> 0
<a> } </a> 0
<a> private void testSpdySessionHandler ( int version , boolean server ) { </a> 1
<a> EmbeddedMessageChannel sessionHandler = new EmbeddedMessageChannel ( </a> 1
<a> new SpdySessionHandler ( version , server ) , new EchoHandler ( closeSignal , server ) ) ; </a> 0
<a> while ( sessionHandler . readOutbound ( ) != null ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> int localStreamID = server ? 1 : 2 ; </a> 0
<a> int remoteStreamID = server ? 2 : 1 ; </a> 0
<a> SpdyPingFrame localPingFrame = new DefaultSpdyPingFrame ( localStreamID ) ; </a> 0
<a> SpdyPingFrame remotePingFrame = new DefaultSpdyPingFrame ( remoteStreamID ) ; </a> 0
<a> SpdySynStreamFrame spdySynStreamFrame = </a> 0
<a> new DefaultSpdySynStreamFrame ( localStreamID , 0 , ( byte ) 0 ) ; </a> 0
<a> spdySynStreamFrame . setHeader ( "Compression" , "test" ) ; </a> 0
<a> SpdyDataFrame spdyDataFrame = new DefaultSpdyDataFrame ( localStreamID ) ; </a> 0
<a> spdyDataFrame . setLast ( true ) ; </a> 0
<a> sessionHandler . writeInbound ( new DefaultSpdyDataFrame ( localStreamID ) ) ; </a> 0
<a> assertRstStream ( sessionHandler . readOutbound ( ) , localStreamID , SpdyStreamStatus . INVALID_STREAM ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> sessionHandler . writeInbound ( new DefaultSpdyDataFrame ( remoteStreamID ) ) ; </a> 0
<a> assertRstStream ( sessionHandler . readOutbound ( ) , remoteStreamID , SpdyStreamStatus . PROTOCOL_ERROR ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> remoteStreamID += 2 ; </a> 0
<a> sessionHandler . writeInbound ( new DefaultSpdySynReplyFrame ( remoteStreamID ) ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> sessionHandler . writeInbound ( new DefaultSpdySynReplyFrame ( remoteStreamID ) ) ; </a> 0
<a> assertRstStream ( sessionHandler . readOutbound ( ) , remoteStreamID , SpdyStreamStatus . STREAM_IN_USE ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> remoteStreamID += 2 ; </a> 0
<a> sessionHandler . writeInbound ( spdySynStreamFrame ) ; </a> 0
<a> assertSynReply ( sessionHandler . readOutbound ( ) , localStreamID , false , spdySynStreamFrame ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> SpdyHeadersFrame spdyHeadersFrame = new DefaultSpdyHeadersFrame ( localStreamID ) ; </a> 0
<a> spdyHeadersFrame . addHeader ( "HEADER" , "test1" ) ; </a> 0
<a> spdyHeadersFrame . addHeader ( "HEADER" , "test2" ) ; </a> 0
<a> sessionHandler . writeInbound ( spdyHeadersFrame ) ; </a> 0
<a> assertHeaders ( sessionHandler . readOutbound ( ) , localStreamID , spdyHeadersFrame ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> localStreamID += 2 ; </a> 0
<a> spdySynStreamFrame . setStreamId ( localStreamID ) ; </a> 0
<a> spdySynStreamFrame . setLast ( true ) ; </a> 0
<a> spdySynStreamFrame . setUnidirectional ( true ) ; </a> 0
<a> sessionHandler . writeInbound ( spdySynStreamFrame ) ; </a> 0
<a> assertRstStream ( sessionHandler . readOutbound ( ) , localStreamID , SpdyStreamStatus . REFUSED_STREAM ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> sessionHandler . writeInbound ( new DefaultSpdyRstStreamFrame ( remoteStreamID , 3 ) ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> remoteStreamID += 2 ; </a> 0
<a> spdySynStreamFrame . setLast ( false ) ; </a> 0
<a> sessionHandler . writeInbound ( spdySynStreamFrame ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> spdySynStreamFrame . setUnidirectional ( false ) ; </a> 0
<a> sessionHandler . writeInbound ( spdySynStreamFrame ) ; </a> 0
<a> assertRstStream ( sessionHandler . readOutbound ( ) , localStreamID , SpdyStreamStatus . PROTOCOL_ERROR ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> localStreamID += 2 ; </a> 0
<a> spdySynStreamFrame . setStreamId ( localStreamID - 1 ) ; </a> 0
<a> sessionHandler . writeInbound ( spdySynStreamFrame ) ; </a> 0
<a> assertRstStream ( sessionHandler . readOutbound ( ) , localStreamID - 1 , SpdyStreamStatus . PROTOCOL_ERROR ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> spdySynStreamFrame . setStreamId ( localStreamID ) ; </a> 0
<a> SpdySettingsFrame spdySettingsFrame = new DefaultSpdySettingsFrame ( ) ; </a> 0
<a> spdySettingsFrame . setValue ( SpdySettingsFrame . SETTINGS_MAX_CONCURRENT_STREAMS , 2 ) ; </a> 0
<a> sessionHandler . writeInbound ( spdySettingsFrame ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> sessionHandler . writeInbound ( spdySynStreamFrame ) ; </a> 0
<a> assertRstStream ( sessionHandler . readOutbound ( ) , localStreamID , SpdyStreamStatus . REFUSED_STREAM ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> spdySettingsFrame . setValue ( SpdySettingsFrame . SETTINGS_MAX_CONCURRENT_STREAMS , 4 ) ; </a> 0
<a> sessionHandler . writeInbound ( spdySettingsFrame ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> sessionHandler . writeInbound ( spdySynStreamFrame ) ; </a> 0
<a> assertSynReply ( sessionHandler . readOutbound ( ) , localStreamID , false , spdySynStreamFrame ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> int testStreamID = spdyDataFrame . getStreamId ( ) ; </a> 0
<a> sessionHandler . writeInbound ( spdyDataFrame ) ; </a> 0
<a> assertDataFrame ( sessionHandler . readOutbound ( ) , testStreamID , spdyDataFrame . isLast ( ) ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> spdyHeadersFrame . setStreamId ( testStreamID ) ; </a> 0
<a> sessionHandler . writeInbound ( spdyHeadersFrame ) ; </a> 0
<a> assertRstStream ( sessionHandler . readOutbound ( ) , testStreamID , SpdyStreamStatus . INVALID_STREAM ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> spdyHeadersFrame . setStreamId ( localStreamID ) ; </a> 0
<a> spdyHeadersFrame . setInvalid ( ) ; </a> 0
<a> sessionHandler . writeInbound ( spdyHeadersFrame ) ; </a> 0
<a> assertRstStream ( sessionHandler . readOutbound ( ) , localStreamID , SpdyStreamStatus . PROTOCOL_ERROR ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> sessionHandler . writeInbound ( localPingFrame ) ; </a> 0
<a> assertPing ( sessionHandler . readOutbound ( ) , localPingFrame . getId ( ) ) ; </a> 1
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> sessionHandler . writeInbound ( remotePingFrame ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> sessionHandler . writeInbound ( closeMessage ) ; </a> 1
<a> assertGoAway ( sessionHandler . readOutbound ( ) , localStreamID ) ; </a> 0
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> localStreamID += 2 ; </a> 1
<a> spdySynStreamFrame . setStreamId ( localStreamID ) ; </a> 1
<a> sessionHandler . writeInbound ( spdySynStreamFrame ) ; </a> 1
<a> assertRstStream ( sessionHandler . readOutbound ( ) , localStreamID , SpdyStreamStatus . REFUSED_STREAM ) ; </a> 1
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> spdyDataFrame . setStreamId ( localStreamID ) ; </a> 1
<a> sessionHandler . writeInbound ( spdyDataFrame ) ; </a> 1
<a> Assert . assertNull ( sessionHandler . readOutbound ( ) ) ; </a> 1
<a> sessionHandler . finish ( ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSpdyClientSessionHandler ( ) { </a> 0
<a> for ( int version = SpdyConstants . SPDY_MIN_VERSION ; version <= SpdyConstants . SPDY_MAX_VERSION ; version ++ ) { </a> 0
<a> logger . info ( "Running: testSpdyClientSessionHandler v" + version ) ; </a> 0
<a> testSpdySessionHandler ( version , false ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testSpdyServerSessionHandler ( ) { </a> 0
<a> for ( int version = SpdyConstants . SPDY_MIN_VERSION ; version <= SpdyConstants . SPDY_MAX_VERSION ; version ++ ) { </a> 0
<a> logger . info ( "Running: testSpdyServerSessionHandler v" + version ) ; </a> 0
<a> testSpdySessionHandler ( version , true ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class EchoHandler extends ChannelInboundMessageHandlerAdapter < Object > { </a> 0
<a> private final int closeSignal ; </a> 0
<a> private final boolean server ; </a> 0
<a> EchoHandler ( int closeSignal , boolean server ) { </a> 0
<a> this . closeSignal = closeSignal ; </a> 0
<a> this . server = server ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> int streamID = server ? 2 : 1 ; </a> 0
<a> SpdySynStreamFrame spdySynStreamFrame = </a> 0
<a> new DefaultSpdySynStreamFrame ( streamID , 0 , ( byte ) 0 ) ; </a> 0
<a> spdySynStreamFrame . setLast ( true ) ; </a> 0
<a> ctx . write ( spdySynStreamFrame ) ; </a> 0
<a> spdySynStreamFrame . setStreamId ( spdySynStreamFrame . getStreamId ( ) + 2 ) ; </a> 1
<a> ctx . write ( spdySynStreamFrame ) ; </a> 0
<a> spdySynStreamFrame . setStreamId ( spdySynStreamFrame . getStreamId ( ) + 2 ) ; </a> 1
<a> ctx . write ( spdySynStreamFrame ) ; </a> 0
<a> spdySynStreamFrame . setStreamId ( spdySynStreamFrame . getStreamId ( ) + 2 ) ; </a> 1
<a> ctx . write ( spdySynStreamFrame ) ; </a> 0
<a> SpdySettingsFrame spdySettingsFrame = new DefaultSpdySettingsFrame ( ) ; </a> 0
<a> spdySettingsFrame . setValue ( SpdySettingsFrame . SETTINGS_MAX_CONCURRENT_STREAMS , 3 ) ; </a> 0
<a> ctx . write ( spdySettingsFrame ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 1
<a> if ( msg instanceof SpdyDataFrame || </a> 0
<a> msg instanceof SpdyPingFrame || </a> 0
<a> msg instanceof SpdyHeadersFrame ) { </a> 0
<a> ctx . write ( msg ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( msg instanceof SpdySynStreamFrame ) { </a> 0
<a> SpdySynStreamFrame spdySynStreamFrame = ( SpdySynStreamFrame ) msg ; </a> 0
<a> if ( ! spdySynStreamFrame . isUnidirectional ( ) ) { </a> 0
<a> int streamID = spdySynStreamFrame . getStreamId ( ) ; </a> 0
<a> SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame ( streamID ) ; </a> 0
<a> spdySynReplyFrame . setLast ( spdySynStreamFrame . isLast ( ) ) ; </a> 0
<a> for ( Map . Entry < String , String > entry : spdySynStreamFrame . getHeaders ( ) ) { </a> 0
<a> spdySynReplyFrame . addHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; </a> 0
<a> } </a> 0
<a> ctx . write ( spdySynReplyFrame ) ; </a> 0
<a> } </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( msg instanceof SpdySettingsFrame ) { </a> 0
<a> SpdySettingsFrame spdySettingsFrame = ( SpdySettingsFrame ) msg ; </a> 0
<a> if ( spdySettingsFrame . isSet ( closeSignal ) ) { </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 1
<a> import io . netty . channel . ChannelInboundByteHandler ; </a> 1
<a> import io . netty . channel . ChannelOutboundByteHandler ; </a> 1
<a> public abstract class ByteToByteCodec </a> 1
<a> extends ChannelHandlerAdapter </a> 0
<a> implements ChannelInboundByteHandler , ChannelOutboundByteHandler { </a> 1
<a> private final ByteToByteEncoder encoder = new ByteToByteEncoder ( ) { </a> 1
<a> @ Override </a> 1
<a> public void encode ( </a> 0
<a> ChannelHandlerContext ctx , </a> 1
<a> ByteBuf in , ByteBuf out ) throws Exception { </a> 1
<a> ByteToByteCodec . this . encode ( ctx , in , out ) ; </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> private final ByteToByteDecoder decoder = new ByteToByteDecoder ( ) { </a> 1
<a> @ Override </a> 1
<a> public void decode ( </a> 0
<a> ChannelHandlerContext ctx , </a> 0
<a> ByteBuf in , ByteBuf out ) throws Exception { </a> 0
<a> ByteToByteCodec . this . decode ( ctx , in , out ) ; </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> @ Override </a> 1
<a> public ByteBuf newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return decoder . newInboundBuffer ( ctx ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> decoder . inboundBufferUpdated ( ctx ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return encoder . newOutboundBuffer ( ctx ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void flush ( </a> 1
<a> ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> encoder . flush ( ctx , future ) ; </a> 0
<a> } </a> 1
<a> public abstract void encode ( </a> 0
<a> ChannelHandlerContext ctx , </a> 0
<a> ByteBuf in , ByteBuf out ) throws Exception ; </a> 0
<a> public abstract void decode ( </a> 0
<a> ChannelHandlerContext ctx , </a> 0
<a> ByteBuf in , ByteBuf out ) throws Exception ; </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandler ; </a> 1
<a> import io . netty . channel . ChannelInboundHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> public abstract class ByteToMessageDecoder < O > </a> 0
<a> extends ChannelInboundHandlerAdapter implements ChannelInboundByteHandler { </a> 0
<a> private ChannelHandlerContext ctx ; </a> 0
<a> @ Override </a> 0
<a> public void beforeAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> this . ctx = ctx ; </a> 0
<a> super . beforeAdd ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return Unpooled . buffer ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> callDecode ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> ByteBuf in = ctx . inboundByteBuffer ( ) ; </a> 1
<a> if ( in . readable ( ) ) { </a> 0
<a> callDecode ( ctx ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> if ( CodecUtil . unfoldAndAdd ( ctx , decodeLast ( ctx , in ) , true ) ) { </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> if ( t instanceof CodecException ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 1
<a> } else { </a> 0
<a> ctx . fireExceptionCaught ( new DecoderException ( t ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> ctx . fireChannelInactive ( ) ; </a> 0
<a> } </a> 0
<a> protected void callDecode ( ChannelHandlerContext ctx ) { </a> 0
<a> ByteBuf in = ctx . inboundByteBuffer ( ) ; </a> 0
<a> boolean decoded = false ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> try { </a> 0
<a> int oldInputLength = in . readableBytes ( ) ; </a> 0
<a> O o = decode ( ctx , in ) ; </a> 0
<a> if ( o == null ) { </a> 1
<a> if ( oldInputLength == in . readableBytes ( ) ) { </a> 0
<a> break ; </a> 0
<a> } else { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( oldInputLength == in . readableBytes ( ) ) { </a> 0
<a> throw new IllegalStateException ( </a> 1
<a> "decode() did not read anything but decoded a message." ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> if ( CodecUtil . unfoldAndAdd ( ctx , o , true ) ) { </a> 0
<a> decoded = true ; </a> 1
<a> } else { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 1
<a> in . unsafe ( ) . discardSomeReadBytes ( ) ; </a> 1
<a> if ( decoded ) { </a> 0
<a> decoded = false ; </a> 1
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 1
<a> if ( t instanceof CodecException ) { </a> 1
<a> ctx . fireExceptionCaught ( t ) ; </a> 1
<a> } else { </a> 1
<a> ctx . fireExceptionCaught ( new DecoderException ( t ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> in . unsafe ( ) . discardSomeReadBytes ( ) ; </a> 1
<a> if ( decoded ) { </a> 1
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> public void replace ( String newHandlerName , ChannelInboundByteHandler newHandler ) { </a> 0
<a> if ( ! ctx . executor ( ) . inEventLoop ( ) ) { </a> 0
<a> throw new IllegalStateException ( "not in event loop" ) ; </a> 0
<a> } </a> 0
<a> ctx . pipeline ( ) . addAfter ( ctx . name ( ) , newHandlerName , newHandler ) ; </a> 0
<a> ByteBuf in = ctx . inboundByteBuffer ( ) ; </a> 0
<a> try { </a> 0
<a> if ( in . readable ( ) ) { </a> 0
<a> ctx . nextInboundByteBuffer ( ) . writeBytes ( ctx . inboundByteBuffer ( ) ) ; </a> 1
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> ctx . pipeline ( ) . remove ( this ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public abstract O decode ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception ; </a> 0
<a> public O decodeLast ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 0
<a> return decode ( ctx , in ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundHandler ; </a> 0
<a> import io . netty . channel . ChannelOutboundHandler ; </a> 0
<a> import io . netty . channel . NoSuchBufferException ; </a> 0
<a> final class CodecUtil { </a> 0
<a> static boolean unfoldAndAdd ( </a> 0
<a> ChannelHandlerContext ctx , Object msg , boolean inbound ) throws Exception { </a> 0
<a> if ( msg == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( msg instanceof Object [ ] ) { </a> 0
<a> Object [ ] array = ( Object [ ] ) msg ; </a> 0
<a> if ( array . length == 0 ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> boolean added = false ; </a> 0
<a> for ( Object m : array ) { </a> 0
<a> if ( m == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( unfoldAndAdd ( ctx , m , inbound ) ) { </a> 0
<a> added = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return added ; </a> 0
<a> } </a> 0
<a> if ( inbound ) { </a> 0
<a> if ( ctx . hasNextInboundMessageBuffer ( ) ) { </a> 0
<a> ctx . nextInboundMessageBuffer ( ) . add ( msg ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( msg instanceof ByteBuf && ctx . hasNextInboundByteBuffer ( ) ) { </a> 0
<a> ByteBuf altDst = ctx . nextInboundByteBuffer ( ) ; </a> 0
<a> ByteBuf src = ( ByteBuf ) msg ; </a> 0
<a> altDst . writeBytes ( src , src . readerIndex ( ) , src . readableBytes ( ) ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( ctx . hasNextOutboundMessageBuffer ( ) ) { </a> 0
<a> ctx . nextOutboundMessageBuffer ( ) . add ( msg ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( msg instanceof ByteBuf && ctx . hasNextOutboundByteBuffer ( ) ) { </a> 0
<a> ByteBuf altDst = ctx . nextOutboundByteBuffer ( ) ; </a> 0
<a> ByteBuf src = ( ByteBuf ) msg ; </a> 0
<a> altDst . writeBytes ( src , src . readerIndex ( ) , src . readableBytes ( ) ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> throw new NoSuchBufferException ( String . format ( </a> 0
<a> "the handler '%s' could not find a %s which accepts a %s." , </a> 0
<a> ctx . name ( ) , </a> 0
<a> inbound ? ChannelInboundHandler . class . getSimpleName ( ) </a> 0
<a> : ChannelOutboundHandler . class . getSimpleName ( ) , </a> 0
<a> msg . getClass ( ) . getSimpleName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> private CodecUtil ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> public class CorruptedFrameException extends DecoderException { </a> 0
<a> private static final long serialVersionUID = 3918052232492988408L ; </a> 0
<a> public CorruptedFrameException ( ) { </a> 0
<a> } </a> 0
<a> public CorruptedFrameException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public CorruptedFrameException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public CorruptedFrameException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> public class DecoderException extends CodecException { </a> 0
<a> private static final long serialVersionUID = 6926716840699621852L ; </a> 0
<a> public DecoderException ( ) { </a> 0
<a> } </a> 0
<a> public DecoderException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public DecoderException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public DecoderException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> public class DelimiterBasedFrameDecoder extends ByteToMessageDecoder < Object > { </a> 0
<a> private final ByteBuf [ ] delimiters ; </a> 0
<a> private final int maxFrameLength ; </a> 0
<a> private final boolean stripDelimiter ; </a> 0
<a> private final boolean failFast ; </a> 0
<a> private boolean discardingTooLongFrame ; </a> 0
<a> private int tooLongFrameLength ; </a> 0
<a> public DelimiterBasedFrameDecoder ( int maxFrameLength , ByteBuf delimiter ) { </a> 0
<a> this ( maxFrameLength , true , delimiter ) ; </a> 0
<a> } </a> 0
<a> public DelimiterBasedFrameDecoder ( </a> 0
<a> int maxFrameLength , boolean stripDelimiter , ByteBuf delimiter ) { </a> 0
<a> this ( maxFrameLength , stripDelimiter , true , delimiter ) ; </a> 0
<a> } </a> 0
<a> public DelimiterBasedFrameDecoder ( </a> 0
<a> int maxFrameLength , boolean stripDelimiter , boolean failFast , </a> 0
<a> ByteBuf delimiter ) { </a> 0
<a> validateMaxFrameLength ( maxFrameLength ) ; </a> 0
<a> validateDelimiter ( delimiter ) ; </a> 0
<a> delimiters = new ByteBuf [ ] { </a> 0
<a> delimiter . slice ( </a> 0
<a> delimiter . readerIndex ( ) , delimiter . readableBytes ( ) ) </a> 0
<a> } ; </a> 0
<a> this . maxFrameLength = maxFrameLength ; </a> 0
<a> this . stripDelimiter = stripDelimiter ; </a> 0
<a> this . failFast = failFast ; </a> 0
<a> } </a> 0
<a> public DelimiterBasedFrameDecoder ( int maxFrameLength , ByteBuf ... delimiters ) { </a> 0
<a> this ( maxFrameLength , true , delimiters ) ; </a> 0
<a> } </a> 0
<a> public DelimiterBasedFrameDecoder ( </a> 0
<a> int maxFrameLength , boolean stripDelimiter , ByteBuf ... delimiters ) { </a> 0
<a> this ( maxFrameLength , stripDelimiter , true , delimiters ) ; </a> 0
<a> } </a> 0
<a> public DelimiterBasedFrameDecoder ( </a> 0
<a> int maxFrameLength , boolean stripDelimiter , boolean failFast , ByteBuf ... delimiters ) { </a> 0
<a> validateMaxFrameLength ( maxFrameLength ) ; </a> 0
<a> if ( delimiters == null ) { </a> 0
<a> throw new NullPointerException ( "delimiters" ) ; </a> 0
<a> } </a> 0
<a> if ( delimiters . length == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "empty delimiters" ) ; </a> 0
<a> } </a> 0
<a> this . delimiters = new ByteBuf [ delimiters . length ] ; </a> 0
<a> for ( int i = 0 ; i < delimiters . length ; i ++ ) { </a> 0
<a> ByteBuf d = delimiters [ i ] ; </a> 0
<a> validateDelimiter ( d ) ; </a> 0
<a> this . delimiters [ i ] = d . slice ( d . readerIndex ( ) , d . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> this . maxFrameLength = maxFrameLength ; </a> 0
<a> this . stripDelimiter = stripDelimiter ; </a> 0
<a> this . failFast = failFast ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decode ( ChannelHandlerContext ctx , ByteBuf buffer ) throws Exception { </a> 0
<a> int minFrameLength = Integer . MAX_VALUE ; </a> 0
<a> ByteBuf minDelim = null ; </a> 0
<a> for ( ByteBuf delim : delimiters ) { </a> 0
<a> int frameLength = indexOf ( buffer , delim ) ; </a> 0
<a> if ( frameLength >= 0 && frameLength < minFrameLength ) { </a> 0
<a> minFrameLength = frameLength ; </a> 0
<a> minDelim = delim ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( minDelim != null ) { </a> 0
<a> int minDelimLength = minDelim . capacity ( ) ; </a> 0
<a> ByteBuf frame ; </a> 0
<a> if ( discardingTooLongFrame ) { </a> 0
<a> discardingTooLongFrame = false ; </a> 0
<a> buffer . skipBytes ( minFrameLength + minDelimLength ) ; </a> 0
<a> int tooLongFrameLength = this . tooLongFrameLength ; </a> 0
<a> this . tooLongFrameLength = 0 ; </a> 0
<a> if ( ! failFast ) { </a> 0
<a> fail ( ctx , tooLongFrameLength ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( minFrameLength > maxFrameLength ) { </a> 0
<a> buffer . skipBytes ( minFrameLength + minDelimLength ) ; </a> 0
<a> fail ( ctx , minFrameLength ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( stripDelimiter ) { </a> 0
<a> frame = buffer . readBytes ( minFrameLength ) ; </a> 0
<a> buffer . skipBytes ( minDelimLength ) ; </a> 0
<a> } else { </a> 0
<a> frame = buffer . readBytes ( minFrameLength + minDelimLength ) ; </a> 0
<a> } </a> 0
<a> return frame ; </a> 0
<a> } else { </a> 0
<a> if ( ! discardingTooLongFrame ) { </a> 0
<a> if ( buffer . readableBytes ( ) > maxFrameLength ) { </a> 0
<a> tooLongFrameLength = buffer . readableBytes ( ) ; </a> 0
<a> buffer . skipBytes ( buffer . readableBytes ( ) ) ; </a> 0
<a> discardingTooLongFrame = true ; </a> 0
<a> if ( failFast ) { </a> 0
<a> fail ( ctx , tooLongFrameLength ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> tooLongFrameLength += buffer . readableBytes ( ) ; </a> 0
<a> buffer . skipBytes ( buffer . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void fail ( ChannelHandlerContext ctx , long frameLength ) { </a> 0
<a> if ( frameLength > 0 ) { </a> 0
<a> ctx . fireExceptionCaught ( </a> 0
<a> new TooLongFrameException ( </a> 0
<a> "frame length exceeds " + maxFrameLength + </a> 0
<a> ": " + frameLength + " - discarded" ) ) ; </a> 0
<a> } else { </a> 0
<a> ctx . fireExceptionCaught ( </a> 0
<a> new TooLongFrameException ( </a> 0
<a> "frame length exceeds " + maxFrameLength + </a> 0
<a> " - discarding" ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static int indexOf ( ByteBuf haystack , ByteBuf needle ) { </a> 0
<a> for ( int i = haystack . readerIndex ( ) ; i < haystack . writerIndex ( ) ; i ++ ) { </a> 0
<a> int haystackIndex = i ; </a> 0
<a> int needleIndex ; </a> 0
<a> for ( needleIndex = 0 ; needleIndex < needle . capacity ( ) ; needleIndex ++ ) { </a> 0
<a> if ( haystack . getByte ( haystackIndex ) != needle . getByte ( needleIndex ) ) { </a> 0
<a> break ; </a> 0
<a> } else { </a> 0
<a> haystackIndex ++ ; </a> 0
<a> if ( haystackIndex == haystack . writerIndex ( ) && </a> 0
<a> needleIndex != needle . capacity ( ) - 1 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( needleIndex == needle . capacity ( ) ) { </a> 0
<a> return i - haystack . readerIndex ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> private static void validateDelimiter ( ByteBuf delimiter ) { </a> 0
<a> if ( delimiter == null ) { </a> 0
<a> throw new NullPointerException ( "delimiter" ) ; </a> 0
<a> } </a> 0
<a> if ( ! delimiter . readable ( ) ) { </a> 0
<a> throw new IllegalArgumentException ( "empty delimiter" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static void validateMaxFrameLength ( int maxFrameLength ) { </a> 0
<a> if ( maxFrameLength <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxFrameLength must be a positive integer: " + </a> 0
<a> maxFrameLength ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> public final class Delimiters { </a> 0
<a> public static ByteBuf [ ] nulDelimiter ( ) { </a> 0
<a> return new ByteBuf [ ] { </a> 0
<a> Unpooled . wrappedBuffer ( new byte [ ] { 0 } ) } ; </a> 0
<a> } </a> 0
<a> public static ByteBuf [ ] lineDelimiter ( ) { </a> 0
<a> return new ByteBuf [ ] { </a> 0
<a> Unpooled . wrappedBuffer ( new byte [ ] { '\r' , '\n' } ) , </a> 0
<a> Unpooled . wrappedBuffer ( new byte [ ] { '\n' } ) , </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> private Delimiters ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> public class EncoderException extends CodecException { </a> 0
<a> private static final long serialVersionUID = - 5086121160476476774L ; </a> 0
<a> public EncoderException ( ) { </a> 0
<a> } </a> 0
<a> public EncoderException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public EncoderException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public EncoderException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . serialization . ObjectDecoder ; </a> 0
<a> public class LengthFieldBasedFrameDecoder extends ByteToMessageDecoder < Object > { </a> 0
<a> private final int maxFrameLength ; </a> 0
<a> private final int lengthFieldOffset ; </a> 0
<a> private final int lengthFieldLength ; </a> 0
<a> private final int lengthFieldEndOffset ; </a> 0
<a> private final int lengthAdjustment ; </a> 0
<a> private final int initialBytesToStrip ; </a> 0
<a> private final boolean failFast ; </a> 0
<a> private boolean discardingTooLongFrame ; </a> 0
<a> private long tooLongFrameLength ; </a> 0
<a> private long bytesToDiscard ; </a> 0
<a> public LengthFieldBasedFrameDecoder ( </a> 0
<a> int maxFrameLength , </a> 0
<a> int lengthFieldOffset , int lengthFieldLength ) { </a> 0
<a> this ( maxFrameLength , lengthFieldOffset , lengthFieldLength , 0 , 0 ) ; </a> 0
<a> } </a> 0
<a> public LengthFieldBasedFrameDecoder ( </a> 0
<a> int maxFrameLength , </a> 0
<a> int lengthFieldOffset , int lengthFieldLength , </a> 0
<a> int lengthAdjustment , int initialBytesToStrip ) { </a> 0
<a> this ( </a> 0
<a> maxFrameLength , </a> 0
<a> lengthFieldOffset , lengthFieldLength , lengthAdjustment , </a> 0
<a> initialBytesToStrip , true ) ; </a> 0
<a> } </a> 0
<a> public LengthFieldBasedFrameDecoder ( </a> 0
<a> int maxFrameLength , </a> 1
<a> int lengthFieldOffset , int lengthFieldLength , </a> 1
<a> int lengthAdjustment , int initialBytesToStrip , boolean failFast ) { </a> 0
<a> if ( maxFrameLength <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxFrameLength must be a positive integer: " + </a> 0
<a> maxFrameLength ) ; </a> 0
<a> } </a> 0
<a> if ( lengthFieldOffset < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "lengthFieldOffset must be a non-negative integer: " + </a> 0
<a> lengthFieldOffset ) ; </a> 0
<a> } </a> 0
<a> if ( initialBytesToStrip < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "initialBytesToStrip must be a non-negative integer: " + </a> 0
<a> initialBytesToStrip ) ; </a> 0
<a> } </a> 0
<a> if ( lengthFieldLength != 1 && lengthFieldLength != 2 && </a> 1
<a> lengthFieldLength != 3 && lengthFieldLength != 4 && </a> 1
<a> lengthFieldLength != 8 ) { </a> 1
<a> throw new IllegalArgumentException ( </a> 1
<a> "lengthFieldLength must be either 1, 2, 3, 4, or 8: " + </a> 1
<a> lengthFieldLength ) ; </a> 1
<a> } </a> 1
<a> if ( lengthFieldOffset > maxFrameLength - lengthFieldLength ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxFrameLength (" + maxFrameLength + ") " + </a> 0
<a> "must be equal to or greater than " + </a> 0
<a> "lengthFieldOffset (" + lengthFieldOffset + ") + " + </a> 0
<a> "lengthFieldLength (" + lengthFieldLength + ")." ) ; </a> 0
<a> } </a> 0
<a> this . maxFrameLength = maxFrameLength ; </a> 0
<a> this . lengthFieldOffset = lengthFieldOffset ; </a> 0
<a> this . lengthFieldLength = lengthFieldLength ; </a> 0
<a> this . lengthAdjustment = lengthAdjustment ; </a> 0
<a> lengthFieldEndOffset = lengthFieldOffset + lengthFieldLength ; </a> 0
<a> this . initialBytesToStrip = initialBytesToStrip ; </a> 0
<a> this . failFast = failFast ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decode ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 0
<a> if ( discardingTooLongFrame ) { </a> 0
<a> long bytesToDiscard = this . bytesToDiscard ; </a> 0
<a> int localBytesToDiscard = ( int ) Math . min ( bytesToDiscard , in . readableBytes ( ) ) ; </a> 0
<a> in . skipBytes ( localBytesToDiscard ) ; </a> 0
<a> bytesToDiscard -= localBytesToDiscard ; </a> 0
<a> this . bytesToDiscard = bytesToDiscard ; </a> 0
<a> failIfNecessary ( ctx , false ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( in . readableBytes ( ) < lengthFieldEndOffset ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> int actualLengthFieldOffset = in . readerIndex ( ) + lengthFieldOffset ; </a> 0
<a> long frameLength ; </a> 1
<a> switch ( lengthFieldLength ) { </a> 1
<a> case 1 : </a> 1
<a> frameLength = in . getUnsignedByte ( actualLengthFieldOffset ) ; </a> 1
<a> break ; </a> 1
<a> case 2 : </a> 1
<a> frameLength = in . getUnsignedShort ( actualLengthFieldOffset ) ; </a> 1
<a> break ; </a> 1
<a> case 3 : </a> 1
<a> frameLength = in . getUnsignedMedium ( actualLengthFieldOffset ) ; </a> 1
<a> break ; </a> 1
<a> case 4 : </a> 1
<a> frameLength = in . getUnsignedInt ( actualLengthFieldOffset ) ; </a> 1
<a> break ; </a> 1
<a> case 8 : </a> 1
<a> frameLength = in . getLong ( actualLengthFieldOffset ) ; </a> 1
<a> break ; </a> 1
<a> default : </a> 1
<a> throw new Error ( "should not reach here" ) ; </a> 1
<a> } </a> 1
<a> if ( frameLength < 0 ) { </a> 0
<a> in . skipBytes ( lengthFieldEndOffset ) ; </a> 0
<a> throw new CorruptedFrameException ( </a> 0
<a> "negative pre-adjustment length field: " + frameLength ) ; </a> 0
<a> } </a> 0
<a> frameLength += lengthAdjustment + lengthFieldEndOffset ; </a> 0
<a> if ( frameLength < lengthFieldEndOffset ) { </a> 0
<a> in . skipBytes ( lengthFieldEndOffset ) ; </a> 0
<a> throw new CorruptedFrameException ( </a> 0
<a> "Adjusted frame length (" + frameLength + ") is less " + </a> 0
<a> "than lengthFieldEndOffset: " + lengthFieldEndOffset ) ; </a> 0
<a> } </a> 0
<a> if ( frameLength > maxFrameLength ) { </a> 0
<a> discardingTooLongFrame = true ; </a> 0
<a> tooLongFrameLength = frameLength ; </a> 0
<a> bytesToDiscard = frameLength - in . readableBytes ( ) ; </a> 0
<a> in . skipBytes ( in . readableBytes ( ) ) ; </a> 0
<a> failIfNecessary ( ctx , true ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> int frameLengthInt = ( int ) frameLength ; </a> 0
<a> if ( in . readableBytes ( ) < frameLengthInt ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> if ( initialBytesToStrip > frameLengthInt ) { </a> 0
<a> in . skipBytes ( frameLengthInt ) ; </a> 0
<a> throw new CorruptedFrameException ( </a> 0
<a> "Adjusted frame length (" + frameLength + ") is less " + </a> 0
<a> "than initialBytesToStrip: " + initialBytesToStrip ) ; </a> 0
<a> } </a> 0
<a> in . skipBytes ( initialBytesToStrip ) ; </a> 0
<a> int readerIndex = in . readerIndex ( ) ; </a> 0
<a> int actualFrameLength = frameLengthInt - initialBytesToStrip ; </a> 0
<a> ByteBuf frame = extractFrame ( in , readerIndex , actualFrameLength ) ; </a> 0
<a> in . readerIndex ( readerIndex + actualFrameLength ) ; </a> 0
<a> return frame ; </a> 0
<a> } </a> 0
<a> private void failIfNecessary ( ChannelHandlerContext ctx , boolean firstDetectionOfTooLongFrame ) { </a> 0
<a> if ( bytesToDiscard == 0 ) { </a> 0
<a> long tooLongFrameLength = this . tooLongFrameLength ; </a> 0
<a> this . tooLongFrameLength = 0 ; </a> 0
<a> discardingTooLongFrame = false ; </a> 0
<a> if ( ! failFast || </a> 0
<a> failFast && firstDetectionOfTooLongFrame ) { </a> 0
<a> fail ( ctx , tooLongFrameLength ) ; </a> 1
<a> } </a> 0
<a> } else { </a> 0
<a> if ( failFast && firstDetectionOfTooLongFrame ) { </a> 0
<a> fail ( ctx , tooLongFrameLength ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected ByteBuf extractFrame ( ByteBuf buffer , int index , int length ) { </a> 0
<a> ByteBuf frame = buffer . unsafe ( ) . newBuffer ( length ) ; </a> 1
<a> frame . writeBytes ( buffer , index , length ) ; </a> 0
<a> return frame ; </a> 0
<a> } </a> 0
<a> private void fail ( ChannelHandlerContext ctx , long frameLength ) { </a> 1
<a> if ( frameLength > 0 ) { </a> 0
<a> ctx . fireExceptionCaught ( </a> 1
<a> new TooLongFrameException ( </a> 1
<a> "Adjusted frame length exceeds " + maxFrameLength + </a> 0
<a> ": " + frameLength + " - discarded" ) ) ; </a> 1
<a> } else { </a> 0
<a> ctx . fireExceptionCaught ( </a> 1
<a> new TooLongFrameException ( </a> 1
<a> "Adjusted frame length exceeds " + maxFrameLength + </a> 0
<a> " - discarding" ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import java . nio . ByteOrder ; </a> 0
<a> @ Sharable </a> 0
<a> public class LengthFieldPrepender extends MessageToByteEncoder < ByteBuf > { </a> 0
<a> private final int lengthFieldLength ; </a> 0
<a> private final boolean lengthIncludesLengthFieldLength ; </a> 0
<a> public LengthFieldPrepender ( int lengthFieldLength ) { </a> 0
<a> this ( lengthFieldLength , false ) ; </a> 0
<a> } </a> 0
<a> public LengthFieldPrepender ( </a> 0
<a> int lengthFieldLength , boolean lengthIncludesLengthFieldLength ) { </a> 0
<a> if ( lengthFieldLength != 1 && lengthFieldLength != 2 && </a> 0
<a> lengthFieldLength != 3 && lengthFieldLength != 4 && </a> 0
<a> lengthFieldLength != 8 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "lengthFieldLength must be either 1, 2, 3, 4, or 8: " + </a> 0
<a> lengthFieldLength ) ; </a> 0
<a> } </a> 0
<a> this . lengthFieldLength = lengthFieldLength ; </a> 0
<a> this . lengthIncludesLengthFieldLength = lengthIncludesLengthFieldLength ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof ByteBuf ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( </a> 0
<a> ChannelHandlerContext ctx , </a> 1
<a> ByteBuf msg , ByteBuf out ) throws Exception { </a> 1
<a> int length = lengthIncludesLengthFieldLength ? </a> 0
<a> msg . readableBytes ( ) + lengthFieldLength : msg . readableBytes ( ) ; </a> 0
<a> switch ( lengthFieldLength ) { </a> 0
<a> case 1 : </a> 0
<a> if ( length >= 256 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "length does not fit into a byte: " + length ) ; </a> 0
<a> } </a> 0
<a> out . writeByte ( ( byte ) length ) ; </a> 0
<a> break ; </a> 0
<a> case 2 : </a> 0
<a> if ( length >= 65536 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "length does not fit into a short integer: " + length ) ; </a> 0
<a> } </a> 0
<a> out . writeShort ( ( short ) length ) ; </a> 0
<a> break ; </a> 0
<a> case 3 : </a> 0
<a> if ( length >= 16777216 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "length does not fit into a medium integer: " + length ) ; </a> 0
<a> } </a> 0
<a> out . writeMedium ( length ) ; </a> 0
<a> break ; </a> 0
<a> case 4 : </a> 0
<a> out . writeInt ( length ) ; </a> 0
<a> break ; </a> 0
<a> case 8 : </a> 0
<a> out . writeLong ( length ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new Error ( "should not reach here" ) ; </a> 0
<a> } </a> 0
<a> out . writeBytes ( msg , msg . readerIndex ( ) , msg . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelOutboundMessageHandlerAdapter ; </a> 1
<a> public abstract class MessageToByteEncoder < I > extends ChannelOutboundMessageHandlerAdapter < I > { </a> 1
<a> @ Override </a> 0
<a> public void flush ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> MessageBuf < I > in = ctx . outboundMessageBuffer ( ) ; </a> 0
<a> ByteBuf out = ctx . nextOutboundByteBuffer ( ) ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> Object msg = in . poll ( ) ; </a> 0
<a> if ( msg == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ! isEncodable ( msg ) ) { </a> 0
<a> ctx . nextOutboundMessageBuffer ( ) . add ( msg ) ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> I imsg = ( I ) msg ; </a> 0
<a> try { </a> 0
<a> encode ( ctx , imsg , out ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( t instanceof CodecException ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } else { </a> 0
<a> ctx . fireExceptionCaught ( new EncoderException ( t ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ctx . flush ( future ) ; </a> 0
<a> } </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public abstract void encode ( ChannelHandlerContext ctx , I msg , ByteBuf out ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandler ; </a> 1
<a> import io . netty . channel . ChannelOutboundMessageHandler ; </a> 1
<a> public abstract class MessageToMessageCodec < INBOUND_IN , INBOUND_OUT , OUTBOUND_IN , OUTBOUND_OUT > </a> 0
<a> extends ChannelHandlerAdapter </a> 0
<a> implements ChannelInboundMessageHandler < INBOUND_IN > , </a> 1
<a> ChannelOutboundMessageHandler < OUTBOUND_IN > { </a> 1
<a> private final MessageToMessageEncoder < OUTBOUND_IN , OUTBOUND_OUT > encoder = </a> 0
<a> new MessageToMessageEncoder < OUTBOUND_IN , OUTBOUND_OUT > ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return MessageToMessageCodec . this . isEncodable ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public OUTBOUND_OUT encode ( ChannelHandlerContext ctx , OUTBOUND_IN msg ) throws Exception { </a> 0
<a> return MessageToMessageCodec . this . encode ( ctx , msg ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private final MessageToMessageDecoder < INBOUND_IN , INBOUND_OUT > decoder = </a> 0
<a> new MessageToMessageDecoder < INBOUND_IN , INBOUND_OUT > ( ) { </a> 0
<a> @ Override </a> 0
<a> public boolean isDecodable ( Object msg ) throws Exception { </a> 0
<a> return MessageToMessageCodec . this . isDecodable ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public INBOUND_OUT decode ( ChannelHandlerContext ctx , INBOUND_IN msg ) throws Exception { </a> 0
<a> return MessageToMessageCodec . this . decode ( ctx , msg ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> @ Override </a> 0
<a> public MessageBuf < INBOUND_IN > newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return decoder . newInboundBuffer ( ctx ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( </a> 1
<a> ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> decoder . inboundBufferUpdated ( ctx ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public MessageBuf < OUTBOUND_IN > newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return encoder . newOutboundBuffer ( ctx ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void flush ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> encoder . flush ( ctx , future ) ; </a> 1
<a> } </a> 0
<a> public boolean isDecodable ( Object msg ) throws Exception { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public abstract OUTBOUND_OUT encode ( ChannelHandlerContext ctx , OUTBOUND_IN msg ) throws Exception ; </a> 0
<a> public abstract INBOUND_OUT decode ( ChannelHandlerContext ctx , INBOUND_IN msg ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandler ; </a> 1
<a> public abstract class MessageToMessageDecoder < I , O > </a> 0
<a> extends ChannelInboundHandlerAdapter implements ChannelInboundMessageHandler < I > { </a> 0
<a> @ Override </a> 0
<a> public MessageBuf < I > newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return Unpooled . messageBuffer ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) </a> 1
<a> throws Exception { </a> 1
<a> MessageBuf < I > in = ctx . inboundMessageBuffer ( ) ; </a> 0
<a> boolean notify = false ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> try { </a> 0
<a> Object msg = in . poll ( ) ; </a> 0
<a> if ( msg == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ! isDecodable ( msg ) ) { </a> 0
<a> ctx . nextInboundMessageBuffer ( ) . add ( msg ) ; </a> 0
<a> notify = true ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> I imsg = ( I ) msg ; </a> 0
<a> O omsg = decode ( ctx , imsg ) ; </a> 0
<a> if ( omsg == null ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> if ( CodecUtil . unfoldAndAdd ( ctx , omsg , true ) ) { </a> 0
<a> notify = true ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( t instanceof CodecException ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } else { </a> 0
<a> ctx . fireExceptionCaught ( new DecoderException ( t ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( notify ) { </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public boolean isDecodable ( Object msg ) throws Exception { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public abstract O decode ( ChannelHandlerContext ctx , I msg ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelOutboundMessageHandlerAdapter ; </a> 1
<a> public abstract class MessageToMessageEncoder < I , O > extends ChannelOutboundMessageHandlerAdapter < I > { </a> 0
<a> @ Override </a> 0
<a> public void flush ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> MessageBuf < I > in = ctx . outboundMessageBuffer ( ) ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> try { </a> 0
<a> Object msg = in . poll ( ) ; </a> 0
<a> if ( msg == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ! isEncodable ( msg ) ) { </a> 0
<a> ctx . nextOutboundMessageBuffer ( ) . add ( msg ) ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> I imsg = ( I ) msg ; </a> 0
<a> O omsg = encode ( ctx , imsg ) ; </a> 0
<a> if ( omsg == null ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> CodecUtil . unfoldAndAdd ( ctx , omsg , false ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( t instanceof CodecException ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } else { </a> 0
<a> ctx . fireExceptionCaught ( new EncoderException ( t ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ctx . flush ( future ) ; </a> 0
<a> } </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public abstract O encode ( ChannelHandlerContext ctx , I msg ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> public class PrematureChannelClosureException extends CodecException { </a> 0
<a> private static final long serialVersionUID = 4907642202594703094L ; </a> 0
<a> public PrematureChannelClosureException ( ) { } </a> 0
<a> public PrematureChannelClosureException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public PrematureChannelClosureException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public PrematureChannelClosureException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . util . internal . Signal ; </a> 0
<a> public abstract class ReplayingDecoder < O , S > extends ByteToMessageDecoder < O > { </a> 0
<a> static final Signal REPLAY = new Signal ( ReplayingDecoder . class . getName ( ) + ".REPLAY" ) ; </a> 1
<a> private final ByteBuf cumulation = Unpooled . buffer ( ) ; </a> 1
<a> private final ReplayingDecoderBuffer replayable = new ReplayingDecoderBuffer ( cumulation ) ; </a> 1
<a> private S state ; </a> 0
<a> private int checkpoint = - 1 ; </a> 0
<a> protected ReplayingDecoder ( ) { </a> 0
<a> this ( null ) ; </a> 0
<a> } </a> 0
<a> protected ReplayingDecoder ( S initialState ) { </a> 0
<a> state = initialState ; </a> 0
<a> } </a> 0
<a> protected void checkpoint ( ) { </a> 0
<a> checkpoint = cumulation . readerIndex ( ) ; </a> 0
<a> } </a> 0
<a> protected void checkpoint ( S state ) { </a> 0
<a> checkpoint ( ) ; </a> 0
<a> state ( state ) ; </a> 0
<a> } </a> 0
<a> protected S state ( ) { </a> 0
<a> return state ; </a> 0
<a> } </a> 0
<a> protected S state ( S newState ) { </a> 0
<a> S oldState = state ; </a> 0
<a> state = newState ; </a> 0
<a> return oldState ; </a> 0
<a> } </a> 0
<a> protected int actualReadableBytes ( ) { </a> 1
<a> return internalBuffer ( ) . readableBytes ( ) ; </a> 1
<a> } </a> 1
<a> protected ByteBuf internalBuffer ( ) { </a> 1
<a> return cumulation ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public ByteBuf newInboundBuffer ( </a> 0
<a> ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return cumulation ; </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> replayable . terminate ( ) ; </a> 0
<a> ByteBuf in = cumulation ; </a> 0
<a> if ( in . readable ( ) ) { </a> 0
<a> callDecode ( ctx ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> if ( CodecUtil . unfoldAndAdd ( ctx , decodeLast ( ctx , replayable ) , true ) ) { </a> 0
<a> fireInboundBufferUpdated ( ctx , in ) ; </a> 0
<a> } </a> 1
<a> } catch ( Signal replay ) { </a> 0
<a> replay . expect ( REPLAY ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( t instanceof CodecException ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 1
<a> } else { </a> 0
<a> ctx . fireExceptionCaught ( new DecoderException ( t ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> ctx . fireChannelInactive ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> protected void callDecode ( ChannelHandlerContext ctx ) { </a> 0
<a> ByteBuf in = cumulation ; </a> 0
<a> boolean decoded = false ; </a> 0
<a> while ( in . readable ( ) ) { </a> 0
<a> try { </a> 0
<a> int oldReaderIndex = checkpoint = in . readerIndex ( ) ; </a> 0
<a> Object result = null ; </a> 1
<a> S oldState = state ; </a> 0
<a> try { </a> 0
<a> result = decode ( ctx , replayable ) ; </a> 1
<a> if ( result == null ) { </a> 1
<a> if ( oldReaderIndex == in . readerIndex ( ) && oldState == state ) { </a> 1
<a> throw new IllegalStateException ( </a> 1
<a> "null cannot be returned if no data is consumed and state didn't change." ) ; </a> 1
<a> } else { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Signal replay ) { </a> 0
<a> replay . expect ( REPLAY ) ; </a> 0
<a> int checkpoint = this . checkpoint ; </a> 0
<a> if ( checkpoint >= 0 ) { </a> 0
<a> in . readerIndex ( checkpoint ) ; </a> 0
<a> } else { </a> 0
<a> } </a> 0
<a> } </a> 1
<a> if ( result == null ) { </a> 1
<a> break ; </a> 0
<a> } </a> 0
<a> if ( oldReaderIndex == in . readerIndex ( ) && oldState == state ) { </a> 0
<a> throw new IllegalStateException ( </a> 1
<a> "decode() method must consume at least one byte " + </a> 1
<a> "if it returned a decoded message (caused by: " + </a> 1
<a> getClass ( ) + ")" ) ; </a> 0
<a> } </a> 0
<a> if ( CodecUtil . unfoldAndAdd ( ctx , result , true ) ) { </a> 0
<a> decoded = true ; </a> 1
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 1
<a> if ( decoded ) { </a> 0
<a> decoded = false ; </a> 1
<a> fireInboundBufferUpdated ( ctx , in ) ; </a> 0
<a> } </a> 1
<a> if ( t instanceof CodecException ) { </a> 1
<a> ctx . fireExceptionCaught ( t ) ; </a> 1
<a> } else { </a> 1
<a> ctx . fireExceptionCaught ( new DecoderException ( t ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> if ( decoded ) { </a> 1
<a> fireInboundBufferUpdated ( ctx , in ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void fireInboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) { </a> 0
<a> final int oldReaderIndex = in . readerIndex ( ) ; </a> 0
<a> in . unsafe ( ) . discardSomeReadBytes ( ) ; </a> 1
<a> final int newReaderIndex = in . readerIndex ( ) ; </a> 0
<a> checkpoint -= oldReaderIndex - newReaderIndex ; </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ByteBufIndexFinder ; </a> 0
<a> import io . netty . buffer . ChannelBufType ; </a> 1
<a> import io . netty . buffer . SwappedByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . util . internal . Signal ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> import java . io . InputStream ; </a> 1
<a> import java . io . OutputStream ; </a> 1
<a> import java . nio . ByteBuffer ; </a> 1
<a> import java . nio . ByteOrder ; </a> 1
<a> import java . nio . channels . GatheringByteChannel ; </a> 1
<a> import java . nio . channels . ScatteringByteChannel ; </a> 1
<a> import java . nio . charset . Charset ; </a> 0
<a> class ReplayingDecoderBuffer implements ByteBuf { </a> 1
<a> private static final Signal REPLAY = ReplayingDecoder . REPLAY ; </a> 0
<a> private final ByteBuf buffer ; </a> 0
<a> private final SwappedByteBuf swapped ; </a> 0
<a> private boolean terminated ; </a> 0
<a> static final ReplayingDecoderBuffer EMPTY_BUFFER = new ReplayingDecoderBuffer ( Unpooled . EMPTY_BUFFER ) ; </a> 0
<a> static { </a> 0
<a> EMPTY_BUFFER . terminate ( ) ; </a> 0
<a> } </a> 0
<a> ReplayingDecoderBuffer ( ByteBuf buffer ) { </a> 0
<a> this . buffer = buffer ; </a> 0
<a> swapped = new SwappedByteBuf ( this ) ; </a> 0
<a> } </a> 0
<a> void terminate ( ) { </a> 0
<a> terminated = true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int capacity ( ) { </a> 0
<a> if ( terminated ) { </a> 0
<a> return buffer . capacity ( ) ; </a> 0
<a> } else { </a> 0
<a> return Integer . MAX_VALUE ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void capacity ( int newCapacity ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int maxCapacity ( ) { </a> 0
<a> return capacity ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelBufType type ( ) { </a> 1
<a> return ChannelBufType . BYTE ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isPooled ( ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDirect ( ) { </a> 0
<a> return buffer . isDirect ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean hasArray ( ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public byte [ ] array ( ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int arrayOffset ( ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void clear ( ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object obj ) { </a> 0
<a> return this == obj ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( ByteBuf buffer ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf copy ( ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf copy ( int index , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> return buffer . copy ( index , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void discardReadBytes ( ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void ensureWritableBytes ( int writableBytes ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public int ensureWritableBytes ( int minWritableBytes , boolean force ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf duplicate ( ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean getBoolean ( int index ) { </a> 0
<a> checkIndex ( index , 1 ) ; </a> 0
<a> return buffer . getBoolean ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte getByte ( int index ) { </a> 0
<a> checkIndex ( index , 1 ) ; </a> 0
<a> return buffer . getByte ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short getUnsignedByte ( int index ) { </a> 0
<a> checkIndex ( index , 1 ) ; </a> 0
<a> return buffer . getUnsignedByte ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , byte [ ] dst , int dstIndex , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> buffer . getBytes ( index , dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , byte [ ] dst ) { </a> 0
<a> checkIndex ( index , dst . length ) ; </a> 0
<a> buffer . getBytes ( index , dst ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuffer dst ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuf dst , int dstIndex , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> buffer . getBytes ( index , dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuf dst , int length ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , ByteBuf dst ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getBytes ( int index , GatheringByteChannel out , int length ) </a> 1
<a> throws IOException { </a> 1
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void getBytes ( int index , OutputStream out , int length ) </a> 0
<a> throws IOException { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getInt ( int index ) { </a> 0
<a> checkIndex ( index , 4 ) ; </a> 0
<a> return buffer . getInt ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getUnsignedInt ( int index ) { </a> 0
<a> checkIndex ( index , 4 ) ; </a> 0
<a> return buffer . getUnsignedInt ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getLong ( int index ) { </a> 0
<a> checkIndex ( index , 8 ) ; </a> 0
<a> return buffer . getLong ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getMedium ( int index ) { </a> 0
<a> checkIndex ( index , 3 ) ; </a> 0
<a> return buffer . getMedium ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getUnsignedMedium ( int index ) { </a> 0
<a> checkIndex ( index , 3 ) ; </a> 0
<a> return buffer . getUnsignedMedium ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short getShort ( int index ) { </a> 0
<a> checkIndex ( index , 2 ) ; </a> 0
<a> return buffer . getShort ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getUnsignedShort ( int index ) { </a> 0
<a> checkIndex ( index , 2 ) ; </a> 0
<a> return buffer . getUnsignedShort ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public char getChar ( int index ) { </a> 0
<a> checkIndex ( index , 2 ) ; </a> 0
<a> return buffer . getChar ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public float getFloat ( int index ) { </a> 0
<a> checkIndex ( index , 4 ) ; </a> 0
<a> return buffer . getFloat ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public double getDouble ( int index ) { </a> 0
<a> checkIndex ( index , 8 ) ; </a> 0
<a> return buffer . getDouble ( index ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int indexOf ( int fromIndex , int toIndex , byte value ) { </a> 0
<a> int endIndex = buffer . indexOf ( fromIndex , toIndex , value ) ; </a> 1
<a> if ( endIndex < 0 ) { </a> 1
<a> throw REPLAY ; </a> 0
<a> } </a> 0
<a> return endIndex ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public int indexOf ( int fromIndex , int toIndex , </a> 1
<a> ByteBufIndexFinder indexFinder ) { </a> 1
<a> int endIndex = buffer . indexOf ( fromIndex , toIndex , indexFinder ) ; </a> 0
<a> if ( endIndex < 0 ) { </a> 0
<a> throw REPLAY ; </a> 0
<a> } </a> 0
<a> return endIndex ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( byte value ) { </a> 0
<a> int bytes = buffer . bytesBefore ( value ) ; </a> 0
<a> if ( bytes < 0 ) { </a> 0
<a> throw REPLAY ; </a> 0
<a> } </a> 0
<a> return bytes ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( ByteBufIndexFinder indexFinder ) { </a> 0
<a> int bytes = buffer . bytesBefore ( indexFinder ) ; </a> 0
<a> if ( bytes < 0 ) { </a> 0
<a> throw REPLAY ; </a> 0
<a> } </a> 0
<a> return bytes ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( int length , byte value ) { </a> 0
<a> checkReadableBytes ( length ) ; </a> 1
<a> int bytes = buffer . bytesBefore ( length , value ) ; </a> 1
<a> if ( bytes < 0 ) { </a> 1
<a> throw REPLAY ; </a> 0
<a> } </a> 0
<a> return bytes ; </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> public int bytesBefore ( int length , ByteBufIndexFinder indexFinder ) { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> int bytes = buffer . bytesBefore ( length , indexFinder ) ; </a> 0
<a> if ( bytes < 0 ) { </a> 0
<a> throw REPLAY ; </a> 0
<a> } </a> 0
<a> return bytes ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( int index , int length , byte value ) { </a> 1
<a> int bytes = buffer . bytesBefore ( index , length , value ) ; </a> 1
<a> if ( bytes < 0 ) { </a> 1
<a> throw REPLAY ; </a> 0
<a> } </a> 0
<a> return bytes ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public int bytesBefore ( int index , int length , </a> 1
<a> ByteBufIndexFinder indexFinder ) { </a> 1
<a> int bytes = buffer . bytesBefore ( index , length , indexFinder ) ; </a> 0
<a> if ( bytes < 0 ) { </a> 0
<a> throw REPLAY ; </a> 0
<a> } </a> 0
<a> return bytes ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void markReaderIndex ( ) { </a> 0
<a> buffer . markReaderIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void markWriterIndex ( ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteOrder order ( ) { </a> 0
<a> return buffer . order ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf order ( ByteOrder endianness ) { </a> 0
<a> if ( endianness == null ) { </a> 0
<a> throw new NullPointerException ( "endianness" ) ; </a> 0
<a> } </a> 0
<a> if ( endianness == order ( ) ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> return swapped ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readable ( ) { </a> 1
<a> return terminated ? buffer . readable ( ) : true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readableBytes ( ) { </a> 0
<a> if ( terminated ) { </a> 0
<a> return buffer . readableBytes ( ) ; </a> 0
<a> } else { </a> 0
<a> return Integer . MAX_VALUE - buffer . readerIndex ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readBoolean ( ) { </a> 0
<a> checkReadableBytes ( 1 ) ; </a> 0
<a> return buffer . readBoolean ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte readByte ( ) { </a> 0
<a> checkReadableBytes ( 1 ) ; </a> 0
<a> return buffer . readByte ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short readUnsignedByte ( ) { </a> 0
<a> checkReadableBytes ( 1 ) ; </a> 0
<a> return buffer . readUnsignedByte ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( byte [ ] dst , int dstIndex , int length ) { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> buffer . readBytes ( dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( byte [ ] dst ) { </a> 0
<a> checkReadableBytes ( dst . length ) ; </a> 0
<a> buffer . readBytes ( dst ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( ByteBuffer dst ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( ByteBuf dst , int dstIndex , int length ) { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> buffer . readBytes ( dst , dstIndex , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( ByteBuf dst , int length ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( ByteBuf dst ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readBytes ( GatheringByteChannel out , int length ) </a> 0
<a> throws IOException { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf readBytes ( int length ) { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> return buffer . readBytes ( length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf readSlice ( int length ) { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> return buffer . readSlice ( length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readBytes ( OutputStream out , int length ) throws IOException { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readerIndex ( ) { </a> 0
<a> return buffer . readerIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void readerIndex ( int readerIndex ) { </a> 0
<a> buffer . readerIndex ( readerIndex ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readInt ( ) { </a> 0
<a> checkReadableBytes ( 4 ) ; </a> 0
<a> return buffer . readInt ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long readUnsignedInt ( ) { </a> 0
<a> checkReadableBytes ( 4 ) ; </a> 0
<a> return buffer . readUnsignedInt ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long readLong ( ) { </a> 0
<a> checkReadableBytes ( 8 ) ; </a> 0
<a> return buffer . readLong ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readMedium ( ) { </a> 0
<a> checkReadableBytes ( 3 ) ; </a> 0
<a> return buffer . readMedium ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readUnsignedMedium ( ) { </a> 0
<a> checkReadableBytes ( 3 ) ; </a> 0
<a> return buffer . readUnsignedMedium ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public short readShort ( ) { </a> 0
<a> checkReadableBytes ( 2 ) ; </a> 0
<a> return buffer . readShort ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int readUnsignedShort ( ) { </a> 0
<a> checkReadableBytes ( 2 ) ; </a> 0
<a> return buffer . readUnsignedShort ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public char readChar ( ) { </a> 0
<a> checkReadableBytes ( 2 ) ; </a> 0
<a> return buffer . readChar ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public float readFloat ( ) { </a> 0
<a> checkReadableBytes ( 4 ) ; </a> 0
<a> return buffer . readFloat ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public double readDouble ( ) { </a> 0
<a> checkReadableBytes ( 8 ) ; </a> 0
<a> return buffer . readDouble ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void resetReaderIndex ( ) { </a> 0
<a> buffer . resetReaderIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void resetWriterIndex ( ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBoolean ( int index , boolean value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setByte ( int index , int value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , byte [ ] src , int srcIndex , int length ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , byte [ ] src ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuffer src ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuf src , int srcIndex , int length ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuf src , int length ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBytes ( int index , ByteBuf src ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , InputStream in , int length ) </a> 0
<a> throws IOException { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setZero ( int index , int length ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int setBytes ( int index , ScatteringByteChannel in , int length ) </a> 0
<a> throws IOException { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public void setIndex ( int readerIndex , int writerIndex ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setInt ( int index , int value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setLong ( int index , long value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setMedium ( int index , int value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setShort ( int index , int value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setChar ( int index , int value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setFloat ( int index , float value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setDouble ( int index , double value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void skipBytes ( int length ) { </a> 0
<a> checkReadableBytes ( length ) ; </a> 0
<a> buffer . skipBytes ( length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf slice ( ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf slice ( int index , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> return buffer . slice ( index , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNioBuffer ( ) { </a> 1
<a> return buffer . hasNioBuffer ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuffer nioBuffer ( ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer nioBuffer ( int index , int length ) { </a> 1
<a> checkIndex ( index , length ) ; </a> 0
<a> return buffer . nioBuffer ( index , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNioBuffers ( ) { </a> 1
<a> return buffer . hasNioBuffers ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuffer [ ] nioBuffers ( ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuffer [ ] nioBuffers ( int index , int length ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> return buffer . nioBuffers ( index , length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( int index , int length , Charset charset ) { </a> 0
<a> checkIndex ( index , length ) ; </a> 0
<a> return buffer . toString ( index , length , charset ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( Charset charsetName ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getClass ( ) . getSimpleName ( ) + '(' + </a> 0
<a> "ridx=" + </a> 0
<a> readerIndex ( ) + </a> 0
<a> ", " + </a> 0
<a> "widx=" + </a> 0
<a> writerIndex ( ) + </a> 0
<a> ')' ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean writable ( ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int writableBytes ( ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBoolean ( boolean value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeByte ( int value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( byte [ ] src , int srcIndex , int length ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void writeBytes ( byte [ ] src ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( ByteBuffer src ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( ByteBuf src , int srcIndex , int length ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( ByteBuf src , int length ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeBytes ( ByteBuf src ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int writeBytes ( InputStream in , int length ) throws IOException { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int writeBytes ( ScatteringByteChannel in , int length ) </a> 0
<a> throws IOException { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeInt ( int value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeLong ( long value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeMedium ( int value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeZero ( int length ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int writerIndex ( ) { </a> 0
<a> return buffer . writerIndex ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writerIndex ( int writerIndex ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeShort ( int value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeChar ( int value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void writeFloat ( float value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void writeDouble ( double value ) { </a> 0
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> private void checkIndex ( int index , int length ) { </a> 0
<a> if ( index + length > buffer . writerIndex ( ) ) { </a> 0
<a> throw REPLAY ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void checkReadableBytes ( int readableBytes ) { </a> 0
<a> if ( buffer . readableBytes ( ) < readableBytes ) { </a> 0
<a> throw REPLAY ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Unsafe unsafe ( ) { </a> 1
<a> throw new UnreplayableOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> public class TooLongFrameException extends DecoderException { </a> 0
<a> private static final long serialVersionUID = - 1995801950698951640L ; </a> 0
<a> public TooLongFrameException ( ) { </a> 0
<a> } </a> 0
<a> public TooLongFrameException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public TooLongFrameException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public TooLongFrameException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> public class UnreplayableOperationException extends UnsupportedOperationException { </a> 0
<a> private static final long serialVersionUID = 8577363912862364021L ; </a> 0
<a> public UnreplayableOperationException ( ) { </a> 0
<a> } </a> 0
<a> public UnreplayableOperationException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public UnreplayableOperationException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> public UnreplayableOperationException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> public class UnsupportedMessageTypeException extends CodecException { </a> 0
<a> private static final long serialVersionUID = 2799598826487038726L ; </a> 0
<a> public UnsupportedMessageTypeException ( </a> 0
<a> Object message , Class < ? > ... expectedTypes ) { </a> 0
<a> super ( message ( </a> 0
<a> message == null ? "null" : message . getClass ( ) . getName ( ) , expectedTypes ) ) ; </a> 0
<a> } </a> 0
<a> public UnsupportedMessageTypeException ( ) { } </a> 0
<a> public UnsupportedMessageTypeException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public UnsupportedMessageTypeException ( String s ) { </a> 0
<a> super ( s ) ; </a> 0
<a> } </a> 0
<a> public UnsupportedMessageTypeException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> private static String message ( </a> 0
<a> String actualType , Class < ? > ... expectedTypes ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( actualType ) ; </a> 0
<a> if ( expectedTypes != null && expectedTypes . length > 0 ) { </a> 0
<a> buf . append ( " (expected: " ) . append ( expectedTypes [ 0 ] . getName ( ) ) ; </a> 0
<a> for ( int i = 1 ; i < expectedTypes . length ; i ++ ) { </a> 0
<a> Class < ? > t = expectedTypes [ i ] ; </a> 0
<a> if ( t == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> buf . append ( ", " ) . append ( t . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> buf . append ( ')' ) ; </a> 0
<a> } </a> 0
<a> return buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . base64 ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> public final class Base64 { </a> 0
<a> private static final int MAX_LINE_LENGTH = 76 ; </a> 0
<a> private static final byte EQUALS_SIGN = ( byte ) '=' ; </a> 0
<a> private static final byte NEW_LINE = ( byte ) '\n' ; </a> 0
<a> private static final byte WHITE_SPACE_ENC = - 5 ; </a> 0
<a> private static final byte EQUALS_SIGN_ENC = - 1 ; </a> 0
<a> private static byte [ ] alphabet ( Base64Dialect dialect ) { </a> 0
<a> if ( dialect == null ) { </a> 0
<a> throw new NullPointerException ( "dialect" ) ; </a> 0
<a> } </a> 0
<a> return dialect . alphabet ; </a> 0
<a> } </a> 0
<a> private static byte [ ] decodabet ( Base64Dialect dialect ) { </a> 0
<a> if ( dialect == null ) { </a> 0
<a> throw new NullPointerException ( "dialect" ) ; </a> 0
<a> } </a> 0
<a> return dialect . decodabet ; </a> 0
<a> } </a> 0
<a> private static boolean breakLines ( Base64Dialect dialect ) { </a> 0
<a> if ( dialect == null ) { </a> 0
<a> throw new NullPointerException ( "dialect" ) ; </a> 0
<a> } </a> 0
<a> return dialect . breakLinesByDefault ; </a> 0
<a> } </a> 0
<a> public static ByteBuf encode ( ByteBuf src ) { </a> 0
<a> return encode ( src , Base64Dialect . STANDARD ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf encode ( ByteBuf src , Base64Dialect dialect ) { </a> 0
<a> return encode ( src , breakLines ( dialect ) , dialect ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf encode ( ByteBuf src , boolean breakLines ) { </a> 0
<a> return encode ( src , breakLines , Base64Dialect . STANDARD ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf encode ( ByteBuf src , boolean breakLines , Base64Dialect dialect ) { </a> 0
<a> if ( src == null ) { </a> 0
<a> throw new NullPointerException ( "src" ) ; </a> 0
<a> } </a> 0
<a> ByteBuf dest = encode ( src , src . readerIndex ( ) , src . readableBytes ( ) , breakLines , dialect ) ; </a> 0
<a> src . readerIndex ( src . writerIndex ( ) ) ; </a> 0
<a> return dest ; </a> 0
<a> } </a> 0
<a> public static ByteBuf encode ( ByteBuf src , int off , int len ) { </a> 0
<a> return encode ( src , off , len , Base64Dialect . STANDARD ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf encode ( ByteBuf src , int off , int len , Base64Dialect dialect ) { </a> 0
<a> return encode ( src , off , len , breakLines ( dialect ) , dialect ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf encode ( </a> 0
<a> ByteBuf src , int off , int len , boolean breakLines ) { </a> 0
<a> return encode ( src , off , len , breakLines , Base64Dialect . STANDARD ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf encode ( </a> 0
<a> ByteBuf src , int off , int len , boolean breakLines , Base64Dialect dialect ) { </a> 0
<a> if ( src == null ) { </a> 0
<a> throw new NullPointerException ( "src" ) ; </a> 0
<a> } </a> 0
<a> if ( dialect == null ) { </a> 0
<a> throw new NullPointerException ( "dialect" ) ; </a> 0
<a> } </a> 0
<a> int len43 = len * 4 / 3 ; </a> 0
<a> ByteBuf dest = src . unsafe ( ) . newBuffer ( </a> 1
<a> len43 + </a> 0
<a> ( len % 3 > 0 ? 4 : 0 ) + </a> 0
<a> ( breakLines ? len43 / MAX_LINE_LENGTH : 0 ) ) . order ( src . order ( ) ) ; </a> 0
<a> int d = 0 ; </a> 0
<a> int e = 0 ; </a> 0
<a> int len2 = len - 2 ; </a> 0
<a> int lineLength = 0 ; </a> 0
<a> for ( ; d < len2 ; d += 3 , e += 4 ) { </a> 0
<a> encode3to4 ( src , d + off , 3 , dest , e , dialect ) ; </a> 0
<a> lineLength += 4 ; </a> 0
<a> if ( breakLines && lineLength == MAX_LINE_LENGTH ) { </a> 0
<a> dest . setByte ( e + 4 , NEW_LINE ) ; </a> 0
<a> e ++ ; </a> 0
<a> lineLength = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( d < len ) { </a> 0
<a> encode3to4 ( src , d + off , len - d , dest , e , dialect ) ; </a> 0
<a> e += 4 ; </a> 0
<a> } </a> 0
<a> return dest . slice ( 0 , e ) ; </a> 0
<a> } </a> 0
<a> private static void encode3to4 ( </a> 0
<a> ByteBuf src , int srcOffset , int numSigBytes , </a> 0
<a> ByteBuf dest , int destOffset , Base64Dialect dialect ) { </a> 0
<a> byte [ ] ALPHABET = alphabet ( dialect ) ; </a> 0
<a> int inBuff = </a> 0
<a> ( numSigBytes > 0 ? src . getByte ( srcOffset ) < < 24 > > > 8 : 0 ) | </a> 0
<a> ( numSigBytes > 1 ? src . getByte ( srcOffset + 1 ) < < 24 > > > 16 : 0 ) | </a> 0
<a> ( numSigBytes > 2 ? src . getByte ( srcOffset + 2 ) < < 24 > > > 24 : 0 ) ; </a> 0
<a> switch ( numSigBytes ) { </a> 0
<a> case 3 : </a> 0
<a> dest . setByte ( destOffset , ALPHABET [ inBuff > > > 18 ] ) ; </a> 0
<a> dest . setByte ( destOffset + 1 , ALPHABET [ inBuff > > > 12 & 0x3f ] ) ; </a> 0
<a> dest . setByte ( destOffset + 2 , ALPHABET [ inBuff > > > 6 & 0x3f ] ) ; </a> 0
<a> dest . setByte ( destOffset + 3 , ALPHABET [ inBuff & 0x3f ] ) ; </a> 0
<a> break ; </a> 0
<a> case 2 : </a> 0
<a> dest . setByte ( destOffset , ALPHABET [ inBuff > > > 18 ] ) ; </a> 0
<a> dest . setByte ( destOffset + 1 , ALPHABET [ inBuff > > > 12 & 0x3f ] ) ; </a> 0
<a> dest . setByte ( destOffset + 2 , ALPHABET [ inBuff > > > 6 & 0x3f ] ) ; </a> 0
<a> dest . setByte ( destOffset + 3 , EQUALS_SIGN ) ; </a> 0
<a> break ; </a> 0
<a> case 1 : </a> 0
<a> dest . setByte ( destOffset , ALPHABET [ inBuff > > > 18 ] ) ; </a> 0
<a> dest . setByte ( destOffset + 1 , ALPHABET [ inBuff > > > 12 & 0x3f ] ) ; </a> 0
<a> dest . setByte ( destOffset + 2 , EQUALS_SIGN ) ; </a> 0
<a> dest . setByte ( destOffset + 3 , EQUALS_SIGN ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static ByteBuf decode ( ByteBuf src ) { </a> 0
<a> return decode ( src , Base64Dialect . STANDARD ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf decode ( ByteBuf src , Base64Dialect dialect ) { </a> 0
<a> if ( src == null ) { </a> 0
<a> throw new NullPointerException ( "src" ) ; </a> 0
<a> } </a> 0
<a> ByteBuf dest = decode ( src , src . readerIndex ( ) , src . readableBytes ( ) , dialect ) ; </a> 0
<a> src . readerIndex ( src . writerIndex ( ) ) ; </a> 0
<a> return dest ; </a> 0
<a> } </a> 0
<a> public static ByteBuf decode ( </a> 0
<a> ByteBuf src , int off , int len ) { </a> 0
<a> return decode ( src , off , len , Base64Dialect . STANDARD ) ; </a> 0
<a> } </a> 0
<a> public static ByteBuf decode ( </a> 0
<a> ByteBuf src , int off , int len , Base64Dialect dialect ) { </a> 0
<a> if ( src == null ) { </a> 0
<a> throw new NullPointerException ( "src" ) ; </a> 0
<a> } </a> 0
<a> if ( dialect == null ) { </a> 0
<a> throw new NullPointerException ( "dialect" ) ; </a> 0
<a> } </a> 0
<a> byte [ ] DECODABET = decodabet ( dialect ) ; </a> 0
<a> int len34 = len * 3 / 4 ; </a> 0
<a> ByteBuf dest = src . unsafe ( ) . newBuffer ( len34 ) . order ( src . order ( ) ) ; </a> 1
<a> int outBuffPosn = 0 ; </a> 0
<a> byte [ ] b4 = new byte [ 4 ] ; </a> 0
<a> int b4Posn = 0 ; </a> 0
<a> int i ; </a> 0
<a> byte sbiCrop ; </a> 0
<a> byte sbiDecode ; </a> 0
<a> for ( i = off ; i < off + len ; i ++ ) { </a> 0
<a> sbiCrop = ( byte ) ( src . getByte ( i ) & 0x7f ) ; </a> 0
<a> sbiDecode = DECODABET [ sbiCrop ] ; </a> 0
<a> if ( sbiDecode >= WHITE_SPACE_ENC ) { </a> 0
<a> if ( sbiDecode >= EQUALS_SIGN_ENC ) { </a> 0
<a> b4 [ b4Posn ++ ] = sbiCrop ; </a> 0
<a> if ( b4Posn > 3 ) { </a> 0
<a> outBuffPosn += decode4to3 ( </a> 0
<a> b4 , 0 , dest , outBuffPosn , dialect ) ; </a> 0
<a> b4Posn = 0 ; </a> 0
<a> if ( sbiCrop == EQUALS_SIGN ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "bad Base64 input character at " + i + ": " + </a> 0
<a> src . getUnsignedByte ( i ) + " (decimal)" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return dest . slice ( 0 , outBuffPosn ) ; </a> 0
<a> } </a> 0
<a> private static int decode4to3 ( </a> 0
<a> byte [ ] src , int srcOffset , </a> 0
<a> ByteBuf dest , int destOffset , Base64Dialect dialect ) { </a> 0
<a> byte [ ] DECODABET = decodabet ( dialect ) ; </a> 0
<a> if ( src [ srcOffset + 2 ] == EQUALS_SIGN ) { </a> 0
<a> int outBuff = </a> 0
<a> ( DECODABET [ src [ srcOffset ] ] & 0xFF ) < < 18 | </a> 0
<a> ( DECODABET [ src [ srcOffset + 1 ] ] & 0xFF ) < < 12 ; </a> 0
<a> dest . setByte ( destOffset , ( byte ) ( outBuff > > > 16 ) ) ; </a> 0
<a> return 1 ; </a> 0
<a> } else if ( src [ srcOffset + 3 ] == EQUALS_SIGN ) { </a> 0
<a> int outBuff = </a> 0
<a> ( DECODABET [ src [ srcOffset ] ] & 0xFF ) < < 18 | </a> 0
<a> ( DECODABET [ src [ srcOffset + 1 ] ] & 0xFF ) < < 12 | </a> 0
<a> ( DECODABET [ src [ srcOffset + 2 ] ] & 0xFF ) < < 6 ; </a> 0
<a> dest . setByte ( destOffset , ( byte ) ( outBuff > > > 16 ) ) ; </a> 0
<a> dest . setByte ( destOffset + 1 , ( byte ) ( outBuff > > > 8 ) ) ; </a> 0
<a> return 2 ; </a> 0
<a> } else { </a> 0
<a> int outBuff ; </a> 0
<a> try { </a> 0
<a> outBuff = </a> 0
<a> ( DECODABET [ src [ srcOffset ] ] & 0xFF ) < < 18 | </a> 0
<a> ( DECODABET [ src [ srcOffset + 1 ] ] & 0xFF ) < < 12 | </a> 0
<a> ( DECODABET [ src [ srcOffset + 2 ] ] & 0xFF ) < < 6 | </a> 0
<a> DECODABET [ src [ srcOffset + 3 ] ] & 0xFF ; </a> 0
<a> } catch ( IndexOutOfBoundsException e ) { </a> 1
<a> throw new IllegalArgumentException ( "not encoded in Base64" ) ; </a> 0
<a> } </a> 0
<a> dest . setByte ( destOffset , ( byte ) ( outBuff > > 16 ) ) ; </a> 0
<a> dest . setByte ( destOffset + 1 , ( byte ) ( outBuff > > 8 ) ) ; </a> 0
<a> dest . setByte ( destOffset + 2 , ( byte ) outBuff ) ; </a> 0
<a> return 3 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private Base64 ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . base64 ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . ByteToMessageDecoder ; </a> 0
<a> import io . netty . handler . codec . DelimiterBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . Delimiters ; </a> 0
<a> import io . netty . handler . codec . MessageToMessageDecoder ; </a> 0
<a> @ Sharable </a> 0
<a> public class Base64Decoder extends MessageToMessageDecoder < ByteBuf , ByteBuf > { </a> 0
<a> private final Base64Dialect dialect ; </a> 0
<a> public Base64Decoder ( ) { </a> 0
<a> this ( Base64Dialect . STANDARD ) ; </a> 0
<a> } </a> 0
<a> public Base64Decoder ( Base64Dialect dialect ) { </a> 0
<a> if ( dialect == null ) { </a> 0
<a> throw new NullPointerException ( "dialect" ) ; </a> 0
<a> } </a> 0
<a> this . dialect = dialect ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDecodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof ByteBuf ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf decode ( ChannelHandlerContext ctx , ByteBuf msg ) throws Exception { </a> 0
<a> return Base64 . decode ( msg , msg . readerIndex ( ) , msg . readableBytes ( ) , dialect ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . base64 ; </a> 0
<a> public enum Base64Dialect { </a> 0
<a> STANDARD ( new byte [ ] { </a> 0
<a> ( byte ) 'A' , ( byte ) 'B' , ( byte ) 'C' , ( byte ) 'D' , ( byte ) 'E' , </a> 0
<a> ( byte ) 'F' , ( byte ) 'G' , ( byte ) 'H' , ( byte ) 'I' , ( byte ) 'J' , </a> 0
<a> ( byte ) 'K' , ( byte ) 'L' , ( byte ) 'M' , ( byte ) 'N' , ( byte ) 'O' , </a> 0
<a> ( byte ) 'P' , ( byte ) 'Q' , ( byte ) 'R' , ( byte ) 'S' , ( byte ) 'T' , </a> 0
<a> ( byte ) 'U' , ( byte ) 'V' , ( byte ) 'W' , ( byte ) 'X' , ( byte ) 'Y' , </a> 0
<a> ( byte ) 'Z' , ( byte ) 'a' , ( byte ) 'b' , ( byte ) 'c' , ( byte ) 'd' , </a> 0
<a> ( byte ) 'e' , ( byte ) 'f' , ( byte ) 'g' , ( byte ) 'h' , ( byte ) 'i' , </a> 0
<a> ( byte ) 'j' , ( byte ) 'k' , ( byte ) 'l' , ( byte ) 'm' , ( byte ) 'n' , </a> 0
<a> ( byte ) 'o' , ( byte ) 'p' , ( byte ) 'q' , ( byte ) 'r' , ( byte ) 's' , </a> 0
<a> ( byte ) 't' , ( byte ) 'u' , ( byte ) 'v' , ( byte ) 'w' , ( byte ) 'x' , </a> 0
<a> ( byte ) 'y' , ( byte ) 'z' , ( byte ) '0' , ( byte ) '1' , ( byte ) '2' , </a> 0
<a> ( byte ) '3' , ( byte ) '4' , ( byte ) '5' , ( byte ) '6' , ( byte ) '7' , </a> 0
<a> ( byte ) '8' , ( byte ) '9' , ( byte ) '+' , ( byte ) '/' } , </a> 0
<a> new byte [ ] { </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> - 9 , - 9 , - 9 , </a> 0
<a> - 5 , - 5 , </a> 0
<a> - 9 , - 9 , </a> 0
<a> - 5 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> - 5 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> 62 , </a> 0
<a> - 9 , - 9 , - 9 , </a> 0
<a> 63 , </a> 0
<a> 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , </a> 0
<a> - 9 , - 9 , - 9 , </a> 0
<a> - 1 , </a> 0
<a> - 9 , - 9 , - 9 , </a> 0
<a> 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , </a> 0
<a> 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , </a> 0
<a> 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , </a> 0
<a> } , true ) , </a> 0
<a> URL_SAFE ( new byte [ ] { </a> 0
<a> ( byte ) 'A' , ( byte ) 'B' , ( byte ) 'C' , ( byte ) 'D' , ( byte ) 'E' , </a> 0
<a> ( byte ) 'F' , ( byte ) 'G' , ( byte ) 'H' , ( byte ) 'I' , ( byte ) 'J' , </a> 0
<a> ( byte ) 'K' , ( byte ) 'L' , ( byte ) 'M' , ( byte ) 'N' , ( byte ) 'O' , </a> 0
<a> ( byte ) 'P' , ( byte ) 'Q' , ( byte ) 'R' , ( byte ) 'S' , ( byte ) 'T' , </a> 0
<a> ( byte ) 'U' , ( byte ) 'V' , ( byte ) 'W' , ( byte ) 'X' , ( byte ) 'Y' , </a> 0
<a> ( byte ) 'Z' , ( byte ) 'a' , ( byte ) 'b' , ( byte ) 'c' , ( byte ) 'd' , </a> 0
<a> ( byte ) 'e' , ( byte ) 'f' , ( byte ) 'g' , ( byte ) 'h' , ( byte ) 'i' , </a> 0
<a> ( byte ) 'j' , ( byte ) 'k' , ( byte ) 'l' , ( byte ) 'm' , ( byte ) 'n' , </a> 0
<a> ( byte ) 'o' , ( byte ) 'p' , ( byte ) 'q' , ( byte ) 'r' , ( byte ) 's' , </a> 0
<a> ( byte ) 't' , ( byte ) 'u' , ( byte ) 'v' , ( byte ) 'w' , ( byte ) 'x' , </a> 0
<a> ( byte ) 'y' , ( byte ) 'z' , ( byte ) '0' , ( byte ) '1' , ( byte ) '2' , </a> 0
<a> ( byte ) '3' , ( byte ) '4' , ( byte ) '5' , ( byte ) '6' , ( byte ) '7' , </a> 0
<a> ( byte ) '8' , ( byte ) '9' , ( byte ) '-' , ( byte ) '_' } , </a> 0
<a> new byte [ ] { </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> - 9 , - 9 , - 9 , </a> 0
<a> - 5 , - 5 , </a> 0
<a> - 9 , - 9 , </a> 0
<a> - 5 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> - 5 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> - 9 , </a> 0
<a> - 9 , </a> 0
<a> 62 , </a> 0
<a> - 9 , </a> 0
<a> - 9 , </a> 0
<a> 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , </a> 0
<a> - 9 , - 9 , - 9 , </a> 0
<a> - 1 , </a> 0
<a> - 9 , - 9 , - 9 , </a> 0
<a> 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , </a> 0
<a> 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , </a> 0
<a> 63 , </a> 0
<a> - 9 , </a> 0
<a> 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , </a> 0
<a> 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , </a> 0
<a> } , false ) , </a> 0
<a> ORDERED ( new byte [ ] { </a> 0
<a> ( byte ) '-' , ( byte ) '0' , ( byte ) '1' , ( byte ) '2' , ( byte ) '3' , </a> 0
<a> ( byte ) '4' , ( byte ) '5' , ( byte ) '6' , ( byte ) '7' , ( byte ) '8' , </a> 0
<a> ( byte ) '9' , ( byte ) 'A' , ( byte ) 'B' , ( byte ) 'C' , ( byte ) 'D' , </a> 0
<a> ( byte ) 'E' , ( byte ) 'F' , ( byte ) 'G' , ( byte ) 'H' , ( byte ) 'I' , </a> 0
<a> ( byte ) 'J' , ( byte ) 'K' , ( byte ) 'L' , ( byte ) 'M' , ( byte ) 'N' , </a> 0
<a> ( byte ) 'O' , ( byte ) 'P' , ( byte ) 'Q' , ( byte ) 'R' , ( byte ) 'S' , </a> 0
<a> ( byte ) 'T' , ( byte ) 'U' , ( byte ) 'V' , ( byte ) 'W' , ( byte ) 'X' , </a> 0
<a> ( byte ) 'Y' , ( byte ) 'Z' , ( byte ) '_' , ( byte ) 'a' , ( byte ) 'b' , </a> 0
<a> ( byte ) 'c' , ( byte ) 'd' , ( byte ) 'e' , ( byte ) 'f' , ( byte ) 'g' , </a> 0
<a> ( byte ) 'h' , ( byte ) 'i' , ( byte ) 'j' , ( byte ) 'k' , ( byte ) 'l' , </a> 0
<a> ( byte ) 'm' , ( byte ) 'n' , ( byte ) 'o' , ( byte ) 'p' , ( byte ) 'q' , </a> 0
<a> ( byte ) 'r' , ( byte ) 's' , ( byte ) 't' , ( byte ) 'u' , ( byte ) 'v' , </a> 0
<a> ( byte ) 'w' , ( byte ) 'x' , ( byte ) 'y' , ( byte ) 'z' } , </a> 0
<a> new byte [ ] { </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> - 9 , - 9 , - 9 , </a> 0
<a> - 5 , - 5 , </a> 0
<a> - 9 , - 9 , </a> 0
<a> - 5 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> - 5 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , - 9 , </a> 0
<a> - 9 , </a> 0
<a> - 9 , </a> 0
<a> 0 , </a> 0
<a> - 9 , </a> 0
<a> - 9 , </a> 0
<a> 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , </a> 0
<a> - 9 , - 9 , - 9 , </a> 0
<a> - 1 , </a> 0
<a> - 9 , - 9 , - 9 , </a> 0
<a> 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , </a> 0
<a> 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , </a> 0
<a> 37 , </a> 0
<a> - 9 , </a> 0
<a> 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , </a> 0
<a> 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , </a> 0
<a> - 9 , - 9 , - 9 , - 9 , </a> 0
<a> } , true ) ; </a> 0
<a> final byte [ ] alphabet ; </a> 0
<a> final byte [ ] decodabet ; </a> 0
<a> final boolean breakLinesByDefault ; </a> 0
<a> Base64Dialect ( byte [ ] alphabet , byte [ ] decodabet , boolean breakLinesByDefault ) { </a> 0
<a> this . alphabet = alphabet ; </a> 0
<a> this . decodabet = decodabet ; </a> 0
<a> this . breakLinesByDefault = breakLinesByDefault ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . base64 ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . DelimiterBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . Delimiters ; </a> 0
<a> import io . netty . handler . codec . MessageToMessageEncoder ; </a> 0
<a> @ Sharable </a> 0
<a> public class Base64Encoder extends MessageToMessageEncoder < ByteBuf , ByteBuf > { </a> 0
<a> private final boolean breakLines ; </a> 0
<a> private final Base64Dialect dialect ; </a> 0
<a> public Base64Encoder ( ) { </a> 0
<a> this ( true ) ; </a> 0
<a> } </a> 0
<a> public Base64Encoder ( boolean breakLines ) { </a> 0
<a> this ( breakLines , Base64Dialect . STANDARD ) ; </a> 0
<a> } </a> 0
<a> public Base64Encoder ( boolean breakLines , Base64Dialect dialect ) { </a> 0
<a> if ( dialect == null ) { </a> 0
<a> throw new NullPointerException ( "dialect" ) ; </a> 0
<a> } </a> 0
<a> this . breakLines = breakLines ; </a> 0
<a> this . dialect = dialect ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof ByteBuf ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf encode ( ChannelHandlerContext ctx , </a> 0
<a> ByteBuf msg ) throws Exception { </a> 1
<a> return Base64 . encode ( msg , msg . readerIndex ( ) , msg . readableBytes ( ) , breakLines , dialect ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . bytes ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . LengthFieldBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . LengthFieldPrepender ; </a> 0
<a> import io . netty . handler . codec . MessageToMessageDecoder ; </a> 0
<a> public class ByteArrayDecoder extends MessageToMessageDecoder < ByteBuf , byte [ ] > { </a> 0
<a> @ Override </a> 0
<a> public boolean isDecodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof ByteBuf ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public byte [ ] decode ( ChannelHandlerContext ctx , ByteBuf msg ) throws Exception { </a> 0
<a> byte [ ] array ; </a> 0
<a> if ( msg . hasArray ( ) ) { </a> 0
<a> if ( msg . arrayOffset ( ) == 0 && msg . readableBytes ( ) == msg . capacity ( ) ) { </a> 0
<a> array = msg . array ( ) ; </a> 0
<a> } else { </a> 0
<a> array = new byte [ msg . readableBytes ( ) ] ; </a> 0
<a> msg . getBytes ( 0 , array ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> array = new byte [ msg . readableBytes ( ) ] ; </a> 0
<a> msg . getBytes ( 0 , array ) ; </a> 0
<a> } </a> 0
<a> return array ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . compression ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . util . internal . jzlib . JZlib ; </a> 0
<a> import io . netty . util . internal . jzlib . ZStream ; </a> 0
<a> public class JZlibDecoder extends ZlibDecoder { </a> 0
<a> private final ZStream z = new ZStream ( ) ; </a> 0
<a> private byte [ ] dictionary ; </a> 0
<a> private volatile boolean finished ; </a> 0
<a> public JZlibDecoder ( ) { </a> 0
<a> this ( ZlibWrapper . ZLIB ) ; </a> 0
<a> } </a> 0
<a> public JZlibDecoder ( ZlibWrapper wrapper ) { </a> 0
<a> if ( wrapper == null ) { </a> 0
<a> throw new NullPointerException ( "wrapper" ) ; </a> 0
<a> } </a> 0
<a> int resultCode = z . inflateInit ( ZlibUtil . convertWrapperType ( wrapper ) ) ; </a> 0
<a> if ( resultCode != JZlib . Z_OK ) { </a> 0
<a> ZlibUtil . fail ( z , "initialization failure" , resultCode ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public JZlibDecoder ( byte [ ] dictionary ) { </a> 0
<a> if ( dictionary == null ) { </a> 0
<a> throw new NullPointerException ( "dictionary" ) ; </a> 0
<a> } </a> 0
<a> this . dictionary = dictionary ; </a> 0
<a> int resultCode ; </a> 0
<a> resultCode = z . inflateInit ( JZlib . W_ZLIB ) ; </a> 0
<a> if ( resultCode != JZlib . Z_OK ) { </a> 0
<a> ZlibUtil . fail ( z , "initialization failure" , resultCode ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isClosed ( ) { </a> 0
<a> return finished ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void decode ( </a> 0
<a> ChannelHandlerContext ctx , </a> 0
<a> ByteBuf in , ByteBuf out ) throws Exception { </a> 0
<a> if ( ! in . readable ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> int inputLength = in . readableBytes ( ) ; </a> 0
<a> boolean inHasArray = in . hasArray ( ) ; </a> 0
<a> z . avail_in = inputLength ; </a> 0
<a> if ( inHasArray ) { </a> 0
<a> z . next_in = in . array ( ) ; </a> 0
<a> z . next_in_index = in . arrayOffset ( ) + in . readerIndex ( ) ; </a> 0
<a> } else { </a> 0
<a> byte [ ] array = new byte [ inputLength ] ; </a> 0
<a> in . readBytes ( array ) ; </a> 0
<a> z . next_in = array ; </a> 0
<a> z . next_in_index = 0 ; </a> 0
<a> } </a> 0
<a> int oldNextInIndex = z . next_in_index ; </a> 0
<a> int maxOutputLength = inputLength < < 1 ; </a> 0
<a> boolean outHasArray = out . hasArray ( ) ; </a> 0
<a> if ( ! outHasArray ) { </a> 0
<a> z . next_out = new byte [ maxOutputLength ] ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> loop : for ( ; ; ) { </a> 0
<a> z . avail_out = maxOutputLength ; </a> 0
<a> if ( outHasArray ) { </a> 0
<a> out . ensureWritableBytes ( maxOutputLength ) ; </a> 0
<a> z . next_out = out . array ( ) ; </a> 0
<a> z . next_out_index = out . arrayOffset ( ) + out . writerIndex ( ) ; </a> 0
<a> } else { </a> 0
<a> z . next_out_index = 0 ; </a> 0
<a> } </a> 0
<a> int oldNextOutIndex = z . next_out_index ; </a> 0
<a> int resultCode = z . inflate ( JZlib . Z_SYNC_FLUSH ) ; </a> 0
<a> int outputLength = z . next_out_index - oldNextOutIndex ; </a> 0
<a> if ( outputLength > 0 ) { </a> 0
<a> if ( outHasArray ) { </a> 0
<a> out . writerIndex ( out . writerIndex ( ) + outputLength ) ; </a> 0
<a> } else { </a> 0
<a> out . writeBytes ( z . next_out , 0 , outputLength ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> switch ( resultCode ) { </a> 0
<a> case JZlib . Z_NEED_DICT : </a> 0
<a> if ( dictionary == null ) { </a> 0
<a> ZlibUtil . fail ( z , "decompression failure" , resultCode ) ; </a> 0
<a> } else { </a> 0
<a> resultCode = z . inflateSetDictionary ( dictionary , dictionary . length ) ; </a> 0
<a> if ( resultCode != JZlib . Z_OK ) { </a> 0
<a> ZlibUtil . fail ( z , "failed to set the dictionary" , resultCode ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> case JZlib . Z_STREAM_END : </a> 0
<a> finished = true ; </a> 0
<a> z . inflateEnd ( ) ; </a> 0
<a> break loop ; </a> 0
<a> case JZlib . Z_OK : </a> 0
<a> break ; </a> 0
<a> case JZlib . Z_BUF_ERROR : </a> 0
<a> if ( z . avail_in <= 0 ) { </a> 0
<a> break loop ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> ZlibUtil . fail ( z , "decompression failure" , resultCode ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> if ( inHasArray ) { </a> 0
<a> in . skipBytes ( z . next_in_index - oldNextInIndex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> z . next_in = null ; </a> 0
<a> z . next_out = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . compression ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . util . internal . jzlib . JZlib ; </a> 0
<a> import io . netty . util . internal . jzlib . ZStream ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> public class JZlibEncoder extends ZlibEncoder { </a> 0
<a> private static final byte [ ] EMPTY_ARRAY = new byte [ 0 ] ; </a> 0
<a> private final ZStream z = new ZStream ( ) ; </a> 0
<a> private final AtomicBoolean finished = new AtomicBoolean ( ) ; </a> 0
<a> private volatile ChannelHandlerContext ctx ; </a> 0
<a> public JZlibEncoder ( ) { </a> 0
<a> this ( 6 ) ; </a> 0
<a> } </a> 0
<a> public JZlibEncoder ( int compressionLevel ) { </a> 0
<a> this ( ZlibWrapper . ZLIB , compressionLevel ) ; </a> 0
<a> } </a> 0
<a> public JZlibEncoder ( ZlibWrapper wrapper ) { </a> 0
<a> this ( wrapper , 6 ) ; </a> 0
<a> } </a> 0
<a> public JZlibEncoder ( ZlibWrapper wrapper , int compressionLevel ) { </a> 0
<a> this ( wrapper , compressionLevel , 15 , 8 ) ; </a> 0
<a> } </a> 0
<a> public JZlibEncoder ( ZlibWrapper wrapper , int compressionLevel , int windowBits , int memLevel ) { </a> 0
<a> if ( compressionLevel < 0 || compressionLevel > 9 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "compressionLevel: " + compressionLevel + </a> 0
<a> " (expected: 0-9)" ) ; </a> 0
<a> } </a> 0
<a> if ( windowBits < 9 || windowBits > 15 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "windowBits: " + windowBits + " (expected: 9-15)" ) ; </a> 0
<a> } </a> 0
<a> if ( memLevel < 1 || memLevel > 9 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "memLevel: " + memLevel + " (expected: 1-9)" ) ; </a> 0
<a> } </a> 0
<a> if ( wrapper == null ) { </a> 0
<a> throw new NullPointerException ( "wrapper" ) ; </a> 0
<a> } </a> 0
<a> if ( wrapper == ZlibWrapper . ZLIB_OR_NONE ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "wrapper '" + ZlibWrapper . ZLIB_OR_NONE + "' is not " + </a> 0
<a> "allowed for compression." ) ; </a> 0
<a> } </a> 0
<a> synchronized ( z ) { </a> 0
<a> int resultCode = z . deflateInit ( </a> 0
<a> compressionLevel , windowBits , memLevel , </a> 0
<a> ZlibUtil . convertWrapperType ( wrapper ) ) ; </a> 0
<a> if ( resultCode != JZlib . Z_OK ) { </a> 0
<a> ZlibUtil . fail ( z , "initialization failure" , resultCode ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public JZlibEncoder ( byte [ ] dictionary ) { </a> 0
<a> this ( 6 , dictionary ) ; </a> 0
<a> } </a> 0
<a> public JZlibEncoder ( int compressionLevel , byte [ ] dictionary ) { </a> 0
<a> this ( compressionLevel , 15 , 8 , dictionary ) ; </a> 0
<a> } </a> 0
<a> public JZlibEncoder ( int compressionLevel , int windowBits , int memLevel , byte [ ] dictionary ) { </a> 0
<a> if ( compressionLevel < 0 || compressionLevel > 9 ) { </a> 0
<a> throw new IllegalArgumentException ( "compressionLevel: " + compressionLevel + " (expected: 0-9)" ) ; </a> 0
<a> } </a> 0
<a> if ( windowBits < 9 || windowBits > 15 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "windowBits: " + windowBits + " (expected: 9-15)" ) ; </a> 0
<a> } </a> 0
<a> if ( memLevel < 1 || memLevel > 9 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "memLevel: " + memLevel + " (expected: 1-9)" ) ; </a> 0
<a> } </a> 0
<a> if ( dictionary == null ) { </a> 0
<a> throw new NullPointerException ( "dictionary" ) ; </a> 0
<a> } </a> 0
<a> synchronized ( z ) { </a> 0
<a> int resultCode ; </a> 0
<a> resultCode = z . deflateInit ( </a> 0
<a> compressionLevel , windowBits , memLevel , </a> 0
<a> JZlib . W_ZLIB ) ; </a> 0
<a> if ( resultCode != JZlib . Z_OK ) { </a> 0
<a> ZlibUtil . fail ( z , "initialization failure" , resultCode ) ; </a> 0
<a> } else { </a> 0
<a> resultCode = z . deflateSetDictionary ( dictionary , dictionary . length ) ; </a> 0
<a> if ( resultCode != JZlib . Z_OK ) { </a> 0
<a> ZlibUtil . fail ( z , "failed to set the dictionary" , resultCode ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture close ( ) { </a> 0
<a> return close ( ctx ( ) . channel ( ) . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture close ( ChannelFuture future ) { </a> 0
<a> return finishEncode ( ctx ( ) , future ) ; </a> 0
<a> } </a> 0
<a> private ChannelHandlerContext ctx ( ) { </a> 0
<a> ChannelHandlerContext ctx = this . ctx ; </a> 0
<a> if ( ctx == null ) { </a> 0
<a> throw new IllegalStateException ( "not added to a pipeline" ) ; </a> 0
<a> } </a> 0
<a> return ctx ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isClosed ( ) { </a> 0
<a> return finished . get ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( ChannelHandlerContext ctx , </a> 0
<a> ByteBuf in , ByteBuf out ) throws Exception { </a> 0
<a> if ( finished . get ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> synchronized ( z ) { </a> 0
<a> try { </a> 0
<a> int inputLength = in . readableBytes ( ) ; </a> 0
<a> boolean inHasArray = in . hasArray ( ) ; </a> 0
<a> z . avail_in = inputLength ; </a> 0
<a> if ( inHasArray ) { </a> 0
<a> z . next_in = in . array ( ) ; </a> 0
<a> z . next_in_index = in . arrayOffset ( ) + in . readerIndex ( ) ; </a> 0
<a> } else { </a> 0
<a> byte [ ] array = new byte [ inputLength ] ; </a> 0
<a> in . readBytes ( array ) ; </a> 0
<a> z . next_in = array ; </a> 0
<a> z . next_in_index = 0 ; </a> 0
<a> } </a> 0
<a> int oldNextInIndex = z . next_in_index ; </a> 0
<a> int maxOutputLength = ( int ) Math . ceil ( inputLength * 1.001 ) + 12 ; </a> 0
<a> boolean outHasArray = out . hasArray ( ) ; </a> 0
<a> z . avail_out = maxOutputLength ; </a> 0
<a> if ( outHasArray ) { </a> 0
<a> out . ensureWritableBytes ( maxOutputLength ) ; </a> 0
<a> z . next_out = out . array ( ) ; </a> 0
<a> z . next_out_index = out . arrayOffset ( ) + out . writerIndex ( ) ; </a> 0
<a> } else { </a> 0
<a> z . next_out = new byte [ maxOutputLength ] ; </a> 0
<a> z . next_out_index = 0 ; </a> 0
<a> } </a> 0
<a> int oldNextOutIndex = z . next_out_index ; </a> 0
<a> int resultCode ; </a> 0
<a> try { </a> 0
<a> resultCode = z . deflate ( JZlib . Z_SYNC_FLUSH ) ; </a> 0
<a> } finally { </a> 0
<a> if ( inHasArray ) { </a> 0
<a> in . skipBytes ( z . next_in_index - oldNextInIndex ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( resultCode != JZlib . Z_OK ) { </a> 0
<a> ZlibUtil . fail ( z , "compression failure" , resultCode ) ; </a> 0
<a> } </a> 0
<a> int outputLength = z . next_out_index - oldNextOutIndex ; </a> 0
<a> if ( outputLength > 0 ) { </a> 0
<a> if ( outHasArray ) { </a> 0
<a> out . writerIndex ( out . writerIndex ( ) + outputLength ) ; </a> 0
<a> } else { </a> 0
<a> out . writeBytes ( z . next_out , 0 , outputLength ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> z . next_in = null ; </a> 0
<a> z . next_out = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( </a> 0
<a> final ChannelHandlerContext ctx , </a> 0
<a> final ChannelFuture future ) throws Exception { </a> 0
<a> ChannelFuture f = finishEncode ( ctx , ctx . newFuture ( ) ) ; </a> 0
<a> f . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture f ) throws Exception { </a> 0
<a> ctx . close ( future ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> if ( ! f . isDone ( ) ) { </a> 0
<a> ctx . executor ( ) . schedule ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> ctx . close ( future ) ; </a> 0
<a> } </a> 0
<a> } , 10 , TimeUnit . SECONDS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private ChannelFuture finishEncode ( ChannelHandlerContext ctx , ChannelFuture future ) { </a> 0
<a> if ( ! finished . compareAndSet ( false , true ) ) { </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> ByteBuf footer ; </a> 0
<a> synchronized ( z ) { </a> 0
<a> try { </a> 0
<a> z . next_in = EMPTY_ARRAY ; </a> 0
<a> z . next_in_index = 0 ; </a> 0
<a> z . avail_in = 0 ; </a> 0
<a> byte [ ] out = new byte [ 32 ] ; </a> 0
<a> z . next_out = out ; </a> 0
<a> z . next_out_index = 0 ; </a> 0
<a> z . avail_out = out . length ; </a> 0
<a> int resultCode = z . deflate ( JZlib . Z_FINISH ) ; </a> 0
<a> if ( resultCode != JZlib . Z_OK && resultCode != JZlib . Z_STREAM_END ) { </a> 0
<a> future . setFailure ( ZlibUtil . exception ( z , "compression failure" , resultCode ) ) ; </a> 0
<a> return future ; </a> 0
<a> } else if ( z . next_out_index != 0 ) { </a> 0
<a> footer = Unpooled . wrappedBuffer ( out , 0 , z . next_out_index ) ; </a> 0
<a> } else { </a> 0
<a> footer = Unpooled . EMPTY_BUFFER ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> z . deflateEnd ( ) ; </a> 0
<a> z . next_in = null ; </a> 0
<a> z . next_out = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> ctx . write ( footer , future ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> this . ctx = ctx ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . compression ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> import java . util . zip . CRC32 ; </a> 0
<a> import java . util . zip . Deflater ; </a> 0
<a> public class JdkZlibEncoder extends ZlibEncoder { </a> 0
<a> private final byte [ ] encodeBuf = new byte [ 8192 ] ; </a> 0
<a> private final Deflater deflater ; </a> 0
<a> private final AtomicBoolean finished = new AtomicBoolean ( ) ; </a> 0
<a> private volatile ChannelHandlerContext ctx ; </a> 0
<a> private final boolean gzip ; </a> 0
<a> private final CRC32 crc = new CRC32 ( ) ; </a> 0
<a> private static final byte [ ] gzipHeader = { 0x1f , ( byte ) 0x8b , Deflater . DEFLATED , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; </a> 0
<a> private boolean writeHeader = true ; </a> 0
<a> public JdkZlibEncoder ( ) { </a> 0
<a> this ( 6 ) ; </a> 0
<a> } </a> 0
<a> public JdkZlibEncoder ( int compressionLevel ) { </a> 0
<a> this ( ZlibWrapper . ZLIB , compressionLevel ) ; </a> 0
<a> } </a> 0
<a> public JdkZlibEncoder ( ZlibWrapper wrapper ) { </a> 0
<a> this ( wrapper , 6 ) ; </a> 0
<a> } </a> 0
<a> public JdkZlibEncoder ( ZlibWrapper wrapper , int compressionLevel ) { </a> 0
<a> if ( compressionLevel < 0 || compressionLevel > 9 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "compressionLevel: " + compressionLevel + " (expected: 0-9)" ) ; </a> 0
<a> } </a> 0
<a> if ( wrapper == null ) { </a> 0
<a> throw new NullPointerException ( "wrapper" ) ; </a> 0
<a> } </a> 0
<a> if ( wrapper == ZlibWrapper . ZLIB_OR_NONE ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "wrapper '" + ZlibWrapper . ZLIB_OR_NONE + "' is not " + </a> 0
<a> "allowed for compression." ) ; </a> 0
<a> } </a> 0
<a> gzip = wrapper == ZlibWrapper . GZIP ; </a> 0
<a> deflater = new Deflater ( compressionLevel , wrapper != ZlibWrapper . ZLIB ) ; </a> 0
<a> } </a> 0
<a> public JdkZlibEncoder ( byte [ ] dictionary ) { </a> 0
<a> this ( 6 , dictionary ) ; </a> 0
<a> } </a> 0
<a> public JdkZlibEncoder ( int compressionLevel , byte [ ] dictionary ) { </a> 0
<a> if ( compressionLevel < 0 || compressionLevel > 9 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "compressionLevel: " + compressionLevel + " (expected: 0-9)" ) ; </a> 0
<a> } </a> 0
<a> if ( dictionary == null ) { </a> 0
<a> throw new NullPointerException ( "dictionary" ) ; </a> 0
<a> } </a> 0
<a> gzip = false ; </a> 0
<a> deflater = new Deflater ( compressionLevel ) ; </a> 0
<a> deflater . setDictionary ( dictionary ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture close ( ) { </a> 0
<a> return close ( ctx ( ) . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture close ( ChannelFuture future ) { </a> 0
<a> return finishEncode ( ctx ( ) , future ) ; </a> 0
<a> } </a> 0
<a> private ChannelHandlerContext ctx ( ) { </a> 0
<a> ChannelHandlerContext ctx = this . ctx ; </a> 0
<a> if ( ctx == null ) { </a> 0
<a> throw new IllegalStateException ( "not added to a pipeline" ) ; </a> 0
<a> } </a> 0
<a> return ctx ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isClosed ( ) { </a> 0
<a> return finished . get ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( ChannelHandlerContext ctx , ByteBuf in , ByteBuf out ) throws Exception { </a> 0
<a> if ( finished . get ( ) ) { </a> 0
<a> out . writeBytes ( in ) ; </a> 0
<a> in . discardReadBytes ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> ByteBuf uncompressed = in ; </a> 0
<a> byte [ ] inAry = new byte [ uncompressed . readableBytes ( ) ] ; </a> 0
<a> uncompressed . readBytes ( inAry ) ; </a> 0
<a> int sizeEstimate = ( int ) Math . ceil ( inAry . length * 1.001 ) + 12 ; </a> 0
<a> out . ensureWritableBytes ( sizeEstimate ) ; </a> 0
<a> synchronized ( deflater ) { </a> 0
<a> if ( gzip ) { </a> 0
<a> crc . update ( inAry ) ; </a> 0
<a> if ( writeHeader ) { </a> 0
<a> out . writeBytes ( gzipHeader ) ; </a> 0
<a> writeHeader = false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> deflater . setInput ( inAry ) ; </a> 0
<a> while ( ! deflater . needsInput ( ) ) { </a> 0
<a> int numBytes = deflater . deflate ( encodeBuf , 0 , encodeBuf . length , Deflater . SYNC_FLUSH ) ; </a> 0
<a> out . writeBytes ( encodeBuf , 0 , numBytes ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( final ChannelHandlerContext ctx , final ChannelFuture future ) throws Exception { </a> 0
<a> ChannelFuture f = finishEncode ( ctx , ctx . newFuture ( ) ) ; </a> 0
<a> f . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture f ) throws Exception { </a> 0
<a> ctx . close ( future ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> if ( ! f . isDone ( ) ) { </a> 0
<a> ctx . executor ( ) . schedule ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> ctx . close ( future ) ; </a> 0
<a> } </a> 0
<a> } , 10 , TimeUnit . SECONDS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private ChannelFuture finishEncode ( final ChannelHandlerContext ctx , ChannelFuture future ) { </a> 0
<a> if ( ! finished . compareAndSet ( false , true ) ) { </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> ByteBuf footer = Unpooled . buffer ( ) ; </a> 0
<a> synchronized ( deflater ) { </a> 0
<a> deflater . finish ( ) ; </a> 0
<a> while ( ! deflater . finished ( ) ) { </a> 0
<a> int numBytes = deflater . deflate ( encodeBuf , 0 , encodeBuf . length ) ; </a> 1
<a> footer . writeBytes ( encodeBuf , 0 , numBytes ) ; </a> 0
<a> } </a> 0
<a> if ( gzip ) { </a> 0
<a> int crcValue = ( int ) crc . getValue ( ) ; </a> 0
<a> int uncBytes = deflater . getTotalIn ( ) ; </a> 0
<a> footer . writeByte ( crcValue ) ; </a> 0
<a> footer . writeByte ( crcValue > > > 8 ) ; </a> 0
<a> footer . writeByte ( crcValue > > > 16 ) ; </a> 0
<a> footer . writeByte ( crcValue > > > 24 ) ; </a> 0
<a> footer . writeByte ( uncBytes ) ; </a> 0
<a> footer . writeByte ( uncBytes > > > 8 ) ; </a> 0
<a> footer . writeByte ( uncBytes > > > 16 ) ; </a> 0
<a> footer . writeByte ( uncBytes > > > 24 ) ; </a> 0
<a> } </a> 0
<a> deflater . end ( ) ; </a> 0
<a> } </a> 0
<a> ctx . nextOutboundByteBuffer ( ) . writeBytes ( footer ) ; </a> 0
<a> ctx . flush ( future ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> this . ctx = ctx ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . compression ; </a> 0
<a> import io . netty . util . internal . DetectionUtil ; </a> 0
<a> public final class ZlibCodecFactory { </a> 0
<a> public static ZlibEncoder newZlibEncoder ( int compressionLevel ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 0
<a> return new JZlibEncoder ( compressionLevel ) ; </a> 0
<a> } else { </a> 0
<a> return new JdkZlibEncoder ( compressionLevel ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static ZlibEncoder newZlibEncoder ( ZlibWrapper wrapper ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 0
<a> return new JZlibEncoder ( wrapper ) ; </a> 0
<a> } else { </a> 0
<a> return new JdkZlibEncoder ( wrapper ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static ZlibEncoder newZlibEncoder ( ZlibWrapper wrapper , int compressionLevel ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 0
<a> return new JZlibEncoder ( wrapper , compressionLevel ) ; </a> 0
<a> } else { </a> 0
<a> return new JdkZlibEncoder ( wrapper , compressionLevel ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static ZlibEncoder newZlibEncoder ( ZlibWrapper wrapper , int compressionLevel , int windowBits , int memLevel ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 0
<a> return new JZlibEncoder ( wrapper , compressionLevel , windowBits , memLevel ) ; </a> 0
<a> } else { </a> 0
<a> return new JdkZlibEncoder ( wrapper , compressionLevel ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static ZlibEncoder newZlibEncoder ( byte [ ] dictionary ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 0
<a> return new JZlibEncoder ( dictionary ) ; </a> 0
<a> } else { </a> 0
<a> return new JdkZlibEncoder ( dictionary ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static ZlibEncoder newZlibEncoder ( int compressionLevel , byte [ ] dictionary ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 0
<a> return new JZlibEncoder ( compressionLevel , dictionary ) ; </a> 0
<a> } else { </a> 0
<a> return new JdkZlibEncoder ( compressionLevel , dictionary ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static ZlibEncoder newZlibEncoder ( int compressionLevel , int windowBits , int memLevel , byte [ ] dictionary ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 0
<a> return new JZlibEncoder ( compressionLevel , windowBits , memLevel , dictionary ) ; </a> 0
<a> } else { </a> 0
<a> return new JdkZlibEncoder ( compressionLevel , dictionary ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static ZlibDecoder newZlibDecoder ( ) { </a> 0
<a> return new JZlibDecoder ( ) ; </a> 0
<a> } </a> 0
<a> public static ZlibDecoder newZlibDecoder ( ZlibWrapper wrapper ) { </a> 0
<a> return new JZlibDecoder ( wrapper ) ; </a> 0
<a> } </a> 0
<a> public static ZlibDecoder newZlibDecoder ( byte [ ] dictionary ) { </a> 0
<a> return new JZlibDecoder ( dictionary ) ; </a> 0
<a> } </a> 0
<a> private ZlibCodecFactory ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . compression ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . handler . codec . ByteToByteDecoder ; </a> 1
<a> public abstract class ZlibDecoder extends ByteToByteDecoder { </a> 0
<a> public abstract boolean isClosed ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . compression ; </a> 0
<a> import io . netty . util . internal . jzlib . JZlib ; </a> 0
<a> import io . netty . util . internal . jzlib . ZStream ; </a> 0
<a> final class ZlibUtil { </a> 0
<a> static void fail ( ZStream z , String message , int resultCode ) { </a> 1
<a> throw exception ( z , message , resultCode ) ; </a> 1
<a> } </a> 0
<a> static CompressionException exception ( ZStream z , String message , int resultCode ) { </a> 1
<a> return new CompressionException ( message + " (" + resultCode + ")" + </a> 0
<a> ( z . msg != null ? ": " + z . msg : "" ) ) ; </a> 1
<a> } </a> 0
<a> static Enum < ? > convertWrapperType ( ZlibWrapper wrapper ) { </a> 0
<a> Enum < ? > convertedWrapperType ; </a> 0
<a> switch ( wrapper ) { </a> 0
<a> case NONE : </a> 0
<a> convertedWrapperType = JZlib . W_NONE ; </a> 0
<a> break ; </a> 0
<a> case ZLIB : </a> 0
<a> convertedWrapperType = JZlib . W_ZLIB ; </a> 0
<a> break ; </a> 0
<a> case GZIP : </a> 0
<a> convertedWrapperType = JZlib . W_GZIP ; </a> 0
<a> break ; </a> 0
<a> case ZLIB_OR_NONE : </a> 0
<a> convertedWrapperType = JZlib . W_ZLIB_OR_NONE ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> return convertedWrapperType ; </a> 0
<a> } </a> 0
<a> private ZlibUtil ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . compression ; </a> 0
<a> public enum ZlibWrapper { </a> 0
<a> ZLIB , </a> 0
<a> GZIP , </a> 0
<a> NONE , </a> 0
<a> ZLIB_OR_NONE </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . compression ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import org . jboss . marshalling . ByteInput ; </a> 0
<a> class ChannelBufferByteInput implements ByteInput { </a> 0
<a> private final ByteBuf buffer ; </a> 0
<a> public ChannelBufferByteInput ( ByteBuf buffer ) { </a> 1
<a> this . buffer = buffer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws IOException { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int available ( ) throws IOException { </a> 0
<a> return buffer . readableBytes ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int read ( ) throws IOException { </a> 0
<a> if ( buffer . readable ( ) ) { </a> 0
<a> return buffer . readByte ( ) & 0xff ; </a> 0
<a> } </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int read ( byte [ ] array ) throws IOException { </a> 0
<a> return read ( array , 0 , array . length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int read ( byte [ ] dst , int dstIndex , int length ) throws IOException { </a> 0
<a> int available = available ( ) ; </a> 0
<a> if ( available == 0 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> length = Math . min ( available , length ) ; </a> 0
<a> buffer . readBytes ( dst , dstIndex , length ) ; </a> 0
<a> return length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long skip ( long bytes ) throws IOException { </a> 0
<a> int readable = buffer . readableBytes ( ) ; </a> 0
<a> if ( readable < bytes ) { </a> 0
<a> bytes = readable ; </a> 0
<a> } </a> 0
<a> buffer . readerIndex ( ( int ) ( buffer . readerIndex ( ) + bytes ) ) ; </a> 0
<a> return bytes ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import org . jboss . marshalling . ByteOutput ; </a> 1
<a> class ChannelBufferByteOutput implements ByteOutput { </a> 0
<a> private final ByteBuf buffer ; </a> 0
<a> public ChannelBufferByteOutput ( ByteBuf buffer ) { </a> 1
<a> this . buffer = buffer ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws IOException { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( ) throws IOException { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( int b ) throws IOException { </a> 0
<a> buffer . writeByte ( b ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( byte [ ] bytes ) throws IOException { </a> 0
<a> buffer . writeBytes ( bytes ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( byte [ ] bytes , int srcIndex , int length ) throws IOException { </a> 0
<a> buffer . writeBytes ( bytes , srcIndex , length ) ; </a> 0
<a> } </a> 0
<a> public ByteBuf getBuffer ( ) { </a> 0
<a> return buffer ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . ReplayingDecoder ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import java . io . ObjectStreamConstants ; </a> 0
<a> import org . jboss . marshalling . ByteInput ; </a> 0
<a> import org . jboss . marshalling . Unmarshaller ; </a> 1
<a> public class CompatibleMarshallingDecoder extends ReplayingDecoder < Object , Void > { </a> 0
<a> protected final UnmarshallerProvider provider ; </a> 0
<a> protected final int maxObjectSize ; </a> 0
<a> public CompatibleMarshallingDecoder ( UnmarshallerProvider provider , int maxObjectSize ) { </a> 0
<a> this . provider = provider ; </a> 0
<a> this . maxObjectSize = maxObjectSize ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decode ( ChannelHandlerContext ctx , ByteBuf buffer ) throws Exception { </a> 0
<a> Unmarshaller unmarshaller = provider . getUnmarshaller ( ctx ) ; </a> 0
<a> ByteInput input = new ChannelBufferByteInput ( buffer ) ; </a> 0
<a> if ( maxObjectSize != Integer . MAX_VALUE ) { </a> 0
<a> input = new LimitingByteInput ( input , maxObjectSize ) ; </a> 0
<a> } </a> 1
<a> try { </a> 0
<a> unmarshaller . start ( input ) ; </a> 0
<a> Object obj = unmarshaller . readObject ( ) ; </a> 0
<a> unmarshaller . finish ( ) ; </a> 0
<a> return obj ; </a> 1
<a> } catch ( LimitingByteInput . TooBigObjectException e ) { </a> 1
<a> throw new TooLongFrameException ( "Object to big to unmarshal" ) ; </a> 0
<a> } finally { </a> 0
<a> unmarshaller . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decodeLast ( ChannelHandlerContext ctx , ByteBuf buffer ) throws Exception { </a> 0
<a> switch ( buffer . readableBytes ( ) ) { </a> 0
<a> case 0 : </a> 0
<a> return null ; </a> 1
<a> case 1 : </a> 0
<a> if ( buffer . getByte ( buffer . readerIndex ( ) ) == ObjectStreamConstants . TC_RESET ) { </a> 0
<a> buffer . skipBytes ( 1 ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> return decode ( ctx , buffer ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> if ( cause instanceof TooLongFrameException ) { </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } else { </a> 0
<a> super . exceptionCaught ( ctx , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . MessageToByteEncoder ; </a> 0
<a> import org . jboss . marshalling . Marshaller ; </a> 0
<a> @ Sharable </a> 0
<a> public class CompatibleMarshallingEncoder extends MessageToByteEncoder < Object > { </a> 0
<a> private final MarshallerProvider provider ; </a> 0
<a> public CompatibleMarshallingEncoder ( MarshallerProvider provider ) { </a> 0
<a> this . provider = provider ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( ChannelHandlerContext ctx , Object msg , ByteBuf out ) throws Exception { </a> 0
<a> Marshaller marshaller = provider . getMarshaller ( ctx ) ; </a> 0
<a> marshaller . start ( new ChannelBufferByteOutput ( out ) ) ; </a> 0
<a> marshaller . writeObject ( msg ) ; </a> 0
<a> marshaller . finish ( ) ; </a> 0
<a> marshaller . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . util . Attribute ; </a> 0
<a> import io . netty . util . AttributeKey ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> import org . jboss . marshalling . Unmarshaller ; </a> 0
<a> public class ContextBoundUnmarshallerProvider extends DefaultUnmarshallerProvider { </a> 0
<a> private static final AttributeKey < Unmarshaller > UNMARSHALLER = new AttributeKey < Unmarshaller > ( </a> 1
<a> ContextBoundUnmarshallerProvider . class . getName ( ) + ".unmarshaller" ) ; </a> 0
<a> public ContextBoundUnmarshallerProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> super ( factory , config ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Unmarshaller getUnmarshaller ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> Attribute < Unmarshaller > attr = ctx . attr ( UNMARSHALLER ) ; </a> 0
<a> Unmarshaller unmarshaller = attr . get ( ) ; </a> 0
<a> if ( unmarshaller == null ) { </a> 0
<a> unmarshaller = super . getUnmarshaller ( ctx ) ; </a> 0
<a> attr . set ( unmarshaller ) ; </a> 0
<a> } </a> 0
<a> return unmarshaller ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> import org . jboss . marshalling . Unmarshaller ; </a> 0
<a> public class DefaultUnmarshallerProvider implements UnmarshallerProvider { </a> 0
<a> private final MarshallerFactory factory ; </a> 0
<a> private final MarshallingConfiguration config ; </a> 0
<a> public DefaultUnmarshallerProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> this . factory = factory ; </a> 0
<a> this . config = config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Unmarshaller getUnmarshaller ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return factory . createUnmarshaller ( config ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import org . jboss . marshalling . ByteInput ; </a> 1
<a> class LimitingByteInput implements ByteInput { </a> 0
<a> private static final TooBigObjectException EXCEPTION = new TooBigObjectException ( ) ; </a> 0
<a> private final ByteInput input ; </a> 0
<a> private final long limit ; </a> 0
<a> private long read ; </a> 0
<a> public LimitingByteInput ( ByteInput input , long limit ) { </a> 1
<a> if ( limit <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "The limit MUST be > 0" ) ; </a> 0
<a> } </a> 0
<a> this . input = input ; </a> 0
<a> this . limit = limit ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws IOException { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int available ( ) throws IOException { </a> 0
<a> return readable ( input . available ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int read ( ) throws IOException { </a> 0
<a> int readable = readable ( 1 ) ; </a> 0
<a> if ( readable > 0 ) { </a> 0
<a> int b = input . read ( ) ; </a> 0
<a> read ++ ; </a> 0
<a> return b ; </a> 0
<a> } else { </a> 0
<a> throw EXCEPTION ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int read ( byte [ ] array ) throws IOException { </a> 0
<a> return read ( array , 0 , array . length ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int read ( byte [ ] array , int offset , int length ) throws IOException { </a> 0
<a> int readable = readable ( length ) ; </a> 0
<a> if ( readable > 0 ) { </a> 0
<a> int i = input . read ( array , offset , readable ) ; </a> 0
<a> read += i ; </a> 0
<a> return i ; </a> 0
<a> } else { </a> 0
<a> throw EXCEPTION ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long skip ( long bytes ) throws IOException { </a> 0
<a> int readable = readable ( ( int ) bytes ) ; </a> 0
<a> if ( readable > 0 ) { </a> 0
<a> long i = input . skip ( readable ) ; </a> 0
<a> read += i ; </a> 0
<a> return i ; </a> 0
<a> } else { </a> 0
<a> throw EXCEPTION ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private int readable ( int length ) { </a> 0
<a> return ( int ) Math . min ( length , limit - read ) ; </a> 0
<a> } </a> 0
<a> static final class TooBigObjectException extends IOException { </a> 0
<a> private static final long serialVersionUID = 1L ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import org . jboss . marshalling . Marshaller ; </a> 0
<a> public interface MarshallerProvider { </a> 0
<a> Marshaller getMarshaller ( ChannelHandlerContext ctx ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . MessageToByteEncoder ; </a> 0
<a> import org . jboss . marshalling . Marshaller ; </a> 0
<a> @ Sharable </a> 0
<a> public class MarshallingEncoder extends MessageToByteEncoder < Object > { </a> 0
<a> private static final byte [ ] LENGTH_PLACEHOLDER = new byte [ 4 ] ; </a> 0
<a> private final MarshallerProvider provider ; </a> 0
<a> public MarshallingEncoder ( MarshallerProvider provider ) { </a> 0
<a> this . provider = provider ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( ChannelHandlerContext ctx , Object msg , ByteBuf out ) throws Exception { </a> 0
<a> Marshaller marshaller = provider . getMarshaller ( ctx ) ; </a> 0
<a> int lengthPos = out . writerIndex ( ) ; </a> 0
<a> out . writeBytes ( LENGTH_PLACEHOLDER ) ; </a> 0
<a> ChannelBufferByteOutput output = new ChannelBufferByteOutput ( out ) ; </a> 0
<a> marshaller . start ( output ) ; </a> 0
<a> marshaller . writeObject ( msg ) ; </a> 0
<a> marshaller . finish ( ) ; </a> 0
<a> marshaller . close ( ) ; </a> 0
<a> out . setInt ( lengthPos , out . writerIndex ( ) - lengthPos - 4 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> import org . jboss . marshalling . Unmarshaller ; </a> 0
<a> public class ThreadLocalUnmarshallerProvider implements UnmarshallerProvider { </a> 0
<a> private final ThreadLocal < Unmarshaller > unmarshallers = new ThreadLocal < Unmarshaller > ( ) ; </a> 1
<a> private final MarshallerFactory factory ; </a> 0
<a> private final MarshallingConfiguration config ; </a> 0
<a> public ThreadLocalUnmarshallerProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> this . factory = factory ; </a> 0
<a> this . config = config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Unmarshaller getUnmarshaller ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> Unmarshaller unmarshaller = unmarshallers . get ( ) ; </a> 0
<a> if ( unmarshaller == null ) { </a> 0
<a> unmarshaller = factory . createUnmarshaller ( config ) ; </a> 0
<a> unmarshallers . set ( unmarshaller ) ; </a> 0
<a> } </a> 0
<a> return unmarshaller ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import org . jboss . marshalling . Unmarshaller ; </a> 0
<a> public interface UnmarshallerProvider { </a> 0
<a> Unmarshaller getUnmarshaller ( ChannelHandlerContext ctx ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . protobuf ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ByteBufInputStream ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . LengthFieldBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . LengthFieldPrepender ; </a> 0
<a> import io . netty . handler . codec . MessageToMessageDecoder ; </a> 0
<a> import com . google . protobuf . ExtensionRegistry ; </a> 0
<a> import com . google . protobuf . Message ; </a> 0
<a> import com . google . protobuf . MessageLite ; </a> 0
<a> @ Sharable </a> 0
<a> public class ProtobufDecoder extends MessageToMessageDecoder < ByteBuf , MessageLite > { </a> 0
<a> private final MessageLite prototype ; </a> 0
<a> private final ExtensionRegistry extensionRegistry ; </a> 0
<a> public ProtobufDecoder ( MessageLite prototype ) { </a> 0
<a> this ( prototype , null ) ; </a> 0
<a> } </a> 0
<a> public ProtobufDecoder ( MessageLite prototype , ExtensionRegistry extensionRegistry ) { </a> 0
<a> if ( prototype == null ) { </a> 0
<a> throw new NullPointerException ( "prototype" ) ; </a> 0
<a> } </a> 0
<a> this . prototype = prototype . getDefaultInstanceForType ( ) ; </a> 0
<a> this . extensionRegistry = extensionRegistry ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDecodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof ByteBuf ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public MessageLite decode ( ChannelHandlerContext ctx , ByteBuf msg ) throws Exception { </a> 0
<a> if ( msg . hasArray ( ) ) { </a> 0
<a> final int offset = msg . readerIndex ( ) ; </a> 0
<a> if ( extensionRegistry == null ) { </a> 0
<a> return prototype . newBuilderForType ( ) . mergeFrom ( </a> 0
<a> msg . array ( ) , msg . arrayOffset ( ) + offset , msg . readableBytes ( ) ) . build ( ) ; </a> 0
<a> } else { </a> 0
<a> return prototype . newBuilderForType ( ) . mergeFrom ( </a> 0
<a> msg . array ( ) , msg . arrayOffset ( ) + offset , msg . readableBytes ( ) , extensionRegistry ) . build ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( extensionRegistry == null ) { </a> 0
<a> return prototype . newBuilderForType ( ) . mergeFrom ( </a> 0
<a> new ByteBufInputStream ( msg ) ) . build ( ) ; </a> 0
<a> } else { </a> 0
<a> return prototype . newBuilderForType ( ) . mergeFrom ( </a> 0
<a> new ByteBufInputStream ( msg ) , extensionRegistry ) . build ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . protobuf ; </a> 0
<a> import static io . netty . buffer . Unpooled . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . LengthFieldBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . LengthFieldPrepender ; </a> 0
<a> import io . netty . handler . codec . MessageToMessageEncoder ; </a> 0
<a> import com . google . protobuf . Message ; </a> 0
<a> import com . google . protobuf . MessageLite ; </a> 0
<a> @ Sharable </a> 0
<a> public class ProtobufEncoder extends MessageToMessageEncoder < Object , ByteBuf > { </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof MessageLite || msg instanceof MessageLite . Builder ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf encode ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 0
<a> if ( msg instanceof MessageLite ) { </a> 0
<a> return wrappedBuffer ( ( ( MessageLite ) msg ) . toByteArray ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( msg instanceof MessageLite . Builder ) { </a> 0
<a> return wrappedBuffer ( ( ( MessageLite . Builder ) msg ) . build ( ) . toByteArray ( ) ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . protobuf ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . ByteToMessageDecoder ; </a> 0
<a> import io . netty . handler . codec . CorruptedFrameException ; </a> 0
<a> import com . google . protobuf . CodedInputStream ; </a> 0
<a> public class ProtobufVarint32FrameDecoder extends ByteToMessageDecoder < Object > { </a> 0
<a> public ProtobufVarint32FrameDecoder ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object decode ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 0
<a> in . markReaderIndex ( ) ; </a> 0
<a> final byte [ ] buf = new byte [ 5 ] ; </a> 0
<a> for ( int i = 0 ; i < buf . length ; i ++ ) { </a> 0
<a> if ( ! in . readable ( ) ) { </a> 0
<a> in . resetReaderIndex ( ) ; </a> 0
<a> return null ; </a> 1
<a> } </a> 0
<a> buf [ i ] = in . readByte ( ) ; </a> 0
<a> if ( buf [ i ] >= 0 ) { </a> 0
<a> int length = CodedInputStream . newInstance ( buf , 0 , i + 1 ) . readRawVarint32 ( ) ; </a> 0
<a> if ( length < 0 ) { </a> 0
<a> throw new CorruptedFrameException ( "negative length: " + length ) ; </a> 0
<a> } </a> 0
<a> if ( in . readableBytes ( ) < length ) { </a> 0
<a> in . resetReaderIndex ( ) ; </a> 0
<a> return null ; </a> 1
<a> } else { </a> 0
<a> return in . readBytes ( length ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> throw new CorruptedFrameException ( "length wider than 32-bit" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . protobuf ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ByteBufOutputStream ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . MessageToByteEncoder ; </a> 0
<a> import com . google . protobuf . CodedOutputStream ; </a> 0
<a> @ Sharable </a> 0
<a> public class ProtobufVarint32LengthFieldPrepender extends MessageToByteEncoder < ByteBuf > { </a> 0
<a> public ProtobufVarint32LengthFieldPrepender ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof ByteBuf ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( </a> 0
<a> ChannelHandlerContext ctx , ByteBuf msg , ByteBuf out ) throws Exception { </a> 0
<a> int bodyLen = msg . readableBytes ( ) ; </a> 0
<a> int headerLen = CodedOutputStream . computeRawVarint32Size ( bodyLen ) ; </a> 0
<a> out . ensureWritableBytes ( headerLen + bodyLen ) ; </a> 0
<a> CodedOutputStream headerOut = </a> 0
<a> CodedOutputStream . newInstance ( new ByteBufOutputStream ( out ) ) ; </a> 0
<a> headerOut . writeRawVarint32 ( bodyLen ) ; </a> 0
<a> headerOut . flush ( ) ; </a> 0
<a> out . writeBytes ( msg , msg . readerIndex ( ) , bodyLen ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . protobuf ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import java . util . Map ; </a> 0
<a> class CachingClassResolver implements ClassResolver { </a> 0
<a> private final Map < String , Class < ? > > classCache ; </a> 0
<a> private final ClassResolver delegate ; </a> 0
<a> CachingClassResolver ( ClassResolver delegate , Map < String , Class < ? > > classCache ) { </a> 0
<a> this . delegate = delegate ; </a> 0
<a> this . classCache = classCache ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Class < ? > resolve ( String className ) throws ClassNotFoundException { </a> 0
<a> Class < ? > clazz ; </a> 0
<a> clazz = classCache . get ( className ) ; </a> 0
<a> if ( clazz != null ) { </a> 0
<a> return clazz ; </a> 0
<a> } </a> 0
<a> clazz = delegate . resolve ( className ) ; </a> 0
<a> classCache . put ( className , clazz ) ; </a> 0
<a> return clazz ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> class ClassLoaderClassResolver implements ClassResolver { </a> 0
<a> private final ClassLoader classLoader ; </a> 0
<a> ClassLoaderClassResolver ( ClassLoader classLoader ) { </a> 0
<a> this . classLoader = classLoader ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Class < ? > resolve ( String className ) throws ClassNotFoundException { </a> 0
<a> try { </a> 0
<a> return classLoader . loadClass ( className ) ; </a> 0
<a> } catch ( ClassNotFoundException e ) { </a> 1
<a> return Class . forName ( className , false , classLoader ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> public interface ClassResolver { </a> 0
<a> Class < ? > resolve ( String className ) throws ClassNotFoundException ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import java . lang . ref . Reference ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> public final class ClassResolvers { </a> 0
<a> public static ClassResolver cacheDisabled ( ClassLoader classLoader ) { </a> 0
<a> return new ClassLoaderClassResolver ( defaultClassLoader ( classLoader ) ) ; </a> 0
<a> } </a> 0
<a> public static ClassResolver weakCachingResolver ( ClassLoader classLoader ) { </a> 0
<a> return new CachingClassResolver ( </a> 0
<a> new ClassLoaderClassResolver ( defaultClassLoader ( classLoader ) ) , </a> 0
<a> new WeakReferenceMap < String , Class < ? > > ( new HashMap < String , Reference < Class < ? > > > ( ) ) ) ; </a> 0
<a> } </a> 0
<a> public static ClassResolver softCachingResolver ( ClassLoader classLoader ) { </a> 0
<a> return new CachingClassResolver ( </a> 0
<a> new ClassLoaderClassResolver ( defaultClassLoader ( classLoader ) ) , </a> 0
<a> new SoftReferenceMap < String , Class < ? > > ( new HashMap < String , Reference < Class < ? > > > ( ) ) ) ; </a> 0
<a> } </a> 0
<a> public static ClassResolver weakCachingConcurrentResolver ( ClassLoader classLoader ) { </a> 0
<a> return new CachingClassResolver ( </a> 0
<a> new ClassLoaderClassResolver ( defaultClassLoader ( classLoader ) ) , </a> 0
<a> new WeakReferenceMap < String , Class < ? > > ( new ConcurrentHashMap < String , Reference < Class < ? > > > ( ) ) ) ; </a> 1
<a> } </a> 0
<a> public static ClassResolver softCachingConcurrentResolver ( ClassLoader classLoader ) { </a> 0
<a> return new CachingClassResolver ( </a> 0
<a> new ClassLoaderClassResolver ( defaultClassLoader ( classLoader ) ) , </a> 0
<a> new SoftReferenceMap < String , Class < ? > > ( new ConcurrentHashMap < String , Reference < Class < ? > > > ( ) ) ) ; </a> 1
<a> } </a> 0
<a> static ClassLoader defaultClassLoader ( ClassLoader classLoader ) { </a> 0
<a> if ( classLoader != null ) { </a> 0
<a> return classLoader ; </a> 0
<a> } </a> 0
<a> final ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; </a> 0
<a> if ( contextClassLoader != null ) { </a> 0
<a> return contextClassLoader ; </a> 0
<a> } </a> 0
<a> return ClassResolvers . class . getClassLoader ( ) ; </a> 0
<a> } </a> 0
<a> private ClassResolvers ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . ObjectOutputStream ; </a> 0
<a> import java . io . ObjectStreamClass ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> class CompactObjectOutputStream extends ObjectOutputStream { </a> 0
<a> static final int TYPE_FAT_DESCRIPTOR = 0 ; </a> 0
<a> static final int TYPE_THIN_DESCRIPTOR = 1 ; </a> 0
<a> CompactObjectOutputStream ( OutputStream out ) throws IOException { </a> 0
<a> super ( out ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void writeStreamHeader ( ) throws IOException { </a> 0
<a> writeByte ( STREAM_VERSION ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void writeClassDescriptor ( ObjectStreamClass desc ) throws IOException { </a> 0
<a> Class < ? > clazz = desc . forClass ( ) ; </a> 0
<a> if ( clazz . isPrimitive ( ) || clazz . isArray ( ) || clazz . isInterface ( ) || </a> 0
<a> desc . getSerialVersionUID ( ) == 0 ) { </a> 0
<a> write ( TYPE_FAT_DESCRIPTOR ) ; </a> 0
<a> super . writeClassDescriptor ( desc ) ; </a> 0
<a> } else { </a> 0
<a> write ( TYPE_THIN_DESCRIPTOR ) ; </a> 0
<a> writeUTF ( desc . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ByteBufOutputStream ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . MessageToByteEncoder ; </a> 0
<a> import io . netty . util . Attribute ; </a> 0
<a> import io . netty . util . AttributeKey ; </a> 0
<a> import java . io . ObjectInputStream ; </a> 0
<a> import java . io . ObjectOutputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> public class CompatibleObjectEncoder extends MessageToByteEncoder < Object > { </a> 0
<a> private static final AttributeKey < ObjectOutputStream > OOS = </a> 0
<a> new AttributeKey < ObjectOutputStream > ( CompatibleObjectEncoder . class . getName ( ) + ".oos" ) ; </a> 1
<a> private final int resetInterval ; </a> 0
<a> private int writtenObjects ; </a> 0
<a> public CompatibleObjectEncoder ( ) { </a> 0
<a> this ( 16 ) ; </a> 0
<a> } </a> 0
<a> public CompatibleObjectEncoder ( int resetInterval ) { </a> 0
<a> if ( resetInterval < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "resetInterval: " + resetInterval ) ; </a> 0
<a> } </a> 0
<a> this . resetInterval = resetInterval ; </a> 0
<a> } </a> 0
<a> protected ObjectOutputStream newObjectOutputStream ( OutputStream out ) throws Exception { </a> 0
<a> return new ObjectOutputStream ( out ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof Serializable ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( ChannelHandlerContext ctx , Object msg , ByteBuf out ) throws Exception { </a> 0
<a> Attribute < ObjectOutputStream > oosAttr = ctx . attr ( OOS ) ; </a> 0
<a> ObjectOutputStream oos = oosAttr . get ( ) ; </a> 0
<a> if ( oos == null ) { </a> 0
<a> oos = newObjectOutputStream ( new ByteBufOutputStream ( out ) ) ; </a> 0
<a> ObjectOutputStream newOos = oosAttr . setIfAbsent ( oos ) ; </a> 0
<a> if ( newOos != null ) { </a> 0
<a> oos = newOos ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> synchronized ( oos ) { </a> 0
<a> if ( resetInterval != 0 ) { </a> 0
<a> writtenObjects ++ ; </a> 0
<a> if ( writtenObjects % resetInterval == 0 ) { </a> 0
<a> oos . reset ( ) ; </a> 0
<a> out . unsafe ( ) . discardSomeReadBytes ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> oos . writeObject ( msg ) ; </a> 0
<a> oos . flush ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import java . io . BufferedReader ; </a> 0
<a> import java . io . DataInputStream ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . ObjectInput ; </a> 0
<a> import java . io . StreamCorruptedException ; </a> 0
<a> public class ObjectDecoderInputStream extends InputStream implements </a> 0
<a> ObjectInput { </a> 0
<a> private final DataInputStream in ; </a> 0
<a> private final int maxObjectSize ; </a> 0
<a> private final ClassResolver classResolver ; </a> 0
<a> public ObjectDecoderInputStream ( InputStream in ) { </a> 0
<a> this ( in , null ) ; </a> 0
<a> } </a> 0
<a> public ObjectDecoderInputStream ( InputStream in , ClassLoader classLoader ) { </a> 0
<a> this ( in , classLoader , 1048576 ) ; </a> 0
<a> } </a> 0
<a> public ObjectDecoderInputStream ( InputStream in , int maxObjectSize ) { </a> 0
<a> this ( in , null , maxObjectSize ) ; </a> 0
<a> } </a> 0
<a> public ObjectDecoderInputStream ( InputStream in , ClassLoader classLoader , int maxObjectSize ) { </a> 0
<a> if ( in == null ) { </a> 0
<a> throw new NullPointerException ( "in" ) ; </a> 0
<a> } </a> 0
<a> if ( maxObjectSize <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "maxObjectSize: " + maxObjectSize ) ; </a> 0
<a> } </a> 0
<a> if ( in instanceof DataInputStream ) { </a> 0
<a> this . in = ( DataInputStream ) in ; </a> 0
<a> } else { </a> 0
<a> this . in = new DataInputStream ( in ) ; </a> 0
<a> } </a> 0
<a> classResolver = ClassResolvers . weakCachingResolver ( classLoader ) ; </a> 0
<a> this . maxObjectSize = maxObjectSize ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object readObject ( ) throws ClassNotFoundException , IOException { </a> 0
<a> int dataLen = readInt ( ) ; </a> 0
<a> if ( dataLen <= 0 ) { </a> 0
<a> throw new StreamCorruptedException ( "invalid data length: " + dataLen ) ; </a> 0
<a> } </a> 0
<a> if ( dataLen > maxObjectSize ) { </a> 0
<a> throw new StreamCorruptedException ( </a> 0
<a> "data length too big: " + dataLen + " (max: " + maxObjectSize + ')' ) ; </a> 0
<a> } </a> 0
<a> return new CompactObjectInputStream ( in , classResolver ) . readObject ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int available ( ) throws IOException { </a> 0
<a> return in . available ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws IOException { </a> 0
<a> in . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void mark ( int readlimit ) { </a> 0
<a> in . mark ( readlimit ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean markSupported ( ) { </a> 0
<a> return in . markSupported ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int read ( ) throws IOException { </a> 0
<a> return in . read ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final int read ( byte [ ] b , int off , int len ) throws IOException { </a> 0
<a> return in . read ( b , off , len ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final int read ( byte [ ] b ) throws IOException { </a> 0
<a> return in . read ( b ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final boolean readBoolean ( ) throws IOException { </a> 0
<a> return in . readBoolean ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final byte readByte ( ) throws IOException { </a> 0
<a> return in . readByte ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final char readChar ( ) throws IOException { </a> 0
<a> return in . readChar ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final double readDouble ( ) throws IOException { </a> 0
<a> return in . readDouble ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final float readFloat ( ) throws IOException { </a> 0
<a> return in . readFloat ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void readFully ( byte [ ] b , int off , int len ) throws IOException { </a> 0
<a> in . readFully ( b , off , len ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void readFully ( byte [ ] b ) throws IOException { </a> 0
<a> in . readFully ( b ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final int readInt ( ) throws IOException { </a> 0
<a> return in . readInt ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> @ Deprecated </a> 0
<a> public final String readLine ( ) throws IOException { </a> 0
<a> return in . readLine ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final long readLong ( ) throws IOException { </a> 0
<a> return in . readLong ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final short readShort ( ) throws IOException { </a> 0
<a> return in . readShort ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final int readUnsignedByte ( ) throws IOException { </a> 0
<a> return in . readUnsignedByte ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final int readUnsignedShort ( ) throws IOException { </a> 0
<a> return in . readUnsignedShort ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final String readUTF ( ) throws IOException { </a> 0
<a> return in . readUTF ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void reset ( ) throws IOException { </a> 0
<a> in . reset ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long skip ( long n ) throws IOException { </a> 0
<a> return in . skip ( n ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final int skipBytes ( int n ) throws IOException { </a> 0
<a> return in . skipBytes ( n ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ByteBufOutputStream ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . handler . codec . MessageToByteEncoder ; </a> 0
<a> import java . io . ObjectInputStream ; </a> 0
<a> import java . io . ObjectOutputStream ; </a> 0
<a> import java . io . Serializable ; </a> 0
<a> @ Sharable </a> 0
<a> public class ObjectEncoder extends MessageToByteEncoder < Object > { </a> 0
<a> private static final byte [ ] LENGTH_PLACEHOLDER = new byte [ 4 ] ; </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof Serializable ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void encode ( ChannelHandlerContext ctx , Object msg , ByteBuf out ) throws Exception { </a> 0
<a> int startIdx = out . writerIndex ( ) ; </a> 0
<a> ByteBufOutputStream bout = new ByteBufOutputStream ( out ) ; </a> 0
<a> bout . write ( LENGTH_PLACEHOLDER ) ; </a> 0
<a> ObjectOutputStream oout = new CompactObjectOutputStream ( bout ) ; </a> 0
<a> oout . writeObject ( msg ) ; </a> 0
<a> oout . flush ( ) ; </a> 0
<a> oout . close ( ) ; </a> 0
<a> int endIdx = out . writerIndex ( ) ; </a> 0
<a> out . setInt ( startIdx , endIdx - startIdx - 4 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ByteBufOutputStream ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import java . io . DataOutputStream ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . ObjectOutput ; </a> 0
<a> import java . io . ObjectOutputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> public class ObjectEncoderOutputStream extends OutputStream implements </a> 0
<a> ObjectOutput { </a> 0
<a> private final DataOutputStream out ; </a> 0
<a> private final int estimatedLength ; </a> 0
<a> public ObjectEncoderOutputStream ( OutputStream out ) { </a> 0
<a> this ( out , 512 ) ; </a> 0
<a> } </a> 0
<a> public ObjectEncoderOutputStream ( OutputStream out , int estimatedLength ) { </a> 0
<a> if ( out == null ) { </a> 0
<a> throw new NullPointerException ( "out" ) ; </a> 0
<a> } </a> 0
<a> if ( estimatedLength < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "estimatedLength: " + estimatedLength ) ; </a> 0
<a> } </a> 0
<a> if ( out instanceof DataOutputStream ) { </a> 0
<a> this . out = ( DataOutputStream ) out ; </a> 0
<a> } else { </a> 0
<a> this . out = new DataOutputStream ( out ) ; </a> 0
<a> } </a> 0
<a> this . estimatedLength = estimatedLength ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void writeObject ( Object obj ) throws IOException { </a> 0
<a> ByteBufOutputStream bout = new ByteBufOutputStream ( Unpooled . buffer ( estimatedLength ) ) ; </a> 0
<a> ObjectOutputStream oout = new CompactObjectOutputStream ( bout ) ; </a> 0
<a> oout . writeObject ( obj ) ; </a> 0
<a> oout . flush ( ) ; </a> 0
<a> oout . close ( ) ; </a> 0
<a> ByteBuf buffer = bout . buffer ( ) ; </a> 0
<a> int objectSize = buffer . readableBytes ( ) ; </a> 0
<a> writeInt ( objectSize ) ; </a> 0
<a> buffer . getBytes ( 0 , this , objectSize ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( int b ) throws IOException { </a> 0
<a> out . write ( b ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws IOException { </a> 0
<a> out . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( ) throws IOException { </a> 0
<a> out . flush ( ) ; </a> 0
<a> } </a> 0
<a> public final int size ( ) { </a> 0
<a> return out . size ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( byte [ ] b , int off , int len ) throws IOException { </a> 0
<a> out . write ( b , off , len ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void write ( byte [ ] b ) throws IOException { </a> 0
<a> out . write ( b ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void writeBoolean ( boolean v ) throws IOException { </a> 0
<a> out . writeBoolean ( v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void writeByte ( int v ) throws IOException { </a> 0
<a> out . writeByte ( v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void writeBytes ( String s ) throws IOException { </a> 0
<a> out . writeBytes ( s ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void writeChar ( int v ) throws IOException { </a> 0
<a> out . writeChar ( v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void writeChars ( String s ) throws IOException { </a> 0
<a> out . writeChars ( s ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void writeDouble ( double v ) throws IOException { </a> 0
<a> out . writeDouble ( v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void writeFloat ( float v ) throws IOException { </a> 0
<a> out . writeFloat ( v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void writeInt ( int v ) throws IOException { </a> 0
<a> out . writeInt ( v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void writeLong ( long v ) throws IOException { </a> 0
<a> out . writeLong ( v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void writeShort ( int v ) throws IOException { </a> 0
<a> out . writeShort ( v ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void writeUTF ( String str ) throws IOException { </a> 0
<a> out . writeUTF ( str ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import java . lang . ref . Reference ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Set ; </a> 0
<a> abstract class ReferenceMap < K , V > implements Map < K , V > { </a> 0
<a> private final Map < K , Reference < V > > delegate ; </a> 0
<a> protected ReferenceMap ( Map < K , Reference < V > > delegate ) { </a> 0
<a> this . delegate = delegate ; </a> 0
<a> } </a> 0
<a> abstract Reference < V > fold ( V value ) ; </a> 0
<a> private V unfold ( Reference < V > ref ) { </a> 0
<a> if ( ref == null ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return ref . get ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int size ( ) { </a> 0
<a> return delegate . size ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEmpty ( ) { </a> 0
<a> return delegate . isEmpty ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean containsKey ( Object key ) { </a> 0
<a> return delegate . containsKey ( key ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean containsValue ( Object value ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public V get ( Object key ) { </a> 0
<a> return unfold ( delegate . get ( key ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public V put ( K key , V value ) { </a> 0
<a> return unfold ( delegate . put ( key , fold ( value ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public V remove ( Object key ) { </a> 0
<a> return unfold ( delegate . remove ( key ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void putAll ( Map < ? extends K , ? extends V > m ) { </a> 0
<a> for ( Entry < ? extends K , ? extends V > entry : m . entrySet ( ) ) { </a> 0
<a> delegate . put ( entry . getKey ( ) , fold ( entry . getValue ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clear ( ) { </a> 0
<a> delegate . clear ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Set < K > keySet ( ) { </a> 0
<a> return delegate . keySet ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Collection < V > values ( ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Set < Entry < K , V > > entrySet ( ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import java . io . FilterInputStream ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> final class SwitchableInputStream extends FilterInputStream { </a> 0
<a> SwitchableInputStream ( ) { </a> 0
<a> super ( null ) ; </a> 0
<a> } </a> 0
<a> void switchStream ( InputStream in ) { </a> 0
<a> this . in = in ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import java . lang . ref . Reference ; </a> 0
<a> import java . lang . ref . WeakReference ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class WeakReferenceMap < K , V > extends ReferenceMap < K , V > { </a> 0
<a> public WeakReferenceMap ( Map < K , Reference < V > > delegate ) { </a> 1
<a> super ( delegate ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> Reference < V > fold ( V value ) { </a> 0
<a> return new WeakReference < V > ( value ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . string ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . DelimiterBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . Delimiters ; </a> 1
<a> import io . netty . handler . codec . MessageToMessageDecoder ; </a> 0
<a> import java . nio . charset . Charset ; </a> 0
<a> @ Sharable </a> 0
<a> public class StringDecoder extends MessageToMessageDecoder < ByteBuf , String > { </a> 0
<a> private final Charset charset ; </a> 0
<a> public StringDecoder ( ) { </a> 0
<a> this ( Charset . defaultCharset ( ) ) ; </a> 0
<a> } </a> 0
<a> public StringDecoder ( Charset charset ) { </a> 0
<a> if ( charset == null ) { </a> 0
<a> throw new NullPointerException ( "charset" ) ; </a> 0
<a> } </a> 0
<a> this . charset = charset ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDecodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof ByteBuf ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String decode ( ChannelHandlerContext ctx , ByteBuf msg ) throws Exception { </a> 0
<a> return msg . toString ( charset ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . string ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . handler . codec . DelimiterBasedFrameDecoder ; </a> 1
<a> import io . netty . handler . codec . Delimiters ; </a> 1
<a> import io . netty . handler . codec . MessageToMessageEncoder ; </a> 0
<a> import java . nio . charset . Charset ; </a> 0
<a> @ Sharable </a> 0
<a> public class StringEncoder extends MessageToMessageEncoder < String , ByteBuf > { </a> 0
<a> private final Charset charset ; </a> 0
<a> public StringEncoder ( ) { </a> 0
<a> this ( Charset . defaultCharset ( ) ) ; </a> 0
<a> } </a> 0
<a> public StringEncoder ( Charset charset ) { </a> 0
<a> if ( charset == null ) { </a> 0
<a> throw new NullPointerException ( "charset" ) ; </a> 0
<a> } </a> 0
<a> this . charset = charset ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEncodable ( Object msg ) throws Exception { </a> 0
<a> return msg instanceof String ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf encode ( ChannelHandlerContext ctx , String msg ) throws Exception { </a> 0
<a> return Unpooled . copiedBuffer ( msg , charset ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ByteBufIndexFinder ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import org . junit . Test ; </a> 0
<a> public class ReplayingDecoderTest { </a> 0
<a> @ Test </a> 0
<a> public void testLineProtocol ( ) { </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( new LineDecoder ( ) ) ; </a> 1
<a> ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 'A' } ) ) ; </a> 0
<a> assertNull ( ch . readInbound ( ) ) ; </a> 0
<a> ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 'B' } ) ) ; </a> 0
<a> assertNull ( ch . readInbound ( ) ) ; </a> 0
<a> ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 'C' } ) ) ; </a> 0
<a> assertNull ( ch . readInbound ( ) ) ; </a> 0
<a> ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { '\n' } ) ) ; </a> 0
<a> assertEquals ( Unpooled . wrappedBuffer ( new byte [ ] { 'A' , 'B' , 'C' } ) , ch . readInbound ( ) ) ; </a> 0
<a> ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 'A' } ) ) ; </a> 0
<a> assertNull ( ch . readInbound ( ) ) ; </a> 0
<a> ch . close ( ) ; </a> 1
<a> assertNull ( ch . readInbound ( ) ) ; </a> 0
<a> } </a> 0
<a> private static final class LineDecoder extends ReplayingDecoder < ByteBuf , Void > { </a> 0
<a> LineDecoder ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf decode ( ChannelHandlerContext ctx , ByteBuf in ) { </a> 0
<a> ByteBuf msg = in . readBytes ( in . bytesBefore ( ByteBufIndexFinder . LF ) ) ; </a> 0
<a> in . skipBytes ( 1 ) ; </a> 0
<a> return msg ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . bytes ; </a> 0
<a> import static io . netty . buffer . Unpooled . * ; </a> 0
<a> import static org . hamcrest . core . Is . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedMessageChannel ; </a> 1
<a> import java . util . Random ; </a> 0
<a> import org . junit . Before ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class ByteArrayDecoderTest { </a> 0
<a> private EmbeddedMessageChannel ch ; </a> 1
<a> @ Before </a> 0
<a> public void setUp ( ) { </a> 0
<a> ch = new EmbeddedMessageChannel ( new ByteArrayDecoder ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecode ( ) { </a> 0
<a> byte [ ] b = new byte [ 2048 ] ; </a> 0
<a> new Random ( ) . nextBytes ( b ) ; </a> 0
<a> ch . writeInbound ( wrappedBuffer ( b ) ) ; </a> 0
<a> assertThat ( ( byte [ ] ) ch . readInbound ( ) , is ( b ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodeEmpty ( ) { </a> 0
<a> byte [ ] b = new byte [ 0 ] ; </a> 0
<a> ch . writeInbound ( wrappedBuffer ( b ) ) ; </a> 0
<a> assertThat ( ( byte [ ] ) ch . readInbound ( ) , is ( b ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDecodeOtherType ( ) { </a> 0
<a> String str = "Meep!" ; </a> 0
<a> ch . writeInbound ( str ) ; </a> 0
<a> assertThat ( ch . readInbound ( ) , is ( ( Object ) str ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . bytes ; </a> 0
<a> import static io . netty . buffer . Unpooled . * ; </a> 0
<a> import static org . hamcrest . core . Is . * ; </a> 0
<a> import static org . hamcrest . core . IsNull . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedMessageChannel ; </a> 1
<a> import java . util . Random ; </a> 0
<a> import org . junit . Before ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class ByteArrayEncoderTest { </a> 0
<a> private EmbeddedMessageChannel ch ; </a> 1
<a> @ Before </a> 0
<a> public void setUp ( ) { </a> 0
<a> ch = new EmbeddedMessageChannel ( new ByteArrayEncoder ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testEncode ( ) { </a> 0
<a> byte [ ] b = new byte [ 2048 ] ; </a> 0
<a> new Random ( ) . nextBytes ( b ) ; </a> 0
<a> ch . writeOutbound ( b ) ; </a> 0
<a> assertThat ( ( ByteBuf ) ch . readOutbound ( ) , is ( wrappedBuffer ( b ) ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testEncodeEmpty ( ) { </a> 0
<a> byte [ ] b = new byte [ 0 ] ; </a> 0
<a> ch . writeOutbound ( b ) ; </a> 0
<a> assertThat ( ch . readOutbound ( ) , nullValue ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testEncodeOtherType ( ) { </a> 0
<a> String str = "Meep!" ; </a> 0
<a> ch . writeOutbound ( str ) ; </a> 0
<a> assertThat ( ch . readOutbound ( ) , is ( ( Object ) str ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . frame ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import io . netty . handler . codec . DecoderException ; </a> 0
<a> import io . netty . handler . codec . DelimiterBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . Delimiters ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import org . junit . Assert ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class DelimiterBasedFrameDecoderTest { </a> 0
<a> @ Test </a> 0
<a> public void testFailSlowTooLongFrameRecovery ( ) throws Exception { </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( </a> 1
<a> new DelimiterBasedFrameDecoder ( 1 , true , false , Delimiters . nulDelimiter ( ) ) ) ; </a> 0
<a> for ( int i = 0 ; i < 2 ; i ++ ) { </a> 0
<a> ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 1 , 2 } ) ) ; </a> 0
<a> try { </a> 0
<a> assertTrue ( ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 0 } ) ) ) ; </a> 0
<a> Assert . fail ( DecoderException . class . getSimpleName ( ) + " must be raised." ) ; </a> 0
<a> } catch ( TooLongFrameException e ) { </a> 0
<a> } </a> 0
<a> ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 'A' , 0 } ) ) ; </a> 0
<a> ByteBuf buf = ( ByteBuf ) ch . readInbound ( ) ; </a> 1
<a> Assert . assertEquals ( "A" , buf . toString ( CharsetUtil . ISO_8859_1 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testFailFastTooLongFrameRecovery ( ) throws Exception { </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( </a> 1
<a> new DelimiterBasedFrameDecoder ( 1 , Delimiters . nulDelimiter ( ) ) ) ; </a> 0
<a> for ( int i = 0 ; i < 2 ; i ++ ) { </a> 0
<a> try { </a> 0
<a> assertTrue ( ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 1 , 2 } ) ) ) ; </a> 0
<a> Assert . fail ( DecoderException . class . getSimpleName ( ) + " must be raised." ) ; </a> 0
<a> } catch ( TooLongFrameException e ) { </a> 0
<a> } </a> 0
<a> ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 0 , 'A' , 0 } ) ) ; </a> 0
<a> ByteBuf buf = ( ByteBuf ) ch . readInbound ( ) ; </a> 1
<a> Assert . assertEquals ( "A" , buf . toString ( CharsetUtil . ISO_8859_1 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . frame ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import io . netty . handler . codec . DecoderException ; </a> 0
<a> import io . netty . handler . codec . LengthFieldBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import org . junit . Assert ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class LengthFieldBasedFrameDecoderTest { </a> 0
<a> @ Test </a> 0
<a> public void testFailSlowTooLongFrameRecovery ( ) throws Exception { </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( </a> 1
<a> new LengthFieldBasedFrameDecoder ( 5 , 0 , 4 , 0 , 4 , false ) ) ; </a> 0
<a> for ( int i = 0 ; i < 2 ; i ++ ) { </a> 0
<a> assertFalse ( ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 0 , 0 , 0 , 2 } ) ) ) ; </a> 0
<a> try { </a> 0
<a> assertTrue ( ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 0 , 0 } ) ) ) ; </a> 0
<a> Assert . fail ( DecoderException . class . getSimpleName ( ) + " must be raised." ) ; </a> 0
<a> } catch ( TooLongFrameException e ) { </a> 0
<a> } </a> 0
<a> ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 0 , 0 , 0 , 1 , 'A' } ) ) ; </a> 0
<a> ByteBuf buf = ( ByteBuf ) ch . readInbound ( ) ; </a> 1
<a> Assert . assertEquals ( "A" , buf . toString ( CharsetUtil . ISO_8859_1 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testFailFastTooLongFrameRecovery ( ) throws Exception { </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( </a> 1
<a> new LengthFieldBasedFrameDecoder ( 5 , 0 , 4 , 0 , 4 ) ) ; </a> 0
<a> for ( int i = 0 ; i < 2 ; i ++ ) { </a> 0
<a> try { </a> 0
<a> assertTrue ( ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 0 , 0 , 0 , 2 } ) ) ) ; </a> 0
<a> Assert . fail ( DecoderException . class . getSimpleName ( ) + " must be raised." ) ; </a> 0
<a> } catch ( TooLongFrameException e ) { </a> 0
<a> } </a> 0
<a> ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { 0 , 0 , 0 , 0 , 0 , 1 , 'A' } ) ) ; </a> 0
<a> ByteBuf buf = ( ByteBuf ) ch . readInbound ( ) ; </a> 1
<a> Assert . assertEquals ( "A" , buf . toString ( CharsetUtil . ISO_8859_1 ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import io . netty . handler . codec . CodecException ; </a> 1
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 1
<a> import java . io . ByteArrayOutputStream ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import junit . framework . Assert ; </a> 1
<a> import org . jboss . marshalling . Marshaller ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . Marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public abstract class AbstractCompatibleMarshallingDecoderTest { </a> 0
<a> private final String testObject = new String ( "test" ) ; </a> 0
<a> @ Test </a> 0
<a> public void testSimpleUnmarshalling ( ) throws IOException { </a> 0
<a> MarshallerFactory marshallerFactory = createMarshallerFactory ( ) ; </a> 0
<a> MarshallingConfiguration configuration = createMarshallingConfig ( ) ; </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( createDecoder ( Integer . MAX_VALUE ) ) ; </a> 1
<a> ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; </a> 0
<a> Marshaller marshaller = marshallerFactory . createMarshaller ( configuration ) ; </a> 0
<a> marshaller . start ( Marshalling . createByteOutput ( bout ) ) ; </a> 0
<a> marshaller . writeObject ( testObject ) ; </a> 0
<a> marshaller . finish ( ) ; </a> 0
<a> marshaller . close ( ) ; </a> 0
<a> byte [ ] testBytes = bout . toByteArray ( ) ; </a> 0
<a> ch . writeInbound ( input ( testBytes ) ) ; </a> 0
<a> assertTrue ( ch . finish ( ) ) ; </a> 0
<a> String unmarshalled = ( String ) ch . readInbound ( ) ; </a> 1
<a> Assert . assertEquals ( testObject , unmarshalled ) ; </a> 1
<a> Assert . assertNull ( ch . readInbound ( ) ) ; </a> 1
<a> } </a> 0
<a> protected ByteBuf input ( byte [ ] input ) { </a> 0
<a> return Unpooled . wrappedBuffer ( input ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testFragmentedUnmarshalling ( ) throws IOException { </a> 0
<a> MarshallerFactory marshallerFactory = createMarshallerFactory ( ) ; </a> 0
<a> MarshallingConfiguration configuration = createMarshallingConfig ( ) ; </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( createDecoder ( Integer . MAX_VALUE ) ) ; </a> 1
<a> ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; </a> 0
<a> Marshaller marshaller = marshallerFactory . createMarshaller ( configuration ) ; </a> 0
<a> marshaller . start ( Marshalling . createByteOutput ( bout ) ) ; </a> 0
<a> marshaller . writeObject ( testObject ) ; </a> 0
<a> marshaller . finish ( ) ; </a> 0
<a> marshaller . close ( ) ; </a> 0
<a> byte [ ] testBytes = bout . toByteArray ( ) ; </a> 0
<a> ByteBuf buffer = input ( testBytes ) ; </a> 0
<a> ByteBuf slice = buffer . readSlice ( 2 ) ; </a> 0
<a> ch . writeInbound ( slice ) ; </a> 1
<a> ch . writeInbound ( buffer ) ; </a> 0
<a> assertTrue ( ch . finish ( ) ) ; </a> 0
<a> String unmarshalled = ( String ) ch . readInbound ( ) ; </a> 1
<a> Assert . assertEquals ( testObject , unmarshalled ) ; </a> 1
<a> Assert . assertNull ( ch . readInbound ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTooBigObject ( ) throws IOException { </a> 0
<a> MarshallerFactory marshallerFactory = createMarshallerFactory ( ) ; </a> 0
<a> MarshallingConfiguration configuration = createMarshallingConfig ( ) ; </a> 0
<a> ChannelHandler mDecoder = createDecoder ( 4 ) ; </a> 0
<a> EmbeddedByteChannel ch = new EmbeddedByteChannel ( mDecoder ) ; </a> 1
<a> ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; </a> 0
<a> Marshaller marshaller = marshallerFactory . createMarshaller ( configuration ) ; </a> 0
<a> marshaller . start ( Marshalling . createByteOutput ( bout ) ) ; </a> 0
<a> marshaller . writeObject ( testObject ) ; </a> 0
<a> marshaller . finish ( ) ; </a> 0
<a> marshaller . close ( ) ; </a> 0
<a> byte [ ] testBytes = bout . toByteArray ( ) ; </a> 0
<a> try { </a> 1
<a> ch . writeInbound ( input ( testBytes ) ) ; </a> 1
<a> fail ( ) ; </a> 1
<a> } catch ( CodecException e ) { </a> 1
<a> assertEquals ( TooLongFrameException . class , e . getClass ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> protected ChannelHandler createDecoder ( int maxObjectSize ) { </a> 0
<a> return new CompatibleMarshallingDecoder ( createProvider ( createMarshallerFactory ( ) , createMarshallingConfig ( ) ) , maxObjectSize ) ; </a> 1
<a> } </a> 0
<a> protected UnmarshallerProvider createProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> return new DefaultUnmarshallerProvider ( factory , config ) ; </a> 0
<a> } </a> 0
<a> protected abstract MarshallerFactory createMarshallerFactory ( ) ; </a> 0
<a> protected abstract MarshallingConfiguration createMarshallingConfig ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . Marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class RiverCompatibleMarshallingDecoderTest extends AbstractCompatibleMarshallingDecoderTest { </a> 0
<a> @ Override </a> 0
<a> protected MarshallerFactory createMarshallerFactory ( ) { </a> 0
<a> return Marshalling . getProvidedMarshallerFactory ( "river" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected MarshallingConfiguration createMarshallingConfig ( ) { </a> 0
<a> final MarshallingConfiguration configuration = new MarshallingConfiguration ( ) ; </a> 0
<a> configuration . setVersion ( 3 ) ; </a> 0
<a> return configuration ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . Marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class RiverCompatibleMarshallingEncoderTest extends AbstractCompatibleMarshallingEncoderTest { </a> 0
<a> @ Override </a> 0
<a> protected MarshallerFactory createMarshallerFactory ( ) { </a> 0
<a> return Marshalling . getProvidedMarshallerFactory ( "river" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected MarshallingConfiguration createMarshallingConfig ( ) { </a> 0
<a> final MarshallingConfiguration configuration = new MarshallingConfiguration ( ) ; </a> 0
<a> configuration . setVersion ( 3 ) ; </a> 0
<a> return configuration ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class RiverContextBoundCompatibleMarshallingDecoderTest extends RiverCompatibleMarshallingDecoderTest { </a> 0
<a> @ Override </a> 0
<a> protected UnmarshallerProvider createProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> return new ContextBoundUnmarshallerProvider ( factory , config ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class RiverContextBoundMarshallingDecoderTest extends RiverMarshallingDecoderTest { </a> 0
<a> @ Override </a> 0
<a> protected UnmarshallerProvider createProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> return new ContextBoundUnmarshallerProvider ( factory , config ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> public class RiverMarshallingDecoderTest extends RiverCompatibleMarshallingDecoderTest { </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf input ( byte [ ] input ) { </a> 0
<a> ByteBuf length = Unpooled . buffer ( 4 ) ; </a> 0
<a> length . writeInt ( input . length ) ; </a> 0
<a> return Unpooled . wrappedBuffer ( length , Unpooled . wrappedBuffer ( input ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ChannelHandler createDecoder ( int maxObjectSize ) { </a> 0
<a> return new MarshallingDecoder ( createProvider ( createMarshallerFactory ( ) , createMarshallingConfig ( ) ) , maxObjectSize ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> public class RiverMarshallingEncoderTest extends RiverCompatibleMarshallingEncoderTest { </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf truncate ( ByteBuf buf ) { </a> 0
<a> buf . readInt ( ) ; </a> 0
<a> return buf ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ChannelHandler createEncoder ( ) { </a> 0
<a> return new MarshallingEncoder ( createProvider ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class RiverThreadLocalCompatibleMarshallingDecoderTest extends RiverCompatibleMarshallingDecoderTest { </a> 0
<a> @ Override </a> 0
<a> protected UnmarshallerProvider createProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> return new ThreadLocalUnmarshallerProvider ( factory , config ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> public class RiverThreadLocalCompatibleMarshallingEncoderTest extends RiverCompatibleMarshallingEncoderTest { </a> 0
<a> @ Override </a> 0
<a> protected MarshallerProvider createProvider ( ) { </a> 0
<a> return new ThreadLocalMarshallerProvider ( createMarshallerFactory ( ) , createMarshallingConfig ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class RiverThreadLocalMarshallingDecoderTest extends RiverMarshallingDecoderTest { </a> 0
<a> @ Override </a> 0
<a> protected UnmarshallerProvider createProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> return new ThreadLocalUnmarshallerProvider ( factory , config ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> public class RiverThreadLocalMarshallingEncoderTest extends RiverMarshallingEncoderTest { </a> 0
<a> @ Override </a> 0
<a> protected MarshallerProvider createProvider ( ) { </a> 0
<a> return new ThreadLocalMarshallerProvider ( createMarshallerFactory ( ) , createMarshallingConfig ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . Marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class SerialCompatibleMarshallingDecoderTest extends AbstractCompatibleMarshallingDecoderTest { </a> 0
<a> @ Override </a> 0
<a> protected MarshallerFactory createMarshallerFactory ( ) { </a> 0
<a> return Marshalling . getProvidedMarshallerFactory ( "serial" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected MarshallingConfiguration createMarshallingConfig ( ) { </a> 0
<a> final MarshallingConfiguration configuration = new MarshallingConfiguration ( ) ; </a> 0
<a> configuration . setVersion ( 5 ) ; </a> 0
<a> return configuration ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . Marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class SerialCompatibleMarshallingEncoderTest extends AbstractCompatibleMarshallingEncoderTest { </a> 0
<a> @ Override </a> 0
<a> protected MarshallerFactory createMarshallerFactory ( ) { </a> 0
<a> return Marshalling . getProvidedMarshallerFactory ( "serial" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected MarshallingConfiguration createMarshallingConfig ( ) { </a> 0
<a> final MarshallingConfiguration configuration = new MarshallingConfiguration ( ) ; </a> 0
<a> configuration . setVersion ( 5 ) ; </a> 0
<a> return configuration ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class SerialContextBoundCompatibleMarshallingDecoderTest extends SerialCompatibleMarshallingDecoderTest { </a> 0
<a> @ Override </a> 0
<a> protected UnmarshallerProvider createProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> return new ContextBoundUnmarshallerProvider ( factory , config ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class SerialContextBoundMarshallingDecoderTest extends SerialMarshallingDecoderTest { </a> 0
<a> @ Override </a> 0
<a> protected UnmarshallerProvider createProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> return new ContextBoundUnmarshallerProvider ( factory , config ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> public class SerialMarshallingDecoderTest extends SerialCompatibleMarshallingDecoderTest { </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf input ( byte [ ] input ) { </a> 0
<a> ByteBuf length = Unpooled . buffer ( 4 ) ; </a> 0
<a> length . writeInt ( input . length ) ; </a> 0
<a> return Unpooled . wrappedBuffer ( length , Unpooled . wrappedBuffer ( input ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ChannelHandler createDecoder ( int maxObjectSize ) { </a> 0
<a> return new MarshallingDecoder ( createProvider ( createMarshallerFactory ( ) , createMarshallingConfig ( ) ) , maxObjectSize ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> public class SerialMarshallingEncoderTest extends SerialCompatibleMarshallingEncoderTest { </a> 0
<a> @ Override </a> 0
<a> protected ByteBuf truncate ( ByteBuf buf ) { </a> 0
<a> buf . readInt ( ) ; </a> 0
<a> return buf ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ChannelHandler createEncoder ( ) { </a> 0
<a> return new MarshallingEncoder ( createProvider ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class SerialThreadLocalCompatibleMarshallingDecoderTest extends SerialCompatibleMarshallingDecoderTest { </a> 0
<a> @ Override </a> 0
<a> protected UnmarshallerProvider createProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> return new ThreadLocalUnmarshallerProvider ( factory , config ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> public class SerialThreadLocalCompatibleMarshallingEncoderTest extends SerialCompatibleMarshallingEncoderTest { </a> 0
<a> @ Override </a> 0
<a> protected MarshallerProvider createProvider ( ) { </a> 0
<a> return new ThreadLocalMarshallerProvider ( createMarshallerFactory ( ) , createMarshallingConfig ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> import org . jboss . marshalling . MarshallerFactory ; </a> 0
<a> import org . jboss . marshalling . MarshallingConfiguration ; </a> 0
<a> public class SerialThreadLocalMarshallingDecoderTest extends SerialMarshallingDecoderTest { </a> 0
<a> @ Override </a> 0
<a> protected UnmarshallerProvider createProvider ( MarshallerFactory factory , MarshallingConfiguration config ) { </a> 0
<a> return new ThreadLocalUnmarshallerProvider ( factory , config ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . marshalling ; </a> 0
<a> public class SerialThreadLocalMarshallingEncoderTest extends SerialMarshallingEncoderTest { </a> 0
<a> @ Override </a> 0
<a> protected MarshallerProvider createProvider ( ) { </a> 0
<a> return new ThreadLocalMarshallerProvider ( createMarshallerFactory ( ) , createMarshallingConfig ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . protobuf ; </a> 0
<a> import static io . netty . buffer . Unpooled . * ; </a> 0
<a> import static org . hamcrest . core . Is . * ; </a> 0
<a> import static org . hamcrest . core . IsNull . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import org . junit . Before ; </a> 1
<a> import org . junit . Test ; </a> 1
<a> public class ProtobufVarint32FrameDecoderTest { </a> 0
<a> private EmbeddedByteChannel ch ; </a> 1
<a> @ Before </a> 0
<a> public void setUp ( ) { </a> 0
<a> ch = new EmbeddedByteChannel ( new ProtobufVarint32FrameDecoder ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTinyDecode ( ) { </a> 0
<a> byte [ ] b = { 4 , 1 , 1 , 1 , 1 } ; </a> 0
<a> ch . writeInbound ( wrappedBuffer ( b , 0 , 1 ) ) ; </a> 0
<a> assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; </a> 0
<a> ch . writeInbound ( wrappedBuffer ( b , 1 , 2 ) ) ; </a> 0
<a> assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; </a> 0
<a> ch . writeInbound ( wrappedBuffer ( b , 3 , b . length - 3 ) ) ; </a> 0
<a> assertThat ( </a> 0
<a> ( ByteBuf ) ch . readInbound ( ) , </a> 1
<a> is ( wrappedBuffer ( new byte [ ] { 1 , 1 , 1 , 1 } ) ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRegularDecode ( ) { </a> 0
<a> byte [ ] b = new byte [ 2048 ] ; </a> 0
<a> for ( int i = 2 ; i < 2048 ; i ++ ) { </a> 0
<a> b [ i ] = 1 ; </a> 0
<a> } </a> 0
<a> b [ 0 ] = - 2 ; </a> 0
<a> b [ 1 ] = 15 ; </a> 0
<a> ch . writeInbound ( wrappedBuffer ( b , 0 , 127 ) ) ; </a> 0
<a> assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; </a> 0
<a> ch . writeInbound ( wrappedBuffer ( b , 127 , 600 ) ) ; </a> 0
<a> assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; </a> 0
<a> ch . writeInbound ( wrappedBuffer ( b , 727 , b . length - 727 ) ) ; </a> 0
<a> assertThat ( ( ByteBuf ) ch . readInbound ( ) , is ( wrappedBuffer ( b , 2 , b . length - 2 ) ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . protobuf ; </a> 0
<a> import static io . netty . buffer . Unpooled . * ; </a> 0
<a> import static org . hamcrest . core . Is . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import io . netty . channel . embedded . EmbeddedByteChannel ; </a> 1
<a> import org . junit . Before ; </a> 1
<a> import org . junit . Test ; </a> 1
<a> public class ProtobufVarint32LengthFieldPrependerTest { </a> 0
<a> private EmbeddedByteChannel ch ; </a> 1
<a> @ Before </a> 0
<a> public void setUp ( ) { </a> 0
<a> ch = new EmbeddedByteChannel ( new ProtobufVarint32LengthFieldPrepender ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTinyEncode ( ) { </a> 0
<a> byte [ ] b = { 4 , 1 , 1 , 1 , 1 } ; </a> 0
<a> ch . writeOutbound ( wrappedBuffer ( b , 1 , b . length - 1 ) ) ; </a> 0
<a> assertThat ( ch . readOutbound ( ) , is ( wrappedBuffer ( b ) ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testRegularDecode ( ) { </a> 0
<a> byte [ ] b = new byte [ 2048 ] ; </a> 0
<a> for ( int i = 2 ; i < 2048 ; i ++ ) { </a> 0
<a> b [ i ] = 1 ; </a> 0
<a> } </a> 0
<a> b [ 0 ] = - 2 ; </a> 0
<a> b [ 1 ] = 15 ; </a> 0
<a> ch . writeOutbound ( wrappedBuffer ( b , 2 , b . length - 2 ) ) ; </a> 0
<a> assertThat ( ch . readOutbound ( ) , is ( wrappedBuffer ( b ) ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import java . io . PipedInputStream ; </a> 0
<a> import java . io . PipedOutputStream ; </a> 0
<a> import java . util . List ; </a> 0
<a> import org . junit . Assert ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class CompactObjectSerializationTest { </a> 0
<a> @ Test </a> 0
<a> public void testInterfaceSerialization ( ) throws Exception { </a> 0
<a> PipedOutputStream pipeOut = new PipedOutputStream ( ) ; </a> 0
<a> PipedInputStream pipeIn = new PipedInputStream ( pipeOut ) ; </a> 0
<a> CompactObjectOutputStream out = new CompactObjectOutputStream ( pipeOut ) ; </a> 0
<a> CompactObjectInputStream in = new CompactObjectInputStream ( pipeIn , ClassResolvers . cacheDisabled ( null ) ) ; </a> 0
<a> out . writeObject ( List . class ) ; </a> 0
<a> Assert . assertSame ( List . class , in . readObject ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . codec . serialization ; </a> 0
<a> import static org . easymock . EasyMock . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class SwitchableInputStreamTest { </a> 0
<a> @ Test </a> 0
<a> public void testSwitchStream ( ) throws Exception { </a> 0
<a> SwitchableInputStream sin = new SwitchableInputStream ( ) ; </a> 0
<a> InputStream in1 = createStrictMock ( InputStream . class ) ; </a> 0
<a> InputStream in2 = createStrictMock ( InputStream . class ) ; </a> 0
<a> expect ( in1 . read ( ) ) . andReturn ( 1 ) ; </a> 0
<a> replay ( in1 , in2 ) ; </a> 0
<a> sin . switchStream ( in1 ) ; </a> 0
<a> assertEquals ( 1 , sin . read ( ) ) ; </a> 0
<a> verify ( in1 , in2 ) ; </a> 0
<a> reset ( in1 , in2 ) ; </a> 0
<a> expect ( in2 . read ( ) ) . andReturn ( 2 ) ; </a> 0
<a> replay ( in1 , in2 ) ; </a> 0
<a> sin . switchStream ( in2 ) ; </a> 0
<a> assertEquals ( 2 , sin . read ( ) ) ; </a> 0
<a> verify ( in1 , in2 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> public abstract class AbstractInternalLogger implements InternalLogger { </a> 0
<a> protected AbstractInternalLogger ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEnabled ( InternalLogLevel level ) { </a> 0
<a> switch ( level ) { </a> 0
<a> case TRACE : </a> 0
<a> return isTraceEnabled ( ) ; </a> 0
<a> case DEBUG : </a> 0
<a> return isDebugEnabled ( ) ; </a> 0
<a> case INFO : </a> 0
<a> return isInfoEnabled ( ) ; </a> 0
<a> case WARN : </a> 0
<a> return isWarnEnabled ( ) ; </a> 0
<a> case ERROR : </a> 0
<a> return isErrorEnabled ( ) ; </a> 0
<a> default : </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void log ( InternalLogLevel level , String msg , Throwable cause ) { </a> 0
<a> switch ( level ) { </a> 0
<a> case TRACE : </a> 0
<a> trace ( msg , cause ) ; </a> 0
<a> break ; </a> 0
<a> case DEBUG : </a> 0
<a> debug ( msg , cause ) ; </a> 0
<a> break ; </a> 0
<a> case INFO : </a> 0
<a> info ( msg , cause ) ; </a> 0
<a> break ; </a> 0
<a> case WARN : </a> 0
<a> warn ( msg , cause ) ; </a> 0
<a> break ; </a> 0
<a> case ERROR : </a> 0
<a> error ( msg , cause ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void log ( InternalLogLevel level , String msg ) { </a> 0
<a> switch ( level ) { </a> 0
<a> case TRACE : </a> 0
<a> trace ( msg ) ; </a> 0
<a> break ; </a> 0
<a> case DEBUG : </a> 0
<a> debug ( msg ) ; </a> 0
<a> break ; </a> 0
<a> case INFO : </a> 0
<a> info ( msg ) ; </a> 0
<a> break ; </a> 0
<a> case WARN : </a> 0
<a> warn ( msg ) ; </a> 0
<a> break ; </a> 0
<a> case ERROR : </a> 0
<a> error ( msg ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import org . apache . commons . logging . Log ; </a> 0
<a> class CommonsLogger extends AbstractInternalLogger { </a> 0
<a> private final Log logger ; </a> 0
<a> private final String loggerName ; </a> 0
<a> CommonsLogger ( Log logger , String loggerName ) { </a> 0
<a> this . logger = logger ; </a> 0
<a> this . loggerName = loggerName ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg ) { </a> 0
<a> logger . trace ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg , Throwable cause ) { </a> 0
<a> logger . trace ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg ) { </a> 0
<a> logger . debug ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg , Throwable cause ) { </a> 0
<a> logger . debug ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg ) { </a> 0
<a> logger . error ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg , Throwable cause ) { </a> 0
<a> logger . error ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg ) { </a> 0
<a> logger . info ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg , Throwable cause ) { </a> 0
<a> logger . info ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isTraceEnabled ( ) { </a> 0
<a> return logger . isTraceEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDebugEnabled ( ) { </a> 0
<a> return logger . isDebugEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isErrorEnabled ( ) { </a> 0
<a> return logger . isErrorEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isInfoEnabled ( ) { </a> 0
<a> return logger . isInfoEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isWarnEnabled ( ) { </a> 0
<a> return logger . isWarnEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg ) { </a> 0
<a> logger . warn ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg , Throwable cause ) { </a> 0
<a> logger . warn ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return loggerName ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import org . apache . commons . logging . LogFactory ; </a> 0
<a> public class CommonsLoggerFactory extends InternalLoggerFactory { </a> 0
<a> @ Override </a> 0
<a> public InternalLogger newInstance ( String name ) { </a> 0
<a> return new CommonsLogger ( LogFactory . getLog ( name ) , name ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> public interface InternalLogger { </a> 0
<a> boolean isTraceEnabled ( ) ; </a> 0
<a> boolean isDebugEnabled ( ) ; </a> 0
<a> boolean isInfoEnabled ( ) ; </a> 0
<a> boolean isWarnEnabled ( ) ; </a> 0
<a> boolean isErrorEnabled ( ) ; </a> 0
<a> boolean isEnabled ( InternalLogLevel level ) ; </a> 0
<a> void trace ( String msg ) ; </a> 0
<a> void trace ( String msg , Throwable cause ) ; </a> 0
<a> void debug ( String msg ) ; </a> 0
<a> void debug ( String msg , Throwable cause ) ; </a> 0
<a> void info ( String msg ) ; </a> 0
<a> void info ( String msg , Throwable cause ) ; </a> 0
<a> void warn ( String msg ) ; </a> 0
<a> void warn ( String msg , Throwable cause ) ; </a> 0
<a> void error ( String msg ) ; </a> 0
<a> void error ( String msg , Throwable cause ) ; </a> 0
<a> void log ( InternalLogLevel level , String msg ) ; </a> 0
<a> void log ( InternalLogLevel level , String msg , Throwable cause ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> public abstract class InternalLoggerFactory { </a> 0
<a> private static volatile InternalLoggerFactory defaultFactory = new JdkLoggerFactory ( ) ; </a> 0
<a> public static InternalLoggerFactory getDefaultFactory ( ) { </a> 0
<a> return defaultFactory ; </a> 0
<a> } </a> 0
<a> public static void setDefaultFactory ( InternalLoggerFactory defaultFactory ) { </a> 0
<a> if ( defaultFactory == null ) { </a> 0
<a> throw new NullPointerException ( "defaultFactory" ) ; </a> 0
<a> } </a> 0
<a> InternalLoggerFactory . defaultFactory = defaultFactory ; </a> 0
<a> } </a> 0
<a> public static InternalLogger getInstance ( Class < ? > clazz ) { </a> 0
<a> return getInstance ( clazz . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> public static InternalLogger getInstance ( String name ) { </a> 0
<a> final InternalLogger logger = getDefaultFactory ( ) . newInstance ( name ) ; </a> 0
<a> return new InternalLogger ( ) { </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg ) { </a> 0
<a> logger . trace ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg , Throwable cause ) { </a> 0
<a> logger . trace ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg ) { </a> 0
<a> logger . debug ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg , Throwable cause ) { </a> 0
<a> logger . debug ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg ) { </a> 0
<a> logger . error ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg , Throwable cause ) { </a> 0
<a> logger . error ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg ) { </a> 0
<a> logger . info ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg , Throwable cause ) { </a> 0
<a> logger . info ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isTraceEnabled ( ) { </a> 0
<a> return logger . isTraceEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDebugEnabled ( ) { </a> 0
<a> return logger . isDebugEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isErrorEnabled ( ) { </a> 0
<a> return logger . isErrorEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isInfoEnabled ( ) { </a> 0
<a> return logger . isInfoEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isWarnEnabled ( ) { </a> 0
<a> return logger . isWarnEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg ) { </a> 0
<a> logger . warn ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg , Throwable cause ) { </a> 0
<a> logger . warn ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEnabled ( InternalLogLevel level ) { </a> 0
<a> return logger . isEnabled ( level ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void log ( InternalLogLevel level , String msg ) { </a> 0
<a> logger . log ( level , msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void log ( InternalLogLevel level , String msg , Throwable cause ) { </a> 0
<a> logger . log ( level , msg , cause ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } </a> 0
<a> public abstract InternalLogger newInstance ( String name ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import org . jboss . logging . Logger ; </a> 0
<a> class JBossLogger extends AbstractInternalLogger { </a> 0
<a> private final Logger logger ; </a> 0
<a> JBossLogger ( Logger logger ) { </a> 0
<a> this . logger = logger ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg ) { </a> 0
<a> logger . trace ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg , Throwable cause ) { </a> 0
<a> logger . trace ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg ) { </a> 0
<a> logger . debug ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg , Throwable cause ) { </a> 0
<a> logger . debug ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg ) { </a> 0
<a> logger . error ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg , Throwable cause ) { </a> 0
<a> logger . error ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg ) { </a> 0
<a> logger . info ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg , Throwable cause ) { </a> 0
<a> logger . info ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isTraceEnabled ( ) { </a> 0
<a> return logger . isTraceEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public boolean isDebugEnabled ( ) { </a> 0
<a> return logger . isDebugEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isErrorEnabled ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public boolean isInfoEnabled ( ) { </a> 0
<a> return logger . isInfoEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isWarnEnabled ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg ) { </a> 0
<a> logger . warn ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg , Throwable cause ) { </a> 0
<a> logger . warn ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return String . valueOf ( logger . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import java . util . logging . Level ; </a> 0
<a> import java . util . logging . Logger ; </a> 0
<a> class JdkLogger extends AbstractInternalLogger { </a> 0
<a> private final Logger logger ; </a> 0
<a> private final String loggerName ; </a> 0
<a> JdkLogger ( Logger logger , String loggerName ) { </a> 0
<a> this . logger = logger ; </a> 0
<a> this . loggerName = loggerName ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg ) { </a> 0
<a> logger . logp ( Level . FINEST , loggerName , null , msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg , Throwable cause ) { </a> 0
<a> logger . logp ( Level . FINEST , loggerName , null , msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg ) { </a> 0
<a> logger . logp ( Level . FINE , loggerName , null , msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg , Throwable cause ) { </a> 0
<a> logger . logp ( Level . FINE , loggerName , null , msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg ) { </a> 0
<a> logger . logp ( Level . SEVERE , loggerName , null , msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg , Throwable cause ) { </a> 0
<a> logger . logp ( Level . SEVERE , loggerName , null , msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg ) { </a> 0
<a> logger . logp ( Level . INFO , loggerName , null , msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg , Throwable cause ) { </a> 0
<a> logger . logp ( Level . INFO , loggerName , null , msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isTraceEnabled ( ) { </a> 0
<a> return logger . isLoggable ( Level . FINEST ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDebugEnabled ( ) { </a> 0
<a> return logger . isLoggable ( Level . FINE ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isErrorEnabled ( ) { </a> 0
<a> return logger . isLoggable ( Level . SEVERE ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isInfoEnabled ( ) { </a> 0
<a> return logger . isLoggable ( Level . INFO ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isWarnEnabled ( ) { </a> 0
<a> return logger . isLoggable ( Level . WARNING ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg ) { </a> 0
<a> logger . logp ( Level . WARNING , loggerName , null , msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg , Throwable cause ) { </a> 0
<a> logger . logp ( Level . WARNING , loggerName , null , msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return loggerName ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> public class JdkLoggerFactory extends InternalLoggerFactory { </a> 0
<a> @ Override </a> 0
<a> public InternalLogger newInstance ( String name ) { </a> 0
<a> final java . util . logging . Logger logger = </a> 0
<a> java . util . logging . Logger . getLogger ( name ) ; </a> 0
<a> return new JdkLogger ( logger , name ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import org . apache . log4j . Logger ; </a> 0
<a> class Log4JLogger extends AbstractInternalLogger { </a> 0
<a> private final Logger logger ; </a> 0
<a> Log4JLogger ( Logger logger ) { </a> 0
<a> this . logger = logger ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg ) { </a> 0
<a> logger . trace ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg , Throwable cause ) { </a> 0
<a> logger . trace ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg ) { </a> 0
<a> logger . debug ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg , Throwable cause ) { </a> 0
<a> logger . debug ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg ) { </a> 0
<a> logger . error ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg , Throwable cause ) { </a> 0
<a> logger . error ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg ) { </a> 0
<a> logger . info ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg , Throwable cause ) { </a> 0
<a> logger . info ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isTraceEnabled ( ) { </a> 0
<a> return logger . isTraceEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDebugEnabled ( ) { </a> 0
<a> return logger . isDebugEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isErrorEnabled ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isInfoEnabled ( ) { </a> 0
<a> return logger . isInfoEnabled ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isWarnEnabled ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg ) { </a> 0
<a> logger . warn ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg , Throwable cause ) { </a> 0
<a> logger . warn ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return String . valueOf ( logger . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> public class Log4JLoggerFactory extends InternalLoggerFactory { </a> 0
<a> @ Override </a> 0
<a> public InternalLogger newInstance ( String name ) { </a> 0
<a> final org . apache . log4j . Logger logger = </a> 0
<a> org . apache . log4j . Logger . getLogger ( name ) ; </a> 0
<a> return new Log4JLogger ( logger ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import org . osgi . service . log . LogService ; </a> 0
<a> class OsgiLogger extends AbstractInternalLogger { </a> 0
<a> private final OsgiLoggerFactory parent ; </a> 0
<a> private final InternalLogger fallback ; </a> 0
<a> private final String name ; </a> 0
<a> private final String prefix ; </a> 0
<a> OsgiLogger ( OsgiLoggerFactory parent , String name , InternalLogger fallback ) { </a> 0
<a> this . parent = parent ; </a> 0
<a> this . name = name ; </a> 0
<a> this . fallback = fallback ; </a> 0
<a> prefix = "[" + name + "] " ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void trace ( String msg , Throwable cause ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg ) { </a> 0
<a> LogService logService = parent . getLogService ( ) ; </a> 0
<a> if ( logService != null ) { </a> 0
<a> logService . log ( LogService . LOG_DEBUG , prefix + msg ) ; </a> 0
<a> } else { </a> 0
<a> fallback . debug ( msg ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void debug ( String msg , Throwable cause ) { </a> 0
<a> LogService logService = parent . getLogService ( ) ; </a> 0
<a> if ( logService != null ) { </a> 0
<a> logService . log ( LogService . LOG_DEBUG , prefix + msg , cause ) ; </a> 0
<a> } else { </a> 0
<a> fallback . debug ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg ) { </a> 0
<a> LogService logService = parent . getLogService ( ) ; </a> 0
<a> if ( logService != null ) { </a> 0
<a> logService . log ( LogService . LOG_ERROR , prefix + msg ) ; </a> 0
<a> } else { </a> 0
<a> fallback . error ( msg ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void error ( String msg , Throwable cause ) { </a> 0
<a> LogService logService = parent . getLogService ( ) ; </a> 0
<a> if ( logService != null ) { </a> 0
<a> logService . log ( LogService . LOG_ERROR , prefix + msg , cause ) ; </a> 0
<a> } else { </a> 0
<a> fallback . error ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg ) { </a> 0
<a> LogService logService = parent . getLogService ( ) ; </a> 0
<a> if ( logService != null ) { </a> 0
<a> logService . log ( LogService . LOG_INFO , prefix + msg ) ; </a> 0
<a> } else { </a> 0
<a> fallback . info ( msg ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void info ( String msg , Throwable cause ) { </a> 0
<a> LogService logService = parent . getLogService ( ) ; </a> 0
<a> if ( logService != null ) { </a> 0
<a> logService . log ( LogService . LOG_INFO , prefix + msg , cause ) ; </a> 0
<a> } else { </a> 0
<a> fallback . info ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isTraceEnabled ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDebugEnabled ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isErrorEnabled ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isInfoEnabled ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isWarnEnabled ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg ) { </a> 0
<a> LogService logService = parent . getLogService ( ) ; </a> 0
<a> if ( logService != null ) { </a> 0
<a> logService . log ( LogService . LOG_WARNING , prefix + msg ) ; </a> 0
<a> } else { </a> 0
<a> fallback . warn ( msg ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void warn ( String msg , Throwable cause ) { </a> 0
<a> LogService logService = parent . getLogService ( ) ; </a> 0
<a> if ( logService != null ) { </a> 0
<a> logService . log ( LogService . LOG_WARNING , prefix + msg , cause ) ; </a> 0
<a> } else { </a> 0
<a> fallback . warn ( msg , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return name ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import org . osgi . framework . BundleContext ; </a> 0
<a> import org . osgi . framework . ServiceReference ; </a> 0
<a> import org . osgi . service . log . LogService ; </a> 0
<a> import org . osgi . util . tracker . ServiceTracker ; </a> 0
<a> public class OsgiLoggerFactory extends InternalLoggerFactory { </a> 0
<a> private final ServiceTracker logServiceTracker ; </a> 1
<a> private final InternalLoggerFactory fallback ; </a> 0
<a> volatile LogService logService ; </a> 0
<a> public OsgiLoggerFactory ( BundleContext ctx ) { </a> 0
<a> this ( ctx , null ) ; </a> 0
<a> } </a> 0
<a> public OsgiLoggerFactory ( BundleContext ctx , InternalLoggerFactory fallback ) { </a> 0
<a> if ( ctx == null ) { </a> 0
<a> throw new NullPointerException ( "ctx" ) ; </a> 0
<a> } </a> 0
<a> if ( fallback == null ) { </a> 0
<a> fallback = InternalLoggerFactory . getDefaultFactory ( ) ; </a> 0
<a> if ( fallback instanceof OsgiLoggerFactory ) { </a> 0
<a> fallback = new JdkLoggerFactory ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> this . fallback = fallback ; </a> 0
<a> logServiceTracker = new ServiceTracker ( </a> 1
<a> ctx , "org.osgi.service.log.LogService" , null ) { </a> 0
<a> @ Override </a> 0
<a> public Object addingService ( ServiceReference reference ) { </a> 1
<a> LogService service = ( LogService ) super . addingService ( reference ) ; </a> 1
<a> logService = service ; </a> 0
<a> return service ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void removedService ( ServiceReference reference , </a> 1
<a> Object service ) { </a> 1
<a> logService = null ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> logServiceTracker . open ( ) ; </a> 0
<a> } </a> 0
<a> public InternalLoggerFactory getFallback ( ) { </a> 0
<a> return fallback ; </a> 0
<a> } </a> 0
<a> public LogService getLogService ( ) { </a> 0
<a> return logService ; </a> 0
<a> } </a> 0
<a> public void destroy ( ) { </a> 0
<a> logService = null ; </a> 0
<a> logServiceTracker . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public InternalLogger newInstance ( String name ) { </a> 0
<a> return new OsgiLogger ( this , name , fallback . newInstance ( name ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> public interface Attribute < T > { </a> 0
<a> T get ( ) ; </a> 0
<a> void set ( T value ) ; </a> 0
<a> T getAndSet ( T value ) ; </a> 0
<a> T setIfAbsent ( T value ) ; </a> 0
<a> boolean compareAndSet ( T oldValue , T newValue ) ; </a> 0
<a> void remove ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import java . util . concurrent . ConcurrentMap ; </a> 1
<a> public final class AttributeKey < T > extends UniqueName { </a> 1
<a> private static final ConcurrentMap < String , Boolean > names = new ConcurrentHashMap < String , Boolean > ( ) ; </a> 1
<a> public AttributeKey ( String name ) { </a> 1
<a> super ( names , name ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> public interface AttributeMap { </a> 0
<a> < T > Attribute < T > attr ( AttributeKey < T > key ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> import java . nio . charset . Charset ; </a> 0
<a> import java . nio . charset . CharsetDecoder ; </a> 0
<a> import java . nio . charset . CharsetEncoder ; </a> 0
<a> import java . nio . charset . CodingErrorAction ; </a> 0
<a> import java . util . IdentityHashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public final class CharsetUtil { </a> 0
<a> public static final Charset UTF_16 = Charset . forName ( "UTF-16" ) ; </a> 0
<a> public static final Charset UTF_16BE = Charset . forName ( "UTF-16BE" ) ; </a> 0
<a> public static final Charset UTF_16LE = Charset . forName ( "UTF-16LE" ) ; </a> 0
<a> public static final Charset UTF_8 = Charset . forName ( "UTF-8" ) ; </a> 0
<a> public static final Charset ISO_8859_1 = Charset . forName ( "ISO-8859-1" ) ; </a> 0
<a> public static final Charset US_ASCII = Charset . forName ( "US-ASCII" ) ; </a> 0
<a> private static final ThreadLocal < Map < Charset , CharsetEncoder > > encoders = </a> 0
<a> new ThreadLocal < Map < Charset , CharsetEncoder > > ( ) { </a> 1
<a> @ Override </a> 0
<a> protected Map < Charset , CharsetEncoder > initialValue ( ) { </a> 0
<a> return new IdentityHashMap < Charset , CharsetEncoder > ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private static final ThreadLocal < Map < Charset , CharsetDecoder > > decoders = </a> 0
<a> new ThreadLocal < Map < Charset , CharsetDecoder > > ( ) { </a> 1
<a> @ Override </a> 0
<a> protected Map < Charset , CharsetDecoder > initialValue ( ) { </a> 0
<a> return new IdentityHashMap < Charset , CharsetDecoder > ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> public static CharsetEncoder getEncoder ( Charset charset ) { </a> 0
<a> if ( charset == null ) { </a> 0
<a> throw new NullPointerException ( "charset" ) ; </a> 0
<a> } </a> 0
<a> Map < Charset , CharsetEncoder > map = encoders . get ( ) ; </a> 0
<a> CharsetEncoder e = map . get ( charset ) ; </a> 0
<a> if ( e != null ) { </a> 0
<a> e . reset ( ) ; </a> 0
<a> e . onMalformedInput ( CodingErrorAction . REPLACE ) ; </a> 0
<a> e . onUnmappableCharacter ( CodingErrorAction . REPLACE ) ; </a> 0
<a> return e ; </a> 0
<a> } </a> 0
<a> e = charset . newEncoder ( ) ; </a> 0
<a> e . onMalformedInput ( CodingErrorAction . REPLACE ) ; </a> 0
<a> e . onUnmappableCharacter ( CodingErrorAction . REPLACE ) ; </a> 0
<a> map . put ( charset , e ) ; </a> 0
<a> return e ; </a> 0
<a> } </a> 0
<a> public static CharsetDecoder getDecoder ( Charset charset ) { </a> 0
<a> if ( charset == null ) { </a> 0
<a> throw new NullPointerException ( "charset" ) ; </a> 0
<a> } </a> 0
<a> Map < Charset , CharsetDecoder > map = decoders . get ( ) ; </a> 0
<a> CharsetDecoder d = map . get ( charset ) ; </a> 0
<a> if ( d != null ) { </a> 0
<a> d . reset ( ) ; </a> 0
<a> d . onMalformedInput ( CodingErrorAction . REPLACE ) ; </a> 0
<a> d . onUnmappableCharacter ( CodingErrorAction . REPLACE ) ; </a> 0
<a> return d ; </a> 0
<a> } </a> 0
<a> d = charset . newDecoder ( ) ; </a> 0
<a> d . onMalformedInput ( CodingErrorAction . REPLACE ) ; </a> 0
<a> d . onUnmappableCharacter ( CodingErrorAction . REPLACE ) ; </a> 0
<a> map . put ( charset , d ) ; </a> 0
<a> return d ; </a> 0
<a> } </a> 0
<a> private CharsetUtil ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> import java . util . IdentityHashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 0
<a> public class DefaultAttributeMap implements AttributeMap { </a> 0
<a> private Map < AttributeKey < ? > , Attribute < ? > > map ; </a> 1
<a> @ Override </a> 0
<a> public synchronized < T > Attribute < T > attr ( AttributeKey < T > key ) { </a> 1
<a> Map < AttributeKey < ? > , Attribute < ? > > map = this . map ; </a> 0
<a> if ( map == null ) { </a> 0
<a> map = this . map = new IdentityHashMap < AttributeKey < ? > , Attribute < ? > > ( 2 ) ; </a> 1
<a> } </a> 0
<a> Attribute < T > attr = ( Attribute < T > ) map . get ( key ) ; </a> 0
<a> if ( attr == null ) { </a> 0
<a> attr = new DefaultAttribute < T > ( ) ; </a> 1
<a> map . put ( key , attr ) ; </a> 0
<a> } </a> 0
<a> return attr ; </a> 0
<a> } </a> 0
<a> private class DefaultAttribute < T > extends AtomicReference < T > implements Attribute < T > { </a> 0
<a> private static final long serialVersionUID = - 2661411462200283011L ; </a> 0
<a> @ Override </a> 0
<a> public T setIfAbsent ( T value ) { </a> 0
<a> if ( compareAndSet ( null , value ) ) { </a> 1
<a> return null ; </a> 0
<a> } else { </a> 1
<a> return get ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void remove ( ) { </a> 0
<a> set ( null ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . util . internal . DetectionUtil ; </a> 1
<a> import io . netty . util . internal . SharedResourceMisuseDetector ; </a> 1
<a> import java . util . ArrayList ; </a> 1
<a> import java . util . Collections ; </a> 0
<a> import java . util . HashSet ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . List ; </a> 1
<a> import java . util . Set ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import java . util . concurrent . Executors ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 1
<a> import java . util . concurrent . locks . ReadWriteLock ; </a> 1
<a> import java . util . concurrent . locks . ReentrantReadWriteLock ; </a> 1
<a> public class HashedWheelTimer implements Timer { </a> 0
<a> static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( HashedWheelTimer . class ) ; </a> 0
<a> private static final SharedResourceMisuseDetector misuseDetector = </a> 1
<a> new SharedResourceMisuseDetector ( HashedWheelTimer . class ) ; </a> 1
<a> private final Worker worker = new Worker ( ) ; </a> 0
<a> final Thread workerThread ; </a> 1
<a> final AtomicBoolean shutdown = new AtomicBoolean ( ) ; </a> 0
<a> private final long roundDuration ; </a> 1
<a> final long tickDuration ; </a> 1
<a> final Set < HashedWheelTimeout > [ ] wheel ; </a> 1
<a> final int mask ; </a> 1
<a> final ReadWriteLock lock = new ReentrantReadWriteLock ( ) ; </a> 1
<a> volatile int wheelCursor ; </a> 1
<a> public HashedWheelTimer ( ) { </a> 0
<a> this ( Executors . defaultThreadFactory ( ) ) ; </a> 0
<a> } </a> 0
<a> public HashedWheelTimer ( long tickDuration , TimeUnit unit ) { </a> 0
<a> this ( Executors . defaultThreadFactory ( ) , tickDuration , unit ) ; </a> 0
<a> } </a> 0
<a> public HashedWheelTimer ( long tickDuration , TimeUnit unit , int ticksPerWheel ) { </a> 0
<a> this ( Executors . defaultThreadFactory ( ) , tickDuration , unit , ticksPerWheel ) ; </a> 0
<a> } </a> 0
<a> public HashedWheelTimer ( ThreadFactory threadFactory ) { </a> 0
<a> this ( threadFactory , 100 , TimeUnit . MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> public HashedWheelTimer ( </a> 0
<a> ThreadFactory threadFactory , long tickDuration , TimeUnit unit ) { </a> 0
<a> this ( threadFactory , tickDuration , unit , 512 ) ; </a> 0
<a> } </a> 0
<a> public HashedWheelTimer ( </a> 0
<a> ThreadFactory threadFactory , </a> 0
<a> long tickDuration , TimeUnit unit , int ticksPerWheel ) { </a> 0
<a> if ( threadFactory == null ) { </a> 0
<a> throw new NullPointerException ( "threadFactory" ) ; </a> 0
<a> } </a> 0
<a> if ( unit == null ) { </a> 0
<a> throw new NullPointerException ( "unit" ) ; </a> 0
<a> } </a> 0
<a> if ( tickDuration <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 1
<a> "tickDuration must be greater than 0: " + tickDuration ) ; </a> 1
<a> } </a> 0
<a> if ( ticksPerWheel <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 1
<a> "ticksPerWheel must be greater than 0: " + ticksPerWheel ) ; </a> 1
<a> } </a> 0
<a> wheel = createWheel ( ticksPerWheel ) ; </a> 0
<a> mask = wheel . length - 1 ; </a> 0
<a> this . tickDuration = tickDuration = unit . toMillis ( tickDuration ) ; </a> 0
<a> if ( tickDuration == Long . MAX_VALUE || </a> 1
<a> tickDuration >= Long . MAX_VALUE / wheel . length ) { </a> 1
<a> throw new IllegalArgumentException ( </a> 1
<a> "tickDuration is too long: " + </a> 1
<a> tickDuration + ' ' + unit ) ; </a> 1
<a> } </a> 0
<a> roundDuration = tickDuration * wheel . length ; </a> 1
<a> workerThread = threadFactory . newThread ( worker ) ; </a> 1
<a> misuseDetector . increase ( ) ; </a> 1
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 1
<a> private static Set < HashedWheelTimeout > [ ] createWheel ( int ticksPerWheel ) { </a> 1
<a> if ( ticksPerWheel <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "ticksPerWheel must be greater than 0: " + ticksPerWheel ) ; </a> 0
<a> } </a> 0
<a> if ( ticksPerWheel > 1073741824 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "ticksPerWheel may not be greater than 2^30: " + ticksPerWheel ) ; </a> 0
<a> } </a> 0
<a> ticksPerWheel = normalizeTicksPerWheel ( ticksPerWheel ) ; </a> 0
<a> Set < HashedWheelTimeout > [ ] wheel = new Set [ ticksPerWheel ] ; </a> 1
<a> for ( int i = 0 ; i < wheel . length ; i ++ ) { </a> 0
<a> wheel [ i ] = Collections . newSetFromMap ( </a> 1
<a> new ConcurrentHashMap < HashedWheelTimeout , Boolean > ( 16 , 0.95f , 4 ) ) ; </a> 1
<a> } </a> 0
<a> return wheel ; </a> 0
<a> } </a> 0
<a> private static int normalizeTicksPerWheel ( int ticksPerWheel ) { </a> 0
<a> int normalizedTicksPerWheel = 1 ; </a> 0
<a> while ( normalizedTicksPerWheel < ticksPerWheel ) { </a> 0
<a> normalizedTicksPerWheel <<= 1 ; </a> 0
<a> } </a> 0
<a> return normalizedTicksPerWheel ; </a> 0
<a> } </a> 0
<a> public synchronized void start ( ) { </a> 0
<a> if ( shutdown . get ( ) ) { </a> 0
<a> throw new IllegalStateException ( "cannot be started once stopped" ) ; </a> 0
<a> } </a> 0
<a> if ( ! workerThread . isAlive ( ) ) { </a> 0
<a> workerThread . start ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized Set < Timeout > stop ( ) { </a> 0
<a> if ( Thread . currentThread ( ) == workerThread ) { </a> 0
<a> throw new IllegalStateException ( </a> 0
<a> HashedWheelTimer . class . getSimpleName ( ) + </a> 0
<a> ".stop() cannot be called from " + </a> 0
<a> TimerTask . class . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( ! shutdown . compareAndSet ( false , true ) ) { </a> 0
<a> return Collections . emptySet ( ) ; </a> 0
<a> } </a> 0
<a> boolean interrupted = false ; </a> 0
<a> while ( workerThread . isAlive ( ) ) { </a> 0
<a> workerThread . interrupt ( ) ; </a> 0
<a> try { </a> 0
<a> workerThread . join ( 100 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 1
<a> interrupted = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( interrupted ) { </a> 0
<a> Thread . currentThread ( ) . interrupt ( ) ; </a> 0
<a> } </a> 0
<a> misuseDetector . decrease ( ) ; </a> 1
<a> Set < Timeout > unprocessedTimeouts = new HashSet < Timeout > ( ) ; </a> 1
<a> for ( Set < HashedWheelTimeout > bucket : wheel ) { </a> 1
<a> unprocessedTimeouts . addAll ( bucket ) ; </a> 1
<a> bucket . clear ( ) ; </a> 1
<a> } </a> 1
<a> return Collections . unmodifiableSet ( unprocessedTimeouts ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Timeout newTimeout ( TimerTask task , long delay , TimeUnit unit ) { </a> 0
<a> final long currentTime = System . currentTimeMillis ( ) ; </a> 1
<a> if ( task == null ) { </a> 0
<a> throw new NullPointerException ( "task" ) ; </a> 0
<a> } </a> 0
<a> if ( unit == null ) { </a> 0
<a> throw new NullPointerException ( "unit" ) ; </a> 0
<a> } </a> 0
<a> if ( ! workerThread . isAlive ( ) ) { </a> 0
<a> start ( ) ; </a> 1
<a> } </a> 0
<a> delay = unit . toMillis ( delay ) ; </a> 1
<a> HashedWheelTimeout timeout = new HashedWheelTimeout ( task , currentTime + delay ) ; </a> 1
<a> scheduleTimeout ( timeout , delay ) ; </a> 1
<a> return timeout ; </a> 1
<a> } </a> 0
<a> void scheduleTimeout ( HashedWheelTimeout timeout , long delay ) { </a> 1
<a> if ( delay < tickDuration ) { </a> 1
<a> delay = tickDuration ; </a> 1
<a> } </a> 1
<a> final long lastRoundDelay = delay % roundDuration ; </a> 1
<a> final long lastTickDelay = delay % tickDuration ; </a> 1
<a> final long relativeIndex = </a> 1
<a> lastRoundDelay / tickDuration + ( lastTickDelay != 0 ? 1 : 0 ) ; </a> 1
<a> final long remainingRounds = </a> 1
<a> delay / roundDuration - ( delay % roundDuration == 0 ? 1 : 0 ) ; </a> 1
<a> lock . readLock ( ) . lock ( ) ; </a> 1
<a> try { </a> 1
<a> int stopIndex = ( int ) ( wheelCursor + relativeIndex & mask ) ; </a> 1
<a> timeout . stopIndex = stopIndex ; </a> 1
<a> timeout . remainingRounds = remainingRounds ; </a> 1
<a> wheel [ stopIndex ] . add ( timeout ) ; </a> 1
<a> } finally { </a> 0
<a> lock . readLock ( ) . unlock ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final class Worker implements Runnable { </a> 0
<a> private long startTime ; </a> 1
<a> private long tick ; </a> 1
<a> Worker ( ) { </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> List < HashedWheelTimeout > expiredTimeouts = </a> 1
<a> new ArrayList < HashedWheelTimeout > ( ) ; </a> 1
<a> startTime = System . currentTimeMillis ( ) ; </a> 1
<a> tick = 1 ; </a> 1
<a> while ( ! shutdown . get ( ) ) { </a> 0
<a> final long deadline = waitForNextTick ( ) ; </a> 0
<a> if ( deadline > 0 ) { </a> 1
<a> fetchExpiredTimeouts ( expiredTimeouts , deadline ) ; </a> 1
<a> notifyExpiredTimeouts ( expiredTimeouts ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private void fetchExpiredTimeouts ( </a> 1
<a> List < HashedWheelTimeout > expiredTimeouts , long deadline ) { </a> 1
<a> lock . writeLock ( ) . lock ( ) ; </a> 1
<a> try { </a> 1
<a> int newWheelCursor = wheelCursor = wheelCursor + 1 & mask ; </a> 1
<a> fetchExpiredTimeouts ( expiredTimeouts , wheel [ newWheelCursor ] . iterator ( ) , deadline ) ; </a> 0
<a> } finally { </a> 1
<a> lock . writeLock ( ) . unlock ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> private void fetchExpiredTimeouts ( </a> 1
<a> List < HashedWheelTimeout > expiredTimeouts , </a> 1
<a> Iterator < HashedWheelTimeout > i , long deadline ) { </a> 0
<a> List < HashedWheelTimeout > slipped = null ; </a> 1
<a> while ( i . hasNext ( ) ) { </a> 1
<a> HashedWheelTimeout timeout = i . next ( ) ; </a> 1
<a> if ( timeout . remainingRounds <= 0 ) { </a> 1
<a> i . remove ( ) ; </a> 1
<a> if ( timeout . deadline <= deadline ) { </a> 1
<a> expiredTimeouts . add ( timeout ) ; </a> 1
<a> } else { </a> 1
<a> if ( slipped == null ) { </a> 1
<a> slipped = new ArrayList < HashedWheelTimer . HashedWheelTimeout > ( ) ; </a> 0
<a> } </a> 1
<a> slipped . add ( timeout ) ; </a> 1
<a> } </a> 0
<a> } else { </a> 1
<a> timeout . remainingRounds -- ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> if ( slipped != null ) { </a> 1
<a> for ( HashedWheelTimeout timeout : slipped ) { </a> 1
<a> scheduleTimeout ( timeout , timeout . deadline - deadline ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<a> private void notifyExpiredTimeouts ( </a> 1
<a> List < HashedWheelTimeout > expiredTimeouts ) { </a> 1
<a> for ( int i = expiredTimeouts . size ( ) - 1 ; i >= 0 ; i -- ) { </a> 1
<a> expiredTimeouts . get ( i ) . expire ( ) ; </a> 1
<a> } </a> 0
<a> expiredTimeouts . clear ( ) ; </a> 1
<a> } </a> 0
<a> private long waitForNextTick ( ) { </a> 0
<a> long deadline = startTime + tickDuration * tick ; </a> 1
<a> for ( ; ; ) { </a> 0
<a> final long currentTime = System . currentTimeMillis ( ) ; </a> 1
<a> long sleepTime = tickDuration * tick - ( currentTime - startTime ) ; </a> 1
<a> if ( DetectionUtil . isWindows ( ) ) { </a> 1
<a> sleepTime = sleepTime / 10 * 10 ; </a> 1
<a> } </a> 1
<a> if ( sleepTime <= 0 ) { </a> 1
<a> break ; </a> 1
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( sleepTime ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> if ( shutdown . get ( ) ) { </a> 0
<a> return - 1 ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> tick ++ ; </a> 1
<a> return deadline ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private final class HashedWheelTimeout implements Timeout { </a> 1
<a> private static final int ST_INIT = 0 ; </a> 0
<a> private static final int ST_CANCELLED = 1 ; </a> 0
<a> private static final int ST_EXPIRED = 2 ; </a> 0
<a> private final TimerTask task ; </a> 0
<a> final long deadline ; </a> 1
<a> volatile int stopIndex ; </a> 1
<a> volatile long remainingRounds ; </a> 1
<a> private final AtomicInteger state = new AtomicInteger ( ST_INIT ) ; </a> 1
<a> HashedWheelTimeout ( TimerTask task , long deadline ) { </a> 1
<a> this . task = task ; </a> 0
<a> this . deadline = deadline ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Timer getTimer ( ) { </a> 0
<a> return HashedWheelTimer . this ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public TimerTask getTask ( ) { </a> 0
<a> return task ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean cancel ( ) { </a> 0
<a> if ( ! state . compareAndSet ( ST_INIT , ST_CANCELLED ) ) { </a> 1
<a> return false ; </a> 0
<a> } </a> 0
<a> wheel [ stopIndex ] . remove ( this ) ; </a> 1
<a> return true ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public boolean isCancelled ( ) { </a> 0
<a> return state . get ( ) == ST_CANCELLED ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isExpired ( ) { </a> 0
<a> return state . get ( ) != ST_INIT ; </a> 1
<a> } </a> 0
<a> public void expire ( ) { </a> 0
<a> if ( ! state . compareAndSet ( ST_INIT , ST_EXPIRED ) ) { </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> task . run ( this ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( </a> 0
<a> "An exception was thrown by " + </a> 0
<a> TimerTask . class . getSimpleName ( ) + "." , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> long currentTime = System . currentTimeMillis ( ) ; </a> 1
<a> long remaining = deadline - currentTime ; </a> 1
<a> StringBuilder buf = new StringBuilder ( 192 ) ; </a> 1
<a> buf . append ( getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> buf . append ( '(' ) ; </a> 1
<a> buf . append ( "deadline: " ) ; </a> 1
<a> if ( remaining > 0 ) { </a> 0
<a> buf . append ( remaining ) ; </a> 1
<a> buf . append ( " ms later, " ) ; </a> 1
<a> } else if ( remaining < 0 ) { </a> 0
<a> buf . append ( - remaining ) ; </a> 1
<a> buf . append ( " ms ago, " ) ; </a> 1
<a> } else { </a> 0
<a> buf . append ( "now, " ) ; </a> 1
<a> } </a> 0
<a> if ( isCancelled ( ) ) { </a> 0
<a> buf . append ( ", cancelled" ) ; </a> 0
<a> } </a> 0
<a> return buf . append ( ')' ) . toString ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . io . BufferedReader ; </a> 0
<a> import java . io . FileReader ; </a> 0
<a> import java . net . InetAddress ; </a> 0
<a> import java . net . NetworkInterface ; </a> 0
<a> import java . net . SocketException ; </a> 0
<a> import java . net . UnknownHostException ; </a> 0
<a> import java . util . Enumeration ; </a> 0
<a> public final class NetworkConstants { </a> 0
<a> public static final InetAddress LOCALHOST ; </a> 0
<a> public static final NetworkInterface LOOPBACK_IF ; </a> 0
<a> public static final int SOMAXCONN ; </a> 0
<a> private static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( NetworkConstants . class ) ; </a> 0
<a> static { </a> 0
<a> InetAddress localhost = null ; </a> 0
<a> try { </a> 0
<a> localhost = InetAddress . getLocalHost ( ) ; </a> 0
<a> } catch ( UnknownHostException e ) { </a> 0
<a> try { </a> 1
<a> localhost = InetAddress . getByAddress ( new byte [ ] { 127 , 0 , 0 , 1 } ) ; </a> 1
<a> } catch ( UnknownHostException e1 ) { </a> 0
<a> try { </a> 1
<a> localhost = InetAddress . getByAddress ( </a> 0
<a> new byte [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } ) ; </a> 0
<a> } catch ( UnknownHostException e2 ) { </a> 0
<a> logger . error ( "Failed to resolve localhost - Incorrect network configuration?" , e2 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> LOCALHOST = localhost ; </a> 0
<a> NetworkInterface loopbackInterface ; </a> 0
<a> try { </a> 0
<a> loopbackInterface = NetworkInterface . getByInetAddress ( LOCALHOST ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 1
<a> loopbackInterface = null ; </a> 0
<a> } </a> 0
<a> if ( loopbackInterface == null ) { </a> 0
<a> try { </a> 0
<a> for ( Enumeration < NetworkInterface > interfaces = NetworkInterface . getNetworkInterfaces ( ) ; </a> 0
<a> interfaces . hasMoreElements ( ) ; ) { </a> 0
<a> NetworkInterface networkInterface = interfaces . nextElement ( ) ; </a> 0
<a> if ( networkInterface . isLoopback ( ) ) { </a> 0
<a> loopbackInterface = networkInterface ; </a> 0
<a> break ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> logger . error ( "Failed to enumerate network interfaces" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> LOOPBACK_IF = loopbackInterface ; </a> 0
<a> int somaxconn = 3072 ; </a> 0
<a> BufferedReader in = null ; </a> 0
<a> try { </a> 0
<a> in = new BufferedReader ( new FileReader ( "/proc/sys/net/core/somaxconn" ) ) ; </a> 0
<a> somaxconn = Integer . parseInt ( in . readLine ( ) ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> } finally { </a> 0
<a> if ( in != null ) { </a> 0
<a> try { </a> 0
<a> in . close ( ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> SOMAXCONN = somaxconn ; </a> 0
<a> } </a> 0
<a> private NetworkConstants ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public interface Timer { </a> 0
<a> Timeout newTimeout ( TimerTask task , long delay , TimeUnit unit ) ; </a> 0
<a> Set < Timeout > stop ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public interface TimerTask { </a> 0
<a> void run ( Timeout timeout ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal ; </a> 0
<a> import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReferenceFieldUpdater ; </a> 0
<a> final class AtomicFieldUpdaterUtil { </a> 0
<a> private static final boolean AVAILABLE ; </a> 0
<a> static final class Node { </a> 0
<a> volatile Node next ; </a> 0
<a> } </a> 0
<a> static { </a> 0
<a> boolean available = false ; </a> 0
<a> try { </a> 0
<a> AtomicReferenceFieldUpdater < Node , Node > tmp = </a> 0
<a> AtomicReferenceFieldUpdater . newUpdater ( </a> 0
<a> Node . class , Node . class , "next" ) ; </a> 0
<a> Node testNode = new Node ( ) ; </a> 0
<a> tmp . set ( testNode , testNode ) ; </a> 0
<a> if ( testNode . next != testNode ) { </a> 0
<a> throw new Exception ( ) ; </a> 0
<a> } </a> 0
<a> available = true ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> } </a> 0
<a> AVAILABLE = available ; </a> 0
<a> } </a> 0
<a> static < T , V > AtomicReferenceFieldUpdater < T , V > newRefUpdater ( Class < T > tclass , Class < V > vclass , String fieldName ) { </a> 0
<a> if ( AVAILABLE ) { </a> 0
<a> return AtomicReferenceFieldUpdater . newUpdater ( tclass , vclass , fieldName ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static < T > AtomicIntegerFieldUpdater < T > newIntUpdater ( Class < T > tclass , String fieldName ) { </a> 0
<a> if ( AVAILABLE ) { </a> 0
<a> return AtomicIntegerFieldUpdater . newUpdater ( tclass , fieldName ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static boolean isAvailable ( ) { </a> 0
<a> return AVAILABLE ; </a> 0
<a> } </a> 0
<a> private AtomicFieldUpdaterUtil ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal ; </a> 0
<a> import java . security . AccessController ; </a> 1
<a> import java . security . PrivilegedActionException ; </a> 1
<a> import java . security . PrivilegedExceptionAction ; </a> 1
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 1
<a> import java . util . zip . Deflater ; </a> 0
<a> public final class DetectionUtil { </a> 1
<a> private static final int JAVA_VERSION = javaVersion0 ( ) ; </a> 1
<a> private static final boolean HAS_UNSAFE = hasUnsafe ( AtomicInteger . class . getClassLoader ( ) ) ; </a> 1
<a> private static final boolean IS_WINDOWS ; </a> 1
<a> static { </a> 1
<a> String os = System . getProperty ( "os.name" ) . toLowerCase ( ) ; </a> 0
<a> IS_WINDOWS = os . contains ( "win" ) ; </a> 1
<a> } </a> 1
<a> public static boolean isWindows ( ) { </a> 1
<a> return IS_WINDOWS ; </a> 1
<a> } </a> 1
<a> public static boolean hasUnsafe ( ) { </a> 1
<a> return HAS_UNSAFE ; </a> 1
<a> } </a> 1
<a> public static int javaVersion ( ) { </a> 1
<a> return JAVA_VERSION ; </a> 1
<a> } </a> 1
<a> private static boolean hasUnsafe ( ClassLoader loader ) { </a> 1
<a> String value = SystemPropertyUtil . get ( "io.netty.noUnsafe" ) ; </a> 0
<a> if ( value != null ) { </a> 0
<a> return false ; </a> 1
<a> } </a> 1
<a> value = SystemPropertyUtil . get ( "io.netty.tryUnsafe" ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> value = SystemPropertyUtil . get ( "org.jboss.netty.tryUnsafe" , "true" ) ; </a> 0
<a> } </a> 1
<a> if ( ! "true" . equalsIgnoreCase ( value ) ) { </a> 0
<a> return false ; </a> 1
<a> } </a> 1
<a> try { </a> 1
<a> Class < ? > unsafeClazz = Class . forName ( "sun.misc.Unsafe" , true , loader ) ; </a> 1
<a> return hasUnsafeField ( unsafeClazz ) ; </a> 1
<a> } catch ( Exception e ) { </a> 1
<a> } </a> 0
<a> return false ; </a> 1
<a> } </a> 0
<a> private static boolean hasUnsafeField ( final Class < ? > unsafeClass ) throws PrivilegedActionException { </a> 1
<a> return AccessController . doPrivileged ( new PrivilegedExceptionAction < Boolean > ( ) { </a> 1
<a> @ Override </a> 1
<a> public Boolean run ( ) throws Exception { </a> 1
<a> unsafeClass . getDeclaredField ( "theUnsafe" ) ; </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> private static int javaVersion0 ( ) { </a> 1
<a> try { </a> 1
<a> Class . forName ( "android.app.Application" , false , ClassLoader . getSystemClassLoader ( ) ) ; </a> 1
<a> return 6 ; </a> 1
<a> } catch ( Exception e ) { </a> 1
<a> } </a> 1
<a> try { </a> 1
<a> Deflater . class . getDeclaredField ( "SYNC_FLUSH" ) ; </a> 0
<a> return 7 ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> } </a> 1
<a> return 6 ; </a> 1
<a> } </a> 1
<a> private DetectionUtil ( ) { </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 1
<a> import java . util . concurrent . atomic . AtomicLong ; </a> 1
<a> public class SharedResourceMisuseDetector { </a> 0
<a> private static final int MAX_ACTIVE_INSTANCES = 256 ; </a> 1
<a> private static final InternalLogger logger = </a> 1
<a> InternalLoggerFactory . getInstance ( SharedResourceMisuseDetector . class ) ; </a> 1
<a> private final Class < ? > type ; </a> 1
<a> private final AtomicLong activeInstances = new AtomicLong ( ) ; </a> 1
<a> private final AtomicBoolean logged = new AtomicBoolean ( ) ; </a> 1
<a> public SharedResourceMisuseDetector ( Class < ? > type ) { </a> 1
<a> if ( type == null ) { </a> 1
<a> throw new NullPointerException ( "type" ) ; </a> 1
<a> } </a> 1
<a> this . type = type ; </a> 1
<a> } </a> 1
<a> public void increase ( ) { </a> 1
<a> if ( activeInstances . incrementAndGet ( ) > MAX_ACTIVE_INSTANCES ) { </a> 1
<a> if ( logger . isWarnEnabled ( ) ) { </a> 1
<a> if ( logged . compareAndSet ( false , true ) ) { </a> 1
<a> logger . warn ( </a> 1
<a> "You are creating too many " + type . getSimpleName ( ) + </a> 1
<a> " instances. " + type . getSimpleName ( ) + </a> 1
<a> " is a shared resource that must be reused across the" + </a> 1
<a> " application, so that only a few instances are created." ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public void decrease ( ) { </a> 1
<a> activeInstances . decrementAndGet ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal ; </a> 0
<a> import io . netty . util . UniqueName ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import java . util . concurrent . ConcurrentMap ; </a> 1
<a> public final class Signal extends Error { </a> 1
<a> private static final long serialVersionUID = - 221145131122459977L ; </a> 0
<a> private static final ConcurrentMap < String , Boolean > map = </a> 1
<a> new ConcurrentHashMap < String , Boolean > ( ) ; </a> 1
<a> private final UniqueName uname ; </a> 1
<a> public Signal ( String name ) { </a> 1
<a> super ( name ) ; </a> 1
<a> uname = new UniqueName ( map , name ) ; </a> 1
<a> } </a> 0
<a> public void expect ( Signal signal ) { </a> 0
<a> if ( this != signal ) { </a> 0
<a> throw new IllegalStateException ( "unexpected signal: " + signal ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Throwable initCause ( Throwable cause ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Throwable fillInStackTrace ( ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return uname . name ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal ; </a> 0
<a> import java . util . Formatter ; </a> 0
<a> public final class StringUtil { </a> 0
<a> private StringUtil ( ) { </a> 1
<a> } </a> 1
<a> public static final String NEWLINE ; </a> 1
<a> static { </a> 0
<a> String newLine ; </a> 0
<a> try { </a> 0
<a> newLine = new Formatter ( ) . format ( "%n" ) . toString ( ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> newLine = "\n" ; </a> 0
<a> } </a> 0
<a> NEWLINE = newLine ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal ; </a> 0
<a> import java . util . regex . Pattern ; </a> 0
<a> final class SystemPropertyUtil { </a> 0
<a> public static String get ( String key ) { </a> 0
<a> try { </a> 0
<a> return System . getProperty ( key ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static String get ( String key , String def ) { </a> 0
<a> String value = get ( key ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> value = def ; </a> 0
<a> } </a> 0
<a> return value ; </a> 0
<a> } </a> 0
<a> public static int get ( String key , int def ) { </a> 0
<a> String value = get ( key ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> return def ; </a> 0
<a> } </a> 0
<a> if ( Pattern . matches ( "-?[0-9]+" , value ) ) { </a> 0
<a> return Integer . parseInt ( value ) ; </a> 0
<a> } else { </a> 0
<a> return def ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private SystemPropertyUtil ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal . jzlib ; </a> 0
<a> final class CRC32 { </a> 0
<a> private static final int [ ] TABLE = { </a> 0
<a> 0x00000000 , 0x77073096 , 0xee0e612c , 0x990951ba , 0x076dc419 , 0x706af48f , 0xe963a535 , 0x9e6495a3 , </a> 0
<a> 0x0edb8832 , 0x79dcb8a4 , 0xe0d5e91e , 0x97d2d988 , 0x09b64c2b , 0x7eb17cbd , 0xe7b82d07 , 0x90bf1d91 , </a> 0
<a> 0x1db71064 , 0x6ab020f2 , 0xf3b97148 , 0x84be41de , 0x1adad47d , 0x6ddde4eb , 0xf4d4b551 , 0x83d385c7 , </a> 0
<a> 0x136c9856 , 0x646ba8c0 , 0xfd62f97a , 0x8a65c9ec , 0x14015c4f , 0x63066cd9 , 0xfa0f3d63 , 0x8d080df5 , </a> 0
<a> 0x3b6e20c8 , 0x4c69105e , 0xd56041e4 , 0xa2677172 , 0x3c03e4d1 , 0x4b04d447 , 0xd20d85fd , 0xa50ab56b , </a> 0
<a> 0x35b5a8fa , 0x42b2986c , 0xdbbbc9d6 , 0xacbcf940 , 0x32d86ce3 , 0x45df5c75 , 0xdcd60dcf , 0xabd13d59 , </a> 0
<a> 0x26d930ac , 0x51de003a , 0xc8d75180 , 0xbfd06116 , 0x21b4f4b5 , 0x56b3c423 , 0xcfba9599 , 0xb8bda50f , </a> 0
<a> 0x2802b89e , 0x5f058808 , 0xc60cd9b2 , 0xb10be924 , 0x2f6f7c87 , 0x58684c11 , 0xc1611dab , 0xb6662d3d , </a> 0
<a> 0x76dc4190 , 0x01db7106 , 0x98d220bc , 0xefd5102a , 0x71b18589 , 0x06b6b51f , 0x9fbfe4a5 , 0xe8b8d433 , </a> 0
<a> 0x7807c9a2 , 0x0f00f934 , 0x9609a88e , 0xe10e9818 , 0x7f6a0dbb , 0x086d3d2d , 0x91646c97 , 0xe6635c01 , </a> 0
<a> 0x6b6b51f4 , 0x1c6c6162 , 0x856530d8 , 0xf262004e , 0x6c0695ed , 0x1b01a57b , 0x8208f4c1 , 0xf50fc457 , </a> 0
<a> 0x65b0d9c6 , 0x12b7e950 , 0x8bbeb8ea , 0xfcb9887c , 0x62dd1ddf , 0x15da2d49 , 0x8cd37cf3 , 0xfbd44c65 , </a> 0
<a> 0x4db26158 , 0x3ab551ce , 0xa3bc0074 , 0xd4bb30e2 , 0x4adfa541 , 0x3dd895d7 , 0xa4d1c46d , 0xd3d6f4fb , </a> 0
<a> 0x4369e96a , 0x346ed9fc , 0xad678846 , 0xda60b8d0 , 0x44042d73 , 0x33031de5 , 0xaa0a4c5f , 0xdd0d7cc9 , </a> 0
<a> 0x5005713c , 0x270241aa , 0xbe0b1010 , 0xc90c2086 , 0x5768b525 , 0x206f85b3 , 0xb966d409 , 0xce61e49f , </a> 0
<a> 0x5edef90e , 0x29d9c998 , 0xb0d09822 , 0xc7d7a8b4 , 0x59b33d17 , 0x2eb40d81 , 0xb7bd5c3b , 0xc0ba6cad , </a> 0
<a> 0xedb88320 , 0x9abfb3b6 , 0x03b6e20c , 0x74b1d29a , 0xead54739 , 0x9dd277af , 0x04db2615 , 0x73dc1683 , </a> 0
<a> 0xe3630b12 , 0x94643b84 , 0x0d6d6a3e , 0x7a6a5aa8 , 0xe40ecf0b , 0x9309ff9d , 0x0a00ae27 , 0x7d079eb1 , </a> 0
<a> 0xf00f9344 , 0x8708a3d2 , 0x1e01f268 , 0x6906c2fe , 0xf762575d , 0x806567cb , 0x196c3671 , 0x6e6b06e7 , </a> 0
<a> 0xfed41b76 , 0x89d32be0 , 0x10da7a5a , 0x67dd4acc , 0xf9b9df6f , 0x8ebeeff9 , 0x17b7be43 , 0x60b08ed5 , </a> 0
<a> 0xd6d6a3e8 , 0xa1d1937e , 0x38d8c2c4 , 0x4fdff252 , 0xd1bb67f1 , 0xa6bc5767 , 0x3fb506dd , 0x48b2364b , </a> 0
<a> 0xd80d2bda , 0xaf0a1b4c , 0x36034af6 , 0x41047a60 , 0xdf60efc3 , 0xa867df55 , 0x316e8eef , 0x4669be79 , </a> 0
<a> 0xcb61b38c , 0xbc66831a , 0x256fd2a0 , 0x5268e236 , 0xcc0c7795 , 0xbb0b4703 , 0x220216b9 , 0x5505262f , </a> 0
<a> 0xc5ba3bbe , 0xb2bd0b28 , 0x2bb45a92 , 0x5cb36a04 , 0xc2d7ffa7 , 0xb5d0cf31 , 0x2cd99e8b , 0x5bdeae1d , </a> 0
<a> 0x9b64c2b0 , 0xec63f226 , 0x756aa39c , 0x026d930a , 0x9c0906a9 , 0xeb0e363f , 0x72076785 , 0x05005713 , </a> 0
<a> 0x95bf4a82 , 0xe2b87a14 , 0x7bb12bae , 0x0cb61b38 , 0x92d28e9b , 0xe5d5be0d , 0x7cdcefb7 , 0x0bdbdf21 , </a> 0
<a> 0x86d3d2d4 , 0xf1d4e242 , 0x68ddb3f8 , 0x1fda836e , 0x81be16cd , 0xf6b9265b , 0x6fb077e1 , 0x18b74777 , </a> 0
<a> 0x88085ae6 , 0xff0f6a70 , 0x66063bca , 0x11010b5c , 0x8f659eff , 0xf862ae69 , 0x616bffd3 , 0x166ccf45 , </a> 0
<a> 0xa00ae278 , 0xd70dd2ee , 0x4e048354 , 0x3903b3c2 , 0xa7672661 , 0xd06016f7 , 0x4969474d , 0x3e6e77db , </a> 0
<a> 0xaed16a4a , 0xd9d65adc , 0x40df0b66 , 0x37d83bf0 , 0xa9bcae53 , 0xdebb9ec5 , 0x47b2cf7f , 0x30b5ffe9 , </a> 0
<a> 0xbdbdf21c , 0xcabac28a , 0x53b39330 , 0x24b4a3a6 , 0xbad03605 , 0xcdd70693 , 0x54de5729 , 0x23d967bf , </a> 0
<a> 0xb3667a2e , 0xc4614ab8 , 0x5d681b02 , 0x2a6f2b94 , 0xb40bbe37 , 0xc30c8ea1 , 0x5a05df1b , 0x2d02ef8d , </a> 0
<a> } ; </a> 0
<a> static int crc32 ( int crc32 , byte [ ] buf , int index , int len ) { </a> 0
<a> final int endIndex = index + len ; </a> 0
<a> crc32 ^= 0xffffffff ; </a> 0
<a> for ( int i = index ; i < endIndex ; i ++ ) { </a> 0
<a> crc32 = crc32 > > > 8 ^ TABLE [ ( crc32 ^ buf [ i ] ) & 0xff ] ; </a> 0
<a> } </a> 0
<a> crc32 ^= 0xffffffff ; </a> 0
<a> return crc32 ; </a> 0
<a> } </a> 0
<a> private CRC32 ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal . jzlib ; </a> 0
<a> import io . netty . util . internal . jzlib . JZlib . WrapperType ; </a> 0
<a> final class Deflate { </a> 0
<a> private static final class Config { </a> 0
<a> final int good_length ; </a> 0
<a> final int max_lazy ; </a> 0
<a> final int nice_length ; </a> 0
<a> final int max_chain ; </a> 0
<a> final int func ; </a> 0
<a> Config ( int good_length , int max_lazy , int nice_length , int max_chain , </a> 0
<a> int func ) { </a> 0
<a> this . good_length = good_length ; </a> 0
<a> this . max_lazy = max_lazy ; </a> 0
<a> this . nice_length = nice_length ; </a> 0
<a> this . max_chain = max_chain ; </a> 0
<a> this . func = func ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static final int STORED = 0 ; </a> 0
<a> private static final int FAST = 1 ; </a> 0
<a> private static final int SLOW = 2 ; </a> 0
<a> private static final Config [ ] config_table ; </a> 0
<a> static { </a> 0
<a> config_table = new Config [ 10 ] ; </a> 0
<a> config_table [ 0 ] = new Config ( 0 , 0 , 0 , 0 , STORED ) ; </a> 0
<a> config_table [ 1 ] = new Config ( 4 , 4 , 8 , 4 , FAST ) ; </a> 0
<a> config_table [ 2 ] = new Config ( 4 , 5 , 16 , 8 , FAST ) ; </a> 0
<a> config_table [ 3 ] = new Config ( 4 , 6 , 32 , 32 , FAST ) ; </a> 0
<a> config_table [ 4 ] = new Config ( 4 , 4 , 16 , 16 , SLOW ) ; </a> 0
<a> config_table [ 5 ] = new Config ( 8 , 16 , 32 , 32 , SLOW ) ; </a> 0
<a> config_table [ 6 ] = new Config ( 8 , 16 , 128 , 128 , SLOW ) ; </a> 0
<a> config_table [ 7 ] = new Config ( 8 , 32 , 128 , 256 , SLOW ) ; </a> 0
<a> config_table [ 8 ] = new Config ( 32 , 128 , 258 , 1024 , SLOW ) ; </a> 0
<a> config_table [ 9 ] = new Config ( 32 , 258 , 258 , 4096 , SLOW ) ; </a> 0
<a> } </a> 0
<a> private static final String [ ] z_errmsg = { "need dictionary" , </a> 0
<a> "stream end" , </a> 0
<a> "" , </a> 0
<a> "file error" , </a> 0
<a> "stream error" , </a> 0
<a> "data error" , </a> 0
<a> "insufficient memory" , </a> 0
<a> "buffer error" , </a> 0
<a> "incompatible version" , </a> 0
<a> "" } ; </a> 0
<a> private static final int NeedMore = 0 ; </a> 0
<a> private static final int BlockDone = 1 ; </a> 0
<a> private static final int FinishStarted = 2 ; </a> 0
<a> private static final int FinishDone = 3 ; </a> 0
<a> private static final int INIT_STATE = 42 ; </a> 0
<a> private static final int BUSY_STATE = 113 ; </a> 0
<a> private static final int FINISH_STATE = 666 ; </a> 0
<a> private static final int STORED_BLOCK = 0 ; </a> 0
<a> private static final int STATIC_TREES = 1 ; </a> 0
<a> private static final int DYN_TREES = 2 ; </a> 0
<a> private static final int Z_BINARY = 0 ; </a> 0
<a> private static final int Z_ASCII = 1 ; </a> 0
<a> private static final int Z_UNKNOWN = 2 ; </a> 0
<a> private static final int Buf_size = 8 * 2 ; </a> 0
<a> private static final int REP_3_6 = 16 ; </a> 0
<a> private static final int REPZ_3_10 = 17 ; </a> 0
<a> private static final int REPZ_11_138 = 18 ; </a> 0
<a> private static final int MIN_MATCH = 3 ; </a> 0
<a> private static final int MAX_MATCH = 258 ; </a> 0
<a> private static final int MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1 ; </a> 0
<a> private static final int END_BLOCK = 256 ; </a> 0
<a> ZStream strm ; </a> 0
<a> int status ; </a> 0
<a> byte [ ] pending_buf ; </a> 0
<a> int pending_buf_size ; </a> 0
<a> int pending_out ; </a> 0
<a> int pending ; </a> 0
<a> WrapperType wrapperType ; </a> 0
<a> private boolean wroteTrailer ; </a> 0
<a> byte data_type ; </a> 0
<a> int last_flush ; </a> 0
<a> int w_size ; </a> 0
<a> int w_bits ; </a> 0
<a> int w_mask ; </a> 0
<a> byte [ ] window ; </a> 0
<a> int window_size ; </a> 0
<a> short [ ] prev ; </a> 0
<a> short [ ] head ; </a> 0
<a> int ins_h ; </a> 0
<a> int hash_size ; </a> 0
<a> int hash_bits ; </a> 0
<a> int hash_mask ; </a> 0
<a> int hash_shift ; </a> 0
<a> int block_start ; </a> 0
<a> int match_length ; </a> 0
<a> int prev_match ; </a> 0
<a> int match_available ; </a> 0
<a> int strstart ; </a> 0
<a> int match_start ; </a> 0
<a> int lookahead ; </a> 0
<a> int prev_length ; </a> 0
<a> int max_chain_length ; </a> 0
<a> int max_lazy_match ; </a> 0
<a> int level ; </a> 0
<a> int strategy ; </a> 0
<a> int good_match ; </a> 0
<a> int nice_match ; </a> 0
<a> short [ ] dyn_ltree ; </a> 0
<a> short [ ] dyn_dtree ; </a> 0
<a> short [ ] bl_tree ; </a> 0
<a> Tree l_desc = new Tree ( ) ; </a> 0
<a> Tree d_desc = new Tree ( ) ; </a> 0
<a> Tree bl_desc = new Tree ( ) ; </a> 0
<a> short [ ] bl_count = new short [ JZlib . MAX_BITS + 1 ] ; </a> 0
<a> int [ ] heap = new int [ 2 * JZlib . L_CODES + 1 ] ; </a> 0
<a> int heap_len ; </a> 0
<a> int heap_max ; </a> 0
<a> byte [ ] depth = new byte [ 2 * JZlib . L_CODES + 1 ] ; </a> 0
<a> int l_buf ; </a> 0
<a> int lit_bufsize ; </a> 0
<a> int last_lit ; </a> 0
<a> int d_buf ; </a> 0
<a> int opt_len ; </a> 0
<a> int static_len ; </a> 0
<a> int matches ; </a> 0
<a> int last_eob_len ; </a> 0
<a> short bi_buf ; </a> 0
<a> int bi_valid ; </a> 0
<a> private int gzipUncompressedBytes ; </a> 0
<a> Deflate ( ) { </a> 0
<a> dyn_ltree = new short [ JZlib . HEAP_SIZE * 2 ] ; </a> 0
<a> dyn_dtree = new short [ ( 2 * JZlib . D_CODES + 1 ) * 2 ] ; </a> 0
<a> bl_tree = new short [ ( 2 * JZlib . BL_CODES + 1 ) * 2 ] ; </a> 0
<a> } </a> 0
<a> private void lm_init ( ) { </a> 0
<a> window_size = 2 * w_size ; </a> 0
<a> max_lazy_match = Deflate . config_table [ level ] . max_lazy ; </a> 0
<a> good_match = Deflate . config_table [ level ] . good_length ; </a> 0
<a> nice_match = Deflate . config_table [ level ] . nice_length ; </a> 0
<a> max_chain_length = Deflate . config_table [ level ] . max_chain ; </a> 0
<a> strstart = 0 ; </a> 0
<a> block_start = 0 ; </a> 0
<a> lookahead = 0 ; </a> 0
<a> match_length = prev_length = MIN_MATCH - 1 ; </a> 0
<a> match_available = 0 ; </a> 0
<a> ins_h = 0 ; </a> 0
<a> } </a> 0
<a> private void tr_init ( ) { </a> 0
<a> l_desc . dyn_tree = dyn_ltree ; </a> 0
<a> l_desc . stat_desc = StaticTree . static_l_desc ; </a> 0
<a> d_desc . dyn_tree = dyn_dtree ; </a> 0
<a> d_desc . stat_desc = StaticTree . static_d_desc ; </a> 0
<a> bl_desc . dyn_tree = bl_tree ; </a> 0
<a> bl_desc . stat_desc = StaticTree . static_bl_desc ; </a> 0
<a> bi_buf = 0 ; </a> 0
<a> bi_valid = 0 ; </a> 0
<a> last_eob_len = 8 ; </a> 0
<a> init_block ( ) ; </a> 0
<a> } </a> 0
<a> private void init_block ( ) { </a> 0
<a> for ( int i = 0 ; i < JZlib . L_CODES ; i ++ ) { </a> 0
<a> dyn_ltree [ i * 2 ] = 0 ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < JZlib . D_CODES ; i ++ ) { </a> 0
<a> dyn_dtree [ i * 2 ] = 0 ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < JZlib . BL_CODES ; i ++ ) { </a> 0
<a> bl_tree [ i * 2 ] = 0 ; </a> 0
<a> } </a> 0
<a> dyn_ltree [ END_BLOCK * 2 ] = 1 ; </a> 0
<a> opt_len = static_len = 0 ; </a> 0
<a> last_lit = matches = 0 ; </a> 0
<a> } </a> 0
<a> void pqdownheap ( short [ ] tree , </a> 0
<a> int k </a> 0
<a> ) { </a> 0
<a> int v = heap [ k ] ; </a> 0
<a> int j = k < < 1 ; </a> 0
<a> while ( j <= heap_len ) { </a> 0
<a> if ( j < heap_len && smaller ( tree , heap [ j + 1 ] , heap [ j ] , depth ) ) { </a> 0
<a> j ++ ; </a> 0
<a> } </a> 0
<a> if ( smaller ( tree , v , heap [ j ] , depth ) ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> heap [ k ] = heap [ j ] ; </a> 0
<a> k = j ; </a> 0
<a> j <<= 1 ; </a> 0
<a> } </a> 0
<a> heap [ k ] = v ; </a> 0
<a> } </a> 0
<a> private static boolean smaller ( short [ ] tree , int n , int m , byte [ ] depth ) { </a> 0
<a> short tn2 = tree [ n * 2 ] ; </a> 0
<a> short tm2 = tree [ m * 2 ] ; </a> 0
<a> return tn2 < tm2 || tn2 == tm2 && depth [ n ] <= depth [ m ] ; </a> 0
<a> } </a> 0
<a> private void scan_tree ( short [ ] tree , </a> 0
<a> int max_code </a> 0
<a> ) { </a> 0
<a> int n ; </a> 0
<a> int prevlen = - 1 ; </a> 0
<a> int curlen ; </a> 0
<a> int nextlen = tree [ 0 * 2 + 1 ] ; </a> 1
<a> int count = 0 ; </a> 0
<a> int max_count = 7 ; </a> 0
<a> int min_count = 4 ; </a> 0
<a> if ( nextlen == 0 ) { </a> 0
<a> max_count = 138 ; </a> 0
<a> min_count = 3 ; </a> 0
<a> } </a> 0
<a> tree [ ( max_code + 1 ) * 2 + 1 ] = ( short ) 0xffff ; </a> 0
<a> for ( n = 0 ; n <= max_code ; n ++ ) { </a> 0
<a> curlen = nextlen ; </a> 0
<a> nextlen = tree [ ( n + 1 ) * 2 + 1 ] ; </a> 0
<a> if ( ++ count < max_count && curlen == nextlen ) { </a> 0
<a> continue ; </a> 0
<a> } else if ( count < min_count ) { </a> 0
<a> bl_tree [ curlen * 2 ] += count ; </a> 0
<a> } else if ( curlen != 0 ) { </a> 0
<a> if ( curlen != prevlen ) { </a> 0
<a> bl_tree [ curlen * 2 ] ++ ; </a> 0
<a> } </a> 0
<a> bl_tree [ REP_3_6 * 2 ] ++ ; </a> 0
<a> } else if ( count <= 10 ) { </a> 0
<a> bl_tree [ REPZ_3_10 * 2 ] ++ ; </a> 0
<a> } else { </a> 0
<a> bl_tree [ REPZ_11_138 * 2 ] ++ ; </a> 0
<a> } </a> 0
<a> count = 0 ; </a> 0
<a> prevlen = curlen ; </a> 0
<a> if ( nextlen == 0 ) { </a> 0
<a> max_count = 138 ; </a> 0
<a> min_count = 3 ; </a> 0
<a> } else if ( curlen == nextlen ) { </a> 0
<a> max_count = 6 ; </a> 0
<a> min_count = 3 ; </a> 0
<a> } else { </a> 0
<a> max_count = 7 ; </a> 0
<a> min_count = 4 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private int build_bl_tree ( ) { </a> 0
<a> int max_blindex ; </a> 0
<a> scan_tree ( dyn_ltree , l_desc . max_code ) ; </a> 0
<a> scan_tree ( dyn_dtree , d_desc . max_code ) ; </a> 0
<a> bl_desc . build_tree ( this ) ; </a> 0
<a> for ( max_blindex = JZlib . BL_CODES - 1 ; max_blindex >= 3 ; max_blindex -- ) { </a> 0
<a> if ( bl_tree [ Tree . bl_order [ max_blindex ] * 2 + 1 ] != 0 ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> opt_len += 3 * ( max_blindex + 1 ) + 5 + 5 + 4 ; </a> 0
<a> return max_blindex ; </a> 0
<a> } </a> 0
<a> private void send_all_trees ( int lcodes , int dcodes , int blcodes ) { </a> 0
<a> int rank ; </a> 0
<a> send_bits ( lcodes - 257 , 5 ) ; </a> 0
<a> send_bits ( dcodes - 1 , 5 ) ; </a> 0
<a> send_bits ( blcodes - 4 , 4 ) ; </a> 0
<a> for ( rank = 0 ; rank < blcodes ; rank ++ ) { </a> 0
<a> send_bits ( bl_tree [ Tree . bl_order [ rank ] * 2 + 1 ] , 3 ) ; </a> 0
<a> } </a> 0
<a> send_tree ( dyn_ltree , lcodes - 1 ) ; </a> 0
<a> send_tree ( dyn_dtree , dcodes - 1 ) ; </a> 0
<a> } </a> 0
<a> private void send_tree ( short [ ] tree , </a> 0
<a> int max_code </a> 0
<a> ) { </a> 0
<a> int n ; </a> 0
<a> int prevlen = - 1 ; </a> 0
<a> int curlen ; </a> 0
<a> int nextlen = tree [ 0 * 2 + 1 ] ; </a> 1
<a> int count = 0 ; </a> 0
<a> int max_count = 7 ; </a> 0
<a> int min_count = 4 ; </a> 0
<a> if ( nextlen == 0 ) { </a> 0
<a> max_count = 138 ; </a> 0
<a> min_count = 3 ; </a> 0
<a> } </a> 0
<a> for ( n = 0 ; n <= max_code ; n ++ ) { </a> 0
<a> curlen = nextlen ; </a> 0
<a> nextlen = tree [ ( n + 1 ) * 2 + 1 ] ; </a> 0
<a> if ( ++ count < max_count && curlen == nextlen ) { </a> 0
<a> continue ; </a> 0
<a> } else if ( count < min_count ) { </a> 0
<a> do { </a> 0
<a> send_code ( curlen , bl_tree ) ; </a> 0
<a> } while ( -- count != 0 ) ; </a> 0
<a> } else if ( curlen != 0 ) { </a> 0
<a> if ( curlen != prevlen ) { </a> 0
<a> send_code ( curlen , bl_tree ) ; </a> 0
<a> count -- ; </a> 0
<a> } </a> 0
<a> send_code ( REP_3_6 , bl_tree ) ; </a> 0
<a> send_bits ( count - 3 , 2 ) ; </a> 0
<a> } else if ( count <= 10 ) { </a> 0
<a> send_code ( REPZ_3_10 , bl_tree ) ; </a> 0
<a> send_bits ( count - 3 , 3 ) ; </a> 0
<a> } else { </a> 0
<a> send_code ( REPZ_11_138 , bl_tree ) ; </a> 0
<a> send_bits ( count - 11 , 7 ) ; </a> 0
<a> } </a> 0
<a> count = 0 ; </a> 0
<a> prevlen = curlen ; </a> 0
<a> if ( nextlen == 0 ) { </a> 0
<a> max_count = 138 ; </a> 0
<a> min_count = 3 ; </a> 0
<a> } else if ( curlen == nextlen ) { </a> 0
<a> max_count = 6 ; </a> 0
<a> min_count = 3 ; </a> 0
<a> } else { </a> 0
<a> max_count = 7 ; </a> 0
<a> min_count = 4 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void put_byte ( byte [ ] p , int start , int len ) { </a> 0
<a> System . arraycopy ( p , start , pending_buf , pending , len ) ; </a> 0
<a> pending += len ; </a> 0
<a> } </a> 0
<a> private void put_byte ( byte c ) { </a> 0
<a> pending_buf [ pending ++ ] = c ; </a> 0
<a> } </a> 0
<a> private void put_short ( int w ) { </a> 0
<a> put_byte ( ( byte ) w ) ; </a> 0
<a> put_byte ( ( byte ) ( w > > > 8 ) ) ; </a> 0
<a> } </a> 0
<a> private void putShortMSB ( int b ) { </a> 0
<a> put_byte ( ( byte ) ( b > > 8 ) ) ; </a> 0
<a> put_byte ( ( byte ) b ) ; </a> 0
<a> } </a> 0
<a> private void send_code ( int c , short [ ] tree ) { </a> 0
<a> int c2 = c * 2 ; </a> 0
<a> send_bits ( tree [ c2 ] & 0xffff , tree [ c2 + 1 ] & 0xffff ) ; </a> 0
<a> } </a> 0
<a> private void send_bits ( int value , int length ) { </a> 0
<a> if ( bi_valid > Buf_size - length ) { </a> 0
<a> bi_buf |= value < < bi_valid & 0xffff ; </a> 0
<a> put_short ( bi_buf ) ; </a> 0
<a> bi_buf = ( short ) ( value > > > Buf_size - bi_valid ) ; </a> 0
<a> bi_valid += length - Buf_size ; </a> 0
<a> } else { </a> 0
<a> bi_buf |= value < < bi_valid & 0xffff ; </a> 0
<a> bi_valid += length ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void _tr_align ( ) { </a> 0
<a> send_bits ( STATIC_TREES < < 1 , 3 ) ; </a> 0
<a> send_code ( END_BLOCK , StaticTree . static_ltree ) ; </a> 0
<a> bi_flush ( ) ; </a> 0
<a> if ( 1 + last_eob_len + 10 - bi_valid < 9 ) { </a> 0
<a> send_bits ( STATIC_TREES < < 1 , 3 ) ; </a> 0
<a> send_code ( END_BLOCK , StaticTree . static_ltree ) ; </a> 0
<a> bi_flush ( ) ; </a> 0
<a> } </a> 0
<a> last_eob_len = 7 ; </a> 0
<a> } </a> 0
<a> private boolean _tr_tally ( int dist , </a> 0
<a> int lc </a> 0
<a> ) { </a> 0
<a> pending_buf [ d_buf + last_lit * 2 ] = ( byte ) ( dist > > > 8 ) ; </a> 0
<a> pending_buf [ d_buf + last_lit * 2 + 1 ] = ( byte ) dist ; </a> 0
<a> pending_buf [ l_buf + last_lit ] = ( byte ) lc ; </a> 0
<a> last_lit ++ ; </a> 0
<a> if ( dist == 0 ) { </a> 0
<a> dyn_ltree [ lc * 2 ] ++ ; </a> 0
<a> } else { </a> 0
<a> matches ++ ; </a> 0
<a> dist -- ; </a> 0
<a> dyn_ltree [ ( Tree . _length_code [ lc ] + JZlib . LITERALS + 1 ) * 2 ] ++ ; </a> 0
<a> dyn_dtree [ Tree . d_code ( dist ) * 2 ] ++ ; </a> 0
<a> } </a> 0
<a> if ( ( last_lit & 0x1fff ) == 0 && level > 2 ) { </a> 0
<a> int out_length = last_lit * 8 ; </a> 0
<a> int in_length = strstart - block_start ; </a> 0
<a> int dcode ; </a> 0
<a> for ( dcode = 0 ; dcode < JZlib . D_CODES ; dcode ++ ) { </a> 0
<a> out_length += dyn_dtree [ dcode * 2 ] * </a> 0
<a> ( 5L + Tree . extra_dbits [ dcode ] ) ; </a> 0
<a> } </a> 0
<a> out_length >>>= 3 ; </a> 0
<a> if ( matches < last_lit / 2 && out_length < in_length / 2 ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return last_lit == lit_bufsize - 1 ; </a> 0
<a> } </a> 0
<a> private void compress_block ( short [ ] ltree , short [ ] dtree ) { </a> 0
<a> int dist ; </a> 0
<a> int lc ; </a> 0
<a> int lx = 0 ; </a> 0
<a> int code ; </a> 0
<a> int extra ; </a> 0
<a> if ( last_lit != 0 ) { </a> 0
<a> do { </a> 0
<a> dist = pending_buf [ d_buf + lx * 2 ] < < 8 & 0xff00 | </a> 0
<a> pending_buf [ d_buf + lx * 2 + 1 ] & 0xff ; </a> 0
<a> lc = pending_buf [ l_buf + lx ] & 0xff ; </a> 0
<a> lx ++ ; </a> 0
<a> if ( dist == 0 ) { </a> 0
<a> send_code ( lc , ltree ) ; </a> 0
<a> } else { </a> 0
<a> code = Tree . _length_code [ lc ] ; </a> 0
<a> send_code ( code + JZlib . LITERALS + 1 , ltree ) ; </a> 0
<a> extra = Tree . extra_lbits [ code ] ; </a> 0
<a> if ( extra != 0 ) { </a> 0
<a> lc -= Tree . base_length [ code ] ; </a> 0
<a> send_bits ( lc , extra ) ; </a> 0
<a> } </a> 0
<a> dist -- ; </a> 0
<a> code = Tree . d_code ( dist ) ; </a> 0
<a> send_code ( code , dtree ) ; </a> 0
<a> extra = Tree . extra_dbits [ code ] ; </a> 0
<a> if ( extra != 0 ) { </a> 0
<a> dist -= Tree . base_dist [ code ] ; </a> 0
<a> send_bits ( dist , extra ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } while ( lx < last_lit ) ; </a> 0
<a> } </a> 0
<a> send_code ( END_BLOCK , ltree ) ; </a> 0
<a> last_eob_len = ltree [ END_BLOCK * 2 + 1 ] ; </a> 0
<a> } </a> 0
<a> private void set_data_type ( ) { </a> 0
<a> int n = 0 ; </a> 0
<a> int ascii_freq = 0 ; </a> 0
<a> int bin_freq = 0 ; </a> 0
<a> while ( n < 7 ) { </a> 0
<a> bin_freq += dyn_ltree [ n * 2 ] ; </a> 0
<a> n ++ ; </a> 0
<a> } </a> 0
<a> while ( n < 128 ) { </a> 0
<a> ascii_freq += dyn_ltree [ n * 2 ] ; </a> 0
<a> n ++ ; </a> 0
<a> } </a> 0
<a> while ( n < JZlib . LITERALS ) { </a> 0
<a> bin_freq += dyn_ltree [ n * 2 ] ; </a> 0
<a> n ++ ; </a> 0
<a> } </a> 0
<a> data_type = ( byte ) ( bin_freq > ascii_freq > > > 2 ? Z_BINARY : Z_ASCII ) ; </a> 0
<a> } </a> 0
<a> private void bi_flush ( ) { </a> 0
<a> if ( bi_valid == 16 ) { </a> 0
<a> put_short ( bi_buf ) ; </a> 0
<a> bi_buf = 0 ; </a> 0
<a> bi_valid = 0 ; </a> 0
<a> } else if ( bi_valid >= 8 ) { </a> 0
<a> put_byte ( ( byte ) bi_buf ) ; </a> 0
<a> bi_buf >>>= 8 ; </a> 0
<a> bi_valid -= 8 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void bi_windup ( ) { </a> 0
<a> if ( bi_valid > 8 ) { </a> 0
<a> put_short ( bi_buf ) ; </a> 0
<a> } else if ( bi_valid > 0 ) { </a> 0
<a> put_byte ( ( byte ) bi_buf ) ; </a> 0
<a> } </a> 0
<a> bi_buf = 0 ; </a> 0
<a> bi_valid = 0 ; </a> 0
<a> } </a> 0
<a> private void copy_block ( int buf , </a> 0
<a> int len , </a> 0
<a> boolean header </a> 0
<a> ) { </a> 0
<a> bi_windup ( ) ; </a> 0
<a> last_eob_len = 8 ; </a> 0
<a> if ( header ) { </a> 0
<a> put_short ( ( short ) len ) ; </a> 0
<a> put_short ( ( short ) ~ len ) ; </a> 0
<a> } </a> 0
<a> put_byte ( window , buf , len ) ; </a> 0
<a> } </a> 0
<a> private void flush_block_only ( boolean eof ) { </a> 0
<a> _tr_flush_block ( block_start >= 0 ? block_start : - 1 , strstart - </a> 0
<a> block_start , eof ) ; </a> 0
<a> block_start = strstart ; </a> 0
<a> strm . flush_pending ( ) ; </a> 0
<a> } </a> 0
<a> private int deflate_stored ( int flush ) { </a> 0
<a> int max_block_size = 0xffff ; </a> 0
<a> int max_start ; </a> 0
<a> if ( max_block_size > pending_buf_size - 5 ) { </a> 0
<a> max_block_size = pending_buf_size - 5 ; </a> 0
<a> } </a> 0
<a> while ( true ) { </a> 0
<a> if ( lookahead <= 1 ) { </a> 0
<a> fill_window ( ) ; </a> 0
<a> if ( lookahead == 0 && flush == JZlib . Z_NO_FLUSH ) { </a> 0
<a> return NeedMore ; </a> 0
<a> } </a> 0
<a> if ( lookahead == 0 ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> strstart += lookahead ; </a> 0
<a> lookahead = 0 ; </a> 0
<a> max_start = block_start + max_block_size ; </a> 0
<a> if ( strstart == 0 || strstart >= max_start ) { </a> 0
<a> lookahead = strstart - max_start ; </a> 0
<a> strstart = max_start ; </a> 0
<a> flush_block_only ( false ) ; </a> 0
<a> if ( strm . avail_out == 0 ) { </a> 0
<a> return NeedMore ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( strstart - block_start >= w_size - MIN_LOOKAHEAD ) { </a> 0
<a> flush_block_only ( false ) ; </a> 0
<a> if ( strm . avail_out == 0 ) { </a> 0
<a> return NeedMore ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> flush_block_only ( flush == JZlib . Z_FINISH ) ; </a> 0
<a> if ( strm . avail_out == 0 ) { </a> 0
<a> return flush == JZlib . Z_FINISH ? FinishStarted : NeedMore ; </a> 0
<a> } </a> 0
<a> return flush == JZlib . Z_FINISH ? FinishDone : BlockDone ; </a> 0
<a> } </a> 0
<a> private void _tr_stored_block ( int buf , </a> 0
<a> int stored_len , </a> 0
<a> boolean eof </a> 0
<a> ) { </a> 0
<a> send_bits ( ( STORED_BLOCK < < 1 ) + ( eof ? 1 : 0 ) , 3 ) ; </a> 0
<a> copy_block ( buf , stored_len , true ) ; </a> 0
<a> } </a> 0
<a> private void _tr_flush_block ( int buf , </a> 0
<a> int stored_len , </a> 0
<a> boolean eof </a> 0
<a> ) { </a> 0
<a> int opt_lenb , static_lenb ; </a> 0
<a> int max_blindex = 0 ; </a> 0
<a> if ( level > 0 ) { </a> 0
<a> if ( data_type == Z_UNKNOWN ) { </a> 0
<a> set_data_type ( ) ; </a> 0
<a> } </a> 0
<a> l_desc . build_tree ( this ) ; </a> 0
<a> d_desc . build_tree ( this ) ; </a> 0
<a> max_blindex = build_bl_tree ( ) ; </a> 0
<a> opt_lenb = opt_len + 3 + 7 > > > 3 ; </a> 0
<a> static_lenb = static_len + 3 + 7 > > > 3 ; </a> 0
<a> if ( static_lenb <= opt_lenb ) { </a> 0
<a> opt_lenb = static_lenb ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> opt_lenb = static_lenb = stored_len + 5 ; </a> 0
<a> } </a> 0
<a> if ( stored_len + 4 <= opt_lenb && buf != - 1 ) { </a> 0
<a> _tr_stored_block ( buf , stored_len , eof ) ; </a> 0
<a> } else if ( static_lenb == opt_lenb ) { </a> 0
<a> send_bits ( ( STATIC_TREES < < 1 ) + ( eof ? 1 : 0 ) , 3 ) ; </a> 0
<a> compress_block ( StaticTree . static_ltree , StaticTree . static_dtree ) ; </a> 0
<a> } else { </a> 0
<a> send_bits ( ( DYN_TREES < < 1 ) + ( eof ? 1 : 0 ) , 3 ) ; </a> 0
<a> send_all_trees ( l_desc . max_code + 1 , d_desc . max_code + 1 , </a> 0
<a> max_blindex + 1 ) ; </a> 0
<a> compress_block ( dyn_ltree , dyn_dtree ) ; </a> 0
<a> } </a> 0
<a> init_block ( ) ; </a> 0
<a> if ( eof ) { </a> 0
<a> bi_windup ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void fill_window ( ) { </a> 0
<a> int n , m ; </a> 0
<a> int p ; </a> 0
<a> int more ; </a> 0
<a> do { </a> 0
<a> more = window_size - lookahead - strstart ; </a> 0
<a> if ( more == 0 && strstart == 0 && lookahead == 0 ) { </a> 0
<a> more = w_size ; </a> 0
<a> } else if ( more == - 1 ) { </a> 0
<a> more -- ; </a> 0
<a> } else if ( strstart >= w_size + w_size - MIN_LOOKAHEAD ) { </a> 0
<a> System . arraycopy ( window , w_size , window , 0 , w_size ) ; </a> 0
<a> match_start -= w_size ; </a> 0
<a> strstart -= w_size ; </a> 0
<a> block_start -= w_size ; </a> 0
<a> n = hash_size ; </a> 0
<a> p = n ; </a> 0
<a> do { </a> 0
<a> m = head [ -- p ] & 0xffff ; </a> 0
<a> head [ p ] = m >= w_size ? ( short ) ( m - w_size ) : 0 ; </a> 0
<a> } while ( -- n != 0 ) ; </a> 0
<a> n = w_size ; </a> 0
<a> p = n ; </a> 0
<a> do { </a> 0
<a> m = prev [ -- p ] & 0xffff ; </a> 0
<a> prev [ p ] = m >= w_size ? ( short ) ( m - w_size ) : 0 ; </a> 0
<a> } while ( -- n != 0 ) ; </a> 0
<a> more += w_size ; </a> 0
<a> } </a> 0
<a> if ( strm . avail_in == 0 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> n = strm . read_buf ( window , strstart + lookahead , more ) ; </a> 0
<a> lookahead += n ; </a> 0
<a> if ( lookahead >= MIN_MATCH ) { </a> 0
<a> ins_h = window [ strstart ] & 0xff ; </a> 0
<a> ins_h = ( ins_h < < hash_shift ^ window [ strstart + 1 ] & 0xff ) & </a> 0
<a> hash_mask ; </a> 0
<a> } </a> 0
<a> } while ( lookahead < MIN_LOOKAHEAD && strm . avail_in != 0 ) ; </a> 0
<a> } </a> 0
<a> private int deflate_fast ( int flush ) { </a> 0
<a> int hash_head = 0 ; </a> 0
<a> boolean bflush ; </a> 0
<a> while ( true ) { </a> 0
<a> if ( lookahead < MIN_LOOKAHEAD ) { </a> 0
<a> fill_window ( ) ; </a> 0
<a> if ( lookahead < MIN_LOOKAHEAD && flush == JZlib . Z_NO_FLUSH ) { </a> 0
<a> return NeedMore ; </a> 0
<a> } </a> 0
<a> if ( lookahead == 0 ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( lookahead >= MIN_MATCH ) { </a> 0
<a> ins_h = ( ins_h < < hash_shift ^ window [ strstart + MIN_MATCH - 1 ] & 0xff ) & </a> 0
<a> hash_mask ; </a> 0
<a> hash_head = head [ ins_h ] & 0xffff ; </a> 0
<a> prev [ strstart & w_mask ] = head [ ins_h ] ; </a> 0
<a> head [ ins_h ] = ( short ) strstart ; </a> 0
<a> } </a> 0
<a> if ( hash_head != 0L && </a> 0
<a> ( strstart - hash_head & 0xffff ) <= w_size - MIN_LOOKAHEAD ) { </a> 0
<a> if ( strategy != JZlib . Z_HUFFMAN_ONLY ) { </a> 0
<a> match_length = longest_match ( hash_head ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( match_length >= MIN_MATCH ) { </a> 0
<a> bflush = _tr_tally ( strstart - match_start , match_length - </a> 0
<a> MIN_MATCH ) ; </a> 0
<a> lookahead -= match_length ; </a> 0
<a> if ( match_length <= max_lazy_match && lookahead >= MIN_MATCH ) { </a> 0
<a> match_length -- ; </a> 0
<a> do { </a> 0
<a> strstart ++ ; </a> 0
<a> ins_h = ( ins_h < < hash_shift ^ window [ strstart + </a> 0
<a> MIN_MATCH - 1 ] & 0xff ) & </a> 0
<a> hash_mask ; </a> 0
<a> hash_head = head [ ins_h ] & 0xffff ; </a> 0
<a> prev [ strstart & w_mask ] = head [ ins_h ] ; </a> 0
<a> head [ ins_h ] = ( short ) strstart ; </a> 0
<a> } while ( -- match_length != 0 ) ; </a> 0
<a> strstart ++ ; </a> 0
<a> } else { </a> 0
<a> strstart += match_length ; </a> 0
<a> match_length = 0 ; </a> 0
<a> ins_h = window [ strstart ] & 0xff ; </a> 0
<a> ins_h = ( ins_h < < hash_shift ^ window [ strstart + 1 ] & 0xff ) & </a> 0
<a> hash_mask ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> bflush = _tr_tally ( 0 , window [ strstart ] & 0xff ) ; </a> 0
<a> lookahead -- ; </a> 0
<a> strstart ++ ; </a> 0
<a> } </a> 0
<a> if ( bflush ) { </a> 0
<a> flush_block_only ( false ) ; </a> 0
<a> if ( strm . avail_out == 0 ) { </a> 0
<a> return NeedMore ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> flush_block_only ( flush == JZlib . Z_FINISH ) ; </a> 0
<a> if ( strm . avail_out == 0 ) { </a> 0
<a> if ( flush == JZlib . Z_FINISH ) { </a> 0
<a> return FinishStarted ; </a> 0
<a> } else { </a> 0
<a> return NeedMore ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return flush == JZlib . Z_FINISH ? FinishDone : BlockDone ; </a> 0
<a> } </a> 0
<a> private int deflate_slow ( int flush ) { </a> 0
<a> int hash_head = 0 ; </a> 0
<a> boolean bflush ; </a> 0
<a> while ( true ) { </a> 0
<a> if ( lookahead < MIN_LOOKAHEAD ) { </a> 0
<a> fill_window ( ) ; </a> 0
<a> if ( lookahead < MIN_LOOKAHEAD && flush == JZlib . Z_NO_FLUSH ) { </a> 0
<a> return NeedMore ; </a> 0
<a> } </a> 0
<a> if ( lookahead == 0 ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( lookahead >= MIN_MATCH ) { </a> 0
<a> ins_h = ( ins_h < < hash_shift ^ window [ strstart + MIN_MATCH - 1 ] & 0xff ) & </a> 0
<a> hash_mask ; </a> 0
<a> hash_head = head [ ins_h ] & 0xffff ; </a> 0
<a> prev [ strstart & w_mask ] = head [ ins_h ] ; </a> 0
<a> head [ ins_h ] = ( short ) strstart ; </a> 0
<a> } </a> 0
<a> prev_length = match_length ; </a> 0
<a> prev_match = match_start ; </a> 0
<a> match_length = MIN_MATCH - 1 ; </a> 0
<a> if ( hash_head != 0 && prev_length < max_lazy_match && </a> 0
<a> ( strstart - hash_head & 0xffff ) <= w_size - MIN_LOOKAHEAD ) { </a> 0
<a> if ( strategy != JZlib . Z_HUFFMAN_ONLY ) { </a> 0
<a> match_length = longest_match ( hash_head ) ; </a> 0
<a> } </a> 0
<a> if ( match_length <= 5 && </a> 0
<a> ( strategy == JZlib . Z_FILTERED || match_length == MIN_MATCH && </a> 0
<a> strstart - match_start > 4096 ) ) { </a> 0
<a> match_length = MIN_MATCH - 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( prev_length >= MIN_MATCH && match_length <= prev_length ) { </a> 0
<a> int max_insert = strstart + lookahead - MIN_MATCH ; </a> 0
<a> bflush = _tr_tally ( strstart - 1 - prev_match , prev_length - </a> 0
<a> MIN_MATCH ) ; </a> 0
<a> lookahead -= prev_length - 1 ; </a> 0
<a> prev_length -= 2 ; </a> 0
<a> do { </a> 0
<a> if ( ++ strstart <= max_insert ) { </a> 0
<a> ins_h = ( ins_h < < hash_shift ^ window [ strstart + </a> 0
<a> MIN_MATCH - 1 ] & 0xff ) & </a> 0
<a> hash_mask ; </a> 0
<a> hash_head = head [ ins_h ] & 0xffff ; </a> 0
<a> prev [ strstart & w_mask ] = head [ ins_h ] ; </a> 0
<a> head [ ins_h ] = ( short ) strstart ; </a> 0
<a> } </a> 0
<a> } while ( -- prev_length != 0 ) ; </a> 0
<a> match_available = 0 ; </a> 0
<a> match_length = MIN_MATCH - 1 ; </a> 0
<a> strstart ++ ; </a> 0
<a> if ( bflush ) { </a> 0
<a> flush_block_only ( false ) ; </a> 0
<a> if ( strm . avail_out == 0 ) { </a> 0
<a> return NeedMore ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else if ( match_available != 0 ) { </a> 0
<a> bflush = _tr_tally ( 0 , window [ strstart - 1 ] & 0xff ) ; </a> 0
<a> if ( bflush ) { </a> 0
<a> flush_block_only ( false ) ; </a> 0
<a> } </a> 0
<a> strstart ++ ; </a> 0
<a> lookahead -- ; </a> 0
<a> if ( strm . avail_out == 0 ) { </a> 0
<a> return NeedMore ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> match_available = 1 ; </a> 0
<a> strstart ++ ; </a> 0
<a> lookahead -- ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( match_available != 0 ) { </a> 0
<a> _tr_tally ( 0 , window [ strstart - 1 ] & 0xff ) ; </a> 0
<a> match_available = 0 ; </a> 0
<a> } </a> 0
<a> flush_block_only ( flush == JZlib . Z_FINISH ) ; </a> 0
<a> if ( strm . avail_out == 0 ) { </a> 0
<a> if ( flush == JZlib . Z_FINISH ) { </a> 0
<a> return FinishStarted ; </a> 0
<a> } else { </a> 0
<a> return NeedMore ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return flush == JZlib . Z_FINISH ? FinishDone : BlockDone ; </a> 0
<a> } </a> 0
<a> private int longest_match ( int cur_match ) { </a> 0
<a> int chain_length = max_chain_length ; </a> 0
<a> int scan = strstart ; </a> 0
<a> int match ; </a> 0
<a> int len ; </a> 0
<a> int best_len = prev_length ; </a> 0
<a> int limit = strstart > w_size - MIN_LOOKAHEAD ? strstart - </a> 0
<a> ( w_size - MIN_LOOKAHEAD ) : 0 ; </a> 0
<a> int nice_match = this . nice_match ; </a> 0
<a> int wmask = w_mask ; </a> 0
<a> int strend = strstart + MAX_MATCH ; </a> 0
<a> byte scan_end1 = window [ scan + best_len - 1 ] ; </a> 0
<a> byte scan_end = window [ scan + best_len ] ; </a> 0
<a> if ( prev_length >= good_match ) { </a> 0
<a> chain_length >>= 2 ; </a> 0
<a> } </a> 0
<a> if ( nice_match > lookahead ) { </a> 0
<a> nice_match = lookahead ; </a> 0
<a> } </a> 0
<a> do { </a> 0
<a> match = cur_match ; </a> 0
<a> if ( window [ match + best_len ] != scan_end || </a> 0
<a> window [ match + best_len - 1 ] != scan_end1 || </a> 0
<a> window [ match ] != window [ scan ] || </a> 0
<a> window [ ++ match ] != window [ scan + 1 ] ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> scan += 2 ; </a> 0
<a> match ++ ; </a> 0
<a> while ( window [ ++ scan ] == window [ ++ match ] && </a> 0
<a> window [ ++ scan ] == window [ ++ match ] && </a> 0
<a> window [ ++ scan ] == window [ ++ match ] && </a> 0
<a> window [ ++ scan ] == window [ ++ match ] && </a> 0
<a> window [ ++ scan ] == window [ ++ match ] && </a> 0
<a> window [ ++ scan ] == window [ ++ match ] && </a> 0
<a> window [ ++ scan ] == window [ ++ match ] && </a> 0
<a> window [ ++ scan ] == window [ ++ match ] && scan < strend ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> len = MAX_MATCH - ( strend - scan ) ; </a> 0
<a> scan = strend - MAX_MATCH ; </a> 0
<a> if ( len > best_len ) { </a> 0
<a> match_start = cur_match ; </a> 0
<a> best_len = len ; </a> 0
<a> if ( len >= nice_match ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> scan_end1 = window [ scan + best_len - 1 ] ; </a> 0
<a> scan_end = window [ scan + best_len ] ; </a> 0
<a> } </a> 0
<a> } while ( ( cur_match = prev [ cur_match & wmask ] & 0xffff ) > limit && </a> 0
<a> -- chain_length != 0 ) ; </a> 0
<a> if ( best_len <= lookahead ) { </a> 0
<a> return best_len ; </a> 0
<a> } </a> 0
<a> return lookahead ; </a> 0
<a> } </a> 0
<a> int deflateInit ( ZStream strm , int level , int bits , int memLevel , WrapperType wrapperType ) { </a> 0
<a> return deflateInit2 ( strm , level , JZlib . Z_DEFLATED , bits , </a> 0
<a> memLevel , JZlib . Z_DEFAULT_STRATEGY , wrapperType ) ; </a> 0
<a> } </a> 0
<a> private int deflateInit2 ( ZStream strm , int level , int method , int windowBits , </a> 0
<a> int memLevel , int strategy , WrapperType wrapperType ) { </a> 0
<a> if ( wrapperType == WrapperType . ZLIB_OR_NONE ) { </a> 0
<a> throw new IllegalArgumentException ( "ZLIB_OR_NONE allowed only for inflate" ) ; </a> 0
<a> } </a> 0
<a> strm . msg = null ; </a> 0
<a> if ( level == JZlib . Z_DEFAULT_COMPRESSION ) { </a> 0
<a> level = 6 ; </a> 0
<a> } </a> 0
<a> if ( windowBits < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "windowBits: " + windowBits ) ; </a> 0
<a> } </a> 0
<a> if ( memLevel < 1 || memLevel > JZlib . MAX_MEM_LEVEL || </a> 0
<a> method != JZlib . Z_DEFLATED || windowBits < 9 || </a> 0
<a> windowBits > 15 || level < 0 || level > 9 || strategy < 0 || </a> 0
<a> strategy > JZlib . Z_HUFFMAN_ONLY ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> strm . dstate = this ; </a> 0
<a> this . wrapperType = wrapperType ; </a> 0
<a> w_bits = windowBits ; </a> 0
<a> w_size = 1 < < w_bits ; </a> 0
<a> w_mask = w_size - 1 ; </a> 0
<a> hash_bits = memLevel + 7 ; </a> 0
<a> hash_size = 1 < < hash_bits ; </a> 0
<a> hash_mask = hash_size - 1 ; </a> 0
<a> hash_shift = ( hash_bits + MIN_MATCH - 1 ) / MIN_MATCH ; </a> 0
<a> window = new byte [ w_size * 2 ] ; </a> 0
<a> prev = new short [ w_size ] ; </a> 0
<a> head = new short [ hash_size ] ; </a> 0
<a> lit_bufsize = 1 < < memLevel + 6 ; </a> 0
<a> pending_buf = new byte [ lit_bufsize * 4 ] ; </a> 0
<a> pending_buf_size = lit_bufsize * 4 ; </a> 0
<a> d_buf = lit_bufsize / 2 ; </a> 0
<a> l_buf = ( 1 + 2 ) * lit_bufsize ; </a> 0
<a> this . level = level ; </a> 0
<a> this . strategy = strategy ; </a> 0
<a> return deflateReset ( strm ) ; </a> 0
<a> } </a> 0
<a> private int deflateReset ( ZStream strm ) { </a> 0
<a> strm . total_in = strm . total_out = 0 ; </a> 0
<a> strm . msg = null ; </a> 0
<a> pending = 0 ; </a> 0
<a> pending_out = 0 ; </a> 0
<a> wroteTrailer = false ; </a> 0
<a> status = wrapperType == WrapperType . NONE ? BUSY_STATE : INIT_STATE ; </a> 0
<a> strm . adler = Adler32 . adler32 ( 0 , null , 0 , 0 ) ; </a> 0
<a> strm . crc32 = 0 ; </a> 0
<a> gzipUncompressedBytes = 0 ; </a> 0
<a> last_flush = JZlib . Z_NO_FLUSH ; </a> 0
<a> tr_init ( ) ; </a> 0
<a> lm_init ( ) ; </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> int deflateEnd ( ) { </a> 0
<a> if ( status != INIT_STATE && status != BUSY_STATE && </a> 0
<a> status != FINISH_STATE ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> pending_buf = null ; </a> 0
<a> head = null ; </a> 0
<a> prev = null ; </a> 0
<a> window = null ; </a> 0
<a> return status == BUSY_STATE ? JZlib . Z_DATA_ERROR : JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> int deflateParams ( ZStream strm , int _level , int _strategy ) { </a> 0
<a> int err = JZlib . Z_OK ; </a> 0
<a> if ( _level == JZlib . Z_DEFAULT_COMPRESSION ) { </a> 0
<a> _level = 6 ; </a> 0
<a> } </a> 0
<a> if ( _level < 0 || _level > 9 || _strategy < 0 || </a> 0
<a> _strategy > JZlib . Z_HUFFMAN_ONLY ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> if ( config_table [ level ] . func != config_table [ _level ] . func && </a> 0
<a> strm . total_in != 0 ) { </a> 0
<a> err = strm . deflate ( JZlib . Z_PARTIAL_FLUSH ) ; </a> 0
<a> } </a> 0
<a> if ( level != _level ) { </a> 0
<a> level = _level ; </a> 0
<a> max_lazy_match = config_table [ level ] . max_lazy ; </a> 0
<a> good_match = config_table [ level ] . good_length ; </a> 0
<a> nice_match = config_table [ level ] . nice_length ; </a> 0
<a> max_chain_length = config_table [ level ] . max_chain ; </a> 0
<a> } </a> 0
<a> strategy = _strategy ; </a> 0
<a> return err ; </a> 0
<a> } </a> 0
<a> int deflateSetDictionary ( ZStream strm , byte [ ] dictionary , int dictLength ) { </a> 0
<a> int length = dictLength ; </a> 0
<a> int index = 0 ; </a> 0
<a> if ( dictionary == null || status != INIT_STATE ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> strm . adler = Adler32 . adler32 ( strm . adler , dictionary , 0 , dictLength ) ; </a> 0
<a> if ( length < MIN_MATCH ) { </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> if ( length > w_size - MIN_LOOKAHEAD ) { </a> 0
<a> length = w_size - MIN_LOOKAHEAD ; </a> 0
<a> index = dictLength - length ; </a> 0
<a> } </a> 0
<a> System . arraycopy ( dictionary , index , window , 0 , length ) ; </a> 0
<a> strstart = length ; </a> 0
<a> block_start = length ; </a> 0
<a> ins_h = window [ 0 ] & 0xff ; </a> 0
<a> ins_h = ( ins_h < < hash_shift ^ window [ 1 ] & 0xff ) & hash_mask ; </a> 0
<a> for ( int n = 0 ; n <= length - MIN_MATCH ; n ++ ) { </a> 0
<a> ins_h = ( ins_h < < hash_shift ^ window [ n + MIN_MATCH - 1 ] & 0xff ) & </a> 0
<a> hash_mask ; </a> 0
<a> prev [ n & w_mask ] = head [ ins_h ] ; </a> 0
<a> head [ ins_h ] = ( short ) n ; </a> 0
<a> } </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> int deflate ( ZStream strm , int flush ) { </a> 0
<a> int old_flush ; </a> 0
<a> if ( flush > JZlib . Z_FINISH || flush < 0 ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> if ( strm . next_out == null || strm . next_in == null && </a> 0
<a> strm . avail_in != 0 || status == FINISH_STATE && </a> 0
<a> flush != JZlib . Z_FINISH ) { </a> 0
<a> strm . msg = z_errmsg [ JZlib . Z_NEED_DICT - JZlib . Z_STREAM_ERROR ] ; </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> if ( strm . avail_out == 0 ) { </a> 0
<a> strm . msg = z_errmsg [ JZlib . Z_NEED_DICT - JZlib . Z_BUF_ERROR ] ; </a> 0
<a> return JZlib . Z_BUF_ERROR ; </a> 0
<a> } </a> 0
<a> this . strm = strm ; </a> 0
<a> old_flush = last_flush ; </a> 0
<a> last_flush = flush ; </a> 0
<a> if ( status == INIT_STATE ) { </a> 0
<a> switch ( wrapperType ) { </a> 0
<a> case ZLIB : </a> 0
<a> int header = JZlib . Z_DEFLATED + ( w_bits - 8 < < 4 ) < < 8 ; </a> 0
<a> int level_flags = ( level - 1 & 0xff ) > > 1 ; </a> 0
<a> if ( level_flags > 3 ) { </a> 0
<a> level_flags = 3 ; </a> 0
<a> } </a> 0
<a> header |= level_flags < < 6 ; </a> 0
<a> if ( strstart != 0 ) { </a> 0
<a> header |= JZlib . PRESET_DICT ; </a> 0
<a> } </a> 0
<a> header += 31 - header % 31 ; </a> 0
<a> putShortMSB ( header ) ; </a> 0
<a> if ( strstart != 0 ) { </a> 0
<a> putShortMSB ( ( int ) ( strm . adler > > > 16 ) ) ; </a> 0
<a> putShortMSB ( ( int ) ( strm . adler & 0xffff ) ) ; </a> 0
<a> } </a> 0
<a> strm . adler = Adler32 . adler32 ( 0 , null , 0 , 0 ) ; </a> 0
<a> break ; </a> 0
<a> case GZIP : </a> 0
<a> put_byte ( ( byte ) 0x1f ) ; </a> 0
<a> put_byte ( ( byte ) 0x8b ) ; </a> 0
<a> put_byte ( ( byte ) 8 ) ; </a> 0
<a> put_byte ( ( byte ) 0 ) ; </a> 0
<a> put_byte ( ( byte ) 0 ) ; </a> 0
<a> put_byte ( ( byte ) 0 ) ; </a> 0
<a> put_byte ( ( byte ) 0 ) ; </a> 0
<a> put_byte ( ( byte ) 0 ) ; </a> 0
<a> switch ( config_table [ level ] . func ) { </a> 0
<a> case FAST : </a> 0
<a> put_byte ( ( byte ) 4 ) ; </a> 0
<a> break ; </a> 0
<a> case SLOW : </a> 0
<a> put_byte ( ( byte ) 2 ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> put_byte ( ( byte ) 0 ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> put_byte ( ( byte ) 255 ) ; </a> 0
<a> strm . crc32 = 0 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> status = BUSY_STATE ; </a> 0
<a> } </a> 0
<a> if ( pending != 0 ) { </a> 0
<a> strm . flush_pending ( ) ; </a> 0
<a> if ( strm . avail_out == 0 ) { </a> 0
<a> last_flush = - 1 ; </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> } else if ( strm . avail_in == 0 && flush <= old_flush && </a> 0
<a> flush != JZlib . Z_FINISH ) { </a> 0
<a> strm . msg = z_errmsg [ JZlib . Z_NEED_DICT - JZlib . Z_BUF_ERROR ] ; </a> 0
<a> return JZlib . Z_BUF_ERROR ; </a> 0
<a> } </a> 0
<a> if ( status == FINISH_STATE && strm . avail_in != 0 ) { </a> 0
<a> strm . msg = z_errmsg [ JZlib . Z_NEED_DICT - JZlib . Z_BUF_ERROR ] ; </a> 0
<a> return JZlib . Z_BUF_ERROR ; </a> 0
<a> } </a> 0
<a> int old_next_in_index = strm . next_in_index ; </a> 0
<a> try { </a> 0
<a> if ( strm . avail_in != 0 || lookahead != 0 || flush != JZlib . Z_NO_FLUSH && </a> 0
<a> status != FINISH_STATE ) { </a> 0
<a> int bstate = - 1 ; </a> 0
<a> switch ( config_table [ level ] . func ) { </a> 0
<a> case STORED : </a> 0
<a> bstate = deflate_stored ( flush ) ; </a> 0
<a> break ; </a> 0
<a> case FAST : </a> 0
<a> bstate = deflate_fast ( flush ) ; </a> 0
<a> break ; </a> 0
<a> case SLOW : </a> 0
<a> bstate = deflate_slow ( flush ) ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> } </a> 0
<a> if ( bstate == FinishStarted || bstate == FinishDone ) { </a> 0
<a> status = FINISH_STATE ; </a> 0
<a> } </a> 0
<a> if ( bstate == NeedMore || bstate == FinishStarted ) { </a> 0
<a> if ( strm . avail_out == 0 ) { </a> 0
<a> last_flush = - 1 ; </a> 0
<a> } </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> if ( bstate == BlockDone ) { </a> 0
<a> if ( flush == JZlib . Z_PARTIAL_FLUSH ) { </a> 0
<a> _tr_align ( ) ; </a> 0
<a> } else { </a> 0
<a> _tr_stored_block ( 0 , 0 , false ) ; </a> 0
<a> if ( flush == JZlib . Z_FULL_FLUSH ) { </a> 0
<a> for ( int i = 0 ; i < hash_size ; i ++ ) { </a> 0
<a> head [ i ] = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> strm . flush_pending ( ) ; </a> 0
<a> if ( strm . avail_out == 0 ) { </a> 0
<a> last_flush = - 1 ; </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> gzipUncompressedBytes += strm . next_in_index - old_next_in_index ; </a> 0
<a> } </a> 0
<a> if ( flush != JZlib . Z_FINISH ) { </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> if ( wrapperType == WrapperType . NONE || wroteTrailer ) { </a> 0
<a> return JZlib . Z_STREAM_END ; </a> 0
<a> } </a> 0
<a> switch ( wrapperType ) { </a> 0
<a> case ZLIB : </a> 0
<a> putShortMSB ( ( int ) ( strm . adler > > > 16 ) ) ; </a> 0
<a> putShortMSB ( ( int ) ( strm . adler & 0xffff ) ) ; </a> 0
<a> break ; </a> 0
<a> case GZIP : </a> 0
<a> put_byte ( ( byte ) ( strm . crc32 & 0xFF ) ) ; </a> 0
<a> put_byte ( ( byte ) ( strm . crc32 > > > 8 & 0xFF ) ) ; </a> 0
<a> put_byte ( ( byte ) ( strm . crc32 > > > 16 & 0xFF ) ) ; </a> 0
<a> put_byte ( ( byte ) ( strm . crc32 > > > 24 & 0xFF ) ) ; </a> 0
<a> put_byte ( ( byte ) ( gzipUncompressedBytes & 0xFF ) ) ; </a> 0
<a> put_byte ( ( byte ) ( gzipUncompressedBytes > > > 8 & 0xFF ) ) ; </a> 0
<a> put_byte ( ( byte ) ( gzipUncompressedBytes > > > 16 & 0xFF ) ) ; </a> 0
<a> put_byte ( ( byte ) ( gzipUncompressedBytes > > > 24 & 0xFF ) ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> strm . flush_pending ( ) ; </a> 0
<a> wroteTrailer = true ; </a> 0
<a> return pending != 0 ? JZlib . Z_OK : JZlib . Z_STREAM_END ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal . jzlib ; </a> 0
<a> final class InfBlocks { </a> 0
<a> private static final int [ ] inflate_mask = { 0x00000000 , 0x00000001 , </a> 0
<a> 0x00000003 , 0x00000007 , 0x0000000f , 0x0000001f , 0x0000003f , </a> 0
<a> 0x0000007f , 0x000000ff , 0x000001ff , 0x000003ff , 0x000007ff , </a> 0
<a> 0x00000fff , 0x00001fff , 0x00003fff , 0x00007fff , 0x0000ffff } ; </a> 0
<a> private static final int [ ] border = { </a> 0
<a> 16 , 17 , 18 , 0 , 8 , 7 , 9 , 6 , 10 , 5 , 11 , 4 , 12 , 3 , 13 , 2 , 14 , 1 , 15 } ; </a> 0
<a> private static final int TYPE = 0 ; </a> 0
<a> private static final int LENS = 1 ; </a> 0
<a> private static final int STORED = 2 ; </a> 0
<a> private static final int TABLE = 3 ; </a> 0
<a> private static final int BTREE = 4 ; </a> 0
<a> private static final int DTREE = 5 ; </a> 0
<a> private static final int CODES = 6 ; </a> 0
<a> private static final int DRY = 7 ; </a> 0
<a> private static final int DONE = 8 ; </a> 0
<a> private static final int BAD = 9 ; </a> 0
<a> private int mode ; </a> 0
<a> private int left ; </a> 0
<a> private int table ; </a> 0
<a> private int index ; </a> 0
<a> private int [ ] blens ; </a> 0
<a> private final int [ ] bb = new int [ 1 ] ; </a> 0
<a> private final int [ ] tb = new int [ 1 ] ; </a> 0
<a> private final InfCodes codes = new InfCodes ( ) ; </a> 0
<a> private int last ; </a> 0
<a> int bitk ; </a> 0
<a> int bitb ; </a> 0
<a> private int [ ] hufts ; </a> 0
<a> byte [ ] window ; </a> 0
<a> final int end ; </a> 0
<a> int read ; </a> 0
<a> int write ; </a> 0
<a> private final Object checkfn ; </a> 0
<a> private long check ; </a> 0
<a> private final InfTree inftree = new InfTree ( ) ; </a> 0
<a> InfBlocks ( ZStream z , Object checkfn , int w ) { </a> 0
<a> hufts = new int [ JZlib . MANY * 3 ] ; </a> 0
<a> window = new byte [ w ] ; </a> 0
<a> end = w ; </a> 0
<a> this . checkfn = checkfn ; </a> 0
<a> mode = TYPE ; </a> 0
<a> reset ( z , null ) ; </a> 0
<a> } </a> 0
<a> void reset ( ZStream z , long [ ] c ) { </a> 0
<a> if ( c != null ) { </a> 0
<a> c [ 0 ] = check ; </a> 0
<a> } </a> 0
<a> mode = TYPE ; </a> 0
<a> bitk = 0 ; </a> 0
<a> bitb = 0 ; </a> 0
<a> read = write = 0 ; </a> 0
<a> if ( checkfn != null ) { </a> 0
<a> z . adler = check = Adler32 . adler32 ( 0L , null , 0 , 0 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int proc ( ZStream z , int r ) { </a> 0
<a> int t ; </a> 0
<a> int b ; </a> 0
<a> int k ; </a> 0
<a> int p ; </a> 0
<a> int n ; </a> 0
<a> int q ; </a> 0
<a> int m ; </a> 0
<a> { </a> 0
<a> p = z . next_in_index ; </a> 0
<a> n = z . avail_in ; </a> 0
<a> b = bitb ; </a> 0
<a> k = bitk ; </a> 0
<a> } </a> 0
<a> { </a> 0
<a> q = write ; </a> 0
<a> m = q < read ? read - q - 1 : end - q ; </a> 0
<a> } </a> 0
<a> while ( true ) { </a> 0
<a> switch ( mode ) { </a> 0
<a> case TYPE : </a> 0
<a> while ( k < 3 ) { </a> 0
<a> if ( n != 0 ) { </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> } else { </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> t = b & 7 ; </a> 0
<a> last = t & 1 ; </a> 0
<a> switch ( t > > > 1 ) { </a> 0
<a> case 0 : </a> 0
<a> { </a> 0
<a> b >>>= 3 ; </a> 0
<a> k -= 3 ; </a> 0
<a> } </a> 0
<a> t = k & 7 ; </a> 0
<a> { </a> 0
<a> b >>>= t ; </a> 0
<a> k -= t ; </a> 0
<a> } </a> 0
<a> mode = LENS ; </a> 0
<a> break ; </a> 0
<a> case 1 : </a> 0
<a> { </a> 0
<a> int [ ] bl = new int [ 1 ] ; </a> 0
<a> int [ ] bd = new int [ 1 ] ; </a> 0
<a> int [ ] [ ] tl = new int [ 1 ] [ ] ; </a> 0
<a> int [ ] [ ] td = new int [ 1 ] [ ] ; </a> 0
<a> InfTree . inflate_trees_fixed ( bl , bd , tl , td ) ; </a> 0
<a> codes . init ( bl [ 0 ] , bd [ 0 ] , tl [ 0 ] , 0 , td [ 0 ] , 0 ) ; </a> 0
<a> } </a> 0
<a> { </a> 0
<a> b >>>= 3 ; </a> 0
<a> k -= 3 ; </a> 0
<a> } </a> 0
<a> mode = CODES ; </a> 0
<a> break ; </a> 0
<a> case 2 : </a> 0
<a> { </a> 0
<a> b >>>= 3 ; </a> 0
<a> k -= 3 ; </a> 0
<a> } </a> 0
<a> mode = TABLE ; </a> 0
<a> break ; </a> 0
<a> case 3 : </a> 0
<a> { </a> 0
<a> b >>>= 3 ; </a> 0
<a> k -= 3 ; </a> 0
<a> } </a> 0
<a> mode = BAD ; </a> 0
<a> z . msg = "invalid block type" ; </a> 0
<a> r = JZlib . Z_DATA_ERROR ; </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> case LENS : </a> 0
<a> while ( k < 32 ) { </a> 0
<a> if ( n != 0 ) { </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> } else { </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> if ( ( ~ b > > > 16 & 0xffff ) != ( b & 0xffff ) ) { </a> 0
<a> mode = BAD ; </a> 0
<a> z . msg = "invalid stored block lengths" ; </a> 0
<a> r = JZlib . Z_DATA_ERROR ; </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> left = b & 0xffff ; </a> 0
<a> b = k = 0 ; </a> 0
<a> mode = left != 0 ? STORED : last != 0 ? DRY : TYPE ; </a> 0
<a> break ; </a> 0
<a> case STORED : </a> 0
<a> if ( n == 0 ) { </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> if ( m == 0 ) { </a> 0
<a> if ( q == end && read != 0 ) { </a> 0
<a> q = 0 ; </a> 0
<a> m = q < read ? read - q - 1 : end - q ; </a> 0
<a> } </a> 0
<a> if ( m == 0 ) { </a> 0
<a> write = q ; </a> 0
<a> r = inflate_flush ( z , r ) ; </a> 0
<a> q = write ; </a> 0
<a> m = q < read ? read - q - 1 : end - q ; </a> 0
<a> if ( q == end && read != 0 ) { </a> 0
<a> q = 0 ; </a> 0
<a> m = q < read ? read - q - 1 : end - q ; </a> 0
<a> } </a> 0
<a> if ( m == 0 ) { </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> t = left ; </a> 0
<a> if ( t > n ) { </a> 0
<a> t = n ; </a> 0
<a> } </a> 0
<a> if ( t > m ) { </a> 0
<a> t = m ; </a> 0
<a> } </a> 0
<a> System . arraycopy ( z . next_in , p , window , q , t ) ; </a> 0
<a> p += t ; </a> 0
<a> n -= t ; </a> 0
<a> q += t ; </a> 0
<a> m -= t ; </a> 0
<a> if ( ( left -= t ) != 0 ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> mode = last != 0 ? DRY : TYPE ; </a> 0
<a> break ; </a> 0
<a> case TABLE : </a> 0
<a> while ( k < 14 ) { </a> 0
<a> if ( n != 0 ) { </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> } else { </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> table = t = b & 0x3fff ; </a> 0
<a> if ( ( t & 0x1f ) > 29 || ( t > > 5 & 0x1f ) > 29 ) { </a> 0
<a> mode = BAD ; </a> 0
<a> z . msg = "too many length or distance symbols" ; </a> 0
<a> r = JZlib . Z_DATA_ERROR ; </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> t = 258 + ( t & 0x1f ) + ( t > > 5 & 0x1f ) ; </a> 0
<a> if ( blens == null || blens . length < t ) { </a> 0
<a> blens = new int [ t ] ; </a> 0
<a> } else { </a> 0
<a> for ( int i = 0 ; i < t ; i ++ ) { </a> 0
<a> blens [ i ] = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> { </a> 0
<a> b >>>= 14 ; </a> 0
<a> k -= 14 ; </a> 0
<a> } </a> 0
<a> index = 0 ; </a> 0
<a> mode = BTREE ; </a> 0
<a> case BTREE : </a> 0
<a> while ( index < 4 + ( table > > > 10 ) ) { </a> 0
<a> while ( k < 3 ) { </a> 0
<a> if ( n != 0 ) { </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> } else { </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> blens [ border [ index ++ ] ] = b & 7 ; </a> 0
<a> { </a> 0
<a> b >>>= 3 ; </a> 0
<a> k -= 3 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> while ( index < 19 ) { </a> 0
<a> blens [ border [ index ++ ] ] = 0 ; </a> 0
<a> } </a> 0
<a> bb [ 0 ] = 7 ; </a> 0
<a> t = inftree . inflate_trees_bits ( blens , bb , tb , hufts , z ) ; </a> 0
<a> if ( t != JZlib . Z_OK ) { </a> 0
<a> r = t ; </a> 0
<a> if ( r == JZlib . Z_DATA_ERROR ) { </a> 0
<a> blens = null ; </a> 0
<a> mode = BAD ; </a> 0
<a> } </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> index = 0 ; </a> 0
<a> mode = DTREE ; </a> 0
<a> case DTREE : </a> 0
<a> while ( true ) { </a> 0
<a> t = table ; </a> 0
<a> if ( ! ( index < 258 + ( t & 0x1f ) + ( t > > 5 & 0x1f ) ) ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> int i , j , c ; </a> 0
<a> t = bb [ 0 ] ; </a> 0
<a> while ( k < t ) { </a> 0
<a> if ( n != 0 ) { </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> } else { </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> if ( tb [ 0 ] == - 1 ) { </a> 0
<a> } </a> 0
<a> t = hufts [ ( tb [ 0 ] + ( b & inflate_mask [ t ] ) ) * 3 + 1 ] ; </a> 0
<a> c = hufts [ ( tb [ 0 ] + ( b & inflate_mask [ t ] ) ) * 3 + 2 ] ; </a> 0
<a> if ( c < 16 ) { </a> 0
<a> b >>>= t ; </a> 0
<a> k -= t ; </a> 0
<a> blens [ index ++ ] = c ; </a> 0
<a> } else { </a> 0
<a> i = c == 18 ? 7 : c - 14 ; </a> 0
<a> j = c == 18 ? 11 : 3 ; </a> 0
<a> while ( k < t + i ) { </a> 0
<a> if ( n != 0 ) { </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> } else { </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> b >>>= t ; </a> 0
<a> k -= t ; </a> 0
<a> j += b & inflate_mask [ i ] ; </a> 0
<a> b >>>= i ; </a> 0
<a> k -= i ; </a> 0
<a> i = index ; </a> 0
<a> t = table ; </a> 0
<a> if ( i + j > 258 + ( t & 0x1f ) + ( t > > 5 & 0x1f ) || </a> 0
<a> c == 16 && i < 1 ) { </a> 0
<a> blens = null ; </a> 0
<a> mode = BAD ; </a> 0
<a> z . msg = "invalid bit length repeat" ; </a> 0
<a> r = JZlib . Z_DATA_ERROR ; </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> c = c == 16 ? blens [ i - 1 ] : 0 ; </a> 0
<a> do { </a> 0
<a> blens [ i ++ ] = c ; </a> 0
<a> } while ( -- j != 0 ) ; </a> 0
<a> index = i ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> tb [ 0 ] = - 1 ; </a> 0
<a> { </a> 0
<a> int [ ] bl = new int [ 1 ] ; </a> 0
<a> int [ ] bd = new int [ 1 ] ; </a> 0
<a> int [ ] tl = new int [ 1 ] ; </a> 0
<a> int [ ] td = new int [ 1 ] ; </a> 0
<a> bl [ 0 ] = 9 ; </a> 0
<a> bd [ 0 ] = 6 ; </a> 0
<a> t = table ; </a> 0
<a> t = inftree . inflate_trees_dynamic ( 257 + ( t & 0x1f ) , </a> 0
<a> 1 + ( t > > 5 & 0x1f ) , blens , bl , bd , tl , td , hufts , </a> 0
<a> z ) ; </a> 0
<a> if ( t != JZlib . Z_OK ) { </a> 0
<a> if ( t == JZlib . Z_DATA_ERROR ) { </a> 0
<a> blens = null ; </a> 0
<a> mode = BAD ; </a> 0
<a> } </a> 0
<a> r = t ; </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> codes . init ( bl [ 0 ] , bd [ 0 ] , hufts , tl [ 0 ] , hufts , td [ 0 ] ) ; </a> 0
<a> } </a> 0
<a> mode = CODES ; </a> 0
<a> case CODES : </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> if ( ( r = codes . proc ( this , z , r ) ) != JZlib . Z_STREAM_END ) { </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> p = z . next_in_index ; </a> 0
<a> n = z . avail_in ; </a> 0
<a> b = bitb ; </a> 0
<a> k = bitk ; </a> 0
<a> q = write ; </a> 0
<a> m = q < read ? read - q - 1 : end - q ; </a> 0
<a> if ( last == 0 ) { </a> 0
<a> mode = TYPE ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> mode = DRY ; </a> 0
<a> case DRY : </a> 0
<a> write = q ; </a> 0
<a> r = inflate_flush ( z , r ) ; </a> 0
<a> q = write ; </a> 0
<a> if ( read != write ) { </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> mode = DONE ; </a> 0
<a> case DONE : </a> 0
<a> r = JZlib . Z_STREAM_END ; </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> case BAD : </a> 0
<a> r = JZlib . Z_DATA_ERROR ; </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> default : </a> 0
<a> r = JZlib . Z_STREAM_ERROR ; </a> 0
<a> bitb = b ; </a> 0
<a> bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> write = q ; </a> 0
<a> return inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void free ( ZStream z ) { </a> 0
<a> reset ( z , null ) ; </a> 0
<a> window = null ; </a> 0
<a> hufts = null ; </a> 0
<a> } </a> 0
<a> void set_dictionary ( byte [ ] d , int start , int n ) { </a> 0
<a> System . arraycopy ( d , start , window , 0 , n ) ; </a> 0
<a> read = write = n ; </a> 0
<a> } </a> 0
<a> int sync_point ( ) { </a> 0
<a> return mode == LENS ? 1 : 0 ; </a> 0
<a> } </a> 0
<a> int inflate_flush ( ZStream z , int r ) { </a> 0
<a> int n ; </a> 0
<a> int p ; </a> 0
<a> int q ; </a> 0
<a> p = z . next_out_index ; </a> 0
<a> q = read ; </a> 0
<a> n = ( q <= write ? write : end ) - q ; </a> 0
<a> if ( n > z . avail_out ) { </a> 0
<a> n = z . avail_out ; </a> 0
<a> } </a> 0
<a> if ( n != 0 && r == JZlib . Z_BUF_ERROR ) { </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> z . avail_out -= n ; </a> 0
<a> z . total_out += n ; </a> 0
<a> if ( checkfn != null ) { </a> 0
<a> z . adler = check = Adler32 . adler32 ( check , window , q , n ) ; </a> 0
<a> } </a> 0
<a> System . arraycopy ( window , q , z . next_out , p , n ) ; </a> 0
<a> p += n ; </a> 0
<a> q += n ; </a> 0
<a> if ( q == end ) { </a> 0
<a> q = 0 ; </a> 0
<a> if ( write == end ) { </a> 0
<a> write = 0 ; </a> 0
<a> } </a> 0
<a> n = write - q ; </a> 0
<a> if ( n > z . avail_out ) { </a> 0
<a> n = z . avail_out ; </a> 0
<a> } </a> 0
<a> if ( n != 0 && r == JZlib . Z_BUF_ERROR ) { </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> z . avail_out -= n ; </a> 0
<a> z . total_out += n ; </a> 0
<a> if ( checkfn != null ) { </a> 0
<a> z . adler = check = Adler32 . adler32 ( check , window , q , n ) ; </a> 0
<a> } </a> 0
<a> System . arraycopy ( window , q , z . next_out , p , n ) ; </a> 0
<a> p += n ; </a> 0
<a> q += n ; </a> 0
<a> } </a> 0
<a> z . next_out_index = p ; </a> 0
<a> read = q ; </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal . jzlib ; </a> 0
<a> final class InfCodes { </a> 0
<a> private static final int [ ] inflate_mask = { 0x00000000 , 0x00000001 , </a> 0
<a> 0x00000003 , 0x00000007 , 0x0000000f , 0x0000001f , 0x0000003f , </a> 0
<a> 0x0000007f , 0x000000ff , 0x000001ff , 0x000003ff , 0x000007ff , </a> 0
<a> 0x00000fff , 0x00001fff , 0x00003fff , 0x00007fff , 0x0000ffff } ; </a> 0
<a> private static final int START = 0 ; </a> 0
<a> private static final int LEN = 1 ; </a> 0
<a> private static final int LENEXT = 2 ; </a> 0
<a> private static final int DIST = 3 ; </a> 0
<a> private static final int DISTEXT = 4 ; </a> 0
<a> private static final int COPY = 5 ; </a> 0
<a> private static final int LIT = 6 ; </a> 0
<a> private static final int WASH = 7 ; </a> 0
<a> private static final int END = 8 ; </a> 0
<a> private static final int BADCODE = 9 ; </a> 0
<a> private int mode ; </a> 0
<a> private int len ; </a> 0
<a> private int [ ] tree ; </a> 0
<a> private int tree_index ; </a> 0
<a> private int need ; </a> 0
<a> private int lit ; </a> 0
<a> private int get ; </a> 0
<a> private int dist ; </a> 0
<a> private byte lbits ; </a> 0
<a> private byte dbits ; </a> 0
<a> private int [ ] ltree ; </a> 0
<a> private int ltree_index ; </a> 0
<a> private int [ ] dtree ; </a> 0
<a> private int dtree_index ; </a> 0
<a> void init ( int bl , int bd , int [ ] tl , int tl_index , int [ ] td , int td_index ) { </a> 0
<a> mode = START ; </a> 0
<a> lbits = ( byte ) bl ; </a> 0
<a> dbits = ( byte ) bd ; </a> 0
<a> ltree = tl ; </a> 0
<a> ltree_index = tl_index ; </a> 0
<a> dtree = td ; </a> 0
<a> dtree_index = td_index ; </a> 0
<a> tree = null ; </a> 0
<a> } </a> 0
<a> int proc ( InfBlocks s , ZStream z , int r ) { </a> 0
<a> int j ; </a> 0
<a> int tindex ; </a> 0
<a> int e ; </a> 0
<a> int b = 0 ; </a> 1
<a> int k = 0 ; </a> 1
<a> int p = 0 ; </a> 1
<a> int n ; </a> 0
<a> int q ; </a> 0
<a> int m ; </a> 0
<a> int f ; </a> 0
<a> p = z . next_in_index ; </a> 0
<a> n = z . avail_in ; </a> 0
<a> b = s . bitb ; </a> 0
<a> k = s . bitk ; </a> 0
<a> q = s . write ; </a> 0
<a> m = q < s . read ? s . read - q - 1 : s . end - q ; </a> 0
<a> while ( true ) { </a> 0
<a> switch ( mode ) { </a> 0
<a> case START : </a> 0
<a> if ( m >= 258 && n >= 10 ) { </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> r = inflate_fast ( lbits , dbits , ltree , ltree_index , dtree , </a> 0
<a> dtree_index , s , z ) ; </a> 0
<a> p = z . next_in_index ; </a> 0
<a> n = z . avail_in ; </a> 0
<a> b = s . bitb ; </a> 0
<a> k = s . bitk ; </a> 0
<a> q = s . write ; </a> 0
<a> m = q < s . read ? s . read - q - 1 : s . end - q ; </a> 0
<a> if ( r != JZlib . Z_OK ) { </a> 0
<a> mode = r == JZlib . Z_STREAM_END ? WASH : BADCODE ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> need = lbits ; </a> 0
<a> tree = ltree ; </a> 0
<a> tree_index = ltree_index ; </a> 0
<a> mode = LEN ; </a> 0
<a> case LEN : </a> 0
<a> j = need ; </a> 0
<a> while ( k < j ) { </a> 0
<a> if ( n != 0 ) { </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> } else { </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return s . inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> tindex = ( tree_index + ( b & inflate_mask [ j ] ) ) * 3 ; </a> 0
<a> b >>>= tree [ tindex + 1 ] ; </a> 0
<a> k -= tree [ tindex + 1 ] ; </a> 0
<a> e = tree [ tindex ] ; </a> 0
<a> if ( e == 0 ) { </a> 0
<a> lit = tree [ tindex + 2 ] ; </a> 0
<a> mode = LIT ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ( e & 16 ) != 0 ) { </a> 0
<a> get = e & 15 ; </a> 0
<a> len = tree [ tindex + 2 ] ; </a> 0
<a> mode = LENEXT ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ( e & 64 ) == 0 ) { </a> 0
<a> need = e ; </a> 0
<a> tree_index = tindex / 3 + tree [ tindex + 2 ] ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ( e & 32 ) != 0 ) { </a> 0
<a> mode = WASH ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> mode = BADCODE ; </a> 0
<a> z . msg = "invalid literal/length code" ; </a> 0
<a> r = JZlib . Z_DATA_ERROR ; </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return s . inflate_flush ( z , r ) ; </a> 0
<a> case LENEXT : </a> 0
<a> j = get ; </a> 0
<a> while ( k < j ) { </a> 0
<a> if ( n != 0 ) { </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> } else { </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return s . inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> len += b & inflate_mask [ j ] ; </a> 0
<a> b >>= j ; </a> 0
<a> k -= j ; </a> 0
<a> need = dbits ; </a> 0
<a> tree = dtree ; </a> 0
<a> tree_index = dtree_index ; </a> 0
<a> mode = DIST ; </a> 0
<a> case DIST : </a> 0
<a> j = need ; </a> 0
<a> while ( k < j ) { </a> 0
<a> if ( n != 0 ) { </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> } else { </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return s . inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> tindex = ( tree_index + ( b & inflate_mask [ j ] ) ) * 3 ; </a> 0
<a> b >>= tree [ tindex + 1 ] ; </a> 0
<a> k -= tree [ tindex + 1 ] ; </a> 0
<a> e = tree [ tindex ] ; </a> 0
<a> if ( ( e & 16 ) != 0 ) { </a> 0
<a> get = e & 15 ; </a> 0
<a> dist = tree [ tindex + 2 ] ; </a> 0
<a> mode = DISTEXT ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ( e & 64 ) == 0 ) { </a> 0
<a> need = e ; </a> 0
<a> tree_index = tindex / 3 + tree [ tindex + 2 ] ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> mode = BADCODE ; </a> 0
<a> z . msg = "invalid distance code" ; </a> 0
<a> r = JZlib . Z_DATA_ERROR ; </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return s . inflate_flush ( z , r ) ; </a> 0
<a> case DISTEXT : </a> 0
<a> j = get ; </a> 0
<a> while ( k < j ) { </a> 0
<a> if ( n != 0 ) { </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> } else { </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return s . inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> dist += b & inflate_mask [ j ] ; </a> 0
<a> b >>= j ; </a> 0
<a> k -= j ; </a> 0
<a> mode = COPY ; </a> 0
<a> case COPY : </a> 0
<a> f = q - dist ; </a> 0
<a> while ( f < 0 ) { </a> 0
<a> f += s . end ; </a> 0
<a> } </a> 0
<a> while ( len != 0 ) { </a> 0
<a> if ( m == 0 ) { </a> 0
<a> if ( q == s . end && s . read != 0 ) { </a> 0
<a> q = 0 ; </a> 0
<a> m = q < s . read ? s . read - q - 1 : s . end - q ; </a> 0
<a> } </a> 0
<a> if ( m == 0 ) { </a> 0
<a> s . write = q ; </a> 0
<a> r = s . inflate_flush ( z , r ) ; </a> 0
<a> q = s . write ; </a> 0
<a> m = q < s . read ? s . read - q - 1 : s . end - q ; </a> 0
<a> if ( q == s . end && s . read != 0 ) { </a> 0
<a> q = 0 ; </a> 0
<a> m = q < s . read ? s . read - q - 1 : s . end - q ; </a> 0
<a> } </a> 0
<a> if ( m == 0 ) { </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return s . inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> s . window [ q ++ ] = s . window [ f ++ ] ; </a> 0
<a> m -- ; </a> 0
<a> if ( f == s . end ) { </a> 0
<a> f = 0 ; </a> 0
<a> } </a> 0
<a> len -- ; </a> 0
<a> } </a> 0
<a> mode = START ; </a> 0
<a> break ; </a> 0
<a> case LIT : </a> 0
<a> if ( m == 0 ) { </a> 0
<a> if ( q == s . end && s . read != 0 ) { </a> 0
<a> q = 0 ; </a> 0
<a> m = q < s . read ? s . read - q - 1 : s . end - q ; </a> 0
<a> } </a> 0
<a> if ( m == 0 ) { </a> 0
<a> s . write = q ; </a> 0
<a> r = s . inflate_flush ( z , r ) ; </a> 0
<a> q = s . write ; </a> 0
<a> m = q < s . read ? s . read - q - 1 : s . end - q ; </a> 0
<a> if ( q == s . end && s . read != 0 ) { </a> 0
<a> q = 0 ; </a> 0
<a> m = q < s . read ? s . read - q - 1 : s . end - q ; </a> 0
<a> } </a> 0
<a> if ( m == 0 ) { </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return s . inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> r = JZlib . Z_OK ; </a> 0
<a> s . window [ q ++ ] = ( byte ) lit ; </a> 0
<a> m -- ; </a> 0
<a> mode = START ; </a> 0
<a> break ; </a> 0
<a> case WASH : </a> 0
<a> if ( k > 7 ) { </a> 0
<a> k -= 8 ; </a> 0
<a> n ++ ; </a> 0
<a> p -- ; </a> 0
<a> } </a> 0
<a> s . write = q ; </a> 0
<a> r = s . inflate_flush ( z , r ) ; </a> 0
<a> q = s . write ; </a> 0
<a> if ( s . read != s . write ) { </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return s . inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> mode = END ; </a> 0
<a> case END : </a> 0
<a> r = JZlib . Z_STREAM_END ; </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return s . inflate_flush ( z , r ) ; </a> 0
<a> case BADCODE : </a> 0
<a> r = JZlib . Z_DATA_ERROR ; </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return s . inflate_flush ( z , r ) ; </a> 0
<a> default : </a> 0
<a> r = JZlib . Z_STREAM_ERROR ; </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return s . inflate_flush ( z , r ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static int inflate_fast ( int bl , int bd , int [ ] tl , int tl_index , int [ ] td , </a> 0
<a> int td_index , InfBlocks s , ZStream z ) { </a> 0
<a> int t ; </a> 0
<a> int [ ] tp ; </a> 0
<a> int tp_index ; </a> 0
<a> int e ; </a> 0
<a> int b ; </a> 0
<a> int k ; </a> 0
<a> int p ; </a> 0
<a> int n ; </a> 0
<a> int q ; </a> 0
<a> int m ; </a> 0
<a> int ml ; </a> 0
<a> int md ; </a> 0
<a> int c ; </a> 0
<a> int d ; </a> 0
<a> int r ; </a> 0
<a> int tp_index_t_3 ; </a> 0
<a> p = z . next_in_index ; </a> 0
<a> n = z . avail_in ; </a> 0
<a> b = s . bitb ; </a> 0
<a> k = s . bitk ; </a> 0
<a> q = s . write ; </a> 0
<a> m = q < s . read ? s . read - q - 1 : s . end - q ; </a> 0
<a> ml = inflate_mask [ bl ] ; </a> 0
<a> md = inflate_mask [ bd ] ; </a> 0
<a> do { </a> 0
<a> while ( k < 20 ) { </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> t = b & ml ; </a> 0
<a> tp = tl ; </a> 0
<a> tp_index = tl_index ; </a> 0
<a> tp_index_t_3 = ( tp_index + t ) * 3 ; </a> 0
<a> if ( ( e = tp [ tp_index_t_3 ] ) == 0 ) { </a> 0
<a> b >>= tp [ tp_index_t_3 + 1 ] ; </a> 0
<a> k -= tp [ tp_index_t_3 + 1 ] ; </a> 0
<a> s . window [ q ++ ] = ( byte ) tp [ tp_index_t_3 + 2 ] ; </a> 0
<a> m -- ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> do { </a> 0
<a> b >>= tp [ tp_index_t_3 + 1 ] ; </a> 0
<a> k -= tp [ tp_index_t_3 + 1 ] ; </a> 0
<a> if ( ( e & 16 ) != 0 ) { </a> 0
<a> e &= 15 ; </a> 0
<a> c = tp [ tp_index_t_3 + 2 ] + ( b & inflate_mask [ e ] ) ; </a> 0
<a> b >>= e ; </a> 0
<a> k -= e ; </a> 0
<a> while ( k < 15 ) { </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> t = b & md ; </a> 0
<a> tp = td ; </a> 0
<a> tp_index = td_index ; </a> 0
<a> tp_index_t_3 = ( tp_index + t ) * 3 ; </a> 0
<a> e = tp [ tp_index_t_3 ] ; </a> 0
<a> do { </a> 0
<a> b >>= tp [ tp_index_t_3 + 1 ] ; </a> 0
<a> k -= tp [ tp_index_t_3 + 1 ] ; </a> 0
<a> if ( ( e & 16 ) != 0 ) { </a> 0
<a> e &= 15 ; </a> 0
<a> while ( k < e ) { </a> 0
<a> n -- ; </a> 0
<a> b |= ( z . next_in [ p ++ ] & 0xff ) < < k ; </a> 0
<a> k += 8 ; </a> 0
<a> } </a> 0
<a> d = tp [ tp_index_t_3 + 2 ] + ( b & inflate_mask [ e ] ) ; </a> 0
<a> b >>= e ; </a> 0
<a> k -= e ; </a> 0
<a> m -= c ; </a> 0
<a> if ( q >= d ) { </a> 0
<a> r = q - d ; </a> 0
<a> if ( q - r > 0 && 2 > q - r ) { </a> 0
<a> s . window [ q ++ ] = s . window [ r ++ ] ; </a> 0
<a> s . window [ q ++ ] = s . window [ r ++ ] ; </a> 0
<a> c -= 2 ; </a> 0
<a> } else { </a> 0
<a> System . arraycopy ( s . window , r , s . window , q , </a> 0
<a> 2 ) ; </a> 0
<a> q += 2 ; </a> 0
<a> r += 2 ; </a> 0
<a> c -= 2 ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> r = q - d ; </a> 0
<a> do { </a> 0
<a> r += s . end ; </a> 0
<a> } while ( r < 0 ) ; </a> 0
<a> e = s . end - r ; </a> 0
<a> if ( c > e ) { </a> 0
<a> c -= e ; </a> 0
<a> if ( q - r > 0 && e > q - r ) { </a> 0
<a> do { </a> 0
<a> s . window [ q ++ ] = s . window [ r ++ ] ; </a> 0
<a> } while ( -- e != 0 ) ; </a> 0
<a> } else { </a> 0
<a> System . arraycopy ( s . window , r , s . window , </a> 0
<a> q , e ) ; </a> 0
<a> q += e ; </a> 0
<a> r += e ; </a> 0
<a> e = 0 ; </a> 1
<a> } </a> 0
<a> r = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( q - r > 0 && c > q - r ) { </a> 0
<a> do { </a> 0
<a> s . window [ q ++ ] = s . window [ r ++ ] ; </a> 0
<a> } while ( -- c != 0 ) ; </a> 0
<a> } else { </a> 0
<a> System . arraycopy ( s . window , r , s . window , q , c ) ; </a> 0
<a> q += c ; </a> 0
<a> r += c ; </a> 0
<a> c = 0 ; </a> 1
<a> } </a> 0
<a> break ; </a> 0
<a> } else if ( ( e & 64 ) == 0 ) { </a> 0
<a> t += tp [ tp_index_t_3 + 2 ] ; </a> 0
<a> t += b & inflate_mask [ e ] ; </a> 0
<a> tp_index_t_3 = ( tp_index + t ) * 3 ; </a> 0
<a> e = tp [ tp_index_t_3 ] ; </a> 0
<a> } else { </a> 0
<a> z . msg = "invalid distance code" ; </a> 0
<a> c = z . avail_in - n ; </a> 0
<a> c = k > > 3 < c ? k > > 3 : c ; </a> 0
<a> n += c ; </a> 0
<a> p -= c ; </a> 0
<a> k -= c < < 3 ; </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return JZlib . Z_DATA_ERROR ; </a> 0
<a> } </a> 0
<a> } while ( true ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ( e & 64 ) == 0 ) { </a> 0
<a> t += tp [ tp_index_t_3 + 2 ] ; </a> 0
<a> t += b & inflate_mask [ e ] ; </a> 0
<a> tp_index_t_3 = ( tp_index + t ) * 3 ; </a> 0
<a> if ( ( e = tp [ tp_index_t_3 ] ) == 0 ) { </a> 0
<a> b >>= tp [ tp_index_t_3 + 1 ] ; </a> 0
<a> k -= tp [ tp_index_t_3 + 1 ] ; </a> 0
<a> s . window [ q ++ ] = ( byte ) tp [ tp_index_t_3 + 2 ] ; </a> 0
<a> m -- ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } else if ( ( e & 32 ) != 0 ) { </a> 0
<a> c = z . avail_in - n ; </a> 0
<a> c = k > > 3 < c ? k > > 3 : c ; </a> 0
<a> n += c ; </a> 0
<a> p -= c ; </a> 0
<a> k -= c < < 3 ; </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return JZlib . Z_STREAM_END ; </a> 0
<a> } else { </a> 0
<a> z . msg = "invalid literal/length code" ; </a> 0
<a> c = z . avail_in - n ; </a> 0
<a> c = k > > 3 < c ? k > > 3 : c ; </a> 0
<a> n += c ; </a> 0
<a> p -= c ; </a> 0
<a> k -= c < < 3 ; </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return JZlib . Z_DATA_ERROR ; </a> 0
<a> } </a> 0
<a> } while ( true ) ; </a> 0
<a> } while ( m >= 258 && n >= 10 ) ; </a> 0
<a> c = z . avail_in - n ; </a> 0
<a> c = k > > 3 < c ? k > > 3 : c ; </a> 0
<a> n += c ; </a> 0
<a> p -= c ; </a> 0
<a> k -= c < < 3 ; </a> 0
<a> s . bitb = b ; </a> 0
<a> s . bitk = k ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> s . write = q ; </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal . jzlib ; </a> 0
<a> final class InfTree { </a> 0
<a> static final int fixed_bl = 9 ; </a> 0
<a> static final int fixed_bd = 5 ; </a> 0
<a> static final int [ ] fixed_tl = { 96 , 7 , 256 , 0 , 8 , 80 , 0 , 8 , 16 , 84 , 8 , 115 , </a> 0
<a> 82 , 7 , 31 , 0 , 8 , 112 , 0 , 8 , 48 , 0 , 9 , 192 , 80 , 7 , 10 , 0 , 8 , 96 , 0 , </a> 0
<a> 8 , 32 , 0 , 9 , 160 , 0 , 8 , 0 , 0 , 8 , 128 , 0 , 8 , 64 , 0 , 9 , 224 , 80 , 7 , </a> 0
<a> 6 , 0 , 8 , 88 , 0 , 8 , 24 , 0 , 9 , 144 , 83 , 7 , 59 , 0 , 8 , 120 , 0 , 8 , 56 , </a> 0
<a> 0 , 9 , 208 , 81 , 7 , 17 , 0 , 8 , 104 , 0 , 8 , 40 , 0 , 9 , 176 , 0 , 8 , 8 , 0 , </a> 0
<a> 8 , 136 , 0 , 8 , 72 , 0 , 9 , 240 , 80 , 7 , 4 , 0 , 8 , 84 , 0 , 8 , 20 , 85 , 8 , </a> 0
<a> 227 , 83 , 7 , 43 , 0 , 8 , 116 , 0 , 8 , 52 , 0 , 9 , 200 , 81 , 7 , 13 , 0 , 8 , </a> 0
<a> 100 , 0 , 8 , 36 , 0 , 9 , 168 , 0 , 8 , 4 , 0 , 8 , 132 , 0 , 8 , 68 , 0 , 9 , 232 , </a> 0
<a> 80 , 7 , 8 , 0 , 8 , 92 , 0 , 8 , 28 , 0 , 9 , 152 , 84 , 7 , 83 , 0 , 8 , 124 , 0 , </a> 0
<a> 8 , 60 , 0 , 9 , 216 , 82 , 7 , 23 , 0 , 8 , 108 , 0 , 8 , 44 , 0 , 9 , 184 , 0 , 8 , </a> 0
<a> 12 , 0 , 8 , 140 , 0 , 8 , 76 , 0 , 9 , 248 , 80 , 7 , 3 , 0 , 8 , 82 , 0 , 8 , 18 , </a> 0
<a> 85 , 8 , 163 , 83 , 7 , 35 , 0 , 8 , 114 , 0 , 8 , 50 , 0 , 9 , 196 , 81 , 7 , 11 , </a> 0
<a> 0 , 8 , 98 , 0 , 8 , 34 , 0 , 9 , 164 , 0 , 8 , 2 , 0 , 8 , 130 , 0 , 8 , 66 , 0 , 9 , </a> 0
<a> 228 , 80 , 7 , 7 , 0 , 8 , 90 , 0 , 8 , 26 , 0 , 9 , 148 , 84 , 7 , 67 , 0 , 8 , 122 , </a> 0
<a> 0 , 8 , 58 , 0 , 9 , 212 , 82 , 7 , 19 , 0 , 8 , 106 , 0 , 8 , 42 , 0 , 9 , 180 , 0 , </a> 0
<a> 8 , 10 , 0 , 8 , 138 , 0 , 8 , 74 , 0 , 9 , 244 , 80 , 7 , 5 , 0 , 8 , 86 , 0 , 8 , </a> 0
<a> 22 , 192 , 8 , 0 , 83 , 7 , 51 , 0 , 8 , 118 , 0 , 8 , 54 , 0 , 9 , 204 , 81 , 7 , </a> 0
<a> 15 , 0 , 8 , 102 , 0 , 8 , 38 , 0 , 9 , 172 , 0 , 8 , 6 , 0 , 8 , 134 , 0 , 8 , 70 , </a> 0
<a> 0 , 9 , 236 , 80 , 7 , 9 , 0 , 8 , 94 , 0 , 8 , 30 , 0 , 9 , 156 , 84 , 7 , 99 , 0 , </a> 0
<a> 8 , 126 , 0 , 8 , 62 , 0 , 9 , 220 , 82 , 7 , 27 , 0 , 8 , 110 , 0 , 8 , 46 , 0 , 9 , </a> 0
<a> 188 , 0 , 8 , 14 , 0 , 8 , 142 , 0 , 8 , 78 , 0 , 9 , 252 , 96 , 7 , 256 , 0 , 8 , </a> 0
<a> 81 , 0 , 8 , 17 , 85 , 8 , 131 , 82 , 7 , 31 , 0 , 8 , 113 , 0 , 8 , 49 , 0 , 9 , </a> 0
<a> 194 , 80 , 7 , 10 , 0 , 8 , 97 , 0 , 8 , 33 , 0 , 9 , 162 , 0 , 8 , 1 , 0 , 8 , 129 , </a> 0
<a> 0 , 8 , 65 , 0 , 9 , 226 , 80 , 7 , 6 , 0 , 8 , 89 , 0 , 8 , 25 , 0 , 9 , 146 , 83 , </a> 0
<a> 7 , 59 , 0 , 8 , 121 , 0 , 8 , 57 , 0 , 9 , 210 , 81 , 7 , 17 , 0 , 8 , 105 , 0 , 8 , </a> 0
<a> 41 , 0 , 9 , 178 , 0 , 8 , 9 , 0 , 8 , 137 , 0 , 8 , 73 , 0 , 9 , 242 , 80 , 7 , 4 , </a> 0
<a> 0 , 8 , 85 , 0 , 8 , 21 , 80 , 8 , 258 , 83 , 7 , 43 , 0 , 8 , 117 , 0 , 8 , 53 , 0 , </a> 0
<a> 9 , 202 , 81 , 7 , 13 , 0 , 8 , 101 , 0 , 8 , 37 , 0 , 9 , 170 , 0 , 8 , 5 , 0 , 8 , </a> 0
<a> 133 , 0 , 8 , 69 , 0 , 9 , 234 , 80 , 7 , 8 , 0 , 8 , 93 , 0 , 8 , 29 , 0 , 9 , 154 , </a> 0
<a> 84 , 7 , 83 , 0 , 8 , 125 , 0 , 8 , 61 , 0 , 9 , 218 , 82 , 7 , 23 , 0 , 8 , 109 , 0 , </a> 0
<a> 8 , 45 , 0 , 9 , 186 , 0 , 8 , 13 , 0 , 8 , 141 , 0 , 8 , 77 , 0 , 9 , 250 , 80 , 7 , </a> 0
<a> 3 , 0 , 8 , 83 , 0 , 8 , 19 , 85 , 8 , 195 , 83 , 7 , 35 , 0 , 8 , 115 , 0 , 8 , 51 , </a> 0
<a> 0 , 9 , 198 , 81 , 7 , 11 , 0 , 8 , 99 , 0 , 8 , 35 , 0 , 9 , 166 , 0 , 8 , 3 , 0 , 8 , </a> 0
<a> 131 , 0 , 8 , 67 , 0 , 9 , 230 , 80 , 7 , 7 , 0 , 8 , 91 , 0 , 8 , 27 , 0 , 9 , 150 , </a> 0
<a> 84 , 7 , 67 , 0 , 8 , 123 , 0 , 8 , 59 , 0 , 9 , 214 , 82 , 7 , 19 , 0 , 8 , 107 , 0 , </a> 0
<a> 8 , 43 , 0 , 9 , 182 , 0 , 8 , 11 , 0 , 8 , 139 , 0 , 8 , 75 , 0 , 9 , 246 , 80 , 7 , </a> 0
<a> 5 , 0 , 8 , 87 , 0 , 8 , 23 , 192 , 8 , 0 , 83 , 7 , 51 , 0 , 8 , 119 , 0 , 8 , 55 , </a> 0
<a> 0 , 9 , 206 , 81 , 7 , 15 , 0 , 8 , 103 , 0 , 8 , 39 , 0 , 9 , 174 , 0 , 8 , 7 , 0 , </a> 0
<a> 8 , 135 , 0 , 8 , 71 , 0 , 9 , 238 , 80 , 7 , 9 , 0 , 8 , 95 , 0 , 8 , 31 , 0 , 9 , </a> 0
<a> 158 , 84 , 7 , 99 , 0 , 8 , 127 , 0 , 8 , 63 , 0 , 9 , 222 , 82 , 7 , 27 , 0 , 8 , </a> 0
<a> 111 , 0 , 8 , 47 , 0 , 9 , 190 , 0 , 8 , 15 , 0 , 8 , 143 , 0 , 8 , 79 , 0 , 9 , 254 , </a> 0
<a> 96 , 7 , 256 , 0 , 8 , 80 , 0 , 8 , 16 , 84 , 8 , 115 , 82 , 7 , 31 , 0 , 8 , 112 , </a> 0
<a> 0 , 8 , 48 , 0 , 9 , 193 , </a> 0
<a> 80 , 7 , 10 , 0 , 8 , 96 , 0 , 8 , 32 , 0 , 9 , 161 , 0 , 8 , 0 , 0 , 8 , 128 , 0 , 8 , </a> 0
<a> 64 , 0 , 9 , 225 , 80 , 7 , 6 , 0 , 8 , 88 , 0 , 8 , 24 , 0 , 9 , 145 , 83 , 7 , 59 , </a> 0
<a> 0 , 8 , 120 , 0 , 8 , 56 , 0 , 9 , 209 , 81 , 7 , 17 , 0 , 8 , 104 , 0 , 8 , 40 , 0 , </a> 0
<a> 9 , 177 , 0 , 8 , 8 , 0 , 8 , 136 , 0 , 8 , 72 , 0 , 9 , 241 , 80 , 7 , 4 , 0 , 8 , </a> 0
<a> 84 , 0 , 8 , 20 , 85 , 8 , 227 , 83 , 7 , 43 , 0 , 8 , 116 , 0 , 8 , 52 , 0 , 9 , </a> 0
<a> 201 , 81 , 7 , 13 , 0 , 8 , 100 , 0 , 8 , 36 , 0 , 9 , 169 , 0 , 8 , 4 , 0 , 8 , 132 , </a> 0
<a> 0 , 8 , 68 , 0 , 9 , 233 , 80 , 7 , 8 , 0 , 8 , 92 , 0 , 8 , 28 , 0 , 9 , 153 , 84 , </a> 0
<a> 7 , 83 , 0 , 8 , 124 , 0 , 8 , 60 , 0 , 9 , 217 , 82 , 7 , 23 , 0 , 8 , 108 , 0 , 8 , </a> 0
<a> 44 , 0 , 9 , 185 , 0 , 8 , 12 , 0 , 8 , 140 , 0 , 8 , 76 , 0 , 9 , 249 , 80 , 7 , 3 , </a> 0
<a> 0 , 8 , 82 , 0 , 8 , 18 , 85 , 8 , 163 , 83 , 7 , 35 , 0 , 8 , 114 , 0 , 8 , 50 , 0 , </a> 0
<a> 9 , 197 , 81 , 7 , 11 , 0 , 8 , 98 , 0 , 8 , 34 , 0 , 9 , 165 , 0 , 8 , 2 , 0 , 8 , </a> 0
<a> 130 , 0 , 8 , 66 , 0 , 9 , 229 , 80 , 7 , 7 , 0 , 8 , 90 , 0 , 8 , 26 , 0 , 9 , 149 , </a> 0
<a> 84 , 7 , 67 , 0 , 8 , 122 , 0 , 8 , 58 , 0 , 9 , 213 , 82 , 7 , 19 , 0 , 8 , 106 , 0 , </a> 0
<a> 8 , 42 , 0 , 9 , 181 , 0 , 8 , 10 , 0 , 8 , 138 , 0 , 8 , 74 , 0 , 9 , 245 , 80 , 7 , </a> 0
<a> 5 , 0 , 8 , 86 , 0 , 8 , 22 , 192 , 8 , 0 , 83 , 7 , 51 , 0 , 8 , 118 , 0 , 8 , 54 , </a> 0
<a> 0 , 9 , 205 , 81 , 7 , 15 , 0 , 8 , 102 , 0 , 8 , 38 , 0 , 9 , 173 , 0 , 8 , 6 , 0 , </a> 0
<a> 8 , 134 , 0 , 8 , 70 , 0 , 9 , 237 , 80 , 7 , 9 , 0 , 8 , 94 , 0 , 8 , 30 , 0 , 9 , </a> 0
<a> 157 , 84 , 7 , 99 , 0 , 8 , 126 , 0 , 8 , 62 , 0 , 9 , 221 , 82 , 7 , 27 , 0 , 8 , </a> 0
<a> 110 , 0 , 8 , 46 , 0 , 9 , 189 , 0 , 8 , 14 , 0 , 8 , 142 , 0 , 8 , 78 , 0 , 9 , 253 , </a> 0
<a> 96 , 7 , 256 , 0 , 8 , 81 , 0 , 8 , 17 , 85 , 8 , 131 , 82 , 7 , 31 , 0 , 8 , 113 , </a> 0
<a> 0 , 8 , 49 , 0 , 9 , 195 , 80 , 7 , 10 , 0 , 8 , 97 , 0 , 8 , 33 , 0 , 9 , 163 , 0 , </a> 0
<a> 8 , 1 , 0 , 8 , 129 , 0 , 8 , 65 , 0 , 9 , 227 , 80 , 7 , 6 , 0 , 8 , 89 , 0 , 8 , 25 , </a> 0
<a> 0 , 9 , 147 , 83 , 7 , 59 , 0 , 8 , 121 , 0 , 8 , 57 , 0 , 9 , 211 , 81 , 7 , 17 , 0 , </a> 0
<a> 8 , 105 , 0 , 8 , 41 , 0 , 9 , 179 , 0 , 8 , 9 , 0 , 8 , 137 , 0 , 8 , 73 , 0 , 9 , </a> 0
<a> 243 , 80 , 7 , 4 , 0 , 8 , 85 , 0 , 8 , 21 , 80 , 8 , 258 , 83 , 7 , 43 , 0 , 8 , </a> 0
<a> 117 , 0 , 8 , 53 , 0 , 9 , 203 , 81 , 7 , 13 , 0 , 8 , 101 , 0 , 8 , 37 , 0 , 9 , </a> 0
<a> 171 , 0 , 8 , 5 , 0 , 8 , 133 , 0 , 8 , 69 , 0 , 9 , 235 , 80 , 7 , 8 , 0 , 8 , 93 , </a> 0
<a> 0 , 8 , 29 , 0 , 9 , 155 , 84 , 7 , 83 , 0 , 8 , 125 , 0 , 8 , 61 , 0 , 9 , 219 , 82 , </a> 0
<a> 7 , 23 , 0 , 8 , 109 , 0 , 8 , 45 , 0 , 9 , 187 , 0 , 8 , 13 , 0 , 8 , 141 , 0 , 8 , </a> 0
<a> 77 , 0 , 9 , 251 , 80 , 7 , 3 , 0 , 8 , 83 , 0 , 8 , 19 , 85 , 8 , 195 , 83 , 7 , 35 , </a> 0
<a> 0 , 8 , 115 , 0 , 8 , 51 , 0 , 9 , 199 , 81 , 7 , 11 , 0 , 8 , 99 , 0 , 8 , 35 , 0 , </a> 0
<a> 9 , 167 , 0 , 8 , 3 , 0 , 8 , 131 , 0 , 8 , 67 , 0 , 9 , 231 , 80 , 7 , 7 , 0 , 8 , </a> 0
<a> 91 , 0 , 8 , 27 , 0 , 9 , 151 , 84 , 7 , 67 , 0 , 8 , 123 , 0 , 8 , 59 , 0 , 9 , 215 , </a> 0
<a> 82 , 7 , 19 , 0 , 8 , 107 , 0 , 8 , 43 , 0 , 9 , 183 , 0 , 8 , 11 , 0 , 8 , 139 , 0 , </a> 0
<a> 8 , 75 , 0 , 9 , 247 , 80 , 7 , 5 , 0 , 8 , 87 , 0 , 8 , 23 , 192 , 8 , 0 , 83 , 7 , </a> 0
<a> 51 , 0 , 8 , 119 , 0 , 8 , 55 , 0 , 9 , 207 , 81 , 7 , 15 , 0 , 8 , 103 , 0 , 8 , 39 , </a> 0
<a> 0 , 9 , 175 , 0 , 8 , 7 , 0 , 8 , 135 , 0 , 8 , 71 , 0 , 9 , 239 , 80 , 7 , 9 , 0 , 8 , </a> 0
<a> 95 , 0 , 8 , 31 , 0 , 9 , 159 , 84 , 7 , 99 , 0 , 8 , 127 , 0 , 8 , 63 , 0 , 9 , 223 , </a> 0
<a> 82 , 7 , 27 , 0 , 8 , 111 , 0 , 8 , 47 , 0 , 9 , 191 , 0 , 8 , 15 , 0 , 8 , 143 , 0 , </a> 0
<a> 8 , 79 , 0 , 9 , 255 } ; </a> 0
<a> static final int [ ] fixed_td = { 80 , 5 , 1 , 87 , 5 , 257 , 83 , 5 , 17 , 91 , 5 , </a> 0
<a> 4097 , 81 , 5 , 5 , 89 , 5 , 1025 , 85 , 5 , 65 , 93 , 5 , 16385 , 80 , 5 , 3 , 88 , </a> 0
<a> 5 , 513 , 84 , 5 , 33 , 92 , 5 , 8193 , 82 , 5 , 9 , 90 , 5 , 2049 , 86 , 5 , 129 , </a> 0
<a> 192 , 5 , 24577 , 80 , 5 , 2 , 87 , 5 , 385 , 83 , 5 , 25 , 91 , 5 , 6145 , 81 , 5 , </a> 0
<a> 7 , 89 , 5 , 1537 , 85 , 5 , 97 , 93 , 5 , 24577 , 80 , 5 , 4 , 88 , 5 , 769 , 84 , </a> 0
<a> 5 , 49 , 92 , 5 , 12289 , 82 , 5 , 13 , 90 , 5 , 3073 , 86 , 5 , 193 , 192 , 5 , </a> 0
<a> 24577 } ; </a> 0
<a> static final int [ ] cplens = { </a> 0
<a> 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 13 , 15 , 17 , 19 , 23 , 27 , 31 , 35 , 43 , 51 , 59 , </a> 0
<a> 67 , 83 , 99 , 115 , 131 , 163 , 195 , 227 , 258 , 0 , 0 } ; </a> 0
<a> static final int [ ] cplext = { </a> 0
<a> 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 5 , </a> 0
<a> 5 , 5 , 5 , 0 , 112 , 112 </a> 0
<a> } ; </a> 0
<a> static final int [ ] cpdist = { </a> 0
<a> 1 , 2 , 3 , 4 , 5 , 7 , 9 , 13 , 17 , 25 , 33 , 49 , 65 , 97 , 129 , 193 , 257 , 385 , 513 , </a> 0
<a> 769 , 1025 , 1537 , 2049 , 3073 , 4097 , 6145 , 8193 , 12289 , 16385 , 24577 } ; </a> 0
<a> static final int [ ] cpdext = { </a> 0
<a> 0 , 0 , 0 , 0 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 6 , 6 , 7 , 7 , 8 , 8 , 9 , 9 , 10 , 10 , </a> 0
<a> 11 , 11 , 12 , 12 , 13 , 13 } ; </a> 0
<a> static final int BMAX = 15 ; </a> 0
<a> private int [ ] hn ; </a> 0
<a> private int [ ] v ; </a> 0
<a> private int [ ] c ; </a> 0
<a> private int [ ] r ; </a> 0
<a> private int [ ] u ; </a> 0
<a> private int [ ] x ; </a> 0
<a> private int huft_build ( int [ ] b , </a> 0
<a> int bindex , int n , </a> 0
<a> int s , </a> 0
<a> int [ ] d , </a> 0
<a> int [ ] e , </a> 0
<a> int [ ] t , </a> 0
<a> int [ ] m , </a> 0
<a> int [ ] hp , </a> 0
<a> int [ ] hn , </a> 0
<a> int [ ] v </a> 0
<a> ) { </a> 0
<a> int a ; </a> 0
<a> int f ; </a> 0
<a> int g ; </a> 0
<a> int h ; </a> 0
<a> int i ; </a> 0
<a> int j ; </a> 0
<a> int k ; </a> 0
<a> int l ; </a> 0
<a> int mask ; </a> 0
<a> int p ; </a> 0
<a> int q ; </a> 0
<a> int w ; </a> 0
<a> int xp ; </a> 0
<a> int y ; </a> 0
<a> int z ; </a> 0
<a> p = 0 ; </a> 0
<a> i = n ; </a> 0
<a> do { </a> 0
<a> c [ b [ bindex + p ] ] ++ ; </a> 0
<a> p ++ ; </a> 0
<a> i -- ; </a> 0
<a> } while ( i != 0 ) ; </a> 0
<a> if ( c [ 0 ] == n ) { </a> 0
<a> t [ 0 ] = - 1 ; </a> 0
<a> m [ 0 ] = 0 ; </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> l = m [ 0 ] ; </a> 0
<a> for ( j = 1 ; j <= BMAX ; j ++ ) { </a> 0
<a> if ( c [ j ] != 0 ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> k = j ; </a> 0
<a> if ( l < j ) { </a> 0
<a> l = j ; </a> 0
<a> } </a> 0
<a> for ( i = BMAX ; i != 0 ; i -- ) { </a> 0
<a> if ( c [ i ] != 0 ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> g = i ; </a> 0
<a> if ( l > i ) { </a> 0
<a> l = i ; </a> 0
<a> } </a> 0
<a> m [ 0 ] = l ; </a> 0
<a> for ( y = 1 < < j ; j < i ; j ++ , y <<= 1 ) { </a> 0
<a> if ( ( y -= c [ j ] ) < 0 ) { </a> 0
<a> return JZlib . Z_DATA_ERROR ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ( y -= c [ i ] ) < 0 ) { </a> 0
<a> return JZlib . Z_DATA_ERROR ; </a> 0
<a> } </a> 0
<a> c [ i ] += y ; </a> 0
<a> x [ 1 ] = j = 0 ; </a> 0
<a> p = 1 ; </a> 0
<a> xp = 2 ; </a> 0
<a> while ( -- i != 0 ) { </a> 0
<a> x [ xp ] = j += c [ p ] ; </a> 0
<a> xp ++ ; </a> 0
<a> p ++ ; </a> 0
<a> } </a> 0
<a> i = 0 ; </a> 0
<a> p = 0 ; </a> 0
<a> do { </a> 0
<a> if ( ( j = b [ bindex + p ] ) != 0 ) { </a> 0
<a> v [ x [ j ] ++ ] = i ; </a> 0
<a> } </a> 0
<a> p ++ ; </a> 0
<a> } while ( ++ i < n ) ; </a> 0
<a> n = x [ g ] ; </a> 0
<a> x [ 0 ] = i = 0 ; </a> 0
<a> p = 0 ; </a> 0
<a> h = - 1 ; </a> 0
<a> w = - l ; </a> 0
<a> u [ 0 ] = 0 ; </a> 0
<a> q = 0 ; </a> 0
<a> z = 0 ; </a> 0
<a> for ( ; k <= g ; k ++ ) { </a> 0
<a> a = c [ k ] ; </a> 0
<a> while ( a -- != 0 ) { </a> 0
<a> while ( k > w + l ) { </a> 0
<a> h ++ ; </a> 0
<a> w += l ; </a> 0
<a> z = g - w ; </a> 0
<a> z = z > l ? l : z ; </a> 0
<a> if ( ( f = 1 < < ( j = k - w ) ) > a + 1 ) { </a> 0
<a> f -= a + 1 ; </a> 0
<a> xp = k ; </a> 0
<a> if ( j < z ) { </a> 0
<a> while ( ++ j < z ) { </a> 0
<a> if ( ( f <<= 1 ) <= c [ ++ xp ] ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> f -= c [ xp ] ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> z = 1 < < j ; </a> 0
<a> if ( hn [ 0 ] + z > JZlib . MANY ) { </a> 0
<a> return JZlib . Z_DATA_ERROR ; </a> 0
<a> } </a> 0
<a> u [ h ] = q = hn [ 0 ] ; </a> 0
<a> hn [ 0 ] += z ; </a> 0
<a> if ( h != 0 ) { </a> 0
<a> x [ h ] = i ; </a> 0
<a> r [ 0 ] = ( byte ) j ; </a> 0
<a> r [ 1 ] = ( byte ) l ; </a> 0
<a> j = i > > > w - l ; </a> 0
<a> r [ 2 ] = q - u [ h - 1 ] - j ; </a> 0
<a> System . arraycopy ( r , 0 , hp , ( u [ h - 1 ] + j ) * 3 , 3 ) ; </a> 0
<a> } else { </a> 0
<a> t [ 0 ] = q ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> r [ 1 ] = ( byte ) ( k - w ) ; </a> 0
<a> if ( p >= n ) { </a> 0
<a> r [ 0 ] = 128 + 64 ; </a> 0
<a> } else if ( v [ p ] < s ) { </a> 0
<a> r [ 0 ] = ( byte ) ( v [ p ] < 256 ? 0 : 32 + 64 ) ; </a> 0
<a> r [ 2 ] = v [ p ++ ] ; </a> 0
<a> } else { </a> 0
<a> r [ 0 ] = ( byte ) ( e [ v [ p ] - s ] + 16 + 64 ) ; </a> 0
<a> r [ 2 ] = d [ v [ p ++ ] - s ] ; </a> 0
<a> } </a> 0
<a> f = 1 < < k - w ; </a> 0
<a> for ( j = i > > > w ; j < z ; j += f ) { </a> 0
<a> System . arraycopy ( r , 0 , hp , ( q + j ) * 3 , 3 ) ; </a> 0
<a> } </a> 0
<a> for ( j = 1 < < k - 1 ; ( i & j ) != 0 ; j >>>= 1 ) { </a> 0
<a> i ^= j ; </a> 0
<a> } </a> 0
<a> i ^= j ; </a> 0
<a> mask = ( 1 < < w ) - 1 ; </a> 0
<a> while ( ( i & mask ) != x [ h ] ) { </a> 0
<a> h -- ; </a> 0
<a> w -= l ; </a> 0
<a> mask = ( 1 < < w ) - 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return y != 0 && g != 1 ? JZlib . Z_BUF_ERROR : JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> int inflate_trees_bits ( int [ ] c , </a> 0
<a> int [ ] bb , </a> 0
<a> int [ ] tb , </a> 0
<a> int [ ] hp , </a> 0
<a> ZStream z </a> 0
<a> ) { </a> 0
<a> int result ; </a> 0
<a> initWorkArea ( 19 ) ; </a> 0
<a> hn [ 0 ] = 0 ; </a> 0
<a> result = huft_build ( c , 0 , 19 , 19 , null , null , tb , bb , hp , hn , v ) ; </a> 0
<a> if ( result == JZlib . Z_DATA_ERROR ) { </a> 0
<a> z . msg = "oversubscribed dynamic bit lengths tree" ; </a> 0
<a> } else if ( result == JZlib . Z_BUF_ERROR || bb [ 0 ] == 0 ) { </a> 0
<a> z . msg = "incomplete dynamic bit lengths tree" ; </a> 0
<a> result = JZlib . Z_DATA_ERROR ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> int inflate_trees_dynamic ( int nl , </a> 0
<a> int nd , </a> 0
<a> int [ ] c , </a> 0
<a> int [ ] bl , </a> 0
<a> int [ ] bd , </a> 0
<a> int [ ] tl , </a> 0
<a> int [ ] td , </a> 0
<a> int [ ] hp , </a> 0
<a> ZStream z </a> 0
<a> ) { </a> 0
<a> int result ; </a> 0
<a> initWorkArea ( 288 ) ; </a> 0
<a> hn [ 0 ] = 0 ; </a> 0
<a> result = huft_build ( c , 0 , nl , 257 , cplens , cplext , tl , bl , hp , hn , v ) ; </a> 0
<a> if ( result != JZlib . Z_OK || bl [ 0 ] == 0 ) { </a> 0
<a> if ( result == JZlib . Z_DATA_ERROR ) { </a> 0
<a> z . msg = "oversubscribed literal/length tree" ; </a> 0
<a> } else if ( result != JZlib . Z_MEM_ERROR ) { </a> 0
<a> z . msg = "incomplete literal/length tree" ; </a> 0
<a> result = JZlib . Z_DATA_ERROR ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> initWorkArea ( 288 ) ; </a> 0
<a> result = huft_build ( c , nl , nd , 0 , cpdist , cpdext , td , bd , hp , hn , v ) ; </a> 0
<a> if ( result != JZlib . Z_OK || bd [ 0 ] == 0 && nl > 257 ) { </a> 0
<a> if ( result == JZlib . Z_DATA_ERROR ) { </a> 0
<a> z . msg = "oversubscribed distance tree" ; </a> 0
<a> } else if ( result == JZlib . Z_BUF_ERROR ) { </a> 0
<a> z . msg = "incomplete distance tree" ; </a> 0
<a> result = JZlib . Z_DATA_ERROR ; </a> 0
<a> } else if ( result != JZlib . Z_MEM_ERROR ) { </a> 0
<a> z . msg = "empty distance tree with lengths" ; </a> 0
<a> result = JZlib . Z_DATA_ERROR ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> static int inflate_trees_fixed ( int [ ] bl , </a> 0
<a> int [ ] bd , </a> 0
<a> int [ ] [ ] tl , </a> 0
<a> int [ ] [ ] td </a> 0
<a> ) { </a> 0
<a> bl [ 0 ] = fixed_bl ; </a> 0
<a> bd [ 0 ] = fixed_bd ; </a> 0
<a> tl [ 0 ] = fixed_tl ; </a> 0
<a> td [ 0 ] = fixed_td ; </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> private void initWorkArea ( int vsize ) { </a> 0
<a> if ( hn == null ) { </a> 0
<a> hn = new int [ 1 ] ; </a> 0
<a> v = new int [ vsize ] ; </a> 0
<a> c = new int [ BMAX + 1 ] ; </a> 0
<a> r = new int [ 3 ] ; </a> 0
<a> u = new int [ BMAX ] ; </a> 0
<a> x = new int [ BMAX + 1 ] ; </a> 0
<a> } else { </a> 0
<a> if ( v . length < vsize ) { </a> 0
<a> v = new int [ vsize ] ; </a> 0
<a> } else { </a> 0
<a> for ( int i = 0 ; i < vsize ; i ++ ) { </a> 0
<a> v [ i ] = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < BMAX + 1 ; i ++ ) { </a> 0
<a> c [ i ] = 0 ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < 3 ; i ++ ) { </a> 0
<a> r [ i ] = 0 ; </a> 0
<a> } </a> 0
<a> System . arraycopy ( c , 0 , u , 0 , BMAX ) ; </a> 0
<a> System . arraycopy ( c , 0 , x , 0 , BMAX + 1 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal . jzlib ; </a> 0
<a> import io . netty . util . internal . jzlib . JZlib . WrapperType ; </a> 0
<a> final class Inflate { </a> 0
<a> private static final int METHOD = 0 ; </a> 0
<a> private static final int FLAG = 1 ; </a> 0
<a> private static final int DICT4 = 2 ; </a> 0
<a> private static final int DICT3 = 3 ; </a> 0
<a> private static final int DICT2 = 4 ; </a> 0
<a> private static final int DICT1 = 5 ; </a> 0
<a> private static final int DICT0 = 6 ; </a> 0
<a> private static final int BLOCKS = 7 ; </a> 0
<a> private static final int CHECK4 = 8 ; </a> 0
<a> private static final int CHECK3 = 9 ; </a> 0
<a> private static final int CHECK2 = 10 ; </a> 0
<a> private static final int CHECK1 = 11 ; </a> 0
<a> private static final int DONE = 12 ; </a> 0
<a> private static final int BAD = 13 ; </a> 0
<a> private static final int GZIP_ID1 = 14 ; </a> 0
<a> private static final int GZIP_ID2 = 15 ; </a> 0
<a> private static final int GZIP_CM = 16 ; </a> 0
<a> private static final int GZIP_FLG = 17 ; </a> 0
<a> private static final int GZIP_MTIME_XFL_OS = 18 ; </a> 0
<a> private static final int GZIP_XLEN = 19 ; </a> 0
<a> private static final int GZIP_FEXTRA = 20 ; </a> 0
<a> private static final int GZIP_FNAME = 21 ; </a> 0
<a> private static final int GZIP_FCOMMENT = 22 ; </a> 0
<a> private static final int GZIP_FHCRC = 23 ; </a> 0
<a> private static final int GZIP_CRC32 = 24 ; </a> 0
<a> private static final int GZIP_ISIZE = 25 ; </a> 0
<a> private int mode ; </a> 0
<a> private int method ; </a> 0
<a> private final long [ ] was = new long [ 1 ] ; </a> 0
<a> private long need ; </a> 0
<a> private int marker ; </a> 0
<a> private WrapperType wrapperType ; </a> 0
<a> private int wbits ; </a> 0
<a> private InfBlocks blocks ; </a> 0
<a> private int gzipFlag ; </a> 0
<a> private int gzipBytesToRead ; </a> 0
<a> private int gzipXLen ; </a> 0
<a> private int gzipUncompressedBytes ; </a> 0
<a> private int gzipCRC32 ; </a> 0
<a> private int gzipISize ; </a> 0
<a> private int inflateReset ( ZStream z ) { </a> 0
<a> if ( z == null || z . istate == null ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> z . total_in = z . total_out = 0 ; </a> 0
<a> z . msg = null ; </a> 0
<a> switch ( wrapperType ) { </a> 0
<a> case NONE : </a> 0
<a> z . istate . mode = BLOCKS ; </a> 0
<a> break ; </a> 0
<a> case ZLIB : </a> 0
<a> case ZLIB_OR_NONE : </a> 0
<a> z . istate . mode = METHOD ; </a> 0
<a> break ; </a> 0
<a> case GZIP : </a> 0
<a> z . istate . mode = GZIP_ID1 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> z . istate . blocks . reset ( z , null ) ; </a> 0
<a> gzipUncompressedBytes = 0 ; </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> int inflateEnd ( ZStream z ) { </a> 0
<a> if ( blocks != null ) { </a> 0
<a> blocks . free ( z ) ; </a> 0
<a> } </a> 0
<a> blocks = null ; </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> int inflateInit ( ZStream z , int w , WrapperType wrapperType ) { </a> 0
<a> z . msg = null ; </a> 0
<a> blocks = null ; </a> 0
<a> this . wrapperType = wrapperType ; </a> 0
<a> if ( w < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "w: " + w ) ; </a> 0
<a> } </a> 0
<a> if ( w < 8 || w > 15 ) { </a> 0
<a> inflateEnd ( z ) ; </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> wbits = w ; </a> 0
<a> z . istate . blocks = new InfBlocks ( </a> 0
<a> z , z . istate . wrapperType == WrapperType . NONE ? null : this , </a> 0
<a> 1 < < w ) ; </a> 0
<a> inflateReset ( z ) ; </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> int inflate ( ZStream z , int f ) { </a> 0
<a> int r ; </a> 0
<a> int b ; </a> 0
<a> if ( z == null || z . istate == null || z . next_in == null ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> f = f == JZlib . Z_FINISH ? JZlib . Z_BUF_ERROR : JZlib . Z_OK ; </a> 0
<a> r = JZlib . Z_BUF_ERROR ; </a> 0
<a> while ( true ) { </a> 0
<a> switch ( z . istate . mode ) { </a> 0
<a> case METHOD : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> if ( z . istate . wrapperType == WrapperType . ZLIB_OR_NONE ) { </a> 0
<a> if ( ( z . next_in [ z . next_in_index ] & 0xf ) != JZlib . Z_DEFLATED || </a> 0
<a> ( z . next_in [ z . next_in_index ] > > 4 ) + 8 > z . istate . wbits ) { </a> 0
<a> z . istate . wrapperType = WrapperType . NONE ; </a> 0
<a> z . istate . mode = BLOCKS ; </a> 0
<a> break ; </a> 0
<a> } else { </a> 0
<a> z . istate . wrapperType = WrapperType . ZLIB ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> if ( ( ( z . istate . method = z . next_in [ z . next_in_index ++ ] ) & 0xf ) != JZlib . Z_DEFLATED ) { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . msg = "unknown compression method" ; </a> 0
<a> z . istate . marker = 5 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ( z . istate . method > > 4 ) + 8 > z . istate . wbits ) { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . msg = "invalid window size" ; </a> 0
<a> z . istate . marker = 5 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> z . istate . mode = FLAG ; </a> 0
<a> case FLAG : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> b = z . next_in [ z . next_in_index ++ ] & 0xff ; </a> 0
<a> if ( ( ( z . istate . method < < 8 ) + b ) % 31 != 0 ) { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . msg = "incorrect header check" ; </a> 0
<a> z . istate . marker = 5 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ( b & JZlib . PRESET_DICT ) == 0 ) { </a> 0
<a> z . istate . mode = BLOCKS ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> z . istate . mode = DICT4 ; </a> 0
<a> case DICT4 : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> z . istate . need = ( z . next_in [ z . next_in_index ++ ] & 0xff ) < < 24 & 0xff000000L ; </a> 0
<a> z . istate . mode = DICT3 ; </a> 0
<a> case DICT3 : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> z . istate . need += ( z . next_in [ z . next_in_index ++ ] & 0xff ) < < 16 & 0xff0000L ; </a> 0
<a> z . istate . mode = DICT2 ; </a> 0
<a> case DICT2 : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> z . istate . need += ( z . next_in [ z . next_in_index ++ ] & 0xff ) < < 8 & 0xff00L ; </a> 0
<a> z . istate . mode = DICT1 ; </a> 0
<a> case DICT1 : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> z . istate . need += z . next_in [ z . next_in_index ++ ] & 0xffL ; </a> 0
<a> z . adler = z . istate . need ; </a> 0
<a> z . istate . mode = DICT0 ; </a> 0
<a> return JZlib . Z_NEED_DICT ; </a> 0
<a> case DICT0 : </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . msg = "need dictionary" ; </a> 0
<a> z . istate . marker = 0 ; </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> case BLOCKS : </a> 0
<a> int old_next_out_index = z . next_out_index ; </a> 0
<a> try { </a> 0
<a> r = z . istate . blocks . proc ( z , r ) ; </a> 0
<a> if ( r == JZlib . Z_DATA_ERROR ) { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . istate . marker = 0 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( r == JZlib . Z_OK ) { </a> 0
<a> r = f ; </a> 0
<a> } </a> 0
<a> if ( r != JZlib . Z_STREAM_END ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . istate . blocks . reset ( z , z . istate . was ) ; </a> 0
<a> } finally { </a> 0
<a> int decompressedBytes = z . next_out_index - old_next_out_index ; </a> 0
<a> gzipUncompressedBytes += decompressedBytes ; </a> 0
<a> z . crc32 = CRC32 . crc32 ( z . crc32 , z . next_out , old_next_out_index , decompressedBytes ) ; </a> 0
<a> } </a> 0
<a> if ( z . istate . wrapperType == WrapperType . NONE ) { </a> 0
<a> z . istate . mode = DONE ; </a> 0
<a> break ; </a> 0
<a> } else if ( z . istate . wrapperType == WrapperType . ZLIB ) { </a> 0
<a> z . istate . mode = CHECK4 ; </a> 0
<a> } else if ( z . istate . wrapperType == WrapperType . GZIP ) { </a> 0
<a> gzipCRC32 = 0 ; </a> 0
<a> gzipISize = 0 ; </a> 0
<a> gzipBytesToRead = 4 ; </a> 0
<a> z . istate . mode = GZIP_CRC32 ; </a> 0
<a> break ; </a> 0
<a> } else { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . msg = "unexpected state" ; </a> 0
<a> z . istate . marker = 0 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case CHECK4 : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> z . istate . need = ( z . next_in [ z . next_in_index ++ ] & 0xff ) < < 24 & 0xff000000L ; </a> 0
<a> z . istate . mode = CHECK3 ; </a> 0
<a> case CHECK3 : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> z . istate . need += ( z . next_in [ z . next_in_index ++ ] & 0xff ) < < 16 & 0xff0000L ; </a> 0
<a> z . istate . mode = CHECK2 ; </a> 0
<a> case CHECK2 : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> z . istate . need += ( z . next_in [ z . next_in_index ++ ] & 0xff ) < < 8 & 0xff00L ; </a> 0
<a> z . istate . mode = CHECK1 ; </a> 0
<a> case CHECK1 : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> z . istate . need += z . next_in [ z . next_in_index ++ ] & 0xffL ; </a> 0
<a> if ( ( int ) z . istate . was [ 0 ] != ( int ) z . istate . need ) { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . msg = "incorrect data check" ; </a> 0
<a> z . istate . marker = 5 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> z . istate . mode = DONE ; </a> 0
<a> case DONE : </a> 0
<a> return JZlib . Z_STREAM_END ; </a> 0
<a> case BAD : </a> 0
<a> return JZlib . Z_DATA_ERROR ; </a> 0
<a> case GZIP_ID1 : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> if ( ( z . next_in [ z . next_in_index ++ ] & 0xff ) != 31 ) { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . msg = "not a gzip stream" ; </a> 0
<a> z . istate . marker = 5 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> z . istate . mode = GZIP_ID2 ; </a> 0
<a> case GZIP_ID2 : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> if ( ( z . next_in [ z . next_in_index ++ ] & 0xff ) != 139 ) { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . msg = "not a gzip stream" ; </a> 0
<a> z . istate . marker = 5 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> z . istate . mode = GZIP_CM ; </a> 0
<a> case GZIP_CM : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> if ( ( z . next_in [ z . next_in_index ++ ] & 0xff ) != JZlib . Z_DEFLATED ) { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . msg = "unknown compression method" ; </a> 0
<a> z . istate . marker = 5 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> z . istate . mode = GZIP_FLG ; </a> 0
<a> case GZIP_FLG : </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> gzipFlag = z . next_in [ z . next_in_index ++ ] & 0xff ; </a> 0
<a> if ( ( gzipFlag & 0xE2 ) != 0 ) { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . msg = "unsupported flag" ; </a> 0
<a> z . istate . marker = 5 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> gzipBytesToRead = 6 ; </a> 0
<a> z . istate . mode = GZIP_MTIME_XFL_OS ; </a> 0
<a> case GZIP_MTIME_XFL_OS : </a> 0
<a> while ( gzipBytesToRead > 0 ) { </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> z . next_in_index ++ ; </a> 0
<a> gzipBytesToRead -- ; </a> 0
<a> } </a> 0
<a> z . istate . mode = GZIP_XLEN ; </a> 0
<a> gzipXLen = 0 ; </a> 0
<a> gzipBytesToRead = 2 ; </a> 0
<a> case GZIP_XLEN : </a> 0
<a> if ( ( gzipFlag & 4 ) != 0 ) { </a> 0
<a> while ( gzipBytesToRead > 0 ) { </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> gzipXLen |= ( z . next_in [ z . next_in_index ++ ] & 0xff ) < < ( 1 - gzipBytesToRead ) * 8 ; </a> 0
<a> gzipBytesToRead -- ; </a> 0
<a> } </a> 0
<a> gzipBytesToRead = gzipXLen ; </a> 0
<a> z . istate . mode = GZIP_FEXTRA ; </a> 0
<a> } else { </a> 0
<a> z . istate . mode = GZIP_FNAME ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case GZIP_FEXTRA : </a> 0
<a> while ( gzipBytesToRead > 0 ) { </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> z . next_in_index ++ ; </a> 0
<a> gzipBytesToRead -- ; </a> 0
<a> } </a> 0
<a> z . istate . mode = GZIP_FNAME ; </a> 0
<a> case GZIP_FNAME : </a> 0
<a> if ( ( gzipFlag & 8 ) != 0 ) { </a> 0
<a> do { </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> } while ( z . next_in [ z . next_in_index ++ ] != 0 ) ; </a> 0
<a> } </a> 0
<a> z . istate . mode = GZIP_FCOMMENT ; </a> 0
<a> case GZIP_FCOMMENT : </a> 0
<a> if ( ( gzipFlag & 16 ) != 0 ) { </a> 0
<a> do { </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> } while ( z . next_in [ z . next_in_index ++ ] != 0 ) ; </a> 0
<a> } </a> 0
<a> gzipBytesToRead = 2 ; </a> 0
<a> z . istate . mode = GZIP_FHCRC ; </a> 0
<a> case GZIP_FHCRC : </a> 0
<a> if ( ( gzipFlag & 2 ) != 0 ) { </a> 0
<a> while ( gzipBytesToRead > 0 ) { </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> z . next_in_index ++ ; </a> 0
<a> gzipBytesToRead -- ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> z . istate . mode = BLOCKS ; </a> 0
<a> break ; </a> 0
<a> case GZIP_CRC32 : </a> 0
<a> while ( gzipBytesToRead > 0 ) { </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> gzipBytesToRead -- ; </a> 0
<a> z . istate . gzipCRC32 |= ( z . next_in [ z . next_in_index ++ ] & 0xff ) < < ( 3 - gzipBytesToRead ) * 8 ; </a> 0
<a> } </a> 0
<a> if ( z . crc32 != z . istate . gzipCRC32 ) { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . msg = "incorrect CRC32 checksum" ; </a> 0
<a> z . istate . marker = 5 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> gzipBytesToRead = 4 ; </a> 0
<a> z . istate . mode = GZIP_ISIZE ; </a> 0
<a> case GZIP_ISIZE : </a> 0
<a> while ( gzipBytesToRead > 0 ) { </a> 0
<a> if ( z . avail_in == 0 ) { </a> 0
<a> return r ; </a> 0
<a> } </a> 0
<a> r = f ; </a> 0
<a> z . avail_in -- ; </a> 0
<a> z . total_in ++ ; </a> 0
<a> gzipBytesToRead -- ; </a> 0
<a> z . istate . gzipISize |= ( z . next_in [ z . next_in_index ++ ] & 0xff ) < < ( 3 - gzipBytesToRead ) * 8 ; </a> 0
<a> } </a> 0
<a> if ( gzipUncompressedBytes != z . istate . gzipISize ) { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . msg = "incorrect ISIZE checksum" ; </a> 0
<a> z . istate . marker = 5 ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> z . istate . mode = DONE ; </a> 0
<a> break ; </a> 0
<a> default : </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static int inflateSetDictionary ( ZStream z , byte [ ] dictionary , int dictLength ) { </a> 0
<a> int index = 0 ; </a> 0
<a> int length = dictLength ; </a> 0
<a> if ( z == null || z . istate == null || z . istate . mode != DICT0 ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> if ( Adler32 . adler32 ( 1L , dictionary , 0 , dictLength ) != z . adler ) { </a> 0
<a> return JZlib . Z_DATA_ERROR ; </a> 0
<a> } </a> 0
<a> z . adler = Adler32 . adler32 ( 0 , null , 0 , 0 ) ; </a> 0
<a> if ( length >= 1 < < z . istate . wbits ) { </a> 0
<a> length = ( 1 < < z . istate . wbits ) - 1 ; </a> 0
<a> index = dictLength - length ; </a> 0
<a> } </a> 0
<a> z . istate . blocks . set_dictionary ( dictionary , index , length ) ; </a> 0
<a> z . istate . mode = BLOCKS ; </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> private static final byte [ ] mark = { ( byte ) 0 , ( byte ) 0 , ( byte ) 0xff , ( byte ) 0xff } ; </a> 0
<a> int inflateSync ( ZStream z ) { </a> 0
<a> int n ; </a> 0
<a> int p ; </a> 0
<a> int m ; </a> 0
<a> long r , w ; </a> 0
<a> if ( z == null || z . istate == null ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> if ( z . istate . mode != BAD ) { </a> 0
<a> z . istate . mode = BAD ; </a> 0
<a> z . istate . marker = 0 ; </a> 0
<a> } </a> 0
<a> if ( ( n = z . avail_in ) == 0 ) { </a> 0
<a> return JZlib . Z_BUF_ERROR ; </a> 0
<a> } </a> 0
<a> p = z . next_in_index ; </a> 0
<a> m = z . istate . marker ; </a> 0
<a> while ( n != 0 && m < 4 ) { </a> 0
<a> if ( z . next_in [ p ] == mark [ m ] ) { </a> 0
<a> m ++ ; </a> 0
<a> } else if ( z . next_in [ p ] != 0 ) { </a> 0
<a> m = 0 ; </a> 0
<a> } else { </a> 0
<a> m = 4 - m ; </a> 0
<a> } </a> 0
<a> p ++ ; </a> 0
<a> n -- ; </a> 0
<a> } </a> 0
<a> z . total_in += p - z . next_in_index ; </a> 0
<a> z . next_in_index = p ; </a> 0
<a> z . avail_in = n ; </a> 0
<a> z . istate . marker = m ; </a> 0
<a> if ( m != 4 ) { </a> 0
<a> return JZlib . Z_DATA_ERROR ; </a> 0
<a> } </a> 0
<a> r = z . total_in ; </a> 0
<a> w = z . total_out ; </a> 0
<a> inflateReset ( z ) ; </a> 0
<a> z . total_in = r ; </a> 0
<a> z . total_out = w ; </a> 0
<a> z . istate . mode = BLOCKS ; </a> 0
<a> return JZlib . Z_OK ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal . jzlib ; </a> 0
<a> public final class JZlib { </a> 0
<a> public static final Enum < ? > W_NONE = WrapperType . NONE ; </a> 0
<a> public static final Enum < ? > W_ZLIB = WrapperType . ZLIB ; </a> 0
<a> public static final Enum < ? > W_GZIP = WrapperType . GZIP ; </a> 0
<a> public static final Enum < ? > W_ZLIB_OR_NONE = WrapperType . ZLIB_OR_NONE ; </a> 0
<a> public static final int Z_NO_COMPRESSION = 0 ; </a> 0
<a> public static final int Z_BEST_SPEED = 1 ; </a> 0
<a> public static final int Z_BEST_COMPRESSION = 9 ; </a> 0
<a> public static final int Z_DEFAULT_COMPRESSION = - 1 ; </a> 0
<a> public static final int Z_FILTERED = 1 ; </a> 0
<a> public static final int Z_HUFFMAN_ONLY = 2 ; </a> 0
<a> public static final int Z_DEFAULT_STRATEGY = 0 ; </a> 0
<a> public static final int Z_NO_FLUSH = 0 ; </a> 0
<a> public static final int Z_PARTIAL_FLUSH = 1 ; </a> 0
<a> public static final int Z_SYNC_FLUSH = 2 ; </a> 0
<a> public static final int Z_FULL_FLUSH = 3 ; </a> 0
<a> public static final int Z_FINISH = 4 ; </a> 0
<a> public static final int Z_OK = 0 ; </a> 0
<a> public static final int Z_STREAM_END = 1 ; </a> 0
<a> public static final int Z_NEED_DICT = 2 ; </a> 0
<a> public static final int Z_ERRNO = - 1 ; </a> 0
<a> public static final int Z_STREAM_ERROR = - 2 ; </a> 0
<a> public static final int Z_DATA_ERROR = - 3 ; </a> 0
<a> public static final int Z_MEM_ERROR = - 4 ; </a> 0
<a> public static final int Z_BUF_ERROR = - 5 ; </a> 0
<a> public static final int Z_VERSION_ERROR = - 6 ; </a> 0
<a> static final int Z_DEFLATED = 8 ; </a> 0
<a> static final int MAX_MEM_LEVEL = 9 ; </a> 0
<a> static final int DEF_MEM_LEVEL = 8 ; </a> 0
<a> static final int MAX_WBITS = 15 ; </a> 0
<a> static final int DEF_WBITS = MAX_WBITS ; </a> 0
<a> static final int MAX_BITS = 15 ; </a> 0
<a> static final int PRESET_DICT = 0x20 ; </a> 0
<a> static final int MANY = 1440 ; </a> 0
<a> static final int BL_CODES = 19 ; </a> 0
<a> static final int D_CODES = 30 ; </a> 0
<a> static final int LITERALS = 256 ; </a> 0
<a> static final int LENGTH_CODES = 29 ; </a> 0
<a> static final int L_CODES = LITERALS + 1 + LENGTH_CODES ; </a> 0
<a> static final int HEAP_SIZE = 2 * L_CODES + 1 ; </a> 0
<a> static final int MAX_BL_BITS = 7 ; </a> 0
<a> enum WrapperType { </a> 0
<a> NONE , ZLIB , GZIP , ZLIB_OR_NONE </a> 0
<a> } </a> 0
<a> private JZlib ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal . jzlib ; </a> 0
<a> final class Tree { </a> 0
<a> static final int [ ] extra_lbits = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 2 , </a> 0
<a> 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 , 5 , 5 , 5 , 5 , 0 } ; </a> 0
<a> static final int [ ] extra_dbits = { 0 , 0 , 0 , 0 , 1 , 1 , 2 , 2 , 3 , 3 , 4 , 4 , 5 , </a> 0
<a> 5 , 6 , 6 , 7 , 7 , 8 , 8 , 9 , 9 , 10 , 10 , 11 , 11 , 12 , 12 , 13 , 13 } ; </a> 0
<a> static final int [ ] extra_blbits = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , </a> 0
<a> 0 , 0 , 0 , 2 , 3 , 7 } ; </a> 0
<a> static final byte [ ] bl_order = { 16 , 17 , 18 , 0 , 8 , 7 , 9 , 6 , 10 , 5 , 11 , 4 , </a> 0
<a> 12 , 3 , 13 , 2 , 14 , 1 , 15 } ; </a> 0
<a> static final byte [ ] _dist_code = { 0 , 1 , 2 , 3 , 4 , 4 , 5 , 5 , 6 , 6 , 6 , 6 , 7 , </a> 0
<a> 7 , 7 , 7 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 8 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 10 , 10 , </a> 0
<a> 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 10 , 11 , 11 , 11 , </a> 0
<a> 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 11 , 12 , 12 , 12 , 12 , </a> 0
<a> 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , </a> 0
<a> 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 13 , 13 , 13 , 13 , 13 , 13 , </a> 0
<a> 13 , 13 , 13 , 13 , 13 , 13 , 13 , 13 , 13 , 13 , 13 , 13 , 13 , 13 , 13 , 13 , 13 , </a> 0
<a> 13 , 13 , 13 , 13 , 13 , 13 , 13 , 13 , 13 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , </a> 0
<a> 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , </a> 0
<a> 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , </a> 0
<a> 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , 14 , </a> 0
<a> 14 , 14 , 14 , 14 , 14 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , </a> 0
<a> 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , </a> 0
<a> 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , </a> 0
<a> 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , 15 , </a> 0
<a> 15 , 0 , 0 , 16 , 17 , 18 , 18 , 19 , 19 , 20 , 20 , 20 , 20 , 21 , 21 , 21 , 21 , </a> 0
<a> 22 , 22 , 22 , 22 , 22 , 22 , 22 , 22 , 23 , 23 , 23 , 23 , 23 , 23 , 23 , 23 , 24 , </a> 0
<a> 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 25 , 25 , </a> 0
<a> 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 26 , 26 , 26 , </a> 0
<a> 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , </a> 0
<a> 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 27 , 27 , 27 , 27 , 27 , </a> 0
<a> 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , </a> 0
<a> 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , </a> 0
<a> 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , </a> 0
<a> 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , </a> 0
<a> 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , 28 , </a> 0
<a> 28 , 28 , 28 , 28 , 28 , 28 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , </a> 0
<a> 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , </a> 0
<a> 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , </a> 0
<a> 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , 29 , </a> 0
<a> 29 , 29 } ; </a> 0
<a> static final byte [ ] _length_code = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 8 , 9 , 9 , </a> 0
<a> 10 , 10 , 11 , 11 , 12 , 12 , 12 , 12 , 13 , 13 , 13 , 13 , 14 , 14 , 14 , 14 , 15 , </a> 0
<a> 15 , 15 , 15 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 17 , 17 , 17 , 17 , 17 , 17 , </a> 0
<a> 17 , 17 , 18 , 18 , 18 , 18 , 18 , 18 , 18 , 18 , 19 , 19 , 19 , 19 , 19 , 19 , 19 , </a> 0
<a> 19 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , 20 , </a> 0
<a> 21 , 21 , 21 , 21 , 21 , 21 , 21 , 21 , 21 , 21 , 21 , 21 , 21 , 21 , 21 , 21 , 22 , </a> 0
<a> 22 , 22 , 22 , 22 , 22 , 22 , 22 , 22 , 22 , 22 , 22 , 22 , 22 , 22 , 22 , 23 , 23 , </a> 0
<a> 23 , 23 , 23 , 23 , 23 , 23 , 23 , 23 , 23 , 23 , 23 , 23 , 23 , 23 , 24 , 24 , 24 , </a> 0
<a> 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , </a> 0
<a> 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 24 , 25 , 25 , 25 , 25 , 25 , </a> 0
<a> 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , </a> 0
<a> 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 25 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , </a> 0
<a> 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , </a> 0
<a> 26 , 26 , 26 , 26 , 26 , 26 , 26 , 26 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , </a> 0
<a> 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , 27 , </a> 0
<a> 27 , 27 , 27 , 27 , 27 , 28 } ; </a> 0
<a> static final int [ ] base_length = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 10 , 12 , 14 , </a> 0
<a> 16 , 20 , 24 , 28 , 32 , 40 , 48 , 56 , 64 , 80 , 96 , 112 , 128 , 160 , 192 , </a> 0
<a> 224 , 0 } ; </a> 0
<a> static final int [ ] base_dist = { 0 , 1 , 2 , 3 , 4 , 6 , 8 , 12 , 16 , 24 , 32 , 48 , </a> 0
<a> 64 , 96 , 128 , 192 , 256 , 384 , 512 , 768 , 1024 , 1536 , 2048 , 3072 , 4096 , </a> 0
<a> 6144 , 8192 , 12288 , 16384 , 24576 } ; </a> 0
<a> static int d_code ( int dist ) { </a> 0
<a> return dist < 256 ? _dist_code [ dist ] : _dist_code [ 256 + ( dist > > > 7 ) ] ; </a> 0
<a> } </a> 0
<a> short [ ] dyn_tree ; </a> 0
<a> int max_code ; </a> 0
<a> StaticTree stat_desc ; </a> 0
<a> private void gen_bitlen ( Deflate s ) { </a> 0
<a> short [ ] tree = dyn_tree ; </a> 0
<a> short [ ] stree = stat_desc . static_tree ; </a> 0
<a> int [ ] extra = stat_desc . extra_bits ; </a> 0
<a> int base = stat_desc . extra_base ; </a> 0
<a> int max_length = stat_desc . max_length ; </a> 0
<a> int h ; </a> 0
<a> int n , m ; </a> 0
<a> int bits ; </a> 0
<a> int xbits ; </a> 0
<a> short f ; </a> 0
<a> int overflow = 0 ; </a> 0
<a> for ( bits = 0 ; bits <= JZlib . MAX_BITS ; bits ++ ) { </a> 0
<a> s . bl_count [ bits ] = 0 ; </a> 0
<a> } </a> 0
<a> tree [ s . heap [ s . heap_max ] * 2 + 1 ] = 0 ; </a> 0
<a> for ( h = s . heap_max + 1 ; h < JZlib . HEAP_SIZE ; h ++ ) { </a> 0
<a> n = s . heap [ h ] ; </a> 0
<a> bits = tree [ tree [ n * 2 + 1 ] * 2 + 1 ] + 1 ; </a> 0
<a> if ( bits > max_length ) { </a> 0
<a> bits = max_length ; </a> 0
<a> overflow ++ ; </a> 0
<a> } </a> 0
<a> tree [ n * 2 + 1 ] = ( short ) bits ; </a> 0
<a> if ( n > max_code ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> s . bl_count [ bits ] ++ ; </a> 0
<a> xbits = 0 ; </a> 0
<a> if ( n >= base ) { </a> 0
<a> xbits = extra [ n - base ] ; </a> 0
<a> } </a> 0
<a> f = tree [ n * 2 ] ; </a> 0
<a> s . opt_len += f * ( bits + xbits ) ; </a> 0
<a> if ( stree != null ) { </a> 0
<a> s . static_len += f * ( stree [ n * 2 + 1 ] + xbits ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( overflow == 0 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> do { </a> 0
<a> bits = max_length - 1 ; </a> 0
<a> while ( s . bl_count [ bits ] == 0 ) { </a> 0
<a> bits -- ; </a> 0
<a> } </a> 0
<a> s . bl_count [ bits ] -- ; </a> 0
<a> s . bl_count [ bits + 1 ] += 2 ; </a> 0
<a> s . bl_count [ max_length ] -- ; </a> 0
<a> overflow -= 2 ; </a> 0
<a> } while ( overflow > 0 ) ; </a> 0
<a> for ( bits = max_length ; bits != 0 ; bits -- ) { </a> 0
<a> n = s . bl_count [ bits ] ; </a> 0
<a> while ( n != 0 ) { </a> 0
<a> m = s . heap [ -- h ] ; </a> 0
<a> if ( m > max_code ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> if ( tree [ m * 2 + 1 ] != bits ) { </a> 0
<a> s . opt_len += ( ( long ) bits - ( long ) tree [ m * 2 + 1 ] ) * </a> 1
<a> tree [ m * 2 ] ; </a> 0
<a> tree [ m * 2 + 1 ] = ( short ) bits ; </a> 0
<a> } </a> 0
<a> n -- ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void build_tree ( Deflate s ) { </a> 0
<a> short [ ] tree = dyn_tree ; </a> 0
<a> short [ ] stree = stat_desc . static_tree ; </a> 0
<a> int elems = stat_desc . elems ; </a> 0
<a> int n , m ; </a> 0
<a> int max_code = - 1 ; </a> 0
<a> int node ; </a> 0
<a> s . heap_len = 0 ; </a> 0
<a> s . heap_max = JZlib . HEAP_SIZE ; </a> 0
<a> for ( n = 0 ; n < elems ; n ++ ) { </a> 0
<a> if ( tree [ n * 2 ] != 0 ) { </a> 0
<a> s . heap [ ++ s . heap_len ] = max_code = n ; </a> 0
<a> s . depth [ n ] = 0 ; </a> 0
<a> } else { </a> 0
<a> tree [ n * 2 + 1 ] = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> while ( s . heap_len < 2 ) { </a> 0
<a> node = s . heap [ ++ s . heap_len ] = max_code < 2 ? ++ max_code : 0 ; </a> 0
<a> tree [ node * 2 ] = 1 ; </a> 0
<a> s . depth [ node ] = 0 ; </a> 0
<a> s . opt_len -- ; </a> 0
<a> if ( stree != null ) { </a> 0
<a> s . static_len -= stree [ node * 2 + 1 ] ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> this . max_code = max_code ; </a> 0
<a> for ( n = s . heap_len / 2 ; n >= 1 ; n -- ) { </a> 0
<a> s . pqdownheap ( tree , n ) ; </a> 0
<a> } </a> 0
<a> node = elems ; </a> 0
<a> do { </a> 0
<a> n = s . heap [ 1 ] ; </a> 0
<a> s . heap [ 1 ] = s . heap [ s . heap_len -- ] ; </a> 0
<a> s . pqdownheap ( tree , 1 ) ; </a> 0
<a> m = s . heap [ 1 ] ; </a> 0
<a> s . heap [ -- s . heap_max ] = n ; </a> 0
<a> s . heap [ -- s . heap_max ] = m ; </a> 0
<a> tree [ node * 2 ] = ( short ) ( tree [ n * 2 ] + tree [ m * 2 ] ) ; </a> 0
<a> s . depth [ node ] = ( byte ) ( Math . max ( s . depth [ n ] , s . depth [ m ] ) + 1 ) ; </a> 0
<a> tree [ n * 2 + 1 ] = tree [ m * 2 + 1 ] = ( short ) node ; </a> 0
<a> s . heap [ 1 ] = node ++ ; </a> 0
<a> s . pqdownheap ( tree , 1 ) ; </a> 0
<a> } while ( s . heap_len >= 2 ) ; </a> 0
<a> s . heap [ -- s . heap_max ] = s . heap [ 1 ] ; </a> 0
<a> gen_bitlen ( s ) ; </a> 0
<a> gen_codes ( tree , max_code , s . bl_count ) ; </a> 0
<a> } </a> 0
<a> private static void gen_codes ( short [ ] tree , </a> 0
<a> int max_code , </a> 0
<a> short [ ] bl_count </a> 0
<a> ) { </a> 0
<a> short [ ] next_code = new short [ JZlib . MAX_BITS + 1 ] ; </a> 0
<a> short code = 0 ; </a> 0
<a> int bits ; </a> 0
<a> int n ; </a> 0
<a> for ( bits = 1 ; bits <= JZlib . MAX_BITS ; bits ++ ) { </a> 0
<a> next_code [ bits ] = code = ( short ) ( code + bl_count [ bits - 1 ] < < 1 ) ; </a> 0
<a> } </a> 0
<a> for ( n = 0 ; n <= max_code ; n ++ ) { </a> 0
<a> int len = tree [ n * 2 + 1 ] ; </a> 0
<a> if ( len == 0 ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> tree [ n * 2 ] = ( short ) bi_reverse ( next_code [ len ] ++ , len ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static int bi_reverse ( int code , </a> 0
<a> int len </a> 0
<a> ) { </a> 0
<a> int res = 0 ; </a> 0
<a> do { </a> 0
<a> res |= code & 1 ; </a> 0
<a> code >>>= 1 ; </a> 0
<a> res <<= 1 ; </a> 0
<a> } while ( -- len > 0 ) ; </a> 0
<a> return res > > > 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal . jzlib ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . util . internal . jzlib . JZlib . WrapperType ; </a> 0
<a> public final class ZStream { </a> 0
<a> private static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( ZStream . class ) ; </a> 0
<a> public byte [ ] next_in ; </a> 0
<a> public int next_in_index ; </a> 0
<a> public int avail_in ; </a> 0
<a> public long total_in ; </a> 0
<a> public byte [ ] next_out ; </a> 0
<a> public int next_out_index ; </a> 0
<a> public int avail_out ; </a> 0
<a> public long total_out ; </a> 0
<a> public String msg ; </a> 0
<a> Deflate dstate ; </a> 0
<a> Inflate istate ; </a> 0
<a> long adler ; </a> 0
<a> int crc32 ; </a> 0
<a> public int inflateInit ( ) { </a> 0
<a> return inflateInit ( JZlib . DEF_WBITS ) ; </a> 0
<a> } </a> 0
<a> public int inflateInit ( Enum < ? > wrapperType ) { </a> 0
<a> return inflateInit ( JZlib . DEF_WBITS , wrapperType ) ; </a> 0
<a> } </a> 0
<a> public int inflateInit ( int w ) { </a> 0
<a> return inflateInit ( w , WrapperType . ZLIB ) ; </a> 0
<a> } </a> 0
<a> public int inflateInit ( int w , @ SuppressWarnings ( "rawtypes" ) Enum wrapperType ) { </a> 0
<a> istate = new Inflate ( ) ; </a> 0
<a> return istate . inflateInit ( this , w , ( WrapperType ) wrapperType ) ; </a> 0
<a> } </a> 0
<a> public int inflate ( int f ) { </a> 0
<a> if ( istate == null ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> return istate . inflate ( this , f ) ; </a> 0
<a> } </a> 0
<a> public int inflateEnd ( ) { </a> 0
<a> if ( istate == null ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> int ret = istate . inflateEnd ( this ) ; </a> 0
<a> istate = null ; </a> 0
<a> return ret ; </a> 0
<a> } </a> 0
<a> public int inflateSync ( ) { </a> 0
<a> if ( istate == null ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> return istate . inflateSync ( this ) ; </a> 0
<a> } </a> 0
<a> public int inflateSetDictionary ( byte [ ] dictionary , int dictLength ) { </a> 0
<a> if ( istate == null ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> return Inflate . inflateSetDictionary ( this , dictionary , dictLength ) ; </a> 0
<a> } </a> 0
<a> public int deflateInit ( int level ) { </a> 0
<a> return deflateInit ( level , JZlib . MAX_WBITS ) ; </a> 0
<a> } </a> 0
<a> public int deflateInit ( int level , Enum < ? > wrapperType ) { </a> 0
<a> return deflateInit ( level , JZlib . MAX_WBITS , wrapperType ) ; </a> 0
<a> } </a> 0
<a> public int deflateInit ( int level , int bits ) { </a> 0
<a> return deflateInit ( level , bits , WrapperType . ZLIB ) ; </a> 0
<a> } </a> 0
<a> public int deflateInit ( int level , int bits , Enum < ? > wrapperType ) { </a> 0
<a> return deflateInit ( level , bits , JZlib . DEF_MEM_LEVEL , wrapperType ) ; </a> 0
<a> } </a> 0
<a> public int deflateInit ( int level , int bits , int memLevel , @ SuppressWarnings ( "rawtypes" ) Enum wrapperType ) { </a> 0
<a> dstate = new Deflate ( ) ; </a> 0
<a> return dstate . deflateInit ( this , level , bits , memLevel , ( WrapperType ) wrapperType ) ; </a> 0
<a> } </a> 0
<a> public int deflate ( int flush ) { </a> 0
<a> if ( dstate == null ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> return dstate . deflate ( this , flush ) ; </a> 0
<a> } </a> 0
<a> public int deflateEnd ( ) { </a> 0
<a> if ( dstate == null ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> int ret = dstate . deflateEnd ( ) ; </a> 0
<a> dstate = null ; </a> 0
<a> return ret ; </a> 0
<a> } </a> 0
<a> public int deflateParams ( int level , int strategy ) { </a> 0
<a> if ( dstate == null ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> return dstate . deflateParams ( this , level , strategy ) ; </a> 0
<a> } </a> 0
<a> public int deflateSetDictionary ( byte [ ] dictionary , int dictLength ) { </a> 0
<a> if ( dstate == null ) { </a> 0
<a> return JZlib . Z_STREAM_ERROR ; </a> 0
<a> } </a> 0
<a> return dstate . deflateSetDictionary ( this , dictionary , dictLength ) ; </a> 0
<a> } </a> 0
<a> void flush_pending ( ) { </a> 0
<a> int len = dstate . pending ; </a> 0
<a> if ( len > avail_out ) { </a> 0
<a> len = avail_out ; </a> 0
<a> } </a> 0
<a> if ( len == 0 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( dstate . pending_buf . length <= dstate . pending_out || </a> 0
<a> next_out . length <= next_out_index || </a> 0
<a> dstate . pending_buf . length < dstate . pending_out + len || </a> 0
<a> next_out . length < next_out_index + len ) { </a> 0
<a> logger . debug ( dstate . pending_buf . length + ", " + </a> 0
<a> dstate . pending_out + ", " + next_out . length + ", " + </a> 0
<a> next_out_index + ", " + len ) ; </a> 0
<a> logger . debug ( "avail_out=" + avail_out ) ; </a> 0
<a> } </a> 0
<a> System . arraycopy ( dstate . pending_buf , dstate . pending_out , next_out , </a> 0
<a> next_out_index , len ) ; </a> 0
<a> next_out_index += len ; </a> 0
<a> dstate . pending_out += len ; </a> 0
<a> total_out += len ; </a> 0
<a> avail_out -= len ; </a> 0
<a> dstate . pending -= len ; </a> 0
<a> if ( dstate . pending == 0 ) { </a> 0
<a> dstate . pending_out = 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> int read_buf ( byte [ ] buf , int start , int size ) { </a> 0
<a> int len = avail_in ; </a> 0
<a> if ( len > size ) { </a> 0
<a> len = size ; </a> 0
<a> } </a> 0
<a> if ( len == 0 ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> avail_in -= len ; </a> 0
<a> switch ( dstate . wrapperType ) { </a> 0
<a> case ZLIB : </a> 0
<a> adler = Adler32 . adler32 ( adler , next_in , next_in_index , len ) ; </a> 0
<a> break ; </a> 0
<a> case GZIP : </a> 0
<a> crc32 = CRC32 . crc32 ( crc32 , next_in , next_in_index , len ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> System . arraycopy ( next_in , next_in_index , buf , start , len ) ; </a> 0
<a> next_in_index += len ; </a> 0
<a> total_in += len ; </a> 0
<a> return len ; </a> 0
<a> } </a> 0
<a> public void free ( ) { </a> 0
<a> next_in = null ; </a> 0
<a> next_out = null ; </a> 0
<a> msg = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal . jzlib ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import static org . easymock . EasyMock . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class CommonsLoggerTest { </a> 0
<a> private static final Exception e = new Exception ( ) ; </a> 0
<a> @ Test </a> 0
<a> public void testIsTraceEnabled ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> expect ( mock . isTraceEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> assertTrue ( logger . isTraceEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsDebugEnabled ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> expect ( mock . isDebugEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> assertTrue ( logger . isDebugEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsInfoEnabled ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> expect ( mock . isInfoEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> assertTrue ( logger . isInfoEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsWarnEnabled ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> expect ( mock . isWarnEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> assertTrue ( logger . isWarnEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsErrorEnabled ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> expect ( mock . isErrorEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> assertTrue ( logger . isErrorEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTrace ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> mock . trace ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> logger . trace ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTraceWithException ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> mock . trace ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> logger . trace ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDebug ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> mock . debug ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> logger . debug ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDebugWithException ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> mock . debug ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> logger . debug ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testInfo ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> mock . info ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> logger . info ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testInfoWithException ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> mock . info ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> logger . info ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWarn ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> mock . warn ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> logger . warn ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWarnWithException ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> mock . warn ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> logger . warn ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testError ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> mock . error ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> logger . error ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testErrorWithException ( ) { </a> 0
<a> org . apache . commons . logging . Log mock = </a> 0
<a> createStrictMock ( org . apache . commons . logging . Log . class ) ; </a> 0
<a> mock . error ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new CommonsLogger ( mock , "foo" ) ; </a> 0
<a> logger . error ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import static org . easymock . EasyMock . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . After ; </a> 0
<a> import org . junit . Before ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class InternalLoggerFactoryTest { </a> 0
<a> private static final Exception e = new Exception ( ) ; </a> 0
<a> private InternalLoggerFactory oldLoggerFactory ; </a> 0
<a> private InternalLogger mock ; </a> 0
<a> @ Before </a> 0
<a> public void init ( ) { </a> 0
<a> oldLoggerFactory = InternalLoggerFactory . getDefaultFactory ( ) ; </a> 0
<a> InternalLoggerFactory mockFactory = createMock ( InternalLoggerFactory . class ) ; </a> 0
<a> mock = createStrictMock ( InternalLogger . class ) ; </a> 0
<a> expect ( mockFactory . newInstance ( "mock" ) ) . andReturn ( mock ) . anyTimes ( ) ; </a> 0
<a> replay ( mockFactory ) ; </a> 0
<a> InternalLoggerFactory . setDefaultFactory ( mockFactory ) ; </a> 0
<a> } </a> 0
<a> @ After </a> 0
<a> public void destroy ( ) { </a> 0
<a> reset ( mock ) ; </a> 0
<a> InternalLoggerFactory . setDefaultFactory ( oldLoggerFactory ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = NullPointerException . class ) </a> 0
<a> public void shouldNotAllowNullDefaultFactory ( ) { </a> 0
<a> InternalLoggerFactory . setDefaultFactory ( null ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void shouldReturnWrappedLogger ( ) { </a> 0
<a> assertNotSame ( mock , InternalLoggerFactory . getInstance ( "mock" ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void shouldGetInstance ( ) { </a> 0
<a> InternalLoggerFactory . setDefaultFactory ( oldLoggerFactory ) ; </a> 0
<a> String helloWorld = "Hello, world!" ; </a> 0
<a> InternalLogger one = InternalLoggerFactory . getInstance ( "helloWorld" ) ; </a> 0
<a> InternalLogger two = InternalLoggerFactory . getInstance ( helloWorld . getClass ( ) ) ; </a> 0
<a> assertNotNull ( one ) ; </a> 0
<a> assertNotNull ( two ) ; </a> 0
<a> assertNotSame ( one , two ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsTraceEnabled ( ) { </a> 0
<a> expect ( mock . isTraceEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> assertTrue ( logger . isTraceEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsDebugEnabled ( ) { </a> 0
<a> expect ( mock . isDebugEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> assertTrue ( logger . isDebugEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsInfoEnabled ( ) { </a> 0
<a> expect ( mock . isInfoEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> assertTrue ( logger . isInfoEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsWarnEnabled ( ) { </a> 0
<a> expect ( mock . isWarnEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> assertTrue ( logger . isWarnEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsErrorEnabled ( ) { </a> 0
<a> expect ( mock . isErrorEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> assertTrue ( logger . isErrorEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTrace ( ) { </a> 0
<a> mock . trace ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> logger . trace ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTraceWithException ( ) { </a> 0
<a> mock . trace ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> logger . trace ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDebug ( ) { </a> 0
<a> mock . debug ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> logger . debug ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDebugWithException ( ) { </a> 0
<a> mock . debug ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> logger . debug ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testInfo ( ) { </a> 0
<a> mock . info ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> logger . info ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testInfoWithException ( ) { </a> 0
<a> mock . info ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> logger . info ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWarn ( ) { </a> 0
<a> mock . warn ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> logger . warn ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWarnWithException ( ) { </a> 0
<a> mock . warn ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> logger . warn ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testError ( ) { </a> 0
<a> mock . error ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> logger . error ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testErrorWithException ( ) { </a> 0
<a> mock . error ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = InternalLoggerFactory . getInstance ( "mock" ) ; </a> 0
<a> logger . error ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class JBossLoggerFactoryTest { </a> 0
<a> @ Test </a> 0
<a> public void testCreation ( ) { </a> 0
<a> InternalLogger logger = new JBossLoggerFactory ( ) . newInstance ( "foo" ) ; </a> 0
<a> assertTrue ( logger instanceof JBossLogger ) ; </a> 0
<a> assertEquals ( "foo" , logger . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import static org . easymock . EasyMock . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class JBossLoggerTest { </a> 0
<a> private static final Exception e = new Exception ( ) ; </a> 0
<a> @ Test </a> 0
<a> public void testIsTraceEnabled ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> expect ( mock . isTraceEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isTraceEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public void testIsDebugEnabled ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> expect ( mock . isDebugEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isDebugEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> @ SuppressWarnings ( "deprecation" ) </a> 0
<a> public void testIsInfoEnabled ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> expect ( mock . isInfoEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isInfoEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsWarnEnabled ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isWarnEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsErrorEnabled ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isErrorEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTrace ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> mock . trace ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> logger . trace ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTraceWithException ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> mock . trace ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> logger . trace ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDebug ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> mock . debug ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> logger . debug ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDebugWithException ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> mock . debug ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> logger . debug ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testInfo ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> mock . info ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> logger . info ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testInfoWithException ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> mock . info ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> logger . info ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWarn ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> mock . warn ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> logger . warn ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWarnWithException ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> mock . warn ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> logger . warn ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testError ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> mock . error ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> logger . error ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testErrorWithException ( ) { </a> 0
<a> org . jboss . logging . Logger mock = </a> 0
<a> createStrictMock ( org . jboss . logging . Logger . class ) ; </a> 0
<a> mock . error ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JBossLogger ( mock ) ; </a> 0
<a> logger . error ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class JdkLoggerFactoryTest { </a> 0
<a> @ Test </a> 0
<a> public void testCreation ( ) { </a> 0
<a> InternalLogger logger = new JdkLoggerFactory ( ) . newInstance ( "foo" ) ; </a> 0
<a> assertTrue ( logger instanceof JdkLogger ) ; </a> 0
<a> assertEquals ( "foo" , logger . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import static org . easymock . EasyMock . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import java . util . logging . Level ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class JdkLoggerTest { </a> 0
<a> private static final Exception e = new Exception ( ) ; </a> 0
<a> @ Test </a> 0
<a> public void testIsTraceEnabled ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> expect ( mock . isLoggable ( Level . FINEST ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> assertTrue ( logger . isTraceEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsDebugEnabled ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> expect ( mock . isLoggable ( Level . FINE ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> assertTrue ( logger . isDebugEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsInfoEnabled ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> expect ( mock . isLoggable ( Level . INFO ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> assertTrue ( logger . isInfoEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsWarnEnabled ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> expect ( mock . isLoggable ( Level . WARNING ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> assertTrue ( logger . isWarnEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsErrorEnabled ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> expect ( mock . isLoggable ( Level . SEVERE ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> assertTrue ( logger . isErrorEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTrace ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> mock . logp ( Level . FINEST , "foo" , null , "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> logger . trace ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTraceWithException ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> mock . logp ( Level . FINEST , "foo" , null , "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> logger . trace ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDebug ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> mock . logp ( Level . FINE , "foo" , null , "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> logger . debug ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDebugWithException ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> mock . logp ( Level . FINE , "foo" , null , "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> logger . debug ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testInfo ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> mock . logp ( Level . INFO , "foo" , null , "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> logger . info ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testInfoWithException ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> mock . logp ( Level . INFO , "foo" , null , "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> logger . info ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWarn ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> mock . logp ( Level . WARNING , "foo" , null , "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> logger . warn ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWarnWithException ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> mock . logp ( Level . WARNING , "foo" , null , "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> logger . warn ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testError ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> mock . logp ( Level . SEVERE , "foo" , null , "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> logger . error ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testErrorWithException ( ) { </a> 0
<a> java . util . logging . Logger mock = </a> 0
<a> createStrictMock ( java . util . logging . Logger . class ) ; </a> 0
<a> mock . logp ( Level . SEVERE , "foo" , null , "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new JdkLogger ( mock , "foo" ) ; </a> 0
<a> logger . error ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class Log4JLoggerFactoryTest { </a> 0
<a> @ Test </a> 0
<a> public void testCreation ( ) { </a> 0
<a> InternalLogger logger = new Log4JLoggerFactory ( ) . newInstance ( "foo" ) ; </a> 0
<a> assertTrue ( logger instanceof Log4JLogger ) ; </a> 0
<a> assertEquals ( "foo" , logger . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import static org . easymock . EasyMock . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class Log4JLoggerTest { </a> 0
<a> private static final Exception e = new Exception ( ) ; </a> 0
<a> @ Test </a> 0
<a> public void testIsTraceEnabled ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> expect ( mock . isTraceEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isTraceEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsDebugEnabled ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> expect ( mock . isDebugEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isDebugEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsInfoEnabled ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> expect ( mock . isInfoEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isInfoEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsWarnEnabled ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isWarnEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsErrorEnabled ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isErrorEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTrace ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> mock . trace ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> logger . trace ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTraceWithException ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> mock . trace ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> logger . trace ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDebug ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> mock . debug ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> logger . debug ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDebugWithException ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> mock . debug ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> logger . debug ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testInfo ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> mock . info ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> logger . info ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testInfoWithException ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> mock . info ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> logger . info ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWarn ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> mock . warn ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> logger . warn ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWarnWithException ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> mock . warn ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> logger . warn ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testError ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> mock . error ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> logger . error ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testErrorWithException ( ) { </a> 0
<a> org . apache . log4j . Logger mock = </a> 0
<a> createStrictMock ( org . apache . log4j . Logger . class ) ; </a> 0
<a> mock . error ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Log4JLogger ( mock ) ; </a> 0
<a> logger . error ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class Slf4JLoggerFactoryTest { </a> 0
<a> @ Test </a> 0
<a> public void testCreation ( ) { </a> 0
<a> InternalLogger logger = new Slf4JLoggerFactory ( ) . newInstance ( "foo" ) ; </a> 0
<a> assertTrue ( logger instanceof Slf4JLogger ) ; </a> 0
<a> assertEquals ( "foo" , logger . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . logging ; </a> 0
<a> import static org . easymock . EasyMock . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class Slf4JLoggerTest { </a> 0
<a> private static final Exception e = new Exception ( ) ; </a> 0
<a> @ Test </a> 0
<a> public void testIsTraceEnabled ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> expect ( mock . isTraceEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isTraceEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsDebugEnabled ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> expect ( mock . isDebugEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isDebugEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsInfoEnabled ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> expect ( mock . isInfoEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isInfoEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsWarnEnabled ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> expect ( mock . isWarnEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isWarnEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testIsErrorEnabled ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> expect ( mock . isErrorEnabled ( ) ) . andReturn ( true ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> assertTrue ( logger . isErrorEnabled ( ) ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTrace ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> mock . trace ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> logger . trace ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testTraceWithException ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> mock . trace ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> logger . trace ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDebug ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> mock . debug ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> logger . debug ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testDebugWithException ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> mock . debug ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> logger . debug ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testInfo ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> mock . info ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> logger . info ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testInfoWithException ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> mock . info ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> logger . info ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWarn ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> mock . warn ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> logger . warn ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testWarnWithException ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> mock . warn ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> logger . warn ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testError ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> mock . error ( "a" ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> logger . error ( "a" ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testErrorWithException ( ) { </a> 0
<a> org . slf4j . Logger mock = </a> 0
<a> createStrictMock ( org . slf4j . Logger . class ) ; </a> 0
<a> mock . error ( "a" , e ) ; </a> 0
<a> replay ( mock ) ; </a> 0
<a> InternalLogger logger = new Slf4JLogger ( mock ) ; </a> 0
<a> logger . error ( "a" , e ) ; </a> 0
<a> verify ( mock ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> import static org . junit . Assert . assertEquals ; </a> 1
<a> import static org . junit . Assert . assertNotNull ; </a> 1
<a> import static org . junit . Assert . assertNotSame ; </a> 1
<a> import static org . junit . Assert . assertNull ; </a> 1
<a> import static org . junit . Assert . assertSame ; </a> 1
<a> import org . junit . Before ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class DefaultAttributeMapTest { </a> 0
<a> private DefaultAttributeMap map ; </a> 0
<a> @ Before </a> 0
<a> public void setup ( ) { </a> 0
<a> this . map = new DefaultAttributeMap ( ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testMapExists ( ) { </a> 0
<a> assertNotNull ( this . map ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testGetSetString ( ) { </a> 0
<a> AttributeKey < String > key = new AttributeKey < String > ( "Nothing" ) ; </a> 1
<a> Attribute one = this . map . attr ( key ) ; </a> 1
<a> assertSame ( one , this . map . attr ( key ) ) ; </a> 1
<a> one . setIfAbsent ( "Whoohoo" ) ; </a> 0
<a> assertSame ( one . get ( ) , "Whoohoo" ) ; </a> 1
<a> one . setIfAbsent ( "What" ) ; </a> 0
<a> assertNotSame ( one . get ( ) , "What" ) ; </a> 1
<a> one . remove ( ) ; </a> 0
<a> assertNull ( one . get ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testGetSetInt ( ) { </a> 0
<a> AttributeKey < Integer > key = new AttributeKey < Integer > ( "Nada" ) ; </a> 1
<a> Attribute one = this . map . attr ( key ) ; </a> 1
<a> assertSame ( one , this . map . attr ( key ) ) ; </a> 1
<a> one . setIfAbsent ( 3653 ) ; </a> 0
<a> assertEquals ( one . get ( ) , 3653 ) ; </a> 1
<a> one . setIfAbsent ( 1 ) ; </a> 0
<a> assertNotSame ( one . get ( ) , 1 ) ; </a> 1
<a> one . remove ( ) ; </a> 0
<a> assertNull ( one . get ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util ; </a> 0
<a> import java . util . ArrayList ; </a> 1
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import static org . junit . Assert . assertFalse ; </a> 1
<a> import static org . junit . Assert . assertNotSame ; </a> 1
<a> import static org . junit . Assert . assertTrue ; </a> 1
<a> import static org . junit . Assert . assertSame ; </a> 1
<a> import org . junit . Before ; </a> 1
<a> import org . junit . Test ; </a> 1
<a> public class UniqueNameTest { </a> 1
<a> private ConcurrentHashMap < String , Boolean > names ; </a> 1
<a> public UniqueName registerName ( String name ) { </a> 1
<a> return new UniqueName ( names , name ) ; </a> 1
<a> } </a> 1
<a> @ Before </a> 1
<a> public void initializeTest ( ) { </a> 1
<a> this . names = new ConcurrentHashMap < String , Boolean > ( ) ; </a> 1
<a> } </a> 1
<a> @ Test ( expected = NullPointerException . class ) </a> 1
<a> public void testCannnotProvideNullMap ( ) { </a> 1
<a> UniqueName nullName = new UniqueName ( null , "Nothing" ) ; </a> 1
<a> } </a> 1
<a> @ Test ( expected = NullPointerException . class ) </a> 1
<a> public void testCannotProvideNullName ( ) { </a> 1
<a> UniqueName nullName = new UniqueName ( this . names , null ) ; </a> 1
<a> } </a> 1
<a> @ Test </a> 1
<a> public void testArgsCanBePassed ( ) { </a> 1
<a> UniqueName nullName = new UniqueName ( this . names , "Argh, matey!" , 2 , 5 , new Object ( ) ) ; </a> 1
<a> } </a> 1
<a> @ Test </a> 1
<a> public void testRegisteringName ( ) { </a> 1
<a> registerName ( "Abcedrian" ) ; </a> 1
<a> assertTrue ( this . names . get ( "Abcedrian" ) ) ; </a> 1
<a> assertTrue ( this . names . get ( "Hellyes" ) == null ) ; </a> 1
<a> } </a> 1
<a> @ Test </a> 1
<a> public void testNameUniqueness ( ) { </a> 1
<a> registerName ( "Leroy" ) ; </a> 1
<a> boolean failed = false ; </a> 1
<a> try { </a> 1
<a> registerName ( "Leroy" ) ; </a> 1
<a> } catch ( IllegalArgumentException ex ) { </a> 1
<a> failed = true ; </a> 1
<a> } </a> 1
<a> assertTrue ( failed ) ; </a> 1
<a> } </a> 1
<a> @ Test </a> 1
<a> public void testIDUniqueness ( ) { </a> 1
<a> UniqueName one = registerName ( "one" ) ; </a> 1
<a> UniqueName two = registerName ( "two" ) ; </a> 1
<a> assertNotSame ( one . id ( ) , two . id ( ) ) ; </a> 1
<a> ArrayList < UniqueName > nameList = new ArrayList < UniqueName > ( ) ; </a> 1
<a> for ( int index = 0 ; index < 2500 ; index ++ ) { </a> 1
<a> UniqueName currentName = registerName ( "test" + index ) ; </a> 1
<a> nameList . add ( currentName ) ; </a> 1
<a> for ( UniqueName otherName : nameList ) { </a> 1
<a> if ( ! currentName . name ( ) . equals ( otherName . name ( ) ) ) { </a> 1
<a> assertNotSame ( currentName , otherName ) ; </a> 1
<a> assertNotSame ( currentName . hashCode ( ) , otherName . hashCode ( ) ) ; </a> 1
<a> assertFalse ( currentName . equals ( otherName ) ) ; </a> 1
<a> assertNotSame ( currentName . toString ( ) , otherName . toString ( ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Test </a> 1
<a> public void testCompareNames ( ) { </a> 1
<a> UniqueName one = registerName ( "One" ) ; </a> 1
<a> UniqueName two = registerName ( "Two" ) ; </a> 1
<a> ConcurrentHashMap < String , Boolean > mapTwo = new ConcurrentHashMap < String , Boolean > ( ) ; </a> 1
<a> UniqueName three = new UniqueName ( mapTwo , "One" ) ; </a> 1
<a> assertSame ( one . compareTo ( one ) , 0 ) ; </a> 1
<a> assertSame ( one . compareTo ( two ) , - 5 ) ; </a> 1
<a> assertSame ( one . compareTo ( three ) , - 1 ) ; </a> 1
<a> assertSame ( three . compareTo ( one ) , 1 ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . util . internal ; </a> 0
<a> import static org . junit . Assert . assertNotNull ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class StringUtilTest { </a> 0
<a> @ Test </a> 0
<a> public void ensureNewlineExists ( ) { </a> 0
<a> assertNotNull ( StringUtil . NEWLINE ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . discard ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> public class DiscardServer { </a> 1
<a> private final int port ; </a> 1
<a> public DiscardServer ( int port ) { </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 0
<a> public void run ( ) throws Exception { </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . localAddress ( port ) </a> 0
<a> . childHandler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 1
<a> ch . pipeline ( ) . addLast ( new DiscardServerHandler ( ) ) ; </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> ChannelFuture f = b . bind ( ) . sync ( ) ; </a> 0
<a> f . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8080 ; </a> 1
<a> } </a> 1
<a> new DiscardServer ( port ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . discard ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 1
<a> import java . util . logging . Level ; </a> 0
<a> import java . util . logging . Logger ; </a> 0
<a> public class DiscardServerHandler extends ChannelInboundByteHandlerAdapter { </a> 1
<a> private static final Logger logger = Logger . getLogger ( </a> 0
<a> DiscardServerHandler . class . getName ( ) ) ; </a> 1
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) </a> 1
<a> throws Exception { </a> 1
<a> in . clear ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , </a> 1
<a> Throwable cause ) throws Exception { </a> 1
<a> logger . log ( </a> 0
<a> Level . WARNING , </a> 0
<a> "Unexpected exception from downstream." , </a> 0
<a> cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . echo ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 1
<a> import java . util . logging . Level ; </a> 1
<a> import java . util . logging . Logger ; </a> 1
<a> public class EchoClientHandler extends ChannelInboundByteHandlerAdapter { </a> 1
<a> private static final Logger logger = Logger . getLogger ( </a> 1
<a> EchoClientHandler . class . getName ( ) ) ; </a> 1
<a> private final ByteBuf firstMessage ; </a> 0
<a> public EchoClientHandler ( int firstMessageSize ) { </a> 1
<a> if ( firstMessageSize <= 0 ) { </a> 1
<a> throw new IllegalArgumentException ( "firstMessageSize: " + firstMessageSize ) ; </a> 1
<a> } </a> 1
<a> firstMessage = Unpooled . buffer ( firstMessageSize ) ; </a> 1
<a> for ( int i = 0 ; i < firstMessage . capacity ( ) ; i ++ ) { </a> 0
<a> firstMessage . writeByte ( ( byte ) i ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) { </a> 0
<a> ctx . write ( firstMessage ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) { </a> 1
<a> ByteBuf out = ctx . nextOutboundByteBuffer ( ) ; </a> 1
<a> out . discardReadBytes ( ) ; </a> 0
<a> out . writeBytes ( in ) ; </a> 1
<a> ctx . flush ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) { </a> 0
<a> logger . log ( Level . WARNING , "Unexpected exception from downstream." , cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . echo ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelOption ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> import io . netty . handler . logging . LogLevel ; </a> 0
<a> import io . netty . handler . logging . LoggingHandler ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> public class EchoServer { </a> 1
<a> private final int port ; </a> 1
<a> public EchoServer ( int port ) { </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 0
<a> public void run ( ) throws Exception { </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . option ( ChannelOption . SO_BACKLOG , 100 ) </a> 0
<a> . localAddress ( new InetSocketAddress ( port ) ) </a> 0
<a> . childOption ( ChannelOption . TCP_NODELAY , true ) </a> 1
<a> . handler ( new LoggingHandler ( LogLevel . INFO ) ) </a> 0
<a> . childHandler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 0
<a> ch . pipeline ( ) . addLast ( </a> 1
<a> new LoggingHandler ( LogLevel . INFO ) , </a> 1
<a> new EchoServerHandler ( ) ) ; </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> ChannelFuture f = b . bind ( ) . sync ( ) ; </a> 0
<a> f . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8080 ; </a> 1
<a> } </a> 1
<a> new EchoServer ( port ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . echo ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 1
<a> import java . util . logging . Level ; </a> 0
<a> import java . util . logging . Logger ; </a> 0
<a> @ Sharable </a> 0
<a> public class EchoServerHandler extends ChannelInboundByteHandlerAdapter { </a> 1
<a> private static final Logger logger = Logger . getLogger ( </a> 0
<a> EchoServerHandler . class . getName ( ) ) ; </a> 1
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) { </a> 1
<a> ByteBuf out = ctx . nextOutboundByteBuffer ( ) ; </a> 1
<a> out . discardReadBytes ( ) ; </a> 0
<a> out . writeBytes ( in ) ; </a> 1
<a> ctx . flush ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) { </a> 0
<a> logger . log ( Level . WARNING , "Unexpected exception from downstream." , cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . factorial ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioSocketChannel ; </a> 0
<a> public class FactorialClient { </a> 1
<a> private final String host ; </a> 1
<a> private final int port ; </a> 1
<a> private final int count ; </a> 1
<a> public FactorialClient ( String host , int port , int count ) { </a> 1
<a> this . host = host ; </a> 1
<a> this . port = port ; </a> 1
<a> this . count = count ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> Bootstrap b = new Bootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioSocketChannel ( ) ) </a> 0
<a> . remoteAddress ( host , port ) </a> 0
<a> . handler ( new FactorialClientInitializer ( count ) ) ; </a> 1
<a> ChannelFuture f = b . connect ( ) . sync ( ) ; </a> 0
<a> FactorialClientHandler handler = </a> 0
<a> ( FactorialClientHandler ) f . channel ( ) . pipeline ( ) . last ( ) ; </a> 0
<a> System . err . format ( </a> 1
<a> "Factorial of %,d is: %,d" , count , handler . getFactorial ( ) ) ; </a> 1
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> if ( args . length != 3 ) { </a> 0
<a> System . err . println ( </a> 0
<a> "Usage: " + FactorialClient . class . getSimpleName ( ) + </a> 0
<a> " <host> <port> <count>" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> String host = args [ 0 ] ; </a> 0
<a> int port = Integer . parseInt ( args [ 1 ] ) ; </a> 0
<a> int count = Integer . parseInt ( args [ 2 ] ) ; </a> 0
<a> if ( count <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "count must be a positive integer." ) ; </a> 0
<a> } </a> 0
<a> new FactorialClient ( host , port , count ) . run ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . factorial ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . compression . ZlibCodecFactory ; </a> 0
<a> import io . netty . handler . codec . compression . ZlibWrapper ; </a> 0
<a> public class FactorialClientInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> private final int count ; </a> 1
<a> public FactorialClientInitializer ( int count ) { </a> 1
<a> this . count = count ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 1
<a> ChannelPipeline pipeline = ch . pipeline ( ) ; </a> 0
<a> pipeline . addLast ( "deflater" , ZlibCodecFactory . newZlibEncoder ( ZlibWrapper . GZIP ) ) ; </a> 0
<a> pipeline . addLast ( "inflater" , ZlibCodecFactory . newZlibDecoder ( ZlibWrapper . GZIP ) ) ; </a> 0
<a> pipeline . addLast ( "decoder" , new BigIntegerDecoder ( ) ) ; </a> 1
<a> pipeline . addLast ( "encoder" , new NumberEncoder ( ) ) ; </a> 1
<a> pipeline . addLast ( "handler" , new FactorialClientHandler ( count ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . factorial ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> public class FactorialServer { </a> 1
<a> private final int port ; </a> 1
<a> public FactorialServer ( int port ) { </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 0
<a> public void run ( ) throws Exception { </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . localAddress ( port ) </a> 0
<a> . childHandler ( new FactorialServerInitializer ( ) ) ; </a> 1
<a> b . bind ( ) . sync ( ) . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8080 ; </a> 1
<a> } </a> 1
<a> new FactorialServer ( port ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . factorial ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import java . math . BigInteger ; </a> 0
<a> import java . util . Formatter ; </a> 1
<a> import java . util . logging . Level ; </a> 1
<a> import java . util . logging . Logger ; </a> 1
<a> public class FactorialServerHandler extends ChannelInboundMessageHandlerAdapter < BigInteger > { </a> 1
<a> private static final Logger logger = Logger . getLogger ( </a> 1
<a> FactorialServerHandler . class . getName ( ) ) ; </a> 1
<a> private BigInteger lastMultiplier = new BigInteger ( "1" ) ; </a> 0
<a> private BigInteger factorial = new BigInteger ( "1" ) ; </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( </a> 0
<a> ChannelHandlerContext ctx , BigInteger msg ) throws Exception { </a> 1
<a> lastMultiplier = msg ; </a> 0
<a> factorial = factorial . multiply ( msg ) ; </a> 0
<a> ctx . write ( factorial ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( </a> 0
<a> ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> logger . info ( new Formatter ( ) . format ( </a> 0
<a> "Factorial of %,d is: %,d" , lastMultiplier , factorial ) . toString ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( </a> 0
<a> ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> logger . log ( </a> 1
<a> Level . WARNING , </a> 1
<a> "Unexpected exception from downstream." , cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . factorial ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . compression . ZlibCodecFactory ; </a> 0
<a> import io . netty . handler . codec . compression . ZlibWrapper ; </a> 0
<a> public class FactorialServerInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 1
<a> ChannelPipeline pipeline = ch . pipeline ( ) ; </a> 0
<a> pipeline . addLast ( "deflater" , ZlibCodecFactory . newZlibEncoder ( ZlibWrapper . GZIP ) ) ; </a> 0
<a> pipeline . addLast ( "inflater" , ZlibCodecFactory . newZlibDecoder ( ZlibWrapper . GZIP ) ) ; </a> 0
<a> pipeline . addLast ( "decoder" , new BigIntegerDecoder ( ) ) ; </a> 1
<a> pipeline . addLast ( "encoder" , new NumberEncoder ( ) ) ; </a> 1
<a> pipeline . addLast ( "handler" , new FactorialServerHandler ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . file ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . Names . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpMethod . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpResponseStatus . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpVersion . * ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . handler . codec . TooLongFrameException ; </a> 0
<a> import io . netty . handler . codec . http . DefaultHttpResponse ; </a> 1
<a> import io . netty . handler . codec . http . HttpHeaders ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseStatus ; </a> 0
<a> import io . netty . handler . stream . ChunkedFile ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . io . File ; </a> 0
<a> import java . io . FileNotFoundException ; </a> 0
<a> import java . io . RandomAccessFile ; </a> 0
<a> import java . io . UnsupportedEncodingException ; </a> 0
<a> import java . net . URLDecoder ; </a> 0
<a> import java . text . SimpleDateFormat ; </a> 0
<a> import java . util . Calendar ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . GregorianCalendar ; </a> 0
<a> import java . util . Locale ; </a> 0
<a> import java . util . TimeZone ; </a> 0
<a> import javax . activation . MimetypesFileTypeMap ; </a> 0
<a> public class HttpStaticFileServerHandler extends ChannelInboundMessageHandlerAdapter < HttpRequest > { </a> 1
<a> public static final String HTTP_DATE_FORMAT = "EEE, dd MMM yyyy HH:mm:ss zzz" ; </a> 0
<a> public static final String HTTP_DATE_GMT_TIMEZONE = "GMT" ; </a> 0
<a> public static final int HTTP_CACHE_SECONDS = 60 ; </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( </a> 0
<a> ChannelHandlerContext ctx , HttpRequest request ) throws Exception { </a> 1
<a> if ( request . getMethod ( ) != GET ) { </a> 1
<a> sendError ( ctx , METHOD_NOT_ALLOWED ) ; </a> 0
<a> return ; </a> 1
<a> } </a> 0
<a> final String path = sanitizeUri ( request . getUri ( ) ) ; </a> 0
<a> if ( path == null ) { </a> 0
<a> sendError ( ctx , FORBIDDEN ) ; </a> 0
<a> return ; </a> 1
<a> } </a> 0
<a> File file = new File ( path ) ; </a> 0
<a> if ( file . isHidden ( ) || ! file . exists ( ) ) { </a> 0
<a> sendError ( ctx , NOT_FOUND ) ; </a> 0
<a> return ; </a> 1
<a> } </a> 0
<a> if ( ! file . isFile ( ) ) { </a> 0
<a> sendError ( ctx , FORBIDDEN ) ; </a> 0
<a> return ; </a> 1
<a> } </a> 0
<a> String ifModifiedSince = request . getHeader ( HttpHeaders . Names . IF_MODIFIED_SINCE ) ; </a> 0
<a> if ( ifModifiedSince != null && ! ifModifiedSince . equals ( "" ) ) { </a> 0
<a> SimpleDateFormat dateFormatter = new SimpleDateFormat ( HTTP_DATE_FORMAT , Locale . US ) ; </a> 0
<a> Date ifModifiedSinceDate = dateFormatter . parse ( ifModifiedSince ) ; </a> 0
<a> long ifModifiedSinceDateSeconds = ifModifiedSinceDate . getTime ( ) / 1000 ; </a> 0
<a> long fileLastModifiedSeconds = file . lastModified ( ) / 1000 ; </a> 0
<a> if ( ifModifiedSinceDateSeconds == fileLastModifiedSeconds ) { </a> 0
<a> sendNotModified ( ctx ) ; </a> 0
<a> return ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> RandomAccessFile raf ; </a> 0
<a> try { </a> 0
<a> raf = new RandomAccessFile ( file , "r" ) ; </a> 0
<a> } catch ( FileNotFoundException fnfe ) { </a> 1
<a> sendError ( ctx , NOT_FOUND ) ; </a> 0
<a> return ; </a> 1
<a> } </a> 0
<a> long fileLength = raf . length ( ) ; </a> 0
<a> HttpResponse response = new DefaultHttpResponse ( HTTP_1_1 , OK ) ; </a> 1
<a> setContentLength ( response , fileLength ) ; </a> 0
<a> setContentTypeHeader ( response , file ) ; </a> 0
<a> setDateAndCacheHeaders ( response , file ) ; </a> 0
<a> if ( isKeepAlive ( request ) ) { </a> 0
<a> response . setHeader ( CONNECTION , HttpHeaders . Values . KEEP_ALIVE ) ; </a> 1
<a> } </a> 0
<a> ctx . write ( response ) ; </a> 1
<a> ChannelFuture writeFuture = ctx . write ( new ChunkedFile ( raf , 0 , fileLength , 8192 ) ) ; </a> 1
<a> if ( ! isKeepAlive ( request ) ) { </a> 0
<a> writeFuture . addListener ( ChannelFutureListener . CLOSE ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( </a> 0
<a> ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> if ( cause instanceof TooLongFrameException ) { </a> 0
<a> sendError ( ctx , BAD_REQUEST ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> cause . printStackTrace ( ) ; </a> 0
<a> if ( ctx . channel ( ) . isActive ( ) ) { </a> 0
<a> sendError ( ctx , INTERNAL_SERVER_ERROR ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static String sanitizeUri ( String uri ) { </a> 0
<a> try { </a> 0
<a> uri = URLDecoder . decode ( uri , "UTF-8" ) ; </a> 0
<a> } catch ( UnsupportedEncodingException e ) { </a> 0
<a> try { </a> 1
<a> uri = URLDecoder . decode ( uri , "ISO-8859-1" ) ; </a> 1
<a> } catch ( UnsupportedEncodingException e1 ) { </a> 1
<a> throw new Error ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> uri = uri . replace ( '/' , File . separatorChar ) ; </a> 0
<a> if ( uri . contains ( File . separator + "." ) || </a> 0
<a> uri . contains ( "." + File . separator ) || </a> 0
<a> uri . startsWith ( "." ) || uri . endsWith ( "." ) ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> return System . getProperty ( "user.dir" ) + File . separator + uri ; </a> 0
<a> } </a> 0
<a> private static void sendError ( ChannelHandlerContext ctx , HttpResponseStatus status ) { </a> 0
<a> HttpResponse response = new DefaultHttpResponse ( HTTP_1_1 , status ) ; </a> 1
<a> response . setHeader ( CONTENT_TYPE , "text/plain; charset=UTF-8" ) ; </a> 1
<a> response . setContent ( Unpooled . copiedBuffer ( </a> 1
<a> "Failure: " + status . toString ( ) + "\r\n" , </a> 1
<a> CharsetUtil . UTF_8 ) ) ; </a> 1
<a> ctx . write ( response ) . addListener ( ChannelFutureListener . CLOSE ) ; </a> 0
<a> } </a> 0
<a> private static void sendNotModified ( ChannelHandlerContext ctx ) { </a> 0
<a> HttpResponse response = new DefaultHttpResponse ( HTTP_1_1 , HttpResponseStatus . NOT_MODIFIED ) ; </a> 0
<a> setDateHeader ( response ) ; </a> 0
<a> ctx . write ( response ) . addListener ( ChannelFutureListener . CLOSE ) ; </a> 0
<a> } </a> 0
<a> private static void setDateHeader ( HttpResponse response ) { </a> 1
<a> SimpleDateFormat dateFormatter = new SimpleDateFormat ( HTTP_DATE_FORMAT , Locale . US ) ; </a> 0
<a> dateFormatter . setTimeZone ( TimeZone . getTimeZone ( HTTP_DATE_GMT_TIMEZONE ) ) ; </a> 0
<a> Calendar time = new GregorianCalendar ( ) ; </a> 0
<a> response . setHeader ( HttpHeaders . Names . DATE , dateFormatter . format ( time . getTime ( ) ) ) ; </a> 0
<a> } </a> 0
<a> private static void setDateAndCacheHeaders ( HttpResponse response , File fileToCache ) { </a> 1
<a> SimpleDateFormat dateFormatter = new SimpleDateFormat ( HTTP_DATE_FORMAT , Locale . US ) ; </a> 0
<a> dateFormatter . setTimeZone ( TimeZone . getTimeZone ( HTTP_DATE_GMT_TIMEZONE ) ) ; </a> 0
<a> Calendar time = new GregorianCalendar ( ) ; </a> 0
<a> response . setHeader ( HttpHeaders . Names . DATE , dateFormatter . format ( time . getTime ( ) ) ) ; </a> 0
<a> time . add ( Calendar . SECOND , HTTP_CACHE_SECONDS ) ; </a> 0
<a> response . setHeader ( HttpHeaders . Names . EXPIRES , dateFormatter . format ( time . getTime ( ) ) ) ; </a> 0
<a> response . setHeader ( HttpHeaders . Names . CACHE_CONTROL , "private, max-age=" + HTTP_CACHE_SECONDS ) ; </a> 0
<a> response . setHeader ( </a> 1
<a> HttpHeaders . Names . LAST_MODIFIED , dateFormatter . format ( new Date ( fileToCache . lastModified ( ) ) ) ) ; </a> 0
<a> } </a> 0
<a> private static void setContentTypeHeader ( HttpResponse response , File file ) { </a> 1
<a> MimetypesFileTypeMap mimeTypesMap = new MimetypesFileTypeMap ( ) ; </a> 0
<a> response . setHeader ( HttpHeaders . Names . CONTENT_TYPE , mimeTypesMap . getContentType ( file . getPath ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . file ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . http . HttpChunkAggregator ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequestDecoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseEncoder ; </a> 1
<a> import io . netty . handler . stream . ChunkedWriteHandler ; </a> 0
<a> public class HttpStaticFileServerInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> @ Override </a> 1
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 1
<a> ChannelPipeline pipeline = ch . pipeline ( ) ; </a> 1
<a> pipeline . addLast ( "decoder" , new HttpRequestDecoder ( ) ) ; </a> 1
<a> pipeline . addLast ( "aggregator" , new HttpChunkAggregator ( 65536 ) ) ; </a> 0
<a> pipeline . addLast ( "encoder" , new HttpResponseEncoder ( ) ) ; </a> 0
<a> pipeline . addLast ( "chunkedWriter" , new ChunkedWriteHandler ( ) ) ; </a> 1
<a> pipeline . addLast ( "handler" , new HttpStaticFileServerHandler ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . snoop ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioSocketChannel ; </a> 0
<a> import io . netty . handler . codec . http . ClientCookieEncoder ; </a> 0
<a> import io . netty . handler . codec . http . DefaultCookie ; </a> 0
<a> import io . netty . handler . codec . http . DefaultHttpRequest ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders ; </a> 0
<a> import io . netty . handler . codec . http . HttpMethod ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 0
<a> import io . netty . handler . codec . http . HttpVersion ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . net . URI ; </a> 0
<a> public class HttpSnoopClient { </a> 1
<a> private final URI uri ; </a> 1
<a> public HttpSnoopClient ( URI uri ) { </a> 1
<a> this . uri = uri ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> String scheme = uri . getScheme ( ) == null ? "http" : uri . getScheme ( ) ; </a> 0
<a> String host = uri . getHost ( ) == null ? "localhost" : uri . getHost ( ) ; </a> 1
<a> int port = uri . getPort ( ) ; </a> 0
<a> if ( port == - 1 ) { </a> 0
<a> if ( scheme . equalsIgnoreCase ( "http" ) ) { </a> 0
<a> port = 80 ; </a> 0
<a> } else if ( scheme . equalsIgnoreCase ( "https" ) ) { </a> 0
<a> port = 443 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! scheme . equalsIgnoreCase ( "http" ) && ! scheme . equalsIgnoreCase ( "https" ) ) { </a> 0
<a> System . err . println ( "Only HTTP(S) is supported." ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> boolean ssl = scheme . equalsIgnoreCase ( "https" ) ; </a> 0
<a> Bootstrap b = new Bootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioSocketChannel ( ) ) </a> 0
<a> . handler ( new HttpSnoopClientInitializer ( ssl ) ) </a> 0
<a> . remoteAddress ( new InetSocketAddress ( host , port ) ) ; </a> 0
<a> Channel ch = b . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> HttpRequest request = new DefaultHttpRequest ( </a> 0
<a> HttpVersion . HTTP_1_1 , HttpMethod . GET , uri . getRawPath ( ) ) ; </a> 0
<a> request . setHeader ( HttpHeaders . Names . HOST , host ) ; </a> 1
<a> request . setHeader ( HttpHeaders . Names . CONNECTION , HttpHeaders . Values . CLOSE ) ; </a> 1
<a> request . setHeader ( HttpHeaders . Names . ACCEPT_ENCODING , HttpHeaders . Values . GZIP ) ; </a> 1
<a> request . setHeader ( </a> 0
<a> HttpHeaders . Names . COOKIE , </a> 0
<a> ClientCookieEncoder . encode ( </a> 0
<a> new DefaultCookie ( "my-cookie" , "foo" ) , </a> 0
<a> new DefaultCookie ( "another-cookie" , "bar" ) ) ) ; </a> 0
<a> ch . write ( request ) ; </a> 1
<a> ch . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> if ( args . length != 1 ) { </a> 0
<a> System . err . println ( </a> 0
<a> "Usage: " + HttpSnoopClient . class . getSimpleName ( ) + </a> 1
<a> " <URL>" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> URI uri = new URI ( args [ 0 ] ) ; </a> 0
<a> new HttpSnoopClient ( uri ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . snoop ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . handler . codec . http . HttpChunk ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class HttpSnoopClientHandler extends ChannelInboundMessageHandlerAdapter < Object > { </a> 1
<a> private boolean readingChunks ; </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 1
<a> if ( ! readingChunks ) { </a> 0
<a> HttpResponse response = ( HttpResponse ) msg ; </a> 0
<a> System . out . println ( "STATUS: " + response . getStatus ( ) ) ; </a> 1
<a> System . out . println ( "VERSION: " + response . getProtocolVersion ( ) ) ; </a> 1
<a> System . out . println ( ) ; </a> 1
<a> if ( ! response . getHeaderNames ( ) . isEmpty ( ) ) { </a> 1
<a> for ( String name : response . getHeaderNames ( ) ) { </a> 1
<a> for ( String value : response . getHeaders ( name ) ) { </a> 1
<a> System . out . println ( "HEADER: " + name + " = " + value ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> System . out . println ( ) ; </a> 1
<a> } </a> 0
<a> if ( response . getTransferEncoding ( ) . isMultiple ( ) ) { </a> 0
<a> readingChunks = true ; </a> 0
<a> System . out . println ( "CHUNKED CONTENT {" ) ; </a> 1
<a> } else { </a> 0
<a> ByteBuf content = response . getContent ( ) ; </a> 0
<a> if ( content . readable ( ) ) { </a> 0
<a> System . out . println ( "CONTENT {" ) ; </a> 1
<a> System . out . println ( content . toString ( CharsetUtil . UTF_8 ) ) ; </a> 0
<a> System . out . println ( "} END OF CONTENT" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> HttpChunk chunk = ( HttpChunk ) msg ; </a> 0
<a> if ( chunk . isLast ( ) ) { </a> 0
<a> readingChunks = false ; </a> 0
<a> System . out . println ( "} END OF CHUNKED CONTENT" ) ; </a> 0
<a> } else { </a> 0
<a> System . out . print ( chunk . getContent ( ) . toString ( CharsetUtil . UTF_8 ) ) ; </a> 0
<a> System . out . flush ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( </a> 1
<a> ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> cause . printStackTrace ( ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . snoop ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . * ; </a> 1
<a> import static io . netty . handler . codec . http . HttpHeaders . Names . * ; </a> 1
<a> import static io . netty . handler . codec . http . HttpResponseStatus . * ; </a> 1
<a> import static io . netty . handler . codec . http . HttpVersion . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . handler . codec . http . Cookie ; </a> 1
<a> import io . netty . handler . codec . http . CookieDecoder ; </a> 0
<a> import io . netty . handler . codec . http . DefaultHttpResponse ; </a> 1
<a> import io . netty . handler . codec . http . HttpChunk ; </a> 0
<a> import io . netty . handler . codec . http . HttpChunkTrailer ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 1
<a> import io . netty . handler . codec . http . QueryStringDecoder ; </a> 0
<a> import io . netty . handler . codec . http . ServerCookieEncoder ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> import java . util . Set ; </a> 0
<a> public class HttpSnoopServerHandler extends ChannelInboundMessageHandlerAdapter < Object > { </a> 1
<a> private HttpRequest request ; </a> 0
<a> private boolean readingChunks ; </a> 1
<a> private final StringBuilder buf = new StringBuilder ( ) ; </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 1
<a> if ( ! readingChunks ) { </a> 0
<a> HttpRequest request = this . request = ( HttpRequest ) msg ; </a> 0
<a> if ( is100ContinueExpected ( request ) ) { </a> 0
<a> send100Continue ( ctx ) ; </a> 1
<a> } </a> 0
<a> buf . setLength ( 0 ) ; </a> 0
<a> buf . append ( "WELCOME TO THE WILD WILD WEB SERVER\r\n" ) ; </a> 0
<a> buf . append ( "===================================\r\n" ) ; </a> 0
<a> buf . append ( "VERSION: " + request . getProtocolVersion ( ) + "\r\n" ) ; </a> 0
<a> buf . append ( "HOSTNAME: " + getHost ( request , "unknown" ) + "\r\n" ) ; </a> 0
<a> buf . append ( "REQUEST_URI: " + request . getUri ( ) + "\r\n\r\n" ) ; </a> 0
<a> for ( Map . Entry < String , String > h : request . getHeaders ( ) ) { </a> 1
<a> buf . append ( "HEADER: " + h . getKey ( ) + " = " + h . getValue ( ) + "\r\n" ) ; </a> 0
<a> } </a> 0
<a> buf . append ( "\r\n" ) ; </a> 0
<a> QueryStringDecoder queryStringDecoder = new QueryStringDecoder ( request . getUri ( ) ) ; </a> 1
<a> Map < String , List < String > > params = queryStringDecoder . getParameters ( ) ; </a> 0
<a> if ( ! params . isEmpty ( ) ) { </a> 0
<a> for ( Entry < String , List < String > > p : params . entrySet ( ) ) { </a> 0
<a> String key = p . getKey ( ) ; </a> 0
<a> List < String > vals = p . getValue ( ) ; </a> 0
<a> for ( String val : vals ) { </a> 0
<a> buf . append ( "PARAM: " + key + " = " + val + "\r\n" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> buf . append ( "\r\n" ) ; </a> 0
<a> } </a> 0
<a> if ( request . getTransferEncoding ( ) . isMultiple ( ) ) { </a> 0
<a> readingChunks = true ; </a> 1
<a> } else { </a> 1
<a> ByteBuf content = request . getContent ( ) ; </a> 0
<a> if ( content . readable ( ) ) { </a> 0
<a> buf . append ( "CONTENT: " + content . toString ( CharsetUtil . UTF_8 ) + "\r\n" ) ; </a> 0
<a> } </a> 0
<a> writeResponse ( ctx ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 1
<a> HttpChunk chunk = ( HttpChunk ) msg ; </a> 0
<a> if ( chunk . isLast ( ) ) { </a> 0
<a> readingChunks = false ; </a> 1
<a> buf . append ( "END OF CONTENT\r\n" ) ; </a> 0
<a> HttpChunkTrailer trailer = ( HttpChunkTrailer ) chunk ; </a> 0
<a> if ( ! trailer . getHeaderNames ( ) . isEmpty ( ) ) { </a> 1
<a> buf . append ( "\r\n" ) ; </a> 0
<a> for ( String name : trailer . getHeaderNames ( ) ) { </a> 1
<a> for ( String value : trailer . getHeaders ( name ) ) { </a> 1
<a> buf . append ( "TRAILING HEADER: " + name + " = " + value + "\r\n" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> buf . append ( "\r\n" ) ; </a> 0
<a> } </a> 0
<a> writeResponse ( ctx ) ; </a> 0
<a> } else { </a> 1
<a> buf . append ( "CHUNK: " + chunk . getContent ( ) . toString ( CharsetUtil . UTF_8 ) + "\r\n" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void writeResponse ( ChannelHandlerContext ctx ) { </a> 0
<a> boolean keepAlive = isKeepAlive ( request ) ; </a> 0
<a> HttpResponse response = new DefaultHttpResponse ( HTTP_1_1 , OK ) ; </a> 0
<a> response . setContent ( Unpooled . copiedBuffer ( buf . toString ( ) , CharsetUtil . UTF_8 ) ) ; </a> 1
<a> response . setHeader ( CONTENT_TYPE , "text/plain; charset=UTF-8" ) ; </a> 1
<a> if ( keepAlive ) { </a> 0
<a> response . setHeader ( CONTENT_LENGTH , response . getContent ( ) . readableBytes ( ) ) ; </a> 1
<a> response . setHeader ( CONNECTION , HttpHeaders . Values . KEEP_ALIVE ) ; </a> 1
<a> } </a> 0
<a> String cookieString = request . getHeader ( COOKIE ) ; </a> 1
<a> if ( cookieString != null ) { </a> 0
<a> Set < Cookie > cookies = CookieDecoder . decode ( cookieString ) ; </a> 0
<a> if ( ! cookies . isEmpty ( ) ) { </a> 0
<a> for ( Cookie cookie : cookies ) { </a> 0
<a> response . addHeader ( SET_COOKIE , ServerCookieEncoder . encode ( cookie ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> response . addHeader ( SET_COOKIE , ServerCookieEncoder . encode ( "key1" , "value1" ) ) ; </a> 0
<a> response . addHeader ( SET_COOKIE , ServerCookieEncoder . encode ( "key2" , "value2" ) ) ; </a> 0
<a> } </a> 0
<a> ChannelFuture future = ctx . write ( response ) ; </a> 0
<a> if ( ! keepAlive ) { </a> 1
<a> future . addListener ( ChannelFutureListener . CLOSE ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<a> private static void send100Continue ( ChannelHandlerContext ctx ) { </a> 1
<a> HttpResponse response = new DefaultHttpResponse ( HTTP_1_1 , CONTINUE ) ; </a> 0
<a> ctx . write ( response ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( </a> 1
<a> ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> cause . printStackTrace ( ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . snoop ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . http . HttpContentCompressor ; </a> 1
<a> import io . netty . handler . codec . http . HttpRequestDecoder ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseEncoder ; </a> 0
<a> public class HttpSnoopServerInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 1
<a> ChannelPipeline p = ch . pipeline ( ) ; </a> 0
<a> p . addLast ( "decoder" , new HttpRequestDecoder ( ) ) ; </a> 1
<a> p . addLast ( "encoder" , new HttpResponseEncoder ( ) ) ; </a> 1
<a> p . addLast ( "deflater" , new HttpContentCompressor ( ) ) ; </a> 1
<a> p . addLast ( "handler" , new HttpSnoopServerHandler ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . autobahn ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> public class AutobahnServer { </a> 0
<a> private final int port ; </a> 0
<a> public AutobahnServer ( int port ) { </a> 0
<a> this . port = port ; </a> 0
<a> } </a> 0
<a> public void run ( ) throws Exception { </a> 0
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . localAddress ( port ) </a> 0
<a> . childHandler ( new AutobahnServerInitializer ( ) ) ; </a> 0
<a> ChannelFuture f = b . bind ( ) . sync ( ) ; </a> 0
<a> System . out . println ( "Web Socket Server started at port " + port ) ; </a> 0
<a> f . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> int port ; </a> 0
<a> if ( args . length > 0 ) { </a> 0
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 0
<a> } else { </a> 0
<a> port = 9000 ; </a> 0
<a> } </a> 0
<a> new AutobahnServer ( port ) . run ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . autobahn ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . client ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . Channel ; </a> 1
<a> import io . netty . channel . ChannelInitializer ; </a> 1
<a> import io . netty . channel . ChannelPipeline ; </a> 1
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioSocketChannel ; </a> 1
<a> import io . netty . handler . codec . http . HttpRequestEncoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseDecoder ; </a> 1
<a> import io . netty . handler . codec . http . websocketx . CloseWebSocketFrame ; </a> 1
<a> import io . netty . handler . codec . http . websocketx . PingWebSocketFrame ; </a> 1
<a> import io . netty . handler . codec . http . websocketx . TextWebSocketFrame ; </a> 1
<a> import io . netty . handler . codec . http . websocketx . WebSocketClientHandshaker ; </a> 1
<a> import io . netty . handler . codec . http . websocketx . WebSocketClientHandshakerFactory ; </a> 1
<a> import io . netty . handler . codec . http . websocketx . WebSocketVersion ; </a> 1
<a> import java . net . URI ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> public class WebSocketClient { </a> 1
<a> private final URI uri ; </a> 1
<a> public WebSocketClient ( URI uri ) { </a> 1
<a> this . uri = uri ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> Bootstrap b = new Bootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> String protocol = uri . getScheme ( ) ; </a> 1
<a> if ( ! protocol . equals ( "ws" ) ) { </a> 0
<a> throw new IllegalArgumentException ( "Unsupported protocol: " + protocol ) ; </a> 0
<a> } </a> 0
<a> HashMap < String , String > customHeaders = new HashMap < String , String > ( ) ; </a> 0
<a> customHeaders . put ( "MyHeader" , "MyValue" ) ; </a> 1
<a> final WebSocketClientHandshaker handshaker = </a> 1
<a> new WebSocketClientHandshakerFactory ( ) . newHandshaker ( </a> 0
<a> uri , WebSocketVersion . V13 , null , false , customHeaders ) ; </a> 1
<a> b . group ( new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioSocketChannel ( ) ) </a> 0
<a> . remoteAddress ( uri . getHost ( ) , uri . getPort ( ) ) </a> 0
<a> . handler ( new ChannelInitializer < SocketChannel > ( ) { </a> 1
<a> @ Override </a> 1
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 1
<a> ChannelPipeline pipeline = ch . pipeline ( ) ; </a> 1
<a> pipeline . addLast ( "decoder" , new HttpResponseDecoder ( ) ) ; </a> 1
<a> pipeline . addLast ( "encoder" , new HttpRequestEncoder ( ) ) ; </a> 1
<a> pipeline . addLast ( "ws-handler" , new WebSocketClientHandler ( handshaker ) ) ; </a> 1
<a> } </a> 0
<a> } ) ; </a> 1
<a> System . out . println ( "WebSocket Client connecting" ) ; </a> 1
<a> Channel ch = b . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> handshaker . handshake ( ch ) . sync ( ) ; </a> 1
<a> System . out . println ( "WebSocket Client sending message" ) ; </a> 0
<a> for ( int i = 0 ; i < 1000 ; i ++ ) { </a> 1
<a> ch . write ( new TextWebSocketFrame ( "Message #" + i ) ) ; </a> 1
<a> } </a> 1
<a> System . out . println ( "WebSocket Client sending ping" ) ; </a> 1
<a> ch . write ( new PingWebSocketFrame ( Unpooled . copiedBuffer ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 } ) ) ) ; </a> 1
<a> System . out . println ( "WebSocket Client sending close" ) ; </a> 0
<a> ch . write ( new CloseWebSocketFrame ( ) ) ; </a> 1
<a> ch . closeFuture ( ) . sync ( ) ; </a> 1
<a> } finally { </a> 1
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> URI uri ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> uri = new URI ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 0
<a> uri = new URI ( "ws://localhost:8080/websocket" ) ; </a> 1
<a> } </a> 0
<a> new WebSocketClient ( uri ) . run ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . server ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> public class WebSocketServer { </a> 1
<a> private final int port ; </a> 1
<a> public WebSocketServer ( int port ) { </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 0
<a> public void run ( ) throws Exception { </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . localAddress ( port ) </a> 0
<a> . childHandler ( new WebSocketServerInitializer ( ) ) ; </a> 1
<a> Channel ch = b . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> System . out . println ( "Web socket server started at port " + port + '.' ) ; </a> 1
<a> System . out . println ( "Open your browser and navigate to http://localhost:" + port + '/' ) ; </a> 1
<a> ch . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8080 ; </a> 1
<a> } </a> 1
<a> new WebSocketServer ( port ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . server ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpHeaders . Names . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpMethod . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpResponseStatus . * ; </a> 0
<a> import static io . netty . handler . codec . http . HttpVersion . * ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . handler . codec . http . DefaultHttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . HttpHeaders ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequest ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponse ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . CloseWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . PingWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . PongWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . TextWebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . WebSocketFrame ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . WebSocketServerHandshaker ; </a> 0
<a> import io . netty . handler . codec . http . websocketx . WebSocketServerHandshakerFactory ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class WebSocketServerHandler extends ChannelInboundMessageHandlerAdapter < Object > { </a> 1
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocketServerHandler . class ) ; </a> 0
<a> private static final String WEBSOCKET_PATH = "/websocket" ; </a> 0
<a> private WebSocketServerHandshaker handshaker ; </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 1
<a> if ( msg instanceof HttpRequest ) { </a> 0
<a> handleHttpRequest ( ctx , ( HttpRequest ) msg ) ; </a> 0
<a> } else if ( msg instanceof WebSocketFrame ) { </a> 0
<a> handleWebSocketFrame ( ctx , ( WebSocketFrame ) msg ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void handleHttpRequest ( ChannelHandlerContext ctx , HttpRequest req ) throws Exception { </a> 0
<a> if ( req . getMethod ( ) != GET ) { </a> 0
<a> sendHttpResponse ( ctx , req , new DefaultHttpResponse ( HTTP_1_1 , FORBIDDEN ) ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( req . getUri ( ) . equals ( "/" ) ) { </a> 0
<a> HttpResponse res = new DefaultHttpResponse ( HTTP_1_1 , OK ) ; </a> 0
<a> ByteBuf content = WebSocketServerIndexPage . getContent ( getWebSocketLocation ( req ) ) ; </a> 0
<a> res . setHeader ( CONTENT_TYPE , "text/html; charset=UTF-8" ) ; </a> 0
<a> setContentLength ( res , content . readableBytes ( ) ) ; </a> 0
<a> res . setContent ( content ) ; </a> 0
<a> sendHttpResponse ( ctx , req , res ) ; </a> 0
<a> return ; </a> 0
<a> } else if ( req . getUri ( ) . equals ( "/favicon.ico" ) ) { </a> 0
<a> HttpResponse res = new DefaultHttpResponse ( HTTP_1_1 , NOT_FOUND ) ; </a> 0
<a> sendHttpResponse ( ctx , req , res ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory ( </a> 0
<a> getWebSocketLocation ( req ) , null , false ) ; </a> 1
<a> handshaker = wsFactory . newHandshaker ( req ) ; </a> 0
<a> if ( handshaker == null ) { </a> 0
<a> wsFactory . sendUnsupportedWebSocketVersionResponse ( ctx . channel ( ) ) ; </a> 0
<a> } else { </a> 0
<a> handshaker . handshake ( ctx . channel ( ) , req ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void handleWebSocketFrame ( ChannelHandlerContext ctx , WebSocketFrame frame ) { </a> 0
<a> if ( frame instanceof CloseWebSocketFrame ) { </a> 0
<a> handshaker . close ( ctx . channel ( ) , ( CloseWebSocketFrame ) frame ) ; </a> 1
<a> return ; </a> 0
<a> } else if ( frame instanceof PingWebSocketFrame ) { </a> 0
<a> ctx . channel ( ) . write ( new PongWebSocketFrame ( frame . getBinaryData ( ) ) ) ; </a> 0
<a> return ; </a> 0
<a> } else if ( ! ( frame instanceof TextWebSocketFrame ) ) { </a> 0
<a> throw new UnsupportedOperationException ( String . format ( "%s frame types not supported" , frame . getClass ( ) </a> 0
<a> . getName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> String request = ( ( TextWebSocketFrame ) frame ) . getText ( ) ; </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( String . format ( "Channel %s received %s" , ctx . channel ( ) . id ( ) , request ) ) ; </a> 0
<a> } </a> 1
<a> ctx . channel ( ) . write ( new TextWebSocketFrame ( request . toUpperCase ( ) ) ) ; </a> 0
<a> } </a> 0
<a> private static void sendHttpResponse ( ChannelHandlerContext ctx , HttpRequest req , HttpResponse res ) { </a> 1
<a> if ( res . getStatus ( ) . getCode ( ) != 200 ) { </a> 0
<a> res . setContent ( Unpooled . copiedBuffer ( res . getStatus ( ) . toString ( ) , CharsetUtil . UTF_8 ) ) ; </a> 1
<a> setContentLength ( res , res . getContent ( ) . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> ChannelFuture f = ctx . channel ( ) . write ( res ) ; </a> 0
<a> if ( ! isKeepAlive ( req ) || res . getStatus ( ) . getCode ( ) != 200 ) { </a> 0
<a> f . addListener ( ChannelFutureListener . CLOSE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> cause . printStackTrace ( ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> private static String getWebSocketLocation ( HttpRequest req ) { </a> 1
<a> return "ws://" + req . getHeader ( HttpHeaders . Names . HOST ) + WEBSOCKET_PATH ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . server ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public final class WebSocketServerIndexPage { </a> 0
<a> private static final String NEWLINE = "\r\n" ; </a> 0
<a> public static ByteBuf getContent ( String webSocketLocation ) { </a> 0
<a> return Unpooled . copiedBuffer ( </a> 0
<a> "<html><head><title>Web Socket Test</title></head>" + NEWLINE + </a> 0
<a> "<body>" + NEWLINE + </a> 0
<a> "<script type=\"text/javascript\">" + NEWLINE + </a> 0
<a> "var socket;" + NEWLINE + </a> 0
<a> "if (!window.WebSocket) {" + NEWLINE + </a> 0
<a> " window.WebSocket = window.MozWebSocket;" + NEWLINE + </a> 0
<a> "}" + NEWLINE + </a> 0
<a> "if (window.WebSocket) {" + NEWLINE + </a> 0
<a> " socket = new WebSocket(\"" + webSocketLocation + "\");" + NEWLINE + </a> 0
<a> " socket.onmessage = function(event) {" + NEWLINE + </a> 0
<a> " var ta = document.getElementById('responseText');" + NEWLINE + </a> 0
<a> " ta.value = ta.value + '\\n' + event.data" + NEWLINE + </a> 0
<a> " };" + NEWLINE + </a> 0
<a> " socket.onopen = function(event) {" + NEWLINE + </a> 0
<a> " var ta = document.getElementById('responseText');" + NEWLINE + </a> 0
<a> " ta.value = \"Web Socket opened!\";" + NEWLINE + </a> 0
<a> " };" + NEWLINE + </a> 0
<a> " socket.onclose = function(event) {" + NEWLINE + </a> 0
<a> " var ta = document.getElementById('responseText');" + NEWLINE + </a> 0
<a> " ta.value = ta.value + \"Web Socket closed\"; " + NEWLINE + </a> 0
<a> " };" + NEWLINE + </a> 0
<a> "} else {" + NEWLINE + </a> 0
<a> " alert(\"Your browser does not support Web Socket.\");" + NEWLINE + </a> 0
<a> "}" + NEWLINE + </a> 0
<a> NEWLINE + </a> 0
<a> "function send(message) {" + NEWLINE + </a> 0
<a> " if (!window.WebSocket) { return; }" + NEWLINE + </a> 0
<a> " if (socket.readyState == WebSocket.OPEN) {" + NEWLINE + </a> 0
<a> " socket.send(message);" + NEWLINE + </a> 0
<a> " } else {" + NEWLINE + </a> 0
<a> " alert(\"The socket is not open.\");" + NEWLINE + </a> 0
<a> " }" + NEWLINE + </a> 0
<a> "}" + NEWLINE + </a> 0
<a> "</script>" + NEWLINE + </a> 0
<a> "<form onsubmit=\"return false;\">" + NEWLINE + </a> 0
<a> "<input type=\"text\" name=\"message\" value=\"Hello, World!\"/>" + </a> 0
<a> "<input type=\"button\" value=\"Send Web Socket Data\"" + NEWLINE + </a> 0
<a> " onclick=\"send(this.form.message.value)\" />" + NEWLINE + </a> 0
<a> "<h3>Output</h3>" + NEWLINE + </a> 0
<a> "<textarea id=\"responseText\" style=\"width:500px;height:300px;\"></textarea>" + NEWLINE + </a> 0
<a> "</form>" + NEWLINE + </a> 0
<a> "</body>" + NEWLINE + </a> 0
<a> "</html>" + NEWLINE , CharsetUtil . US_ASCII ) ; </a> 0
<a> } </a> 0
<a> private WebSocketServerIndexPage ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . server ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . http . HttpChunkAggregator ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequestDecoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseEncoder ; </a> 1
<a> public class WebSocketServerInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 0
<a> ChannelPipeline pipeline = ch . pipeline ( ) ; </a> 0
<a> pipeline . addLast ( "decoder" , new HttpRequestDecoder ( ) ) ; </a> 1
<a> pipeline . addLast ( "aggregator" , new HttpChunkAggregator ( 65536 ) ) ; </a> 0
<a> pipeline . addLast ( "encoder" , new HttpResponseEncoder ( ) ) ; </a> 1
<a> pipeline . addLast ( "handler" , new WebSocketServerHandler ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . server ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . sslserver ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . Channel ; </a> 1
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 1
<a> public class WebSocketSslServer { </a> 0
<a> private final int port ; </a> 1
<a> public WebSocketSslServer ( int port ) { </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 1
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . localAddress ( port ) </a> 0
<a> . childHandler ( new WebSocketSslServerInitializer ( ) ) ; </a> 1
<a> Channel ch = b . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> System . out . println ( "Web socket server started at port " + port + '.' ) ; </a> 1
<a> System . out . println ( "Open your browser and navigate to https://localhost:" + port + '/' ) ; </a> 1
<a> ch . closeFuture ( ) . sync ( ) ; </a> 1
<a> } finally { </a> 1
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8443 ; </a> 1
<a> } </a> 1
<a> String keyStoreFilePath = System . getProperty ( "keystore.file.path" ) ; </a> 0
<a> if ( keyStoreFilePath == null || keyStoreFilePath . isEmpty ( ) ) { </a> 0
<a> System . out . println ( "ERROR: System property keystore.file.path not set. Exiting now!" ) ; </a> 0
<a> System . exit ( 1 ) ; </a> 0
<a> } </a> 0
<a> String keyStoreFilePassword = System . getProperty ( "keystore.file.password" ) ; </a> 0
<a> if ( keyStoreFilePassword == null || keyStoreFilePassword . isEmpty ( ) ) { </a> 0
<a> System . out . println ( "ERROR: System property keystore.file.password not set. Exiting now!" ) ; </a> 0
<a> System . exit ( 1 ) ; </a> 0
<a> } </a> 0
<a> new WebSocketSslServer ( port ) . run ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . sslserver ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 1
<a> import io . netty . channel . ChannelPipeline ; </a> 1
<a> import io . netty . channel . socket . SocketChannel ; </a> 1
<a> import io . netty . handler . codec . http . HttpChunkAggregator ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequestDecoder ; </a> 1
<a> import io . netty . handler . codec . http . HttpResponseEncoder ; </a> 1
<a> import io . netty . handler . ssl . SslHandler ; </a> 1
<a> import javax . net . ssl . SSLEngine ; </a> 1
<a> public class WebSocketSslServerInitializer extends ChannelInitializer < SocketChannel > { </a> 1
<a> @ Override </a> 1
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 1
<a> ChannelPipeline pipeline = ch . pipeline ( ) ; </a> 1
<a> SSLEngine engine = WebSocketSslServerSslContext . getInstance ( ) . getServerContext ( ) . createSSLEngine ( ) ; </a> 0
<a> engine . setUseClientMode ( false ) ; </a> 1
<a> pipeline . addLast ( "ssl" , new SslHandler ( engine ) ) ; </a> 1
<a> pipeline . addLast ( "decoder" , new HttpRequestDecoder ( ) ) ; </a> 1
<a> pipeline . addLast ( "aggregator" , new HttpChunkAggregator ( 65536 ) ) ; </a> 0
<a> pipeline . addLast ( "encoder" , new HttpResponseEncoder ( ) ) ; </a> 0
<a> pipeline . addLast ( "handler" , new WebSocketSslServerHandler ( ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . sslserver ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . io . FileInputStream ; </a> 0
<a> import java . security . KeyStore ; </a> 0
<a> import java . security . Security ; </a> 0
<a> import javax . net . ssl . KeyManagerFactory ; </a> 0
<a> import javax . net . ssl . SSLContext ; </a> 0
<a> public final class WebSocketSslServerSslContext { </a> 1
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocketSslServerSslContext . class ) ; </a> 0
<a> private static final String PROTOCOL = "TLS" ; </a> 0
<a> private SSLContext _serverContext ; </a> 0
<a> public static WebSocketSslServerSslContext getInstance ( ) { </a> 0
<a> return SingletonHolder . INSTANCE ; </a> 0
<a> } </a> 0
<a> private static class SingletonHolder { </a> 0
<a> public static final WebSocketSslServerSslContext INSTANCE = new WebSocketSslServerSslContext ( ) ; </a> 0
<a> } </a> 0
<a> private WebSocketSslServerSslContext ( ) { </a> 0
<a> try { </a> 0
<a> String algorithm = Security . getProperty ( "ssl.KeyManagerFactory.algorithm" ) ; </a> 0
<a> if ( algorithm == null ) { </a> 0
<a> algorithm = "SunX509" ; </a> 0
<a> } </a> 0
<a> SSLContext serverContext ; </a> 0
<a> try { </a> 0
<a> String keyStoreFilePath = System . getProperty ( "keystore.file.path" ) ; </a> 0
<a> String keyStoreFilePassword = System . getProperty ( "keystore.file.password" ) ; </a> 0
<a> KeyStore ks = KeyStore . getInstance ( "JKS" ) ; </a> 0
<a> FileInputStream fin = new FileInputStream ( keyStoreFilePath ) ; </a> 0
<a> ks . load ( fin , keyStoreFilePassword . toCharArray ( ) ) ; </a> 0
<a> KeyManagerFactory kmf = KeyManagerFactory . getInstance ( algorithm ) ; </a> 0
<a> kmf . init ( ks , keyStoreFilePassword . toCharArray ( ) ) ; </a> 0
<a> serverContext = SSLContext . getInstance ( PROTOCOL ) ; </a> 0
<a> serverContext . init ( kmf . getKeyManagers ( ) , null , null ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new Error ( "Failed to initialize the server-side SSLContext" , e ) ; </a> 0
<a> } </a> 0
<a> _serverContext = serverContext ; </a> 0
<a> } catch ( Exception ex ) { </a> 0
<a> if ( logger . isErrorEnabled ( ) ) { </a> 0
<a> logger . error ( "Error initializing SslContextManager. " + ex . getMessage ( ) , ex ) ; </a> 0
<a> } </a> 0
<a> System . exit ( 1 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public SSLContext getServerContext ( ) { </a> 0
<a> return _serverContext ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . http . websocketx . sslserver ; </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . localecho ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . local . LocalAddress ; </a> 0
<a> import io . netty . channel . local . LocalChannel ; </a> 0
<a> import io . netty . channel . local . LocalEventLoopGroup ; </a> 1
<a> import io . netty . channel . local . LocalServerChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . handler . logging . LogLevel ; </a> 0
<a> import io . netty . handler . logging . LoggingHandler ; </a> 0
<a> import java . io . BufferedReader ; </a> 0
<a> import java . io . InputStreamReader ; </a> 0
<a> public class LocalEcho { </a> 1
<a> private final String port ; </a> 1
<a> public LocalEcho ( String port ) { </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> final LocalAddress addr = new LocalAddress ( port ) ; </a> 1
<a> Bootstrap cb = new Bootstrap ( ) ; </a> 0
<a> ServerBootstrap sb = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> sb . group ( new LocalEventLoopGroup ( ) ) </a> 0
<a> . channel ( new LocalServerChannel ( ) ) </a> 0
<a> . localAddress ( addr ) </a> 0
<a> . handler ( new ChannelInitializer < LocalServerChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( LocalServerChannel ch ) throws Exception { </a> 0
<a> ch . pipeline ( ) . addLast ( new LoggingHandler ( LogLevel . INFO ) ) ; </a> 0
<a> } </a> 0
<a> } ) </a> 0
<a> . childHandler ( new ChannelInitializer < LocalChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( LocalChannel ch ) throws Exception { </a> 0
<a> ch . pipeline ( ) . addLast ( </a> 0
<a> new LoggingHandler ( LogLevel . INFO ) , </a> 0
<a> new LocalEchoServerHandler ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> cb . group ( new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new LocalChannel ( ) ) </a> 0
<a> . remoteAddress ( addr ) </a> 0
<a> . handler ( new ChannelInitializer < LocalChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( LocalChannel ch ) throws Exception { </a> 0
<a> ch . pipeline ( ) . addLast ( </a> 0
<a> new LoggingHandler ( LogLevel . INFO ) , </a> 0
<a> new LocalEchoClientHandler ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> sb . bind ( ) . sync ( ) ; </a> 0
<a> Channel ch = cb . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> System . out . println ( "Enter text (quit to end)" ) ; </a> 0
<a> ChannelFuture lastWriteFuture = null ; </a> 0
<a> BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> String line = in . readLine ( ) ; </a> 0
<a> if ( line == null || "quit" . equalsIgnoreCase ( line ) ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> lastWriteFuture = ch . write ( line ) ; </a> 0
<a> } </a> 0
<a> if ( lastWriteFuture != null ) { </a> 0
<a> lastWriteFuture . awaitUninterruptibly ( ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> sb . shutdown ( ) ; </a> 0
<a> cb . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> new LocalEcho ( "1" ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . localecho ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> public class LocalEchoClientHandler extends ChannelInboundMessageHandlerAdapter < String > { </a> 1
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , String msg ) { </a> 1
<a> System . out . println ( msg ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) { </a> 0
<a> cause . printStackTrace ( ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . localecho ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> public class LocalEchoServerHandler extends ChannelInboundMessageHandlerAdapter < String > { </a> 1
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , String msg ) { </a> 1
<a> ctx . write ( msg ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) { </a> 0
<a> cause . printStackTrace ( ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . localtime ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioSocketChannel ; </a> 0
<a> import java . util . ArrayList ; </a> 1
<a> import java . util . Collection ; </a> 1
<a> import java . util . Iterator ; </a> 1
<a> import java . util . List ; </a> 0
<a> public class LocalTimeClient { </a> 0
<a> private final String host ; </a> 1
<a> private final int port ; </a> 1
<a> private final Collection < String > cities ; </a> 1
<a> public LocalTimeClient ( String host , int port , Collection < String > cities ) { </a> 0
<a> this . host = host ; </a> 1
<a> this . port = port ; </a> 1
<a> this . cities = new ArrayList < String > ( ) ; </a> 1
<a> this . cities . addAll ( cities ) ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> Bootstrap b = new Bootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioSocketChannel ( ) ) </a> 0
<a> . remoteAddress ( host , port ) </a> 0
<a> . handler ( new LocalTimeClientInitializer ( ) ) ; </a> 0
<a> Channel ch = b . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> LocalTimeClientHandler handler = </a> 0
<a> ch . pipeline ( ) . get ( LocalTimeClientHandler . class ) ; </a> 0
<a> List < String > response = handler . getLocalTimes ( cities ) ; </a> 1
<a> ch . close ( ) ; </a> 0
<a> Iterator < String > i1 = cities . iterator ( ) ; </a> 1
<a> Iterator < String > i2 = response . iterator ( ) ; </a> 1
<a> while ( i1 . hasNext ( ) ) { </a> 1
<a> System . out . format ( "%28s: %s%n" , i1 . next ( ) , i2 . next ( ) ) ; </a> 1
<a> } </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> if ( args . length < 3 ) { </a> 0
<a> printUsage ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> String host = args [ 0 ] ; </a> 0
<a> int port = Integer . parseInt ( args [ 1 ] ) ; </a> 0
<a> Collection < String > cities = parseCities ( args , 2 ) ; </a> 0
<a> if ( cities == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> new LocalTimeClient ( host , port , cities ) . run ( ) ; </a> 0
<a> } </a> 1
<a> private static void printUsage ( ) { </a> 1
<a> System . err . println ( </a> 1
<a> "Usage: " + LocalTimeClient . class . getSimpleName ( ) + </a> 0
<a> " <host> <port> <continent/city_name> ..." ) ; </a> 1
<a> System . err . println ( </a> 1
<a> "Example: " + LocalTimeClient . class . getSimpleName ( ) + </a> 0
<a> " localhost 8080 America/New_York Asia/Seoul" ) ; </a> 1
<a> } </a> 1
<a> private static List < String > parseCities ( String [ ] args , int offset ) { </a> 1
<a> List < String > cities = new ArrayList < String > ( ) ; </a> 1
<a> for ( int i = offset ; i < args . length ; i ++ ) { </a> 1
<a> if ( ! args [ i ] . matches ( "^[_A-Za-z]+/[_A-Za-z]+$" ) ) { </a> 0
<a> System . err . println ( "Syntax error: '" + args [ i ] + "'" ) ; </a> 0
<a> printUsage ( ) ; </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> cities . add ( args [ i ] . trim ( ) ) ; </a> 1
<a> } </a> 1
<a> return cities ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . localtime ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . example . localtime . LocalTimeProtocol . Continent ; </a> 0
<a> import io . netty . example . localtime . LocalTimeProtocol . LocalTime ; </a> 0
<a> import io . netty . example . localtime . LocalTimeProtocol . LocalTimes ; </a> 0
<a> import io . netty . example . localtime . LocalTimeProtocol . Location ; </a> 0
<a> import io . netty . example . localtime . LocalTimeProtocol . Locations ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . Formatter ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . concurrent . BlockingQueue ; </a> 0
<a> import java . util . concurrent . LinkedBlockingQueue ; </a> 0
<a> import java . util . logging . Level ; </a> 1
<a> import java . util . logging . Logger ; </a> 1
<a> public class LocalTimeClientHandler extends ChannelInboundMessageHandlerAdapter < LocalTimes > { </a> 0
<a> private static final Logger logger = Logger . getLogger ( </a> 1
<a> LocalTimeClientHandler . class . getName ( ) ) ; </a> 0
<a> private volatile Channel channel ; </a> 0
<a> private final BlockingQueue < LocalTimes > answer = new LinkedBlockingQueue < LocalTimes > ( ) ; </a> 0
<a> public List < String > getLocalTimes ( Collection < String > cities ) { </a> 0
<a> Locations . Builder builder = Locations . newBuilder ( ) ; </a> 0
<a> for ( String c : cities ) { </a> 0
<a> String [ ] components = c . split ( "/" ) ; </a> 0
<a> builder . addLocation ( Location . newBuilder ( ) . </a> 0
<a> setContinent ( Continent . valueOf ( components [ 0 ] . toUpperCase ( ) ) ) . </a> 0
<a> setCity ( components [ 1 ] ) . build ( ) ) ; </a> 0
<a> } </a> 0
<a> channel . write ( builder . build ( ) ) ; </a> 1
<a> LocalTimes localTimes ; </a> 0
<a> boolean interrupted = false ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> try { </a> 0
<a> localTimes = answer . take ( ) ; </a> 0
<a> break ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 1
<a> interrupted = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( interrupted ) { </a> 0
<a> Thread . currentThread ( ) . interrupt ( ) ; </a> 0
<a> } </a> 0
<a> List < String > result = new ArrayList < String > ( ) ; </a> 0
<a> for ( LocalTime lt : localTimes . getLocalTimeList ( ) ) { </a> 0
<a> result . add ( </a> 0
<a> new Formatter ( ) . format ( </a> 0
<a> "%4d-%02d-%02d %02d:%02d:%02d %s" , </a> 0
<a> lt . getYear ( ) , </a> 0
<a> lt . getMonth ( ) , </a> 0
<a> lt . getDayOfMonth ( ) , </a> 0
<a> lt . getHour ( ) , </a> 0
<a> lt . getMinute ( ) , </a> 0
<a> lt . getSecond ( ) , </a> 0
<a> lt . getDayOfWeek ( ) . name ( ) ) . toString ( ) ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelRegistered ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> channel = ctx . channel ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , LocalTimes msg ) throws Exception { </a> 1
<a> answer . add ( msg ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> logger . log ( </a> 1
<a> Level . WARNING , </a> 1
<a> "Unexpected exception from downstream." , cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . localtime ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . protobuf . ProtobufDecoder ; </a> 0
<a> import io . netty . handler . codec . protobuf . ProtobufEncoder ; </a> 0
<a> import io . netty . handler . codec . protobuf . ProtobufVarint32FrameDecoder ; </a> 0
<a> import io . netty . handler . codec . protobuf . ProtobufVarint32LengthFieldPrepender ; </a> 0
<a> public class LocalTimeClientInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 1
<a> ChannelPipeline p = ch . pipeline ( ) ; </a> 0
<a> p . addLast ( "frameDecoder" , new ProtobufVarint32FrameDecoder ( ) ) ; </a> 1
<a> p . addLast ( "protobufDecoder" , new ProtobufDecoder ( LocalTimeProtocol . LocalTimes . getDefaultInstance ( ) ) ) ; </a> 0
<a> p . addLast ( "frameEncoder" , new ProtobufVarint32LengthFieldPrepender ( ) ) ; </a> 1
<a> p . addLast ( "protobufEncoder" , new ProtobufEncoder ( ) ) ; </a> 1
<a> p . addLast ( "handler" , new LocalTimeClientHandler ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . localtime ; </a> 0
<a> @ SuppressWarnings ( "all" ) </a> 0
<a> public final class LocalTimeProtocol { </a> 0
<a> private LocalTimeProtocol ( ) { } </a> 0
<a> public static void registerAllExtensions ( </a> 0
<a> com . google . protobuf . ExtensionRegistry registry ) { </a> 0
<a> } </a> 0
<a> public enum Continent </a> 0
<a> implements com . google . protobuf . ProtocolMessageEnum { </a> 0
<a> AFRICA ( 0 , 0 ) , </a> 0
<a> AMERICA ( 1 , 1 ) , </a> 0
<a> ANTARCTICA ( 2 , 2 ) , </a> 0
<a> ARCTIC ( 3 , 3 ) , </a> 0
<a> ASIA ( 4 , 4 ) , </a> 0
<a> ATLANTIC ( 5 , 5 ) , </a> 0
<a> AUSTRALIA ( 6 , 6 ) , </a> 0
<a> EUROPE ( 7 , 7 ) , </a> 0
<a> INDIAN ( 8 , 8 ) , </a> 0
<a> MIDEAST ( 9 , 9 ) , </a> 0
<a> PACIFIC ( 10 , 10 ) , </a> 0
<a> ; </a> 0
<a> public static final int AFRICA_VALUE = 0 ; </a> 0
<a> public static final int AMERICA_VALUE = 1 ; </a> 0
<a> public static final int ANTARCTICA_VALUE = 2 ; </a> 0
<a> public static final int ARCTIC_VALUE = 3 ; </a> 0
<a> public static final int ASIA_VALUE = 4 ; </a> 0
<a> public static final int ATLANTIC_VALUE = 5 ; </a> 0
<a> public static final int AUSTRALIA_VALUE = 6 ; </a> 0
<a> public static final int EUROPE_VALUE = 7 ; </a> 0
<a> public static final int INDIAN_VALUE = 8 ; </a> 0
<a> public static final int MIDEAST_VALUE = 9 ; </a> 0
<a> public static final int PACIFIC_VALUE = 10 ; </a> 0
<a> public final int getNumber ( ) { return value ; } </a> 0
<a> public static Continent valueOf ( int value ) { </a> 0
<a> switch ( value ) { </a> 0
<a> case 0 : return AFRICA ; </a> 0
<a> case 1 : return AMERICA ; </a> 0
<a> case 2 : return ANTARCTICA ; </a> 0
<a> case 3 : return ARCTIC ; </a> 0
<a> case 4 : return ASIA ; </a> 0
<a> case 5 : return ATLANTIC ; </a> 0
<a> case 6 : return AUSTRALIA ; </a> 0
<a> case 7 : return EUROPE ; </a> 0
<a> case 8 : return INDIAN ; </a> 0
<a> case 9 : return MIDEAST ; </a> 0
<a> case 10 : return PACIFIC ; </a> 0
<a> default : return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static com . google . protobuf . Internal . EnumLiteMap < Continent > </a> 0
<a> internalGetValueMap ( ) { </a> 0
<a> return internalValueMap ; </a> 0
<a> } </a> 0
<a> private static com . google . protobuf . Internal . EnumLiteMap < Continent > </a> 0
<a> internalValueMap = </a> 0
<a> new com . google . protobuf . Internal . EnumLiteMap < Continent > ( ) { </a> 0
<a> public Continent findValueByNumber ( int number ) { </a> 0
<a> return Continent . valueOf ( number ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> public final com . google . protobuf . Descriptors . EnumValueDescriptor </a> 0
<a> getValueDescriptor ( ) { </a> 0
<a> return getDescriptor ( ) . getValues ( ) . get ( index ) ; </a> 0
<a> } </a> 0
<a> public final com . google . protobuf . Descriptors . EnumDescriptor </a> 0
<a> getDescriptorForType ( ) { </a> 0
<a> return getDescriptor ( ) ; </a> 0
<a> } </a> 0
<a> public static final com . google . protobuf . Descriptors . EnumDescriptor </a> 0
<a> getDescriptor ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . getDescriptor ( ) . getEnumTypes ( ) . get ( 0 ) ; </a> 0
<a> } </a> 0
<a> private static final Continent [ ] VALUES = { </a> 0
<a> AFRICA , AMERICA , ANTARCTICA , ARCTIC , ASIA , ATLANTIC , AUSTRALIA , EUROPE , INDIAN , MIDEAST , PACIFIC , </a> 0
<a> } ; </a> 0
<a> public static Continent valueOf ( </a> 0
<a> com . google . protobuf . Descriptors . EnumValueDescriptor desc ) { </a> 0
<a> if ( desc . getType ( ) != getDescriptor ( ) ) { </a> 0
<a> throw new java . lang . IllegalArgumentException ( </a> 0
<a> "EnumValueDescriptor is not for this type." ) ; </a> 0
<a> } </a> 0
<a> return VALUES [ desc . getIndex ( ) ] ; </a> 0
<a> } </a> 0
<a> private final int index ; </a> 0
<a> private final int value ; </a> 0
<a> private Continent ( int index , int value ) { </a> 0
<a> this . index = index ; </a> 0
<a> this . value = value ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public enum DayOfWeek </a> 0
<a> implements com . google . protobuf . ProtocolMessageEnum { </a> 0
<a> SUNDAY ( 0 , 1 ) , </a> 0
<a> MONDAY ( 1 , 2 ) , </a> 0
<a> TUESDAY ( 2 , 3 ) , </a> 0
<a> WEDNESDAY ( 3 , 4 ) , </a> 0
<a> THURSDAY ( 4 , 5 ) , </a> 0
<a> FRIDAY ( 5 , 6 ) , </a> 0
<a> SATURDAY ( 6 , 7 ) , </a> 0
<a> ; </a> 0
<a> public static final int SUNDAY_VALUE = 1 ; </a> 0
<a> public static final int MONDAY_VALUE = 2 ; </a> 0
<a> public static final int TUESDAY_VALUE = 3 ; </a> 0
<a> public static final int WEDNESDAY_VALUE = 4 ; </a> 0
<a> public static final int THURSDAY_VALUE = 5 ; </a> 0
<a> public static final int FRIDAY_VALUE = 6 ; </a> 0
<a> public static final int SATURDAY_VALUE = 7 ; </a> 0
<a> public final int getNumber ( ) { return value ; } </a> 0
<a> public static DayOfWeek valueOf ( int value ) { </a> 0
<a> switch ( value ) { </a> 0
<a> case 1 : return SUNDAY ; </a> 0
<a> case 2 : return MONDAY ; </a> 0
<a> case 3 : return TUESDAY ; </a> 0
<a> case 4 : return WEDNESDAY ; </a> 0
<a> case 5 : return THURSDAY ; </a> 0
<a> case 6 : return FRIDAY ; </a> 0
<a> case 7 : return SATURDAY ; </a> 0
<a> default : return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static com . google . protobuf . Internal . EnumLiteMap < DayOfWeek > </a> 0
<a> internalGetValueMap ( ) { </a> 0
<a> return internalValueMap ; </a> 0
<a> } </a> 0
<a> private static com . google . protobuf . Internal . EnumLiteMap < DayOfWeek > </a> 0
<a> internalValueMap = </a> 0
<a> new com . google . protobuf . Internal . EnumLiteMap < DayOfWeek > ( ) { </a> 0
<a> public DayOfWeek findValueByNumber ( int number ) { </a> 0
<a> return DayOfWeek . valueOf ( number ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> public final com . google . protobuf . Descriptors . EnumValueDescriptor </a> 0
<a> getValueDescriptor ( ) { </a> 0
<a> return getDescriptor ( ) . getValues ( ) . get ( index ) ; </a> 0
<a> } </a> 0
<a> public final com . google . protobuf . Descriptors . EnumDescriptor </a> 0
<a> getDescriptorForType ( ) { </a> 0
<a> return getDescriptor ( ) ; </a> 0
<a> } </a> 0
<a> public static final com . google . protobuf . Descriptors . EnumDescriptor </a> 0
<a> getDescriptor ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . getDescriptor ( ) . getEnumTypes ( ) . get ( 1 ) ; </a> 0
<a> } </a> 0
<a> private static final DayOfWeek [ ] VALUES = { </a> 0
<a> SUNDAY , MONDAY , TUESDAY , WEDNESDAY , THURSDAY , FRIDAY , SATURDAY , </a> 0
<a> } ; </a> 0
<a> public static DayOfWeek valueOf ( </a> 0
<a> com . google . protobuf . Descriptors . EnumValueDescriptor desc ) { </a> 0
<a> if ( desc . getType ( ) != getDescriptor ( ) ) { </a> 0
<a> throw new java . lang . IllegalArgumentException ( </a> 0
<a> "EnumValueDescriptor is not for this type." ) ; </a> 0
<a> } </a> 0
<a> return VALUES [ desc . getIndex ( ) ] ; </a> 0
<a> } </a> 0
<a> private final int index ; </a> 0
<a> private final int value ; </a> 0
<a> private DayOfWeek ( int index , int value ) { </a> 0
<a> this . index = index ; </a> 0
<a> this . value = value ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public interface LocationOrBuilder </a> 0
<a> extends com . google . protobuf . MessageOrBuilder { </a> 0
<a> boolean hasContinent ( ) ; </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Continent getContinent ( ) ; </a> 0
<a> boolean hasCity ( ) ; </a> 0
<a> String getCity ( ) ; </a> 0
<a> } </a> 0
<a> public static final class Location extends </a> 0
<a> com . google . protobuf . GeneratedMessage </a> 0
<a> implements LocationOrBuilder { </a> 0
<a> private Location ( Builder builder ) { </a> 0
<a> super ( builder ) ; </a> 0
<a> } </a> 0
<a> private Location ( boolean noInit ) { } </a> 0
<a> private static final Location defaultInstance ; </a> 0
<a> public static Location getDefaultInstance ( ) { </a> 0
<a> return defaultInstance ; </a> 0
<a> } </a> 0
<a> public Location getDefaultInstanceForType ( ) { </a> 0
<a> return defaultInstance ; </a> 0
<a> } </a> 0
<a> public static final com . google . protobuf . Descriptors . Descriptor </a> 0
<a> getDescriptor ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_Location_descriptor ; </a> 0
<a> } </a> 0
<a> protected com . google . protobuf . GeneratedMessage . FieldAccessorTable </a> 0
<a> internalGetFieldAccessorTable ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_Location_fieldAccessorTable ; </a> 0
<a> } </a> 0
<a> private int bitField0_ ; </a> 0
<a> public static final int CONTINENT_FIELD_NUMBER = 1 ; </a> 0
<a> private io . netty . example . localtime . LocalTimeProtocol . Continent continent_ ; </a> 0
<a> public boolean hasContinent ( ) { </a> 0
<a> return ( bitField0_ & 0x00000001 ) == 0x00000001 ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Continent getContinent ( ) { </a> 0
<a> return continent_ ; </a> 0
<a> } </a> 0
<a> public static final int CITY_FIELD_NUMBER = 2 ; </a> 0
<a> private java . lang . Object city_ ; </a> 0
<a> public boolean hasCity ( ) { </a> 0
<a> return ( bitField0_ & 0x00000002 ) == 0x00000002 ; </a> 0
<a> } </a> 0
<a> public String getCity ( ) { </a> 0
<a> java . lang . Object ref = city_ ; </a> 0
<a> if ( ref instanceof String ) { </a> 0
<a> return ( String ) ref ; </a> 0
<a> } else { </a> 0
<a> com . google . protobuf . ByteString bs = </a> 0
<a> ( com . google . protobuf . ByteString ) ref ; </a> 0
<a> String s = bs . toStringUtf8 ( ) ; </a> 0
<a> if ( com . google . protobuf . Internal . isValidUtf8 ( bs ) ) { </a> 0
<a> city_ = s ; </a> 0
<a> } </a> 0
<a> return s ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private com . google . protobuf . ByteString getCityBytes ( ) { </a> 0
<a> java . lang . Object ref = city_ ; </a> 0
<a> if ( ref instanceof String ) { </a> 0
<a> com . google . protobuf . ByteString b = </a> 0
<a> com . google . protobuf . ByteString . copyFromUtf8 ( ( String ) ref ) ; </a> 0
<a> city_ = b ; </a> 0
<a> return b ; </a> 0
<a> } else { </a> 0
<a> return ( com . google . protobuf . ByteString ) ref ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void initFields ( ) { </a> 0
<a> continent_ = io . netty . example . localtime . LocalTimeProtocol . Continent . AFRICA ; </a> 0
<a> city_ = "" ; </a> 0
<a> } </a> 0
<a> private byte memoizedIsInitialized = - 1 ; </a> 0
<a> public final boolean isInitialized ( ) { </a> 0
<a> byte isInitialized = memoizedIsInitialized ; </a> 0
<a> if ( isInitialized != - 1 ) { </a> 0
<a> return isInitialized == 1 ; </a> 0
<a> } </a> 0
<a> if ( ! hasContinent ( ) ) { </a> 0
<a> memoizedIsInitialized = 0 ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasCity ( ) ) { </a> 0
<a> memoizedIsInitialized = 0 ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> memoizedIsInitialized = 1 ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public void writeTo ( com . google . protobuf . CodedOutputStream output ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> getSerializedSize ( ) ; </a> 0
<a> if ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) { </a> 0
<a> output . writeEnum ( 1 , continent_ . getNumber ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000002 ) == 0x00000002 ) { </a> 0
<a> output . writeBytes ( 2 , getCityBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> getUnknownFields ( ) . writeTo ( output ) ; </a> 0
<a> } </a> 0
<a> private int memoizedSerializedSize = - 1 ; </a> 0
<a> public int getSerializedSize ( ) { </a> 0
<a> int size = memoizedSerializedSize ; </a> 0
<a> if ( size != - 1 ) { </a> 0
<a> return size ; </a> 0
<a> } </a> 0
<a> size = 0 ; </a> 0
<a> if ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) { </a> 0
<a> size += com . google . protobuf . CodedOutputStream </a> 0
<a> . computeEnumSize ( 1 , continent_ . getNumber ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000002 ) == 0x00000002 ) { </a> 0
<a> size += com . google . protobuf . CodedOutputStream </a> 0
<a> . computeBytesSize ( 2 , getCityBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> size += getUnknownFields ( ) . getSerializedSize ( ) ; </a> 0
<a> memoizedSerializedSize = size ; </a> 0
<a> return size ; </a> 0
<a> } </a> 0
<a> private static final long serialVersionUID = 0L ; </a> 0
<a> @ java . lang . Override </a> 0
<a> protected java . lang . Object writeReplace ( ) </a> 0
<a> throws java . io . ObjectStreamException { </a> 0
<a> return super . writeReplace ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Location parseFrom ( </a> 0
<a> com . google . protobuf . ByteString data ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Location parseFrom ( </a> 0
<a> com . google . protobuf . ByteString data , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Location parseFrom ( byte [ ] data ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Location parseFrom ( </a> 0
<a> byte [ ] data , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Location parseFrom ( java . io . InputStream input ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Location parseFrom ( </a> 0
<a> java . io . InputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Location parseDelimitedFrom ( java . io . InputStream input ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> Builder builder = newBuilder ( ) ; </a> 0
<a> if ( builder . mergeDelimitedFrom ( input ) ) { </a> 0
<a> return builder . buildParsed ( ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Location parseDelimitedFrom ( </a> 0
<a> java . io . InputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> Builder builder = newBuilder ( ) ; </a> 0
<a> if ( builder . mergeDelimitedFrom ( input , extensionRegistry ) ) { </a> 0
<a> return builder . buildParsed ( ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Location parseFrom ( </a> 0
<a> com . google . protobuf . CodedInputStream input ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Location parseFrom ( </a> 0
<a> com . google . protobuf . CodedInputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static Builder newBuilder ( ) { return Builder . create ( ) ; } </a> 0
<a> public Builder newBuilderForType ( ) { return newBuilder ( ) ; } </a> 0
<a> public static Builder newBuilder ( io . netty . example . localtime . LocalTimeProtocol . Location prototype ) { </a> 0
<a> return newBuilder ( ) . mergeFrom ( prototype ) ; </a> 0
<a> } </a> 0
<a> public Builder toBuilder ( ) { return newBuilder ( this ) ; } </a> 0
<a> @ java . lang . Override </a> 0
<a> protected Builder newBuilderForType ( </a> 0
<a> com . google . protobuf . GeneratedMessage . BuilderParent parent ) { </a> 0
<a> Builder builder = new Builder ( parent ) ; </a> 0
<a> return builder ; </a> 0
<a> } </a> 0
<a> public static final class Builder extends </a> 0
<a> com . google . protobuf . GeneratedMessage . Builder < Builder > </a> 0
<a> implements io . netty . example . localtime . LocalTimeProtocol . LocationOrBuilder { </a> 0
<a> public static final com . google . protobuf . Descriptors . Descriptor </a> 0
<a> getDescriptor ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_Location_descriptor ; </a> 0
<a> } </a> 0
<a> protected com . google . protobuf . GeneratedMessage . FieldAccessorTable </a> 0
<a> internalGetFieldAccessorTable ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_Location_fieldAccessorTable ; </a> 0
<a> } </a> 0
<a> private Builder ( ) { </a> 0
<a> maybeForceBuilderInitialization ( ) ; </a> 0
<a> } </a> 0
<a> private Builder ( BuilderParent parent ) { </a> 0
<a> super ( parent ) ; </a> 0
<a> maybeForceBuilderInitialization ( ) ; </a> 0
<a> } </a> 0
<a> private void maybeForceBuilderInitialization ( ) { </a> 0
<a> if ( com . google . protobuf . GeneratedMessage . alwaysUseFieldBuilders ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static Builder create ( ) { </a> 0
<a> return new Builder ( ) ; </a> 0
<a> } </a> 0
<a> public Builder clear ( ) { </a> 0
<a> super . clear ( ) ; </a> 0
<a> continent_ = io . netty . example . localtime . LocalTimeProtocol . Continent . AFRICA ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> city_ = "" ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000002 ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clone ( ) { </a> 0
<a> return create ( ) . mergeFrom ( buildPartial ( ) ) ; </a> 0
<a> } </a> 0
<a> public com . google . protobuf . Descriptors . Descriptor </a> 0
<a> getDescriptorForType ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . Location . getDescriptor ( ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Location getDefaultInstanceForType ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . Location . getDefaultInstance ( ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Location build ( ) { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Location result = buildPartial ( ) ; </a> 0
<a> if ( ! result . isInitialized ( ) ) { </a> 0
<a> throw newUninitializedMessageException ( result ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> private io . netty . example . localtime . LocalTimeProtocol . Location buildParsed ( ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Location result = buildPartial ( ) ; </a> 0
<a> if ( ! result . isInitialized ( ) ) { </a> 0
<a> throw newUninitializedMessageException ( </a> 0
<a> result ) . asInvalidProtocolBufferException ( ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Location buildPartial ( ) { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Location result = new io . netty . example . localtime . LocalTimeProtocol . Location ( this ) ; </a> 0
<a> int from_bitField0_ = bitField0_ ; </a> 0
<a> int to_bitField0_ = 0 ; </a> 0
<a> if ( ( from_bitField0_ & 0x00000001 ) == 0x00000001 ) { </a> 0
<a> to_bitField0_ |= 0x00000001 ; </a> 0
<a> } </a> 0
<a> result . continent_ = continent_ ; </a> 0
<a> if ( ( from_bitField0_ & 0x00000002 ) == 0x00000002 ) { </a> 0
<a> to_bitField0_ |= 0x00000002 ; </a> 0
<a> } </a> 0
<a> result . city_ = city_ ; </a> 0
<a> result . bitField0_ = to_bitField0_ ; </a> 0
<a> onBuilt ( ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> public Builder mergeFrom ( com . google . protobuf . Message other ) { </a> 0
<a> if ( other instanceof io . netty . example . localtime . LocalTimeProtocol . Location ) { </a> 0
<a> return mergeFrom ( ( io . netty . example . localtime . LocalTimeProtocol . Location ) other ) ; </a> 0
<a> } else { </a> 0
<a> super . mergeFrom ( other ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public Builder mergeFrom ( io . netty . example . localtime . LocalTimeProtocol . Location other ) { </a> 0
<a> if ( other == io . netty . example . localtime . LocalTimeProtocol . Location . getDefaultInstance ( ) ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> if ( other . hasContinent ( ) ) { </a> 0
<a> setContinent ( other . getContinent ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( other . hasCity ( ) ) { </a> 0
<a> setCity ( other . getCity ( ) ) ; </a> 0
<a> } </a> 0
<a> mergeUnknownFields ( other . getUnknownFields ( ) ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public final boolean isInitialized ( ) { </a> 0
<a> if ( ! hasContinent ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasCity ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public Builder mergeFrom ( </a> 0
<a> com . google . protobuf . CodedInputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> com . google . protobuf . UnknownFieldSet . Builder unknownFields = </a> 0
<a> com . google . protobuf . UnknownFieldSet . newBuilder ( </a> 0
<a> getUnknownFields ( ) ) ; </a> 0
<a> while ( true ) { </a> 0
<a> int tag = input . readTag ( ) ; </a> 0
<a> switch ( tag ) { </a> 0
<a> case 0 : </a> 0
<a> setUnknownFields ( unknownFields . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> default : { </a> 0
<a> if ( ! parseUnknownField ( input , unknownFields , </a> 0
<a> extensionRegistry , tag ) ) { </a> 0
<a> setUnknownFields ( unknownFields . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 8 : { </a> 0
<a> int rawValue = input . readEnum ( ) ; </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Continent value = io . netty . example . localtime . LocalTimeProtocol . Continent . valueOf ( rawValue ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> unknownFields . mergeVarintField ( 1 , rawValue ) ; </a> 0
<a> } else { </a> 0
<a> bitField0_ |= 0x00000001 ; </a> 0
<a> continent_ = value ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 18 : { </a> 0
<a> bitField0_ |= 0x00000002 ; </a> 0
<a> city_ = input . readBytes ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private int bitField0_ ; </a> 0
<a> private io . netty . example . localtime . LocalTimeProtocol . Continent continent_ = io . netty . example . localtime . LocalTimeProtocol . Continent . AFRICA ; </a> 0
<a> public boolean hasContinent ( ) { </a> 0
<a> return ( bitField0_ & 0x00000001 ) == 0x00000001 ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Continent getContinent ( ) { </a> 0
<a> return continent_ ; </a> 0
<a> } </a> 0
<a> public Builder setContinent ( io . netty . example . localtime . LocalTimeProtocol . Continent value ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( ) ; </a> 0
<a> } </a> 0
<a> bitField0_ |= 0x00000001 ; </a> 0
<a> continent_ = value ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clearContinent ( ) { </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> continent_ = io . netty . example . localtime . LocalTimeProtocol . Continent . AFRICA ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> private java . lang . Object city_ = "" ; </a> 0
<a> public boolean hasCity ( ) { </a> 0
<a> return ( bitField0_ & 0x00000002 ) == 0x00000002 ; </a> 0
<a> } </a> 0
<a> public String getCity ( ) { </a> 0
<a> java . lang . Object ref = city_ ; </a> 0
<a> if ( ! ( ref instanceof String ) ) { </a> 0
<a> String s = ( ( com . google . protobuf . ByteString ) ref ) . toStringUtf8 ( ) ; </a> 0
<a> city_ = s ; </a> 0
<a> return s ; </a> 0
<a> } else { </a> 0
<a> return ( String ) ref ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public Builder setCity ( String value ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( ) ; </a> 0
<a> } </a> 0
<a> bitField0_ |= 0x00000002 ; </a> 0
<a> city_ = value ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clearCity ( ) { </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000002 ; </a> 0
<a> city_ = getDefaultInstance ( ) . getCity ( ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> void setCity ( com . google . protobuf . ByteString value ) { </a> 0
<a> bitField0_ |= 0x00000002 ; </a> 0
<a> city_ = value ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static { </a> 0
<a> defaultInstance = new Location ( true ) ; </a> 0
<a> defaultInstance . initFields ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public interface LocationsOrBuilder </a> 0
<a> extends com . google . protobuf . MessageOrBuilder { </a> 0
<a> java . util . List < io . netty . example . localtime . LocalTimeProtocol . Location > </a> 0
<a> getLocationList ( ) ; </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Location getLocation ( int index ) ; </a> 0
<a> int getLocationCount ( ) ; </a> 0
<a> java . util . List < ? extends io . netty . example . localtime . LocalTimeProtocol . LocationOrBuilder > </a> 0
<a> getLocationOrBuilderList ( ) ; </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocationOrBuilder getLocationOrBuilder ( </a> 0
<a> int index ) ; </a> 0
<a> } </a> 0
<a> public static final class Locations extends </a> 0
<a> com . google . protobuf . GeneratedMessage </a> 0
<a> implements LocationsOrBuilder { </a> 0
<a> private Locations ( Builder builder ) { </a> 0
<a> super ( builder ) ; </a> 0
<a> } </a> 0
<a> private Locations ( boolean noInit ) { } </a> 0
<a> private static final Locations defaultInstance ; </a> 0
<a> public static Locations getDefaultInstance ( ) { </a> 0
<a> return defaultInstance ; </a> 0
<a> } </a> 0
<a> public Locations getDefaultInstanceForType ( ) { </a> 0
<a> return defaultInstance ; </a> 0
<a> } </a> 0
<a> public static final com . google . protobuf . Descriptors . Descriptor </a> 0
<a> getDescriptor ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_Locations_descriptor ; </a> 0
<a> } </a> 0
<a> protected com . google . protobuf . GeneratedMessage . FieldAccessorTable </a> 0
<a> internalGetFieldAccessorTable ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_Locations_fieldAccessorTable ; </a> 0
<a> } </a> 0
<a> public static final int LOCATION_FIELD_NUMBER = 1 ; </a> 0
<a> private java . util . List < io . netty . example . localtime . LocalTimeProtocol . Location > location_ ; </a> 0
<a> public java . util . List < io . netty . example . localtime . LocalTimeProtocol . Location > getLocationList ( ) { </a> 0
<a> return location_ ; </a> 0
<a> } </a> 0
<a> public java . util . List < ? extends io . netty . example . localtime . LocalTimeProtocol . LocationOrBuilder > </a> 0
<a> getLocationOrBuilderList ( ) { </a> 0
<a> return location_ ; </a> 0
<a> } </a> 0
<a> public int getLocationCount ( ) { </a> 0
<a> return location_ . size ( ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Location getLocation ( int index ) { </a> 0
<a> return location_ . get ( index ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocationOrBuilder getLocationOrBuilder ( </a> 0
<a> int index ) { </a> 0
<a> return location_ . get ( index ) ; </a> 0
<a> } </a> 0
<a> private void initFields ( ) { </a> 0
<a> location_ = java . util . Collections . emptyList ( ) ; </a> 0
<a> } </a> 0
<a> private byte memoizedIsInitialized = - 1 ; </a> 0
<a> public final boolean isInitialized ( ) { </a> 0
<a> byte isInitialized = memoizedIsInitialized ; </a> 0
<a> if ( isInitialized != - 1 ) { </a> 0
<a> return isInitialized == 1 ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < getLocationCount ( ) ; i ++ ) { </a> 0
<a> if ( ! getLocation ( i ) . isInitialized ( ) ) { </a> 0
<a> memoizedIsInitialized = 0 ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> memoizedIsInitialized = 1 ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public void writeTo ( com . google . protobuf . CodedOutputStream output ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> getSerializedSize ( ) ; </a> 0
<a> for ( int i = 0 ; i < location_ . size ( ) ; i ++ ) { </a> 0
<a> output . writeMessage ( 1 , location_ . get ( i ) ) ; </a> 0
<a> } </a> 0
<a> getUnknownFields ( ) . writeTo ( output ) ; </a> 0
<a> } </a> 0
<a> private int memoizedSerializedSize = - 1 ; </a> 0
<a> public int getSerializedSize ( ) { </a> 0
<a> int size = memoizedSerializedSize ; </a> 0
<a> if ( size != - 1 ) { </a> 0
<a> return size ; </a> 0
<a> } </a> 0
<a> size = 0 ; </a> 0
<a> for ( int i = 0 ; i < location_ . size ( ) ; i ++ ) { </a> 0
<a> size += com . google . protobuf . CodedOutputStream </a> 0
<a> . computeMessageSize ( 1 , location_ . get ( i ) ) ; </a> 0
<a> } </a> 0
<a> size += getUnknownFields ( ) . getSerializedSize ( ) ; </a> 0
<a> memoizedSerializedSize = size ; </a> 0
<a> return size ; </a> 0
<a> } </a> 0
<a> private static final long serialVersionUID = 0L ; </a> 0
<a> @ java . lang . Override </a> 0
<a> protected java . lang . Object writeReplace ( ) </a> 0
<a> throws java . io . ObjectStreamException { </a> 0
<a> return super . writeReplace ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Locations parseFrom ( </a> 0
<a> com . google . protobuf . ByteString data ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Locations parseFrom ( </a> 0
<a> com . google . protobuf . ByteString data , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Locations parseFrom ( byte [ ] data ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Locations parseFrom ( </a> 0
<a> byte [ ] data , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Locations parseFrom ( java . io . InputStream input ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Locations parseFrom ( </a> 0
<a> java . io . InputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Locations parseDelimitedFrom ( java . io . InputStream input ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> Builder builder = newBuilder ( ) ; </a> 0
<a> if ( builder . mergeDelimitedFrom ( input ) ) { </a> 0
<a> return builder . buildParsed ( ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Locations parseDelimitedFrom ( </a> 0
<a> java . io . InputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> Builder builder = newBuilder ( ) ; </a> 0
<a> if ( builder . mergeDelimitedFrom ( input , extensionRegistry ) ) { </a> 0
<a> return builder . buildParsed ( ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Locations parseFrom ( </a> 0
<a> com . google . protobuf . CodedInputStream input ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . Locations parseFrom ( </a> 0
<a> com . google . protobuf . CodedInputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static Builder newBuilder ( ) { return Builder . create ( ) ; } </a> 0
<a> public Builder newBuilderForType ( ) { return newBuilder ( ) ; } </a> 0
<a> public static Builder newBuilder ( io . netty . example . localtime . LocalTimeProtocol . Locations prototype ) { </a> 0
<a> return newBuilder ( ) . mergeFrom ( prototype ) ; </a> 0
<a> } </a> 0
<a> public Builder toBuilder ( ) { return newBuilder ( this ) ; } </a> 0
<a> @ java . lang . Override </a> 0
<a> protected Builder newBuilderForType ( </a> 0
<a> com . google . protobuf . GeneratedMessage . BuilderParent parent ) { </a> 0
<a> Builder builder = new Builder ( parent ) ; </a> 0
<a> return builder ; </a> 0
<a> } </a> 0
<a> public static final class Builder extends </a> 0
<a> com . google . protobuf . GeneratedMessage . Builder < Builder > </a> 0
<a> implements io . netty . example . localtime . LocalTimeProtocol . LocationsOrBuilder { </a> 0
<a> public static final com . google . protobuf . Descriptors . Descriptor </a> 0
<a> getDescriptor ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_Locations_descriptor ; </a> 0
<a> } </a> 0
<a> protected com . google . protobuf . GeneratedMessage . FieldAccessorTable </a> 0
<a> internalGetFieldAccessorTable ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_Locations_fieldAccessorTable ; </a> 0
<a> } </a> 0
<a> private Builder ( ) { </a> 0
<a> maybeForceBuilderInitialization ( ) ; </a> 0
<a> } </a> 0
<a> private Builder ( BuilderParent parent ) { </a> 0
<a> super ( parent ) ; </a> 0
<a> maybeForceBuilderInitialization ( ) ; </a> 0
<a> } </a> 0
<a> private void maybeForceBuilderInitialization ( ) { </a> 0
<a> if ( com . google . protobuf . GeneratedMessage . alwaysUseFieldBuilders ) { </a> 0
<a> getLocationFieldBuilder ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static Builder create ( ) { </a> 0
<a> return new Builder ( ) ; </a> 0
<a> } </a> 0
<a> public Builder clear ( ) { </a> 0
<a> super . clear ( ) ; </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> location_ = java . util . Collections . emptyList ( ) ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> } else { </a> 0
<a> locationBuilder_ . clear ( ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clone ( ) { </a> 0
<a> return create ( ) . mergeFrom ( buildPartial ( ) ) ; </a> 0
<a> } </a> 0
<a> public com . google . protobuf . Descriptors . Descriptor </a> 0
<a> getDescriptorForType ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . Locations . getDescriptor ( ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Locations getDefaultInstanceForType ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . Locations . getDefaultInstance ( ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Locations build ( ) { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Locations result = buildPartial ( ) ; </a> 0
<a> if ( ! result . isInitialized ( ) ) { </a> 0
<a> throw newUninitializedMessageException ( result ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> private io . netty . example . localtime . LocalTimeProtocol . Locations buildParsed ( ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Locations result = buildPartial ( ) ; </a> 0
<a> if ( ! result . isInitialized ( ) ) { </a> 0
<a> throw newUninitializedMessageException ( </a> 0
<a> result ) . asInvalidProtocolBufferException ( ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Locations buildPartial ( ) { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Locations result = new io . netty . example . localtime . LocalTimeProtocol . Locations ( this ) ; </a> 0
<a> int from_bitField0_ = bitField0_ ; </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> if ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) { </a> 0
<a> location_ = java . util . Collections . unmodifiableList ( location_ ) ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> } </a> 0
<a> result . location_ = location_ ; </a> 0
<a> } else { </a> 0
<a> result . location_ = locationBuilder_ . build ( ) ; </a> 0
<a> } </a> 0
<a> onBuilt ( ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> public Builder mergeFrom ( com . google . protobuf . Message other ) { </a> 0
<a> if ( other instanceof io . netty . example . localtime . LocalTimeProtocol . Locations ) { </a> 0
<a> return mergeFrom ( ( io . netty . example . localtime . LocalTimeProtocol . Locations ) other ) ; </a> 0
<a> } else { </a> 0
<a> super . mergeFrom ( other ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public Builder mergeFrom ( io . netty . example . localtime . LocalTimeProtocol . Locations other ) { </a> 0
<a> if ( other == io . netty . example . localtime . LocalTimeProtocol . Locations . getDefaultInstance ( ) ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> if ( ! other . location_ . isEmpty ( ) ) { </a> 0
<a> if ( location_ . isEmpty ( ) ) { </a> 0
<a> location_ = other . location_ ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> } else { </a> 0
<a> ensureLocationIsMutable ( ) ; </a> 0
<a> location_ . addAll ( other . location_ ) ; </a> 0
<a> } </a> 0
<a> onChanged ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( ! other . location_ . isEmpty ( ) ) { </a> 0
<a> if ( locationBuilder_ . isEmpty ( ) ) { </a> 0
<a> locationBuilder_ . dispose ( ) ; </a> 0
<a> locationBuilder_ = null ; </a> 0
<a> location_ = other . location_ ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> locationBuilder_ = </a> 0
<a> com . google . protobuf . GeneratedMessage . alwaysUseFieldBuilders ? </a> 0
<a> getLocationFieldBuilder ( ) : null ; </a> 0
<a> } else { </a> 0
<a> locationBuilder_ . addAllMessages ( other . location_ ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> mergeUnknownFields ( other . getUnknownFields ( ) ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public final boolean isInitialized ( ) { </a> 0
<a> for ( int i = 0 ; i < getLocationCount ( ) ; i ++ ) { </a> 0
<a> if ( ! getLocation ( i ) . isInitialized ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public Builder mergeFrom ( </a> 0
<a> com . google . protobuf . CodedInputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> com . google . protobuf . UnknownFieldSet . Builder unknownFields = </a> 0
<a> com . google . protobuf . UnknownFieldSet . newBuilder ( </a> 0
<a> getUnknownFields ( ) ) ; </a> 0
<a> while ( true ) { </a> 0
<a> int tag = input . readTag ( ) ; </a> 0
<a> switch ( tag ) { </a> 0
<a> case 0 : </a> 0
<a> setUnknownFields ( unknownFields . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> default : { </a> 0
<a> if ( ! parseUnknownField ( input , unknownFields , </a> 0
<a> extensionRegistry , tag ) ) { </a> 0
<a> setUnknownFields ( unknownFields . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 10 : { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Location . Builder subBuilder = io . netty . example . localtime . LocalTimeProtocol . Location . newBuilder ( ) ; </a> 0
<a> input . readMessage ( subBuilder , extensionRegistry ) ; </a> 0
<a> addLocation ( subBuilder . buildPartial ( ) ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private int bitField0_ ; </a> 0
<a> private java . util . List < io . netty . example . localtime . LocalTimeProtocol . Location > location_ = </a> 0
<a> java . util . Collections . emptyList ( ) ; </a> 0
<a> private void ensureLocationIsMutable ( ) { </a> 0
<a> if ( ! ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) ) { </a> 0
<a> location_ = new java . util . ArrayList < io . netty . example . localtime . LocalTimeProtocol . Location > ( location_ ) ; </a> 0
<a> bitField0_ |= 0x00000001 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private com . google . protobuf . RepeatedFieldBuilder < </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Location , io . netty . example . localtime . LocalTimeProtocol . Location . Builder , io . netty . example . localtime . LocalTimeProtocol . LocationOrBuilder > locationBuilder_ ; </a> 0
<a> public java . util . List < io . netty . example . localtime . LocalTimeProtocol . Location > getLocationList ( ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> return java . util . Collections . unmodifiableList ( location_ ) ; </a> 0
<a> } else { </a> 0
<a> return locationBuilder_ . getMessageList ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public int getLocationCount ( ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> return location_ . size ( ) ; </a> 0
<a> } else { </a> 0
<a> return locationBuilder_ . getCount ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Location getLocation ( int index ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> return location_ . get ( index ) ; </a> 0
<a> } else { </a> 0
<a> return locationBuilder_ . getMessage ( index ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public Builder setLocation ( </a> 0
<a> int index , io . netty . example . localtime . LocalTimeProtocol . Location value ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( ) ; </a> 0
<a> } </a> 0
<a> ensureLocationIsMutable ( ) ; </a> 0
<a> location_ . set ( index , value ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> locationBuilder_ . setMessage ( index , value ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder setLocation ( </a> 0
<a> int index , io . netty . example . localtime . LocalTimeProtocol . Location . Builder builderForValue ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> ensureLocationIsMutable ( ) ; </a> 0
<a> location_ . set ( index , builderForValue . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> locationBuilder_ . setMessage ( index , builderForValue . build ( ) ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder addLocation ( io . netty . example . localtime . LocalTimeProtocol . Location value ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( ) ; </a> 0
<a> } </a> 0
<a> ensureLocationIsMutable ( ) ; </a> 0
<a> location_ . add ( value ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> locationBuilder_ . addMessage ( value ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder addLocation ( </a> 0
<a> int index , io . netty . example . localtime . LocalTimeProtocol . Location value ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( ) ; </a> 0
<a> } </a> 0
<a> ensureLocationIsMutable ( ) ; </a> 0
<a> location_ . add ( index , value ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> locationBuilder_ . addMessage ( index , value ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder addLocation ( </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Location . Builder builderForValue ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> ensureLocationIsMutable ( ) ; </a> 0
<a> location_ . add ( builderForValue . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> locationBuilder_ . addMessage ( builderForValue . build ( ) ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder addLocation ( </a> 0
<a> int index , io . netty . example . localtime . LocalTimeProtocol . Location . Builder builderForValue ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> ensureLocationIsMutable ( ) ; </a> 0
<a> location_ . add ( index , builderForValue . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> locationBuilder_ . addMessage ( index , builderForValue . build ( ) ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder addAllLocation ( </a> 0
<a> java . lang . Iterable < ? extends io . netty . example . localtime . LocalTimeProtocol . Location > values ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> ensureLocationIsMutable ( ) ; </a> 0
<a> super . addAll ( values , location_ ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> locationBuilder_ . addAllMessages ( values ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clearLocation ( ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> location_ = java . util . Collections . emptyList ( ) ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> locationBuilder_ . clear ( ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder removeLocation ( int index ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> ensureLocationIsMutable ( ) ; </a> 0
<a> location_ . remove ( index ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> locationBuilder_ . remove ( index ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Location . Builder getLocationBuilder ( </a> 0
<a> int index ) { </a> 0
<a> return getLocationFieldBuilder ( ) . getBuilder ( index ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocationOrBuilder getLocationOrBuilder ( </a> 0
<a> int index ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> return location_ . get ( index ) ; } else { </a> 0
<a> return locationBuilder_ . getMessageOrBuilder ( index ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public java . util . List < ? extends io . netty . example . localtime . LocalTimeProtocol . LocationOrBuilder > </a> 0
<a> getLocationOrBuilderList ( ) { </a> 0
<a> if ( locationBuilder_ != null ) { </a> 0
<a> return locationBuilder_ . getMessageOrBuilderList ( ) ; </a> 0
<a> } else { </a> 0
<a> return java . util . Collections . unmodifiableList ( location_ ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Location . Builder addLocationBuilder ( ) { </a> 0
<a> return getLocationFieldBuilder ( ) . addBuilder ( </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Location . getDefaultInstance ( ) ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . Location . Builder addLocationBuilder ( </a> 0
<a> int index ) { </a> 0
<a> return getLocationFieldBuilder ( ) . addBuilder ( </a> 0
<a> index , io . netty . example . localtime . LocalTimeProtocol . Location . getDefaultInstance ( ) ) ; </a> 0
<a> } </a> 0
<a> public java . util . List < io . netty . example . localtime . LocalTimeProtocol . Location . Builder > </a> 0
<a> getLocationBuilderList ( ) { </a> 0
<a> return getLocationFieldBuilder ( ) . getBuilderList ( ) ; </a> 0
<a> } </a> 0
<a> private com . google . protobuf . RepeatedFieldBuilder < </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Location , io . netty . example . localtime . LocalTimeProtocol . Location . Builder , io . netty . example . localtime . LocalTimeProtocol . LocationOrBuilder > </a> 0
<a> getLocationFieldBuilder ( ) { </a> 0
<a> if ( locationBuilder_ == null ) { </a> 0
<a> locationBuilder_ = new com . google . protobuf . RepeatedFieldBuilder < </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Location , io . netty . example . localtime . LocalTimeProtocol . Location . Builder , io . netty . example . localtime . LocalTimeProtocol . LocationOrBuilder > ( </a> 0
<a> location_ , </a> 0
<a> ( bitField0_ & 0x00000001 ) == 0x00000001 , </a> 0
<a> getParentForChildren ( ) , </a> 0
<a> isClean ( ) ) ; </a> 0
<a> location_ = null ; </a> 0
<a> } </a> 0
<a> return locationBuilder_ ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static { </a> 0
<a> defaultInstance = new Locations ( true ) ; </a> 0
<a> defaultInstance . initFields ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public interface LocalTimeOrBuilder </a> 0
<a> extends com . google . protobuf . MessageOrBuilder { </a> 0
<a> boolean hasYear ( ) ; </a> 0
<a> int getYear ( ) ; </a> 0
<a> boolean hasMonth ( ) ; </a> 0
<a> int getMonth ( ) ; </a> 0
<a> boolean hasDayOfMonth ( ) ; </a> 0
<a> int getDayOfMonth ( ) ; </a> 0
<a> boolean hasDayOfWeek ( ) ; </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . DayOfWeek getDayOfWeek ( ) ; </a> 0
<a> boolean hasHour ( ) ; </a> 0
<a> int getHour ( ) ; </a> 0
<a> boolean hasMinute ( ) ; </a> 0
<a> int getMinute ( ) ; </a> 0
<a> boolean hasSecond ( ) ; </a> 0
<a> int getSecond ( ) ; </a> 0
<a> } </a> 0
<a> public static final class LocalTime extends </a> 0
<a> com . google . protobuf . GeneratedMessage </a> 0
<a> implements LocalTimeOrBuilder { </a> 0
<a> private LocalTime ( Builder builder ) { </a> 0
<a> super ( builder ) ; </a> 0
<a> } </a> 0
<a> private LocalTime ( boolean noInit ) { } </a> 0
<a> private static final LocalTime defaultInstance ; </a> 0
<a> public static LocalTime getDefaultInstance ( ) { </a> 0
<a> return defaultInstance ; </a> 0
<a> } </a> 0
<a> public LocalTime getDefaultInstanceForType ( ) { </a> 0
<a> return defaultInstance ; </a> 0
<a> } </a> 0
<a> public static final com . google . protobuf . Descriptors . Descriptor </a> 0
<a> getDescriptor ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_LocalTime_descriptor ; </a> 0
<a> } </a> 0
<a> protected com . google . protobuf . GeneratedMessage . FieldAccessorTable </a> 0
<a> internalGetFieldAccessorTable ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_LocalTime_fieldAccessorTable ; </a> 0
<a> } </a> 0
<a> private int bitField0_ ; </a> 0
<a> public static final int YEAR_FIELD_NUMBER = 1 ; </a> 0
<a> private int year_ ; </a> 0
<a> public boolean hasYear ( ) { </a> 0
<a> return ( bitField0_ & 0x00000001 ) == 0x00000001 ; </a> 0
<a> } </a> 0
<a> public int getYear ( ) { </a> 0
<a> return year_ ; </a> 0
<a> } </a> 0
<a> public static final int MONTH_FIELD_NUMBER = 2 ; </a> 0
<a> private int month_ ; </a> 0
<a> public boolean hasMonth ( ) { </a> 0
<a> return ( bitField0_ & 0x00000002 ) == 0x00000002 ; </a> 0
<a> } </a> 0
<a> public int getMonth ( ) { </a> 0
<a> return month_ ; </a> 0
<a> } </a> 0
<a> public static final int DAYOFMONTH_FIELD_NUMBER = 4 ; </a> 0
<a> private int dayOfMonth_ ; </a> 0
<a> public boolean hasDayOfMonth ( ) { </a> 0
<a> return ( bitField0_ & 0x00000004 ) == 0x00000004 ; </a> 0
<a> } </a> 0
<a> public int getDayOfMonth ( ) { </a> 0
<a> return dayOfMonth_ ; </a> 0
<a> } </a> 0
<a> public static final int DAYOFWEEK_FIELD_NUMBER = 5 ; </a> 0
<a> private io . netty . example . localtime . LocalTimeProtocol . DayOfWeek dayOfWeek_ ; </a> 0
<a> public boolean hasDayOfWeek ( ) { </a> 0
<a> return ( bitField0_ & 0x00000008 ) == 0x00000008 ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . DayOfWeek getDayOfWeek ( ) { </a> 0
<a> return dayOfWeek_ ; </a> 0
<a> } </a> 0
<a> public static final int HOUR_FIELD_NUMBER = 6 ; </a> 0
<a> private int hour_ ; </a> 0
<a> public boolean hasHour ( ) { </a> 0
<a> return ( bitField0_ & 0x00000010 ) == 0x00000010 ; </a> 0
<a> } </a> 0
<a> public int getHour ( ) { </a> 0
<a> return hour_ ; </a> 0
<a> } </a> 0
<a> public static final int MINUTE_FIELD_NUMBER = 7 ; </a> 0
<a> private int minute_ ; </a> 0
<a> public boolean hasMinute ( ) { </a> 0
<a> return ( bitField0_ & 0x00000020 ) == 0x00000020 ; </a> 0
<a> } </a> 0
<a> public int getMinute ( ) { </a> 0
<a> return minute_ ; </a> 0
<a> } </a> 0
<a> public static final int SECOND_FIELD_NUMBER = 8 ; </a> 0
<a> private int second_ ; </a> 0
<a> public boolean hasSecond ( ) { </a> 0
<a> return ( bitField0_ & 0x00000040 ) == 0x00000040 ; </a> 0
<a> } </a> 0
<a> public int getSecond ( ) { </a> 0
<a> return second_ ; </a> 0
<a> } </a> 0
<a> private void initFields ( ) { </a> 0
<a> year_ = 0 ; </a> 0
<a> month_ = 0 ; </a> 0
<a> dayOfMonth_ = 0 ; </a> 0
<a> dayOfWeek_ = io . netty . example . localtime . LocalTimeProtocol . DayOfWeek . SUNDAY ; </a> 0
<a> hour_ = 0 ; </a> 0
<a> minute_ = 0 ; </a> 0
<a> second_ = 0 ; </a> 0
<a> } </a> 0
<a> private byte memoizedIsInitialized = - 1 ; </a> 0
<a> public final boolean isInitialized ( ) { </a> 0
<a> byte isInitialized = memoizedIsInitialized ; </a> 0
<a> if ( isInitialized != - 1 ) { </a> 0
<a> return isInitialized == 1 ; </a> 0
<a> } </a> 0
<a> if ( ! hasYear ( ) ) { </a> 0
<a> memoizedIsInitialized = 0 ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasMonth ( ) ) { </a> 0
<a> memoizedIsInitialized = 0 ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasDayOfMonth ( ) ) { </a> 0
<a> memoizedIsInitialized = 0 ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasDayOfWeek ( ) ) { </a> 0
<a> memoizedIsInitialized = 0 ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasHour ( ) ) { </a> 0
<a> memoizedIsInitialized = 0 ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasMinute ( ) ) { </a> 0
<a> memoizedIsInitialized = 0 ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasSecond ( ) ) { </a> 0
<a> memoizedIsInitialized = 0 ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> memoizedIsInitialized = 1 ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public void writeTo ( com . google . protobuf . CodedOutputStream output ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> getSerializedSize ( ) ; </a> 0
<a> if ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) { </a> 0
<a> output . writeUInt32 ( 1 , year_ ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000002 ) == 0x00000002 ) { </a> 0
<a> output . writeUInt32 ( 2 , month_ ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000004 ) == 0x00000004 ) { </a> 0
<a> output . writeUInt32 ( 4 , dayOfMonth_ ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000008 ) == 0x00000008 ) { </a> 0
<a> output . writeEnum ( 5 , dayOfWeek_ . getNumber ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000010 ) == 0x00000010 ) { </a> 0
<a> output . writeUInt32 ( 6 , hour_ ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000020 ) == 0x00000020 ) { </a> 0
<a> output . writeUInt32 ( 7 , minute_ ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000040 ) == 0x00000040 ) { </a> 0
<a> output . writeUInt32 ( 8 , second_ ) ; </a> 0
<a> } </a> 0
<a> getUnknownFields ( ) . writeTo ( output ) ; </a> 0
<a> } </a> 0
<a> private int memoizedSerializedSize = - 1 ; </a> 0
<a> public int getSerializedSize ( ) { </a> 0
<a> int size = memoizedSerializedSize ; </a> 0
<a> if ( size != - 1 ) { </a> 0
<a> return size ; </a> 0
<a> } </a> 0
<a> size = 0 ; </a> 0
<a> if ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) { </a> 0
<a> size += com . google . protobuf . CodedOutputStream </a> 0
<a> . computeUInt32Size ( 1 , year_ ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000002 ) == 0x00000002 ) { </a> 0
<a> size += com . google . protobuf . CodedOutputStream </a> 0
<a> . computeUInt32Size ( 2 , month_ ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000004 ) == 0x00000004 ) { </a> 0
<a> size += com . google . protobuf . CodedOutputStream </a> 0
<a> . computeUInt32Size ( 4 , dayOfMonth_ ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000008 ) == 0x00000008 ) { </a> 0
<a> size += com . google . protobuf . CodedOutputStream </a> 0
<a> . computeEnumSize ( 5 , dayOfWeek_ . getNumber ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000010 ) == 0x00000010 ) { </a> 0
<a> size += com . google . protobuf . CodedOutputStream </a> 0
<a> . computeUInt32Size ( 6 , hour_ ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000020 ) == 0x00000020 ) { </a> 0
<a> size += com . google . protobuf . CodedOutputStream </a> 0
<a> . computeUInt32Size ( 7 , minute_ ) ; </a> 0
<a> } </a> 0
<a> if ( ( bitField0_ & 0x00000040 ) == 0x00000040 ) { </a> 0
<a> size += com . google . protobuf . CodedOutputStream </a> 0
<a> . computeUInt32Size ( 8 , second_ ) ; </a> 0
<a> } </a> 0
<a> size += getUnknownFields ( ) . getSerializedSize ( ) ; </a> 0
<a> memoizedSerializedSize = size ; </a> 0
<a> return size ; </a> 0
<a> } </a> 0
<a> private static final long serialVersionUID = 0L ; </a> 0
<a> @ java . lang . Override </a> 0
<a> protected java . lang . Object writeReplace ( ) </a> 0
<a> throws java . io . ObjectStreamException { </a> 0
<a> return super . writeReplace ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTime parseFrom ( </a> 0
<a> com . google . protobuf . ByteString data ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTime parseFrom ( </a> 0
<a> com . google . protobuf . ByteString data , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTime parseFrom ( byte [ ] data ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTime parseFrom ( </a> 0
<a> byte [ ] data , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTime parseFrom ( java . io . InputStream input ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTime parseFrom ( </a> 0
<a> java . io . InputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTime parseDelimitedFrom ( java . io . InputStream input ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> Builder builder = newBuilder ( ) ; </a> 0
<a> if ( builder . mergeDelimitedFrom ( input ) ) { </a> 0
<a> return builder . buildParsed ( ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTime parseDelimitedFrom ( </a> 0
<a> java . io . InputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> Builder builder = newBuilder ( ) ; </a> 0
<a> if ( builder . mergeDelimitedFrom ( input , extensionRegistry ) ) { </a> 0
<a> return builder . buildParsed ( ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTime parseFrom ( </a> 0
<a> com . google . protobuf . CodedInputStream input ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTime parseFrom ( </a> 0
<a> com . google . protobuf . CodedInputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static Builder newBuilder ( ) { return Builder . create ( ) ; } </a> 0
<a> public Builder newBuilderForType ( ) { return newBuilder ( ) ; } </a> 0
<a> public static Builder newBuilder ( io . netty . example . localtime . LocalTimeProtocol . LocalTime prototype ) { </a> 0
<a> return newBuilder ( ) . mergeFrom ( prototype ) ; </a> 0
<a> } </a> 0
<a> public Builder toBuilder ( ) { return newBuilder ( this ) ; } </a> 0
<a> @ java . lang . Override </a> 0
<a> protected Builder newBuilderForType ( </a> 0
<a> com . google . protobuf . GeneratedMessage . BuilderParent parent ) { </a> 0
<a> Builder builder = new Builder ( parent ) ; </a> 0
<a> return builder ; </a> 0
<a> } </a> 0
<a> public static final class Builder extends </a> 0
<a> com . google . protobuf . GeneratedMessage . Builder < Builder > </a> 0
<a> implements io . netty . example . localtime . LocalTimeProtocol . LocalTimeOrBuilder { </a> 0
<a> public static final com . google . protobuf . Descriptors . Descriptor </a> 0
<a> getDescriptor ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_LocalTime_descriptor ; </a> 0
<a> } </a> 0
<a> protected com . google . protobuf . GeneratedMessage . FieldAccessorTable </a> 0
<a> internalGetFieldAccessorTable ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_LocalTime_fieldAccessorTable ; </a> 0
<a> } </a> 0
<a> private Builder ( ) { </a> 0
<a> maybeForceBuilderInitialization ( ) ; </a> 0
<a> } </a> 0
<a> private Builder ( BuilderParent parent ) { </a> 0
<a> super ( parent ) ; </a> 0
<a> maybeForceBuilderInitialization ( ) ; </a> 0
<a> } </a> 0
<a> private void maybeForceBuilderInitialization ( ) { </a> 0
<a> if ( com . google . protobuf . GeneratedMessage . alwaysUseFieldBuilders ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static Builder create ( ) { </a> 0
<a> return new Builder ( ) ; </a> 0
<a> } </a> 0
<a> public Builder clear ( ) { </a> 0
<a> super . clear ( ) ; </a> 0
<a> year_ = 0 ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> month_ = 0 ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000002 ; </a> 0
<a> dayOfMonth_ = 0 ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000004 ; </a> 0
<a> dayOfWeek_ = io . netty . example . localtime . LocalTimeProtocol . DayOfWeek . SUNDAY ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000008 ; </a> 0
<a> hour_ = 0 ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000010 ; </a> 0
<a> minute_ = 0 ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000020 ; </a> 0
<a> second_ = 0 ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000040 ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clone ( ) { </a> 0
<a> return create ( ) . mergeFrom ( buildPartial ( ) ) ; </a> 0
<a> } </a> 0
<a> public com . google . protobuf . Descriptors . Descriptor </a> 0
<a> getDescriptorForType ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . LocalTime . getDescriptor ( ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTime getDefaultInstanceForType ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . LocalTime . getDefaultInstance ( ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTime build ( ) { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTime result = buildPartial ( ) ; </a> 0
<a> if ( ! result . isInitialized ( ) ) { </a> 0
<a> throw newUninitializedMessageException ( result ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> private io . netty . example . localtime . LocalTimeProtocol . LocalTime buildParsed ( ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTime result = buildPartial ( ) ; </a> 0
<a> if ( ! result . isInitialized ( ) ) { </a> 0
<a> throw newUninitializedMessageException ( </a> 0
<a> result ) . asInvalidProtocolBufferException ( ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTime buildPartial ( ) { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTime result = new io . netty . example . localtime . LocalTimeProtocol . LocalTime ( this ) ; </a> 0
<a> int from_bitField0_ = bitField0_ ; </a> 0
<a> int to_bitField0_ = 0 ; </a> 0
<a> if ( ( from_bitField0_ & 0x00000001 ) == 0x00000001 ) { </a> 0
<a> to_bitField0_ |= 0x00000001 ; </a> 0
<a> } </a> 0
<a> result . year_ = year_ ; </a> 0
<a> if ( ( from_bitField0_ & 0x00000002 ) == 0x00000002 ) { </a> 0
<a> to_bitField0_ |= 0x00000002 ; </a> 0
<a> } </a> 0
<a> result . month_ = month_ ; </a> 0
<a> if ( ( from_bitField0_ & 0x00000004 ) == 0x00000004 ) { </a> 0
<a> to_bitField0_ |= 0x00000004 ; </a> 0
<a> } </a> 0
<a> result . dayOfMonth_ = dayOfMonth_ ; </a> 0
<a> if ( ( from_bitField0_ & 0x00000008 ) == 0x00000008 ) { </a> 0
<a> to_bitField0_ |= 0x00000008 ; </a> 0
<a> } </a> 0
<a> result . dayOfWeek_ = dayOfWeek_ ; </a> 0
<a> if ( ( from_bitField0_ & 0x00000010 ) == 0x00000010 ) { </a> 0
<a> to_bitField0_ |= 0x00000010 ; </a> 0
<a> } </a> 0
<a> result . hour_ = hour_ ; </a> 0
<a> if ( ( from_bitField0_ & 0x00000020 ) == 0x00000020 ) { </a> 0
<a> to_bitField0_ |= 0x00000020 ; </a> 0
<a> } </a> 0
<a> result . minute_ = minute_ ; </a> 0
<a> if ( ( from_bitField0_ & 0x00000040 ) == 0x00000040 ) { </a> 0
<a> to_bitField0_ |= 0x00000040 ; </a> 0
<a> } </a> 0
<a> result . second_ = second_ ; </a> 0
<a> result . bitField0_ = to_bitField0_ ; </a> 0
<a> onBuilt ( ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> public Builder mergeFrom ( com . google . protobuf . Message other ) { </a> 0
<a> if ( other instanceof io . netty . example . localtime . LocalTimeProtocol . LocalTime ) { </a> 0
<a> return mergeFrom ( ( io . netty . example . localtime . LocalTimeProtocol . LocalTime ) other ) ; </a> 0
<a> } else { </a> 0
<a> super . mergeFrom ( other ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public Builder mergeFrom ( io . netty . example . localtime . LocalTimeProtocol . LocalTime other ) { </a> 0
<a> if ( other == io . netty . example . localtime . LocalTimeProtocol . LocalTime . getDefaultInstance ( ) ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> if ( other . hasYear ( ) ) { </a> 0
<a> setYear ( other . getYear ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( other . hasMonth ( ) ) { </a> 0
<a> setMonth ( other . getMonth ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( other . hasDayOfMonth ( ) ) { </a> 0
<a> setDayOfMonth ( other . getDayOfMonth ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( other . hasDayOfWeek ( ) ) { </a> 0
<a> setDayOfWeek ( other . getDayOfWeek ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( other . hasHour ( ) ) { </a> 0
<a> setHour ( other . getHour ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( other . hasMinute ( ) ) { </a> 0
<a> setMinute ( other . getMinute ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( other . hasSecond ( ) ) { </a> 0
<a> setSecond ( other . getSecond ( ) ) ; </a> 0
<a> } </a> 0
<a> mergeUnknownFields ( other . getUnknownFields ( ) ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public final boolean isInitialized ( ) { </a> 0
<a> if ( ! hasYear ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasMonth ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasDayOfMonth ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasDayOfWeek ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasHour ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasMinute ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ! hasSecond ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public Builder mergeFrom ( </a> 0
<a> com . google . protobuf . CodedInputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> com . google . protobuf . UnknownFieldSet . Builder unknownFields = </a> 0
<a> com . google . protobuf . UnknownFieldSet . newBuilder ( </a> 0
<a> getUnknownFields ( ) ) ; </a> 0
<a> while ( true ) { </a> 0
<a> int tag = input . readTag ( ) ; </a> 0
<a> switch ( tag ) { </a> 0
<a> case 0 : </a> 0
<a> setUnknownFields ( unknownFields . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> default : { </a> 0
<a> if ( ! parseUnknownField ( input , unknownFields , </a> 0
<a> extensionRegistry , tag ) ) { </a> 0
<a> setUnknownFields ( unknownFields . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 8 : { </a> 0
<a> bitField0_ |= 0x00000001 ; </a> 0
<a> year_ = input . readUInt32 ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 16 : { </a> 0
<a> bitField0_ |= 0x00000002 ; </a> 0
<a> month_ = input . readUInt32 ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 32 : { </a> 0
<a> bitField0_ |= 0x00000004 ; </a> 0
<a> dayOfMonth_ = input . readUInt32 ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 40 : { </a> 0
<a> int rawValue = input . readEnum ( ) ; </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . DayOfWeek value = io . netty . example . localtime . LocalTimeProtocol . DayOfWeek . valueOf ( rawValue ) ; </a> 0
<a> if ( value == null ) { </a> 0
<a> unknownFields . mergeVarintField ( 5 , rawValue ) ; </a> 0
<a> } else { </a> 0
<a> bitField0_ |= 0x00000008 ; </a> 0
<a> dayOfWeek_ = value ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 48 : { </a> 0
<a> bitField0_ |= 0x00000010 ; </a> 0
<a> hour_ = input . readUInt32 ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 56 : { </a> 0
<a> bitField0_ |= 0x00000020 ; </a> 0
<a> minute_ = input . readUInt32 ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 64 : { </a> 0
<a> bitField0_ |= 0x00000040 ; </a> 0
<a> second_ = input . readUInt32 ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private int bitField0_ ; </a> 0
<a> private int year_ ; </a> 0
<a> public boolean hasYear ( ) { </a> 0
<a> return ( bitField0_ & 0x00000001 ) == 0x00000001 ; </a> 0
<a> } </a> 0
<a> public int getYear ( ) { </a> 0
<a> return year_ ; </a> 0
<a> } </a> 0
<a> public Builder setYear ( int value ) { </a> 0
<a> bitField0_ |= 0x00000001 ; </a> 0
<a> year_ = value ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clearYear ( ) { </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> year_ = 0 ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> private int month_ ; </a> 0
<a> public boolean hasMonth ( ) { </a> 0
<a> return ( bitField0_ & 0x00000002 ) == 0x00000002 ; </a> 0
<a> } </a> 0
<a> public int getMonth ( ) { </a> 0
<a> return month_ ; </a> 0
<a> } </a> 0
<a> public Builder setMonth ( int value ) { </a> 0
<a> bitField0_ |= 0x00000002 ; </a> 0
<a> month_ = value ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clearMonth ( ) { </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000002 ; </a> 0
<a> month_ = 0 ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> private int dayOfMonth_ ; </a> 0
<a> public boolean hasDayOfMonth ( ) { </a> 0
<a> return ( bitField0_ & 0x00000004 ) == 0x00000004 ; </a> 0
<a> } </a> 0
<a> public int getDayOfMonth ( ) { </a> 0
<a> return dayOfMonth_ ; </a> 0
<a> } </a> 0
<a> public Builder setDayOfMonth ( int value ) { </a> 0
<a> bitField0_ |= 0x00000004 ; </a> 0
<a> dayOfMonth_ = value ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clearDayOfMonth ( ) { </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000004 ; </a> 0
<a> dayOfMonth_ = 0 ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> private io . netty . example . localtime . LocalTimeProtocol . DayOfWeek dayOfWeek_ = io . netty . example . localtime . LocalTimeProtocol . DayOfWeek . SUNDAY ; </a> 0
<a> public boolean hasDayOfWeek ( ) { </a> 0
<a> return ( bitField0_ & 0x00000008 ) == 0x00000008 ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . DayOfWeek getDayOfWeek ( ) { </a> 0
<a> return dayOfWeek_ ; </a> 0
<a> } </a> 0
<a> public Builder setDayOfWeek ( io . netty . example . localtime . LocalTimeProtocol . DayOfWeek value ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( ) ; </a> 0
<a> } </a> 0
<a> bitField0_ |= 0x00000008 ; </a> 0
<a> dayOfWeek_ = value ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clearDayOfWeek ( ) { </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000008 ; </a> 0
<a> dayOfWeek_ = io . netty . example . localtime . LocalTimeProtocol . DayOfWeek . SUNDAY ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> private int hour_ ; </a> 0
<a> public boolean hasHour ( ) { </a> 0
<a> return ( bitField0_ & 0x00000010 ) == 0x00000010 ; </a> 0
<a> } </a> 0
<a> public int getHour ( ) { </a> 0
<a> return hour_ ; </a> 0
<a> } </a> 0
<a> public Builder setHour ( int value ) { </a> 0
<a> bitField0_ |= 0x00000010 ; </a> 0
<a> hour_ = value ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clearHour ( ) { </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000010 ; </a> 0
<a> hour_ = 0 ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> private int minute_ ; </a> 0
<a> public boolean hasMinute ( ) { </a> 0
<a> return ( bitField0_ & 0x00000020 ) == 0x00000020 ; </a> 0
<a> } </a> 0
<a> public int getMinute ( ) { </a> 0
<a> return minute_ ; </a> 0
<a> } </a> 0
<a> public Builder setMinute ( int value ) { </a> 0
<a> bitField0_ |= 0x00000020 ; </a> 0
<a> minute_ = value ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clearMinute ( ) { </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000020 ; </a> 0
<a> minute_ = 0 ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> private int second_ ; </a> 0
<a> public boolean hasSecond ( ) { </a> 0
<a> return ( bitField0_ & 0x00000040 ) == 0x00000040 ; </a> 0
<a> } </a> 0
<a> public int getSecond ( ) { </a> 0
<a> return second_ ; </a> 0
<a> } </a> 0
<a> public Builder setSecond ( int value ) { </a> 0
<a> bitField0_ |= 0x00000040 ; </a> 0
<a> second_ = value ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clearSecond ( ) { </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000040 ; </a> 0
<a> second_ = 0 ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static { </a> 0
<a> defaultInstance = new LocalTime ( true ) ; </a> 0
<a> defaultInstance . initFields ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public interface LocalTimesOrBuilder </a> 0
<a> extends com . google . protobuf . MessageOrBuilder { </a> 0
<a> java . util . List < io . netty . example . localtime . LocalTimeProtocol . LocalTime > </a> 0
<a> getLocalTimeList ( ) ; </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTime getLocalTime ( int index ) ; </a> 0
<a> int getLocalTimeCount ( ) ; </a> 0
<a> java . util . List < ? extends io . netty . example . localtime . LocalTimeProtocol . LocalTimeOrBuilder > </a> 0
<a> getLocalTimeOrBuilderList ( ) ; </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTimeOrBuilder getLocalTimeOrBuilder ( </a> 0
<a> int index ) ; </a> 0
<a> } </a> 0
<a> public static final class LocalTimes extends </a> 0
<a> com . google . protobuf . GeneratedMessage </a> 0
<a> implements LocalTimesOrBuilder { </a> 0
<a> private LocalTimes ( Builder builder ) { </a> 0
<a> super ( builder ) ; </a> 0
<a> } </a> 0
<a> private LocalTimes ( boolean noInit ) { } </a> 0
<a> private static final LocalTimes defaultInstance ; </a> 0
<a> public static LocalTimes getDefaultInstance ( ) { </a> 0
<a> return defaultInstance ; </a> 0
<a> } </a> 0
<a> public LocalTimes getDefaultInstanceForType ( ) { </a> 0
<a> return defaultInstance ; </a> 0
<a> } </a> 0
<a> public static final com . google . protobuf . Descriptors . Descriptor </a> 0
<a> getDescriptor ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_LocalTimes_descriptor ; </a> 0
<a> } </a> 0
<a> protected com . google . protobuf . GeneratedMessage . FieldAccessorTable </a> 0
<a> internalGetFieldAccessorTable ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_LocalTimes_fieldAccessorTable ; </a> 0
<a> } </a> 0
<a> public static final int LOCALTIME_FIELD_NUMBER = 1 ; </a> 0
<a> private java . util . List < io . netty . example . localtime . LocalTimeProtocol . LocalTime > localTime_ ; </a> 0
<a> public java . util . List < io . netty . example . localtime . LocalTimeProtocol . LocalTime > getLocalTimeList ( ) { </a> 0
<a> return localTime_ ; </a> 0
<a> } </a> 0
<a> public java . util . List < ? extends io . netty . example . localtime . LocalTimeProtocol . LocalTimeOrBuilder > </a> 0
<a> getLocalTimeOrBuilderList ( ) { </a> 0
<a> return localTime_ ; </a> 0
<a> } </a> 0
<a> public int getLocalTimeCount ( ) { </a> 0
<a> return localTime_ . size ( ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTime getLocalTime ( int index ) { </a> 0
<a> return localTime_ . get ( index ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTimeOrBuilder getLocalTimeOrBuilder ( </a> 0
<a> int index ) { </a> 0
<a> return localTime_ . get ( index ) ; </a> 0
<a> } </a> 0
<a> private void initFields ( ) { </a> 0
<a> localTime_ = java . util . Collections . emptyList ( ) ; </a> 0
<a> } </a> 0
<a> private byte memoizedIsInitialized = - 1 ; </a> 0
<a> public final boolean isInitialized ( ) { </a> 0
<a> byte isInitialized = memoizedIsInitialized ; </a> 0
<a> if ( isInitialized != - 1 ) { </a> 0
<a> return isInitialized == 1 ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < getLocalTimeCount ( ) ; i ++ ) { </a> 0
<a> if ( ! getLocalTime ( i ) . isInitialized ( ) ) { </a> 0
<a> memoizedIsInitialized = 0 ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> memoizedIsInitialized = 1 ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public void writeTo ( com . google . protobuf . CodedOutputStream output ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> getSerializedSize ( ) ; </a> 0
<a> for ( int i = 0 ; i < localTime_ . size ( ) ; i ++ ) { </a> 0
<a> output . writeMessage ( 1 , localTime_ . get ( i ) ) ; </a> 0
<a> } </a> 0
<a> getUnknownFields ( ) . writeTo ( output ) ; </a> 0
<a> } </a> 0
<a> private int memoizedSerializedSize = - 1 ; </a> 0
<a> public int getSerializedSize ( ) { </a> 0
<a> int size = memoizedSerializedSize ; </a> 0
<a> if ( size != - 1 ) { </a> 0
<a> return size ; </a> 0
<a> } </a> 0
<a> size = 0 ; </a> 0
<a> for ( int i = 0 ; i < localTime_ . size ( ) ; i ++ ) { </a> 0
<a> size += com . google . protobuf . CodedOutputStream </a> 0
<a> . computeMessageSize ( 1 , localTime_ . get ( i ) ) ; </a> 0
<a> } </a> 0
<a> size += getUnknownFields ( ) . getSerializedSize ( ) ; </a> 0
<a> memoizedSerializedSize = size ; </a> 0
<a> return size ; </a> 0
<a> } </a> 0
<a> private static final long serialVersionUID = 0L ; </a> 0
<a> @ java . lang . Override </a> 0
<a> protected java . lang . Object writeReplace ( ) </a> 0
<a> throws java . io . ObjectStreamException { </a> 0
<a> return super . writeReplace ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTimes parseFrom ( </a> 0
<a> com . google . protobuf . ByteString data ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTimes parseFrom ( </a> 0
<a> com . google . protobuf . ByteString data , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTimes parseFrom ( byte [ ] data ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTimes parseFrom ( </a> 0
<a> byte [ ] data , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( data , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTimes parseFrom ( java . io . InputStream input ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTimes parseFrom ( </a> 0
<a> java . io . InputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTimes parseDelimitedFrom ( java . io . InputStream input ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> Builder builder = newBuilder ( ) ; </a> 0
<a> if ( builder . mergeDelimitedFrom ( input ) ) { </a> 0
<a> return builder . buildParsed ( ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTimes parseDelimitedFrom ( </a> 0
<a> java . io . InputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> Builder builder = newBuilder ( ) ; </a> 0
<a> if ( builder . mergeDelimitedFrom ( input , extensionRegistry ) ) { </a> 0
<a> return builder . buildParsed ( ) ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTimes parseFrom ( </a> 0
<a> com . google . protobuf . CodedInputStream input ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input ) . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static io . netty . example . localtime . LocalTimeProtocol . LocalTimes parseFrom ( </a> 0
<a> com . google . protobuf . CodedInputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> return newBuilder ( ) . mergeFrom ( input , extensionRegistry ) </a> 0
<a> . buildParsed ( ) ; </a> 0
<a> } </a> 0
<a> public static Builder newBuilder ( ) { return Builder . create ( ) ; } </a> 0
<a> public Builder newBuilderForType ( ) { return newBuilder ( ) ; } </a> 0
<a> public static Builder newBuilder ( io . netty . example . localtime . LocalTimeProtocol . LocalTimes prototype ) { </a> 0
<a> return newBuilder ( ) . mergeFrom ( prototype ) ; </a> 0
<a> } </a> 0
<a> public Builder toBuilder ( ) { return newBuilder ( this ) ; } </a> 0
<a> @ java . lang . Override </a> 0
<a> protected Builder newBuilderForType ( </a> 0
<a> com . google . protobuf . GeneratedMessage . BuilderParent parent ) { </a> 0
<a> Builder builder = new Builder ( parent ) ; </a> 0
<a> return builder ; </a> 0
<a> } </a> 0
<a> public static final class Builder extends </a> 0
<a> com . google . protobuf . GeneratedMessage . Builder < Builder > </a> 0
<a> implements io . netty . example . localtime . LocalTimeProtocol . LocalTimesOrBuilder { </a> 0
<a> public static final com . google . protobuf . Descriptors . Descriptor </a> 0
<a> getDescriptor ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_LocalTimes_descriptor ; </a> 0
<a> } </a> 0
<a> protected com . google . protobuf . GeneratedMessage . FieldAccessorTable </a> 0
<a> internalGetFieldAccessorTable ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . internal_static_io_netty_example_localtime_LocalTimes_fieldAccessorTable ; </a> 0
<a> } </a> 0
<a> private Builder ( ) { </a> 0
<a> maybeForceBuilderInitialization ( ) ; </a> 0
<a> } </a> 0
<a> private Builder ( BuilderParent parent ) { </a> 0
<a> super ( parent ) ; </a> 0
<a> maybeForceBuilderInitialization ( ) ; </a> 0
<a> } </a> 0
<a> private void maybeForceBuilderInitialization ( ) { </a> 0
<a> if ( com . google . protobuf . GeneratedMessage . alwaysUseFieldBuilders ) { </a> 0
<a> getLocalTimeFieldBuilder ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static Builder create ( ) { </a> 0
<a> return new Builder ( ) ; </a> 0
<a> } </a> 0
<a> public Builder clear ( ) { </a> 0
<a> super . clear ( ) ; </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> localTime_ = java . util . Collections . emptyList ( ) ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> } else { </a> 0
<a> localTimeBuilder_ . clear ( ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clone ( ) { </a> 0
<a> return create ( ) . mergeFrom ( buildPartial ( ) ) ; </a> 0
<a> } </a> 0
<a> public com . google . protobuf . Descriptors . Descriptor </a> 0
<a> getDescriptorForType ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . LocalTimes . getDescriptor ( ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTimes getDefaultInstanceForType ( ) { </a> 0
<a> return io . netty . example . localtime . LocalTimeProtocol . LocalTimes . getDefaultInstance ( ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTimes build ( ) { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTimes result = buildPartial ( ) ; </a> 0
<a> if ( ! result . isInitialized ( ) ) { </a> 0
<a> throw newUninitializedMessageException ( result ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> private io . netty . example . localtime . LocalTimeProtocol . LocalTimes buildParsed ( ) </a> 0
<a> throws com . google . protobuf . InvalidProtocolBufferException { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTimes result = buildPartial ( ) ; </a> 0
<a> if ( ! result . isInitialized ( ) ) { </a> 0
<a> throw newUninitializedMessageException ( </a> 0
<a> result ) . asInvalidProtocolBufferException ( ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTimes buildPartial ( ) { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTimes result = new io . netty . example . localtime . LocalTimeProtocol . LocalTimes ( this ) ; </a> 0
<a> int from_bitField0_ = bitField0_ ; </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> if ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) { </a> 0
<a> localTime_ = java . util . Collections . unmodifiableList ( localTime_ ) ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> } </a> 0
<a> result . localTime_ = localTime_ ; </a> 0
<a> } else { </a> 0
<a> result . localTime_ = localTimeBuilder_ . build ( ) ; </a> 0
<a> } </a> 0
<a> onBuilt ( ) ; </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> public Builder mergeFrom ( com . google . protobuf . Message other ) { </a> 0
<a> if ( other instanceof io . netty . example . localtime . LocalTimeProtocol . LocalTimes ) { </a> 0
<a> return mergeFrom ( ( io . netty . example . localtime . LocalTimeProtocol . LocalTimes ) other ) ; </a> 0
<a> } else { </a> 0
<a> super . mergeFrom ( other ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public Builder mergeFrom ( io . netty . example . localtime . LocalTimeProtocol . LocalTimes other ) { </a> 0
<a> if ( other == io . netty . example . localtime . LocalTimeProtocol . LocalTimes . getDefaultInstance ( ) ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> if ( ! other . localTime_ . isEmpty ( ) ) { </a> 0
<a> if ( localTime_ . isEmpty ( ) ) { </a> 0
<a> localTime_ = other . localTime_ ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> } else { </a> 0
<a> ensureLocalTimeIsMutable ( ) ; </a> 0
<a> localTime_ . addAll ( other . localTime_ ) ; </a> 0
<a> } </a> 0
<a> onChanged ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( ! other . localTime_ . isEmpty ( ) ) { </a> 0
<a> if ( localTimeBuilder_ . isEmpty ( ) ) { </a> 0
<a> localTimeBuilder_ . dispose ( ) ; </a> 0
<a> localTimeBuilder_ = null ; </a> 0
<a> localTime_ = other . localTime_ ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> localTimeBuilder_ = </a> 0
<a> com . google . protobuf . GeneratedMessage . alwaysUseFieldBuilders ? </a> 0
<a> getLocalTimeFieldBuilder ( ) : null ; </a> 0
<a> } else { </a> 0
<a> localTimeBuilder_ . addAllMessages ( other . localTime_ ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> mergeUnknownFields ( other . getUnknownFields ( ) ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public final boolean isInitialized ( ) { </a> 0
<a> for ( int i = 0 ; i < getLocalTimeCount ( ) ; i ++ ) { </a> 0
<a> if ( ! getLocalTime ( i ) . isInitialized ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public Builder mergeFrom ( </a> 0
<a> com . google . protobuf . CodedInputStream input , </a> 0
<a> com . google . protobuf . ExtensionRegistryLite extensionRegistry ) </a> 0
<a> throws java . io . IOException { </a> 0
<a> com . google . protobuf . UnknownFieldSet . Builder unknownFields = </a> 0
<a> com . google . protobuf . UnknownFieldSet . newBuilder ( </a> 0
<a> getUnknownFields ( ) ) ; </a> 0
<a> while ( true ) { </a> 0
<a> int tag = input . readTag ( ) ; </a> 0
<a> switch ( tag ) { </a> 0
<a> case 0 : </a> 0
<a> setUnknownFields ( unknownFields . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> default : { </a> 0
<a> if ( ! parseUnknownField ( input , unknownFields , </a> 0
<a> extensionRegistry , tag ) ) { </a> 0
<a> setUnknownFields ( unknownFields . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> case 10 : { </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTime . Builder subBuilder = io . netty . example . localtime . LocalTimeProtocol . LocalTime . newBuilder ( ) ; </a> 0
<a> input . readMessage ( subBuilder , extensionRegistry ) ; </a> 0
<a> addLocalTime ( subBuilder . buildPartial ( ) ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private int bitField0_ ; </a> 0
<a> private java . util . List < io . netty . example . localtime . LocalTimeProtocol . LocalTime > localTime_ = </a> 0
<a> java . util . Collections . emptyList ( ) ; </a> 0
<a> private void ensureLocalTimeIsMutable ( ) { </a> 0
<a> if ( ! ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) ) { </a> 0
<a> localTime_ = new java . util . ArrayList < io . netty . example . localtime . LocalTimeProtocol . LocalTime > ( localTime_ ) ; </a> 0
<a> bitField0_ |= 0x00000001 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private com . google . protobuf . RepeatedFieldBuilder < </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTime , io . netty . example . localtime . LocalTimeProtocol . LocalTime . Builder , io . netty . example . localtime . LocalTimeProtocol . LocalTimeOrBuilder > localTimeBuilder_ ; </a> 0
<a> public java . util . List < io . netty . example . localtime . LocalTimeProtocol . LocalTime > getLocalTimeList ( ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> return java . util . Collections . unmodifiableList ( localTime_ ) ; </a> 0
<a> } else { </a> 0
<a> return localTimeBuilder_ . getMessageList ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public int getLocalTimeCount ( ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> return localTime_ . size ( ) ; </a> 0
<a> } else { </a> 0
<a> return localTimeBuilder_ . getCount ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTime getLocalTime ( int index ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> return localTime_ . get ( index ) ; </a> 0
<a> } else { </a> 0
<a> return localTimeBuilder_ . getMessage ( index ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public Builder setLocalTime ( </a> 0
<a> int index , io . netty . example . localtime . LocalTimeProtocol . LocalTime value ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( ) ; </a> 0
<a> } </a> 0
<a> ensureLocalTimeIsMutable ( ) ; </a> 0
<a> localTime_ . set ( index , value ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> localTimeBuilder_ . setMessage ( index , value ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder setLocalTime ( </a> 0
<a> int index , io . netty . example . localtime . LocalTimeProtocol . LocalTime . Builder builderForValue ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> ensureLocalTimeIsMutable ( ) ; </a> 0
<a> localTime_ . set ( index , builderForValue . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> localTimeBuilder_ . setMessage ( index , builderForValue . build ( ) ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder addLocalTime ( io . netty . example . localtime . LocalTimeProtocol . LocalTime value ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( ) ; </a> 0
<a> } </a> 0
<a> ensureLocalTimeIsMutable ( ) ; </a> 0
<a> localTime_ . add ( value ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> localTimeBuilder_ . addMessage ( value ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder addLocalTime ( </a> 0
<a> int index , io . netty . example . localtime . LocalTimeProtocol . LocalTime value ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> if ( value == null ) { </a> 0
<a> throw new NullPointerException ( ) ; </a> 0
<a> } </a> 0
<a> ensureLocalTimeIsMutable ( ) ; </a> 0
<a> localTime_ . add ( index , value ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> localTimeBuilder_ . addMessage ( index , value ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder addLocalTime ( </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTime . Builder builderForValue ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> ensureLocalTimeIsMutable ( ) ; </a> 0
<a> localTime_ . add ( builderForValue . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> localTimeBuilder_ . addMessage ( builderForValue . build ( ) ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder addLocalTime ( </a> 0
<a> int index , io . netty . example . localtime . LocalTimeProtocol . LocalTime . Builder builderForValue ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> ensureLocalTimeIsMutable ( ) ; </a> 0
<a> localTime_ . add ( index , builderForValue . build ( ) ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> localTimeBuilder_ . addMessage ( index , builderForValue . build ( ) ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder addAllLocalTime ( </a> 0
<a> java . lang . Iterable < ? extends io . netty . example . localtime . LocalTimeProtocol . LocalTime > values ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> ensureLocalTimeIsMutable ( ) ; </a> 0
<a> super . addAll ( values , localTime_ ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> localTimeBuilder_ . addAllMessages ( values ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder clearLocalTime ( ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> localTime_ = java . util . Collections . emptyList ( ) ; </a> 0
<a> bitField0_ = bitField0_ & ~ 0x00000001 ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> localTimeBuilder_ . clear ( ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Builder removeLocalTime ( int index ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> ensureLocalTimeIsMutable ( ) ; </a> 0
<a> localTime_ . remove ( index ) ; </a> 0
<a> onChanged ( ) ; </a> 0
<a> } else { </a> 0
<a> localTimeBuilder_ . remove ( index ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTime . Builder getLocalTimeBuilder ( </a> 0
<a> int index ) { </a> 0
<a> return getLocalTimeFieldBuilder ( ) . getBuilder ( index ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTimeOrBuilder getLocalTimeOrBuilder ( </a> 0
<a> int index ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> return localTime_ . get ( index ) ; } else { </a> 0
<a> return localTimeBuilder_ . getMessageOrBuilder ( index ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public java . util . List < ? extends io . netty . example . localtime . LocalTimeProtocol . LocalTimeOrBuilder > </a> 0
<a> getLocalTimeOrBuilderList ( ) { </a> 0
<a> if ( localTimeBuilder_ != null ) { </a> 0
<a> return localTimeBuilder_ . getMessageOrBuilderList ( ) ; </a> 0
<a> } else { </a> 0
<a> return java . util . Collections . unmodifiableList ( localTime_ ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTime . Builder addLocalTimeBuilder ( ) { </a> 0
<a> return getLocalTimeFieldBuilder ( ) . addBuilder ( </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTime . getDefaultInstance ( ) ) ; </a> 0
<a> } </a> 0
<a> public io . netty . example . localtime . LocalTimeProtocol . LocalTime . Builder addLocalTimeBuilder ( </a> 0
<a> int index ) { </a> 0
<a> return getLocalTimeFieldBuilder ( ) . addBuilder ( </a> 0
<a> index , io . netty . example . localtime . LocalTimeProtocol . LocalTime . getDefaultInstance ( ) ) ; </a> 0
<a> } </a> 0
<a> public java . util . List < io . netty . example . localtime . LocalTimeProtocol . LocalTime . Builder > </a> 0
<a> getLocalTimeBuilderList ( ) { </a> 0
<a> return getLocalTimeFieldBuilder ( ) . getBuilderList ( ) ; </a> 0
<a> } </a> 0
<a> private com . google . protobuf . RepeatedFieldBuilder < </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTime , io . netty . example . localtime . LocalTimeProtocol . LocalTime . Builder , io . netty . example . localtime . LocalTimeProtocol . LocalTimeOrBuilder > </a> 0
<a> getLocalTimeFieldBuilder ( ) { </a> 0
<a> if ( localTimeBuilder_ == null ) { </a> 0
<a> localTimeBuilder_ = new com . google . protobuf . RepeatedFieldBuilder < </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTime , io . netty . example . localtime . LocalTimeProtocol . LocalTime . Builder , io . netty . example . localtime . LocalTimeProtocol . LocalTimeOrBuilder > ( </a> 0
<a> localTime_ , </a> 0
<a> ( bitField0_ & 0x00000001 ) == 0x00000001 , </a> 0
<a> getParentForChildren ( ) , </a> 0
<a> isClean ( ) ) ; </a> 0
<a> localTime_ = null ; </a> 0
<a> } </a> 0
<a> return localTimeBuilder_ ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static { </a> 0
<a> defaultInstance = new LocalTimes ( true ) ; </a> 0
<a> defaultInstance . initFields ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static com . google . protobuf . Descriptors . Descriptor </a> 0
<a> internal_static_io_netty_example_localtime_Location_descriptor ; </a> 0
<a> private static </a> 0
<a> com . google . protobuf . GeneratedMessage . FieldAccessorTable </a> 0
<a> internal_static_io_netty_example_localtime_Location_fieldAccessorTable ; </a> 0
<a> private static com . google . protobuf . Descriptors . Descriptor </a> 0
<a> internal_static_io_netty_example_localtime_Locations_descriptor ; </a> 0
<a> private static </a> 0
<a> com . google . protobuf . GeneratedMessage . FieldAccessorTable </a> 0
<a> internal_static_io_netty_example_localtime_Locations_fieldAccessorTable ; </a> 0
<a> private static com . google . protobuf . Descriptors . Descriptor </a> 0
<a> internal_static_io_netty_example_localtime_LocalTime_descriptor ; </a> 0
<a> private static </a> 0
<a> com . google . protobuf . GeneratedMessage . FieldAccessorTable </a> 0
<a> internal_static_io_netty_example_localtime_LocalTime_fieldAccessorTable ; </a> 0
<a> private static com . google . protobuf . Descriptors . Descriptor </a> 0
<a> internal_static_io_netty_example_localtime_LocalTimes_descriptor ; </a> 0
<a> private static </a> 0
<a> com . google . protobuf . GeneratedMessage . FieldAccessorTable </a> 0
<a> internal_static_io_netty_example_localtime_LocalTimes_fieldAccessorTable ; </a> 0
<a> public static com . google . protobuf . Descriptors . FileDescriptor </a> 0
<a> getDescriptor ( ) { </a> 0
<a> return descriptor ; </a> 0
<a> } </a> 0
<a> private static com . google . protobuf . Descriptors . FileDescriptor </a> 0
<a> descriptor ; </a> 0
<a> static { </a> 0
<a> java . lang . String [ ] descriptorData = { </a> 0
<a> "\n@src/main/java/io/netty/example/localti" + </a> 0
<a> "me/LocalTimeProtocol.proto\022\032io.netty.exa" + </a> 0
<a> "mple.localtime\"R\n\010Location\0228\n\tcontinent\030" + </a> 0
<a> "\001 \002(\0162%.io.netty.example.localtime.Conti" + </a> 0
<a> "nent\022\014\n\004city\030\002 \002(\t\"C\n\tLocations\0226\n\010locat" + </a> 0
<a> "ion\030\001 \003(\0132$.io.netty.example.localtime.L" + </a> 0
<a> "ocation\"\244\001\n\tLocalTime\022\014\n\004year\030\001 \002(\r\022\r\n\005m" + </a> 0
<a> "onth\030\002 \002(\r\022\022\n\ndayOfMonth\030\004 \002(\r\0228\n\tdayOfW" + </a> 0
<a> "eek\030\005 \002(\0162%.io.netty.example.localtime.D" + </a> 0
<a> "ayOfWeek\022\014\n\004hour\030\006 \002(\r\022\016\n\006minute\030\007 \002(\r\022\016" , </a> 0
<a> "\n\006second\030\010 \002(\r\"F\n\nLocalTimes\0228\n\tlocalTim" + </a> 0
<a> "e\030\001 \003(\0132%.io.netty.example.localtime.Loc" + </a> 0
<a> "alTime*\231\001\n\tContinent\022\n\n\006AFRICA\020\000\022\013\n\007AMER" + </a> 0
<a> "ICA\020\001\022\016\n\nANTARCTICA\020\002\022\n\n\006ARCTIC\020\003\022\010\n\004ASI" + </a> 0
<a> "A\020\004\022\014\n\010ATLANTIC\020\005\022\r\n\tAUSTRALIA\020\006\022\n\n\006EURO" + </a> 0
<a> "PE\020\007\022\n\n\006INDIAN\020\010\022\013\n\007MIDEAST\020\t\022\013\n\007PACIFIC" + </a> 0
<a> "\020\n*g\n\tDayOfWeek\022\n\n\006SUNDAY\020\001\022\n\n\006MONDAY\020\002\022" + </a> 0
<a> "\013\n\007TUESDAY\020\003\022\r\n\tWEDNESDAY\020\004\022\014\n\010THURSDAY\020" + </a> 0
<a> "\005\022\n\n\006FRIDAY\020\006\022\014\n\010SATURDAY\020\007B\002H\001" </a> 0
<a> } ; </a> 0
<a> com . google . protobuf . Descriptors . FileDescriptor . InternalDescriptorAssigner assigner = </a> 0
<a> new com . google . protobuf . Descriptors . FileDescriptor . InternalDescriptorAssigner ( ) { </a> 0
<a> public com . google . protobuf . ExtensionRegistry assignDescriptors ( </a> 0
<a> com . google . protobuf . Descriptors . FileDescriptor root ) { </a> 0
<a> descriptor = root ; </a> 0
<a> internal_static_io_netty_example_localtime_Location_descriptor = </a> 0
<a> getDescriptor ( ) . getMessageTypes ( ) . get ( 0 ) ; </a> 0
<a> internal_static_io_netty_example_localtime_Location_fieldAccessorTable = new </a> 0
<a> com . google . protobuf . GeneratedMessage . FieldAccessorTable ( </a> 0
<a> internal_static_io_netty_example_localtime_Location_descriptor , </a> 0
<a> new java . lang . String [ ] { "Continent" , "City" , } , </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Location . class , </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Location . Builder . class ) ; </a> 0
<a> internal_static_io_netty_example_localtime_Locations_descriptor = </a> 0
<a> getDescriptor ( ) . getMessageTypes ( ) . get ( 1 ) ; </a> 0
<a> internal_static_io_netty_example_localtime_Locations_fieldAccessorTable = new </a> 0
<a> com . google . protobuf . GeneratedMessage . FieldAccessorTable ( </a> 0
<a> internal_static_io_netty_example_localtime_Locations_descriptor , </a> 0
<a> new java . lang . String [ ] { "Location" , } , </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Locations . class , </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . Locations . Builder . class ) ; </a> 0
<a> internal_static_io_netty_example_localtime_LocalTime_descriptor = </a> 0
<a> getDescriptor ( ) . getMessageTypes ( ) . get ( 2 ) ; </a> 0
<a> internal_static_io_netty_example_localtime_LocalTime_fieldAccessorTable = new </a> 0
<a> com . google . protobuf . GeneratedMessage . FieldAccessorTable ( </a> 0
<a> internal_static_io_netty_example_localtime_LocalTime_descriptor , </a> 0
<a> new java . lang . String [ ] { "Year" , "Month" , "DayOfMonth" , "DayOfWeek" , "Hour" , "Minute" , "Second" , } , </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTime . class , </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTime . Builder . class ) ; </a> 0
<a> internal_static_io_netty_example_localtime_LocalTimes_descriptor = </a> 0
<a> getDescriptor ( ) . getMessageTypes ( ) . get ( 3 ) ; </a> 0
<a> internal_static_io_netty_example_localtime_LocalTimes_fieldAccessorTable = new </a> 0
<a> com . google . protobuf . GeneratedMessage . FieldAccessorTable ( </a> 0
<a> internal_static_io_netty_example_localtime_LocalTimes_descriptor , </a> 0
<a> new java . lang . String [ ] { "LocalTime" , } , </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTimes . class , </a> 0
<a> io . netty . example . localtime . LocalTimeProtocol . LocalTimes . Builder . class ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> com . google . protobuf . Descriptors . FileDescriptor </a> 0
<a> . internalBuildGeneratedFileFrom ( descriptorData , </a> 0
<a> new com . google . protobuf . Descriptors . FileDescriptor [ ] { </a> 0
<a> } , assigner ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . localtime ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> public class LocalTimeServer { </a> 0
<a> private final int port ; </a> 1
<a> public LocalTimeServer ( int port ) { </a> 0
<a> this . port = port ; </a> 1
<a> } </a> 0
<a> public void run ( ) throws Exception { </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . localAddress ( port ) </a> 0
<a> . childHandler ( new LocalTimeServerInitializer ( ) ) ; </a> 0
<a> b . bind ( ) . sync ( ) . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8080 ; </a> 1
<a> } </a> 1
<a> new LocalTimeServer ( port ) . run ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . localtime ; </a> 0
<a> import static java . util . Calendar . * ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . example . localtime . LocalTimeProtocol . Continent ; </a> 0
<a> import io . netty . example . localtime . LocalTimeProtocol . DayOfWeek ; </a> 0
<a> import io . netty . example . localtime . LocalTimeProtocol . LocalTime ; </a> 0
<a> import io . netty . example . localtime . LocalTimeProtocol . LocalTimes ; </a> 0
<a> import io . netty . example . localtime . LocalTimeProtocol . Location ; </a> 0
<a> import io . netty . example . localtime . LocalTimeProtocol . Locations ; </a> 0
<a> import java . util . Calendar ; </a> 0
<a> import java . util . TimeZone ; </a> 0
<a> import java . util . logging . Level ; </a> 1
<a> import java . util . logging . Logger ; </a> 1
<a> public class LocalTimeServerHandler extends ChannelInboundMessageHandlerAdapter < Locations > { </a> 0
<a> private static final Logger logger = Logger . getLogger ( </a> 1
<a> LocalTimeServerHandler . class . getName ( ) ) ; </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , Locations locations ) throws Exception { </a> 1
<a> long currentTime = System . currentTimeMillis ( ) ; </a> 0
<a> LocalTimes . Builder builder = LocalTimes . newBuilder ( ) ; </a> 0
<a> for ( Location l : locations . getLocationList ( ) ) { </a> 0
<a> TimeZone tz = TimeZone . getTimeZone ( </a> 0
<a> toString ( l . getContinent ( ) ) + '/' + l . getCity ( ) ) ; </a> 0
<a> Calendar calendar = Calendar . getInstance ( tz ) ; </a> 0
<a> calendar . setTimeInMillis ( currentTime ) ; </a> 0
<a> builder . addLocalTime ( LocalTime . newBuilder ( ) . </a> 0
<a> setYear ( calendar . get ( YEAR ) ) . </a> 0
<a> setMonth ( calendar . get ( MONTH ) + 1 ) . </a> 0
<a> setDayOfMonth ( calendar . get ( DAY_OF_MONTH ) ) . </a> 0
<a> setDayOfWeek ( DayOfWeek . valueOf ( calendar . get ( DAY_OF_WEEK ) ) ) . </a> 0
<a> setHour ( calendar . get ( HOUR_OF_DAY ) ) . </a> 0
<a> setMinute ( calendar . get ( MINUTE ) ) . </a> 0
<a> setSecond ( calendar . get ( SECOND ) ) . build ( ) ) ; </a> 0
<a> } </a> 0
<a> ctx . write ( builder . build ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> logger . log ( </a> 1
<a> Level . WARNING , </a> 1
<a> "Unexpected exception from downstream." , cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> private static String toString ( Continent c ) { </a> 0
<a> return c . name ( ) . charAt ( 0 ) + c . name ( ) . toLowerCase ( ) . substring ( 1 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . localtime ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . protobuf . ProtobufDecoder ; </a> 0
<a> import io . netty . handler . codec . protobuf . ProtobufEncoder ; </a> 0
<a> import io . netty . handler . codec . protobuf . ProtobufVarint32FrameDecoder ; </a> 0
<a> import io . netty . handler . codec . protobuf . ProtobufVarint32LengthFieldPrepender ; </a> 0
<a> public class LocalTimeServerInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 0
<a> ChannelPipeline p = ch . pipeline ( ) ; </a> 0
<a> p . addLast ( "frameDecoder" , new ProtobufVarint32FrameDecoder ( ) ) ; </a> 0
<a> p . addLast ( "protobufDecoder" , new ProtobufDecoder ( LocalTimeProtocol . Locations . getDefaultInstance ( ) ) ) ; </a> 0
<a> p . addLast ( "frameEncoder" , new ProtobufVarint32LengthFieldPrepender ( ) ) ; </a> 0
<a> p . addLast ( "protobufEncoder" , new ProtobufEncoder ( ) ) ; </a> 0
<a> p . addLast ( "handler" , new LocalTimeServerHandler ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . objectecho ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . logging . Level ; </a> 1
<a> import java . util . logging . Logger ; </a> 1
<a> public class ObjectEchoClientHandler extends ChannelInboundMessageHandlerAdapter < List < Integer > > { </a> 1
<a> private static final Logger logger = Logger . getLogger ( </a> 1
<a> ObjectEchoClientHandler . class . getName ( ) ) ; </a> 1
<a> private final List < Integer > firstMessage ; </a> 0
<a> public ObjectEchoClientHandler ( int firstMessageSize ) { </a> 1
<a> if ( firstMessageSize <= 0 ) { </a> 1
<a> throw new IllegalArgumentException ( </a> 1
<a> "firstMessageSize: " + firstMessageSize ) ; </a> 1
<a> } </a> 1
<a> firstMessage = new ArrayList < Integer > ( firstMessageSize ) ; </a> 1
<a> for ( int i = 0 ; i < firstMessageSize ; i ++ ) { </a> 1
<a> firstMessage . add ( Integer . valueOf ( i ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> ctx . write ( firstMessage ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , List < Integer > msg ) throws Exception { </a> 1
<a> ctx . write ( msg ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( </a> 1
<a> ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> logger . log ( </a> 1
<a> Level . WARNING , </a> 1
<a> "Unexpected exception from downstream." , cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . objectecho ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> import io . netty . example . echo . EchoServer ; </a> 0
<a> import io . netty . handler . codec . serialization . ClassResolvers ; </a> 0
<a> import io . netty . handler . codec . serialization . ObjectDecoder ; </a> 0
<a> import io . netty . handler . codec . serialization . ObjectEncoder ; </a> 0
<a> public class ObjectEchoServer { </a> 1
<a> private final int port ; </a> 1
<a> public ObjectEchoServer ( int port ) { </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 0
<a> public void run ( ) throws Exception { </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . localAddress ( port ) </a> 0
<a> . childHandler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 0
<a> ch . pipeline ( ) . addLast ( </a> 1
<a> new ObjectEncoder ( ) , </a> 0
<a> new ObjectDecoder ( ClassResolvers . cacheDisabled ( null ) ) , </a> 0
<a> new ObjectEchoServerHandler ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> b . bind ( ) . sync ( ) . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8080 ; </a> 1
<a> } </a> 1
<a> new ObjectEchoServer ( port ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . objectecho ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import java . util . List ; </a> 1
<a> import java . util . logging . Level ; </a> 0
<a> import java . util . logging . Logger ; </a> 0
<a> public class ObjectEchoServerHandler extends ChannelInboundMessageHandlerAdapter < List < Integer > > { </a> 1
<a> private static final Logger logger = Logger . getLogger ( </a> 0
<a> ObjectEchoServerHandler . class . getName ( ) ) ; </a> 1
<a> @ Override </a> 0
<a> public void messageReceived ( </a> 0
<a> ChannelHandlerContext ctx , List < Integer > msg ) throws Exception { </a> 1
<a> ctx . write ( msg ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( </a> 0
<a> ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> logger . log ( </a> 0
<a> Level . WARNING , </a> 0
<a> "Unexpected exception from downstream." , cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . portunification ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> public class PortUnificationServer { </a> 1
<a> private final int port ; </a> 1
<a> public PortUnificationServer ( int port ) { </a> 0
<a> this . port = port ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . localAddress ( port ) </a> 0
<a> . childHandler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 0
<a> ch . pipeline ( ) . addLast ( new PortUnificationServerHandler ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> b . bind ( ) . sync ( ) . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8080 ; </a> 1
<a> } </a> 1
<a> new PortUnificationServer ( port ) . run ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . portunification ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 1
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . example . factorial . BigIntegerDecoder ; </a> 0
<a> import io . netty . example . factorial . FactorialServerHandler ; </a> 0
<a> import io . netty . example . factorial . NumberEncoder ; </a> 0
<a> import io . netty . example . http . snoop . HttpSnoopServerHandler ; </a> 0
<a> import io . netty . example . securechat . SecureChatSslContextFactory ; </a> 0
<a> import io . netty . handler . codec . compression . ZlibCodecFactory ; </a> 0
<a> import io . netty . handler . codec . compression . ZlibWrapper ; </a> 0
<a> import io . netty . handler . codec . http . HttpContentCompressor ; </a> 0
<a> import io . netty . handler . codec . http . HttpRequestDecoder ; </a> 0
<a> import io . netty . handler . codec . http . HttpResponseEncoder ; </a> 0
<a> import io . netty . handler . ssl . SslHandler ; </a> 0
<a> import javax . net . ssl . SSLEngine ; </a> 0
<a> public class PortUnificationServerHandler extends ChannelInboundByteHandlerAdapter { </a> 1
<a> private final boolean detectSsl ; </a> 0
<a> private final boolean detectGzip ; </a> 0
<a> public PortUnificationServerHandler ( ) { </a> 0
<a> this ( true , true ) ; </a> 0
<a> } </a> 0
<a> private PortUnificationServerHandler ( boolean detectSsl , boolean detectGzip ) { </a> 0
<a> this . detectSsl = detectSsl ; </a> 0
<a> this . detectGzip = detectGzip ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 1
<a> if ( in . readableBytes ( ) < 2 ) { </a> 1
<a> return ; </a> 0
<a> } </a> 0
<a> final int magic1 = in . getUnsignedByte ( in . readerIndex ( ) ) ; </a> 0
<a> final int magic2 = in . getUnsignedByte ( in . readerIndex ( ) + 1 ) ; </a> 0
<a> if ( isSsl ( magic1 ) ) { </a> 1
<a> enableSsl ( ctx ) ; </a> 1
<a> } else if ( isGzip ( magic1 , magic2 ) ) { </a> 1
<a> enableGzip ( ctx ) ; </a> 0
<a> } else if ( isHttp ( magic1 , magic2 ) ) { </a> 0
<a> switchToHttp ( ctx ) ; </a> 0
<a> } else if ( isFactorial ( magic1 ) ) { </a> 0
<a> switchToFactorial ( ctx ) ; </a> 0
<a> } else { </a> 0
<a> in . clear ( ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> ctx . nextInboundByteBuffer ( ) . writeBytes ( in ) ; </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 0
<a> } </a> 0
<a> private boolean isSsl ( int magic1 ) { </a> 1
<a> if ( detectSsl ) { </a> 0
<a> switch ( magic1 ) { </a> 1
<a> case 20 : case 21 : case 22 : case 23 : case 255 : </a> 1
<a> return true ; </a> 1
<a> default : </a> 1
<a> return magic1 >= 128 ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private boolean isGzip ( int magic1 , int magic2 ) { </a> 0
<a> if ( detectGzip ) { </a> 0
<a> return magic1 == 31 && magic2 == 139 ; </a> 0
<a> } </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private static boolean isHttp ( int magic1 , int magic2 ) { </a> 0
<a> return </a> 0
<a> magic1 == 'G' && magic2 == 'E' || </a> 0
<a> magic1 == 'P' && magic2 == 'O' || </a> 0
<a> magic1 == 'P' && magic2 == 'U' || </a> 0
<a> magic1 == 'H' && magic2 == 'E' || </a> 0
<a> magic1 == 'O' && magic2 == 'P' || </a> 0
<a> magic1 == 'P' && magic2 == 'A' || </a> 0
<a> magic1 == 'D' && magic2 == 'E' || </a> 0
<a> magic1 == 'T' && magic2 == 'R' || </a> 0
<a> magic1 == 'C' && magic2 == 'O' ; </a> 0
<a> } </a> 0
<a> private static boolean isFactorial ( int magic1 ) { </a> 0
<a> return magic1 == 'F' ; </a> 0
<a> } </a> 0
<a> private void enableSsl ( ChannelHandlerContext ctx ) { </a> 0
<a> ChannelPipeline p = ctx . pipeline ( ) ; </a> 0
<a> SSLEngine engine = </a> 0
<a> SecureChatSslContextFactory . getServerContext ( ) . createSSLEngine ( ) ; </a> 0
<a> engine . setUseClientMode ( false ) ; </a> 0
<a> p . addLast ( "ssl" , new SslHandler ( engine ) ) ; </a> 0
<a> p . addLast ( "unificationA" , new PortUnificationServerHandler ( false , detectGzip ) ) ; </a> 0
<a> p . remove ( this ) ; </a> 0
<a> } </a> 0
<a> private void enableGzip ( ChannelHandlerContext ctx ) { </a> 0
<a> ChannelPipeline p = ctx . pipeline ( ) ; </a> 0
<a> p . addLast ( "gzipdeflater" , ZlibCodecFactory . newZlibEncoder ( ZlibWrapper . GZIP ) ) ; </a> 0
<a> p . addLast ( "gzipinflater" , ZlibCodecFactory . newZlibDecoder ( ZlibWrapper . GZIP ) ) ; </a> 0
<a> p . addLast ( "unificationB" , new PortUnificationServerHandler ( detectSsl , false ) ) ; </a> 0
<a> p . remove ( this ) ; </a> 0
<a> } </a> 0
<a> private void switchToHttp ( ChannelHandlerContext ctx ) { </a> 0
<a> ChannelPipeline p = ctx . pipeline ( ) ; </a> 0
<a> p . addLast ( "decoder" , new HttpRequestDecoder ( ) ) ; </a> 0
<a> p . addLast ( "encoder" , new HttpResponseEncoder ( ) ) ; </a> 0
<a> p . addLast ( "deflater" , new HttpContentCompressor ( ) ) ; </a> 0
<a> p . addLast ( "handler" , new HttpSnoopServerHandler ( ) ) ; </a> 0
<a> p . remove ( this ) ; </a> 0
<a> } </a> 0
<a> private void switchToFactorial ( ChannelHandlerContext ctx ) { </a> 0
<a> ChannelPipeline p = ctx . pipeline ( ) ; </a> 0
<a> p . addLast ( "decoder" , new BigIntegerDecoder ( ) ) ; </a> 0
<a> p . addLast ( "encoder" , new NumberEncoder ( ) ) ; </a> 0
<a> p . addLast ( "handler" , new FactorialServerHandler ( ) ) ; </a> 0
<a> p . remove ( this ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . proxy ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> public class HexDumpProxy { </a> 1
<a> private final int localPort ; </a> 1
<a> private final String remoteHost ; </a> 1
<a> private final int remotePort ; </a> 1
<a> public HexDumpProxy ( int localPort , String remoteHost , int remotePort ) { </a> 1
<a> this . localPort = localPort ; </a> 1
<a> this . remoteHost = remoteHost ; </a> 1
<a> this . remotePort = remotePort ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> System . err . println ( </a> 1
<a> "Proxying *:" + localPort + " to " + </a> 1
<a> remoteHost + ':' + remotePort + " ..." ) ; </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 1
<a> . localAddress ( localPort ) </a> 1
<a> . childHandler ( new HexDumpProxyInitializer ( remoteHost , remotePort ) ) ; </a> 0
<a> b . bind ( ) . sync ( ) . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> if ( args . length != 3 ) { </a> 0
<a> System . err . println ( </a> 0
<a> "Usage: " + HexDumpProxy . class . getSimpleName ( ) + </a> 0
<a> " <local port> <remote host> <remote port>" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> int localPort = Integer . parseInt ( args [ 0 ] ) ; </a> 0
<a> String remoteHost = args [ 1 ] ; </a> 0
<a> int remotePort = Integer . parseInt ( args [ 2 ] ) ; </a> 0
<a> new HexDumpProxy ( localPort , remoteHost , remotePort ) . run ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . proxy ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 1
<a> public class HexDumpProxyBackendHandler extends ChannelInboundByteHandlerAdapter { </a> 1
<a> private final Channel inboundChannel ; </a> 0
<a> public HexDumpProxyBackendHandler ( Channel inboundChannel ) { </a> 0
<a> this . inboundChannel = inboundChannel ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> ctx . flush ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 0
<a> ByteBuf out = inboundChannel . outboundByteBuffer ( ) ; </a> 1
<a> out . discardReadBytes ( ) ; </a> 0
<a> out . writeBytes ( in ) ; </a> 1
<a> in . clear ( ) ; </a> 0
<a> inboundChannel . flush ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> HexDumpProxyFrontendHandler . closeOnFlush ( inboundChannel ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> cause . printStackTrace ( ) ; </a> 0
<a> HexDumpProxyFrontendHandler . closeOnFlush ( ctx . channel ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . qotm ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelOption ; </a> 0
<a> import io . netty . channel . socket . DatagramPacket ; </a> 0
<a> import io . netty . channel . socket . nio . NioDatagramChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> public class QuoteOfTheMomentClient { </a> 1
<a> private final int port ; </a> 1
<a> public QuoteOfTheMomentClient ( int port ) { </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> Bootstrap b = new Bootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioDatagramChannel ( ) ) </a> 0
<a> . localAddress ( new InetSocketAddress ( 0 ) ) </a> 0
<a> . option ( ChannelOption . SO_BROADCAST , true ) </a> 0
<a> . handler ( new QuoteOfTheMomentClientHandler ( ) ) ; </a> 0
<a> Channel ch = b . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> ch . write ( new DatagramPacket ( </a> 0
<a> Unpooled . copiedBuffer ( "QOTM?" , CharsetUtil . UTF_8 ) , </a> 0
<a> new InetSocketAddress ( "255.255.255.255" , port ) ) ) ; </a> 1
<a> if ( ! ch . closeFuture ( ) . await ( 5000 ) ) { </a> 0
<a> System . err . println ( "QOTM request timed out." ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8080 ; </a> 1
<a> } </a> 1
<a> new QuoteOfTheMomentClient ( port ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . qotm ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . socket . DatagramPacket ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> public class QuoteOfTheMomentClientHandler extends ChannelInboundMessageHandlerAdapter < DatagramPacket > { </a> 1
<a> @ Override </a> 0
<a> public void messageReceived ( </a> 1
<a> ChannelHandlerContext ctx , DatagramPacket msg ) </a> 1
<a> throws Exception { </a> 1
<a> String response = msg . data ( ) . toString ( CharsetUtil . UTF_8 ) ; </a> 1
<a> if ( response . startsWith ( "QOTM: " ) ) { </a> 0
<a> System . out . println ( "Quote of the Moment: " + response . substring ( 6 ) ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( </a> 0
<a> ChannelHandlerContext ctx , Throwable cause ) </a> 0
<a> throws Exception { </a> 0
<a> cause . printStackTrace ( ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . qotm ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . channel . ChannelOption ; </a> 0
<a> import io . netty . channel . socket . nio . NioDatagramChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> public class QuoteOfTheMomentServer { </a> 1
<a> private final int port ; </a> 1
<a> public QuoteOfTheMomentServer ( int port ) { </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> Bootstrap b = new Bootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioDatagramChannel ( ) ) </a> 0
<a> . localAddress ( new InetSocketAddress ( port ) ) </a> 0
<a> . option ( ChannelOption . SO_BROADCAST , true ) </a> 0
<a> . handler ( new QuoteOfTheMomentServerHandler ( ) ) ; </a> 0
<a> b . bind ( ) . sync ( ) . channel ( ) . closeFuture ( ) . await ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8080 ; </a> 1
<a> } </a> 1
<a> new QuoteOfTheMomentServer ( port ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . qotm ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . socket . DatagramPacket ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . util . Random ; </a> 0
<a> public class QuoteOfTheMomentServerHandler extends ChannelInboundMessageHandlerAdapter < DatagramPacket > { </a> 1
<a> private static final Random random = new Random ( ) ; </a> 0
<a> private static final String [ ] quotes = { </a> 0
<a> "Where there is love there is life." , </a> 0
<a> "First they ignore you, then they laugh at you, then they fight you, then you win." , </a> 0
<a> "Be the change you want to see in the world." , </a> 0
<a> "The weak can never forgive. Forgiveness is the attribute of the strong." , </a> 0
<a> } ; </a> 0
<a> private static String nextQuote ( ) { </a> 0
<a> int quoteId ; </a> 0
<a> synchronized ( random ) { </a> 0
<a> quoteId = random . nextInt ( quotes . length ) ; </a> 0
<a> } </a> 0
<a> return quotes [ quoteId ] ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( </a> 1
<a> ChannelHandlerContext ctx , DatagramPacket msg ) </a> 1
<a> throws Exception { </a> 1
<a> if ( msg . data ( ) . toString ( CharsetUtil . UTF_8 ) . equals ( "QOTM?" ) ) { </a> 0
<a> ctx . write ( new DatagramPacket ( </a> 0
<a> Unpooled . copiedBuffer ( "QOTM: " + nextQuote ( ) , CharsetUtil . UTF_8 ) , </a> 1
<a> msg . remoteAddress ( ) ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( </a> 1
<a> ChannelHandlerContext ctx , Throwable cause ) </a> 1
<a> throws Exception { </a> 1
<a> cause . printStackTrace ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . securechat ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioSocketChannel ; </a> 0
<a> import io . netty . example . telnet . TelnetClient ; </a> 0
<a> import java . io . BufferedReader ; </a> 0
<a> import java . io . InputStreamReader ; </a> 0
<a> public class SecureChatClient { </a> 1
<a> private final String host ; </a> 1
<a> private final int port ; </a> 1
<a> public SecureChatClient ( String host , int port ) { </a> 0
<a> this . host = host ; </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 1
<a> public void run ( ) throws Exception { </a> 1
<a> Bootstrap b = new Bootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioSocketChannel ( ) ) </a> 0
<a> . remoteAddress ( host , port ) </a> 0
<a> . handler ( new SecureChatClientInitializer ( ) ) ; </a> 0
<a> Channel ch = b . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> ChannelFuture lastWriteFuture = null ; </a> 0
<a> BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> String line = in . readLine ( ) ; </a> 0
<a> if ( line == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> lastWriteFuture = ch . write ( line + "\r\n" ) ; </a> 0
<a> if ( line . toLowerCase ( ) . equals ( "bye" ) ) { </a> 0
<a> ch . closeFuture ( ) . sync ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( lastWriteFuture != null ) { </a> 0
<a> lastWriteFuture . sync ( ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> if ( args . length != 2 ) { </a> 0
<a> System . err . println ( </a> 0
<a> "Usage: " + SecureChatClient . class . getSimpleName ( ) + </a> 0
<a> " <host> <port>" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> String host = args [ 0 ] ; </a> 0
<a> int port = Integer . parseInt ( args [ 1 ] ) ; </a> 0
<a> new SecureChatClient ( host , port ) . run ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . securechat ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import java . util . logging . Level ; </a> 1
<a> import java . util . logging . Logger ; </a> 1
<a> public class SecureChatClientHandler extends ChannelInboundMessageHandlerAdapter < String > { </a> 1
<a> private static final Logger logger = Logger . getLogger ( </a> 1
<a> SecureChatClientHandler . class . getName ( ) ) ; </a> 1
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , String msg ) throws Exception { </a> 1
<a> System . err . println ( msg ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> logger . log ( </a> 1
<a> Level . WARNING , </a> 1
<a> "Unexpected exception from downstream." , cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . securechat ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . DelimiterBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . Delimiters ; </a> 0
<a> import io . netty . handler . codec . string . StringDecoder ; </a> 0
<a> import io . netty . handler . codec . string . StringEncoder ; </a> 0
<a> import io . netty . handler . ssl . SslHandler ; </a> 0
<a> import javax . net . ssl . SSLEngine ; </a> 0
<a> public class SecureChatClientInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 0
<a> ChannelPipeline pipeline = ch . pipeline ( ) ; </a> 0
<a> SSLEngine engine = </a> 0
<a> SecureChatSslContextFactory . getClientContext ( ) . createSSLEngine ( ) ; </a> 0
<a> engine . setUseClientMode ( true ) ; </a> 0
<a> pipeline . addLast ( "ssl" , new SslHandler ( engine ) ) ; </a> 0
<a> pipeline . addLast ( "framer" , new DelimiterBasedFrameDecoder ( </a> 0
<a> 8192 , Delimiters . lineDelimiter ( ) ) ) ; </a> 0
<a> pipeline . addLast ( "decoder" , new StringDecoder ( ) ) ; </a> 0
<a> pipeline . addLast ( "encoder" , new StringEncoder ( ) ) ; </a> 0
<a> pipeline . addLast ( "handler" , new SecureChatClientHandler ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . securechat ; </a> 0
<a> import java . security . InvalidAlgorithmParameterException ; </a> 0
<a> import java . security . KeyStore ; </a> 0
<a> import java . security . KeyStoreException ; </a> 0
<a> import java . security . cert . CertificateException ; </a> 0
<a> import java . security . cert . X509Certificate ; </a> 0
<a> import javax . net . ssl . ManagerFactoryParameters ; </a> 0
<a> import javax . net . ssl . TrustManager ; </a> 1
<a> import javax . net . ssl . TrustManagerFactorySpi ; </a> 1
<a> import javax . net . ssl . X509TrustManager ; </a> 1
<a> public class SecureChatTrustManagerFactory extends TrustManagerFactorySpi { </a> 0
<a> private static final TrustManager DUMMY_TRUST_MANAGER = new X509TrustManager ( ) { </a> 0
<a> @ Override </a> 0
<a> public X509Certificate [ ] getAcceptedIssuers ( ) { </a> 0
<a> return new X509Certificate [ 0 ] ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void checkClientTrusted ( </a> 0
<a> X509Certificate [ ] chain , String authType ) throws CertificateException { </a> 0
<a> System . err . println ( </a> 0
<a> "UNKNOWN CLIENT CERTIFICATE: " + chain [ 0 ] . getSubjectDN ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void checkServerTrusted ( </a> 0
<a> X509Certificate [ ] chain , String authType ) throws CertificateException { </a> 0
<a> System . err . println ( </a> 0
<a> "UNKNOWN SERVER CERTIFICATE: " + chain [ 0 ] . getSubjectDN ( ) ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> public static TrustManager [ ] getTrustManagers ( ) { </a> 0
<a> return new TrustManager [ ] { DUMMY_TRUST_MANAGER } ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected TrustManager [ ] engineGetTrustManagers ( ) { </a> 0
<a> return getTrustManagers ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void engineInit ( KeyStore keystore ) throws KeyStoreException { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void engineInit ( ManagerFactoryParameters managerFactoryParameters ) </a> 0
<a> throws InvalidAlgorithmParameterException { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . telnet ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import java . util . logging . Level ; </a> 1
<a> import java . util . logging . Logger ; </a> 1
<a> @ Sharable </a> 0
<a> public class TelnetClientHandler extends ChannelInboundMessageHandlerAdapter < String > { </a> 1
<a> private static final Logger logger = Logger . getLogger ( </a> 0
<a> TelnetClientHandler . class . getName ( ) ) ; </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , String msg ) throws Exception { </a> 1
<a> System . err . println ( msg ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> logger . log ( </a> 1
<a> Level . WARNING , </a> 1
<a> "Unexpected exception from downstream." , cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . telnet ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . DelimiterBasedFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . Delimiters ; </a> 0
<a> import io . netty . handler . codec . string . StringDecoder ; </a> 0
<a> import io . netty . handler . codec . string . StringEncoder ; </a> 0
<a> public class TelnetClientInitializer extends ChannelInitializer < SocketChannel > { </a> 0
<a> private static final StringDecoder DECODER = new StringDecoder ( ) ; </a> 0
<a> private static final StringEncoder ENCODER = new StringEncoder ( ) ; </a> 0
<a> private static final TelnetClientHandler CLIENTHANDLER = new TelnetClientHandler ( ) ; </a> 1
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 1
<a> ChannelPipeline pipeline = ch . pipeline ( ) ; </a> 0
<a> pipeline . addLast ( "framer" , new DelimiterBasedFrameDecoder ( </a> 1
<a> 8192 , Delimiters . lineDelimiter ( ) ) ) ; </a> 1
<a> pipeline . addLast ( "decoder" , DECODER ) ; </a> 1
<a> pipeline . addLast ( "encoder" , ENCODER ) ; </a> 1
<a> pipeline . addLast ( "handler" , CLIENTHANDLER ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . telnet ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> public class TelnetServer { </a> 1
<a> private final int port ; </a> 1
<a> public TelnetServer ( int port ) { </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 0
<a> public void run ( ) throws Exception { </a> 1
<a> ServerBootstrap b = new ServerBootstrap ( ) ; </a> 0
<a> try { </a> 0
<a> b . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) </a> 0
<a> . channel ( new NioServerSocketChannel ( ) ) </a> 0
<a> . localAddress ( port ) </a> 0
<a> . childHandler ( new TelnetServerPipelineFactory ( ) ) ; </a> 1
<a> b . bind ( ) . sync ( ) . channel ( ) . closeFuture ( ) . sync ( ) ; </a> 0
<a> } finally { </a> 0
<a> b . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 1
<a> int port ; </a> 1
<a> if ( args . length > 0 ) { </a> 1
<a> port = Integer . parseInt ( args [ 0 ] ) ; </a> 1
<a> } else { </a> 1
<a> port = 8080 ; </a> 1
<a> } </a> 1
<a> new TelnetServer ( port ) . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . telnet ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import java . net . InetAddress ; </a> 0
<a> import java . util . Date ; </a> 0
<a> import java . util . logging . Level ; </a> 1
<a> import java . util . logging . Logger ; </a> 1
<a> @ Sharable </a> 0
<a> public class TelnetServerHandler extends ChannelInboundMessageHandlerAdapter < String > { </a> 1
<a> private static final Logger logger = Logger . getLogger ( </a> 0
<a> TelnetServerHandler . class . getName ( ) ) ; </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> ctx . write ( </a> 1
<a> "Welcome to " + InetAddress . getLocalHost ( ) . getHostName ( ) + "!\r\n" ) ; </a> 1
<a> ctx . write ( "It is " + new Date ( ) + " now.\r\n" ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , String request ) throws Exception { </a> 1
<a> String response ; </a> 0
<a> boolean close = false ; </a> 0
<a> if ( request . length ( ) == 0 ) { </a> 0
<a> response = "Please type something.\r\n" ; </a> 0
<a> } else if ( request . toLowerCase ( ) . equals ( "bye" ) ) { </a> 0
<a> response = "Have a good day!\r\n" ; </a> 0
<a> close = true ; </a> 0
<a> } else { </a> 0
<a> response = "Did you say '" + request + "'?\r\n" ; </a> 0
<a> } </a> 0
<a> ChannelFuture future = ctx . write ( response ) ; </a> 0
<a> if ( close ) { </a> 0
<a> future . addListener ( ChannelFutureListener . CLOSE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> logger . log ( </a> 1
<a> Level . WARNING , </a> 1
<a> "Unexpected exception from downstream." , cause ) ; </a> 1
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . telnet ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 1
<a> import io . netty . channel . ChannelPipeline ; </a> 1
<a> import io . netty . channel . socket . SocketChannel ; </a> 1
<a> import io . netty . handler . codec . DelimiterBasedFrameDecoder ; </a> 1
<a> import io . netty . handler . codec . Delimiters ; </a> 1
<a> import io . netty . handler . codec . string . StringDecoder ; </a> 1
<a> import io . netty . handler . codec . string . StringEncoder ; </a> 1
<a> public class TelnetServerPipelineFactory extends ChannelInitializer < SocketChannel > { </a> 1
<a> private static final StringDecoder DECODER = new StringDecoder ( ) ; </a> 1
<a> private static final StringEncoder ENCODER = new StringEncoder ( ) ; </a> 0
<a> private static final TelnetServerHandler SERVERHANDLER = new TelnetServerHandler ( ) ; </a> 1
<a> @ Override </a> 1
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 1
<a> ChannelPipeline pipeline = ch . pipeline ( ) ; </a> 1
<a> pipeline . addLast ( "framer" , new DelimiterBasedFrameDecoder ( </a> 0
<a> 8192 , Delimiters . lineDelimiter ( ) ) ) ; </a> 0
<a> pipeline . addLast ( "decoder" , DECODER ) ; </a> 1
<a> pipeline . addLast ( "encoder" , ENCODER ) ; </a> 1
<a> pipeline . addLast ( "handler" , SERVERHANDLER ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . uptime ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . EventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioSocketChannel ; </a> 0
<a> import io . netty . handler . timeout . IdleStateHandler ; </a> 0
<a> public class UptimeClient { </a> 1
<a> static final int RECONNECT_DELAY = 5 ; </a> 1
<a> private static final int READ_TIMEOUT = 10 ; </a> 1
<a> private final String host ; </a> 1
<a> private final int port ; </a> 1
<a> private final UptimeClientHandler handler = new UptimeClientHandler ( this ) ; </a> 1
<a> public UptimeClient ( String host , int port ) { </a> 1
<a> this . host = host ; </a> 1
<a> this . port = port ; </a> 1
<a> } </a> 1
<a> public void run ( ) { </a> 1
<a> configureBootstrap ( new Bootstrap ( ) ) . connect ( ) ; </a> 0
<a> } </a> 0
<a> private Bootstrap configureBootstrap ( Bootstrap b ) { </a> 0
<a> return configureBootstrap ( b , new NioEventLoopGroup ( ) ) ; </a> 0
<a> } </a> 0
<a> Bootstrap configureBootstrap ( Bootstrap b , EventLoopGroup g ) { </a> 0
<a> b . group ( g ) </a> 0
<a> . channel ( new NioSocketChannel ( ) ) </a> 0
<a> . remoteAddress ( host , port ) </a> 1
<a> . handler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel ch ) throws Exception { </a> 0
<a> ch . pipeline ( ) . addLast ( new IdleStateHandler ( READ_TIMEOUT , 0 , 0 ) , handler ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> return b ; </a> 0
<a> } </a> 0
<a> public static void main ( String [ ] args ) throws Exception { </a> 0
<a> if ( args . length != 2 ) { </a> 0
<a> System . err . println ( </a> 0
<a> "Usage: " + UptimeClient . class . getSimpleName ( ) + </a> 0
<a> " <host> <port>" ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> String host = args [ 0 ] ; </a> 0
<a> int port = Integer . parseInt ( args [ 1 ] ) ; </a> 0
<a> new UptimeClient ( host , port ) . run ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . example . uptime ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 1
<a> import io . netty . channel . EventLoop ; </a> 0
<a> import io . netty . handler . timeout . IdleState ; </a> 0
<a> import io . netty . handler . timeout . IdleStateEvent ; </a> 0
<a> import java . net . ConnectException ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> @ Sharable </a> 0
<a> public class UptimeClientHandler extends ChannelInboundByteHandlerAdapter { </a> 1
<a> private final UptimeClient client ; </a> 1
<a> private long startTime = - 1 ; </a> 1
<a> public UptimeClientHandler ( UptimeClient client ) { </a> 1
<a> this . client = client ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> if ( startTime < 0 ) { </a> 0
<a> startTime = System . currentTimeMillis ( ) ; </a> 0
<a> } </a> 0
<a> println ( "Connected to: " + ctx . channel ( ) . remoteAddress ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 1
<a> in . clear ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception { </a> 1
<a> if ( ! ( evt instanceof IdleStateEvent ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> IdleStateEvent e = ( IdleStateEvent ) evt ; </a> 0
<a> if ( e . state ( ) == IdleState . READER_IDLE ) { </a> 0
<a> println ( "Disconnecting due to no inbound traffic" ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> println ( "Disconnected from: " + ctx . channel ( ) . remoteAddress ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelUnregistered ( final ChannelHandlerContext ctx ) </a> 0
<a> throws Exception { </a> 0
<a> println ( "Sleeping for: " + UptimeClient . RECONNECT_DELAY + "s" ) ; </a> 0
<a> final EventLoop loop = ctx . channel ( ) . eventLoop ( ) ; </a> 0
<a> loop . schedule ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> println ( "Reconnecting to: " + ctx . channel ( ) . remoteAddress ( ) ) ; </a> 1
<a> client . configureBootstrap ( new Bootstrap ( ) , loop ) . connect ( ) ; </a> 1
<a> } </a> 0
<a> } , UptimeClient . RECONNECT_DELAY , TimeUnit . SECONDS ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> if ( cause instanceof ConnectException ) { </a> 1
<a> startTime = - 1 ; </a> 1
<a> println ( "Failed to connect: " + cause . getMessage ( ) ) ; </a> 1
<a> } </a> 1
<a> cause . printStackTrace ( ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> void println ( String msg ) { </a> 0
<a> if ( startTime < 0 ) { </a> 0
<a> System . err . format ( "[SERVER IS DOWN] %s%n" , msg ) ; </a> 0
<a> } else { </a> 0
<a> System . err . format ( "[UPTIME: %5ds] %s%n" , ( System . currentTimeMillis ( ) - startTime ) / 1000 , msg ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . logging ; </a> 0
<a> import io . netty . logging . InternalLogLevel ; </a> 0
<a> public enum LogLevel { </a> 0
<a> TRACE ( InternalLogLevel . TRACE ) , </a> 0
<a> DEBUG ( InternalLogLevel . DEBUG ) , </a> 0
<a> INFO ( InternalLogLevel . INFO ) , </a> 0
<a> WARN ( InternalLogLevel . WARN ) , </a> 0
<a> ERROR ( InternalLogLevel . ERROR ) ; </a> 0
<a> private final InternalLogLevel internalLevel ; </a> 0
<a> LogLevel ( InternalLogLevel internalLevel ) { </a> 0
<a> this . internalLevel = internalLevel ; </a> 0
<a> } </a> 0
<a> InternalLogLevel toInternalLevel ( ) { </a> 1
<a> return internalLevel ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . logging ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . ChannelHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . logging . InternalLogLevel ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> @ Sharable </a> 0
<a> public class LoggingHandler extends ChannelHandlerAdapter { </a> 0
<a> private static final LogLevel DEFAULT_LEVEL = LogLevel . DEBUG ; </a> 0
<a> protected final InternalLogger logger ; </a> 0
<a> protected final InternalLogLevel internalLevel ; </a> 0
<a> private final LogLevel level ; </a> 0
<a> public LoggingHandler ( ) { </a> 0
<a> this ( DEFAULT_LEVEL ) ; </a> 0
<a> } </a> 0
<a> public LoggingHandler ( LogLevel level ) { </a> 1
<a> if ( level == null ) { </a> 1
<a> throw new NullPointerException ( "level" ) ; </a> 1
<a> } </a> 1
<a> logger = InternalLoggerFactory . getInstance ( getClass ( ) ) ; </a> 1
<a> this . level = level ; </a> 1
<a> internalLevel = level . toInternalLevel ( ) ; </a> 1
<a> } </a> 1
<a> public LoggingHandler ( Class < ? > clazz ) { </a> 0
<a> this ( clazz , DEFAULT_LEVEL ) ; </a> 0
<a> } </a> 0
<a> public LoggingHandler ( Class < ? > clazz , LogLevel level ) { </a> 0
<a> if ( clazz == null ) { </a> 0
<a> throw new NullPointerException ( "clazz" ) ; </a> 0
<a> } </a> 0
<a> if ( level == null ) { </a> 0
<a> throw new NullPointerException ( "level" ) ; </a> 0
<a> } </a> 0
<a> logger = InternalLoggerFactory . getInstance ( clazz ) ; </a> 0
<a> this . level = level ; </a> 0
<a> internalLevel = level . toInternalLevel ( ) ; </a> 0
<a> } </a> 0
<a> public LoggingHandler ( String name ) { </a> 0
<a> this ( name , DEFAULT_LEVEL ) ; </a> 0
<a> } </a> 0
<a> public LoggingHandler ( String name , LogLevel level ) { </a> 0
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> if ( level == null ) { </a> 0
<a> throw new NullPointerException ( "level" ) ; </a> 0
<a> } </a> 0
<a> logger = InternalLoggerFactory . getInstance ( name ) ; </a> 0
<a> this . level = level ; </a> 0
<a> internalLevel = level . toInternalLevel ( ) ; </a> 0
<a> } </a> 0
<a> public LogLevel level ( ) { </a> 0
<a> return level ; </a> 0
<a> } </a> 0
<a> protected String format ( ChannelHandlerContext ctx , String message ) { </a> 0
<a> String chStr = ctx . channel ( ) . toString ( ) ; </a> 0
<a> StringBuilder buf = new StringBuilder ( chStr . length ( ) + message . length ( ) + 1 ) ; </a> 0
<a> buf . append ( chStr ) ; </a> 0
<a> buf . append ( ' ' ) ; </a> 0
<a> buf . append ( message ) ; </a> 0
<a> return buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelRegistered ( ChannelHandlerContext ctx ) </a> 0
<a> throws Exception { </a> 0
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , "REGISTERED" ) ) ; </a> 0
<a> } </a> 0
<a> super . channelRegistered ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelUnregistered ( ChannelHandlerContext ctx ) </a> 0
<a> throws Exception { </a> 0
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , "UNREGISTERED" ) ) ; </a> 0
<a> } </a> 0
<a> super . channelUnregistered ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) </a> 0
<a> throws Exception { </a> 0
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , "ACTIVE" ) ) ; </a> 0
<a> } </a> 0
<a> super . channelActive ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) </a> 0
<a> throws Exception { </a> 0
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , "INACTIVE" ) ) ; </a> 0
<a> } </a> 0
<a> super . channelInactive ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , </a> 0
<a> Throwable cause ) throws Exception { </a> 0
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , "EXCEPTION: " + cause ) , cause ) ; </a> 0
<a> } </a> 0
<a> super . exceptionCaught ( ctx , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void userEventTriggered ( ChannelHandlerContext ctx , </a> 0
<a> Object evt ) throws Exception { </a> 0
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , "USER_EVENT: " + evt ) ) ; </a> 0
<a> } </a> 0
<a> super . userEventTriggered ( ctx , evt ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void bind ( ChannelHandlerContext ctx , </a> 0
<a> SocketAddress localAddress , ChannelFuture future ) throws Exception { </a> 0
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , "BIND(" + localAddress + ')' ) ) ; </a> 0
<a> } </a> 0
<a> super . bind ( ctx , localAddress , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void connect ( ChannelHandlerContext ctx , </a> 0
<a> SocketAddress remoteAddress , SocketAddress localAddress , </a> 0
<a> ChannelFuture future ) throws Exception { </a> 0
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , "CONNECT(" + remoteAddress + ", " + localAddress + ')' ) ) ; </a> 0
<a> } </a> 0
<a> super . connect ( ctx , remoteAddress , localAddress , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void disconnect ( ChannelHandlerContext ctx , </a> 0
<a> ChannelFuture future ) throws Exception { </a> 0
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , "DISCONNECT()" ) ) ; </a> 0
<a> } </a> 0
<a> super . disconnect ( ctx , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ChannelHandlerContext ctx , </a> 0
<a> ChannelFuture future ) throws Exception { </a> 0
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , "CLOSE()" ) ) ; </a> 0
<a> } </a> 0
<a> super . close ( ctx , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void deregister ( ChannelHandlerContext ctx , </a> 0
<a> ChannelFuture future ) throws Exception { </a> 0
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , "DEREGISTER()" ) ) ; </a> 0
<a> } </a> 0
<a> super . deregister ( ctx , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( ChannelHandlerContext ctx , ChannelFuture future ) </a> 0
<a> throws Exception { </a> 1
<a> ctx . flush ( future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) </a> 0
<a> throws Exception { </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . logging ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandler ; </a> 1
<a> import io . netty . channel . ChannelOutboundMessageHandler ; </a> 1
<a> public class MessageLoggingHandler </a> 1
<a> extends LoggingHandler </a> 1
<a> implements ChannelInboundMessageHandler < Object > , ChannelOutboundMessageHandler < Object > { </a> 1
<a> public MessageLoggingHandler ( ) { } </a> 0
<a> public MessageLoggingHandler ( Class < ? > clazz , LogLevel level ) { </a> 0
<a> super ( clazz , level ) ; </a> 0
<a> } </a> 0
<a> public MessageLoggingHandler ( Class < ? > clazz ) { </a> 0
<a> super ( clazz ) ; </a> 0
<a> } </a> 0
<a> public MessageLoggingHandler ( LogLevel level ) { </a> 0
<a> super ( level ) ; </a> 0
<a> } </a> 0
<a> public MessageLoggingHandler ( String name , LogLevel level ) { </a> 0
<a> super ( name , level ) ; </a> 0
<a> } </a> 0
<a> public MessageLoggingHandler ( String name ) { </a> 0
<a> super ( name ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public MessageBuf < Object > newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return Unpooled . messageBuffer ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public MessageBuf < Object > newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . messageBuffer ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) </a> 1
<a> throws Exception { </a> 1
<a> MessageBuf < Object > buf = ctx . inboundMessageBuffer ( ) ; </a> 1
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 0
<a> logger . log ( internalLevel , format ( ctx , formatBuffer ( "RECEIVED" , buf ) ) ) ; </a> 1
<a> } </a> 0
<a> MessageBuf < Object > out = ctx . nextInboundMessageBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> Object o = buf . poll ( ) ; </a> 1
<a> if ( o == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> out . add ( o ) ; </a> 1
<a> } </a> 1
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> public void flush ( ChannelHandlerContext ctx , ChannelFuture future ) </a> 0
<a> throws Exception { </a> 1
<a> MessageBuf < Object > buf = ctx . outboundMessageBuffer ( ) ; </a> 1
<a> if ( logger . isEnabled ( internalLevel ) ) { </a> 1
<a> logger . log ( internalLevel , format ( ctx , formatBuffer ( "WRITE" , buf ) ) ) ; </a> 1
<a> } </a> 1
<a> MessageBuf < Object > out = ctx . nextOutboundMessageBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> Object o = buf . poll ( ) ; </a> 1
<a> if ( o == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 0
<a> out . add ( o ) ; </a> 1
<a> } </a> 0
<a> ctx . flush ( future ) ; </a> 0
<a> } </a> 1
<a> protected String formatBuffer ( String message , MessageBuf < Object > buf ) { </a> 1
<a> return message + '(' + buf . size ( ) + "): " + buf ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . ssl ; </a> 0
<a> import java . util . concurrent . Executor ; </a> 0
<a> final class ImmediateExecutor implements Executor { </a> 1
<a> static final ImmediateExecutor INSTANCE = new ImmediateExecutor ( ) ; </a> 0
<a> @ Override </a> 0
<a> public void execute ( Runnable command ) { </a> 0
<a> command . run ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . ssl ; </a> 0
<a> import javax . net . ssl . SSLException ; </a> 0
<a> public class NotSslRecordException extends SSLException { </a> 0
<a> private static final long serialVersionUID = - 4316784434770656841L ; </a> 0
<a> public NotSslRecordException ( ) { </a> 0
<a> super ( "" ) ; </a> 0
<a> } </a> 0
<a> public NotSslRecordException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public NotSslRecordException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> public NotSslRecordException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . ssl ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . stream ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> public interface ChunkedByteInput extends ChunkedInput < ByteBuf > { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . stream ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import java . io . File ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . RandomAccessFile ; </a> 0
<a> public class ChunkedFile implements ChunkedByteInput { </a> 0
<a> private final RandomAccessFile file ; </a> 0
<a> private final long startOffset ; </a> 0
<a> private final long endOffset ; </a> 0
<a> private final int chunkSize ; </a> 0
<a> private long offset ; </a> 0
<a> public ChunkedFile ( File file ) throws IOException { </a> 0
<a> this ( file , ChunkedStream . DEFAULT_CHUNK_SIZE ) ; </a> 0
<a> } </a> 0
<a> public ChunkedFile ( File file , int chunkSize ) throws IOException { </a> 0
<a> this ( new RandomAccessFile ( file , "r" ) , chunkSize ) ; </a> 0
<a> } </a> 0
<a> public ChunkedFile ( RandomAccessFile file ) throws IOException { </a> 0
<a> this ( file , ChunkedStream . DEFAULT_CHUNK_SIZE ) ; </a> 0
<a> } </a> 0
<a> public ChunkedFile ( RandomAccessFile file , int chunkSize ) throws IOException { </a> 0
<a> this ( file , 0 , file . length ( ) , chunkSize ) ; </a> 0
<a> } </a> 0
<a> public ChunkedFile ( RandomAccessFile file , long offset , long length , int chunkSize ) throws IOException { </a> 0
<a> if ( file == null ) { </a> 0
<a> throw new NullPointerException ( "file" ) ; </a> 0
<a> } </a> 0
<a> if ( offset < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "offset: " + offset + " (expected: 0 or greater)" ) ; </a> 0
<a> } </a> 0
<a> if ( length < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "length: " + length + " (expected: 0 or greater)" ) ; </a> 0
<a> } </a> 0
<a> if ( chunkSize <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "chunkSize: " + chunkSize + </a> 0
<a> " (expected: a positive integer)" ) ; </a> 0
<a> } </a> 0
<a> this . file = file ; </a> 0
<a> this . offset = startOffset = offset ; </a> 0
<a> endOffset = offset + length ; </a> 0
<a> this . chunkSize = chunkSize ; </a> 0
<a> file . seek ( offset ) ; </a> 0
<a> } </a> 0
<a> public long getStartOffset ( ) { </a> 0
<a> return startOffset ; </a> 0
<a> } </a> 0
<a> public long getEndOffset ( ) { </a> 0
<a> return endOffset ; </a> 0
<a> } </a> 0
<a> public long getCurrentOffset ( ) { </a> 0
<a> return offset ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEndOfInput ( ) throws Exception { </a> 0
<a> return ! ( offset < endOffset && file . getChannel ( ) . isOpen ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws Exception { </a> 0
<a> file . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readChunk ( ByteBuf buffer ) throws Exception { </a> 0
<a> long offset = this . offset ; </a> 0
<a> if ( offset >= endOffset ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> int chunkSize = ( int ) Math . min ( this . chunkSize , endOffset - offset ) ; </a> 0
<a> byte [ ] chunk = new byte [ chunkSize ] ; </a> 0
<a> file . readFully ( chunk ) ; </a> 0
<a> buffer . writeBytes ( chunk ) ; </a> 0
<a> this . offset = offset + chunkSize ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . stream ; </a> 0
<a> public interface ChunkedInput < B > { </a> 0
<a> boolean isEndOfInput ( ) throws Exception ; </a> 0
<a> void close ( ) throws Exception ; </a> 0
<a> boolean readChunk ( B buffer ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . stream ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import java . io . File ; </a> 0
<a> import java . io . FileInputStream ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . nio . channels . FileChannel ; </a> 0
<a> public class ChunkedNioFile implements ChunkedByteInput { </a> 0
<a> private final FileChannel in ; </a> 0
<a> private final long startOffset ; </a> 0
<a> private final long endOffset ; </a> 0
<a> private final int chunkSize ; </a> 0
<a> private long offset ; </a> 0
<a> public ChunkedNioFile ( File in ) throws IOException { </a> 0
<a> this ( new FileInputStream ( in ) . getChannel ( ) ) ; </a> 0
<a> } </a> 0
<a> public ChunkedNioFile ( File in , int chunkSize ) throws IOException { </a> 0
<a> this ( new FileInputStream ( in ) . getChannel ( ) , chunkSize ) ; </a> 0
<a> } </a> 0
<a> public ChunkedNioFile ( FileChannel in ) throws IOException { </a> 0
<a> this ( in , ChunkedStream . DEFAULT_CHUNK_SIZE ) ; </a> 0
<a> } </a> 0
<a> public ChunkedNioFile ( FileChannel in , int chunkSize ) throws IOException { </a> 0
<a> this ( in , 0 , in . size ( ) , chunkSize ) ; </a> 0
<a> } </a> 0
<a> public ChunkedNioFile ( FileChannel in , long offset , long length , int chunkSize ) </a> 0
<a> throws IOException { </a> 0
<a> if ( in == null ) { </a> 0
<a> throw new NullPointerException ( "in" ) ; </a> 0
<a> } </a> 0
<a> if ( offset < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "offset: " + offset + " (expected: 0 or greater)" ) ; </a> 0
<a> } </a> 0
<a> if ( length < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "length: " + length + " (expected: 0 or greater)" ) ; </a> 0
<a> } </a> 0
<a> if ( chunkSize <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "chunkSize: " + chunkSize + </a> 0
<a> " (expected: a positive integer)" ) ; </a> 0
<a> } </a> 0
<a> if ( offset != 0 ) { </a> 0
<a> in . position ( offset ) ; </a> 0
<a> } </a> 0
<a> this . in = in ; </a> 0
<a> this . chunkSize = chunkSize ; </a> 0
<a> this . offset = startOffset = offset ; </a> 0
<a> endOffset = offset + length ; </a> 0
<a> } </a> 0
<a> public long getStartOffset ( ) { </a> 0
<a> return startOffset ; </a> 0
<a> } </a> 0
<a> public long getEndOffset ( ) { </a> 0
<a> return endOffset ; </a> 0
<a> } </a> 0
<a> public long getCurrentOffset ( ) { </a> 0
<a> return offset ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEndOfInput ( ) throws Exception { </a> 0
<a> return ! ( offset < endOffset && in . isOpen ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws Exception { </a> 0
<a> in . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readChunk ( ByteBuf buffer ) throws Exception { </a> 0
<a> long offset = this . offset ; </a> 0
<a> if ( offset >= endOffset ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> int chunkSize = ( int ) Math . min ( this . chunkSize , endOffset - offset ) ; </a> 0
<a> int readBytes = 0 ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> int localReadBytes = buffer . writeBytes ( in , chunkSize - readBytes ) ; </a> 0
<a> if ( localReadBytes < 0 ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> readBytes += localReadBytes ; </a> 0
<a> if ( readBytes == chunkSize ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> this . offset += readBytes ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . stream ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . channels . ReadableByteChannel ; </a> 0
<a> public class ChunkedNioStream implements ChunkedByteInput { </a> 0
<a> private final ReadableByteChannel in ; </a> 0
<a> private final int chunkSize ; </a> 0
<a> private long offset ; </a> 0
<a> private final ByteBuffer byteBuffer ; </a> 0
<a> public ChunkedNioStream ( ReadableByteChannel in ) { </a> 0
<a> this ( in , ChunkedStream . DEFAULT_CHUNK_SIZE ) ; </a> 0
<a> } </a> 0
<a> public ChunkedNioStream ( ReadableByteChannel in , int chunkSize ) { </a> 0
<a> if ( in == null ) { </a> 0
<a> throw new NullPointerException ( "in" ) ; </a> 0
<a> } </a> 0
<a> if ( chunkSize <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "chunkSize: " + chunkSize + </a> 0
<a> " (expected: a positive integer)" ) ; </a> 0
<a> } </a> 0
<a> this . in = in ; </a> 0
<a> offset = 0 ; </a> 0
<a> this . chunkSize = chunkSize ; </a> 0
<a> byteBuffer = ByteBuffer . allocate ( chunkSize ) ; </a> 0
<a> } </a> 0
<a> public long getTransferredBytes ( ) { </a> 0
<a> return offset ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEndOfInput ( ) throws Exception { </a> 0
<a> if ( byteBuffer . position ( ) > 0 ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( in . isOpen ( ) ) { </a> 0
<a> int b = in . read ( byteBuffer ) ; </a> 0
<a> if ( b < 0 ) { </a> 0
<a> return true ; </a> 0
<a> } else { </a> 0
<a> offset += b ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws Exception { </a> 0
<a> in . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readChunk ( ByteBuf buffer ) throws Exception { </a> 0
<a> if ( isEndOfInput ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> int readBytes = byteBuffer . position ( ) ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> int localReadBytes = in . read ( byteBuffer ) ; </a> 0
<a> if ( localReadBytes < 0 ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> readBytes += localReadBytes ; </a> 0
<a> offset += localReadBytes ; </a> 0
<a> if ( readBytes == chunkSize ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> byteBuffer . flip ( ) ; </a> 0
<a> buffer . writeBytes ( byteBuffer ) ; </a> 0
<a> byteBuffer . clear ( ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . stream ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . PushbackInputStream ; </a> 0
<a> public class ChunkedStream implements ChunkedByteInput { </a> 0
<a> static final int DEFAULT_CHUNK_SIZE = 8192 ; </a> 0
<a> private final PushbackInputStream in ; </a> 0
<a> private final int chunkSize ; </a> 0
<a> private long offset ; </a> 0
<a> public ChunkedStream ( InputStream in ) { </a> 0
<a> this ( in , DEFAULT_CHUNK_SIZE ) ; </a> 0
<a> } </a> 0
<a> public ChunkedStream ( InputStream in , int chunkSize ) { </a> 0
<a> if ( in == null ) { </a> 0
<a> throw new NullPointerException ( "in" ) ; </a> 0
<a> } </a> 0
<a> if ( chunkSize <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "chunkSize: " + chunkSize + </a> 0
<a> " (expected: a positive integer)" ) ; </a> 0
<a> } </a> 0
<a> if ( in instanceof PushbackInputStream ) { </a> 0
<a> this . in = ( PushbackInputStream ) in ; </a> 0
<a> } else { </a> 0
<a> this . in = new PushbackInputStream ( in ) ; </a> 0
<a> } </a> 0
<a> this . chunkSize = chunkSize ; </a> 0
<a> } </a> 0
<a> public long getTransferredBytes ( ) { </a> 0
<a> return offset ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEndOfInput ( ) throws Exception { </a> 0
<a> int b = in . read ( ) ; </a> 0
<a> if ( b < 0 ) { </a> 0
<a> return true ; </a> 0
<a> } else { </a> 0
<a> in . unread ( b ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( ) throws Exception { </a> 0
<a> in . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean readChunk ( ByteBuf buffer ) throws Exception { </a> 0
<a> if ( isEndOfInput ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> final int availableBytes = in . available ( ) ; </a> 0
<a> final int chunkSize ; </a> 0
<a> if ( availableBytes <= 0 ) { </a> 0
<a> chunkSize = this . chunkSize ; </a> 0
<a> } else { </a> 0
<a> chunkSize = Math . min ( this . chunkSize , in . available ( ) ) ; </a> 0
<a> } </a> 0
<a> offset += buffer . writeBytes ( in , chunkSize ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . stream ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> import io . netty . channel . ChannelHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelOutboundMessageHandler ; </a> 1
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . nio . channels . ClosedChannelException ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> public class ChunkedWriteHandler </a> 1
<a> extends ChannelHandlerAdapter implements ChannelOutboundMessageHandler < Object > { </a> 0
<a> private static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( ChunkedWriteHandler . class ) ; </a> 0
<a> private final MessageBuf < Object > queue = Unpooled . messageBuffer ( ) ; </a> 1
<a> private final int maxPendingWrites ; </a> 0
<a> private volatile ChannelHandlerContext ctx ; </a> 0
<a> private final AtomicInteger pendingWrites = new AtomicInteger ( ) ; </a> 0
<a> private Object currentEvent ; </a> 0
<a> public ChunkedWriteHandler ( ) { </a> 0
<a> this ( 4 ) ; </a> 0
<a> } </a> 0
<a> public ChunkedWriteHandler ( int maxPendingWrites ) { </a> 0
<a> if ( maxPendingWrites <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "maxPendingWrites: " + maxPendingWrites + " (expected: > 0)" ) ; </a> 0
<a> } </a> 0
<a> this . maxPendingWrites = maxPendingWrites ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public MessageBuf < Object > newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> this . ctx = ctx ; </a> 1
<a> return queue ; </a> 1
<a> } </a> 1
<a> private boolean isWritable ( ) { </a> 0
<a> return pendingWrites . get ( ) < maxPendingWrites ; </a> 0
<a> } </a> 0
<a> public void resumeTransfer ( ) { </a> 0
<a> final ChannelHandlerContext ctx = this . ctx ; </a> 0
<a> if ( ctx == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( ctx . executor ( ) . inEventLoop ( ) ) { </a> 0
<a> try { </a> 0
<a> doFlush ( ctx ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( "Unexpected exception while sending chunks." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> ctx . executor ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> try { </a> 0
<a> doFlush ( ctx ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( "Unexpected exception while sending chunks." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> queue . add ( future ) ; </a> 0
<a> if ( isWritable ( ) || ! ctx . channel ( ) . isActive ( ) ) { </a> 0
<a> doFlush ( ctx ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> doFlush ( ctx ) ; </a> 0
<a> super . channelInactive ( ctx ) ; </a> 1
<a> } </a> 0
<a> private void discard ( final ChannelHandlerContext ctx , Throwable cause ) { </a> 0
<a> boolean fireExceptionCaught = false ; </a> 0
<a> boolean success = true ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> Object currentEvent = this . currentEvent ; </a> 0
<a> if ( this . currentEvent == null ) { </a> 0
<a> currentEvent = queue . poll ( ) ; </a> 0
<a> } else { </a> 0
<a> this . currentEvent = null ; </a> 0
<a> } </a> 0
<a> if ( currentEvent == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( currentEvent instanceof ChunkedInput ) { </a> 0
<a> ChunkedInput < ? > in = ( ChunkedInput < ? > ) currentEvent ; </a> 0
<a> try { </a> 0
<a> if ( ! in . isEndOfInput ( ) ) { </a> 0
<a> success = false ; </a> 0
<a> } </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> success = false ; </a> 0
<a> logger . warn ( ChunkedInput . class . getSimpleName ( ) + ".isEndOfInput() failed" , e ) ; </a> 0
<a> } </a> 0
<a> closeInput ( in ) ; </a> 0
<a> } else if ( currentEvent instanceof ChannelFuture ) { </a> 0
<a> ChannelFuture f = ( ChannelFuture ) currentEvent ; </a> 0
<a> if ( ! success ) { </a> 0
<a> fireExceptionCaught = true ; </a> 0
<a> if ( cause == null ) { </a> 0
<a> cause = new ClosedChannelException ( ) ; </a> 0
<a> } </a> 0
<a> f . setFailure ( cause ) ; </a> 0
<a> } else { </a> 0
<a> f . setSuccess ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( fireExceptionCaught ) { </a> 0
<a> ctx . fireExceptionCaught ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void doFlush ( final ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> Channel channel = ctx . channel ( ) ; </a> 0
<a> if ( ! channel . isActive ( ) ) { </a> 0
<a> discard ( ctx , null ) ; </a> 0
<a> return ; </a> 1
<a> } </a> 0
<a> while ( isWritable ( ) ) { </a> 0
<a> if ( currentEvent == null ) { </a> 0
<a> currentEvent = queue . poll ( ) ; </a> 0
<a> } </a> 0
<a> if ( currentEvent == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> final Object currentEvent = this . currentEvent ; </a> 0
<a> if ( currentEvent instanceof ChannelFuture ) { </a> 0
<a> this . currentEvent = null ; </a> 0
<a> ctx . flush ( ( ChannelFuture ) currentEvent ) ; </a> 0
<a> } else if ( currentEvent instanceof ChunkedInput ) { </a> 0
<a> final ChunkedInput < ? > chunks = ( ChunkedInput < ? > ) currentEvent ; </a> 0
<a> boolean read ; </a> 0
<a> boolean endOfInput ; </a> 0
<a> boolean suspend ; </a> 0
<a> try { </a> 0
<a> read = readChunk ( ctx , chunks ) ; </a> 1
<a> endOfInput = chunks . isEndOfInput ( ) ; </a> 0
<a> if ( ! read ) { </a> 0
<a> suspend = ! endOfInput ; </a> 0
<a> } else { </a> 0
<a> suspend = false ; </a> 0
<a> } </a> 0
<a> } catch ( final Throwable t ) { </a> 0
<a> this . currentEvent = null ; </a> 0
<a> if ( ctx . executor ( ) . inEventLoop ( ) ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } else { </a> 0
<a> ctx . executor ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> closeInput ( chunks ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( suspend ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> pendingWrites . incrementAndGet ( ) ; </a> 0
<a> ChannelFuture f = ctx . flush ( ) ; </a> 1
<a> if ( endOfInput ) { </a> 0
<a> this . currentEvent = null ; </a> 0
<a> f . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 0
<a> pendingWrites . decrementAndGet ( ) ; </a> 0
<a> closeInput ( chunks ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } else if ( isWritable ( ) ) { </a> 0
<a> f . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 0
<a> pendingWrites . decrementAndGet ( ) ; </a> 0
<a> if ( ! future . isSuccess ( ) ) { </a> 0
<a> closeInput ( ( ChunkedInput < ? > ) currentEvent ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } else { </a> 0
<a> f . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 0
<a> pendingWrites . decrementAndGet ( ) ; </a> 0
<a> if ( ! future . isSuccess ( ) ) { </a> 0
<a> closeInput ( ( ChunkedInput < ? > ) currentEvent ) ; </a> 0
<a> } else if ( isWritable ( ) ) { </a> 1
<a> resumeTransfer ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> ctx . nextOutboundMessageBuffer ( ) . add ( currentEvent ) ; </a> 0
<a> this . currentEvent = null ; </a> 0
<a> } </a> 0
<a> if ( ! channel . isActive ( ) ) { </a> 0
<a> discard ( ctx , new ClosedChannelException ( ) ) ; </a> 0
<a> return ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> protected boolean readChunk ( ChannelHandlerContext ctx , ChunkedInput < ? > chunks ) throws Exception { </a> 1
<a> if ( chunks instanceof ChunkedByteInput ) { </a> 0
<a> return ( ( ChunkedByteInput ) chunks ) . readChunk ( ctx . nextOutboundByteBuffer ( ) ) ; </a> 1
<a> } else if ( chunks instanceof ChunkedMessageInput ) { </a> 0
<a> return ( ( ChunkedMessageInput < Object > ) chunks ) . readChunk ( ctx . nextOutboundMessageBuffer ( ) ) ; </a> 1
<a> } else { </a> 0
<a> throw new IllegalArgumentException ( "ChunkedInput instance " + chunks + " not supported" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static void closeInput ( ChunkedInput < ? > chunks ) { </a> 0
<a> try { </a> 0
<a> chunks . close ( ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( "Failed to close a chunked input." , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void beforeRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> doFlush ( ctx ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void afterRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> discard ( ctx , new ChannelException ( ChunkedWriteHandler . class . getSimpleName ( ) + " removed from pipeline." ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . stream ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . timeout ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> public enum IdleState { </a> 0
<a> READER_IDLE , </a> 0
<a> WRITER_IDLE , </a> 0
<a> ALL_IDLE </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . timeout ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 1
<a> import io . netty . channel . ChannelHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 1
<a> import io . netty . channel . EventExecutor ; </a> 0
<a> import io . netty . util . HashedWheelTimer ; </a> 1
<a> import io . netty . util . Timer ; </a> 1
<a> import java . nio . channels . Channels ; </a> 1
<a> import java . util . concurrent . ScheduledFuture ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public class IdleStateHandler extends ChannelHandlerAdapter { </a> 1
<a> private final long readerIdleTimeMillis ; </a> 0
<a> private final long writerIdleTimeMillis ; </a> 0
<a> private final long allIdleTimeMillis ; </a> 0
<a> volatile ScheduledFuture < ? > readerIdleTimeout ; </a> 0
<a> volatile long lastReadTime ; </a> 0
<a> int readerIdleCount ; </a> 0
<a> volatile ScheduledFuture < ? > writerIdleTimeout ; </a> 0
<a> volatile long lastWriteTime ; </a> 0
<a> int writerIdleCount ; </a> 0
<a> volatile ScheduledFuture < ? > allIdleTimeout ; </a> 0
<a> int allIdleCount ; </a> 0
<a> private volatile int state ; </a> 0
<a> public IdleStateHandler ( </a> 0
<a> int readerIdleTimeSeconds , </a> 0
<a> int writerIdleTimeSeconds , </a> 0
<a> int allIdleTimeSeconds ) { </a> 0
<a> this ( readerIdleTimeSeconds , writerIdleTimeSeconds , allIdleTimeSeconds , </a> 0
<a> TimeUnit . SECONDS ) ; </a> 0
<a> } </a> 0
<a> public IdleStateHandler ( </a> 0
<a> long readerIdleTime , long writerIdleTime , long allIdleTime , </a> 0
<a> TimeUnit unit ) { </a> 0
<a> if ( unit == null ) { </a> 0
<a> throw new NullPointerException ( "unit" ) ; </a> 0
<a> } </a> 0
<a> if ( readerIdleTime <= 0 ) { </a> 0
<a> readerIdleTimeMillis = 0 ; </a> 0
<a> } else { </a> 0
<a> readerIdleTimeMillis = Math . max ( unit . toMillis ( readerIdleTime ) , 1 ) ; </a> 0
<a> } </a> 0
<a> if ( writerIdleTime <= 0 ) { </a> 0
<a> writerIdleTimeMillis = 0 ; </a> 0
<a> } else { </a> 0
<a> writerIdleTimeMillis = Math . max ( unit . toMillis ( writerIdleTime ) , 1 ) ; </a> 0
<a> } </a> 0
<a> if ( allIdleTime <= 0 ) { </a> 0
<a> allIdleTimeMillis = 0 ; </a> 0
<a> } else { </a> 0
<a> allIdleTimeMillis = Math . max ( unit . toMillis ( allIdleTime ) , 1 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public long getReaderIdleTimeInMillis ( ) { </a> 0
<a> return readerIdleTimeMillis ; </a> 0
<a> } </a> 0
<a> public long getWriterIdleTimeInMillis ( ) { </a> 0
<a> return writerIdleTimeMillis ; </a> 0
<a> } </a> 0
<a> public long getAllIdleTimeInMillis ( ) { </a> 0
<a> return allIdleTimeMillis ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> if ( ctx . channel ( ) . isActive ( ) & ctx . channel ( ) . isRegistered ( ) ) { </a> 0
<a> initialize ( ctx ) ; </a> 0
<a> } else { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> destroy ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelRegistered ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> if ( ctx . channel ( ) . isActive ( ) ) { </a> 0
<a> initialize ( ctx ) ; </a> 0
<a> } </a> 0
<a> super . channelRegistered ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> initialize ( ctx ) ; </a> 0
<a> super . channelActive ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> destroy ( ) ; </a> 0
<a> super . channelInactive ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> lastReadTime = System . currentTimeMillis ( ) ; </a> 0
<a> readerIdleCount = allIdleCount = 0 ; </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( final ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> future . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 1
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 1
<a> lastWriteTime = System . currentTimeMillis ( ) ; </a> 1
<a> writerIdleCount = allIdleCount = 0 ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> super . flush ( ctx , future ) ; </a> 1
<a> } </a> 1
<a> private void initialize ( ChannelHandlerContext ctx ) { </a> 0
<a> switch ( state ) { </a> 0
<a> case 1 : </a> 0
<a> case 2 : </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> state = 1 ; </a> 0
<a> EventExecutor loop = ctx . executor ( ) ; </a> 0
<a> lastReadTime = lastWriteTime = System . currentTimeMillis ( ) ; </a> 0
<a> if ( readerIdleTimeMillis > 0 ) { </a> 0
<a> readerIdleTimeout = loop . schedule ( </a> 0
<a> new ReaderIdleTimeoutTask ( ctx ) , </a> 0
<a> readerIdleTimeMillis , TimeUnit . MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> if ( writerIdleTimeMillis > 0 ) { </a> 0
<a> writerIdleTimeout = loop . schedule ( </a> 0
<a> new WriterIdleTimeoutTask ( ctx ) , </a> 0
<a> writerIdleTimeMillis , TimeUnit . MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> if ( allIdleTimeMillis > 0 ) { </a> 0
<a> allIdleTimeout = loop . schedule ( </a> 0
<a> new AllIdleTimeoutTask ( ctx ) , </a> 0
<a> allIdleTimeMillis , TimeUnit . MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void destroy ( ) { </a> 0
<a> state = 2 ; </a> 0
<a> if ( readerIdleTimeout != null ) { </a> 0
<a> readerIdleTimeout . cancel ( false ) ; </a> 0
<a> readerIdleTimeout = null ; </a> 0
<a> } </a> 0
<a> if ( writerIdleTimeout != null ) { </a> 0
<a> writerIdleTimeout . cancel ( false ) ; </a> 0
<a> writerIdleTimeout = null ; </a> 0
<a> } </a> 0
<a> if ( allIdleTimeout != null ) { </a> 0
<a> allIdleTimeout . cancel ( false ) ; </a> 0
<a> allIdleTimeout = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void channelIdle ( ChannelHandlerContext ctx , IdleStateEvent evt ) throws Exception { </a> 0
<a> ctx . fireUserEventTriggered ( evt ) ; </a> 0
<a> } </a> 0
<a> private final class ReaderIdleTimeoutTask implements Runnable { </a> 0
<a> private final ChannelHandlerContext ctx ; </a> 0
<a> ReaderIdleTimeoutTask ( ChannelHandlerContext ctx ) { </a> 0
<a> this . ctx = ctx ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> if ( ! ctx . channel ( ) . isOpen ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> long currentTime = System . currentTimeMillis ( ) ; </a> 0
<a> long lastReadTime = IdleStateHandler . this . lastReadTime ; </a> 0
<a> long nextDelay = readerIdleTimeMillis - ( currentTime - lastReadTime ) ; </a> 0
<a> if ( nextDelay <= 0 ) { </a> 0
<a> readerIdleTimeout = </a> 0
<a> ctx . executor ( ) . schedule ( this , readerIdleTimeMillis , TimeUnit . MILLISECONDS ) ; </a> 0
<a> try { </a> 0
<a> channelIdle ( ctx , new IdleStateEvent ( </a> 0
<a> IdleState . READER_IDLE , readerIdleCount ++ , currentTime - lastReadTime ) ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> readerIdleTimeout = ctx . executor ( ) . schedule ( this , nextDelay , TimeUnit . MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final class WriterIdleTimeoutTask implements Runnable { </a> 0
<a> private final ChannelHandlerContext ctx ; </a> 0
<a> WriterIdleTimeoutTask ( ChannelHandlerContext ctx ) { </a> 0
<a> this . ctx = ctx ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> if ( ! ctx . channel ( ) . isOpen ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> long currentTime = System . currentTimeMillis ( ) ; </a> 0
<a> long lastWriteTime = IdleStateHandler . this . lastWriteTime ; </a> 0
<a> long nextDelay = writerIdleTimeMillis - ( currentTime - lastWriteTime ) ; </a> 0
<a> if ( nextDelay <= 0 ) { </a> 0
<a> writerIdleTimeout = ctx . executor ( ) . schedule ( </a> 0
<a> this , writerIdleTimeMillis , TimeUnit . MILLISECONDS ) ; </a> 0
<a> try { </a> 0
<a> channelIdle ( ctx , new IdleStateEvent ( </a> 0
<a> IdleState . WRITER_IDLE , writerIdleCount ++ , currentTime - lastWriteTime ) ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> writerIdleTimeout = ctx . executor ( ) . schedule ( this , nextDelay , TimeUnit . MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final class AllIdleTimeoutTask implements Runnable { </a> 0
<a> private final ChannelHandlerContext ctx ; </a> 0
<a> AllIdleTimeoutTask ( ChannelHandlerContext ctx ) { </a> 0
<a> this . ctx = ctx ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> if ( ! ctx . channel ( ) . isOpen ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> long currentTime = System . currentTimeMillis ( ) ; </a> 0
<a> long lastIoTime = Math . max ( lastReadTime , lastWriteTime ) ; </a> 0
<a> long nextDelay = allIdleTimeMillis - ( currentTime - lastIoTime ) ; </a> 0
<a> if ( nextDelay <= 0 ) { </a> 0
<a> allIdleTimeout = ctx . executor ( ) . schedule ( </a> 0
<a> this , allIdleTimeMillis , TimeUnit . MILLISECONDS ) ; </a> 0
<a> try { </a> 0
<a> channelIdle ( ctx , new IdleStateEvent ( </a> 0
<a> IdleState . ALL_IDLE , allIdleCount ++ , currentTime - lastIoTime ) ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> allIdleTimeout = ctx . executor ( ) . schedule ( this , nextDelay , TimeUnit . MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . timeout ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 1
<a> import io . netty . channel . ChannelStateHandlerAdapter ; </a> 1
<a> import io . netty . util . HashedWheelTimer ; </a> 1
<a> import io . netty . util . Timer ; </a> 1
<a> import java . nio . channels . Channels ; </a> 1
<a> import java . util . concurrent . ScheduledFuture ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public class ReadTimeoutHandler extends ChannelStateHandlerAdapter { </a> 1
<a> private final long timeoutMillis ; </a> 0
<a> private volatile ScheduledFuture < ? > timeout ; </a> 0
<a> private volatile long lastReadTime ; </a> 0
<a> private volatile int state ; </a> 0
<a> private boolean closed ; </a> 0
<a> public ReadTimeoutHandler ( int timeoutSeconds ) { </a> 0
<a> this ( timeoutSeconds , TimeUnit . SECONDS ) ; </a> 0
<a> } </a> 0
<a> public ReadTimeoutHandler ( long timeout , TimeUnit unit ) { </a> 0
<a> if ( unit == null ) { </a> 0
<a> throw new NullPointerException ( "unit" ) ; </a> 0
<a> } </a> 0
<a> if ( timeout <= 0 ) { </a> 0
<a> timeoutMillis = 0 ; </a> 0
<a> } else { </a> 0
<a> timeoutMillis = Math . max ( unit . toMillis ( timeout ) , 1 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> if ( ctx . channel ( ) . isActive ( ) && ctx . channel ( ) . isRegistered ( ) ) { </a> 0
<a> initialize ( ctx ) ; </a> 0
<a> } else { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> destroy ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelRegistered ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> if ( ctx . channel ( ) . isActive ( ) ) { </a> 0
<a> initialize ( ctx ) ; </a> 0
<a> } </a> 0
<a> super . channelRegistered ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> initialize ( ctx ) ; </a> 0
<a> super . channelActive ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> destroy ( ) ; </a> 0
<a> super . channelInactive ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> lastReadTime = System . currentTimeMillis ( ) ; </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> private void initialize ( ChannelHandlerContext ctx ) { </a> 0
<a> switch ( state ) { </a> 0
<a> case 1 : </a> 0
<a> case 2 : </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> state = 1 ; </a> 0
<a> lastReadTime = System . currentTimeMillis ( ) ; </a> 0
<a> if ( timeoutMillis > 0 ) { </a> 0
<a> timeout = ctx . executor ( ) . schedule ( </a> 0
<a> new ReadTimeoutTask ( ctx ) , </a> 0
<a> timeoutMillis , TimeUnit . MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void destroy ( ) { </a> 0
<a> state = 2 ; </a> 0
<a> if ( timeout != null ) { </a> 0
<a> timeout . cancel ( false ) ; </a> 0
<a> timeout = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected void readTimedOut ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> if ( ! closed ) { </a> 0
<a> ctx . fireExceptionCaught ( ReadTimeoutException . INSTANCE ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> closed = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final class ReadTimeoutTask implements Runnable { </a> 0
<a> private final ChannelHandlerContext ctx ; </a> 0
<a> ReadTimeoutTask ( ChannelHandlerContext ctx ) { </a> 0
<a> this . ctx = ctx ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> if ( ! ctx . channel ( ) . isOpen ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> long currentTime = System . currentTimeMillis ( ) ; </a> 0
<a> long nextDelay = timeoutMillis - ( currentTime - lastReadTime ) ; </a> 0
<a> if ( nextDelay <= 0 ) { </a> 0
<a> timeout = ctx . executor ( ) . schedule ( this , timeoutMillis , TimeUnit . MILLISECONDS ) ; </a> 0
<a> try { </a> 0
<a> readTimedOut ( ctx ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> timeout = ctx . executor ( ) . schedule ( this , nextDelay , TimeUnit . MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . timeout ; </a> 0
<a> public final class WriteTimeoutException extends TimeoutException { </a> 0
<a> private static final long serialVersionUID = - 144786655770296065L ; </a> 0
<a> public static final WriteTimeoutException INSTANCE = new WriteTimeoutException ( ) ; </a> 0
<a> private WriteTimeoutException ( ) { } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . timeout ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelOperationHandlerAdapter ; </a> 1
<a> import io . netty . channel . ChannelPipeline ; </a> 1
<a> import io . netty . util . HashedWheelTimer ; </a> 1
<a> import io . netty . util . Timer ; </a> 1
<a> import java . nio . channels . Channels ; </a> 1
<a> import java . util . concurrent . ScheduledFuture ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public class WriteTimeoutHandler extends ChannelOperationHandlerAdapter { </a> 1
<a> private final long timeoutMillis ; </a> 0
<a> private boolean closed ; </a> 0
<a> public WriteTimeoutHandler ( int timeoutSeconds ) { </a> 0
<a> this ( timeoutSeconds , TimeUnit . SECONDS ) ; </a> 0
<a> } </a> 0
<a> public WriteTimeoutHandler ( long timeout , TimeUnit unit ) { </a> 0
<a> if ( unit == null ) { </a> 0
<a> throw new NullPointerException ( "unit" ) ; </a> 0
<a> } </a> 0
<a> if ( timeout <= 0 ) { </a> 0
<a> timeoutMillis = 0 ; </a> 0
<a> } else { </a> 0
<a> timeoutMillis = Math . max ( unit . toMillis ( timeout ) , 1 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( final ChannelHandlerContext ctx , final ChannelFuture future ) throws Exception { </a> 0
<a> if ( timeoutMillis > 0 ) { </a> 0
<a> final ScheduledFuture < ? > sf = ctx . executor ( ) . schedule ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> if ( future . setFailure ( WriteTimeoutException . INSTANCE ) ) { </a> 0
<a> try { </a> 0
<a> writeTimedOut ( ctx ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , timeoutMillis , TimeUnit . MILLISECONDS ) ; </a> 0
<a> future . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 0
<a> sf . cancel ( false ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> super . flush ( ctx , future ) ; </a> 0
<a> } </a> 0
<a> protected void writeTimedOut ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> if ( ! closed ) { </a> 0
<a> ctx . fireExceptionCaught ( WriteTimeoutException . INSTANCE ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> closed = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . timeout ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . handler . ssl ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import org . junit . Test ; </a> 1
<a> public class ImmediateExecutorTest { </a> 0
<a> @ Test </a> 1
<a> public void shouldExecuteImmediately ( ) { </a> 1
<a> ImmediateExecutor e = ImmediateExecutor . INSTANCE ; </a> 0
<a> long startTime = System . nanoTime ( ) ; </a> 1
<a> e . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> long startTime = System . nanoTime ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> try { </a> 1
<a> Thread . sleep ( 1000 ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> } </a> 1
<a> if ( System . nanoTime ( ) - startTime >= 1000000000L ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> assertTrue ( System . nanoTime ( ) - startTime >= 1000000000L ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . transport . socket ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . testsuite . transport . socket . SocketTestPermutation . Factory ; </a> 0
<a> import io . netty . testsuite . util . TestUtils ; </a> 0
<a> import io . netty . util . NetworkConstants ; </a> 0
<a> import java . lang . reflect . InvocationTargetException ; </a> 0
<a> import java . lang . reflect . Method ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> import org . junit . Rule ; </a> 0
<a> import org . junit . rules . TestName ; </a> 0
<a> public abstract class AbstractSocketTest { </a> 0
<a> private static final List < Entry < Factory < ServerBootstrap > , Factory < Bootstrap > > > COMBO = </a> 0
<a> SocketTestPermutation . socket ( ) ; </a> 0
<a> @ Rule </a> 0
<a> public final TestName testName = new TestName ( ) ; </a> 0
<a> protected final InternalLogger logger = InternalLoggerFactory . getInstance ( getClass ( ) ) ; </a> 0
<a> protected volatile ServerBootstrap sb ; </a> 0
<a> protected volatile Bootstrap cb ; </a> 0
<a> protected volatile InetSocketAddress addr ; </a> 0
<a> protected volatile Factory < Bootstrap > currentBootstrap ; </a> 0
<a> protected void run ( ) throws Throwable { </a> 0
<a> int i = 0 ; </a> 0
<a> for ( Entry < Factory < ServerBootstrap > , Factory < Bootstrap > > e : COMBO ) { </a> 0
<a> currentBootstrap = e . getValue ( ) ; </a> 0
<a> sb = e . getKey ( ) . newInstance ( ) ; </a> 0
<a> cb = e . getValue ( ) . newInstance ( ) ; </a> 0
<a> addr = new InetSocketAddress ( </a> 0
<a> NetworkConstants . LOCALHOST , TestUtils . getFreePort ( ) ) ; </a> 0
<a> sb . localAddress ( addr ) ; </a> 0
<a> cb . remoteAddress ( addr ) ; </a> 0
<a> logger . info ( String . format ( </a> 0
<a> "Running: %s %d of %d" , testName . getMethodName ( ) , ++ i , COMBO . size ( ) ) ) ; </a> 0
<a> try { </a> 0
<a> Method m = getClass ( ) . getDeclaredMethod ( </a> 1
<a> testName . getMethodName ( ) , ServerBootstrap . class , Bootstrap . class ) ; </a> 1
<a> m . invoke ( this , sb , cb ) ; </a> 0
<a> } catch ( InvocationTargetException ex ) { </a> 0
<a> throw ex . getCause ( ) ; </a> 0
<a> } finally { </a> 0
<a> sb . shutdown ( ) ; </a> 0
<a> cb . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . transport . socket ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . ChannelOption ; </a> 0
<a> import io . netty . channel . socket . DatagramChannel ; </a> 0
<a> import io . netty . channel . socket . DatagramPacket ; </a> 0
<a> import io . netty . util . NetworkConstants ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . util . concurrent . CountDownLatch ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import org . junit . Assert ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class DatagramMulticastTest extends AbstractDatagramTest { </a> 0
<a> @ Test </a> 0
<a> public void testMulticast ( ) throws Throwable { </a> 0
<a> run ( ) ; </a> 0
<a> } </a> 0
<a> public void testMulticast ( Bootstrap sb , Bootstrap cb ) throws Throwable { </a> 0
<a> MulticastTestHandler mhandler = new MulticastTestHandler ( ) ; </a> 0
<a> sb . handler ( new ChannelInboundMessageHandlerAdapter < DatagramPacket > ( ) { </a> 1
<a> @ Override </a> 0
<a> public void messageReceived ( </a> 1
<a> ChannelHandlerContext ctx , </a> 1
<a> DatagramPacket msg ) throws Exception { </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> cb . handler ( mhandler ) ; </a> 0
<a> sb . option ( ChannelOption . IP_MULTICAST_IF , NetworkConstants . LOOPBACK_IF ) ; </a> 0
<a> sb . option ( ChannelOption . SO_REUSEADDR , true ) ; </a> 0
<a> cb . option ( ChannelOption . IP_MULTICAST_IF , NetworkConstants . LOOPBACK_IF ) ; </a> 0
<a> cb . option ( ChannelOption . SO_REUSEADDR , true ) ; </a> 0
<a> cb . localAddress ( addr . getPort ( ) ) ; </a> 0
<a> Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> DatagramChannel cc = ( DatagramChannel ) cb . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> String group = "230.0.0.1" ; </a> 0
<a> InetSocketAddress groupAddress = new InetSocketAddress ( group , addr . getPort ( ) ) ; </a> 0
<a> cc . joinGroup ( groupAddress , NetworkConstants . LOOPBACK_IF ) . sync ( ) ; </a> 0
<a> sc . write ( new DatagramPacket ( Unpooled . copyInt ( 1 ) , groupAddress ) ) . sync ( ) ; </a> 0
<a> assertTrue ( mhandler . await ( ) ) ; </a> 0
<a> cc . leaveGroup ( groupAddress , NetworkConstants . LOOPBACK_IF ) . sync ( ) ; </a> 0
<a> Thread . sleep ( 1000 ) ; </a> 0
<a> sc . write ( new DatagramPacket ( Unpooled . copyInt ( 1 ) , groupAddress ) ) . sync ( ) ; </a> 0
<a> mhandler . await ( ) ; </a> 0
<a> sc . close ( ) . awaitUninterruptibly ( ) ; </a> 0
<a> cc . close ( ) . awaitUninterruptibly ( ) ; </a> 0
<a> } </a> 0
<a> private final class MulticastTestHandler extends ChannelInboundMessageHandlerAdapter < DatagramPacket > { </a> 0
<a> private final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> private boolean done ; </a> 0
<a> private volatile boolean fail ; </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( </a> 1
<a> ChannelHandlerContext ctx , </a> 1
<a> DatagramPacket msg ) throws Exception { </a> 1
<a> if ( done ) { </a> 1
<a> fail = true ; </a> 0
<a> } </a> 0
<a> Assert . assertEquals ( 1 , msg . data ( ) . readInt ( ) ) ; </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> done = true ; </a> 0
<a> } </a> 0
<a> public boolean await ( ) throws Exception { </a> 0
<a> boolean success = latch . await ( 10 , TimeUnit . SECONDS ) ; </a> 0
<a> if ( fail ) { </a> 0
<a> Assert . fail ( ) ; </a> 0
<a> } </a> 0
<a> return success ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . transport . socket ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . socket . DatagramPacket ; </a> 0
<a> import java . util . concurrent . CountDownLatch ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import org . junit . Assert ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class DatagramUnicastTest extends AbstractDatagramTest { </a> 0
<a> @ Test </a> 0
<a> public void testSimpleSend ( ) throws Throwable { </a> 0
<a> run ( ) ; </a> 0
<a> } </a> 0
<a> public void testSimpleSend ( Bootstrap sb , Bootstrap cb ) throws Throwable { </a> 0
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> sb . handler ( new ChannelInboundMessageHandlerAdapter < DatagramPacket > ( ) { </a> 1
<a> @ Override </a> 0
<a> public void messageReceived ( </a> 1
<a> ChannelHandlerContext ctx , </a> 1
<a> DatagramPacket msg ) throws Exception { </a> 1
<a> Assert . assertEquals ( 1 , msg . data ( ) . readInt ( ) ) ; </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> cb . handler ( new ChannelInboundMessageHandlerAdapter < DatagramPacket > ( ) { </a> 1
<a> @ Override </a> 0
<a> public void messageReceived ( </a> 1
<a> ChannelHandlerContext ctx , </a> 1
<a> DatagramPacket msg ) throws Exception { </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> Channel cc = cb . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> cc . write ( new DatagramPacket ( Unpooled . copyInt ( 1 ) , addr ) ) . sync ( ) ; </a> 0
<a> assertTrue ( latch . await ( 10 , TimeUnit . SECONDS ) ) ; </a> 0
<a> sc . close ( ) . sync ( ) ; </a> 0
<a> cc . close ( ) . sync ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . transport . socket ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . FixedLengthFrameDecoder ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . Random ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class SocketFixedLengthEchoTest extends AbstractSocketTest { </a> 0
<a> private static final Random random = new Random ( ) ; </a> 0
<a> static final byte [ ] data = new byte [ 1048576 ] ; </a> 0
<a> static { </a> 0
<a> random . nextBytes ( data ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testFixedLengthEcho ( ) throws Throwable { </a> 0
<a> run ( ) ; </a> 0
<a> } </a> 0
<a> public void testFixedLengthEcho ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { </a> 0
<a> final EchoHandler sh = new EchoHandler ( ) ; </a> 1
<a> final EchoHandler ch = new EchoHandler ( ) ; </a> 1
<a> sb . childHandler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel sch ) throws Exception { </a> 0
<a> sch . pipeline ( ) . addLast ( "decoder" , new FixedLengthFrameDecoder ( 1024 ) ) ; </a> 0
<a> sch . pipeline ( ) . addAfter ( "decoder" , "handler" , sh ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> cb . handler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel sch ) throws Exception { </a> 0
<a> sch . pipeline ( ) . addLast ( "decoder" , new FixedLengthFrameDecoder ( 1024 ) ) ; </a> 0
<a> sch . pipeline ( ) . addAfter ( "decoder" , "handler" , ch ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> Channel cc = cb . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> for ( int i = 0 ; i < data . length ; ) { </a> 0
<a> int length = Math . min ( random . nextInt ( 1024 * 3 ) , data . length - i ) ; </a> 0
<a> cc . write ( Unpooled . wrappedBuffer ( data , i , length ) ) ; </a> 0
<a> i += length ; </a> 0
<a> } </a> 0
<a> while ( ch . counter < data . length ) { </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> while ( sh . counter < data . length ) { </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> sh . channel . close ( ) . sync ( ) ; </a> 0
<a> ch . channel . close ( ) . sync ( ) ; </a> 0
<a> sc . close ( ) . sync ( ) ; </a> 0
<a> if ( sh . exception . get ( ) != null && ! ( sh . exception . get ( ) instanceof IOException ) ) { </a> 0
<a> throw sh . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null && ! ( ch . exception . get ( ) instanceof IOException ) ) { </a> 0
<a> throw ch . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> throw sh . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> throw ch . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class EchoHandler extends ChannelInboundMessageHandlerAdapter < ByteBuf > { </a> 1
<a> volatile Channel channel ; </a> 0
<a> final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 0
<a> volatile int counter ; </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) </a> 0
<a> throws Exception { </a> 0
<a> channel = ctx . channel ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( </a> 1
<a> ChannelHandlerContext ctx , </a> 1
<a> ByteBuf msg ) throws Exception { </a> 1
<a> assertEquals ( 1024 , msg . readableBytes ( ) ) ; </a> 0
<a> byte [ ] actual = new byte [ msg . readableBytes ( ) ] ; </a> 0
<a> msg . getBytes ( 0 , actual ) ; </a> 0
<a> int lastIdx = counter ; </a> 0
<a> for ( int i = 0 ; i < actual . length ; i ++ ) { </a> 0
<a> assertEquals ( data [ i + lastIdx ] , actual [ i ] ) ; </a> 0
<a> } </a> 0
<a> if ( channel . parent ( ) != null ) { </a> 0
<a> channel . write ( msg ) ; </a> 0
<a> } </a> 0
<a> counter += actual . length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( </a> 0
<a> ChannelHandlerContext ctx , Throwable cause ) </a> 0
<a> throws Exception { </a> 0
<a> if ( exception . compareAndSet ( null , cause ) ) { </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . transport . socket ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . serialization . ClassResolvers ; </a> 0
<a> import io . netty . handler . codec . serialization . ObjectDecoder ; </a> 0
<a> import io . netty . handler . codec . serialization . ObjectEncoder ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . util . Random ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class SocketObjectEchoTest extends AbstractSocketTest { </a> 0
<a> static final Random random = new Random ( ) ; </a> 0
<a> static final String [ ] data = new String [ 1024 ] ; </a> 0
<a> static { </a> 0
<a> for ( int i = 0 ; i < data . length ; i ++ ) { </a> 0
<a> int eLen = random . nextInt ( 512 ) ; </a> 0
<a> char [ ] e = new char [ eLen ] ; </a> 0
<a> for ( int j = 0 ; j < eLen ; j ++ ) { </a> 0
<a> e [ j ] = ( char ) ( 'a' + random . nextInt ( 26 ) ) ; </a> 0
<a> } </a> 0
<a> data [ i ] = new String ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testObjectEcho ( ) throws Throwable { </a> 0
<a> run ( ) ; </a> 0
<a> } </a> 0
<a> public void testObjectEcho ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { </a> 0
<a> final EchoHandler sh = new EchoHandler ( ) ; </a> 1
<a> final EchoHandler ch = new EchoHandler ( ) ; </a> 1
<a> sb . childHandler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel sch ) throws Exception { </a> 0
<a> sch . pipeline ( ) . addLast ( </a> 0
<a> new ObjectDecoder ( ClassResolvers . cacheDisabled ( getClass ( ) . getClassLoader ( ) ) ) , </a> 0
<a> new ObjectEncoder ( ) , </a> 0
<a> sh ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> cb . handler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel sch ) throws Exception { </a> 0
<a> sch . pipeline ( ) . addLast ( </a> 0
<a> new ObjectDecoder ( ClassResolvers . cacheDisabled ( getClass ( ) . getClassLoader ( ) ) ) , </a> 0
<a> new ObjectEncoder ( ) , </a> 0
<a> ch ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> Channel cc = cb . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> for ( String element : data ) { </a> 0
<a> cc . write ( element ) ; </a> 0
<a> } </a> 0
<a> while ( ch . counter < data . length ) { </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> while ( sh . counter < data . length ) { </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> sh . channel . close ( ) . sync ( ) ; </a> 0
<a> ch . channel . close ( ) . sync ( ) ; </a> 0
<a> sc . close ( ) . sync ( ) ; </a> 0
<a> if ( sh . exception . get ( ) != null && ! ( sh . exception . get ( ) instanceof IOException ) ) { </a> 0
<a> throw sh . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null && ! ( ch . exception . get ( ) instanceof IOException ) ) { </a> 0
<a> throw ch . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> throw sh . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> throw ch . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class EchoHandler extends ChannelInboundMessageHandlerAdapter < String > { </a> 1
<a> volatile Channel channel ; </a> 0
<a> final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 0
<a> volatile int counter ; </a> 0
<a> EchoHandler ( ) { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) </a> 0
<a> throws Exception { </a> 0
<a> channel = ctx . channel ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , </a> 1
<a> String msg ) throws Exception { </a> 1
<a> assertEquals ( data [ counter ] , msg ) ; </a> 0
<a> if ( channel . parent ( ) != null ) { </a> 0
<a> channel . write ( msg ) ; </a> 0
<a> } </a> 0
<a> counter ++ ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , </a> 0
<a> Throwable cause ) throws Exception { </a> 0
<a> if ( exception . compareAndSet ( null , cause ) ) { </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . transport . socket ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . codec . spdy . SpdyConstants ; </a> 0
<a> import io . netty . handler . codec . spdy . SpdyFrameDecoder ; </a> 0
<a> import io . netty . handler . codec . spdy . SpdyFrameEncoder ; </a> 0
<a> import io . netty . util . NetworkConstants ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . util . Random ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class SocketSpdyEchoTest extends AbstractSocketTest { </a> 0
<a> private static final Random random = new Random ( ) ; </a> 0
<a> static final int ignoredBytes = 20 ; </a> 0
<a> private static ByteBuf createFrames ( int version ) { </a> 0
<a> int length = version < 3 ? 1176 : 1174 ; </a> 0
<a> ByteBuf frames = Unpooled . buffer ( length ) ; </a> 0
<a> frames . writeByte ( 0x80 ) ; </a> 0
<a> frames . writeByte ( version ) ; </a> 0
<a> frames . writeShort ( 0xFFFF ) ; </a> 0
<a> frames . writeByte ( 0xFF ) ; </a> 0
<a> frames . writeMedium ( 4 ) ; </a> 0
<a> frames . writeInt ( random . nextInt ( ) ) ; </a> 0
<a> frames . writeByte ( 0x80 ) ; </a> 0
<a> frames . writeByte ( version ) ; </a> 0
<a> frames . writeShort ( 5 ) ; </a> 0
<a> frames . writeInt ( 0 ) ; </a> 0
<a> frames . writeInt ( random . nextInt ( ) & 0x7FFFFFFF | 0x01 ) ; </a> 0
<a> frames . writeByte ( 0x01 ) ; </a> 0
<a> frames . writeMedium ( 1024 ) ; </a> 0
<a> for ( int i = 0 ; i < 256 ; i ++ ) { </a> 0
<a> frames . writeInt ( random . nextInt ( ) ) ; </a> 0
<a> } </a> 0
<a> frames . writeByte ( 0x80 ) ; </a> 0
<a> frames . writeByte ( version ) ; </a> 0
<a> frames . writeShort ( 1 ) ; </a> 0
<a> frames . writeByte ( 0x03 ) ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> frames . writeMedium ( 12 ) ; </a> 0
<a> } else { </a> 0
<a> frames . writeMedium ( 10 ) ; </a> 0
<a> } </a> 0
<a> frames . writeInt ( random . nextInt ( ) & 0x7FFFFFFF | 0x01 ) ; </a> 0
<a> frames . writeInt ( random . nextInt ( ) & 0x7FFFFFFF ) ; </a> 0
<a> frames . writeShort ( 0x8000 ) ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> frames . writeShort ( 0 ) ; </a> 0
<a> } </a> 0
<a> frames . writeByte ( 0x80 ) ; </a> 0
<a> frames . writeByte ( version ) ; </a> 0
<a> frames . writeShort ( 2 ) ; </a> 0
<a> frames . writeByte ( 0x01 ) ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> frames . writeMedium ( 8 ) ; </a> 0
<a> } else { </a> 0
<a> frames . writeMedium ( 4 ) ; </a> 0
<a> } </a> 0
<a> frames . writeInt ( random . nextInt ( ) & 0x7FFFFFFF | 0x01 ) ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> frames . writeInt ( 0 ) ; </a> 0
<a> } </a> 0
<a> frames . writeByte ( 0x80 ) ; </a> 0
<a> frames . writeByte ( version ) ; </a> 0
<a> frames . writeShort ( 3 ) ; </a> 0
<a> frames . writeInt ( 8 ) ; </a> 0
<a> frames . writeInt ( random . nextInt ( ) & 0x7FFFFFFF | 0x01 ) ; </a> 0
<a> frames . writeInt ( random . nextInt ( ) | 0x01 ) ; </a> 0
<a> frames . writeByte ( 0x80 ) ; </a> 0
<a> frames . writeByte ( version ) ; </a> 0
<a> frames . writeShort ( 4 ) ; </a> 0
<a> frames . writeByte ( 0x01 ) ; </a> 0
<a> frames . writeMedium ( 12 ) ; </a> 0
<a> frames . writeInt ( 1 ) ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> frames . writeMedium ( random . nextInt ( ) ) ; </a> 0
<a> frames . writeByte ( 0x03 ) ; </a> 0
<a> } else { </a> 0
<a> frames . writeByte ( 0x03 ) ; </a> 0
<a> frames . writeMedium ( random . nextInt ( ) ) ; </a> 0
<a> } </a> 0
<a> frames . writeInt ( random . nextInt ( ) ) ; </a> 0
<a> frames . writeByte ( 0x80 ) ; </a> 0
<a> frames . writeByte ( version ) ; </a> 0
<a> frames . writeShort ( 6 ) ; </a> 0
<a> frames . writeInt ( 4 ) ; </a> 0
<a> frames . writeInt ( random . nextInt ( ) ) ; </a> 0
<a> frames . writeByte ( 0x80 ) ; </a> 0
<a> frames . writeByte ( version ) ; </a> 0
<a> frames . writeShort ( 7 ) ; </a> 0
<a> if ( version < 3 ) { </a> 0
<a> frames . writeInt ( 4 ) ; </a> 0
<a> } else { </a> 0
<a> frames . writeInt ( 8 ) ; </a> 0
<a> } </a> 0
<a> frames . writeInt ( random . nextInt ( ) & 0x7FFFFFFF ) ; </a> 0
<a> if ( version >= 3 ) { </a> 0
<a> frames . writeInt ( random . nextInt ( ) | 0x01 ) ; </a> 0
<a> } </a> 0
<a> frames . writeByte ( 0x80 ) ; </a> 0
<a> frames . writeByte ( version ) ; </a> 0
<a> frames . writeShort ( 8 ) ; </a> 0
<a> frames . writeByte ( 0x01 ) ; </a> 0
<a> frames . writeMedium ( 4 ) ; </a> 0
<a> frames . writeInt ( random . nextInt ( ) & 0x7FFFFFFF | 0x01 ) ; </a> 0
<a> frames . writeByte ( 0x80 ) ; </a> 0
<a> frames . writeByte ( version ) ; </a> 0
<a> frames . writeShort ( 9 ) ; </a> 0
<a> frames . writeInt ( 8 ) ; </a> 0
<a> frames . writeInt ( random . nextInt ( ) & 0x7FFFFFFF | 0x01 ) ; </a> 0
<a> frames . writeInt ( random . nextInt ( ) & 0x7FFFFFFF | 0x01 ) ; </a> 0
<a> return frames ; </a> 0
<a> } </a> 0
<a> private int version ; </a> 0
<a> @ Test ( timeout = 15000 ) </a> 0
<a> public void testSpdyEcho ( ) throws Throwable { </a> 0
<a> for ( version = SpdyConstants . SPDY_MIN_VERSION ; version <= SpdyConstants . SPDY_MAX_VERSION ; version ++ ) { </a> 0
<a> logger . info ( "Testing against SPDY v" + version ) ; </a> 0
<a> run ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void testSpdyEcho ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { </a> 1
<a> ByteBuf frames = createFrames ( version ) ; </a> 0
<a> final SpdyEchoTestServerHandler sh = new SpdyEchoTestServerHandler ( ) ; </a> 1
<a> final SpdyEchoTestClientHandler ch = new SpdyEchoTestClientHandler ( frames ) ; </a> 0
<a> sb . childHandler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel channel ) throws Exception { </a> 0
<a> channel . pipeline ( ) . addLast ( </a> 0
<a> new SpdyFrameDecoder ( version ) , </a> 0
<a> new SpdyFrameEncoder ( version ) , </a> 0
<a> sh ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> cb . handler ( ch ) ; </a> 0
<a> Channel sc = sb . localAddress ( 0 ) . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> int port = ( ( InetSocketAddress ) sc . localAddress ( ) ) . getPort ( ) ; </a> 0
<a> Channel cc = cb . remoteAddress ( NetworkConstants . LOCALHOST , port ) . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> cc . write ( frames ) ; </a> 0
<a> while ( ch . counter < frames . writerIndex ( ) - ignoredBytes ) { </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( sh . exception . get ( ) != null && ! ( sh . exception . get ( ) instanceof IOException ) ) { </a> 0
<a> throw sh . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null && ! ( ch . exception . get ( ) instanceof IOException ) ) { </a> 0
<a> throw ch . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> throw sh . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> throw ch . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class SpdyEchoTestServerHandler extends ChannelInboundMessageHandlerAdapter < Object > { </a> 0
<a> final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 0
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , Object msg ) throws Exception { </a> 1
<a> ctx . write ( msg ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> if ( exception . compareAndSet ( null , cause ) ) { </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class SpdyEchoTestClientHandler extends ChannelInboundByteHandlerAdapter { </a> 0
<a> final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 0
<a> final ByteBuf frames ; </a> 0
<a> volatile int counter ; </a> 0
<a> SpdyEchoTestClientHandler ( ByteBuf frames ) { </a> 1
<a> this . frames = frames ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 1
<a> byte [ ] actual = new byte [ in . readableBytes ( ) ] ; </a> 0
<a> in . readBytes ( actual ) ; </a> 0
<a> int lastIdx = counter ; </a> 0
<a> for ( int i = 0 ; i < actual . length ; i ++ ) { </a> 0
<a> assertEquals ( frames . getByte ( ignoredBytes + i + lastIdx ) , actual [ i ] ) ; </a> 0
<a> } </a> 0
<a> counter += actual . length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> if ( exception . compareAndSet ( null , cause ) ) { </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . transport . socket ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 1
<a> import io . netty . channel . ChannelFutureListener ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 1
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . handler . ssl . SslHandler ; </a> 0
<a> import java . io . ByteArrayInputStream ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . security . InvalidAlgorithmParameterException ; </a> 0
<a> import java . security . KeyStore ; </a> 0
<a> import java . security . KeyStoreException ; </a> 0
<a> import java . security . Security ; </a> 0
<a> import java . security . cert . CertificateException ; </a> 0
<a> import java . security . cert . X509Certificate ; </a> 0
<a> import java . util . Random ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 1
<a> import javax . net . ssl . KeyManagerFactory ; </a> 1
<a> import javax . net . ssl . ManagerFactoryParameters ; </a> 1
<a> import javax . net . ssl . SSLContext ; </a> 0
<a> import javax . net . ssl . SSLEngine ; </a> 0
<a> import javax . net . ssl . TrustManager ; </a> 0
<a> import javax . net . ssl . TrustManagerFactorySpi ; </a> 0
<a> import javax . net . ssl . X509TrustManager ; </a> 0
<a> import org . junit . Test ; </a> 1
<a> public class SocketSslEchoTest extends AbstractSocketTest { </a> 0
<a> private static final int FIRST_MESSAGE_SIZE = 16384 ; </a> 0
<a> private static final Random random = new Random ( ) ; </a> 0
<a> static final byte [ ] data = new byte [ 1048576 ] ; </a> 0
<a> static { </a> 0
<a> random . nextBytes ( data ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 1
<a> public void testSslEcho ( ) throws Throwable { </a> 1
<a> run ( ) ; </a> 1
<a> } </a> 0
<a> public void testSslEcho ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { </a> 1
<a> final EchoHandler sh = new EchoHandler ( true ) ; </a> 0
<a> final EchoHandler ch = new EchoHandler ( false ) ; </a> 0
<a> final SSLEngine sse = BogusSslContextFactory . getServerContext ( ) . createSSLEngine ( ) ; </a> 0
<a> final SSLEngine cse = BogusSslContextFactory . getClientContext ( ) . createSSLEngine ( ) ; </a> 0
<a> sse . setUseClientMode ( false ) ; </a> 0
<a> cse . setUseClientMode ( true ) ; </a> 0
<a> sb . childHandler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel sch ) throws Exception { </a> 0
<a> sch . pipeline ( ) . addFirst ( "ssl" , new SslHandler ( sse ) ) ; </a> 0
<a> sch . pipeline ( ) . addLast ( "handler" , sh ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> cb . handler ( new ChannelInitializer < SocketChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( SocketChannel sch ) throws Exception { </a> 0
<a> sch . pipeline ( ) . addFirst ( "ssl" , new SslHandler ( cse ) ) ; </a> 0
<a> sch . pipeline ( ) . addLast ( "handler" , ch ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> Channel cc = cb . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> ChannelFuture hf = cc . pipeline ( ) . get ( SslHandler . class ) . handshake ( ) ; </a> 1
<a> final ChannelFuture firstByteWriteFuture = </a> 0
<a> cc . write ( Unpooled . wrappedBuffer ( data , 0 , FIRST_MESSAGE_SIZE ) ) ; </a> 0
<a> final AtomicBoolean firstByteWriteFutureDone = new AtomicBoolean ( ) ; </a> 0
<a> hf . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 0
<a> firstByteWriteFutureDone . set ( firstByteWriteFuture . isDone ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> hf . sync ( ) ; </a> 0
<a> assertFalse ( firstByteWriteFutureDone . get ( ) ) ; </a> 0
<a> for ( int i = FIRST_MESSAGE_SIZE ; i < data . length ; ) { </a> 0
<a> int length = Math . min ( random . nextInt ( 1024 * 64 ) , data . length - i ) ; </a> 0
<a> cc . write ( Unpooled . wrappedBuffer ( data , i , length ) ) ; </a> 0
<a> i += length ; </a> 0
<a> } </a> 0
<a> while ( ch . counter < data . length ) { </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> while ( sh . counter < data . length ) { </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> sh . channel . close ( ) . awaitUninterruptibly ( ) ; </a> 0
<a> ch . channel . close ( ) . awaitUninterruptibly ( ) ; </a> 0
<a> sc . close ( ) . awaitUninterruptibly ( ) ; </a> 0
<a> if ( sh . exception . get ( ) != null && ! ( sh . exception . get ( ) instanceof IOException ) ) { </a> 0
<a> throw sh . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null && ! ( ch . exception . get ( ) instanceof IOException ) ) { </a> 0
<a> throw ch . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( sh . exception . get ( ) != null ) { </a> 0
<a> throw sh . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( ch . exception . get ( ) != null ) { </a> 0
<a> throw ch . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class EchoHandler extends ChannelInboundByteHandlerAdapter { </a> 1
<a> volatile Channel channel ; </a> 0
<a> final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 0
<a> volatile int counter ; </a> 0
<a> private final boolean server ; </a> 0
<a> EchoHandler ( boolean server ) { </a> 0
<a> this . server = server ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) </a> 1
<a> throws Exception { </a> 1
<a> channel = ctx . channel ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( </a> 1
<a> ChannelHandlerContext ctx , ByteBuf in ) </a> 1
<a> throws Exception { </a> 1
<a> byte [ ] actual = new byte [ in . readableBytes ( ) ] ; </a> 0
<a> in . readBytes ( actual ) ; </a> 0
<a> int lastIdx = counter ; </a> 0
<a> for ( int i = 0 ; i < actual . length ; i ++ ) { </a> 0
<a> assertEquals ( data [ i + lastIdx ] , actual [ i ] ) ; </a> 0
<a> } </a> 0
<a> if ( channel . parent ( ) != null ) { </a> 0
<a> channel . write ( Unpooled . wrappedBuffer ( actual ) ) ; </a> 0
<a> } </a> 0
<a> counter += actual . length ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , </a> 1
<a> Throwable cause ) throws Exception { </a> 1
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( </a> 0
<a> "Unexpected exception from the " + </a> 0
<a> ( server ? "server" : "client" ) + " side" , cause ) ; </a> 0
<a> } </a> 0
<a> exception . compareAndSet ( null , cause ) ; </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class BogusSslContextFactory { </a> 1
<a> private static final String PROTOCOL = "TLS" ; </a> 0
<a> private static final SSLContext SERVER_CONTEXT ; </a> 0
<a> private static final SSLContext CLIENT_CONTEXT ; </a> 0
<a> static { </a> 0
<a> String algorithm = Security . getProperty ( "ssl.KeyManagerFactory.algorithm" ) ; </a> 0
<a> if ( algorithm == null ) { </a> 0
<a> algorithm = "SunX509" ; </a> 0
<a> } </a> 0
<a> SSLContext serverContext ; </a> 0
<a> SSLContext clientContext ; </a> 0
<a> try { </a> 0
<a> KeyStore ks = KeyStore . getInstance ( "JKS" ) ; </a> 0
<a> ks . load ( BogusKeyStore . asInputStream ( ) , </a> 0
<a> BogusKeyStore . getKeyStorePassword ( ) ) ; </a> 0
<a> KeyManagerFactory kmf = KeyManagerFactory . getInstance ( algorithm ) ; </a> 0
<a> kmf . init ( ks , BogusKeyStore . getCertificatePassword ( ) ) ; </a> 0
<a> serverContext = SSLContext . getInstance ( PROTOCOL ) ; </a> 0
<a> serverContext . init ( kmf . getKeyManagers ( ) , null , null ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new Error ( </a> 0
<a> "Failed to initialize the server-side SSLContext" , e ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> clientContext = SSLContext . getInstance ( PROTOCOL ) ; </a> 0
<a> clientContext . init ( null , BogusTrustManagerFactory . getTrustManagers ( ) , null ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new Error ( </a> 0
<a> "Failed to initialize the client-side SSLContext" , e ) ; </a> 0
<a> } </a> 0
<a> SERVER_CONTEXT = serverContext ; </a> 0
<a> CLIENT_CONTEXT = clientContext ; </a> 0
<a> } </a> 0
<a> public static SSLContext getServerContext ( ) { </a> 0
<a> return SERVER_CONTEXT ; </a> 0
<a> } </a> 0
<a> public static SSLContext getClientContext ( ) { </a> 0
<a> return CLIENT_CONTEXT ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class BogusTrustManagerFactory extends TrustManagerFactorySpi { </a> 0
<a> private static final TrustManager DUMMY_TRUST_MANAGER = new X509TrustManager ( ) { </a> 0
<a> @ Override </a> 0
<a> public X509Certificate [ ] getAcceptedIssuers ( ) { </a> 0
<a> return new X509Certificate [ 0 ] ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void checkClientTrusted ( </a> 0
<a> X509Certificate [ ] chain , String authType ) throws CertificateException { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void checkServerTrusted ( </a> 0
<a> X509Certificate [ ] chain , String authType ) throws CertificateException { </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> public static TrustManager [ ] getTrustManagers ( ) { </a> 0
<a> return new TrustManager [ ] { DUMMY_TRUST_MANAGER } ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected TrustManager [ ] engineGetTrustManagers ( ) { </a> 0
<a> return getTrustManagers ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void engineInit ( KeyStore keystore ) throws KeyStoreException { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void engineInit ( ManagerFactoryParameters managerFactoryParameters ) </a> 0
<a> throws InvalidAlgorithmParameterException { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static final class BogusKeyStore { </a> 0
<a> private static final short [ ] DATA = { </a> 0
<a> 0xfe , 0xed , 0xfe , 0xed , 0x00 , 0x00 , 0x00 , 0x02 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x02 , 0x00 , 0x00 , 0x00 , 0x01 , </a> 0
<a> 0x00 , 0x07 , 0x65 , 0x78 , 0x61 , 0x6d , 0x70 , 0x6c , </a> 0
<a> 0x65 , 0x00 , 0x00 , 0x01 , 0x1a , 0x9f , 0x57 , 0xa5 , </a> 0
<a> 0x27 , 0x00 , 0x00 , 0x01 , 0x9a , 0x30 , 0x82 , 0x01 , </a> 0
<a> 0x96 , 0x30 , 0x0e , 0x06 , 0x0a , 0x2b , 0x06 , 0x01 , </a> 0
<a> 0x04 , 0x01 , 0x2a , 0x02 , 0x11 , 0x01 , 0x01 , 0x05 , </a> 0
<a> 0x00 , 0x04 , 0x82 , 0x01 , 0x82 , 0x48 , 0x6d , 0xcf , </a> 0
<a> 0x16 , 0xb5 , 0x50 , 0x95 , 0x36 , 0xbf , 0x47 , 0x27 , </a> 0
<a> 0x50 , 0x58 , 0x0d , 0xa2 , 0x52 , 0x7e , 0x25 , 0xab , </a> 0
<a> 0x14 , 0x1a , 0x26 , 0x5e , 0x2d , 0x8a , 0x23 , 0x90 , </a> 0
<a> 0x60 , 0x7f , 0x12 , 0x20 , 0x56 , 0xd1 , 0x43 , 0xa2 , </a> 0
<a> 0x6b , 0x47 , 0x5d , 0xed , 0x9d , 0xd4 , 0xe5 , 0x83 , </a> 0
<a> 0x28 , 0x89 , 0xc2 , 0x16 , 0x4c , 0x76 , 0x06 , 0xad , </a> 0
<a> 0x8e , 0x8c , 0x29 , 0x1a , 0x9b , 0x0f , 0xdd , 0x60 , </a> 0
<a> 0x4b , 0xb4 , 0x62 , 0x82 , 0x9e , 0x4a , 0x63 , 0x83 , </a> 0
<a> 0x2e , 0xd2 , 0x43 , 0x78 , 0xc2 , 0x32 , 0x1f , 0x60 , </a> 0
<a> 0xa9 , 0x8a , 0x7f , 0x0f , 0x7c , 0xa6 , 0x1d , 0xe6 , </a> 0
<a> 0x92 , 0x9e , 0x52 , 0xc7 , 0x7d , 0xbb , 0x35 , 0x3b , </a> 0
<a> 0xaa , 0x89 , 0x73 , 0x4c , 0xfb , 0x99 , 0x54 , 0x97 , </a> 0
<a> 0x99 , 0x28 , 0x6e , 0x66 , 0x5b , 0xf7 , 0x9b , 0x7e , </a> 0
<a> 0x6d , 0x8a , 0x2f , 0xfa , 0xc3 , 0x1e , 0x71 , 0xb9 , </a> 0
<a> 0xbd , 0x8f , 0xc5 , 0x63 , 0x25 , 0x31 , 0x20 , 0x02 , </a> 0
<a> 0xff , 0x02 , 0xf0 , 0xc9 , 0x2c , 0xdd , 0x3a , 0x10 , </a> 0
<a> 0x30 , 0xab , 0xe5 , 0xad , 0x3d , 0x1a , 0x82 , 0x77 , </a> 0
<a> 0x46 , 0xed , 0x03 , 0x38 , 0xa4 , 0x73 , 0x6d , 0x36 , </a> 0
<a> 0x36 , 0x33 , 0x70 , 0xb2 , 0x63 , 0x20 , 0xca , 0x03 , </a> 0
<a> 0xbf , 0x5a , 0xf4 , 0x7c , 0x35 , 0xf0 , 0x63 , 0x1a , </a> 0
<a> 0x12 , 0x33 , 0x12 , 0x58 , 0xd9 , 0xa2 , 0x63 , 0x6b , </a> 0
<a> 0x63 , 0x82 , 0x41 , 0x65 , 0x70 , 0x37 , 0x4b , 0x99 , </a> 0
<a> 0x04 , 0x9f , 0xdd , 0x5e , 0x07 , 0x01 , 0x95 , 0x9f , </a> 0
<a> 0x36 , 0xe8 , 0xc3 , 0x66 , 0x2a , 0x21 , 0x69 , 0x68 , </a> 0
<a> 0x40 , 0xe6 , 0xbc , 0xbb , 0x85 , 0x81 , 0x21 , 0x13 , </a> 0
<a> 0xe6 , 0xa4 , 0xcf , 0xd3 , 0x67 , 0xe3 , 0xfd , 0x75 , </a> 0
<a> 0xf0 , 0xdf , 0x83 , 0xe0 , 0xc5 , 0x36 , 0x09 , 0xac , </a> 0
<a> 0x1b , 0xd4 , 0xf7 , 0x2a , 0x23 , 0x57 , 0x1c , 0x5c , </a> 0
<a> 0x0f , 0xf4 , 0xcf , 0xa2 , 0xcf , 0xf5 , 0xbd , 0x9c , </a> 0
<a> 0x69 , 0x98 , 0x78 , 0x3a , 0x25 , 0xe4 , 0xfd , 0x85 , </a> 0
<a> 0x11 , 0xcc , 0x7d , 0xef , 0xeb , 0x74 , 0x60 , 0xb1 , </a> 0
<a> 0xb7 , 0xfb , 0x1f , 0x0e , 0x62 , 0xff , 0xfe , 0x09 , </a> 0
<a> 0x0a , 0xc3 , 0x80 , 0x2f , 0x10 , 0x49 , 0x89 , 0x78 , </a> 0
<a> 0xd2 , 0x08 , 0xfa , 0x89 , 0x22 , 0x45 , 0x91 , 0x21 , </a> 0
<a> 0xbc , 0x90 , 0x3e , 0xad , 0xb3 , 0x0a , 0xb4 , 0x0e , </a> 0
<a> 0x1c , 0xa1 , 0x93 , 0x92 , 0xd8 , 0x72 , 0x07 , 0x54 , </a> 0
<a> 0x60 , 0xe7 , 0x91 , 0xfc , 0xd9 , 0x3c , 0xe1 , 0x6f , </a> 0
<a> 0x08 , 0xe4 , 0x56 , 0xf6 , 0x0b , 0xb0 , 0x3c , 0x39 , </a> 0
<a> 0x8a , 0x2d , 0x48 , 0x44 , 0x28 , 0x13 , 0xca , 0xe9 , </a> 0
<a> 0xf7 , 0xa3 , 0xb6 , 0x8a , 0x5f , 0x31 , 0xa9 , 0x72 , </a> 0
<a> 0xf2 , 0xde , 0x96 , 0xf2 , 0xb1 , 0x53 , 0xb1 , 0x3e , </a> 0
<a> 0x24 , 0x57 , 0xfd , 0x18 , 0x45 , 0x1f , 0xc5 , 0x33 , </a> 0
<a> 0x1b , 0xa4 , 0xe8 , 0x21 , 0xfa , 0x0e , 0xb2 , 0xb9 , </a> 0
<a> 0xcb , 0xc7 , 0x07 , 0x41 , 0xdd , 0x2f , 0xb6 , 0x6a , </a> 0
<a> 0x23 , 0x18 , 0xed , 0xc1 , 0xef , 0xe2 , 0x4b , 0xec , </a> 0
<a> 0xc9 , 0xba , 0xfb , 0x46 , 0x43 , 0x90 , 0xd7 , 0xb5 , </a> 0
<a> 0x68 , 0x28 , 0x31 , 0x2b , 0x8d , 0xa8 , 0x51 , 0x63 , </a> 0
<a> 0xf7 , 0x53 , 0x99 , 0x19 , 0x68 , 0x85 , 0x66 , 0x00 , </a> 0
<a> 0x00 , 0x00 , 0x01 , 0x00 , 0x05 , 0x58 , 0x2e , 0x35 , </a> 0
<a> 0x30 , 0x39 , 0x00 , 0x00 , 0x02 , 0x3a , 0x30 , 0x82 , </a> 0
<a> 0x02 , 0x36 , 0x30 , 0x82 , 0x01 , 0xe0 , 0xa0 , 0x03 , </a> 0
<a> 0x02 , 0x01 , 0x02 , 0x02 , 0x04 , 0x48 , 0x59 , 0xf1 , </a> 0
<a> 0x92 , 0x30 , 0x0d , 0x06 , 0x09 , 0x2a , 0x86 , 0x48 , </a> 0
<a> 0x86 , 0xf7 , 0x0d , 0x01 , 0x01 , 0x05 , 0x05 , 0x00 , </a> 0
<a> 0x30 , 0x81 , 0xa0 , 0x31 , 0x0b , 0x30 , 0x09 , 0x06 , </a> 0
<a> 0x03 , 0x55 , 0x04 , 0x06 , 0x13 , 0x02 , 0x4b , 0x52 , </a> 0
<a> 0x31 , 0x13 , 0x30 , 0x11 , 0x06 , 0x03 , 0x55 , 0x04 , </a> 0
<a> 0x08 , 0x13 , 0x0a , 0x4b , 0x79 , 0x75 , 0x6e , 0x67 , </a> 0
<a> 0x67 , 0x69 , 0x2d , 0x64 , 0x6f , 0x31 , 0x14 , 0x30 , </a> 0
<a> 0x12 , 0x06 , 0x03 , 0x55 , 0x04 , 0x07 , 0x13 , 0x0b , </a> 0
<a> 0x53 , 0x65 , 0x6f , 0x6e , 0x67 , 0x6e , 0x61 , 0x6d , </a> 0
<a> 0x2d , 0x73 , 0x69 , 0x31 , 0x1a , 0x30 , 0x18 , 0x06 , </a> 0
<a> 0x03 , 0x55 , 0x04 , 0x0a , 0x13 , 0x11 , 0x54 , 0x68 , </a> 0
<a> 0x65 , 0x20 , 0x4e , 0x65 , 0x74 , 0x74 , 0x79 , 0x20 , </a> 0
<a> 0x50 , 0x72 , 0x6f , 0x6a , 0x65 , 0x63 , 0x74 , 0x31 , </a> 0
<a> 0x18 , 0x30 , 0x16 , 0x06 , 0x03 , 0x55 , 0x04 , 0x0b , </a> 0
<a> 0x13 , 0x0f , 0x45 , 0x78 , 0x61 , 0x6d , 0x70 , 0x6c , </a> 0
<a> 0x65 , 0x20 , 0x41 , 0x75 , 0x74 , 0x68 , 0x6f , 0x72 , </a> 0
<a> 0x73 , 0x31 , 0x30 , 0x30 , 0x2e , 0x06 , 0x03 , 0x55 , </a> 0
<a> 0x04 , 0x03 , 0x13 , 0x27 , 0x73 , 0x65 , 0x63 , 0x75 , </a> 0
<a> 0x72 , 0x65 , 0x63 , 0x68 , 0x61 , 0x74 , 0x2e , 0x65 , </a> 0
<a> 0x78 , 0x61 , 0x6d , 0x70 , 0x6c , 0x65 , 0x2e , 0x6e , </a> 0
<a> 0x65 , 0x74 , 0x74 , 0x79 , 0x2e , 0x67 , 0x6c , 0x65 , </a> 0
<a> 0x61 , 0x6d , 0x79 , 0x6e , 0x6f , 0x64 , 0x65 , 0x2e , </a> 0
<a> 0x6e , 0x65 , 0x74 , 0x30 , 0x20 , 0x17 , 0x0d , 0x30 , </a> 0
<a> 0x38 , 0x30 , 0x36 , 0x31 , 0x39 , 0x30 , 0x35 , 0x34 , </a> 0
<a> 0x31 , 0x33 , 0x38 , 0x5a , 0x18 , 0x0f , 0x32 , 0x31 , </a> 0
<a> 0x38 , 0x37 , 0x31 , 0x31 , 0x32 , 0x34 , 0x30 , 0x35 , </a> 0
<a> 0x34 , 0x31 , 0x33 , 0x38 , 0x5a , 0x30 , 0x81 , 0xa0 , </a> 0
<a> 0x31 , 0x0b , 0x30 , 0x09 , 0x06 , 0x03 , 0x55 , 0x04 , </a> 0
<a> 0x06 , 0x13 , 0x02 , 0x4b , 0x52 , 0x31 , 0x13 , 0x30 , </a> 0
<a> 0x11 , 0x06 , 0x03 , 0x55 , 0x04 , 0x08 , 0x13 , 0x0a , </a> 0
<a> 0x4b , 0x79 , 0x75 , 0x6e , 0x67 , 0x67 , 0x69 , 0x2d , </a> 0
<a> 0x64 , 0x6f , 0x31 , 0x14 , 0x30 , 0x12 , 0x06 , 0x03 , </a> 0
<a> 0x55 , 0x04 , 0x07 , 0x13 , 0x0b , 0x53 , 0x65 , 0x6f , </a> 0
<a> 0x6e , 0x67 , 0x6e , 0x61 , 0x6d , 0x2d , 0x73 , 0x69 , </a> 0
<a> 0x31 , 0x1a , 0x30 , 0x18 , 0x06 , 0x03 , 0x55 , 0x04 , </a> 0
<a> 0x0a , 0x13 , 0x11 , 0x54 , 0x68 , 0x65 , 0x20 , 0x4e , </a> 0
<a> 0x65 , 0x74 , 0x74 , 0x79 , 0x20 , 0x50 , 0x72 , 0x6f , </a> 0
<a> 0x6a , 0x65 , 0x63 , 0x74 , 0x31 , 0x18 , 0x30 , 0x16 , </a> 0
<a> 0x06 , 0x03 , 0x55 , 0x04 , 0x0b , 0x13 , 0x0f , 0x45 , </a> 0
<a> 0x78 , 0x61 , 0x6d , 0x70 , 0x6c , 0x65 , 0x20 , 0x41 , </a> 0
<a> 0x75 , 0x74 , 0x68 , 0x6f , 0x72 , 0x73 , 0x31 , 0x30 , </a> 0
<a> 0x30 , 0x2e , 0x06 , 0x03 , 0x55 , 0x04 , 0x03 , 0x13 , </a> 0
<a> 0x27 , 0x73 , 0x65 , 0x63 , 0x75 , 0x72 , 0x65 , 0x63 , </a> 0
<a> 0x68 , 0x61 , 0x74 , 0x2e , 0x65 , 0x78 , 0x61 , 0x6d , </a> 0
<a> 0x70 , 0x6c , 0x65 , 0x2e , 0x6e , 0x65 , 0x74 , 0x74 , </a> 0
<a> 0x79 , 0x2e , 0x67 , 0x6c , 0x65 , 0x61 , 0x6d , 0x79 , </a> 0
<a> 0x6e , 0x6f , 0x64 , 0x65 , 0x2e , 0x6e , 0x65 , 0x74 , </a> 0
<a> 0x30 , 0x5c , 0x30 , 0x0d , 0x06 , 0x09 , 0x2a , 0x86 , </a> 0
<a> 0x48 , 0x86 , 0xf7 , 0x0d , 0x01 , 0x01 , 0x01 , 0x05 , </a> 0
<a> 0x00 , 0x03 , 0x4b , 0x00 , 0x30 , 0x48 , 0x02 , 0x41 , </a> 0
<a> 0x00 , 0xc3 , 0xe3 , 0x5e , 0x41 , 0xa7 , 0x87 , 0x11 , </a> 0
<a> 0x00 , 0x42 , 0x2a , 0xb0 , 0x4b , 0xed , 0xb2 , 0xe0 , </a> 0
<a> 0x23 , 0xdb , 0xb1 , 0x3d , 0x58 , 0x97 , 0x35 , 0x60 , </a> 0
<a> 0x0b , 0x82 , 0x59 , 0xd3 , 0x00 , 0xea , 0xd4 , 0x61 , </a> 0
<a> 0xb8 , 0x79 , 0x3f , 0xb6 , 0x3c , 0x12 , 0x05 , 0x93 , </a> 0
<a> 0x2e , 0x9a , 0x59 , 0x68 , 0x14 , 0x77 , 0x3a , 0xc8 , </a> 0
<a> 0x50 , 0x25 , 0x57 , 0xa4 , 0x49 , 0x18 , 0x63 , 0x41 , </a> 0
<a> 0xf0 , 0x2d , 0x28 , 0xec , 0x06 , 0xfb , 0xb4 , 0x9f , </a> 0
<a> 0xbf , 0x02 , 0x03 , 0x01 , 0x00 , 0x01 , 0x30 , 0x0d , </a> 0
<a> 0x06 , 0x09 , 0x2a , 0x86 , 0x48 , 0x86 , 0xf7 , 0x0d , </a> 0
<a> 0x01 , 0x01 , 0x05 , 0x05 , 0x00 , 0x03 , 0x41 , 0x00 , </a> 0
<a> 0x65 , 0x6c , 0x30 , 0x01 , 0xc2 , 0x8e , 0x3e , 0xcb , </a> 0
<a> 0xb3 , 0x77 , 0x48 , 0xe9 , 0x66 , 0x61 , 0x9a , 0x40 , </a> 0
<a> 0x86 , 0xaf , 0xf6 , 0x03 , 0xeb , 0xba , 0x6a , 0xf2 , </a> 0
<a> 0xfd , 0xe2 , 0xaf , 0x36 , 0x5e , 0x7b , 0xaa , 0x22 , </a> 0
<a> 0x04 , 0xdd , 0x2c , 0x20 , 0xc4 , 0xfc , 0xdd , 0xd0 , </a> 0
<a> 0x82 , 0x20 , 0x1c , 0x3d , 0xd7 , 0x9e , 0x5e , 0x5c , </a> 0
<a> 0x92 , 0x5a , 0x76 , 0x71 , 0x28 , 0xf5 , 0x07 , 0x7d , </a> 0
<a> 0xa2 , 0x81 , 0xba , 0x77 , 0x9f , 0x2a , 0xd9 , 0x44 , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x01 , 0x00 , 0x05 , 0x6d , 0x79 , </a> 0
<a> 0x6b , 0x65 , 0x79 , 0x00 , 0x00 , 0x01 , 0x1a , 0x9f , </a> 0
<a> 0x5b , 0x56 , 0xa0 , 0x00 , 0x00 , 0x01 , 0x99 , 0x30 , </a> 0
<a> 0x82 , 0x01 , 0x95 , 0x30 , 0x0e , 0x06 , 0x0a , 0x2b , </a> 0
<a> 0x06 , 0x01 , 0x04 , 0x01 , 0x2a , 0x02 , 0x11 , 0x01 , </a> 0
<a> 0x01 , 0x05 , 0x00 , 0x04 , 0x82 , 0x01 , 0x81 , 0x29 , </a> 0
<a> 0xa8 , 0xb6 , 0x08 , 0x0c , 0x85 , 0x75 , 0x3e , 0xdd , </a> 0
<a> 0xb5 , 0xe5 , 0x1a , 0x87 , 0x68 , 0xd1 , 0x90 , 0x4b , </a> 0
<a> 0x29 , 0x31 , 0xee , 0x90 , 0xbc , 0x9d , 0x73 , 0xa0 , </a> 0
<a> 0x3f , 0xe9 , 0x0b , 0xa4 , 0xef , 0x30 , 0x9b , 0x36 , </a> 0
<a> 0x9a , 0xb2 , 0x54 , 0x77 , 0x81 , 0x07 , 0x4b , 0xaa , </a> 0
<a> 0xa5 , 0x77 , 0x98 , 0xe1 , 0xeb , 0xb5 , 0x7c , 0x4e , </a> 0
<a> 0x48 , 0xd5 , 0x08 , 0xfc , 0x2c , 0x36 , 0xe2 , 0x65 , </a> 0
<a> 0x03 , 0xac , 0xe5 , 0xf3 , 0x96 , 0xb7 , 0xd0 , 0xb5 , </a> 0
<a> 0x3b , 0x92 , 0xe4 , 0x14 , 0x05 , 0x7a , 0x6a , 0x92 , </a> 0
<a> 0x56 , 0xfe , 0x4e , 0xab , 0xd3 , 0x0e , 0x32 , 0x04 , </a> 0
<a> 0x22 , 0x22 , 0x74 , 0x47 , 0x7d , 0xec , 0x21 , 0x99 , </a> 0
<a> 0x30 , 0x31 , 0x64 , 0x46 , 0x64 , 0x9b , 0xc7 , 0x13 , </a> 0
<a> 0xbf , 0xbe , 0xd0 , 0x31 , 0x49 , 0xe7 , 0x3c , 0xbf , </a> 0
<a> 0xba , 0xb1 , 0x20 , 0xf9 , 0x42 , 0xf4 , 0xa9 , 0xa9 , </a> 0
<a> 0xe5 , 0x13 , 0x65 , 0x32 , 0xbf , 0x7c , 0xcc , 0x91 , </a> 0
<a> 0xd3 , 0xfd , 0x24 , 0x47 , 0x0b , 0xe5 , 0x53 , 0xad , </a> 0
<a> 0x50 , 0x30 , 0x56 , 0xd1 , 0xfa , 0x9c , 0x37 , 0xa8 , </a> 0
<a> 0xc1 , 0xce , 0xf6 , 0x0b , 0x18 , 0xaa , 0x7c , 0xab , </a> 0
<a> 0xbd , 0x1f , 0xdf , 0xe4 , 0x80 , 0xb8 , 0xa7 , 0xe0 , </a> 0
<a> 0xad , 0x7d , 0x50 , 0x74 , 0xf1 , 0x98 , 0x78 , 0xbc , </a> 0
<a> 0x58 , 0xb9 , 0xc2 , 0x52 , 0xbe , 0xd2 , 0x5b , 0x81 , </a> 0
<a> 0x94 , 0x83 , 0x8f , 0xb9 , 0x4c , 0xee , 0x01 , 0x2b , </a> 0
<a> 0x5e , 0xc9 , 0x6e , 0x9b , 0xf5 , 0x63 , 0x69 , 0xe4 , </a> 0
<a> 0xd8 , 0x0b , 0x47 , 0xd8 , 0xfd , 0xd8 , 0xe0 , 0xed , </a> 0
<a> 0xa8 , 0x27 , 0x03 , 0x74 , 0x1e , 0x5d , 0x32 , 0xe6 , </a> 0
<a> 0x5c , 0x63 , 0xc2 , 0xfb , 0x3f , 0xee , 0xb4 , 0x13 , </a> 0
<a> 0xc6 , 0x0e , 0x6e , 0x74 , 0xe0 , 0x22 , 0xac , 0xce , </a> 0
<a> 0x79 , 0xf9 , 0x43 , 0x68 , 0xc1 , 0x03 , 0x74 , 0x2b , </a> 0
<a> 0xe1 , 0x18 , 0xf8 , 0x7f , 0x76 , 0x9a , 0xea , 0x82 , </a> 0
<a> 0x3f , 0xc2 , 0xa6 , 0xa7 , 0x4c , 0xfe , 0xae , 0x29 , </a> 0
<a> 0x3b , 0xc1 , 0x10 , 0x7c , 0xd5 , 0x77 , 0x17 , 0x79 , </a> 0
<a> 0x5f , 0xcb , 0xad , 0x1f , 0xd8 , 0xa1 , 0xfd , 0x90 , </a> 0
<a> 0xe1 , 0x6b , 0xb2 , 0xef , 0xb9 , 0x41 , 0x26 , 0xa4 , </a> 0
<a> 0x0b , 0x4f , 0xc6 , 0x83 , 0x05 , 0x6f , 0xf0 , 0x64 , </a> 0
<a> 0x40 , 0xe1 , 0x44 , 0xc4 , 0xf9 , 0x40 , 0x2b , 0x3b , </a> 0
<a> 0x40 , 0xdb , 0xaf , 0x35 , 0xa4 , 0x9b , 0x9f , 0xc4 , </a> 0
<a> 0x74 , 0x07 , 0xe5 , 0x18 , 0x60 , 0xc5 , 0xfe , 0x15 , </a> 0
<a> 0x0e , 0x3a , 0x25 , 0x2a , 0x11 , 0xee , 0x78 , 0x2f , </a> 0
<a> 0xb8 , 0xd1 , 0x6e , 0x4e , 0x3c , 0x0a , 0xb5 , 0xb9 , </a> 0
<a> 0x40 , 0x86 , 0x27 , 0x6d , 0x8f , 0x53 , 0xb7 , 0x77 , </a> 0
<a> 0x36 , 0xec , 0x5d , 0xed , 0x32 , 0x40 , 0x43 , 0x82 , </a> 0
<a> 0xc3 , 0x52 , 0x58 , 0xc4 , 0x26 , 0x39 , 0xf3 , 0xb3 , </a> 0
<a> 0xad , 0x58 , 0xab , 0xb7 , 0xf7 , 0x8e , 0x0e , 0xba , </a> 0
<a> 0x8e , 0x78 , 0x9d , 0xbf , 0x58 , 0x34 , 0xbd , 0x77 , </a> 0
<a> 0x73 , 0xa6 , 0x50 , 0x55 , 0x00 , 0x60 , 0x26 , 0xbf , </a> 0
<a> 0x6d , 0xb4 , 0x98 , 0x8a , 0x18 , 0x83 , 0x89 , 0xf8 , </a> 0
<a> 0xcd , 0x0d , 0x49 , 0x06 , 0xae , 0x51 , 0x6e , 0xaf , </a> 0
<a> 0xbd , 0xe2 , 0x07 , 0x13 , 0xd8 , 0x64 , 0xcc , 0xbf , </a> 0
<a> 0x00 , 0x00 , 0x00 , 0x01 , 0x00 , 0x05 , 0x58 , 0x2e , </a> 0
<a> 0x35 , 0x30 , 0x39 , 0x00 , 0x00 , 0x02 , 0x34 , 0x30 , </a> 0
<a> 0x82 , 0x02 , 0x30 , 0x30 , 0x82 , 0x01 , 0xda , 0xa0 , </a> 0
<a> 0x03 , 0x02 , 0x01 , 0x02 , 0x02 , 0x04 , 0x48 , 0x59 , </a> 0
<a> 0xf2 , 0x84 , 0x30 , 0x0d , 0x06 , 0x09 , 0x2a , 0x86 , </a> 0
<a> 0x48 , 0x86 , 0xf7 , 0x0d , 0x01 , 0x01 , 0x05 , 0x05 , </a> 0
<a> 0x00 , 0x30 , 0x81 , 0x9d , 0x31 , 0x0b , 0x30 , 0x09 , </a> 0
<a> 0x06 , 0x03 , 0x55 , 0x04 , 0x06 , 0x13 , 0x02 , 0x4b , </a> 0
<a> 0x52 , 0x31 , 0x13 , 0x30 , 0x11 , 0x06 , 0x03 , 0x55 , </a> 0
<a> 0x04 , 0x08 , 0x13 , 0x0a , 0x4b , 0x79 , 0x75 , 0x6e , </a> 0
<a> 0x67 , 0x67 , 0x69 , 0x2d , 0x64 , 0x6f , 0x31 , 0x14 , </a> 0
<a> 0x30 , 0x12 , 0x06 , 0x03 , 0x55 , 0x04 , 0x07 , 0x13 , </a> 0
<a> 0x0b , 0x53 , 0x65 , 0x6f , 0x6e , 0x67 , 0x6e , 0x61 , </a> 0
<a> 0x6d , 0x2d , 0x73 , 0x69 , 0x31 , 0x1a , 0x30 , 0x18 , </a> 0
<a> 0x06 , 0x03 , 0x55 , 0x04 , 0x0a , 0x13 , 0x11 , 0x54 , </a> 0
<a> 0x68 , 0x65 , 0x20 , 0x4e , 0x65 , 0x74 , 0x74 , 0x79 , </a> 0
<a> 0x20 , 0x50 , 0x72 , 0x6f , 0x6a , 0x65 , 0x63 , 0x74 , </a> 0
<a> 0x31 , 0x15 , 0x30 , 0x13 , 0x06 , 0x03 , 0x55 , 0x04 , </a> 0
<a> 0x0b , 0x13 , 0x0c , 0x43 , 0x6f , 0x6e , 0x74 , 0x72 , </a> 0
<a> 0x69 , 0x62 , 0x75 , 0x74 , 0x6f , 0x72 , 0x73 , 0x31 , </a> 0
<a> 0x30 , 0x30 , 0x2e , 0x06 , 0x03 , 0x55 , 0x04 , 0x03 , </a> 0
<a> 0x13 , 0x27 , 0x73 , 0x65 , 0x63 , 0x75 , 0x72 , 0x65 , </a> 0
<a> 0x63 , 0x68 , 0x61 , 0x74 , 0x2e , 0x65 , 0x78 , 0x61 , </a> 0
<a> 0x6d , 0x70 , 0x6c , 0x65 , 0x2e , 0x6e , 0x65 , 0x74 , </a> 0
<a> 0x74 , 0x79 , 0x2e , 0x67 , 0x6c , 0x65 , 0x61 , 0x6d , </a> 0
<a> 0x79 , 0x6e , 0x6f , 0x64 , 0x65 , 0x2e , 0x6e , 0x65 , </a> 0
<a> 0x74 , 0x30 , 0x20 , 0x17 , 0x0d , 0x30 , 0x38 , 0x30 , </a> 0
<a> 0x36 , 0x31 , 0x39 , 0x30 , 0x35 , 0x34 , 0x35 , 0x34 , </a> 0
<a> 0x30 , 0x5a , 0x18 , 0x0f , 0x32 , 0x31 , 0x38 , 0x37 , </a> 0
<a> 0x31 , 0x31 , 0x32 , 0x33 , 0x30 , 0x35 , 0x34 , 0x35 , </a> 0
<a> 0x34 , 0x30 , 0x5a , 0x30 , 0x81 , 0x9d , 0x31 , 0x0b , </a> 0
<a> 0x30 , 0x09 , 0x06 , 0x03 , 0x55 , 0x04 , 0x06 , 0x13 , </a> 0
<a> 0x02 , 0x4b , 0x52 , 0x31 , 0x13 , 0x30 , 0x11 , 0x06 , </a> 0
<a> 0x03 , 0x55 , 0x04 , 0x08 , 0x13 , 0x0a , 0x4b , 0x79 , </a> 0
<a> 0x75 , 0x6e , 0x67 , 0x67 , 0x69 , 0x2d , 0x64 , 0x6f , </a> 0
<a> 0x31 , 0x14 , 0x30 , 0x12 , 0x06 , 0x03 , 0x55 , 0x04 , </a> 0
<a> 0x07 , 0x13 , 0x0b , 0x53 , 0x65 , 0x6f , 0x6e , 0x67 , </a> 0
<a> 0x6e , 0x61 , 0x6d , 0x2d , 0x73 , 0x69 , 0x31 , 0x1a , </a> 0
<a> 0x30 , 0x18 , 0x06 , 0x03 , 0x55 , 0x04 , 0x0a , 0x13 , </a> 0
<a> 0x11 , 0x54 , 0x68 , 0x65 , 0x20 , 0x4e , 0x65 , 0x74 , </a> 0
<a> 0x74 , 0x79 , 0x20 , 0x50 , 0x72 , 0x6f , 0x6a , 0x65 , </a> 0
<a> 0x63 , 0x74 , 0x31 , 0x15 , 0x30 , 0x13 , 0x06 , 0x03 , </a> 0
<a> 0x55 , 0x04 , 0x0b , 0x13 , 0x0c , 0x43 , 0x6f , 0x6e , </a> 0
<a> 0x74 , 0x72 , 0x69 , 0x62 , 0x75 , 0x74 , 0x6f , 0x72 , </a> 0
<a> 0x73 , 0x31 , 0x30 , 0x30 , 0x2e , 0x06 , 0x03 , 0x55 , </a> 0
<a> 0x04 , 0x03 , 0x13 , 0x27 , 0x73 , 0x65 , 0x63 , 0x75 , </a> 0
<a> 0x72 , 0x65 , 0x63 , 0x68 , 0x61 , 0x74 , 0x2e , 0x65 , </a> 0
<a> 0x78 , 0x61 , 0x6d , 0x70 , 0x6c , 0x65 , 0x2e , 0x6e , </a> 0
<a> 0x65 , 0x74 , 0x74 , 0x79 , 0x2e , 0x67 , 0x6c , 0x65 , </a> 0
<a> 0x61 , 0x6d , 0x79 , 0x6e , 0x6f , 0x64 , 0x65 , 0x2e , </a> 0
<a> 0x6e , 0x65 , 0x74 , 0x30 , 0x5c , 0x30 , 0x0d , 0x06 , </a> 0
<a> 0x09 , 0x2a , 0x86 , 0x48 , 0x86 , 0xf7 , 0x0d , 0x01 , </a> 0
<a> 0x01 , 0x01 , 0x05 , 0x00 , 0x03 , 0x4b , 0x00 , 0x30 , </a> 0
<a> 0x48 , 0x02 , 0x41 , 0x00 , 0x95 , 0xb3 , 0x47 , 0x17 , </a> 0
<a> 0x95 , 0x0f , 0x57 , 0xcf , 0x66 , 0x72 , 0x0a , 0x7e , </a> 0
<a> 0x5b , 0x54 , 0xea , 0x8c , 0x6f , 0x79 , 0xde , 0x94 , </a> 0
<a> 0xac , 0x0b , 0x5a , 0xd4 , 0xd6 , 0x1b , 0x58 , 0x12 , </a> 0
<a> 0x1a , 0x16 , 0x3d , 0xfe , 0xdf , 0xa5 , 0x2b , 0x86 , </a> 0
<a> 0xbc , 0x64 , 0xd4 , 0x80 , 0x1e , 0x3f , 0xf9 , 0xe2 , </a> 0
<a> 0x04 , 0x03 , 0x79 , 0x9b , 0xc1 , 0x5c , 0xf0 , 0xf1 , </a> 0
<a> 0xf3 , 0xf1 , 0xe3 , 0xbf , 0x3f , 0xc0 , 0x1f , 0xdd , </a> 0
<a> 0xdb , 0xc0 , 0x5b , 0x21 , 0x02 , 0x03 , 0x01 , 0x00 , </a> 0
<a> 0x01 , 0x30 , 0x0d , 0x06 , 0x09 , 0x2a , 0x86 , 0x48 , </a> 0
<a> 0x86 , 0xf7 , 0x0d , 0x01 , 0x01 , 0x05 , 0x05 , 0x00 , </a> 0
<a> 0x03 , 0x41 , 0x00 , 0x02 , 0xd7 , 0xdd , 0xbd , 0x0c , </a> 0
<a> 0x8e , 0x21 , 0x20 , 0xef , 0x9e , 0x4f , 0x1f , 0xf5 , </a> 0
<a> 0x49 , 0xf1 , 0xae , 0x58 , 0x9b , 0x94 , 0x3a , 0x1f , </a> 0
<a> 0x70 , 0x33 , 0xf0 , 0x9b , 0xbb , 0xe9 , 0xc0 , 0xf3 , </a> 0
<a> 0x72 , 0xcb , 0xde , 0xb6 , 0x56 , 0x72 , 0xcc , 0x1c , </a> 0
<a> 0xf0 , 0xd6 , 0x5a , 0x2a , 0xbc , 0xa1 , 0x7e , 0x23 , </a> 0
<a> 0x83 , 0xe9 , 0xe7 , 0xcf , 0x9e , 0xa5 , 0xf9 , 0xcc , </a> 0
<a> 0xc2 , 0x61 , 0xf4 , 0xdb , 0x40 , 0x93 , 0x1d , 0x63 , </a> 0
<a> 0x8a , 0x50 , 0x4c , 0x11 , 0x39 , 0xb1 , 0x91 , 0xc1 , </a> 0
<a> 0xe6 , 0x9d , 0xd9 , 0x1a , 0x62 , 0x1b , 0xb8 , 0xd3 , </a> 0
<a> 0xd6 , 0x9a , 0x6d , 0xb9 , 0x8e , 0x15 , 0x51 } ; </a> 0
<a> public static InputStream asInputStream ( ) { </a> 0
<a> byte [ ] data = new byte [ DATA . length ] ; </a> 0
<a> for ( int i = 0 ; i < data . length ; i ++ ) { </a> 0
<a> data [ i ] = ( byte ) DATA [ i ] ; </a> 0
<a> } </a> 0
<a> return new ByteArrayInputStream ( data ) ; </a> 0
<a> } </a> 0
<a> public static char [ ] getCertificatePassword ( ) { </a> 0
<a> return "secret" . toCharArray ( ) ; </a> 0
<a> } </a> 0
<a> public static char [ ] getKeyStorePassword ( ) { </a> 0
<a> return "secret" . toCharArray ( ) ; </a> 0
<a> } </a> 0
<a> private BogusKeyStore ( ) { </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . transport . socket ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import io . netty . bootstrap . Bootstrap ; </a> 1
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . channel . Channel ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 1
<a> import io . netty . channel . ChannelHandler ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 1
<a> import io . netty . channel . ChannelInboundByteHandlerAdapter ; </a> 1
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . group . ChannelGroup ; </a> 1
<a> import io . netty . channel . group . DefaultChannelGroup ; </a> 1
<a> import io . netty . channel . socket . SocketChannel ; </a> 1
<a> import java . io . IOException ; </a> 1
<a> import java . util . Random ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 1
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 1
<a> import org . junit . Ignore ; </a> 1
<a> import org . junit . Test ; </a> 1
<a> public class SocketSuspendTest extends AbstractSocketTest { </a> 1
<a> private static final Random random = new Random ( ) ; </a> 1
<a> static final byte [ ] data = new byte [ 1048576 ] ; </a> 1
<a> static { </a> 1
<a> random . nextBytes ( data ) ; </a> 1
<a> } </a> 1
<a> @ Ignore </a> 1
<a> @ Test </a> 1
<a> public void testSuspendAccept ( ) throws Throwable { </a> 1
<a> run ( ) ; </a> 1
<a> } </a> 1
<a> public void testSuspendAccept ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { </a> 1
<a> ServerHandler handler = new ServerHandler ( ) ; </a> 1
<a> GroupHandler sh = new GroupHandler ( ) ; </a> 1
<a> GroupHandler ch = new GroupHandler ( ) ; </a> 1
<a> sb . handler ( handler ) ; </a> 1
<a> sb . childHandler ( sh ) ; </a> 1
<a> Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; </a> 1
<a> cb . handler ( ch ) ; </a> 1
<a> cb . connect ( ) . sync ( ) ; </a> 1
<a> Thread . sleep ( 1000 ) ; </a> 1
<a> Bootstrap cb2 = currentBootstrap . newInstance ( ) ; </a> 1
<a> cb2 . handler ( ch ) ; </a> 1
<a> cb2 . remoteAddress ( addr ) ; </a> 1
<a> ChannelFuture cf = cb2 . connect ( ) ; </a> 1
<a> assertFalse ( cf . await ( 2 , TimeUnit . SECONDS ) ) ; </a> 1
<a> sc . pipeline ( ) . context ( handler ) . readable ( true ) ; </a> 1
<a> assertTrue ( cf . await ( 2 , TimeUnit . SECONDS ) ) ; </a> 1
<a> sh . group . close ( ) . awaitUninterruptibly ( ) ; </a> 1
<a> ch . group . close ( ) . awaitUninterruptibly ( ) ; </a> 1
<a> sc . close ( ) . sync ( ) ; </a> 1
<a> if ( sh . exception . get ( ) != null && ! ( sh . exception . get ( ) instanceof IOException ) ) { </a> 1
<a> throw sh . exception . get ( ) ; </a> 1
<a> } </a> 1
<a> if ( ch . exception . get ( ) != null && ! ( ch . exception . get ( ) instanceof IOException ) ) { </a> 1
<a> throw ch . exception . get ( ) ; </a> 1
<a> } </a> 1
<a> if ( sh . exception . get ( ) != null ) { </a> 1
<a> throw sh . exception . get ( ) ; </a> 1
<a> } </a> 1
<a> if ( ch . exception . get ( ) != null ) { </a> 1
<a> throw ch . exception . get ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private static class ServerHandler extends ChannelInboundMessageHandlerAdapter < SocketChannel > { </a> 1
<a> @ Override </a> 1
<a> public void messageReceived ( ChannelHandlerContext ctx , SocketChannel msg ) throws Exception { </a> 1
<a> ctx . nextInboundMessageBuffer ( ) . add ( msg ) ; </a> 1
<a> ctx . readable ( false ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ ChannelHandler . Sharable </a> 1
<a> private static class GroupHandler extends ChannelInboundByteHandlerAdapter { </a> 1
<a> final ChannelGroup group = new DefaultChannelGroup ( ) ; </a> 1
<a> final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 1
<a> @ Override </a> 1
<a> public void channelActive ( ChannelHandlerContext ctx ) </a> 1
<a> throws Exception { </a> 1
<a> group . add ( ctx . channel ( ) ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void exceptionCaught ( ChannelHandlerContext ctx , </a> 1
<a> Throwable cause ) throws Exception { </a> 1
<a> if ( exception . compareAndSet ( null , cause ) ) { </a> 1
<a> ctx . close ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { </a> 1
<a> in . clear ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . transport . socket ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . channel . socket . InternetProtocolFamily ; </a> 0
<a> import io . netty . channel . socket . aio . AioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . aio . AioServerSocketChannel ; </a> 1
<a> import io . netty . channel . socket . aio . AioSocketChannel ; </a> 1
<a> import io . netty . channel . socket . nio . NioDatagramChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioEventLoopGroup ; </a> 0
<a> import io . netty . channel . socket . nio . NioServerSocketChannel ; </a> 0
<a> import io . netty . channel . socket . nio . NioSocketChannel ; </a> 0
<a> import io . netty . channel . socket . oio . OioDatagramChannel ; </a> 1
<a> import io . netty . channel . socket . oio . OioEventLoopGroup ; </a> 1
<a> import io . netty . channel . socket . oio . OioServerSocketChannel ; </a> 1
<a> import io . netty . channel . socket . oio . OioSocketChannel ; </a> 1
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> final class SocketTestPermutation { </a> 0
<a> static List < Entry < Factory < ServerBootstrap > , Factory < Bootstrap > > > socket ( ) { </a> 0
<a> List < Entry < Factory < ServerBootstrap > , Factory < Bootstrap > > > list = </a> 0
<a> new ArrayList < Entry < Factory < ServerBootstrap > , Factory < Bootstrap > > > ( ) ; </a> 0
<a> List < Factory < ServerBootstrap > > sbfs = </a> 1
<a> new ArrayList < Factory < ServerBootstrap > > ( ) ; </a> 1
<a> sbfs . add ( new Factory < ServerBootstrap > ( ) { </a> 1
<a> @ Override </a> 1
<a> public ServerBootstrap newInstance ( ) { </a> 1
<a> return new ServerBootstrap ( ) . </a> 1
<a> group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) . </a> 1
<a> channel ( new NioServerSocketChannel ( ) ) ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> sbfs . add ( new Factory < ServerBootstrap > ( ) { </a> 1
<a> @ Override </a> 1
<a> public ServerBootstrap newInstance ( ) { </a> 1
<a> AioEventLoopGroup parentGroup = new AioEventLoopGroup ( ) ; </a> 1
<a> AioEventLoopGroup childGroup = new AioEventLoopGroup ( ) ; </a> 1
<a> return new ServerBootstrap ( ) . </a> 1
<a> group ( parentGroup , childGroup ) . </a> 1
<a> channel ( new AioServerSocketChannel ( parentGroup , childGroup ) ) ; </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> sbfs . add ( new Factory < ServerBootstrap > ( ) { </a> 0
<a> @ Override </a> 0
<a> public ServerBootstrap newInstance ( ) { </a> 0
<a> return new ServerBootstrap ( ) . </a> 1
<a> group ( new OioEventLoopGroup ( ) , new OioEventLoopGroup ( ) ) . </a> 1
<a> channel ( new OioServerSocketChannel ( ) ) ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> List < Factory < Bootstrap > > cbfs = </a> 0
<a> new ArrayList < Factory < Bootstrap > > ( ) ; </a> 0
<a> cbfs . add ( new Factory < Bootstrap > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Bootstrap newInstance ( ) { </a> 0
<a> return new Bootstrap ( ) . group ( new NioEventLoopGroup ( ) ) . channel ( new NioSocketChannel ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> cbfs . add ( new Factory < Bootstrap > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Bootstrap newInstance ( ) { </a> 0
<a> AioEventLoopGroup loop = new AioEventLoopGroup ( ) ; </a> 0
<a> return new Bootstrap ( ) . group ( loop ) . channel ( new AioSocketChannel ( loop ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> cbfs . add ( new Factory < Bootstrap > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Bootstrap newInstance ( ) { </a> 0
<a> return new Bootstrap ( ) . group ( new OioEventLoopGroup ( ) ) . channel ( new OioSocketChannel ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> for ( Factory < ServerBootstrap > sbf : sbfs ) { </a> 0
<a> for ( Factory < Bootstrap > cbf : cbfs ) { </a> 0
<a> final Factory < ServerBootstrap > sbf0 = sbf ; </a> 0
<a> final Factory < Bootstrap > cbf0 = cbf ; </a> 0
<a> list . add ( new Entry < Factory < ServerBootstrap > , Factory < Bootstrap > > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Factory < ServerBootstrap > getKey ( ) { </a> 0
<a> return sbf0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Factory < Bootstrap > getValue ( ) { </a> 0
<a> return cbf0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Factory < Bootstrap > setValue ( Factory < Bootstrap > value ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> list . remove ( list . size ( ) - 1 ) ; </a> 0
<a> return list ; </a> 0
<a> } </a> 0
<a> static List < Entry < Factory < Bootstrap > , Factory < Bootstrap > > > datagram ( ) { </a> 0
<a> List < Entry < Factory < Bootstrap > , Factory < Bootstrap > > > list = </a> 0
<a> new ArrayList < Entry < Factory < Bootstrap > , Factory < Bootstrap > > > ( ) ; </a> 0
<a> List < Factory < Bootstrap > > bfs = </a> 0
<a> new ArrayList < Factory < Bootstrap > > ( ) ; </a> 0
<a> bfs . add ( new Factory < Bootstrap > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Bootstrap newInstance ( ) { </a> 0
<a> return new Bootstrap ( ) . group ( new NioEventLoopGroup ( ) ) . channel ( </a> 0
<a> new NioDatagramChannel ( InternetProtocolFamily . IPv4 ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> bfs . add ( new Factory < Bootstrap > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Bootstrap newInstance ( ) { </a> 0
<a> return new Bootstrap ( ) . group ( new OioEventLoopGroup ( ) ) . channel ( new OioDatagramChannel ( ) ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> for ( Factory < Bootstrap > sbf : bfs ) { </a> 0
<a> for ( Factory < Bootstrap > cbf : bfs ) { </a> 0
<a> final Factory < Bootstrap > sbf0 = sbf ; </a> 0
<a> final Factory < Bootstrap > cbf0 = cbf ; </a> 0
<a> list . add ( new Entry < Factory < Bootstrap > , Factory < Bootstrap > > ( ) { </a> 0
<a> @ Override </a> 0
<a> public Factory < Bootstrap > getKey ( ) { </a> 0
<a> return sbf0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Factory < Bootstrap > getValue ( ) { </a> 0
<a> return cbf0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Factory < Bootstrap > setValue ( Factory < Bootstrap > value ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return list ; </a> 0
<a> } </a> 0
<a> private SocketTestPermutation ( ) { } </a> 0
<a> interface Factory < T > { </a> 0
<a> T newInstance ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . testsuite . util ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . ServerSocket ; </a> 0
<a> public class TestUtils { </a> 1
<a> private final static int START_PORT = 20000 ; </a> 1
<a> private final static int END_PORT = 30000 ; </a> 1
<a> public static int getFreePort ( ) { </a> 0
<a> for ( int start = START_PORT ; start <= END_PORT ; start ++ ) { </a> 0
<a> try { </a> 0
<a> ServerSocket socket = new ServerSocket ( start ) ; </a> 0
<a> socket . setReuseAddress ( true ) ; </a> 0
<a> socket . close ( ) ; </a> 0
<a> return start ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> } </a> 0
<a> } </a> 0
<a> throw new RuntimeException ( "Unable to find a free port...." ) ; </a> 0
<a> } </a> 0
<a> private TestUtils ( ) { } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . bootstrap ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> import io . netty . channel . ChannelOption ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . EventLoopGroup ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . net . InetAddress ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . nio . channels . ClosedChannelException ; </a> 0
<a> import java . util . LinkedHashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> public class Bootstrap { </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( Bootstrap . class ) ; </a> 0
<a> private final Map < ChannelOption < ? > , Object > options = new LinkedHashMap < ChannelOption < ? > , Object > ( ) ; </a> 0
<a> private EventLoopGroup group ; </a> 0
<a> private Channel channel ; </a> 0
<a> private ChannelHandler handler ; </a> 0
<a> private SocketAddress localAddress ; </a> 0
<a> private SocketAddress remoteAddress ; </a> 0
<a> public Bootstrap group ( EventLoopGroup group ) { </a> 0
<a> if ( group == null ) { </a> 0
<a> throw new NullPointerException ( "group" ) ; </a> 0
<a> } </a> 0
<a> if ( this . group != null ) { </a> 0
<a> throw new IllegalStateException ( "group set already" ) ; </a> 0
<a> } </a> 0
<a> this . group = group ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Bootstrap channel ( Channel channel ) { </a> 0
<a> if ( channel == null ) { </a> 0
<a> throw new NullPointerException ( "channel" ) ; </a> 0
<a> } </a> 0
<a> if ( this . channel != null ) { </a> 0
<a> throw new IllegalStateException ( "channel set already" ) ; </a> 0
<a> } </a> 0
<a> this . channel = channel ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public < T > Bootstrap option ( ChannelOption < T > option , T value ) { </a> 0
<a> if ( option == null ) { </a> 0
<a> throw new NullPointerException ( "option" ) ; </a> 0
<a> } </a> 0
<a> if ( value == null ) { </a> 0
<a> options . remove ( option ) ; </a> 0
<a> } else { </a> 0
<a> options . put ( option , value ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Bootstrap handler ( ChannelHandler handler ) { </a> 0
<a> if ( handler == null ) { </a> 0
<a> throw new NullPointerException ( "handler" ) ; </a> 0
<a> } </a> 0
<a> this . handler = handler ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Bootstrap localAddress ( SocketAddress localAddress ) { </a> 0
<a> this . localAddress = localAddress ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Bootstrap localAddress ( int port ) { </a> 0
<a> localAddress = new InetSocketAddress ( port ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Bootstrap localAddress ( String host , int port ) { </a> 0
<a> localAddress = new InetSocketAddress ( host , port ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Bootstrap localAddress ( InetAddress host , int port ) { </a> 0
<a> localAddress = new InetSocketAddress ( host , port ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Bootstrap remoteAddress ( SocketAddress remoteAddress ) { </a> 0
<a> this . remoteAddress = remoteAddress ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Bootstrap remoteAddress ( String host , int port ) { </a> 0
<a> remoteAddress = new InetSocketAddress ( host , port ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public Bootstrap remoteAddress ( InetAddress host , int port ) { </a> 0
<a> remoteAddress = new InetSocketAddress ( host , port ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ChannelFuture bind ( ) { </a> 0
<a> validate ( ) ; </a> 0
<a> return bind ( channel . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> public ChannelFuture bind ( ChannelFuture future ) { </a> 0
<a> validate ( future ) ; </a> 0
<a> if ( localAddress == null ) { </a> 0
<a> throw new IllegalStateException ( "localAddress not set" ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> init ( ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> future . setFailure ( t ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> if ( ! ensureOpen ( future ) ) { </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> return channel . bind ( localAddress , future ) . addListener ( ChannelFutureListener . CLOSE_ON_FAILURE ) ; </a> 0
<a> } </a> 0
<a> public ChannelFuture connect ( ) { </a> 0
<a> validate ( ) ; </a> 0
<a> return connect ( channel . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> public ChannelFuture connect ( ChannelFuture future ) { </a> 0
<a> validate ( future ) ; </a> 0
<a> if ( remoteAddress == null ) { </a> 0
<a> throw new IllegalStateException ( "remoteAddress not set" ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> init ( ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> future . setFailure ( t ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> if ( ! ensureOpen ( future ) ) { </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> if ( localAddress == null ) { </a> 0
<a> channel . connect ( remoteAddress , future ) ; </a> 0
<a> } else { </a> 0
<a> channel . connect ( remoteAddress , localAddress , future ) ; </a> 0
<a> } </a> 0
<a> return future . addListener ( ChannelFutureListener . CLOSE_ON_FAILURE ) ; </a> 0
<a> } </a> 0
<a> private void init ( ) throws Exception { </a> 0
<a> if ( channel . isActive ( ) ) { </a> 0
<a> throw new IllegalStateException ( "channel already active:: " + channel ) ; </a> 0
<a> } </a> 0
<a> if ( channel . isRegistered ( ) ) { </a> 0
<a> throw new IllegalStateException ( "channel already registered: " + channel ) ; </a> 0
<a> } </a> 0
<a> if ( ! channel . isOpen ( ) ) { </a> 0
<a> throw new ClosedChannelException ( ) ; </a> 0
<a> } </a> 0
<a> ChannelPipeline p = channel . pipeline ( ) ; </a> 0
<a> p . addLast ( handler ) ; </a> 0
<a> for ( Entry < ChannelOption < ? > , Object > e : options . entrySet ( ) ) { </a> 0
<a> try { </a> 0
<a> if ( ! channel . config ( ) . setOption ( ( ChannelOption < Object > ) e . getKey ( ) , e . getValue ( ) ) ) { </a> 0
<a> logger . warn ( "Unknown channel option: " + e ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Failed to set a channel option: " + channel , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> group . register ( channel ) . syncUninterruptibly ( ) ; </a> 0
<a> } </a> 0
<a> private static boolean ensureOpen ( ChannelFuture future ) { </a> 0
<a> if ( ! future . channel ( ) . isOpen ( ) ) { </a> 0
<a> future . setFailure ( new ChannelException ( "initialization failure" ) ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> public void shutdown ( ) { </a> 0
<a> if ( group != null ) { </a> 0
<a> group . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void validate ( ) { </a> 0
<a> if ( group == null ) { </a> 0
<a> throw new IllegalStateException ( "group not set" ) ; </a> 0
<a> } </a> 0
<a> if ( channel == null ) { </a> 0
<a> throw new IllegalStateException ( "channel not set" ) ; </a> 0
<a> } </a> 0
<a> if ( handler == null ) { </a> 0
<a> throw new IllegalStateException ( "handler not set" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void validate ( ChannelFuture future ) { </a> 0
<a> if ( future == null ) { </a> 0
<a> throw new NullPointerException ( "future" ) ; </a> 0
<a> } </a> 0
<a> if ( future . channel ( ) != channel ) { </a> 0
<a> throw new IllegalArgumentException ( "future.channel() must be the same channel." ) ; </a> 0
<a> } </a> 0
<a> validate ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . bootstrap ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelInboundMessageHandler ; </a> 0
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelOption ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import io . netty . channel . EventLoopGroup ; </a> 0
<a> import io . netty . channel . ServerChannel ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . util . NetworkConstants ; </a> 0
<a> import java . net . InetAddress ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . nio . channels . ClosedChannelException ; </a> 0
<a> import java . util . LinkedHashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> public class ServerBootstrap { </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( ServerBootstrap . class ) ; </a> 0
<a> private static final InetSocketAddress DEFAULT_LOCAL_ADDR = new InetSocketAddress ( NetworkConstants . LOCALHOST , 0 ) ; </a> 0
<a> private final ChannelHandler acceptor = new ChannelInitializer < Channel > ( ) { </a> 1
<a> @ Override </a> 1
<a> public void initChannel ( Channel ch ) throws Exception { </a> 1
<a> ch . pipeline ( ) . addLast ( new Acceptor ( ) ) ; </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> private final Map < ChannelOption < ? > , Object > parentOptions = new LinkedHashMap < ChannelOption < ? > , Object > ( ) ; </a> 0
<a> private final Map < ChannelOption < ? > , Object > childOptions = new LinkedHashMap < ChannelOption < ? > , Object > ( ) ; </a> 0
<a> private EventLoopGroup parentGroup ; </a> 0
<a> private EventLoopGroup childGroup ; </a> 1
<a> private ServerChannel channel ; </a> 0
<a> private ChannelHandler handler ; </a> 0
<a> private ChannelHandler childHandler ; </a> 1
<a> private SocketAddress localAddress ; </a> 0
<a> public ServerBootstrap group ( EventLoopGroup group ) { </a> 0
<a> if ( group == null ) { </a> 0
<a> throw new NullPointerException ( "group" ) ; </a> 0
<a> } </a> 0
<a> if ( parentGroup != null ) { </a> 0
<a> throw new IllegalStateException ( "parentGroup set already" ) ; </a> 0
<a> } </a> 0
<a> parentGroup = group ; </a> 0
<a> childGroup = group ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ServerBootstrap group ( EventLoopGroup parentGroup , EventLoopGroup childGroup ) { </a> 0
<a> if ( parentGroup == null ) { </a> 0
<a> throw new NullPointerException ( "parentGroup" ) ; </a> 0
<a> } </a> 0
<a> if ( this . parentGroup != null ) { </a> 0
<a> throw new IllegalStateException ( "parentGroup set already" ) ; </a> 0
<a> } </a> 0
<a> this . parentGroup = parentGroup ; </a> 0
<a> this . childGroup = childGroup ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ServerBootstrap channel ( ServerChannel channel ) { </a> 0
<a> if ( channel == null ) { </a> 0
<a> throw new NullPointerException ( "channel" ) ; </a> 0
<a> } </a> 1
<a> if ( this . channel != null ) { </a> 0
<a> throw new IllegalStateException ( "channel set already" ) ; </a> 0
<a> } </a> 1
<a> this . channel = channel ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public < T > ServerBootstrap option ( ChannelOption < T > parentOption , T value ) { </a> 0
<a> if ( parentOption == null ) { </a> 0
<a> throw new NullPointerException ( "parentOption" ) ; </a> 0
<a> } </a> 0
<a> if ( value == null ) { </a> 0
<a> parentOptions . remove ( parentOption ) ; </a> 0
<a> } else { </a> 0
<a> parentOptions . put ( parentOption , value ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 1
<a> public < T > ServerBootstrap childOption ( ChannelOption < T > childOption , T value ) { </a> 0
<a> if ( childOption == null ) { </a> 0
<a> throw new NullPointerException ( "childOption" ) ; </a> 0
<a> } </a> 0
<a> if ( value == null ) { </a> 0
<a> childOptions . remove ( childOption ) ; </a> 0
<a> } else { </a> 0
<a> childOptions . put ( childOption , value ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ServerBootstrap handler ( ChannelHandler handler ) { </a> 0
<a> this . handler = handler ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ServerBootstrap childHandler ( ChannelHandler childHandler ) { </a> 0
<a> if ( childHandler == null ) { </a> 0
<a> throw new NullPointerException ( "childHandler" ) ; </a> 0
<a> } </a> 0
<a> this . childHandler = childHandler ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ServerBootstrap localAddress ( SocketAddress localAddress ) { </a> 0
<a> if ( localAddress == null ) { </a> 0
<a> throw new NullPointerException ( "localAddress" ) ; </a> 0
<a> } </a> 0
<a> this . localAddress = localAddress ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ServerBootstrap localAddress ( int port ) { </a> 0
<a> localAddress = new InetSocketAddress ( port ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ServerBootstrap localAddress ( String host , int port ) { </a> 0
<a> localAddress = new InetSocketAddress ( host , port ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ServerBootstrap localAddress ( InetAddress host , int port ) { </a> 0
<a> localAddress = new InetSocketAddress ( host , port ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> public ChannelFuture bind ( ) { </a> 0
<a> validate ( ) ; </a> 0
<a> return bind ( channel . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> public ChannelFuture bind ( ChannelFuture future ) { </a> 0
<a> validate ( future ) ; </a> 0
<a> if ( channel . isActive ( ) ) { </a> 0
<a> future . setFailure ( new IllegalStateException ( "channel already bound: " + channel ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> if ( channel . isRegistered ( ) ) { </a> 0
<a> future . setFailure ( new IllegalStateException ( "channel already registered: " + channel ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> if ( ! channel . isOpen ( ) ) { </a> 0
<a> future . setFailure ( new ClosedChannelException ( ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> try { </a> 1
<a> channel . config ( ) . setOptions ( parentOptions ) ; </a> 0
<a> } catch ( Exception e ) { </a> 1
<a> future . setFailure ( e ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 1
<a> ChannelPipeline p = channel . pipeline ( ) ; </a> 0
<a> if ( handler != null ) { </a> 0
<a> p . addLast ( handler ) ; </a> 0
<a> } </a> 0
<a> p . addLast ( acceptor ) ; </a> 1
<a> ChannelFuture f = parentGroup . register ( channel ) . awaitUninterruptibly ( ) ; </a> 0
<a> if ( ! f . isSuccess ( ) ) { </a> 1
<a> future . setFailure ( f . cause ( ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 1
<a> if ( ! channel . isOpen ( ) ) { </a> 0
<a> future . setFailure ( new ChannelException ( "initialization failure" ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> channel . bind ( localAddress , future ) . addListener ( ChannelFutureListener . CLOSE_ON_FAILURE ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> public void shutdown ( ) { </a> 0
<a> if ( parentGroup != null ) { </a> 0
<a> parentGroup . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> if ( childGroup != null ) { </a> 0
<a> childGroup . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void validate ( ) { </a> 0
<a> if ( parentGroup == null ) { </a> 0
<a> throw new IllegalStateException ( "parentGroup not set" ) ; </a> 0
<a> } </a> 0
<a> if ( channel == null ) { </a> 0
<a> throw new IllegalStateException ( "channel not set" ) ; </a> 0
<a> } </a> 0
<a> if ( childHandler == null ) { </a> 0
<a> throw new IllegalStateException ( "childHandler not set" ) ; </a> 0
<a> } </a> 0
<a> if ( childGroup == null ) { </a> 0
<a> logger . warn ( "childGroup is not set. Using parentGroup instead." ) ; </a> 0
<a> childGroup = parentGroup ; </a> 0
<a> } </a> 0
<a> if ( localAddress == null ) { </a> 0
<a> logger . warn ( "localAddress is not set. Using " + DEFAULT_LOCAL_ADDR + " instead." ) ; </a> 0
<a> localAddress = DEFAULT_LOCAL_ADDR ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void validate ( ChannelFuture future ) { </a> 0
<a> if ( future == null ) { </a> 0
<a> throw new NullPointerException ( "future" ) ; </a> 0
<a> } </a> 0
<a> if ( future . channel ( ) != channel ) { </a> 0
<a> throw new IllegalArgumentException ( "future.channel() must be the same channel." ) ; </a> 0
<a> } </a> 0
<a> validate ( ) ; </a> 0
<a> } </a> 0
<a> private class Acceptor </a> 1
<a> extends ChannelInboundHandlerAdapter implements ChannelInboundMessageHandler < Channel > { </a> 0
<a> @ Override </a> 0
<a> public MessageBuf < Channel > newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . messageBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) { </a> 1
<a> MessageBuf < Channel > in = ctx . inboundMessageBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> Channel child = in . poll ( ) ; </a> 1
<a> if ( child == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> child . pipeline ( ) . addLast ( childHandler ) ; </a> 0
<a> for ( Entry < ChannelOption < ? > , Object > e : childOptions . entrySet ( ) ) { </a> 1
<a> try { </a> 0
<a> if ( ! child . config ( ) . setOption ( ( ChannelOption < Object > ) e . getKey ( ) , e . getValue ( ) ) ) { </a> 0
<a> logger . warn ( "Unknown channel option: " + e ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Failed to set a channel option: " + child , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> childGroup . register ( child ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Failed to register an accepted channel: " + child , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . bootstrap ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import io . netty . util . DefaultAttributeMap ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . nio . channels . ClosedChannelException ; </a> 0
<a> import java . util . Random ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import java . util . concurrent . ConcurrentMap ; </a> 1
<a> public abstract class AbstractChannel extends DefaultAttributeMap implements Channel { </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( AbstractChannel . class ) ; </a> 0
<a> static final ConcurrentMap < Integer , Channel > allChannels = new ConcurrentHashMap < Integer , Channel > ( ) ; </a> 1
<a> private static final Random random = new Random ( ) ; </a> 0
<a> private static Integer allocateId ( Channel channel ) { </a> 1
<a> int idVal = random . nextInt ( ) ; </a> 0
<a> if ( idVal > 0 ) { </a> 0
<a> idVal = - idVal ; </a> 0
<a> } else if ( idVal == 0 ) { </a> 0
<a> idVal = - 1 ; </a> 0
<a> } </a> 0
<a> Integer id ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> id = Integer . valueOf ( idVal ) ; </a> 1
<a> if ( allChannels . putIfAbsent ( id , channel ) == null ) { </a> 1
<a> return id ; </a> 1
<a> } else { </a> 1
<a> idVal -- ; </a> 1
<a> if ( idVal >= 0 ) { </a> 1
<a> idVal = - 1 ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<a> private final Channel parent ; </a> 0
<a> private final Integer id ; </a> 0
<a> private final Unsafe unsafe ; </a> 0
<a> private final DefaultChannelPipeline pipeline ; </a> 0
<a> private final ChannelFuture succeededFuture = new SucceededChannelFuture ( this ) ; </a> 0
<a> private final ChannelFuture voidFuture = new VoidChannelFuture ( this ) ; </a> 0
<a> private final CloseFuture closeFuture = new CloseFuture ( this ) ; </a> 1
<a> protected final ChannelFlushFutureNotifier flushFutureNotifier = new ChannelFlushFutureNotifier ( ) ; </a> 0
<a> private volatile SocketAddress localAddress ; </a> 0
<a> private volatile SocketAddress remoteAddress ; </a> 0
<a> private volatile EventLoop eventLoop ; </a> 0
<a> private volatile boolean registered ; </a> 0
<a> private ClosedChannelException closedChannelException ; </a> 0
<a> private boolean inFlushNow ; </a> 0
<a> private boolean flushNowPending ; </a> 1
<a> private boolean strValActive ; </a> 0
<a> private String strVal ; </a> 0
<a> protected AbstractChannel ( Channel parent , Integer id ) { </a> 0
<a> if ( id == null ) { </a> 0
<a> id = allocateId ( this ) ; </a> 0
<a> } else { </a> 0
<a> if ( id . intValue ( ) < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "id: " + id + " (expected: >= 0)" ) ; </a> 0
<a> } </a> 0
<a> if ( allChannels . putIfAbsent ( id , this ) != null ) { </a> 1
<a> throw new IllegalArgumentException ( "duplicate ID: " + id ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> this . parent = parent ; </a> 0
<a> this . id = id ; </a> 0
<a> unsafe = newUnsafe ( ) ; </a> 0
<a> pipeline = new DefaultChannelPipeline ( this ) ; </a> 0
<a> closeFuture ( ) . addListener ( new ChannelFutureListener ( ) { </a> 1
<a> @ Override </a> 1
<a> public void operationComplete ( ChannelFuture future ) { </a> 1
<a> allChannels . remove ( id ( ) ) ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public final Integer id ( ) { </a> 1
<a> return id ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public Channel parent ( ) { </a> 0
<a> return parent ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline pipeline ( ) { </a> 0
<a> return pipeline ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public EventLoop eventLoop ( ) { </a> 0
<a> EventLoop eventLoop = this . eventLoop ; </a> 0
<a> if ( eventLoop == null ) { </a> 0
<a> throw new IllegalStateException ( "channel not registered to an event loop" ) ; </a> 0
<a> } </a> 0
<a> return eventLoop ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public SocketAddress localAddress ( ) { </a> 0
<a> SocketAddress localAddress = this . localAddress ; </a> 0
<a> if ( localAddress == null ) { </a> 0
<a> try { </a> 0
<a> this . localAddress = localAddress = unsafe ( ) . localAddress ( ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return localAddress ; </a> 0
<a> } </a> 0
<a> protected void invalidateLocalAddress ( ) { </a> 0
<a> localAddress = null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public SocketAddress remoteAddress ( ) { </a> 0
<a> SocketAddress remoteAddress = this . remoteAddress ; </a> 0
<a> if ( remoteAddress == null ) { </a> 0
<a> try { </a> 0
<a> this . remoteAddress = remoteAddress = unsafe ( ) . remoteAddress ( ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return remoteAddress ; </a> 0
<a> } </a> 0
<a> protected void invalidateRemoteAddress ( ) { </a> 0
<a> remoteAddress = null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isRegistered ( ) { </a> 0
<a> return registered ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture bind ( SocketAddress localAddress ) { </a> 0
<a> return pipeline . bind ( localAddress ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture connect ( SocketAddress remoteAddress ) { </a> 0
<a> return pipeline . connect ( remoteAddress ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture connect ( SocketAddress remoteAddress , SocketAddress localAddress ) { </a> 0
<a> return pipeline . connect ( remoteAddress , localAddress ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture disconnect ( ) { </a> 0
<a> return pipeline . disconnect ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture close ( ) { </a> 0
<a> return pipeline . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture deregister ( ) { </a> 0
<a> return pipeline . deregister ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture flush ( ) { </a> 1
<a> return pipeline . flush ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture write ( Object message ) { </a> 1
<a> return pipeline . write ( message ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture bind ( SocketAddress localAddress , ChannelFuture future ) { </a> 0
<a> return pipeline . bind ( localAddress , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture connect ( SocketAddress remoteAddress , ChannelFuture future ) { </a> 0
<a> return pipeline . connect ( remoteAddress , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture connect ( SocketAddress remoteAddress , SocketAddress localAddress , ChannelFuture future ) { </a> 0
<a> return pipeline . connect ( remoteAddress , localAddress , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture disconnect ( ChannelFuture future ) { </a> 0
<a> return pipeline . disconnect ( future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture close ( ChannelFuture future ) { </a> 0
<a> return pipeline . close ( future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture deregister ( ChannelFuture future ) { </a> 0
<a> return pipeline . deregister ( future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf outboundByteBuffer ( ) { </a> 1
<a> return pipeline . outboundByteBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public MessageBuf < Object > outboundMessageBuffer ( ) { </a> 1
<a> return pipeline . outboundMessageBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelFuture flush ( ChannelFuture future ) { </a> 0
<a> return pipeline . flush ( future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture write ( Object message , ChannelFuture future ) { </a> 0
<a> return pipeline . write ( message , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture newFuture ( ) { </a> 0
<a> return new DefaultChannelFuture ( this , false ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture newSucceededFuture ( ) { </a> 0
<a> return succeededFuture ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture newFailedFuture ( Throwable cause ) { </a> 0
<a> return new FailedChannelFuture ( this , cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture closeFuture ( ) { </a> 0
<a> return closeFuture ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Unsafe unsafe ( ) { </a> 0
<a> return unsafe ; </a> 0
<a> } </a> 0
<a> protected abstract Unsafe newUnsafe ( ) ; </a> 0
<a> @ Override </a> 0
<a> public final int hashCode ( ) { </a> 0
<a> return this . id ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final boolean equals ( Object o ) { </a> 0
<a> return this == o ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final int compareTo ( Channel o ) { </a> 0
<a> return id ( ) . compareTo ( o . id ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> boolean active = isActive ( ) ; </a> 0
<a> if ( strValActive == active && strVal != null ) { </a> 0
<a> return strVal ; </a> 0
<a> } </a> 0
<a> SocketAddress remoteAddr = remoteAddress ( ) ; </a> 0
<a> SocketAddress localAddr = localAddress ( ) ; </a> 0
<a> if ( remoteAddr != null ) { </a> 0
<a> SocketAddress srcAddr ; </a> 0
<a> SocketAddress dstAddr ; </a> 0
<a> if ( parent == null ) { </a> 0
<a> srcAddr = localAddr ; </a> 0
<a> dstAddr = remoteAddr ; </a> 0
<a> } else { </a> 0
<a> srcAddr = remoteAddr ; </a> 0
<a> dstAddr = localAddr ; </a> 0
<a> } </a> 0
<a> strVal = String . format ( "[id: 0x%08x, %s %s %s]" , id , srcAddr , active ? "=>" : ":>" , dstAddr ) ; </a> 0
<a> } else if ( localAddr != null ) { </a> 0
<a> strVal = String . format ( "[id: 0x%08x, %s]" , id , localAddr ) ; </a> 0
<a> } else { </a> 0
<a> strVal = String . format ( "[id: 0x%08x]" , id ) ; </a> 0
<a> } </a> 0
<a> strValActive = active ; </a> 0
<a> return strVal ; </a> 0
<a> } </a> 0
<a> protected abstract class AbstractUnsafe implements Unsafe { </a> 0
<a> private final Runnable flushLaterTask = new FlushLater ( ) ; </a> 1
<a> @ Override </a> 0
<a> public final ChannelHandlerContext directOutboundContext ( ) { </a> 0
<a> return pipeline . head ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public final ChannelFuture voidFuture ( ) { </a> 0
<a> return voidFuture ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final SocketAddress localAddress ( ) { </a> 0
<a> return localAddress0 ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final SocketAddress remoteAddress ( ) { </a> 0
<a> return remoteAddress0 ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void register ( EventLoop eventLoop , ChannelFuture future ) { </a> 1
<a> if ( eventLoop == null ) { </a> 0
<a> throw new NullPointerException ( "eventLoop" ) ; </a> 0
<a> } </a> 0
<a> if ( isRegistered ( ) ) { </a> 0
<a> throw new IllegalStateException ( "registered to an event loop already" ) ; </a> 0
<a> } </a> 0
<a> if ( ! isCompatible ( eventLoop ) ) { </a> 0
<a> throw new IllegalStateException ( "incompatible event loop type: " + eventLoop . getClass ( ) . getName ( ) ) ; </a> 0
<a> } </a> 0
<a> AbstractChannel . this . eventLoop = eventLoop ; </a> 0
<a> assert eventLoop ( ) . inEventLoop ( ) ; </a> 0
<a> if ( ! ensureOpen ( future ) ) { </a> 0
<a> return ; </a> 1
<a> } </a> 1
<a> try { </a> 0
<a> Runnable postRegisterTask = doRegister ( ) ; </a> 0
<a> registered = true ; </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> pipeline . fireChannelRegistered ( ) ; </a> 0
<a> if ( postRegisterTask != null ) { </a> 0
<a> postRegisterTask . run ( ) ; </a> 0
<a> } </a> 0
<a> if ( isActive ( ) ) { </a> 0
<a> pipeline . fireChannelActive ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> try { </a> 1
<a> doClose ( ) ; </a> 1
<a> } catch ( Throwable t2 ) { </a> 1
<a> logger . warn ( "Failed to close a channel" , t2 ) ; </a> 1
<a> } </a> 1
<a> future . setFailure ( t ) ; </a> 0
<a> pipeline . fireExceptionCaught ( t ) ; </a> 0
<a> closeFuture . setClosed ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public final void bind ( final SocketAddress localAddress , final ChannelFuture future ) { </a> 0
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> if ( ! ensureOpen ( future ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> boolean wasActive = isActive ( ) ; </a> 0
<a> doBind ( localAddress ) ; </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> if ( ! wasActive && isActive ( ) ) { </a> 0
<a> pipeline . fireChannelActive ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> future . setFailure ( t ) ; </a> 0
<a> pipeline . fireExceptionCaught ( t ) ; </a> 0
<a> closeIfClosed ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> bind ( localAddress , future ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void disconnect ( final ChannelFuture future ) { </a> 0
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> try { </a> 0
<a> boolean wasActive = isActive ( ) ; </a> 0
<a> doDisconnect ( ) ; </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> if ( wasActive && ! isActive ( ) ) { </a> 0
<a> pipeline . fireChannelInactive ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> future . setFailure ( t ) ; </a> 0
<a> closeIfClosed ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> disconnect ( future ) ; </a> 0
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void close ( final ChannelFuture future ) { </a> 0
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> boolean wasActive = isActive ( ) ; </a> 0
<a> if ( closeFuture . setClosed ( ) ) { </a> 0
<a> try { </a> 0
<a> doClose ( ) ; </a> 0
<a> future . setSuccess ( ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> future . setFailure ( t ) ; </a> 1
<a> } </a> 0
<a> if ( closedChannelException != null ) { </a> 1
<a> closedChannelException = new ClosedChannelException ( ) ; </a> 0
<a> } </a> 0
<a> flushFutureNotifier . notifyFlushFutures ( closedChannelException ) ; </a> 1
<a> if ( wasActive && ! isActive ( ) ) { </a> 0
<a> pipeline . fireChannelInactive ( ) ; </a> 0
<a> } </a> 0
<a> deregister ( voidFuture ( ) ) ; </a> 0
<a> } else { </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> eventLoop ( ) . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> close ( future ) ; </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void deregister ( final ChannelFuture future ) { </a> 0
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> if ( ! registered ) { </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> doDeregister ( ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Unexpected exception occurred while deregistering a channel." , t ) ; </a> 0
<a> } finally { </a> 0
<a> if ( registered ) { </a> 0
<a> registered = false ; </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> pipeline . fireChannelUnregistered ( ) ; </a> 0
<a> } else { </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> deregister ( future ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void flush ( final ChannelFuture future ) { </a> 0
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> if ( future != voidFuture ) { </a> 0
<a> final int bufSize ; </a> 1
<a> final ChannelHandlerContext ctx = directOutboundContext ( ) ; </a> 0
<a> if ( ctx . hasOutboundByteBuffer ( ) ) { </a> 0
<a> bufSize = ctx . outboundByteBuffer ( ) . readableBytes ( ) ; </a> 1
<a> } else { </a> 1
<a> bufSize = ctx . outboundMessageBuffer ( ) . size ( ) ; </a> 1
<a> } </a> 1
<a> flushFutureNotifier . addFlushFuture ( future , bufSize ) ; </a> 0
<a> } </a> 0
<a> if ( ! inFlushNow ) { </a> 1
<a> try { </a> 0
<a> if ( ! isFlushPending ( ) ) { </a> 1
<a> flushNow ( ) ; </a> 1
<a> } else { </a> 1
<a> } </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> flushFutureNotifier . notifyFlushFutures ( t ) ; </a> 1
<a> pipeline . fireExceptionCaught ( t ) ; </a> 0
<a> if ( t instanceof IOException ) { </a> 1
<a> close ( voidFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> if ( ! isActive ( ) ) { </a> 0
<a> close ( unsafe ( ) . voidFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } else { </a> 1
<a> if ( ! flushNowPending ) { </a> 1
<a> flushNowPending = true ; </a> 1
<a> eventLoop ( ) . execute ( flushLaterTask ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } else { </a> 0
<a> eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> flush ( future ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> public final void flushNow ( ) { </a> 1
<a> if ( inFlushNow ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> inFlushNow = true ; </a> 0
<a> ChannelHandlerContext ctx = directOutboundContext ( ) ; </a> 0
<a> Throwable cause = null ; </a> 0
<a> try { </a> 0
<a> if ( ctx . hasOutboundByteBuffer ( ) ) { </a> 0
<a> ByteBuf out = ctx . outboundByteBuffer ( ) ; </a> 1
<a> int oldSize = out . readableBytes ( ) ; </a> 1
<a> try { </a> 1
<a> doFlushByteBuffer ( out ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> cause = t ; </a> 0
<a> } finally { </a> 0
<a> final int newSize = out . readableBytes ( ) ; </a> 0
<a> final int writtenBytes = oldSize - newSize ; </a> 0
<a> if ( writtenBytes > 0 ) { </a> 0
<a> flushFutureNotifier . increaseWriteCounter ( writtenBytes ) ; </a> 0
<a> if ( newSize == 0 ) { </a> 1
<a> out . discardReadBytes ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> MessageBuf < Object > out = ctx . outboundMessageBuffer ( ) ; </a> 1
<a> int oldSize = out . size ( ) ; </a> 1
<a> try { </a> 1
<a> doFlushMessageBuffer ( out ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> cause = t ; </a> 1
<a> } finally { </a> 1
<a> flushFutureNotifier . increaseWriteCounter ( oldSize - out . size ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> if ( cause == null ) { </a> 1
<a> flushFutureNotifier . notifyFlushFutures ( ) ; </a> 1
<a> } else { </a> 0
<a> flushFutureNotifier . notifyFlushFutures ( cause ) ; </a> 1
<a> pipeline . fireExceptionCaught ( cause ) ; </a> 0
<a> if ( cause instanceof IOException ) { </a> 1
<a> close ( voidFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } finally { </a> 0
<a> inFlushNow = false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected final boolean ensureOpen ( ChannelFuture future ) { </a> 0
<a> if ( isOpen ( ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> Exception e = new ClosedChannelException ( ) ; </a> 1
<a> future . setFailure ( e ) ; </a> 1
<a> pipeline . fireExceptionCaught ( e ) ; </a> 1
<a> return false ; </a> 0
<a> } </a> 0
<a> protected final void closeIfClosed ( ) { </a> 0
<a> if ( isOpen ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> close ( voidFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private class FlushLater implements Runnable { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> flushNowPending = false ; </a> 1
<a> unsafe ( ) . flush ( voidFuture ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> protected abstract boolean isCompatible ( EventLoop loop ) ; </a> 0
<a> protected abstract SocketAddress localAddress0 ( ) ; </a> 0
<a> protected abstract SocketAddress remoteAddress0 ( ) ; </a> 0
<a> protected abstract Runnable doRegister ( ) throws Exception ; </a> 0
<a> protected abstract void doBind ( SocketAddress localAddress ) throws Exception ; </a> 0
<a> protected abstract void doDisconnect ( ) throws Exception ; </a> 0
<a> protected void doPreClose ( ) throws Exception { </a> 0
<a> } </a> 0
<a> protected abstract void doClose ( ) throws Exception ; </a> 0
<a> protected abstract void doDeregister ( ) throws Exception ; </a> 0
<a> protected void doFlushByteBuffer ( ByteBuf buf ) throws Exception { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 0
<a> protected void doFlushMessageBuffer ( MessageBuf < Object > buf ) throws Exception { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 0
<a> protected abstract boolean isFlushPending ( ) ; </a> 0
<a> private final class CloseFuture extends DefaultChannelFuture implements ChannelFuture . Unsafe { </a> 0
<a> CloseFuture ( AbstractChannel ch ) { </a> 0
<a> super ( ch , false ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean setSuccess ( ) { </a> 0
<a> throw new IllegalStateException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean setFailure ( Throwable cause ) { </a> 0
<a> throw new IllegalStateException ( ) ; </a> 0
<a> } </a> 0
<a> boolean setClosed ( ) { </a> 0
<a> try { </a> 0
<a> doPreClose ( ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> logger . warn ( "doPreClose() raised an exception." , e ) ; </a> 0
<a> } </a> 0
<a> return super . setSuccess ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . ChannelBufType ; </a> 1
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import java . net . SocketAddress ; </a> 0
<a> public abstract class AbstractServerChannel extends AbstractChannel implements ServerChannel { </a> 0
<a> private static final ChannelMetadata METADATA = new ChannelMetadata ( ChannelBufType . MESSAGE , false ) ; </a> 0
<a> protected AbstractServerChannel ( Integer id ) { </a> 0
<a> super ( null , id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf outboundByteBuffer ( ) { </a> 1
<a> throw new NoSuchBufferException ( String . format ( </a> 1
<a> "%s does not have an outbound buffer." , ServerChannel . class . getSimpleName ( ) ) ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public MessageBuf < Object > outboundMessageBuffer ( ) { </a> 1
<a> throw new NoSuchBufferException ( String . format ( </a> 1
<a> "%s does not have an outbound buffer." , ServerChannel . class . getSimpleName ( ) ) ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelMetadata metadata ( ) { </a> 0
<a> return METADATA ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public SocketAddress remoteAddress ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> protected SocketAddress remoteAddress0 ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDisconnect ( ) throws Exception { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doFlushByteBuffer ( ByteBuf buf ) throws Exception { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doFlushMessageBuffer ( MessageBuf < Object > buf ) throws Exception { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isFlushPending ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> protected abstract class AbstractServerUnsafe extends AbstractUnsafe { </a> 1
<a> @ Override </a> 0
<a> public void flush ( final ChannelFuture future ) { </a> 0
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> reject ( future ) ; </a> 1
<a> } else { </a> 0
<a> eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> flush ( future ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void connect ( </a> 1
<a> final SocketAddress remoteAddress , final SocketAddress localAddress , </a> 1
<a> final ChannelFuture future ) { </a> 0
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> reject ( future ) ; </a> 1
<a> } else { </a> 0
<a> eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> connect ( remoteAddress , localAddress , future ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void reject ( ChannelFuture future ) { </a> 0
<a> Exception cause = new UnsupportedOperationException ( ) ; </a> 1
<a> future . setFailure ( cause ) ; </a> 1
<a> pipeline ( ) . fireExceptionCaught ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . channel . socket . DatagramChannel ; </a> 0
<a> import io . netty . channel . socket . ServerSocketChannel ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . util . AttributeMap ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . nio . channels . SelectionKey ; </a> 1
<a> public interface Channel extends AttributeMap , ChannelOutboundInvoker , ChannelFutureFactory , Comparable < Channel > { </a> 1
<a> Integer id ( ) ; </a> 1
<a> EventLoop eventLoop ( ) ; </a> 0
<a> Channel parent ( ) ; </a> 0
<a> ChannelConfig config ( ) ; </a> 0
<a> ChannelPipeline pipeline ( ) ; </a> 1
<a> boolean isOpen ( ) ; </a> 0
<a> boolean isRegistered ( ) ; </a> 0
<a> boolean isActive ( ) ; </a> 0
<a> ChannelMetadata metadata ( ) ; </a> 0
<a> ByteBuf outboundByteBuffer ( ) ; </a> 1
<a> < T > MessageBuf < T > outboundMessageBuffer ( ) ; </a> 1
<a> SocketAddress localAddress ( ) ; </a> 0
<a> SocketAddress remoteAddress ( ) ; </a> 0
<a> ChannelFuture closeFuture ( ) ; </a> 0
<a> Unsafe unsafe ( ) ; </a> 0
<a> interface Unsafe { </a> 0
<a> ChannelHandlerContext directOutboundContext ( ) ; </a> 0
<a> ChannelFuture voidFuture ( ) ; </a> 0
<a> SocketAddress localAddress ( ) ; </a> 0
<a> SocketAddress remoteAddress ( ) ; </a> 0
<a> void register ( EventLoop eventLoop , ChannelFuture future ) ; </a> 0
<a> void bind ( SocketAddress localAddress , ChannelFuture future ) ; </a> 0
<a> void connect ( SocketAddress remoteAddress , SocketAddress localAddress , ChannelFuture future ) ; </a> 0
<a> void disconnect ( ChannelFuture future ) ; </a> 0
<a> void close ( ChannelFuture future ) ; </a> 0
<a> void deregister ( ChannelFuture future ) ; </a> 0
<a> void flush ( ChannelFuture future ) ; </a> 0
<a> void flushNow ( ) ; </a> 1
<a> void suspendRead ( ) ; </a> 1
<a> void resumeRead ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . channel . socket . SocketChannelConfig ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . channels . WritableByteChannel ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public interface ChannelConfig { </a> 0
<a> Map < ChannelOption < ? > , Object > getOptions ( ) ; </a> 0
<a> boolean setOptions ( Map < ChannelOption < ? > , ? > options ) ; </a> 0
<a> < T > T getOption ( ChannelOption < T > option ) ; </a> 0
<a> < T > boolean setOption ( ChannelOption < T > option , T value ) ; </a> 0
<a> int getConnectTimeoutMillis ( ) ; </a> 0
<a> void setConnectTimeoutMillis ( int connectTimeoutMillis ) ; </a> 0
<a> int getWriteSpinCount ( ) ; </a> 0
<a> void setWriteSpinCount ( int writeSpinCount ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public class ChannelException extends RuntimeException { </a> 0
<a> private static final long serialVersionUID = 2908618315971075004L ; </a> 0
<a> public ChannelException ( ) { </a> 0
<a> } </a> 0
<a> public ChannelException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public ChannelException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public ChannelException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . concurrent . Future ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public interface ChannelFuture extends Future < Void > { </a> 0
<a> Channel channel ( ) ; </a> 0
<a> @ Override </a> 0
<a> boolean isDone ( ) ; </a> 0
<a> @ Override </a> 0
<a> boolean isCancelled ( ) ; </a> 0
<a> boolean isSuccess ( ) ; </a> 0
<a> Throwable cause ( ) ; </a> 0
<a> boolean cancel ( ) ; </a> 0
<a> boolean setSuccess ( ) ; </a> 0
<a> boolean setFailure ( Throwable cause ) ; </a> 0
<a> boolean setProgress ( long amount , long current , long total ) ; </a> 0
<a> ChannelFuture addListener ( ChannelFutureListener listener ) ; </a> 0
<a> ChannelFuture removeListener ( ChannelFutureListener listener ) ; </a> 0
<a> ChannelFuture sync ( ) throws InterruptedException ; </a> 0
<a> ChannelFuture syncUninterruptibly ( ) ; </a> 0
<a> ChannelFuture await ( ) throws InterruptedException ; </a> 0
<a> ChannelFuture awaitUninterruptibly ( ) ; </a> 0
<a> boolean await ( long timeout , TimeUnit unit ) throws InterruptedException ; </a> 0
<a> boolean await ( long timeoutMillis ) throws InterruptedException ; </a> 0
<a> boolean awaitUninterruptibly ( long timeout , TimeUnit unit ) ; </a> 0
<a> boolean awaitUninterruptibly ( long timeoutMillis ) ; </a> 0
<a> interface Unsafe extends ChannelFuture { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . HashSet ; </a> 0
<a> import java . util . Set ; </a> 0
<a> public class ChannelFutureAggregator implements ChannelFutureListener { </a> 0
<a> private final ChannelFuture aggregateFuture ; </a> 0
<a> private Set < ChannelFuture > pendingFutures ; </a> 0
<a> public ChannelFutureAggregator ( ChannelFuture aggregateFuture ) { </a> 0
<a> this . aggregateFuture = aggregateFuture ; </a> 0
<a> } </a> 0
<a> public void addFuture ( ChannelFuture future ) { </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( pendingFutures == null ) { </a> 0
<a> pendingFutures = new HashSet < ChannelFuture > ( ) ; </a> 0
<a> } </a> 0
<a> pendingFutures . add ( future ) ; </a> 0
<a> } </a> 0
<a> future . addListener ( this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) </a> 1
<a> throws Exception { </a> 1
<a> if ( future . isCancelled ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> synchronized ( this ) { </a> 1
<a> if ( pendingFutures == null ) { </a> 0
<a> aggregateFuture . setSuccess ( ) ; </a> 0
<a> } else { </a> 0
<a> pendingFutures . remove ( future ) ; </a> 0
<a> if ( ! future . isSuccess ( ) ) { </a> 0
<a> aggregateFuture . setFailure ( future . cause ( ) ) ; </a> 0
<a> for ( ChannelFuture pendingFuture : pendingFutures ) { </a> 0
<a> pendingFuture . cancel ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> if ( pendingFutures . isEmpty ( ) ) { </a> 0
<a> aggregateFuture . setSuccess ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . EventListener ; </a> 0
<a> public interface ChannelFutureListener extends EventListener { </a> 0
<a> ChannelFutureListener CLOSE = new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) { </a> 0
<a> future . channel ( ) . close ( ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> ChannelFutureListener CLOSE_ON_FAILURE = new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) { </a> 0
<a> if ( ! future . isSuccess ( ) ) { </a> 0
<a> future . channel ( ) . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> void operationComplete ( ChannelFuture future ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public interface ChannelFutureProgressListener extends ChannelFutureListener { </a> 0
<a> void operationProgressed ( ChannelFuture future , long amount , long current , long total ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . channel . group . ChannelGroup ; </a> 0
<a> import java . lang . annotation . Documented ; </a> 0
<a> import java . lang . annotation . ElementType ; </a> 0
<a> import java . lang . annotation . Inherited ; </a> 0
<a> import java . lang . annotation . Retention ; </a> 0
<a> import java . lang . annotation . RetentionPolicy ; </a> 0
<a> import java . lang . annotation . Target ; </a> 0
<a> import java . nio . channels . Channels ; </a> 0
<a> public interface ChannelHandler { </a> 0
<a> void beforeAdd ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> void afterAdd ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> void beforeRemove ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> void afterRemove ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception ; </a> 0
<a> void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception ; </a> 1
<a> @ Inherited </a> 0
<a> @ Documented </a> 0
<a> @ Target ( ElementType . TYPE ) </a> 0
<a> @ Retention ( RetentionPolicy . RUNTIME ) </a> 0
<a> @ interface Sharable { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . net . SocketAddress ; </a> 1
<a> public class ChannelHandlerAdapter extends ChannelStateHandlerAdapter implements ChannelOperationHandler { </a> 0
<a> @ Override </a> 0
<a> public void bind ( ChannelHandlerContext ctx , SocketAddress localAddress , ChannelFuture future ) throws Exception { </a> 0
<a> ctx . bind ( localAddress , future ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void connect ( </a> 0
<a> ChannelHandlerContext ctx , SocketAddress remoteAddress , SocketAddress localAddress , </a> 0
<a> ChannelFuture future ) throws Exception { </a> 0
<a> ctx . connect ( remoteAddress , localAddress , future ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void disconnect ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> ctx . disconnect ( future ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void close ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> ctx . close ( future ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void deregister ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> ctx . deregister ( future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> if ( this instanceof ChannelOutboundHandler ) { </a> 0
<a> throw new IllegalStateException ( </a> 0
<a> "flush(...) must be overridden by " + getClass ( ) . getName ( ) + </a> 0
<a> ", which implements " + ChannelOutboundHandler . class . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> ctx . flush ( future ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . util . AttributeMap ; </a> 0
<a> import java . nio . channels . Channels ; </a> 0
<a> import java . util . Set ; </a> 0
<a> public interface ChannelHandlerContext </a> 0
<a> extends AttributeMap , ChannelFutureFactory , </a> 1
<a> ChannelInboundInvoker , ChannelOutboundInvoker { </a> 1
<a> Channel channel ( ) ; </a> 0
<a> ChannelPipeline pipeline ( ) ; </a> 1
<a> EventExecutor executor ( ) ; </a> 0
<a> String name ( ) ; </a> 0
<a> ChannelHandler handler ( ) ; </a> 0
<a> Set < ChannelHandlerType > type ( ) ; </a> 0
<a> boolean hasInboundByteBuffer ( ) ; </a> 1
<a> boolean hasInboundMessageBuffer ( ) ; </a> 1
<a> ByteBuf inboundByteBuffer ( ) ; </a> 1
<a> < T > MessageBuf < T > inboundMessageBuffer ( ) ; </a> 1
<a> boolean hasOutboundByteBuffer ( ) ; </a> 1
<a> boolean hasOutboundMessageBuffer ( ) ; </a> 1
<a> ByteBuf outboundByteBuffer ( ) ; </a> 1
<a> < T > MessageBuf < T > outboundMessageBuffer ( ) ; </a> 1
<a> boolean hasNextInboundByteBuffer ( ) ; </a> 0
<a> boolean hasNextInboundMessageBuffer ( ) ; </a> 0
<a> ByteBuf nextInboundByteBuffer ( ) ; </a> 1
<a> MessageBuf < Object > nextInboundMessageBuffer ( ) ; </a> 1
<a> boolean hasNextOutboundByteBuffer ( ) ; </a> 0
<a> boolean hasNextOutboundMessageBuffer ( ) ; </a> 0
<a> ByteBuf nextOutboundByteBuffer ( ) ; </a> 1
<a> MessageBuf < Object > nextOutboundMessageBuffer ( ) ; </a> 1
<a> boolean isReadable ( ) ; </a> 1
<a> void readable ( boolean readable ) ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public class ChannelHandlerLifeCycleException extends RuntimeException { </a> 0
<a> private static final long serialVersionUID = 8764799996088850672L ; </a> 0
<a> public ChannelHandlerLifeCycleException ( ) { </a> 0
<a> } </a> 0
<a> public ChannelHandlerLifeCycleException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public ChannelHandlerLifeCycleException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public ChannelHandlerLifeCycleException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public enum ChannelHandlerType { </a> 0
<a> STATE ( 0 ) , </a> 0
<a> INBOUND ( 0 ) , </a> 0
<a> OPERATION ( 1 ) , </a> 0
<a> OUTBOUND ( 1 ) ; </a> 0
<a> final int direction ; </a> 0
<a> ChannelHandlerType ( int direction ) { </a> 0
<a> this . direction = direction ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> public interface ChannelInboundByteHandler extends ChannelInboundHandler { </a> 1
<a> @ Override </a> 1
<a> ByteBuf newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> public abstract class ChannelInboundByteHandlerAdapter </a> 1
<a> extends ChannelInboundHandlerAdapter implements ChannelInboundByteHandler { </a> 0
<a> @ Override </a> 1
<a> public ByteBuf newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . buffer ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public final void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> ByteBuf in = ctx . inboundByteBuffer ( ) ; </a> 0
<a> try { </a> 0
<a> inboundBufferUpdated ( ctx , in ) ; </a> 0
<a> } finally { </a> 0
<a> if ( ! in . readable ( ) ) { </a> 1
<a> in . unsafe ( ) . discardSomeReadBytes ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> public abstract void inboundBufferUpdated ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception ; </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ChannelBuf ; </a> 1
<a> public interface ChannelInboundHandler extends ChannelStateHandler { </a> 0
<a> ChannelBuf newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public abstract class ChannelInboundHandlerAdapter </a> 0
<a> extends ChannelStateHandlerAdapter implements ChannelInboundHandler { </a> 0
<a> @ Override </a> 0
<a> public abstract void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public interface ChannelInboundInvoker { </a> 0
<a> void fireChannelRegistered ( ) ; </a> 0
<a> void fireChannelUnregistered ( ) ; </a> 0
<a> void fireChannelActive ( ) ; </a> 0
<a> void fireChannelInactive ( ) ; </a> 0
<a> void fireExceptionCaught ( Throwable cause ) ; </a> 0
<a> void fireUserEventTriggered ( Object event ) ; </a> 0
<a> void fireInboundBufferUpdated ( ) ; </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> public interface ChannelInboundMessageHandler < I > extends ChannelInboundHandler { </a> 1
<a> @ Override </a> 1
<a> MessageBuf < I > newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> public abstract class ChannelInboundMessageHandlerAdapter < I > </a> 1
<a> extends ChannelInboundHandlerAdapter implements ChannelInboundMessageHandler < I > { </a> 0
<a> @ Override </a> 1
<a> public MessageBuf < I > newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . messageBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public final void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> firstMessageReceived ( ctx ) ; </a> 0
<a> MessageBuf < I > in = ctx . inboundMessageBuffer ( ) ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> I msg = in . poll ( ) ; </a> 0
<a> if ( msg == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> try { </a> 0
<a> messageReceived ( ctx , msg ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> ctx . fireExceptionCaught ( t ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> lastMessageReceived ( ctx ) ; </a> 0
<a> } </a> 0
<a> public void firstMessageReceived ( ChannelHandlerContext ctx ) throws Exception { } </a> 0
<a> public abstract void messageReceived ( ChannelHandlerContext ctx , I msg ) throws Exception ; </a> 0
<a> public void lastMessageReceived ( ChannelHandlerContext ctx ) throws Exception { } </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> @ Sharable </a> 0
<a> public abstract class ChannelInitializer < C extends Channel > extends ChannelStateHandlerAdapter { </a> 1
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( ChannelInitializer . class ) ; </a> 0
<a> public abstract void initChannel ( C ch ) throws Exception ; </a> 0
<a> @ Override </a> 1
<a> public final void channelRegistered ( ChannelHandlerContext ctx ) </a> 1
<a> throws Exception { </a> 1
<a> boolean removed = false ; </a> 1
<a> boolean success = false ; </a> 0
<a> try { </a> 0
<a> initChannel ( ( C ) ctx . channel ( ) ) ; </a> 0
<a> ctx . pipeline ( ) . remove ( this ) ; </a> 1
<a> removed = true ; </a> 1
<a> ctx . fireChannelRegistered ( ) ; </a> 0
<a> success = true ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Failed to initialize a channel. Closing: " + ctx . channel ( ) , t ) ; </a> 0
<a> } finally { </a> 0
<a> if ( ! removed ) { </a> 1
<a> ctx . pipeline ( ) . remove ( this ) ; </a> 1
<a> } </a> 0
<a> if ( ! success ) { </a> 0
<a> ctx . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ChannelBufType ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> public final class ChannelMetadata { </a> 0
<a> private final ChannelBufType bufferType ; </a> 0
<a> private final boolean hasDisconnect ; </a> 0
<a> public ChannelMetadata ( ChannelBufType bufferType , boolean hasDisconnect ) { </a> 0
<a> if ( bufferType == null ) { </a> 0
<a> throw new NullPointerException ( "bufferType" ) ; </a> 0
<a> } </a> 0
<a> this . bufferType = bufferType ; </a> 0
<a> this . hasDisconnect = hasDisconnect ; </a> 0
<a> } </a> 0
<a> public ChannelBufType bufferType ( ) { </a> 0
<a> return bufferType ; </a> 0
<a> } </a> 0
<a> public boolean hasDisconnect ( ) { </a> 0
<a> return hasDisconnect ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> public interface ChannelOperationHandler extends ChannelHandler { </a> 1
<a> void bind ( ChannelHandlerContext ctx , SocketAddress localAddress , ChannelFuture future ) throws Exception ; </a> 0
<a> void connect ( </a> 1
<a> ChannelHandlerContext ctx , SocketAddress remoteAddress , </a> 1
<a> SocketAddress localAddress , ChannelFuture future ) throws Exception ; </a> 0
<a> void disconnect ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception ; </a> 0
<a> void close ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception ; </a> 0
<a> void deregister ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception ; </a> 0
<a> void flush ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception ; </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . net . SocketAddress ; </a> 1
<a> public class ChannelOperationHandlerAdapter implements ChannelOperationHandler { </a> 0
<a> @ Override </a> 0
<a> public void beforeAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void afterAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void afterRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) </a> 0
<a> throws Exception { </a> 0
<a> ctx . fireExceptionCaught ( cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) </a> 0
<a> throws Exception { </a> 0
<a> ctx . fireUserEventTriggered ( evt ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void bind ( ChannelHandlerContext ctx , SocketAddress localAddress , </a> 1
<a> ChannelFuture future ) throws Exception { </a> 0
<a> ctx . bind ( localAddress , future ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void connect ( ChannelHandlerContext ctx , SocketAddress remoteAddress , </a> 1
<a> SocketAddress localAddress , ChannelFuture future ) throws Exception { </a> 0
<a> ctx . connect ( remoteAddress , localAddress , future ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void disconnect ( ChannelHandlerContext ctx , ChannelFuture future ) </a> 0
<a> throws Exception { </a> 1
<a> ctx . disconnect ( future ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void close ( ChannelHandlerContext ctx , ChannelFuture future ) </a> 0
<a> throws Exception { </a> 1
<a> ctx . close ( future ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void deregister ( ChannelHandlerContext ctx , ChannelFuture future ) </a> 0
<a> throws Exception { </a> 1
<a> ctx . deregister ( future ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public void flush ( ChannelHandlerContext ctx , ChannelFuture future ) </a> 0
<a> throws Exception { </a> 0
<a> if ( this instanceof ChannelOutboundHandler ) { </a> 0
<a> throw new IllegalStateException ( </a> 0
<a> "flush(...) must be overridden by " + getClass ( ) . getName ( ) + </a> 0
<a> ", which implements " + ChannelOutboundHandler . class . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> ctx . flush ( future ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> public interface ChannelOutboundByteHandler extends ChannelOutboundHandler { </a> 1
<a> @ Override </a> 1
<a> ByteBuf newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> public abstract class ChannelOutboundByteHandlerAdapter </a> 1
<a> extends ChannelOutboundHandlerAdapter implements ChannelOutboundByteHandler { </a> 0
<a> @ Override </a> 1
<a> public ByteBuf newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . buffer ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public abstract class ChannelOutboundHandlerAdapter </a> 0
<a> extends ChannelOperationHandlerAdapter implements ChannelOutboundHandler { </a> 0
<a> @ Override </a> 0
<a> public abstract void flush ( ChannelHandlerContext ctx , ChannelFuture future ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . net . SocketAddress ; </a> 1
<a> public interface ChannelOutboundInvoker { </a> 0
<a> ChannelFuture bind ( SocketAddress localAddress ) ; </a> 1
<a> ChannelFuture connect ( SocketAddress remoteAddress ) ; </a> 1
<a> ChannelFuture connect ( SocketAddress remoteAddress , SocketAddress localAddress ) ; </a> 1
<a> ChannelFuture disconnect ( ) ; </a> 1
<a> ChannelFuture close ( ) ; </a> 1
<a> ChannelFuture deregister ( ) ; </a> 0
<a> ChannelFuture flush ( ) ; </a> 1
<a> ChannelFuture write ( Object message ) ; </a> 1
<a> ChannelFuture bind ( SocketAddress localAddress , ChannelFuture future ) ; </a> 0
<a> ChannelFuture connect ( SocketAddress remoteAddress , ChannelFuture future ) ; </a> 0
<a> ChannelFuture connect ( SocketAddress remoteAddress , SocketAddress localAddress , ChannelFuture future ) ; </a> 0
<a> ChannelFuture disconnect ( ChannelFuture future ) ; </a> 0
<a> ChannelFuture close ( ChannelFuture future ) ; </a> 0
<a> ChannelFuture deregister ( ChannelFuture future ) ; </a> 0
<a> ChannelFuture flush ( ChannelFuture future ) ; </a> 0
<a> ChannelFuture write ( Object message , ChannelFuture future ) ; </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> public abstract class ChannelOutboundMessageHandlerAdapter < I > </a> 1
<a> extends ChannelOutboundHandlerAdapter implements ChannelOutboundMessageHandler < I > { </a> 0
<a> @ Override </a> 1
<a> public MessageBuf < I > newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . messageBuffer ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import java . io . InputStream ; </a> 1
<a> import java . io . OutputStream ; </a> 1
<a> import java . nio . channels . Channels ; </a> 1
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . NoSuchElementException ; </a> 0
<a> public interface ChannelPipeline extends ChannelInboundInvoker , ChannelOutboundInvoker { </a> 0
<a> MessageBuf < Object > inboundMessageBuffer ( ) ; </a> 1
<a> ByteBuf inboundByteBuffer ( ) ; </a> 1
<a> MessageBuf < Object > outboundMessageBuffer ( ) ; </a> 1
<a> ByteBuf outboundByteBuffer ( ) ; </a> 1
<a> ChannelPipeline addFirst ( String name , ChannelHandler handler ) ; </a> 0
<a> ChannelPipeline addFirst ( EventExecutorGroup group , String name , ChannelHandler handler ) ; </a> 0
<a> ChannelPipeline addLast ( String name , ChannelHandler handler ) ; </a> 0
<a> ChannelPipeline addLast ( EventExecutorGroup group , String name , ChannelHandler handler ) ; </a> 0
<a> ChannelPipeline addBefore ( String baseName , String name , ChannelHandler handler ) ; </a> 0
<a> ChannelPipeline addBefore ( EventExecutorGroup group , String baseName , String name , ChannelHandler handler ) ; </a> 0
<a> ChannelPipeline addAfter ( String baseName , String name , ChannelHandler handler ) ; </a> 0
<a> ChannelPipeline addAfter ( EventExecutorGroup group , String baseName , String name , ChannelHandler handler ) ; </a> 0
<a> ChannelPipeline addFirst ( ChannelHandler ... handlers ) ; </a> 0
<a> ChannelPipeline addFirst ( EventExecutorGroup group , ChannelHandler ... handlers ) ; </a> 0
<a> ChannelPipeline addLast ( ChannelHandler ... handlers ) ; </a> 0
<a> ChannelPipeline addLast ( EventExecutorGroup group , ChannelHandler ... handlers ) ; </a> 0
<a> void remove ( ChannelHandler handler ) ; </a> 0
<a> ChannelHandler remove ( String name ) ; </a> 0
<a> < T extends ChannelHandler > T remove ( Class < T > handlerType ) ; </a> 0
<a> ChannelHandler removeFirst ( ) ; </a> 0
<a> ChannelHandler removeLast ( ) ; </a> 0
<a> void replace ( ChannelHandler oldHandler , String newName , ChannelHandler newHandler ) ; </a> 0
<a> ChannelHandler replace ( String oldName , String newName , ChannelHandler newHandler ) ; </a> 0
<a> < T extends ChannelHandler > T replace ( Class < T > oldHandlerType , String newName , ChannelHandler newHandler ) ; </a> 0
<a> ChannelHandler first ( ) ; </a> 0
<a> ChannelHandler last ( ) ; </a> 0
<a> ChannelHandler get ( String name ) ; </a> 0
<a> < T extends ChannelHandler > T get ( Class < T > handlerType ) ; </a> 0
<a> ChannelHandlerContext context ( ChannelHandler handler ) ; </a> 0
<a> ChannelHandlerContext context ( String name ) ; </a> 0
<a> ChannelHandlerContext context ( Class < ? extends ChannelHandler > handlerType ) ; </a> 0
<a> Channel channel ( ) ; </a> 0
<a> List < String > names ( ) ; </a> 0
<a> Map < String , ChannelHandler > toMap ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public class ChannelPipelineException extends ChannelException { </a> 0
<a> private static final long serialVersionUID = 3379174210419885980L ; </a> 0
<a> public ChannelPipelineException ( ) { </a> 0
<a> } </a> 0
<a> public ChannelPipelineException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public ChannelPipelineException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public ChannelPipelineException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public interface ChannelStateHandler extends ChannelHandler { </a> 1
<a> void channelRegistered ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> void channelUnregistered ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> void channelActive ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> void channelInactive ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception ; </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public class ChannelStateHandlerAdapter implements ChannelStateHandler { </a> 0
<a> boolean added ; </a> 0
<a> final boolean isSharable ( ) { </a> 0
<a> return getClass ( ) . isAnnotationPresent ( Sharable . class ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void afterAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void beforeRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void afterRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) </a> 0
<a> throws Exception { </a> 0
<a> ctx . fireExceptionCaught ( cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) </a> 1
<a> throws Exception { </a> 1
<a> ctx . fireUserEventTriggered ( evt ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> public void channelRegistered ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> ctx . fireChannelRegistered ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void channelUnregistered ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> ctx . fireChannelUnregistered ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void channelActive ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> ctx . fireChannelActive ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> ctx . fireChannelInactive ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> if ( this instanceof ChannelInboundHandler ) { </a> 0
<a> throw new IllegalStateException ( </a> 0
<a> "inboundBufferUpdated(...) must be overridden by " + getClass ( ) . getName ( ) + </a> 0
<a> ", which implements " + ChannelInboundHandler . class . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . util . Iterator ; </a> 1
<a> import java . util . concurrent . BlockingQueue ; </a> 1
<a> import java . util . concurrent . Callable ; </a> 1
<a> import java . util . concurrent . DelayQueue ; </a> 1
<a> import java . util . concurrent . Delayed ; </a> 1
<a> import java . util . concurrent . FutureTask ; </a> 0
<a> import java . util . concurrent . RejectedExecutionException ; </a> 1
<a> import java . util . concurrent . ScheduledFuture ; </a> 0
<a> import java . util . concurrent . Semaphore ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . atomic . AtomicLong ; </a> 1
<a> public final class ChannelTaskScheduler { </a> 0
<a> private static final InternalLogger logger = </a> 1
<a> InternalLoggerFactory . getInstance ( ChannelTaskScheduler . class ) ; </a> 0
<a> private static final long SCHEDULE_PURGE_INTERVAL = TimeUnit . SECONDS . toNanos ( 1 ) ; </a> 0
<a> private static final long START_TIME = System . nanoTime ( ) ; </a> 1
<a> private static final AtomicLong nextTaskId = new AtomicLong ( ) ; </a> 1
<a> private static long nanoTime ( ) { </a> 0
<a> return System . nanoTime ( ) - START_TIME ; </a> 0
<a> } </a> 0
<a> private static long deadlineNanos ( long delay ) { </a> 0
<a> return nanoTime ( ) + delay ; </a> 0
<a> } </a> 0
<a> private final BlockingQueue < ScheduledFutureTask < ? > > taskQueue = new DelayQueue < ScheduledFutureTask < ? > > ( ) ; </a> 1
<a> private final Thread thread ; </a> 0
<a> private final Object stateLock = new Object ( ) ; </a> 0
<a> private final Semaphore threadLock = new Semaphore ( 0 ) ; </a> 0
<a> private volatile int state ; </a> 1
<a> public ChannelTaskScheduler ( ThreadFactory threadFactory ) { </a> 0
<a> if ( threadFactory == null ) { </a> 0
<a> throw new NullPointerException ( "threadFactory" ) ; </a> 0
<a> } </a> 0
<a> thread = threadFactory . newThread ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> try { </a> 1
<a> for ( ; ; ) { </a> 1
<a> ScheduledFutureTask < ? > task ; </a> 1
<a> try { </a> 1
<a> task = taskQueue . take ( ) ; </a> 1
<a> runTask ( task ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> if ( isShutdown ( ) && taskQueue . peek ( ) == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } finally { </a> 0
<a> try { </a> 0
<a> try { </a> 0
<a> cleanupTasks ( ) ; </a> 0
<a> } finally { </a> 0
<a> synchronized ( stateLock ) { </a> 0
<a> state = 3 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> cleanupTasks ( ) ; </a> 0
<a> } finally { </a> 0
<a> threadLock . release ( ) ; </a> 1
<a> assert taskQueue . isEmpty ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private void runTask ( ScheduledFutureTask < ? > task ) { </a> 1
<a> EventExecutor executor = task . executor ; </a> 0
<a> if ( executor == null ) { </a> 1
<a> task . run ( ) ; </a> 1
<a> } else { </a> 1
<a> if ( executor . isShutdown ( ) ) { </a> 1
<a> task . cancel ( false ) ; </a> 1
<a> } else { </a> 1
<a> try { </a> 1
<a> task . executor . execute ( task ) ; </a> 0
<a> } catch ( RejectedExecutionException e ) { </a> 1
<a> task . cancel ( false ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void cleanupTasks ( ) { </a> 0
<a> for ( ; ; ) { </a> 0
<a> boolean ran = false ; </a> 0
<a> cancelScheduledTasks ( ) ; </a> 0
<a> for ( ; ; ) { </a> 1
<a> final ScheduledFutureTask < ? > task = taskQueue . poll ( ) ; </a> 1
<a> if ( task == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> try { </a> 1
<a> runTask ( task ) ; </a> 1
<a> ran = true ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "A task raised an exception." , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ! ran && taskQueue . isEmpty ( ) ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> private boolean inSameThread ( ) { </a> 1
<a> return Thread . currentThread ( ) == thread ; </a> 1
<a> } </a> 1
<a> public void shutdown ( ) { </a> 1
<a> boolean inSameThread = inSameThread ( ) ; </a> 1
<a> boolean wakeup = false ; </a> 1
<a> if ( inSameThread ) { </a> 1
<a> synchronized ( stateLock ) { </a> 0
<a> assert state == 1 ; </a> 0
<a> state = 2 ; </a> 0
<a> wakeup = true ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> synchronized ( stateLock ) { </a> 0
<a> switch ( state ) { </a> 0
<a> case 0 : </a> 0
<a> state = 3 ; </a> 0
<a> threadLock . release ( ) ; </a> 1
<a> break ; </a> 1
<a> case 1 : </a> 1
<a> state = 2 ; </a> 1
<a> wakeup = true ; </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> if ( wakeup && ! inSameThread && isShutdown ( ) ) { </a> 1
<a> thread . interrupt ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public boolean isShutdown ( ) { </a> 1
<a> return state >= 2 ; </a> 1
<a> } </a> 1
<a> public boolean isTerminated ( ) { </a> 1
<a> return state == 3 ; </a> 1
<a> } </a> 1
<a> public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { </a> 0
<a> if ( unit == null ) { </a> 0
<a> throw new NullPointerException ( "unit" ) ; </a> 0
<a> } </a> 0
<a> if ( inSameThread ( ) ) { </a> 1
<a> throw new IllegalStateException ( "cannot await termination of the current thread" ) ; </a> 0
<a> } </a> 0
<a> if ( threadLock . tryAcquire ( timeout , unit ) ) { </a> 0
<a> threadLock . release ( ) ; </a> 0
<a> } </a> 0
<a> return isTerminated ( ) ; </a> 0
<a> } </a> 0
<a> public ScheduledFuture < ? > schedule ( </a> 1
<a> EventExecutor executor , Runnable command , long delay , TimeUnit unit ) { </a> 1
<a> if ( executor == null ) { </a> 1
<a> throw new NullPointerException ( "executor" ) ; </a> 1
<a> } </a> 1
<a> if ( command == null ) { </a> 0
<a> throw new NullPointerException ( "command" ) ; </a> 0
<a> } </a> 0
<a> if ( unit == null ) { </a> 0
<a> throw new NullPointerException ( "unit" ) ; </a> 0
<a> } </a> 0
<a> if ( delay < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> String . format ( "delay: %d (expected: >= 0)" , delay ) ) ; </a> 0
<a> } </a> 0
<a> return schedule ( new ScheduledFutureTask < Void > ( executor , command , null , deadlineNanos ( unit . toNanos ( delay ) ) ) ) ; </a> 0
<a> } </a> 1
<a> public < V > ScheduledFuture < V > schedule ( </a> 1
<a> EventExecutor executor , Callable < V > callable , long delay , TimeUnit unit ) { </a> 1
<a> if ( executor == null ) { </a> 1
<a> throw new NullPointerException ( "executor" ) ; </a> 1
<a> } </a> 1
<a> if ( callable == null ) { </a> 0
<a> throw new NullPointerException ( "callable" ) ; </a> 0
<a> } </a> 0
<a> if ( unit == null ) { </a> 0
<a> throw new NullPointerException ( "unit" ) ; </a> 0
<a> } </a> 0
<a> if ( delay < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> String . format ( "delay: %d (expected: >= 0)" , delay ) ) ; </a> 0
<a> } </a> 0
<a> return schedule ( new ScheduledFutureTask < V > ( executor , callable , deadlineNanos ( unit . toNanos ( delay ) ) ) ) ; </a> 0
<a> } </a> 1
<a> public ScheduledFuture < ? > scheduleAtFixedRate ( </a> 1
<a> EventExecutor executor , Runnable command , long initialDelay , long period , TimeUnit unit ) { </a> 1
<a> if ( executor == null ) { </a> 1
<a> throw new NullPointerException ( "executor" ) ; </a> 1
<a> } </a> 1
<a> if ( command == null ) { </a> 0
<a> throw new NullPointerException ( "command" ) ; </a> 0
<a> } </a> 0
<a> if ( unit == null ) { </a> 0
<a> throw new NullPointerException ( "unit" ) ; </a> 0
<a> } </a> 0
<a> if ( initialDelay < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> String . format ( "initialDelay: %d (expected: >= 0)" , initialDelay ) ) ; </a> 0
<a> } </a> 0
<a> if ( period <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> String . format ( "period: %d (expected: > 0)" , period ) ) ; </a> 0
<a> } </a> 0
<a> return schedule ( new ScheduledFutureTask < Void > ( </a> 0
<a> executor , command , null , deadlineNanos ( unit . toNanos ( initialDelay ) ) , unit . toNanos ( period ) ) ) ; </a> 0
<a> } </a> 1
<a> public ScheduledFuture < ? > scheduleWithFixedDelay ( </a> 1
<a> EventExecutor executor , Runnable command , long initialDelay , long delay , TimeUnit unit ) { </a> 1
<a> if ( executor == null ) { </a> 1
<a> throw new NullPointerException ( "executor" ) ; </a> 1
<a> } </a> 1
<a> if ( command == null ) { </a> 0
<a> throw new NullPointerException ( "command" ) ; </a> 0
<a> } </a> 0
<a> if ( unit == null ) { </a> 0
<a> throw new NullPointerException ( "unit" ) ; </a> 0
<a> } </a> 0
<a> if ( initialDelay < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> String . format ( "initialDelay: %d (expected: >= 0)" , initialDelay ) ) ; </a> 0
<a> } </a> 0
<a> if ( delay <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> String . format ( "delay: %d (expected: > 0)" , delay ) ) ; </a> 0
<a> } </a> 0
<a> return schedule ( new ScheduledFutureTask < Void > ( </a> 0
<a> executor , command , null , deadlineNanos ( unit . toNanos ( initialDelay ) ) , - unit . toNanos ( delay ) ) ) ; </a> 0
<a> } </a> 0
<a> private < V > ScheduledFuture < V > schedule ( ScheduledFutureTask < V > task ) { </a> 0
<a> if ( isShutdown ( ) ) { </a> 0
<a> reject ( ) ; </a> 0
<a> } </a> 0
<a> taskQueue . add ( task ) ; </a> 1
<a> if ( isShutdown ( ) ) { </a> 1
<a> task . cancel ( false ) ; </a> 1
<a> } </a> 1
<a> boolean started = false ; </a> 1
<a> if ( ! inSameThread ( ) ) { </a> 1
<a> synchronized ( stateLock ) { </a> 0
<a> if ( state == 0 ) { </a> 0
<a> state = 1 ; </a> 0
<a> thread . start ( ) ; </a> 0
<a> started = true ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> if ( started ) { </a> 1
<a> schedule ( new ScheduledFutureTask < Void > ( </a> 0
<a> null , new PurgeTask ( ) , null , </a> 0
<a> deadlineNanos ( SCHEDULE_PURGE_INTERVAL ) , - SCHEDULE_PURGE_INTERVAL ) ) ; </a> 1
<a> } </a> 1
<a> return task ; </a> 1
<a> } </a> 1
<a> private static void reject ( ) { </a> 0
<a> throw new RejectedExecutionException ( "event executor shut down" ) ; </a> 0
<a> } </a> 0
<a> private void cancelScheduledTasks ( ) { </a> 1
<a> if ( taskQueue . isEmpty ( ) ) { </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> for ( ScheduledFutureTask < ? > task : taskQueue . toArray ( new ScheduledFutureTask < ? > [ taskQueue . size ( ) ] ) ) { </a> 1
<a> task . cancel ( false ) ; </a> 1
<a> } </a> 1
<a> taskQueue . clear ( ) ; </a> 1
<a> } </a> 1
<a> private class ScheduledFutureTask < V > extends FutureTask < V > implements ScheduledFuture < V > { </a> 0
<a> private final EventExecutor executor ; </a> 0
<a> private final long id = nextTaskId . getAndIncrement ( ) ; </a> 0
<a> private long deadlineNanos ; </a> 0
<a> private final long periodNanos ; </a> 0
<a> ScheduledFutureTask ( EventExecutor executor , Runnable runnable , V result , long nanoTime ) { </a> 0
<a> super ( runnable , result ) ; </a> 0
<a> this . executor = executor ; </a> 0
<a> deadlineNanos = nanoTime ; </a> 0
<a> periodNanos = 0 ; </a> 0
<a> } </a> 1
<a> ScheduledFutureTask ( EventExecutor executor , Runnable runnable , V result , long nanoTime , long period ) { </a> 0
<a> super ( runnable , result ) ; </a> 0
<a> if ( period == 0 ) { </a> 1
<a> throw new IllegalArgumentException ( </a> 0
<a> String . format ( "period: %d (expected: != 0)" , period ) ) ; </a> 0
<a> } </a> 1
<a> this . executor = executor ; </a> 0
<a> deadlineNanos = nanoTime ; </a> 1
<a> periodNanos = period ; </a> 1
<a> } </a> 1
<a> ScheduledFutureTask ( EventExecutor executor , Callable < V > callable , long nanoTime ) { </a> 0
<a> super ( callable ) ; </a> 0
<a> this . executor = executor ; </a> 0
<a> deadlineNanos = nanoTime ; </a> 1
<a> periodNanos = 0 ; </a> 1
<a> } </a> 0
<a> public long deadlineNanos ( ) { </a> 0
<a> return deadlineNanos ; </a> 0
<a> } </a> 0
<a> public long delayNanos ( ) { </a> 0
<a> return Math . max ( 0 , deadlineNanos ( ) - nanoTime ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public long getDelay ( TimeUnit unit ) { </a> 0
<a> return unit . convert ( delayNanos ( ) , TimeUnit . NANOSECONDS ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( Delayed o ) { </a> 0
<a> if ( this == o ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> ScheduledFutureTask < ? > that = ( ScheduledFutureTask < ? > ) o ; </a> 0
<a> long d = deadlineNanos ( ) - that . deadlineNanos ( ) ; </a> 0
<a> if ( d < 0 ) { </a> 0
<a> return - 1 ; </a> 0
<a> } else if ( d > 0 ) { </a> 0
<a> return 1 ; </a> 0
<a> } else if ( id < that . id ) { </a> 0
<a> return - 1 ; </a> 0
<a> } else if ( id == that . id ) { </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } else { </a> 0
<a> return 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 1
<a> if ( periodNanos == 0 ) { </a> 1
<a> super . run ( ) ; </a> 0
<a> } else { </a> 1
<a> boolean reset = runAndReset ( ) ; </a> 0
<a> if ( reset && ! isShutdown ( ) ) { </a> 0
<a> long p = periodNanos ; </a> 0
<a> if ( p > 0 ) { </a> 0
<a> deadlineNanos += p ; </a> 0
<a> } else { </a> 0
<a> deadlineNanos = nanoTime ( ) - p ; </a> 0
<a> } </a> 0
<a> schedule ( this ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private final class PurgeTask implements Runnable { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> Iterator < ScheduledFutureTask < ? > > i = taskQueue . iterator ( ) ; </a> 1
<a> while ( i . hasNext ( ) ) { </a> 1
<a> ScheduledFutureTask < ? > task = i . next ( ) ; </a> 0
<a> if ( task . isCancelled ( ) ) { </a> 0
<a> i . remove ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . buffer . ChannelBuf ; </a> 1
<a> import java . net . SocketAddress ; </a> 0
<a> public class CombinedChannelHandler </a> 0
<a> extends ChannelHandlerAdapter implements ChannelInboundHandler , ChannelOutboundHandler { </a> 0
<a> private ChannelOutboundHandler out ; </a> 0
<a> private ChannelInboundHandler in ; </a> 0
<a> protected CombinedChannelHandler ( ) { </a> 0
<a> } </a> 0
<a> public CombinedChannelHandler ( </a> 0
<a> ChannelInboundHandler inboundHandler , ChannelOutboundHandler outboundHandler ) { </a> 0
<a> init ( inboundHandler , outboundHandler ) ; </a> 0
<a> } </a> 0
<a> protected void init ( </a> 0
<a> ChannelInboundHandler inboundHandler , ChannelOutboundHandler outboundHandler ) { </a> 0
<a> if ( inboundHandler == null ) { </a> 0
<a> throw new NullPointerException ( "inboundHandler" ) ; </a> 0
<a> } </a> 0
<a> if ( outboundHandler == null ) { </a> 0
<a> throw new NullPointerException ( "outboundHandler" ) ; </a> 0
<a> } </a> 0
<a> if ( inboundHandler instanceof ChannelOperationHandler ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "inboundHandler must not implement " + </a> 0
<a> ChannelOperationHandler . class . getSimpleName ( ) + " to get combined." ) ; </a> 0
<a> } </a> 0
<a> if ( outboundHandler instanceof ChannelStateHandler ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "outboundHandler must not implement " + </a> 0
<a> ChannelStateHandler . class . getSimpleName ( ) + " to get combined." ) ; </a> 0
<a> } </a> 0
<a> if ( in != null ) { </a> 0
<a> throw new IllegalStateException ( "init() cannot be called more than once." ) ; </a> 0
<a> } </a> 0
<a> in = inboundHandler ; </a> 0
<a> out = outboundHandler ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelBuf newInboundBuffer ( </a> 1
<a> ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return in . newInboundBuffer ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelBuf newOutboundBuffer ( </a> 1
<a> ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return out . newOutboundBuffer ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void beforeAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> if ( in == null ) { </a> 0
<a> throw new IllegalStateException ( </a> 0
<a> "not initialized yet - call init() in the constructor of the subclass" ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> in . beforeAdd ( ctx ) ; </a> 0
<a> } finally { </a> 0
<a> out . beforeAdd ( ctx ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void afterAdd ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> try { </a> 1
<a> in . afterAdd ( ctx ) ; </a> 0
<a> } finally { </a> 0
<a> out . afterAdd ( ctx ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void beforeRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> try { </a> 0
<a> in . beforeRemove ( ctx ) ; </a> 0
<a> } finally { </a> 0
<a> out . beforeRemove ( ctx ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void afterRemove ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> try { </a> 0
<a> in . afterRemove ( ctx ) ; </a> 0
<a> } finally { </a> 0
<a> out . afterRemove ( ctx ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void channelRegistered ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> in . channelRegistered ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelUnregistered ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> in . channelUnregistered ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelActive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> in . channelActive ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> in . channelInactive ( ctx ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> in . exceptionCaught ( ctx , cause ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception { </a> 1
<a> in . userEventTriggered ( ctx , evt ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> in . inboundBufferUpdated ( ctx ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void bind ( </a> 1
<a> ChannelHandlerContext ctx , </a> 1
<a> SocketAddress localAddress , ChannelFuture future ) throws Exception { </a> 0
<a> out . bind ( ctx , localAddress , future ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void connect ( </a> 1
<a> ChannelHandlerContext ctx , </a> 1
<a> SocketAddress remoteAddress , SocketAddress localAddress , </a> 1
<a> ChannelFuture future ) throws Exception { </a> 0
<a> out . connect ( ctx , remoteAddress , localAddress , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void disconnect ( </a> 0
<a> ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> out . disconnect ( ctx , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void close ( </a> 0
<a> ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> out . close ( ctx , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void deregister ( </a> 0
<a> ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> out . deregister ( ctx , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( </a> 0
<a> ChannelHandlerContext ctx , ChannelFuture future ) throws Exception { </a> 0
<a> out . flush ( ctx , future ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public abstract class CompleteChannelFuture implements ChannelFuture { </a> 0
<a> private final Channel channel ; </a> 0
<a> protected CompleteChannelFuture ( Channel channel ) { </a> 0
<a> if ( channel == null ) { </a> 0
<a> throw new NullPointerException ( "channel" ) ; </a> 0
<a> } </a> 0
<a> this . channel = channel ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture addListener ( final ChannelFutureListener listener ) { </a> 0
<a> if ( listener == null ) { </a> 0
<a> throw new NullPointerException ( "listener" ) ; </a> 0
<a> } </a> 0
<a> DefaultChannelFuture . notifyListener ( this , listener ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture removeListener ( ChannelFutureListener listener ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture await ( ) throws InterruptedException { </a> 0
<a> if ( Thread . interrupted ( ) ) { </a> 0
<a> throw new InterruptedException ( ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean await ( long timeout , TimeUnit unit ) throws InterruptedException { </a> 0
<a> if ( Thread . interrupted ( ) ) { </a> 0
<a> throw new InterruptedException ( ) ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean await ( long timeoutMillis ) throws InterruptedException { </a> 0
<a> if ( Thread . interrupted ( ) ) { </a> 0
<a> throw new InterruptedException ( ) ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture awaitUninterruptibly ( ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitUninterruptibly ( long timeout , TimeUnit unit ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitUninterruptibly ( long timeoutMillis ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Channel channel ( ) { </a> 0
<a> return channel ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDone ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean setProgress ( long amount , long current , long total ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean setFailure ( Throwable cause ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean setSuccess ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean cancel ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean cancel ( boolean mayInterruptIfRunning ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isCancelled ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import static io . netty . channel . ChannelOption . * ; </a> 0
<a> import io . netty . channel . socket . SocketChannelConfig ; </a> 0
<a> import java . util . IdentityHashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . Map . Entry ; </a> 0
<a> public class DefaultChannelConfig implements ChannelConfig { </a> 0
<a> private static final int DEFAULT_CONNECT_TIMEOUT = 30000 ; </a> 0
<a> private volatile int connectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT ; </a> 0
<a> private volatile int writeSpinCount = 16 ; </a> 0
<a> @ Override </a> 0
<a> public Map < ChannelOption < ? > , Object > getOptions ( ) { </a> 0
<a> return getOptions ( null , CONNECT_TIMEOUT_MILLIS , WRITE_SPIN_COUNT ) ; </a> 1
<a> } </a> 0
<a> protected Map < ChannelOption < ? > , Object > getOptions ( </a> 0
<a> Map < ChannelOption < ? > , Object > result , ChannelOption < ? > ... options ) { </a> 0
<a> if ( result == null ) { </a> 0
<a> result = new IdentityHashMap < ChannelOption < ? > , Object > ( ) ; </a> 0
<a> } </a> 0
<a> for ( ChannelOption < ? > o : options ) { </a> 0
<a> result . put ( o , getOption ( o ) ) ; </a> 0
<a> } </a> 0
<a> return result ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean setOptions ( Map < ChannelOption < ? > , ? > options ) { </a> 0
<a> if ( options == null ) { </a> 0
<a> throw new NullPointerException ( "options" ) ; </a> 0
<a> } </a> 0
<a> boolean setAllOptions = true ; </a> 0
<a> for ( Entry < ChannelOption < ? > , ? > e : options . entrySet ( ) ) { </a> 0
<a> if ( ! setOption ( ( ChannelOption < Object > ) e . getKey ( ) , e . getValue ( ) ) ) { </a> 0
<a> setAllOptions = false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return setAllOptions ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public < T > T getOption ( ChannelOption < T > option ) { </a> 0
<a> if ( option == null ) { </a> 0
<a> throw new NullPointerException ( "option" ) ; </a> 0
<a> } </a> 0
<a> if ( option == CONNECT_TIMEOUT_MILLIS ) { </a> 0
<a> return ( T ) Integer . valueOf ( getConnectTimeoutMillis ( ) ) ; </a> 0
<a> } else if ( option == WRITE_SPIN_COUNT ) { </a> 0
<a> return ( T ) Integer . valueOf ( getWriteSpinCount ( ) ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > boolean setOption ( ChannelOption < T > option , T value ) { </a> 0
<a> validate ( option , value ) ; </a> 0
<a> if ( option == CONNECT_TIMEOUT_MILLIS ) { </a> 0
<a> setConnectTimeoutMillis ( ( Integer ) value ) ; </a> 0
<a> } else if ( option == WRITE_SPIN_COUNT ) { </a> 0
<a> setWriteSpinCount ( ( Integer ) value ) ; </a> 0
<a> } else { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> protected < T > void validate ( ChannelOption < T > option , T value ) { </a> 0
<a> if ( option == null ) { </a> 0
<a> throw new NullPointerException ( "option" ) ; </a> 0
<a> } </a> 0
<a> option . validate ( value ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getConnectTimeoutMillis ( ) { </a> 0
<a> return connectTimeoutMillis ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setConnectTimeoutMillis ( int connectTimeoutMillis ) { </a> 0
<a> if ( connectTimeoutMillis < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( String . format ( </a> 0
<a> "connectTimeoutMillis: %d (expected: >= 0)" , connectTimeoutMillis ) ) ; </a> 0
<a> } </a> 0
<a> this . connectTimeoutMillis = connectTimeoutMillis ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getWriteSpinCount ( ) { </a> 0
<a> return writeSpinCount ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setWriteSpinCount ( int writeSpinCount ) { </a> 0
<a> if ( writeSpinCount <= 0 ) { </a> 0
<a> throw new IllegalArgumentException ( </a> 0
<a> "writeSpinCount must be a positive integer." ) ; </a> 0
<a> } </a> 0
<a> this . writeSpinCount = writeSpinCount ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import static java . util . concurrent . TimeUnit . * ; </a> 0
<a> import io . netty . channel . ChannelFlushFutureNotifier . FlushCheckpoint ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . nio . channels . Channels ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . concurrent . ExecutionException ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . TimeoutException ; </a> 0
<a> public class DefaultChannelFuture extends FlushCheckpoint implements ChannelFuture { </a> 0
<a> private static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( DefaultChannelFuture . class ) ; </a> 0
<a> private static final int MAX_LISTENER_STACK_DEPTH = 8 ; </a> 0
<a> private static final ThreadLocal < Integer > LISTENER_STACK_DEPTH = new ThreadLocal < Integer > ( ) { </a> 0
<a> @ Override </a> 0
<a> protected Integer initialValue ( ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private static final Throwable CANCELLED = new Throwable ( ) ; </a> 0
<a> private final Channel channel ; </a> 0
<a> private final boolean cancellable ; </a> 0
<a> private ChannelFutureListener firstListener ; </a> 0
<a> private List < ChannelFutureListener > otherListeners ; </a> 0
<a> private List < ChannelFutureProgressListener > progressListeners ; </a> 0
<a> private boolean done ; </a> 0
<a> private Throwable cause ; </a> 0
<a> private int waiters ; </a> 0
<a> private long flushCheckpoint ; </a> 0
<a> public DefaultChannelFuture ( Channel channel , boolean cancellable ) { </a> 0
<a> this . channel = channel ; </a> 0
<a> this . cancellable = cancellable ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Channel channel ( ) { </a> 0
<a> return channel ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized boolean isDone ( ) { </a> 0
<a> return done ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized boolean isSuccess ( ) { </a> 0
<a> return done && cause == null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized Throwable cause ( ) { </a> 0
<a> if ( cause != CANCELLED ) { </a> 0
<a> return cause ; </a> 0
<a> } else { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized boolean isCancelled ( ) { </a> 0
<a> return cause == CANCELLED ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture addListener ( final ChannelFutureListener listener ) { </a> 0
<a> if ( listener == null ) { </a> 0
<a> throw new NullPointerException ( "listener" ) ; </a> 0
<a> } </a> 0
<a> boolean notifyNow = false ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( done ) { </a> 0
<a> notifyNow = true ; </a> 0
<a> } else { </a> 0
<a> if ( firstListener == null ) { </a> 0
<a> firstListener = listener ; </a> 0
<a> } else { </a> 0
<a> if ( otherListeners == null ) { </a> 0
<a> otherListeners = new ArrayList < ChannelFutureListener > ( 1 ) ; </a> 0
<a> } </a> 0
<a> otherListeners . add ( listener ) ; </a> 0
<a> } </a> 0
<a> if ( listener instanceof ChannelFutureProgressListener ) { </a> 0
<a> if ( progressListeners == null ) { </a> 0
<a> progressListeners = new ArrayList < ChannelFutureProgressListener > ( 1 ) ; </a> 0
<a> } </a> 0
<a> progressListeners . add ( ( ChannelFutureProgressListener ) listener ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( notifyNow ) { </a> 0
<a> notifyListener ( this , listener ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture removeListener ( ChannelFutureListener listener ) { </a> 0
<a> if ( listener == null ) { </a> 0
<a> throw new NullPointerException ( "listener" ) ; </a> 0
<a> } </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( ! done ) { </a> 0
<a> if ( listener == firstListener ) { </a> 0
<a> if ( otherListeners != null && ! otherListeners . isEmpty ( ) ) { </a> 0
<a> firstListener = otherListeners . remove ( 0 ) ; </a> 0
<a> } else { </a> 0
<a> firstListener = null ; </a> 0
<a> } </a> 0
<a> } else if ( otherListeners != null ) { </a> 0
<a> otherListeners . remove ( listener ) ; </a> 0
<a> } </a> 0
<a> if ( listener instanceof ChannelFutureProgressListener ) { </a> 0
<a> progressListeners . remove ( listener ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture sync ( ) throws InterruptedException { </a> 0
<a> await ( ) ; </a> 0
<a> rethrowIfFailed ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture syncUninterruptibly ( ) { </a> 0
<a> awaitUninterruptibly ( ) ; </a> 0
<a> rethrowIfFailed ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Void get ( ) throws InterruptedException , ExecutionException { </a> 0
<a> await ( ) ; </a> 0
<a> Throwable cause = cause ( ) ; </a> 0
<a> if ( cause == null ) { </a> 0
<a> return null ; </a> 0
<a> } else { </a> 0
<a> throw new ExecutionException ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Void get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , </a> 0
<a> TimeoutException { </a> 0
<a> if ( ! await ( timeout , unit ) ) { </a> 0
<a> throw new TimeoutException ( ) ; </a> 0
<a> } </a> 0
<a> Throwable cause = cause ( ) ; </a> 0
<a> if ( cause == null ) { </a> 0
<a> return null ; </a> 0
<a> } else { </a> 0
<a> throw new ExecutionException ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void rethrowIfFailed ( ) { </a> 0
<a> Throwable cause = cause ( ) ; </a> 0
<a> if ( cause == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( cause instanceof RuntimeException ) { </a> 0
<a> throw ( RuntimeException ) cause ; </a> 0
<a> } </a> 0
<a> if ( cause instanceof Error ) { </a> 0
<a> throw ( Error ) cause ; </a> 0
<a> } </a> 0
<a> throw new ChannelException ( cause ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture await ( ) throws InterruptedException { </a> 0
<a> if ( Thread . interrupted ( ) ) { </a> 0
<a> throw new InterruptedException ( ) ; </a> 0
<a> } </a> 0
<a> synchronized ( this ) { </a> 0
<a> while ( ! done ) { </a> 0
<a> checkDeadLock ( ) ; </a> 0
<a> waiters ++ ; </a> 0
<a> try { </a> 0
<a> wait ( ) ; </a> 0
<a> } finally { </a> 0
<a> waiters -- ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean await ( long timeout , TimeUnit unit ) </a> 0
<a> throws InterruptedException { </a> 0
<a> return await0 ( unit . toNanos ( timeout ) , true ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean await ( long timeoutMillis ) throws InterruptedException { </a> 0
<a> return await0 ( MILLISECONDS . toNanos ( timeoutMillis ) , true ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture awaitUninterruptibly ( ) { </a> 0
<a> boolean interrupted = false ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> while ( ! done ) { </a> 0
<a> checkDeadLock ( ) ; </a> 0
<a> waiters ++ ; </a> 0
<a> try { </a> 0
<a> wait ( ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> interrupted = true ; </a> 0
<a> } finally { </a> 0
<a> waiters -- ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( interrupted ) { </a> 0
<a> Thread . currentThread ( ) . interrupt ( ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitUninterruptibly ( long timeout , TimeUnit unit ) { </a> 0
<a> try { </a> 0
<a> return await0 ( unit . toNanos ( timeout ) , false ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> throw new InternalError ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitUninterruptibly ( long timeoutMillis ) { </a> 0
<a> try { </a> 0
<a> return await0 ( MILLISECONDS . toNanos ( timeoutMillis ) , false ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> throw new InternalError ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean await0 ( long timeoutNanos , boolean interruptable ) throws InterruptedException { </a> 0
<a> if ( interruptable && Thread . interrupted ( ) ) { </a> 0
<a> throw new InterruptedException ( ) ; </a> 0
<a> } </a> 0
<a> long startTime = timeoutNanos <= 0 ? 0 : System . nanoTime ( ) ; </a> 0
<a> long waitTime = timeoutNanos ; </a> 0
<a> boolean interrupted = false ; </a> 0
<a> try { </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( done ) { </a> 0
<a> return done ; </a> 0
<a> } else if ( waitTime <= 0 ) { </a> 0
<a> return done ; </a> 0
<a> } </a> 0
<a> checkDeadLock ( ) ; </a> 0
<a> waiters ++ ; </a> 0
<a> try { </a> 0
<a> for ( ; ; ) { </a> 0
<a> try { </a> 0
<a> wait ( waitTime / 1000000 , ( int ) ( waitTime % 1000000 ) ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> if ( interruptable ) { </a> 0
<a> throw e ; </a> 0
<a> } else { </a> 0
<a> interrupted = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( done ) { </a> 0
<a> return true ; </a> 0
<a> } else { </a> 0
<a> waitTime = timeoutNanos - ( System . nanoTime ( ) - startTime ) ; </a> 0
<a> if ( waitTime <= 0 ) { </a> 0
<a> return done ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> waiters -- ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> if ( interrupted ) { </a> 0
<a> Thread . currentThread ( ) . interrupt ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void checkDeadLock ( ) { </a> 0
<a> if ( channel ( ) . isRegistered ( ) && channel ( ) . eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> throw new BlockingOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean setSuccess ( ) { </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( done ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> done = true ; </a> 0
<a> if ( waiters > 0 ) { </a> 0
<a> notifyAll ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> notifyListeners ( ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean setFailure ( Throwable cause ) { </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( done ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> this . cause = cause ; </a> 0
<a> done = true ; </a> 0
<a> if ( waiters > 0 ) { </a> 0
<a> notifyAll ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> notifyListeners ( ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean cancel ( ) { </a> 0
<a> if ( ! cancellable ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( done ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> cause = CANCELLED ; </a> 0
<a> done = true ; </a> 0
<a> if ( waiters > 0 ) { </a> 0
<a> notifyAll ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> notifyListeners ( ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean cancel ( boolean mayInterruptIfRunning ) { </a> 0
<a> return cancel ( ) ; </a> 0
<a> } </a> 0
<a> private void notifyListeners ( ) { </a> 0
<a> if ( firstListener == null ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( channel ( ) . eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> notifyListener0 ( this , firstListener ) ; </a> 0
<a> firstListener = null ; </a> 0
<a> if ( otherListeners != null ) { </a> 0
<a> for ( ChannelFutureListener l : otherListeners ) { </a> 0
<a> notifyListener0 ( this , l ) ; </a> 0
<a> } </a> 0
<a> otherListeners = null ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> final ChannelFutureListener firstListener = this . firstListener ; </a> 0
<a> final List < ChannelFutureListener > otherListeners = this . otherListeners ; </a> 0
<a> this . firstListener = null ; </a> 0
<a> this . otherListeners = null ; </a> 0
<a> channel ( ) . eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> notifyListener0 ( DefaultChannelFuture . this , firstListener ) ; </a> 0
<a> if ( otherListeners != null ) { </a> 0
<a> for ( ChannelFutureListener l : otherListeners ) { </a> 0
<a> notifyListener0 ( DefaultChannelFuture . this , l ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static void notifyListener ( final ChannelFuture f , final ChannelFutureListener l ) { </a> 0
<a> EventLoop loop = f . channel ( ) . eventLoop ( ) ; </a> 0
<a> if ( loop . inEventLoop ( ) ) { </a> 0
<a> final Integer stackDepth = LISTENER_STACK_DEPTH . get ( ) ; </a> 0
<a> if ( stackDepth < MAX_LISTENER_STACK_DEPTH ) { </a> 0
<a> LISTENER_STACK_DEPTH . set ( stackDepth + 1 ) ; </a> 0
<a> try { </a> 0
<a> notifyListener0 ( f , l ) ; </a> 0
<a> } finally { </a> 0
<a> LISTENER_STACK_DEPTH . set ( stackDepth ) ; </a> 0
<a> } </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> loop . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> notifyListener ( f , l ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> private static void notifyListener0 ( ChannelFuture f , ChannelFutureListener l ) { </a> 0
<a> try { </a> 0
<a> l . operationComplete ( f ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( </a> 0
<a> "An exception was thrown by " + </a> 0
<a> ChannelFutureListener . class . getSimpleName ( ) + "." , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean setProgress ( long amount , long current , long total ) { </a> 0
<a> ChannelFutureProgressListener [ ] plisteners ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( done ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> Collection < ChannelFutureProgressListener > progressListeners = </a> 0
<a> this . progressListeners ; </a> 0
<a> if ( progressListeners == null || progressListeners . isEmpty ( ) ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> plisteners = progressListeners . toArray ( </a> 0
<a> new ChannelFutureProgressListener [ progressListeners . size ( ) ] ) ; </a> 0
<a> } </a> 0
<a> for ( ChannelFutureProgressListener pl : plisteners ) { </a> 0
<a> notifyProgressListener ( pl , amount , current , total ) ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> private void notifyProgressListener ( </a> 0
<a> ChannelFutureProgressListener l , </a> 0
<a> long amount , long current , long total ) { </a> 0
<a> try { </a> 0
<a> l . operationProgressed ( this , amount , current , total ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( </a> 0
<a> "An exception was thrown by " + </a> 0
<a> ChannelFutureProgressListener . class . getSimpleName ( ) + "." , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> long flushCheckpoint ( ) { </a> 0
<a> return flushCheckpoint ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> void flushCheckpoint ( long checkpoint ) { </a> 0
<a> flushCheckpoint = checkpoint ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> ChannelFuture future ( ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import static io . netty . channel . DefaultChannelPipeline . * ; </a> 1
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . ChannelBuf ; </a> 1
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . util . DefaultAttributeMap ; </a> 1
<a> import java . net . SocketAddress ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . EnumSet ; </a> 0
<a> import java . util . Queue ; </a> 1
<a> import java . util . Set ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 1
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 1
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 0
<a> final class DefaultChannelHandlerContext extends DefaultAttributeMap implements ChannelHandlerContext { </a> 1
<a> private static final EnumSet < ChannelHandlerType > EMPTY_TYPE = EnumSet . noneOf ( ChannelHandlerType . class ) ; </a> 0
<a> static final int DIR_INBOUND = 0x00000001 ; </a> 1
<a> static final int DIR_OUTBOUND = 0x80000000 ; </a> 1
<a> volatile DefaultChannelHandlerContext next ; </a> 0
<a> volatile DefaultChannelHandlerContext prev ; </a> 0
<a> private final Channel channel ; </a> 1
<a> private final DefaultChannelPipeline pipeline ; </a> 0
<a> EventExecutor executor ; </a> 1
<a> private final String name ; </a> 0
<a> private final Set < ChannelHandlerType > type ; </a> 0
<a> final int directions ; </a> 1
<a> private final ChannelHandler handler ; </a> 0
<a> final MessageBuf < Object > inMsgBuf ; </a> 0
<a> final ByteBuf inByteBuf ; </a> 0
<a> final MessageBuf < Object > outMsgBuf ; </a> 0
<a> final ByteBuf outByteBuf ; </a> 0
<a> final AtomicReference < MessageBridge > inMsgBridge ; </a> 1
<a> final AtomicReference < MessageBridge > outMsgBridge ; </a> 1
<a> final AtomicReference < ByteBridge > inByteBridge ; </a> 1
<a> final AtomicReference < ByteBridge > outByteBridge ; </a> 1
<a> final AtomicBoolean readable = new AtomicBoolean ( true ) ; </a> 1
<a> final Runnable fireChannelRegisteredTask = new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> DefaultChannelHandlerContext ctx = DefaultChannelHandlerContext . this ; </a> 1
<a> try { </a> 1
<a> ( ( ChannelStateHandler ) ctx . handler ) . channelRegistered ( ctx ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> pipeline . notifyHandlerException ( t ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> final Runnable fireChannelUnregisteredTask = new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> DefaultChannelHandlerContext ctx = DefaultChannelHandlerContext . this ; </a> 1
<a> try { </a> 1
<a> ( ( ChannelStateHandler ) ctx . handler ) . channelUnregistered ( ctx ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> pipeline . notifyHandlerException ( t ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> final Runnable fireChannelActiveTask = new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> DefaultChannelHandlerContext ctx = DefaultChannelHandlerContext . this ; </a> 1
<a> try { </a> 1
<a> ( ( ChannelStateHandler ) ctx . handler ) . channelActive ( ctx ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> pipeline . notifyHandlerException ( t ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> final Runnable fireChannelInactiveTask = new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> DefaultChannelHandlerContext ctx = DefaultChannelHandlerContext . this ; </a> 1
<a> try { </a> 1
<a> ( ( ChannelStateHandler ) ctx . handler ) . channelInactive ( ctx ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> pipeline . notifyHandlerException ( t ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> final Runnable curCtxFireInboundBufferUpdatedTask = new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> DefaultChannelHandlerContext ctx = DefaultChannelHandlerContext . this ; </a> 1
<a> flushBridge ( ) ; </a> 1
<a> try { </a> 1
<a> ( ( ChannelStateHandler ) ctx . handler ) . inboundBufferUpdated ( ctx ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 1
<a> pipeline . notifyHandlerException ( t ) ; </a> 1
<a> } finally { </a> 1
<a> ByteBuf buf = inByteBuf ; </a> 0
<a> if ( buf != null ) { </a> 0
<a> if ( ! buf . readable ( ) ) { </a> 0
<a> buf . discardReadBytes ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> private final Runnable nextCtxFireInboundBufferUpdatedTask = new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> DefaultChannelHandlerContext next = nextContext ( </a> 0
<a> DefaultChannelHandlerContext . this . next , DIR_INBOUND ) ; </a> 1
<a> if ( next != null ) { </a> 1
<a> next . fillBridge ( ) ; </a> 1
<a> EventExecutor executor = next . executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> next . curCtxFireInboundBufferUpdatedTask . run ( ) ; </a> 1
<a> } else { </a> 1
<a> executor . execute ( next . curCtxFireInboundBufferUpdatedTask ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> @ SuppressWarnings ( "unchecked" ) </a> 1
<a> DefaultChannelHandlerContext ( </a> 1
<a> DefaultChannelPipeline pipeline , EventExecutorGroup group , </a> 0
<a> DefaultChannelHandlerContext prev , DefaultChannelHandlerContext next , </a> 0
<a> String name , ChannelHandler handler ) { </a> 1
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> if ( handler == null ) { </a> 0
<a> throw new NullPointerException ( "handler" ) ; </a> 0
<a> } </a> 0
<a> int typeValue = 0 ; </a> 1
<a> EnumSet < ChannelHandlerType > type = EMPTY_TYPE . clone ( ) ; </a> 0
<a> if ( handler instanceof ChannelStateHandler ) { </a> 0
<a> type . add ( ChannelHandlerType . STATE ) ; </a> 0
<a> typeValue |= DIR_INBOUND ; </a> 1
<a> if ( handler instanceof ChannelInboundHandler ) { </a> 0
<a> type . add ( ChannelHandlerType . INBOUND ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( handler instanceof ChannelOperationHandler ) { </a> 0
<a> type . add ( ChannelHandlerType . OPERATION ) ; </a> 0
<a> typeValue |= DIR_OUTBOUND ; </a> 1
<a> if ( handler instanceof ChannelOutboundHandler ) { </a> 0
<a> type . add ( ChannelHandlerType . OUTBOUND ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> this . type = Collections . unmodifiableSet ( type ) ; </a> 0
<a> directions = typeValue ; </a> 1
<a> this . prev = prev ; </a> 0
<a> this . next = next ; </a> 0
<a> channel = pipeline . channel ; </a> 1
<a> this . pipeline = pipeline ; </a> 1
<a> this . name = name ; </a> 1
<a> this . handler = handler ; </a> 1
<a> if ( group != null ) { </a> 1
<a> EventExecutor childExecutor = pipeline . childExecutors . get ( group ) ; </a> 1
<a> if ( childExecutor == null ) { </a> 1
<a> childExecutor = group . next ( ) ; </a> 1
<a> pipeline . childExecutors . put ( group , childExecutor ) ; </a> 1
<a> } </a> 1
<a> executor = childExecutor ; </a> 1
<a> } else if ( channel . isRegistered ( ) ) { </a> 0
<a> executor = channel . eventLoop ( ) ; </a> 0
<a> } else { </a> 0
<a> executor = null ; </a> 1
<a> } </a> 0
<a> if ( type . contains ( ChannelHandlerType . INBOUND ) ) { </a> 1
<a> ChannelBuf buf ; </a> 1
<a> try { </a> 1
<a> buf = ( ( ChannelInboundHandler ) handler ) . newInboundBuffer ( this ) ; </a> 1
<a> } catch ( Exception e ) { </a> 1
<a> throw new ChannelPipelineException ( "A user handler failed to create a new inbound buffer." , e ) ; </a> 0
<a> } </a> 0
<a> if ( buf == null ) { </a> 0
<a> throw new ChannelPipelineException ( "A user handler's newInboundBuffer() returned null" ) ; </a> 0
<a> } </a> 1
<a> if ( buf instanceof ByteBuf ) { </a> 1
<a> inByteBuf = ( ByteBuf ) buf ; </a> 1
<a> inByteBridge = new AtomicReference < ByteBridge > ( ) ; </a> 0
<a> inMsgBuf = null ; </a> 0
<a> inMsgBridge = null ; </a> 0
<a> } else if ( buf instanceof MessageBuf ) { </a> 1
<a> inByteBuf = null ; </a> 0
<a> inByteBridge = null ; </a> 0
<a> inMsgBuf = ( MessageBuf < Object > ) buf ; </a> 1
<a> inMsgBridge = new AtomicReference < MessageBridge > ( ) ; </a> 0
<a> } else { </a> 1
<a> throw new Error ( ) ; </a> 0
<a> } </a> 1
<a> } else { </a> 0
<a> inByteBuf = null ; </a> 1
<a> inByteBridge = null ; </a> 0
<a> inMsgBuf = null ; </a> 1
<a> inMsgBridge = null ; </a> 0
<a> } </a> 1
<a> if ( type . contains ( ChannelHandlerType . OUTBOUND ) ) { </a> 1
<a> ChannelBuf buf ; </a> 1
<a> try { </a> 0
<a> buf = ( ( ChannelOutboundHandler ) handler ) . newOutboundBuffer ( this ) ; </a> 1
<a> } catch ( Exception e ) { </a> 0
<a> throw new ChannelPipelineException ( "A user handler failed to create a new outbound buffer." , e ) ; </a> 0
<a> } </a> 0
<a> if ( buf == null ) { </a> 0
<a> throw new ChannelPipelineException ( "A user handler's newOutboundBuffer() returned null" ) ; </a> 0
<a> } </a> 1
<a> if ( buf instanceof ByteBuf ) { </a> 1
<a> outByteBuf = ( ByteBuf ) buf ; </a> 1
<a> outByteBridge = new AtomicReference < ByteBridge > ( ) ; </a> 0
<a> outMsgBuf = null ; </a> 0
<a> outMsgBridge = null ; </a> 0
<a> } else if ( buf instanceof MessageBuf ) { </a> 0
<a> outByteBuf = null ; </a> 0
<a> outByteBridge = null ; </a> 0
<a> outMsgBuf = ( MessageBuf < Object > ) buf ; </a> 1
<a> outMsgBridge = new AtomicReference < MessageBridge > ( ) ; </a> 0
<a> } else { </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 1
<a> outByteBuf = null ; </a> 1
<a> outByteBridge = null ; </a> 1
<a> outMsgBuf = null ; </a> 1
<a> outMsgBridge = null ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> void fillBridge ( ) { </a> 1
<a> if ( inMsgBridge != null ) { </a> 1
<a> MessageBridge bridge = inMsgBridge . get ( ) ; </a> 0
<a> if ( bridge != null ) { </a> 1
<a> bridge . fill ( ) ; </a> 1
<a> } </a> 1
<a> } else if ( inByteBridge != null ) { </a> 1
<a> ByteBridge bridge = inByteBridge . get ( ) ; </a> 0
<a> if ( bridge != null ) { </a> 1
<a> bridge . fill ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> if ( outMsgBridge != null ) { </a> 1
<a> MessageBridge bridge = outMsgBridge . get ( ) ; </a> 0
<a> if ( bridge != null ) { </a> 1
<a> bridge . fill ( ) ; </a> 1
<a> } </a> 1
<a> } else if ( outByteBridge != null ) { </a> 1
<a> ByteBridge bridge = outByteBridge . get ( ) ; </a> 0
<a> if ( bridge != null ) { </a> 1
<a> bridge . fill ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> void flushBridge ( ) { </a> 1
<a> if ( inMsgBridge != null ) { </a> 1
<a> MessageBridge bridge = inMsgBridge . get ( ) ; </a> 0
<a> if ( bridge != null ) { </a> 1
<a> bridge . flush ( inMsgBuf ) ; </a> 1
<a> } </a> 1
<a> } else if ( inByteBridge != null ) { </a> 1
<a> ByteBridge bridge = inByteBridge . get ( ) ; </a> 0
<a> if ( bridge != null ) { </a> 1
<a> bridge . flush ( inByteBuf ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> if ( outMsgBridge != null ) { </a> 1
<a> MessageBridge bridge = outMsgBridge . get ( ) ; </a> 0
<a> if ( bridge != null ) { </a> 1
<a> bridge . flush ( outMsgBuf ) ; </a> 1
<a> } </a> 1
<a> } else if ( outByteBridge != null ) { </a> 1
<a> ByteBridge bridge = outByteBridge . get ( ) ; </a> 0
<a> if ( bridge != null ) { </a> 1
<a> bridge . flush ( outByteBuf ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public Channel channel ( ) { </a> 0
<a> return channel ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelPipeline pipeline ( ) { </a> 0
<a> return pipeline ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public EventExecutor executor ( ) { </a> 0
<a> if ( executor == null ) { </a> 1
<a> return executor = channel . eventLoop ( ) ; </a> 0
<a> } else { </a> 1
<a> return executor ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelHandler handler ( ) { </a> 0
<a> return handler ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String name ( ) { </a> 0
<a> return name ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Set < ChannelHandlerType > type ( ) { </a> 0
<a> return type ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasInboundByteBuffer ( ) { </a> 1
<a> return inByteBuf != null ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean hasInboundMessageBuffer ( ) { </a> 1
<a> return inMsgBuf != null ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf inboundByteBuffer ( ) { </a> 1
<a> if ( inByteBuf == null ) { </a> 1
<a> if ( handler instanceof ChannelInboundHandler ) { </a> 1
<a> throw new NoSuchBufferException ( String . format ( </a> 0
<a> "the handler '%s' has no inbound byte buffer; it implements %s, but " + </a> 0
<a> "its newInboundBuffer() method created a %s." , </a> 0
<a> name , ChannelInboundHandler . class . getSimpleName ( ) , </a> 0
<a> MessageBuf . class . getSimpleName ( ) ) ) ; </a> 0
<a> } else { </a> 0
<a> throw new NoSuchBufferException ( String . format ( </a> 1
<a> "the handler '%s' has no inbound byte buffer; it does not implement %s." , </a> 1
<a> name , ChannelInboundHandler . class . getSimpleName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> return inByteBuf ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> @ SuppressWarnings ( "unchecked" ) </a> 1
<a> public < T > MessageBuf < T > inboundMessageBuffer ( ) { </a> 1
<a> if ( inMsgBuf == null ) { </a> 1
<a> if ( handler instanceof ChannelInboundHandler ) { </a> 1
<a> throw new NoSuchBufferException ( String . format ( </a> 0
<a> "the handler '%s' has no inbound message buffer; it implements %s, but " + </a> 0
<a> "its newInboundBuffer() method created a %s." , </a> 0
<a> name , ChannelInboundHandler . class . getSimpleName ( ) , </a> 0
<a> ByteBuf . class . getSimpleName ( ) ) ) ; </a> 0
<a> } else { </a> 0
<a> throw new NoSuchBufferException ( String . format ( </a> 1
<a> "the handler '%s' has no inbound message buffer; it does not implement %s." , </a> 1
<a> name , ChannelInboundHandler . class . getSimpleName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> return ( MessageBuf < T > ) inMsgBuf ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean hasOutboundByteBuffer ( ) { </a> 1
<a> return outByteBuf != null ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean hasOutboundMessageBuffer ( ) { </a> 1
<a> return outMsgBuf != null ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf outboundByteBuffer ( ) { </a> 1
<a> if ( outByteBuf == null ) { </a> 1
<a> if ( handler instanceof ChannelOutboundHandler ) { </a> 1
<a> throw new NoSuchBufferException ( String . format ( </a> 0
<a> "the handler '%s' has no outbound byte buffer; it implements %s, but " + </a> 0
<a> "its newOutboundBuffer() method created a %s." , </a> 0
<a> name , ChannelOutboundHandler . class . getSimpleName ( ) , </a> 0
<a> MessageBuf . class . getSimpleName ( ) ) ) ; </a> 0
<a> } else { </a> 0
<a> throw new NoSuchBufferException ( String . format ( </a> 1
<a> "the handler '%s' has no outbound byte buffer; it does not implement %s." , </a> 1
<a> name , ChannelOutboundHandler . class . getSimpleName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> return outByteBuf ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> @ SuppressWarnings ( "unchecked" ) </a> 1
<a> public < T > MessageBuf < T > outboundMessageBuffer ( ) { </a> 1
<a> if ( outMsgBuf == null ) { </a> 1
<a> if ( handler instanceof ChannelOutboundHandler ) { </a> 1
<a> throw new NoSuchBufferException ( String . format ( </a> 0
<a> "the handler '%s' has no outbound message buffer; it implements %s, but " + </a> 0
<a> "its newOutboundBuffer() method created a %s." , </a> 0
<a> name , ChannelOutboundHandler . class . getSimpleName ( ) , </a> 0
<a> ByteBuf . class . getSimpleName ( ) ) ) ; </a> 0
<a> } else { </a> 0
<a> throw new NoSuchBufferException ( String . format ( </a> 1
<a> "the handler '%s' has no outbound message buffer; it does not implement %s." , </a> 1
<a> name , ChannelOutboundHandler . class . getSimpleName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> return ( MessageBuf < T > ) outMsgBuf ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public boolean hasNextInboundByteBuffer ( ) { </a> 0
<a> DefaultChannelHandlerContext ctx = next ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> if ( ctx == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ctx . inByteBridge != null ) { </a> 1
<a> return true ; </a> 0
<a> } </a> 0
<a> ctx = ctx . next ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNextInboundMessageBuffer ( ) { </a> 0
<a> DefaultChannelHandlerContext ctx = next ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> if ( ctx == null ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> if ( ctx . inMsgBridge != null ) { </a> 1
<a> return true ; </a> 0
<a> } </a> 0
<a> ctx = ctx . next ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNextOutboundByteBuffer ( ) { </a> 0
<a> return pipeline . hasNextOutboundByteBuffer ( prev ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNextOutboundMessageBuffer ( ) { </a> 0
<a> return pipeline . hasNextOutboundMessageBuffer ( prev ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ByteBuf nextInboundByteBuffer ( ) { </a> 1
<a> DefaultChannelHandlerContext ctx = next ; </a> 1
<a> final Thread currentThread = Thread . currentThread ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> if ( ctx == null ) { </a> 0
<a> if ( prev != null ) { </a> 0
<a> throw new NoSuchBufferException ( String . format ( </a> 0
<a> "the handler '%s' could not find a %s whose inbound buffer is %s." , </a> 0
<a> name , ChannelInboundHandler . class . getSimpleName ( ) , </a> 0
<a> ByteBuf . class . getSimpleName ( ) ) ) ; </a> 0
<a> } else { </a> 0
<a> throw new NoSuchBufferException ( String . format ( </a> 0
<a> "the pipeline does not contain a %s whose inbound buffer is %s." , </a> 0
<a> ChannelInboundHandler . class . getSimpleName ( ) , </a> 0
<a> ByteBuf . class . getSimpleName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ctx . inByteBuf != null ) { </a> 0
<a> if ( ctx . executor ( ) . inEventLoop ( currentThread ) ) { </a> 0
<a> return ctx . inByteBuf ; </a> 0
<a> } else { </a> 0
<a> ByteBridge bridge = ctx . inByteBridge . get ( ) ; </a> 0
<a> if ( bridge == null ) { </a> 1
<a> bridge = new ByteBridge ( ) ; </a> 1
<a> if ( ! ctx . inByteBridge . compareAndSet ( null , bridge ) ) { </a> 0
<a> bridge = ctx . inByteBridge . get ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> return bridge . byteBuf ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> ctx = ctx . next ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public MessageBuf < Object > nextInboundMessageBuffer ( ) { </a> 1
<a> DefaultChannelHandlerContext ctx = next ; </a> 1
<a> final Thread currentThread = Thread . currentThread ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> if ( ctx == null ) { </a> 0
<a> if ( prev != null ) { </a> 0
<a> throw new NoSuchBufferException ( String . format ( </a> 0
<a> "the handler '%s' could not find a %s whose inbound buffer is %s." , </a> 0
<a> name , ChannelInboundHandler . class . getSimpleName ( ) , </a> 0
<a> MessageBuf . class . getSimpleName ( ) ) ) ; </a> 0
<a> } else { </a> 0
<a> throw new NoSuchBufferException ( String . format ( </a> 0
<a> "the pipeline does not contain a %s whose inbound buffer is %s." , </a> 0
<a> ChannelInboundHandler . class . getSimpleName ( ) , </a> 0
<a> MessageBuf . class . getSimpleName ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ctx . inMsgBuf != null ) { </a> 0
<a> if ( ctx . executor ( ) . inEventLoop ( currentThread ) ) { </a> 0
<a> return ctx . inMsgBuf ; </a> 0
<a> } else { </a> 0
<a> MessageBridge bridge = ctx . inMsgBridge . get ( ) ; </a> 0
<a> if ( bridge == null ) { </a> 1
<a> bridge = new MessageBridge ( ) ; </a> 1
<a> if ( ! ctx . inMsgBridge . compareAndSet ( null , bridge ) ) { </a> 0
<a> bridge = ctx . inMsgBridge . get ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return bridge . msgBuf ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> ctx = ctx . next ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf nextOutboundByteBuffer ( ) { </a> 1
<a> return pipeline . nextOutboundByteBuffer ( prev ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public MessageBuf < Object > nextOutboundMessageBuffer ( ) { </a> 1
<a> return pipeline . nextOutboundMessageBuffer ( prev ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void fireChannelRegistered ( ) { </a> 0
<a> DefaultChannelHandlerContext next = nextContext ( this . next , DIR_INBOUND ) ; </a> 1
<a> if ( next != null ) { </a> 0
<a> EventExecutor executor = next . executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> next . fireChannelRegisteredTask . run ( ) ; </a> 1
<a> } else { </a> 1
<a> executor . execute ( next . fireChannelRegisteredTask ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public void fireChannelUnregistered ( ) { </a> 0
<a> DefaultChannelHandlerContext next = nextContext ( this . next , DIR_INBOUND ) ; </a> 1
<a> if ( next != null ) { </a> 0
<a> EventExecutor executor = next . executor ( ) ; </a> 0
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> next . fireChannelUnregisteredTask . run ( ) ; </a> 1
<a> } else { </a> 0
<a> executor . execute ( next . fireChannelUnregisteredTask ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void fireChannelActive ( ) { </a> 0
<a> DefaultChannelHandlerContext next = nextContext ( this . next , DIR_INBOUND ) ; </a> 1
<a> if ( next != null ) { </a> 0
<a> EventExecutor executor = next . executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> next . fireChannelActiveTask . run ( ) ; </a> 1
<a> } else { </a> 1
<a> executor . execute ( next . fireChannelActiveTask ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public void fireChannelInactive ( ) { </a> 0
<a> DefaultChannelHandlerContext next = nextContext ( this . next , DIR_INBOUND ) ; </a> 1
<a> if ( next != null ) { </a> 0
<a> EventExecutor executor = next . executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> next . fireChannelInactiveTask . run ( ) ; </a> 1
<a> } else { </a> 1
<a> executor . execute ( next . fireChannelInactiveTask ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void fireExceptionCaught ( final Throwable cause ) { </a> 0
<a> if ( cause == null ) { </a> 0
<a> throw new NullPointerException ( "cause" ) ; </a> 0
<a> } </a> 0
<a> DefaultChannelHandlerContext next = this . next ; </a> 1
<a> if ( next != null ) { </a> 0
<a> EventExecutor executor = next . executor ( ) ; </a> 0
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> try { </a> 1
<a> next . handler ( ) . exceptionCaught ( next , cause ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( </a> 0
<a> "An exception was thrown by a user handler's " + </a> 0
<a> "exceptionCaught() method while handling the following exception:" , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } else { </a> 1
<a> try { </a> 1
<a> executor . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 1
<a> fireExceptionCaught ( cause ) ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> if ( logger . isWarnEnabled ( ) ) { </a> 1
<a> logger . warn ( "Failed to submit an exceptionCaught() event." , t ) ; </a> 1
<a> logger . warn ( "The exceptionCaught() event that was failed to submit was:" , cause ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } else { </a> 0
<a> logger . warn ( </a> 0
<a> "An exceptionCaught() event was fired, and it reached at the end of the " + </a> 0
<a> "pipeline. It usually means the last inbound handler in the pipeline did not " + </a> 0
<a> "handle the exception." , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void fireUserEventTriggered ( final Object event ) { </a> 0
<a> if ( event == null ) { </a> 0
<a> throw new NullPointerException ( "event" ) ; </a> 0
<a> } </a> 0
<a> DefaultChannelHandlerContext next = this . next ; </a> 1
<a> if ( next != null ) { </a> 0
<a> EventExecutor executor = next . executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> try { </a> 1
<a> next . handler ( ) . userEventTriggered ( next , event ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> pipeline . notifyHandlerException ( t ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 1
<a> executor . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 1
<a> fireUserEventTriggered ( event ) ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void fireInboundBufferUpdated ( ) { </a> 0
<a> EventExecutor executor = executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 1
<a> nextCtxFireInboundBufferUpdatedTask . run ( ) ; </a> 1
<a> } else { </a> 1
<a> executor . execute ( nextCtxFireInboundBufferUpdatedTask ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> public ChannelFuture bind ( SocketAddress localAddress ) { </a> 0
<a> return bind ( localAddress , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture connect ( SocketAddress remoteAddress ) { </a> 0
<a> return connect ( remoteAddress , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture connect ( SocketAddress remoteAddress , SocketAddress localAddress ) { </a> 0
<a> return connect ( remoteAddress , localAddress , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture disconnect ( ) { </a> 0
<a> return disconnect ( newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture close ( ) { </a> 0
<a> return close ( newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture deregister ( ) { </a> 0
<a> return deregister ( newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture flush ( ) { </a> 1
<a> return flush ( newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture write ( Object message ) { </a> 1
<a> return write ( message , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture bind ( SocketAddress localAddress , ChannelFuture future ) { </a> 0
<a> return pipeline . bind ( nextContext ( prev , DIR_OUTBOUND ) , localAddress , future ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public ChannelFuture connect ( SocketAddress remoteAddress , ChannelFuture future ) { </a> 0
<a> return connect ( remoteAddress , null , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture connect ( SocketAddress remoteAddress , SocketAddress localAddress , ChannelFuture future ) { </a> 0
<a> return pipeline . connect ( nextContext ( prev , DIR_OUTBOUND ) , remoteAddress , localAddress , future ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelFuture disconnect ( ChannelFuture future ) { </a> 0
<a> return pipeline . disconnect ( nextContext ( prev , DIR_OUTBOUND ) , future ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public ChannelFuture close ( ChannelFuture future ) { </a> 0
<a> return pipeline . close ( nextContext ( prev , DIR_OUTBOUND ) , future ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public ChannelFuture deregister ( ChannelFuture future ) { </a> 0
<a> return pipeline . deregister ( nextContext ( prev , DIR_OUTBOUND ) , future ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public ChannelFuture flush ( final ChannelFuture future ) { </a> 0
<a> EventExecutor executor = executor ( ) ; </a> 1
<a> if ( executor . inEventLoop ( ) ) { </a> 0
<a> DefaultChannelHandlerContext prev = nextContext ( this . prev , DIR_OUTBOUND ) ; </a> 1
<a> prev . fillBridge ( ) ; </a> 1
<a> pipeline . flush ( prev , future ) ; </a> 0
<a> } else { </a> 1
<a> executor . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 1
<a> flush ( future ) ; </a> 0
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public ChannelFuture write ( Object message , ChannelFuture future ) { </a> 0
<a> return pipeline . write ( prev , message , future ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public ChannelFuture newFuture ( ) { </a> 0
<a> return channel . newFuture ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture newSucceededFuture ( ) { </a> 0
<a> return channel . newSucceededFuture ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture newFailedFuture ( Throwable cause ) { </a> 0
<a> return channel . newFailedFuture ( cause ) ; </a> 1
<a> } </a> 1
<a> static final class MessageBridge { </a> 1
<a> final MessageBuf < Object > msgBuf = Unpooled . messageBuffer ( ) ; </a> 1
<a> final Queue < Object [ ] > exchangeBuf = new ConcurrentLinkedQueue < Object [ ] > ( ) ; </a> 1
<a> void fill ( ) { </a> 1
<a> if ( msgBuf . isEmpty ( ) ) { </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> Object [ ] data = msgBuf . toArray ( ) ; </a> 1
<a> msgBuf . clear ( ) ; </a> 1
<a> exchangeBuf . add ( data ) ; </a> 1
<a> } </a> 1
<a> void flush ( MessageBuf < Object > out ) { </a> 1
<a> for ( ; ; ) { </a> 1
<a> Object [ ] data = exchangeBuf . poll ( ) ; </a> 1
<a> if ( data == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> Collections . addAll ( out , data ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> } </a> 1
<a> static final class ByteBridge { </a> 1
<a> final ByteBuf byteBuf = Unpooled . buffer ( ) ; </a> 1
<a> final Queue < ByteBuf > exchangeBuf = new ConcurrentLinkedQueue < ByteBuf > ( ) ; </a> 1
<a> void fill ( ) { </a> 1
<a> if ( ! byteBuf . readable ( ) ) { </a> 0
<a> return ; </a> 1
<a> } </a> 1
<a> ByteBuf data = byteBuf . readBytes ( byteBuf . readableBytes ( ) ) ; </a> 1
<a> byteBuf . discardReadBytes ( ) ; </a> 1
<a> exchangeBuf . add ( data ) ; </a> 1
<a> } </a> 1
<a> void flush ( ByteBuf out ) { </a> 1
<a> for ( ; ; ) { </a> 1
<a> ByteBuf data = exchangeBuf . poll ( ) ; </a> 1
<a> if ( data == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> out . writeBytes ( data ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isReadable ( ) { </a> 1
<a> return readable . get ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void readable ( boolean readable ) { </a> 1
<a> pipeline . readable ( this , readable ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 0
<a> class DefaultEventExecutor extends SingleThreadEventExecutor { </a> 0
<a> DefaultEventExecutor ( </a> 1
<a> DefaultEventExecutorGroup parent , ThreadFactory threadFactory , ChannelTaskScheduler scheduler ) { </a> 0
<a> super ( parent , threadFactory , scheduler ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void run ( ) { </a> 0
<a> for ( ; ; ) { </a> 1
<a> Runnable task ; </a> 1
<a> try { </a> 1
<a> task = takeTask ( ) ; </a> 1
<a> task . run ( ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 1
<a> } </a> 0
<a> if ( isShutdown ( ) && peekTask ( ) == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> protected void wakeup ( boolean inEventLoop ) { </a> 0
<a> if ( ! inEventLoop && isShutdown ( ) ) { </a> 0
<a> interruptThread ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 0
<a> public class DefaultEventExecutorGroup extends MultithreadEventExecutorGroup { </a> 0
<a> public DefaultEventExecutorGroup ( int nThreads ) { </a> 1
<a> this ( nThreads , null ) ; </a> 1
<a> } </a> 0
<a> public DefaultEventExecutorGroup ( int nThreads , ThreadFactory threadFactory ) { </a> 1
<a> super ( nThreads , threadFactory ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> protected EventExecutor newChild ( </a> 0
<a> ThreadFactory threadFactory , ChannelTaskScheduler scheduler , Object ... args ) throws Exception { </a> 0
<a> return new DefaultEventExecutor ( this , threadFactory , scheduler ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . concurrent . ScheduledExecutorService ; </a> 0
<a> public interface EventExecutor extends EventExecutorGroup , ScheduledExecutorService { </a> 0
<a> EventExecutorGroup parent ( ) ; </a> 0
<a> boolean inEventLoop ( ) ; </a> 0
<a> boolean inEventLoop ( Thread thread ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . concurrent . ExecutorService ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public interface EventExecutorGroup { </a> 0
<a> EventExecutor next ( ) ; </a> 0
<a> void shutdown ( ) ; </a> 0
<a> boolean isShutdown ( ) ; </a> 0
<a> boolean isTerminated ( ) ; </a> 0
<a> boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public interface EventLoop extends EventExecutor , EventLoopGroup { </a> 0
<a> @ Override </a> 0
<a> EventLoopGroup parent ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public class EventLoopException extends ChannelException { </a> 0
<a> private static final long serialVersionUID = - 8969100344583703616L ; </a> 0
<a> public EventLoopException ( ) { </a> 0
<a> } </a> 0
<a> public EventLoopException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public EventLoopException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public EventLoopException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 1
<a> public abstract class MultithreadEventExecutorGroup implements EventExecutorGroup { </a> 0
<a> private static final int DEFAULT_POOL_SIZE = Runtime . getRuntime ( ) . availableProcessors ( ) * 2 ; </a> 0
<a> private static final AtomicInteger poolId = new AtomicInteger ( ) ; </a> 0
<a> final ChannelTaskScheduler scheduler ; </a> 0
<a> private final EventExecutor [ ] children ; </a> 0
<a> private final AtomicInteger childIndex = new AtomicInteger ( ) ; </a> 0
<a> protected MultithreadEventExecutorGroup ( int nThreads , ThreadFactory threadFactory , Object ... args ) { </a> 1
<a> if ( nThreads < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( String . format ( </a> 0
<a> "nThreads: %d (expected: >= 0)" , nThreads ) ) ; </a> 0
<a> } </a> 0
<a> if ( nThreads == 0 ) { </a> 0
<a> nThreads = DEFAULT_POOL_SIZE ; </a> 0
<a> } </a> 0
<a> if ( threadFactory == null ) { </a> 0
<a> threadFactory = new DefaultThreadFactory ( ) ; </a> 0
<a> } </a> 0
<a> scheduler = new ChannelTaskScheduler ( threadFactory ) ; </a> 0
<a> children = new SingleThreadEventExecutor [ nThreads ] ; </a> 1
<a> for ( int i = 0 ; i < nThreads ; i ++ ) { </a> 1
<a> boolean success = false ; </a> 0
<a> try { </a> 0
<a> children [ i ] = newChild ( threadFactory , scheduler , args ) ; </a> 1
<a> success = true ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new EventLoopException ( "failed to create a child event loop" , e ) ; </a> 0
<a> } finally { </a> 0
<a> if ( ! success ) { </a> 0
<a> for ( int j = 0 ; j < i ; j ++ ) { </a> 0
<a> children [ j ] . shutdown ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public EventExecutor next ( ) { </a> 0
<a> return children [ Math . abs ( childIndex . getAndIncrement ( ) % children . length ) ] ; </a> 0
<a> } </a> 0
<a> protected abstract EventExecutor newChild ( </a> 0
<a> ThreadFactory threadFactory , ChannelTaskScheduler scheduler , Object ... args ) throws Exception ; </a> 0
<a> @ Override </a> 0
<a> public void shutdown ( ) { </a> 0
<a> scheduler . shutdown ( ) ; </a> 1
<a> for ( EventExecutor l : children ) { </a> 0
<a> l . shutdown ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isShutdown ( ) { </a> 0
<a> if ( ! scheduler . isShutdown ( ) ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> for ( EventExecutor l : children ) { </a> 0
<a> if ( ! l . isShutdown ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isTerminated ( ) { </a> 0
<a> if ( ! scheduler . isTerminated ( ) ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> for ( EventExecutor l : children ) { </a> 0
<a> if ( ! l . isTerminated ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitTermination ( long timeout , TimeUnit unit ) </a> 0
<a> throws InterruptedException { </a> 0
<a> long deadline = System . nanoTime ( ) + unit . toNanos ( timeout ) ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> long timeLeft = deadline - System . nanoTime ( ) ; </a> 0
<a> if ( timeLeft <= 0 ) { </a> 0
<a> return isTerminated ( ) ; </a> 1
<a> } </a> 1
<a> if ( scheduler . awaitTermination ( timeLeft , TimeUnit . NANOSECONDS ) ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> loop : for ( EventExecutor l : children ) { </a> 0
<a> for ( ; ; ) { </a> 0
<a> long timeLeft = deadline - System . nanoTime ( ) ; </a> 0
<a> if ( timeLeft <= 0 ) { </a> 0
<a> break loop ; </a> 0
<a> } </a> 0
<a> if ( l . awaitTermination ( timeLeft , TimeUnit . NANOSECONDS ) ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return isTerminated ( ) ; </a> 0
<a> } </a> 0
<a> private final class DefaultThreadFactory implements ThreadFactory { </a> 0
<a> private final AtomicInteger nextId = new AtomicInteger ( ) ; </a> 0
<a> private final String prefix ; </a> 0
<a> DefaultThreadFactory ( ) { </a> 0
<a> String typeName = MultithreadEventExecutorGroup . this . getClass ( ) . getSimpleName ( ) ; </a> 0
<a> typeName = "" + Character . toLowerCase ( typeName . charAt ( 0 ) ) + typeName . substring ( 1 ) ; </a> 0
<a> prefix = typeName + '-' + poolId . incrementAndGet ( ) + '-' ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Thread newThread ( Runnable r ) { </a> 0
<a> Thread t = new Thread ( r , prefix + nextId . incrementAndGet ( ) ) ; </a> 0
<a> try { </a> 0
<a> if ( t . isDaemon ( ) ) { </a> 0
<a> t . setDaemon ( false ) ; </a> 0
<a> } </a> 0
<a> if ( t . getPriority ( ) != Thread . MAX_PRIORITY ) { </a> 0
<a> t . setPriority ( Thread . MAX_PRIORITY ) ; </a> 0
<a> } </a> 0
<a> } catch ( Exception ignored ) { </a> 0
<a> } </a> 0
<a> return t ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> public class NoSuchBufferException extends ChannelPipelineException { </a> 0
<a> private static final long serialVersionUID = - 131650785896627090L ; </a> 0
<a> public NoSuchBufferException ( ) { </a> 0
<a> } </a> 0
<a> public NoSuchBufferException ( String message , Throwable cause ) { </a> 0
<a> super ( message , cause ) ; </a> 0
<a> } </a> 0
<a> public NoSuchBufferException ( String message ) { </a> 0
<a> super ( message ) ; </a> 0
<a> } </a> 0
<a> public NoSuchBufferException ( Throwable cause ) { </a> 0
<a> super ( cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . channel . socket . ServerSocketChannel ; </a> 0
<a> public interface ServerChannel extends Channel { </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collections ; </a> 1
<a> import java . util . LinkedHashSet ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Queue ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . concurrent . AbstractExecutorService ; </a> 0
<a> import java . util . concurrent . BlockingQueue ; </a> 0
<a> import java . util . concurrent . Callable ; </a> 0
<a> import java . util . concurrent . LinkedBlockingQueue ; </a> 0
<a> import java . util . concurrent . RejectedExecutionException ; </a> 0
<a> import java . util . concurrent . ScheduledFuture ; </a> 0
<a> import java . util . concurrent . Semaphore ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public abstract class SingleThreadEventExecutor extends AbstractExecutorService implements EventExecutor { </a> 0
<a> private static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( SingleThreadEventExecutor . class ) ; </a> 0
<a> static final ThreadLocal < SingleThreadEventExecutor > CURRENT_EVENT_LOOP = </a> 0
<a> new ThreadLocal < SingleThreadEventExecutor > ( ) ; </a> 0
<a> public static SingleThreadEventExecutor currentEventLoop ( ) { </a> 0
<a> return CURRENT_EVENT_LOOP . get ( ) ; </a> 0
<a> } </a> 0
<a> private final EventExecutorGroup parent ; </a> 1
<a> private final Queue < Runnable > taskQueue ; </a> 0
<a> private final Thread thread ; </a> 0
<a> private final Object stateLock = new Object ( ) ; </a> 0
<a> private final Semaphore threadLock = new Semaphore ( 0 ) ; </a> 0
<a> private final ChannelTaskScheduler scheduler ; </a> 0
<a> private final Set < Runnable > shutdownHooks = new LinkedHashSet < Runnable > ( ) ; </a> 0
<a> private volatile int state ; </a> 1
<a> protected SingleThreadEventExecutor ( </a> 1
<a> EventExecutorGroup parent , ThreadFactory threadFactory , ChannelTaskScheduler scheduler ) { </a> 0
<a> if ( threadFactory == null ) { </a> 0
<a> throw new NullPointerException ( "threadFactory" ) ; </a> 0
<a> } </a> 0
<a> if ( scheduler == null ) { </a> 0
<a> throw new NullPointerException ( "scheduler" ) ; </a> 0
<a> } </a> 0
<a> this . parent = parent ; </a> 0
<a> this . scheduler = scheduler ; </a> 0
<a> thread = threadFactory . newThread ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> CURRENT_EVENT_LOOP . set ( SingleThreadEventExecutor . this ) ; </a> 0
<a> try { </a> 1
<a> SingleThreadEventExecutor . this . run ( ) ; </a> 1
<a> } finally { </a> 1
<a> try { </a> 1
<a> try { </a> 1
<a> cleanupTasks ( ) ; </a> 1
<a> } finally { </a> 1
<a> synchronized ( stateLock ) { </a> 1
<a> state = 3 ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> cleanupTasks ( ) ; </a> 1
<a> } finally { </a> 1
<a> try { </a> 0
<a> cleanup ( ) ; </a> 0
<a> } finally { </a> 0
<a> threadLock . release ( ) ; </a> 0
<a> assert taskQueue . isEmpty ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private void cleanupTasks ( ) { </a> 1
<a> for ( ; ; ) { </a> 1
<a> boolean ran = false ; </a> 1
<a> ran |= runAllTasks ( ) ; </a> 1
<a> ran |= runShutdownHooks ( ) ; </a> 1
<a> if ( ! ran && ! hasTasks ( ) ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } ) ; </a> 0
<a> taskQueue = newTaskQueue ( ) ; </a> 0
<a> } </a> 0
<a> protected Queue < Runnable > newTaskQueue ( ) { </a> 0
<a> return new LinkedBlockingQueue < Runnable > ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public EventExecutorGroup parent ( ) { </a> 1
<a> return parent ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public EventExecutor next ( ) { </a> 1
<a> return this ; </a> 1
<a> } </a> 1
<a> protected void interruptThread ( ) { </a> 1
<a> thread . interrupt ( ) ; </a> 0
<a> } </a> 1
<a> protected Runnable pollTask ( ) { </a> 0
<a> assert inEventLoop ( ) ; </a> 0
<a> return taskQueue . poll ( ) ; </a> 0
<a> } </a> 0
<a> protected Runnable takeTask ( ) throws InterruptedException { </a> 1
<a> assert inEventLoop ( ) ; </a> 0
<a> if ( taskQueue instanceof BlockingQueue ) { </a> 1
<a> return ( ( BlockingQueue < Runnable > ) taskQueue ) . take ( ) ; </a> 1
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> protected Runnable peekTask ( ) { </a> 0
<a> assert inEventLoop ( ) ; </a> 0
<a> return taskQueue . peek ( ) ; </a> 0
<a> } </a> 0
<a> protected boolean hasTasks ( ) { </a> 0
<a> assert inEventLoop ( ) ; </a> 0
<a> return ! taskQueue . isEmpty ( ) ; </a> 0
<a> } </a> 0
<a> protected void addTask ( Runnable task ) { </a> 0
<a> if ( task == null ) { </a> 0
<a> throw new NullPointerException ( "task" ) ; </a> 0
<a> } </a> 0
<a> if ( isShutdown ( ) ) { </a> 1
<a> reject ( ) ; </a> 0
<a> } </a> 0
<a> taskQueue . add ( task ) ; </a> 0
<a> } </a> 0
<a> protected boolean removeTask ( Runnable task ) { </a> 0
<a> if ( task == null ) { </a> 0
<a> throw new NullPointerException ( "task" ) ; </a> 0
<a> } </a> 0
<a> return taskQueue . remove ( task ) ; </a> 0
<a> } </a> 0
<a> protected boolean runAllTasks ( ) { </a> 0
<a> boolean ran = false ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> final Runnable task = pollTask ( ) ; </a> 0
<a> if ( task == null ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> task . run ( ) ; </a> 0
<a> ran = true ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> logger . warn ( "A task raised an exception." , t ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return ran ; </a> 0
<a> } </a> 0
<a> protected abstract void run ( ) ; </a> 0
<a> protected void cleanup ( ) { </a> 0
<a> } </a> 0
<a> protected abstract void wakeup ( boolean inEventLoop ) ; </a> 1
<a> @ Override </a> 0
<a> public boolean inEventLoop ( ) { </a> 1
<a> return inEventLoop ( Thread . currentThread ( ) ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean inEventLoop ( Thread thread ) { </a> 1
<a> return thread == this . thread ; </a> 0
<a> } </a> 0
<a> public void addShutdownHook ( final Runnable task ) { </a> 0
<a> if ( inEventLoop ( ) ) { </a> 0
<a> shutdownHooks . add ( task ) ; </a> 0
<a> } else { </a> 0
<a> execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> shutdownHooks . add ( task ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public void removeShutdownHook ( final Runnable task ) { </a> 0
<a> if ( inEventLoop ( ) ) { </a> 0
<a> shutdownHooks . remove ( task ) ; </a> 0
<a> } else { </a> 0
<a> execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> shutdownHooks . remove ( task ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean runShutdownHooks ( ) { </a> 0
<a> boolean ran = false ; </a> 0
<a> while ( ! shutdownHooks . isEmpty ( ) ) { </a> 0
<a> List < Runnable > copy = new ArrayList < Runnable > ( shutdownHooks ) ; </a> 0
<a> shutdownHooks . clear ( ) ; </a> 0
<a> for ( Runnable task : copy ) { </a> 0
<a> try { </a> 0
<a> task . run ( ) ; </a> 0
<a> ran = true ; </a> 1
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Shutdown hook raised an exception." , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return ran ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void shutdown ( ) { </a> 0
<a> boolean inEventLoop = inEventLoop ( ) ; </a> 0
<a> boolean wakeup = false ; </a> 1
<a> if ( inEventLoop ) { </a> 0
<a> synchronized ( stateLock ) { </a> 1
<a> assert state == 1 ; </a> 1
<a> state = 2 ; </a> 1
<a> wakeup = true ; </a> 1
<a> } </a> 1
<a> } else { </a> 0
<a> synchronized ( stateLock ) { </a> 1
<a> switch ( state ) { </a> 0
<a> case 0 : </a> 0
<a> state = 3 ; </a> 0
<a> try { </a> 0
<a> cleanup ( ) ; </a> 0
<a> } finally { </a> 0
<a> threadLock . release ( ) ; </a> 0
<a> } </a> 0
<a> break ; </a> 0
<a> case 1 : </a> 1
<a> state = 2 ; </a> 1
<a> wakeup = true ; </a> 1
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( wakeup ) { </a> 0
<a> wakeup ( inEventLoop ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public List < Runnable > shutdownNow ( ) { </a> 0
<a> shutdown ( ) ; </a> 0
<a> return Collections . emptyList ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isShutdown ( ) { </a> 0
<a> return state >= 2 ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isTerminated ( ) { </a> 0
<a> return state == 3 ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { </a> 0
<a> if ( unit == null ) { </a> 0
<a> throw new NullPointerException ( "unit" ) ; </a> 0
<a> } </a> 0
<a> if ( inEventLoop ( ) ) { </a> 0
<a> throw new IllegalStateException ( "cannot await termination of the current thread" ) ; </a> 0
<a> } </a> 0
<a> if ( threadLock . tryAcquire ( timeout , unit ) ) { </a> 0
<a> threadLock . release ( ) ; </a> 0
<a> } </a> 0
<a> return isTerminated ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void execute ( Runnable task ) { </a> 0
<a> if ( task == null ) { </a> 0
<a> throw new NullPointerException ( "task" ) ; </a> 0
<a> } </a> 0
<a> if ( inEventLoop ( ) ) { </a> 1
<a> addTask ( task ) ; </a> 0
<a> wakeup ( true ) ; </a> 1
<a> } else { </a> 0
<a> synchronized ( stateLock ) { </a> 1
<a> if ( state == 0 ) { </a> 1
<a> state = 1 ; </a> 1
<a> thread . start ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> addTask ( task ) ; </a> 1
<a> if ( isShutdown ( ) && removeTask ( task ) ) { </a> 1
<a> reject ( ) ; </a> 1
<a> } </a> 0
<a> wakeup ( false ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private static void reject ( ) { </a> 1
<a> throw new RejectedExecutionException ( "event executor shut down" ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public ScheduledFuture < ? > schedule ( Runnable command , long delay , TimeUnit unit ) { </a> 0
<a> return scheduler . schedule ( this , command , delay , unit ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < V > ScheduledFuture < V > schedule ( Callable < V > callable , long delay , TimeUnit unit ) { </a> 0
<a> return scheduler . schedule ( this , callable , delay , unit ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ScheduledFuture < ? > scheduleAtFixedRate ( Runnable command , long initialDelay , long period , TimeUnit unit ) { </a> 0
<a> return scheduler . scheduleAtFixedRate ( this , command , initialDelay , period , unit ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ScheduledFuture < ? > scheduleWithFixedDelay ( Runnable command , long initialDelay , long delay , TimeUnit unit ) { </a> 0
<a> return scheduler . scheduleWithFixedDelay ( this , command , initialDelay , delay , unit ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 1
<a> public abstract class SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop { </a> 0
<a> protected SingleThreadEventLoop ( </a> 1
<a> EventLoopGroup parent , ThreadFactory threadFactory , ChannelTaskScheduler scheduler ) { </a> 1
<a> super ( parent , threadFactory , scheduler ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public EventLoopGroup parent ( ) { </a> 0
<a> return ( EventLoopGroup ) super . parent ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public EventLoop next ( ) { </a> 0
<a> return ( EventLoop ) super . next ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public ChannelFuture register ( Channel channel ) { </a> 1
<a> if ( channel == null ) { </a> 0
<a> throw new NullPointerException ( "channel" ) ; </a> 0
<a> } </a> 0
<a> return register ( channel , channel . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public ChannelFuture register ( final Channel channel , final ChannelFuture future ) { </a> 1
<a> if ( inEventLoop ( ) ) { </a> 0
<a> channel . unsafe ( ) . register ( this , future ) ; </a> 1
<a> } else { </a> 1
<a> execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> channel . unsafe ( ) . register ( SingleThreadEventLoop . this , future ) ; </a> 0
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> return future ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . nio . channels . Channels ; </a> 0
<a> import java . util . concurrent . ExecutionException ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . TimeoutException ; </a> 0
<a> public class SucceededChannelFuture extends CompleteChannelFuture { </a> 0
<a> public SucceededChannelFuture ( Channel channel ) { </a> 0
<a> super ( channel ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Throwable cause ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isSuccess ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture sync ( ) throws InterruptedException { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture syncUninterruptibly ( ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Void get ( ) throws InterruptedException , ExecutionException { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Void get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , </a> 0
<a> TimeoutException { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import java . util . concurrent . ExecutionException ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . TimeoutException ; </a> 0
<a> public class VoidChannelFuture implements ChannelFuture . Unsafe { </a> 0
<a> private final Channel channel ; </a> 0
<a> public VoidChannelFuture ( Channel channel ) { </a> 0
<a> if ( channel == null ) { </a> 0
<a> throw new NullPointerException ( "channel" ) ; </a> 0
<a> } </a> 0
<a> this . channel = channel ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture addListener ( final ChannelFutureListener listener ) { </a> 0
<a> fail ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture removeListener ( ChannelFutureListener listener ) { </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture await ( ) throws InterruptedException { </a> 0
<a> if ( Thread . interrupted ( ) ) { </a> 0
<a> throw new InterruptedException ( ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean await ( long timeout , TimeUnit unit ) throws InterruptedException { </a> 0
<a> fail ( ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean await ( long timeoutMillis ) throws InterruptedException { </a> 0
<a> fail ( ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture awaitUninterruptibly ( ) { </a> 0
<a> fail ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitUninterruptibly ( long timeout , TimeUnit unit ) { </a> 0
<a> fail ( ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitUninterruptibly ( long timeoutMillis ) { </a> 0
<a> fail ( ) ; </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Channel channel ( ) { </a> 0
<a> return channel ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isDone ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isCancelled ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isSuccess ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Throwable cause ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture sync ( ) throws InterruptedException { </a> 0
<a> fail ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture syncUninterruptibly ( ) { </a> 0
<a> fail ( ) ; </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Void get ( ) throws InterruptedException , ExecutionException { </a> 0
<a> fail ( ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Void get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , </a> 0
<a> TimeoutException { </a> 0
<a> fail ( ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean setProgress ( long amount , long current , long total ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean setFailure ( Throwable cause ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean setSuccess ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean cancel ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean cancel ( boolean mayInterruptIfRunning ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private static void fail ( ) { </a> 0
<a> throw new IllegalStateException ( "void future" ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . embedded ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . ChannelBuf ; </a> 1
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . AbstractChannel ; </a> 1
<a> import io . netty . channel . ChannelConfig ; </a> 1
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 1
<a> import io . netty . channel . ChannelInboundHandler ; </a> 0
<a> import io . netty . channel . ChannelInboundHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelOutboundHandler ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 1
<a> import io . netty . channel . DefaultChannelConfig ; </a> 1
<a> import io . netty . channel . EventLoop ; </a> 1
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . net . SocketAddress ; </a> 1
<a> public abstract class AbstractEmbeddedChannel extends AbstractChannel { </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( AbstractEmbeddedChannel . class ) ; </a> 1
<a> private final ChannelConfig config = new DefaultChannelConfig ( ) ; </a> 0
<a> private final SocketAddress localAddress = new EmbeddedSocketAddress ( ) ; </a> 1
<a> private final SocketAddress remoteAddress = new EmbeddedSocketAddress ( ) ; </a> 1
<a> private final MessageBuf < Object > lastInboundMessageBuffer = Unpooled . messageBuffer ( ) ; </a> 1
<a> private final ByteBuf lastInboundByteBuffer = Unpooled . buffer ( ) ; </a> 1
<a> protected final Object lastOutboundBuffer ; </a> 1
<a> private Throwable lastException ; </a> 1
<a> private int state ; </a> 1
<a> AbstractEmbeddedChannel ( Object lastOutboundBuffer , ChannelHandler ... handlers ) { </a> 1
<a> super ( null , null ) ; </a> 1
<a> if ( handlers == null ) { </a> 0
<a> throw new NullPointerException ( "handlers" ) ; </a> 0
<a> } </a> 0
<a> this . lastOutboundBuffer = lastOutboundBuffer ; </a> 1
<a> int nHandlers = 0 ; </a> 1
<a> boolean hasBuffer = false ; </a> 1
<a> ChannelPipeline p = pipeline ( ) ; </a> 1
<a> for ( ChannelHandler h : handlers ) { </a> 1
<a> if ( h == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> nHandlers ++ ; </a> 1
<a> p . addLast ( h ) ; </a> 0
<a> if ( h instanceof ChannelInboundHandler || h instanceof ChannelOutboundHandler ) { </a> 0
<a> hasBuffer = true ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> if ( nHandlers == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "handlers is empty." ) ; </a> 0
<a> } </a> 0
<a> if ( ! hasBuffer ) { </a> 1
<a> throw new IllegalArgumentException ( "handlers does not provide any buffers." ) ; </a> 0
<a> } </a> 0
<a> p . addLast ( new LastInboundMessageHandler ( ) , new LastInboundByteHandler ( ) ) ; </a> 1
<a> new EmbeddedEventLoop ( ) . register ( this ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelConfig config ( ) { </a> 0
<a> return config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isOpen ( ) { </a> 0
<a> return state < 2 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isActive ( ) { </a> 0
<a> return state == 1 ; </a> 0
<a> } </a> 0
<a> public MessageBuf < Object > lastInboundMessageBuffer ( ) { </a> 1
<a> return lastInboundMessageBuffer ; </a> 1
<a> } </a> 1
<a> public ByteBuf lastInboundByteBuffer ( ) { </a> 1
<a> return lastInboundByteBuffer ; </a> 1
<a> } </a> 1
<a> public Object readInbound ( ) { </a> 1
<a> if ( lastInboundByteBuffer . readable ( ) ) { </a> 0
<a> try { </a> 1
<a> return lastInboundByteBuffer . readBytes ( lastInboundByteBuffer . readableBytes ( ) ) ; </a> 1
<a> } finally { </a> 1
<a> lastInboundByteBuffer . clear ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> return lastInboundMessageBuffer . poll ( ) ; </a> 1
<a> } </a> 1
<a> public void checkException ( ) { </a> 1
<a> Throwable t = lastException ; </a> 1
<a> if ( t == null ) { </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> lastException = null ; </a> 1
<a> if ( t instanceof RuntimeException ) { </a> 0
<a> throw ( RuntimeException ) t ; </a> 0
<a> } </a> 0
<a> if ( t instanceof Error ) { </a> 0
<a> throw ( Error ) t ; </a> 0
<a> } </a> 0
<a> throw new ChannelException ( t ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> protected boolean isCompatible ( EventLoop loop ) { </a> 0
<a> return loop instanceof EmbeddedEventLoop ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress localAddress0 ( ) { </a> 0
<a> return isActive ( ) ? localAddress : null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress remoteAddress0 ( ) { </a> 0
<a> return isActive ( ) ? remoteAddress : null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected Runnable doRegister ( ) throws Exception { </a> 0
<a> state = 1 ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doBind ( SocketAddress localAddress ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDisconnect ( ) throws Exception { </a> 0
<a> doClose ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doClose ( ) throws Exception { </a> 0
<a> state = 2 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDeregister ( ) throws Exception { </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected Unsafe newUnsafe ( ) { </a> 0
<a> return new DefaultUnsafe ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isFlushPending ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private class DefaultUnsafe extends AbstractUnsafe { </a> 0
<a> @ Override </a> 0
<a> public void connect ( SocketAddress remoteAddress , </a> 0
<a> SocketAddress localAddress , ChannelFuture future ) { </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void suspendRead ( ) { </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void resumeRead ( ) { </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private final class LastInboundMessageHandler extends ChannelInboundHandlerAdapter { </a> 0
<a> @ Override </a> 1
<a> public ChannelBuf newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return lastInboundMessageBuffer ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) </a> 1
<a> throws Exception { </a> 1
<a> if ( lastException == null ) { </a> 1
<a> lastException = cause ; </a> 1
<a> } else { </a> 1
<a> logger . warn ( </a> 1
<a> "More than one exception was raised. " + </a> 1
<a> "Will report only the first one and log others." , cause ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private final class LastInboundByteHandler extends ChannelInboundHandlerAdapter { </a> 0
<a> @ Override </a> 1
<a> public ChannelBuf newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return lastInboundByteBuffer ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . embedded ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . ChannelBufType ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelHandler ; </a> 1
<a> import io . netty . channel . ChannelMetadata ; </a> 0
<a> public class EmbeddedByteChannel extends AbstractEmbeddedChannel { </a> 0
<a> private static final ChannelMetadata METADATA = new ChannelMetadata ( ChannelBufType . BYTE , false ) ; </a> 0
<a> public EmbeddedByteChannel ( ChannelHandler ... handlers ) { </a> 1
<a> super ( Unpooled . buffer ( ) , handlers ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelMetadata metadata ( ) { </a> 0
<a> return METADATA ; </a> 0
<a> } </a> 1
<a> public ByteBuf inboundBuffer ( ) { </a> 1
<a> return pipeline ( ) . inboundByteBuffer ( ) ; </a> 1
<a> } </a> 1
<a> public ByteBuf lastOutboundBuffer ( ) { </a> 1
<a> return ( ByteBuf ) lastOutboundBuffer ; </a> 1
<a> } </a> 1
<a> public ByteBuf readOutbound ( ) { </a> 1
<a> if ( ! lastOutboundBuffer ( ) . readable ( ) ) { </a> 0
<a> return null ; </a> 1
<a> } </a> 1
<a> try { </a> 1
<a> return lastOutboundBuffer ( ) . readBytes ( lastOutboundBuffer ( ) . readableBytes ( ) ) ; </a> 1
<a> } finally { </a> 1
<a> lastOutboundBuffer ( ) . clear ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public boolean writeInbound ( ByteBuf data ) { </a> 0
<a> inboundBuffer ( ) . writeBytes ( data ) ; </a> 1
<a> pipeline ( ) . fireInboundBufferUpdated ( ) ; </a> 0
<a> checkException ( ) ; </a> 0
<a> return lastInboundByteBuffer ( ) . readable ( ) || ! lastInboundMessageBuffer ( ) . isEmpty ( ) ; </a> 0
<a> } </a> 1
<a> public boolean writeOutbound ( Object msg ) { </a> 0
<a> write ( msg ) ; </a> 0
<a> checkException ( ) ; </a> 0
<a> return lastOutboundBuffer ( ) . readable ( ) ; </a> 0
<a> } </a> 1
<a> public boolean finish ( ) { </a> 0
<a> close ( ) ; </a> 0
<a> checkException ( ) ; </a> 0
<a> return lastInboundByteBuffer ( ) . readable ( ) || ! lastInboundMessageBuffer ( ) . isEmpty ( ) || </a> 0
<a> lastOutboundBuffer ( ) . readable ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> protected void doFlushByteBuffer ( ByteBuf buf ) throws Exception { </a> 1
<a> if ( ! lastOutboundBuffer ( ) . readable ( ) ) { </a> 0
<a> lastOutboundBuffer ( ) . discardReadBytes ( ) ; </a> 0
<a> } </a> 0
<a> lastOutboundBuffer ( ) . writeBytes ( buf ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . embedded ; </a> 0
<a> import io . netty . channel . Channel ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 1
<a> import io . netty . channel . EventLoop ; </a> 1
<a> import io . netty . channel . EventLoopGroup ; </a> 1
<a> import java . util . Collections ; </a> 1
<a> import java . util . List ; </a> 1
<a> import java . util . concurrent . AbstractExecutorService ; </a> 0
<a> import java . util . concurrent . Callable ; </a> 0
<a> import java . util . concurrent . ScheduledFuture ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> class EmbeddedEventLoop extends AbstractExecutorService implements EventLoop { </a> 1
<a> @ Override </a> 0
<a> public ScheduledFuture < ? > schedule ( Runnable command , long delay , </a> 0
<a> TimeUnit unit ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < V > ScheduledFuture < V > schedule ( Callable < V > callable , long delay , </a> 0
<a> TimeUnit unit ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ScheduledFuture < ? > scheduleAtFixedRate ( Runnable command , </a> 0
<a> long initialDelay , long period , TimeUnit unit ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ScheduledFuture < ? > scheduleWithFixedDelay ( Runnable command , </a> 0
<a> long initialDelay , long delay , TimeUnit unit ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void shutdown ( ) { </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> public List < Runnable > shutdownNow ( ) { </a> 1
<a> return Collections . emptyList ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isShutdown ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isTerminated ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitTermination ( long timeout , TimeUnit unit ) </a> 1
<a> throws InterruptedException { </a> 1
<a> Thread . sleep ( unit . toMillis ( timeout ) ) ; </a> 1
<a> return false ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void execute ( Runnable command ) { </a> 1
<a> command . run ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelFuture register ( Channel channel ) { </a> 0
<a> return register ( channel , channel . newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture register ( Channel channel , ChannelFuture future ) { </a> 0
<a> channel . unsafe ( ) . register ( this , future ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean inEventLoop ( ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean inEventLoop ( Thread thread ) { </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public EventLoop next ( ) { </a> 1
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public EventLoopGroup parent ( ) { </a> 1
<a> return this ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . embedded ; </a> 0
<a> import io . netty . buffer . ChannelBufType ; </a> 1
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . ChannelHandler ; </a> 1
<a> import io . netty . channel . ChannelMetadata ; </a> 0
<a> public class EmbeddedMessageChannel extends AbstractEmbeddedChannel { </a> 0
<a> private static final ChannelMetadata METADATA = new ChannelMetadata ( ChannelBufType . MESSAGE , false ) ; </a> 0
<a> public EmbeddedMessageChannel ( ChannelHandler ... handlers ) { </a> 1
<a> super ( Unpooled . messageBuffer ( ) , handlers ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelMetadata metadata ( ) { </a> 0
<a> return METADATA ; </a> 0
<a> } </a> 1
<a> public MessageBuf < Object > inboundBuffer ( ) { </a> 1
<a> return pipeline ( ) . inboundMessageBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ SuppressWarnings ( "unchecked" ) </a> 1
<a> public MessageBuf < Object > lastOutboundBuffer ( ) { </a> 1
<a> return ( MessageBuf < Object > ) lastOutboundBuffer ; </a> 1
<a> } </a> 1
<a> public Object readOutbound ( ) { </a> 1
<a> return lastOutboundBuffer ( ) . poll ( ) ; </a> 1
<a> } </a> 1
<a> public boolean writeInbound ( Object msg ) { </a> 0
<a> inboundBuffer ( ) . add ( msg ) ; </a> 0
<a> pipeline ( ) . fireInboundBufferUpdated ( ) ; </a> 1
<a> checkException ( ) ; </a> 1
<a> return lastInboundByteBuffer ( ) . readable ( ) || ! lastInboundMessageBuffer ( ) . isEmpty ( ) ; </a> 0
<a> } </a> 1
<a> public boolean writeOutbound ( Object msg ) { </a> 0
<a> write ( msg ) ; </a> 0
<a> checkException ( ) ; </a> 0
<a> return ! lastOutboundBuffer ( ) . isEmpty ( ) ; </a> 1
<a> } </a> 1
<a> public boolean finish ( ) { </a> 1
<a> close ( ) ; </a> 1
<a> checkException ( ) ; </a> 1
<a> return lastInboundByteBuffer ( ) . readable ( ) || ! lastInboundMessageBuffer ( ) . isEmpty ( ) || </a> 0
<a> ! lastOutboundBuffer ( ) . isEmpty ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> protected void doFlushMessageBuffer ( MessageBuf < Object > buf ) throws Exception { </a> 1
<a> buf . drainTo ( lastOutboundBuffer ( ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . embedded ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> class EmbeddedSocketAddress extends SocketAddress { </a> 0
<a> private static final long serialVersionUID = 1400788804624980619L ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . embedded ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . group ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ServerChannel ; </a> 0
<a> import io . netty . util . CharsetUtil ; </a> 0
<a> import java . util . Set ; </a> 0
<a> public interface ChannelGroup extends Set < Channel > , Comparable < ChannelGroup > { </a> 0
<a> String name ( ) ; </a> 0
<a> Channel find ( Integer id ) ; </a> 1
<a> ChannelGroupFuture write ( Object message ) ; </a> 0
<a> ChannelGroupFuture disconnect ( ) ; </a> 0
<a> ChannelGroupFuture close ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . group ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelHandler ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public interface ChannelGroupFuture extends Iterable < ChannelFuture > { </a> 0
<a> ChannelGroup getGroup ( ) ; </a> 0
<a> ChannelFuture find ( Integer channelId ) ; </a> 1
<a> ChannelFuture find ( Channel channel ) ; </a> 0
<a> boolean isDone ( ) ; </a> 0
<a> boolean isCompleteSuccess ( ) ; </a> 0
<a> boolean isPartialSuccess ( ) ; </a> 0
<a> boolean isCompleteFailure ( ) ; </a> 0
<a> boolean isPartialFailure ( ) ; </a> 0
<a> void addListener ( ChannelGroupFutureListener listener ) ; </a> 0
<a> void removeListener ( ChannelGroupFutureListener listener ) ; </a> 0
<a> ChannelGroupFuture await ( ) throws InterruptedException ; </a> 0
<a> ChannelGroupFuture awaitUninterruptibly ( ) ; </a> 0
<a> boolean await ( long timeout , TimeUnit unit ) throws InterruptedException ; </a> 0
<a> boolean await ( long timeoutMillis ) throws InterruptedException ; </a> 0
<a> boolean awaitUninterruptibly ( long timeout , TimeUnit unit ) ; </a> 0
<a> boolean awaitUninterruptibly ( long timeoutMillis ) ; </a> 0
<a> @ Override </a> 0
<a> Iterator < ChannelFuture > iterator ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . group ; </a> 0
<a> import java . util . EventListener ; </a> 0
<a> public interface ChannelGroupFutureListener extends EventListener { </a> 0
<a> void operationComplete ( ChannelGroupFuture future ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . group ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . NoSuchElementException ; </a> 0
<a> final class CombinedIterator < E > implements Iterator < E > { </a> 0
<a> private final Iterator < E > i1 ; </a> 0
<a> private final Iterator < E > i2 ; </a> 0
<a> private Iterator < E > currentIterator ; </a> 0
<a> CombinedIterator ( Iterator < E > i1 , Iterator < E > i2 ) { </a> 0
<a> if ( i1 == null ) { </a> 0
<a> throw new NullPointerException ( "i1" ) ; </a> 0
<a> } </a> 0
<a> if ( i2 == null ) { </a> 0
<a> throw new NullPointerException ( "i2" ) ; </a> 0
<a> } </a> 0
<a> this . i1 = i1 ; </a> 0
<a> this . i2 = i2 ; </a> 0
<a> currentIterator = i1 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean hasNext ( ) { </a> 0
<a> boolean hasNext = currentIterator . hasNext ( ) ; </a> 1
<a> if ( hasNext ) { </a> 1
<a> return true ; </a> 0
<a> } </a> 0
<a> if ( currentIterator == i1 ) { </a> 0
<a> currentIterator = i2 ; </a> 0
<a> return hasNext ( ) ; </a> 1
<a> } else { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public E next ( ) { </a> 0
<a> try { </a> 0
<a> return currentIterator . next ( ) ; </a> 0
<a> } catch ( NoSuchElementException e ) { </a> 0
<a> if ( currentIterator == i1 ) { </a> 0
<a> currentIterator = i2 ; </a> 0
<a> return next ( ) ; </a> 1
<a> } else { </a> 0
<a> throw e ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void remove ( ) { </a> 0
<a> currentIterator . remove ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . group ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . channel . ServerChannel ; </a> 0
<a> import java . util . AbstractSet ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . LinkedHashMap ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import java . util . concurrent . ConcurrentMap ; </a> 1
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> public class DefaultChannelGroup extends AbstractSet < Channel > implements ChannelGroup { </a> 0
<a> private static final AtomicInteger nextId = new AtomicInteger ( ) ; </a> 0
<a> private final String name ; </a> 0
<a> private final ConcurrentMap < Integer , Channel > serverChannels = new ConcurrentHashMap < Integer , Channel > ( ) ; </a> 1
<a> private final ConcurrentMap < Integer , Channel > nonServerChannels = new ConcurrentHashMap < Integer , Channel > ( ) ; </a> 1
<a> private final ChannelFutureListener remover = new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 0
<a> remove ( future . channel ( ) ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> public DefaultChannelGroup ( ) { </a> 1
<a> this ( "group-0x" + Integer . toHexString ( nextId . incrementAndGet ( ) ) ) ; </a> 1
<a> } </a> 1
<a> public DefaultChannelGroup ( String name ) { </a> 1
<a> if ( name == null ) { </a> 0
<a> throw new NullPointerException ( "name" ) ; </a> 0
<a> } </a> 0
<a> this . name = name ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String name ( ) { </a> 0
<a> return name ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isEmpty ( ) { </a> 0
<a> return nonServerChannels . isEmpty ( ) && serverChannels . isEmpty ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int size ( ) { </a> 0
<a> return nonServerChannels . size ( ) + serverChannels . size ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Channel find ( Integer id ) { </a> 1
<a> Channel c = nonServerChannels . get ( id ) ; </a> 1
<a> if ( c != null ) { </a> 1
<a> return c ; </a> 1
<a> } else { </a> 1
<a> return serverChannels . get ( id ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean contains ( Object o ) { </a> 0
<a> if ( o instanceof Integer ) { </a> 1
<a> return nonServerChannels . containsKey ( o ) || serverChannels . containsKey ( o ) ; </a> 1
<a> } else if ( o instanceof Channel ) { </a> 1
<a> Channel c = ( Channel ) o ; </a> 0
<a> if ( o instanceof ServerChannel ) { </a> 0
<a> return serverChannels . containsKey ( c . id ( ) ) ; </a> 1
<a> } else { </a> 0
<a> return nonServerChannels . containsKey ( c . id ( ) ) ; </a> 1
<a> } </a> 0
<a> } else { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean add ( Channel channel ) { </a> 0
<a> ConcurrentMap < Integer , Channel > map = </a> 1
<a> channel instanceof ServerChannel ? serverChannels : nonServerChannels ; </a> 0
<a> boolean added = map . putIfAbsent ( channel . id ( ) , channel ) == null ; </a> 1
<a> if ( added ) { </a> 0
<a> channel . closeFuture ( ) . addListener ( remover ) ; </a> 0
<a> } </a> 0
<a> return added ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean remove ( Object o ) { </a> 0
<a> Channel c = null ; </a> 1
<a> if ( o instanceof Integer ) { </a> 1
<a> c = nonServerChannels . remove ( o ) ; </a> 1
<a> if ( c == null ) { </a> 1
<a> c = serverChannels . remove ( o ) ; </a> 1
<a> } </a> 1
<a> } else if ( o instanceof Channel ) { </a> 1
<a> c = ( Channel ) o ; </a> 1
<a> if ( c instanceof ServerChannel ) { </a> 0
<a> c = serverChannels . remove ( c . id ( ) ) ; </a> 1
<a> } else { </a> 0
<a> c = nonServerChannels . remove ( c . id ( ) ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> if ( c == null ) { </a> 1
<a> return false ; </a> 0
<a> } </a> 0
<a> c . closeFuture ( ) . removeListener ( remover ) ; </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void clear ( ) { </a> 0
<a> nonServerChannels . clear ( ) ; </a> 0
<a> serverChannels . clear ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Iterator < Channel > iterator ( ) { </a> 0
<a> return new CombinedIterator < Channel > ( </a> 0
<a> serverChannels . values ( ) . iterator ( ) , </a> 1
<a> nonServerChannels . values ( ) . iterator ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Object [ ] toArray ( ) { </a> 0
<a> Collection < Channel > channels = new ArrayList < Channel > ( size ( ) ) ; </a> 0
<a> channels . addAll ( serverChannels . values ( ) ) ; </a> 1
<a> channels . addAll ( nonServerChannels . values ( ) ) ; </a> 1
<a> return channels . toArray ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > T [ ] toArray ( T [ ] a ) { </a> 0
<a> Collection < Channel > channels = new ArrayList < Channel > ( size ( ) ) ; </a> 0
<a> channels . addAll ( serverChannels . values ( ) ) ; </a> 1
<a> channels . addAll ( nonServerChannels . values ( ) ) ; </a> 1
<a> return channels . toArray ( a ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelGroupFuture close ( ) { </a> 0
<a> Map < Integer , ChannelFuture > futures = </a> 1
<a> new LinkedHashMap < Integer , ChannelFuture > ( size ( ) ) ; </a> 1
<a> for ( Channel c : serverChannels . values ( ) ) { </a> 1
<a> futures . put ( c . id ( ) , c . close ( ) . awaitUninterruptibly ( ) ) ; </a> 1
<a> } </a> 0
<a> for ( Channel c : nonServerChannels . values ( ) ) { </a> 1
<a> futures . put ( c . id ( ) , c . close ( ) ) ; </a> 1
<a> } </a> 0
<a> return new DefaultChannelGroupFuture ( this , futures ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelGroupFuture disconnect ( ) { </a> 0
<a> Map < Integer , ChannelFuture > futures = </a> 1
<a> new LinkedHashMap < Integer , ChannelFuture > ( size ( ) ) ; </a> 1
<a> for ( Channel c : serverChannels . values ( ) ) { </a> 1
<a> futures . put ( c . id ( ) , c . disconnect ( ) ) ; </a> 1
<a> } </a> 0
<a> for ( Channel c : nonServerChannels . values ( ) ) { </a> 1
<a> futures . put ( c . id ( ) , c . disconnect ( ) ) ; </a> 1
<a> } </a> 0
<a> return new DefaultChannelGroupFuture ( this , futures ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelGroupFuture write ( Object message ) { </a> 0
<a> Map < Integer , ChannelFuture > futures = </a> 0
<a> new LinkedHashMap < Integer , ChannelFuture > ( size ( ) ) ; </a> 0
<a> if ( message instanceof ByteBuf ) { </a> 0
<a> ByteBuf buf = ( ByteBuf ) message ; </a> 0
<a> for ( Channel c : nonServerChannels . values ( ) ) { </a> 0
<a> futures . put ( c . id ( ) , c . write ( buf . duplicate ( ) ) ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> for ( Channel c : nonServerChannels . values ( ) ) { </a> 1
<a> futures . put ( c . id ( ) , c . write ( message ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return new DefaultChannelGroupFuture ( this , futures ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return System . identityHashCode ( this ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object o ) { </a> 0
<a> return this == o ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( ChannelGroup o ) { </a> 0
<a> int v = name ( ) . compareTo ( o . name ( ) ) ; </a> 0
<a> if ( v != 0 ) { </a> 0
<a> return v ; </a> 0
<a> } </a> 0
<a> return System . identityHashCode ( this ) - System . identityHashCode ( o ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return getClass ( ) . getSimpleName ( ) + </a> 0
<a> "(name: " + name ( ) + ", size: " + size ( ) + ')' ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . group ; </a> 0
<a> import static java . util . concurrent . TimeUnit . * ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelFutureListener ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . Collections ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . LinkedHashMap ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public class DefaultChannelGroupFuture implements ChannelGroupFuture { </a> 0
<a> private static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( DefaultChannelGroupFuture . class ) ; </a> 0
<a> private final ChannelGroup group ; </a> 0
<a> final Map < Integer , ChannelFuture > futures ; </a> 0
<a> private ChannelGroupFutureListener firstListener ; </a> 0
<a> private List < ChannelGroupFutureListener > otherListeners ; </a> 0
<a> private boolean done ; </a> 0
<a> int successCount ; </a> 0
<a> int failureCount ; </a> 0
<a> private int waiters ; </a> 0
<a> private final ChannelFutureListener childListener = new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 0
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 0
<a> boolean success = future . isSuccess ( ) ; </a> 0
<a> boolean callSetDone ; </a> 0
<a> synchronized ( DefaultChannelGroupFuture . this ) { </a> 0
<a> if ( success ) { </a> 0
<a> successCount ++ ; </a> 0
<a> } else { </a> 0
<a> failureCount ++ ; </a> 0
<a> } </a> 0
<a> callSetDone = successCount + failureCount == futures . size ( ) ; </a> 0
<a> assert successCount + failureCount <= futures . size ( ) ; </a> 0
<a> } </a> 0
<a> if ( callSetDone ) { </a> 0
<a> setDone ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> public DefaultChannelGroupFuture ( ChannelGroup group , Collection < ChannelFuture > futures ) { </a> 0
<a> if ( group == null ) { </a> 0
<a> throw new NullPointerException ( "group" ) ; </a> 0
<a> } </a> 0
<a> if ( futures == null ) { </a> 0
<a> throw new NullPointerException ( "futures" ) ; </a> 0
<a> } </a> 0
<a> this . group = group ; </a> 0
<a> Map < Integer , ChannelFuture > futureMap = new LinkedHashMap < Integer , ChannelFuture > ( ) ; </a> 1
<a> for ( ChannelFuture f : futures ) { </a> 0
<a> futureMap . put ( f . channel ( ) . id ( ) , f ) ; </a> 1
<a> } </a> 0
<a> this . futures = Collections . unmodifiableMap ( futureMap ) ; </a> 0
<a> for ( ChannelFuture f : this . futures . values ( ) ) { </a> 0
<a> f . addListener ( childListener ) ; </a> 0
<a> } </a> 0
<a> if ( this . futures . isEmpty ( ) ) { </a> 0
<a> setDone ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> DefaultChannelGroupFuture ( ChannelGroup group , Map < Integer , ChannelFuture > futures ) { </a> 0
<a> this . group = group ; </a> 0
<a> this . futures = Collections . unmodifiableMap ( futures ) ; </a> 0
<a> for ( ChannelFuture f : this . futures . values ( ) ) { </a> 0
<a> f . addListener ( childListener ) ; </a> 0
<a> } </a> 0
<a> if ( this . futures . isEmpty ( ) ) { </a> 0
<a> setDone ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelGroup getGroup ( ) { </a> 0
<a> return group ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture find ( Integer channelId ) { </a> 1
<a> return futures . get ( channelId ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelFuture find ( Channel channel ) { </a> 0
<a> return futures . get ( channel . id ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public Iterator < ChannelFuture > iterator ( ) { </a> 0
<a> return futures . values ( ) . iterator ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized boolean isDone ( ) { </a> 0
<a> return done ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized boolean isCompleteSuccess ( ) { </a> 0
<a> return successCount == futures . size ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized boolean isPartialSuccess ( ) { </a> 0
<a> return successCount != 0 && successCount != futures . size ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized boolean isPartialFailure ( ) { </a> 0
<a> return failureCount != 0 && failureCount != futures . size ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public synchronized boolean isCompleteFailure ( ) { </a> 0
<a> int futureCnt = futures . size ( ) ; </a> 0
<a> return futureCnt != 0 && failureCount == futureCnt ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void addListener ( ChannelGroupFutureListener listener ) { </a> 0
<a> if ( listener == null ) { </a> 0
<a> throw new NullPointerException ( "listener" ) ; </a> 0
<a> } </a> 0
<a> boolean notifyNow = false ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( done ) { </a> 0
<a> notifyNow = true ; </a> 0
<a> } else { </a> 0
<a> if ( firstListener == null ) { </a> 0
<a> firstListener = listener ; </a> 0
<a> } else { </a> 0
<a> if ( otherListeners == null ) { </a> 0
<a> otherListeners = new ArrayList < ChannelGroupFutureListener > ( 1 ) ; </a> 0
<a> } </a> 0
<a> otherListeners . add ( listener ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( notifyNow ) { </a> 0
<a> notifyListener ( listener ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void removeListener ( ChannelGroupFutureListener listener ) { </a> 0
<a> if ( listener == null ) { </a> 0
<a> throw new NullPointerException ( "listener" ) ; </a> 0
<a> } </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( ! done ) { </a> 0
<a> if ( listener == firstListener ) { </a> 0
<a> if ( otherListeners != null && ! otherListeners . isEmpty ( ) ) { </a> 0
<a> firstListener = otherListeners . remove ( 0 ) ; </a> 0
<a> } else { </a> 0
<a> firstListener = null ; </a> 0
<a> } </a> 0
<a> } else if ( otherListeners != null ) { </a> 0
<a> otherListeners . remove ( listener ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelGroupFuture await ( ) throws InterruptedException { </a> 0
<a> if ( Thread . interrupted ( ) ) { </a> 0
<a> throw new InterruptedException ( ) ; </a> 0
<a> } </a> 0
<a> synchronized ( this ) { </a> 0
<a> while ( ! done ) { </a> 0
<a> waiters ++ ; </a> 0
<a> try { </a> 0
<a> wait ( ) ; </a> 0
<a> } finally { </a> 0
<a> waiters -- ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean await ( long timeout , TimeUnit unit ) </a> 0
<a> throws InterruptedException { </a> 0
<a> return await0 ( unit . toNanos ( timeout ) , true ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean await ( long timeoutMillis ) throws InterruptedException { </a> 0
<a> return await0 ( MILLISECONDS . toNanos ( timeoutMillis ) , true ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelGroupFuture awaitUninterruptibly ( ) { </a> 0
<a> boolean interrupted = false ; </a> 0
<a> synchronized ( this ) { </a> 0
<a> while ( ! done ) { </a> 0
<a> waiters ++ ; </a> 0
<a> try { </a> 0
<a> wait ( ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> interrupted = true ; </a> 0
<a> } finally { </a> 0
<a> waiters -- ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( interrupted ) { </a> 0
<a> Thread . currentThread ( ) . interrupt ( ) ; </a> 0
<a> } </a> 0
<a> return this ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitUninterruptibly ( long timeout , TimeUnit unit ) { </a> 0
<a> try { </a> 0
<a> return await0 ( unit . toNanos ( timeout ) , false ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> throw new InternalError ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitUninterruptibly ( long timeoutMillis ) { </a> 0
<a> try { </a> 0
<a> return await0 ( MILLISECONDS . toNanos ( timeoutMillis ) , false ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> throw new InternalError ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private boolean await0 ( long timeoutNanos , boolean interruptable ) throws InterruptedException { </a> 0
<a> if ( interruptable && Thread . interrupted ( ) ) { </a> 0
<a> throw new InterruptedException ( ) ; </a> 0
<a> } </a> 0
<a> long startTime = timeoutNanos <= 0 ? 0 : System . nanoTime ( ) ; </a> 0
<a> long waitTime = timeoutNanos ; </a> 0
<a> boolean interrupted = false ; </a> 0
<a> try { </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( done ) { </a> 0
<a> return done ; </a> 0
<a> } else if ( waitTime <= 0 ) { </a> 0
<a> return done ; </a> 0
<a> } </a> 0
<a> waiters ++ ; </a> 0
<a> try { </a> 0
<a> for ( ; ; ) { </a> 0
<a> try { </a> 0
<a> wait ( waitTime / 1000000 , ( int ) ( waitTime % 1000000 ) ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> if ( interruptable ) { </a> 0
<a> throw e ; </a> 0
<a> } else { </a> 0
<a> interrupted = true ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( done ) { </a> 0
<a> return true ; </a> 0
<a> } else { </a> 0
<a> waitTime = timeoutNanos - ( System . nanoTime ( ) - startTime ) ; </a> 0
<a> if ( waitTime <= 0 ) { </a> 0
<a> return done ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> waiters -- ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> if ( interrupted ) { </a> 0
<a> Thread . currentThread ( ) . interrupt ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void setDone ( ) { </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( done ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> done = true ; </a> 0
<a> if ( waiters > 0 ) { </a> 0
<a> notifyAll ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> notifyListeners ( ) ; </a> 0
<a> } </a> 0
<a> private void notifyListeners ( ) { </a> 0
<a> if ( firstListener != null ) { </a> 0
<a> notifyListener ( firstListener ) ; </a> 0
<a> firstListener = null ; </a> 0
<a> if ( otherListeners != null ) { </a> 0
<a> for ( ChannelGroupFutureListener l : otherListeners ) { </a> 0
<a> notifyListener ( l ) ; </a> 0
<a> } </a> 0
<a> otherListeners = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void notifyListener ( ChannelGroupFutureListener l ) { </a> 0
<a> try { </a> 0
<a> l . operationComplete ( this ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( </a> 0
<a> "An exception was thrown by " + </a> 0
<a> ChannelFutureListener . class . getSimpleName ( ) + "." , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . group ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . local ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> public final class LocalAddress extends SocketAddress implements Comparable < LocalAddress > { </a> 0
<a> private static final long serialVersionUID = 4644331421130916435L ; </a> 0
<a> public static final LocalAddress ANY = new LocalAddress ( "ANY" ) ; </a> 0
<a> private final String id ; </a> 0
<a> private final String strVal ; </a> 0
<a> LocalAddress ( Channel channel ) { </a> 0
<a> StringBuilder buf = new StringBuilder ( 16 ) ; </a> 0
<a> buf . append ( "local:E" ) ; </a> 0
<a> buf . append ( Long . toHexString ( channel . id ( ) . intValue ( ) & 0xFFFFFFFFL | 0x100000000L ) ) ; </a> 1
<a> buf . setCharAt ( 7 , ':' ) ; </a> 0
<a> id = buf . substring ( 6 ) ; </a> 0
<a> strVal = buf . toString ( ) ; </a> 0
<a> } </a> 0
<a> public LocalAddress ( String id ) { </a> 0
<a> if ( id == null ) { </a> 0
<a> throw new NullPointerException ( "id" ) ; </a> 0
<a> } </a> 0
<a> id = id . trim ( ) . toLowerCase ( ) ; </a> 0
<a> if ( id . length ( ) == 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "empty id" ) ; </a> 0
<a> } </a> 0
<a> this . id = id ; </a> 0
<a> strVal = "local:" + id ; </a> 0
<a> } </a> 0
<a> public String id ( ) { </a> 0
<a> return id ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int hashCode ( ) { </a> 0
<a> return id . hashCode ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean equals ( Object o ) { </a> 0
<a> if ( ! ( o instanceof LocalAddress ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> return id . equals ( ( ( LocalAddress ) o ) . id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int compareTo ( LocalAddress o ) { </a> 0
<a> return id . compareTo ( o . id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 0
<a> return strVal ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . local ; </a> 0
<a> import io . netty . buffer . ChannelBufType ; </a> 1
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . channel . AbstractChannel ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelConfig ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelMetadata ; </a> 0
<a> import io . netty . channel . DefaultChannelConfig ; </a> 0
<a> import io . netty . channel . EventLoop ; </a> 0
<a> import io . netty . channel . SingleThreadEventExecutor ; </a> 0
<a> import io . netty . channel . SingleThreadEventLoop ; </a> 1
<a> import java . net . SocketAddress ; </a> 0
<a> import java . nio . channels . AlreadyConnectedException ; </a> 0
<a> import java . nio . channels . ClosedChannelException ; </a> 0
<a> import java . nio . channels . ConnectionPendingException ; </a> 0
<a> import java . nio . channels . NotYetConnectedException ; </a> 0
<a> public class LocalChannel extends AbstractChannel { </a> 0
<a> private static final ChannelMetadata METADATA = new ChannelMetadata ( ChannelBufType . MESSAGE , false ) ; </a> 0
<a> private final ChannelConfig config = new DefaultChannelConfig ( ) ; </a> 0
<a> private final Runnable shutdownHook = new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> unsafe ( ) . close ( unsafe ( ) . voidFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private volatile int state ; </a> 0
<a> private volatile LocalChannel peer ; </a> 0
<a> private volatile LocalAddress localAddress ; </a> 0
<a> private volatile LocalAddress remoteAddress ; </a> 0
<a> private volatile ChannelFuture connectFuture ; </a> 0
<a> public LocalChannel ( ) { </a> 0
<a> this ( null ) ; </a> 0
<a> } </a> 0
<a> public LocalChannel ( Integer id ) { </a> 0
<a> super ( null , id ) ; </a> 0
<a> } </a> 0
<a> LocalChannel ( LocalServerChannel parent , LocalChannel peer ) { </a> 0
<a> super ( parent , null ) ; </a> 0
<a> this . peer = peer ; </a> 0
<a> localAddress = parent . localAddress ( ) ; </a> 0
<a> remoteAddress = peer . localAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelMetadata metadata ( ) { </a> 0
<a> return METADATA ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelConfig config ( ) { </a> 0
<a> return config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public LocalServerChannel parent ( ) { </a> 0
<a> return ( LocalServerChannel ) super . parent ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public LocalAddress localAddress ( ) { </a> 0
<a> return ( LocalAddress ) super . localAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public LocalAddress remoteAddress ( ) { </a> 0
<a> return ( LocalAddress ) super . remoteAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isOpen ( ) { </a> 0
<a> return state < 3 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isActive ( ) { </a> 0
<a> return state == 2 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected Unsafe newUnsafe ( ) { </a> 0
<a> return new LocalUnsafe ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isCompatible ( EventLoop loop ) { </a> 0
<a> return loop instanceof SingleThreadEventLoop ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress localAddress0 ( ) { </a> 0
<a> return localAddress ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress remoteAddress0 ( ) { </a> 0
<a> return remoteAddress ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected Runnable doRegister ( ) throws Exception { </a> 0
<a> final LocalChannel peer = this . peer ; </a> 0
<a> Runnable postRegisterTask ; </a> 0
<a> if ( peer != null ) { </a> 0
<a> state = 2 ; </a> 0
<a> peer . remoteAddress = parent ( ) . localAddress ( ) ; </a> 0
<a> peer . state = 2 ; </a> 0
<a> final EventLoop peerEventLoop = peer . eventLoop ( ) ; </a> 0
<a> postRegisterTask = new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> peerEventLoop . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> peer . connectFuture . setSuccess ( ) ; </a> 0
<a> peer . pipeline ( ) . fireChannelActive ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> } else { </a> 0
<a> postRegisterTask = null ; </a> 0
<a> } </a> 0
<a> ( ( SingleThreadEventExecutor ) eventLoop ( ) ) . addShutdownHook ( shutdownHook ) ; </a> 0
<a> return postRegisterTask ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doBind ( SocketAddress localAddress ) throws Exception { </a> 0
<a> this . localAddress = </a> 0
<a> LocalChannelRegistry . register ( this , this . localAddress , </a> 0
<a> localAddress ) ; </a> 0
<a> state = 1 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDisconnect ( ) throws Exception { </a> 0
<a> doClose ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doPreClose ( ) throws Exception { </a> 0
<a> if ( state > 2 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( parent ( ) == null ) { </a> 0
<a> LocalChannelRegistry . unregister ( localAddress ) ; </a> 0
<a> } </a> 0
<a> localAddress = null ; </a> 0
<a> state = 3 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doClose ( ) throws Exception { </a> 0
<a> if ( peer . isActive ( ) ) { </a> 0
<a> peer . unsafe ( ) . close ( peer . unsafe ( ) . voidFuture ( ) ) ; </a> 0
<a> peer = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDeregister ( ) throws Exception { </a> 1
<a> if ( isOpen ( ) ) { </a> 0
<a> unsafe ( ) . close ( unsafe ( ) . voidFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> ( ( SingleThreadEventExecutor ) eventLoop ( ) ) . removeShutdownHook ( shutdownHook ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doFlushMessageBuffer ( MessageBuf < Object > buf ) throws Exception { </a> 1
<a> if ( state < 2 ) { </a> 0
<a> throw new NotYetConnectedException ( ) ; </a> 0
<a> } </a> 0
<a> if ( state > 2 ) { </a> 0
<a> throw new ClosedChannelException ( ) ; </a> 0
<a> } </a> 0
<a> final LocalChannel peer = this . peer ; </a> 0
<a> assert peer != null ; </a> 1
<a> buf . drainTo ( peer . pipeline ( ) . inboundMessageBuffer ( ) ) ; </a> 1
<a> peer . eventLoop ( ) . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> peer . pipeline ( ) . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isFlushPending ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> private class LocalUnsafe extends AbstractUnsafe { </a> 0
<a> @ Override </a> 0
<a> public void connect ( final SocketAddress remoteAddress , </a> 0
<a> SocketAddress localAddress , final ChannelFuture future ) { </a> 0
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> if ( ! ensureOpen ( future ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( state == 2 ) { </a> 0
<a> Exception cause = new AlreadyConnectedException ( ) ; </a> 0
<a> future . setFailure ( cause ) ; </a> 0
<a> pipeline ( ) . fireExceptionCaught ( cause ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> if ( connectFuture != null ) { </a> 0
<a> throw new ConnectionPendingException ( ) ; </a> 0
<a> } </a> 0
<a> connectFuture = future ; </a> 0
<a> if ( state != 1 ) { </a> 0
<a> if ( localAddress == null ) { </a> 0
<a> localAddress = new LocalAddress ( LocalChannel . this ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( localAddress != null ) { </a> 0
<a> try { </a> 0
<a> doBind ( localAddress ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> future . setFailure ( t ) ; </a> 0
<a> pipeline ( ) . fireExceptionCaught ( t ) ; </a> 1
<a> close ( voidFuture ( ) ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> Channel boundChannel = LocalChannelRegistry . get ( remoteAddress ) ; </a> 0
<a> if ( ! ( boundChannel instanceof LocalServerChannel ) ) { </a> 0
<a> Exception cause = </a> 1
<a> new ChannelException ( "connection refused" ) ; </a> 1
<a> future . setFailure ( cause ) ; </a> 0
<a> pipeline ( ) . fireExceptionCaught ( cause ) ; </a> 1
<a> close ( voidFuture ( ) ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> LocalServerChannel serverChannel = ( LocalServerChannel ) boundChannel ; </a> 0
<a> peer = serverChannel . serve ( LocalChannel . this ) ; </a> 0
<a> } else { </a> 0
<a> final SocketAddress localAddress0 = localAddress ; </a> 0
<a> eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> connect ( remoteAddress , localAddress0 , future ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void suspendRead ( ) { </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void resumeRead ( ) { </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . local ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import java . util . concurrent . ConcurrentMap ; </a> 0
<a> final class LocalChannelRegistry { </a> 0
<a> private static final ConcurrentMap < LocalAddress , Channel > boundChannels = </a> 1
<a> new ConcurrentHashMap < LocalAddress , Channel > ( ) ; </a> 1
<a> static LocalAddress register ( </a> 0
<a> Channel channel , LocalAddress oldLocalAddress , SocketAddress localAddress ) { </a> 0
<a> if ( oldLocalAddress != null ) { </a> 0
<a> throw new ChannelException ( "already bound" ) ; </a> 0
<a> } </a> 0
<a> if ( ! ( localAddress instanceof LocalAddress ) ) { </a> 0
<a> throw new ChannelException ( </a> 0
<a> "unsupported address type: " + localAddress . getClass ( ) . getSimpleName ( ) ) ; </a> 0
<a> } </a> 0
<a> LocalAddress addr = ( LocalAddress ) localAddress ; </a> 0
<a> if ( LocalAddress . ANY . equals ( addr ) ) { </a> 0
<a> addr = new LocalAddress ( channel ) ; </a> 0
<a> } </a> 0
<a> Channel boundChannel = boundChannels . putIfAbsent ( addr , channel ) ; </a> 0
<a> if ( boundChannel != null ) { </a> 0
<a> throw new ChannelException ( "address already in use by: " + boundChannel ) ; </a> 0
<a> } </a> 0
<a> return addr ; </a> 0
<a> } </a> 0
<a> static Channel get ( SocketAddress localAddress ) { </a> 0
<a> return boundChannels . get ( localAddress ) ; </a> 0
<a> } </a> 0
<a> static void unregister ( LocalAddress localAddress ) { </a> 0
<a> boundChannels . remove ( localAddress ) ; </a> 0
<a> } </a> 0
<a> private LocalChannelRegistry ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . local ; </a> 0
<a> import io . netty . channel . SingleThreadEventLoop ; </a> 1
<a> import io . netty . channel . ChannelTaskScheduler ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 0
<a> final class LocalEventLoop extends SingleThreadEventLoop { </a> 1
<a> LocalEventLoop ( </a> 1
<a> LocalEventLoopGroup parent , ThreadFactory threadFactory , ChannelTaskScheduler scheduler ) { </a> 0
<a> super ( parent , threadFactory , scheduler ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void run ( ) { </a> 1
<a> for ( ; ; ) { </a> 1
<a> Runnable task ; </a> 1
<a> try { </a> 1
<a> task = takeTask ( ) ; </a> 1
<a> task . run ( ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> } </a> 1
<a> if ( isShutdown ( ) ) { </a> 1
<a> task = pollTask ( ) ; </a> 1
<a> if ( task == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> task . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> protected void wakeup ( boolean inEventLoop ) { </a> 0
<a> if ( ! inEventLoop && isShutdown ( ) ) { </a> 0
<a> interruptThread ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . local ; </a> 0
<a> import io . netty . channel . EventExecutor ; </a> 0
<a> import io . netty . channel . MultithreadEventLoopGroup ; </a> 1
<a> import io . netty . channel . ChannelTaskScheduler ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 0
<a> public class LocalEventLoopGroup extends MultithreadEventLoopGroup { </a> 1
<a> public LocalEventLoopGroup ( ) { </a> 1
<a> this ( 0 ) ; </a> 0
<a> } </a> 0
<a> public LocalEventLoopGroup ( int nThreads ) { </a> 1
<a> this ( nThreads , null ) ; </a> 1
<a> } </a> 1
<a> public LocalEventLoopGroup ( int nThreads , ThreadFactory threadFactory ) { </a> 1
<a> super ( nThreads , threadFactory ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> protected EventExecutor newChild ( </a> 1
<a> ThreadFactory threadFactory , ChannelTaskScheduler scheduler , Object ... args ) throws Exception { </a> 0
<a> return new LocalEventLoop ( this , threadFactory , scheduler ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . local ; </a> 0
<a> import io . netty . channel . AbstractServerChannel ; </a> 0
<a> import io . netty . channel . ChannelConfig ; </a> 0
<a> import io . netty . channel . DefaultChannelConfig ; </a> 0
<a> import io . netty . channel . EventLoop ; </a> 0
<a> import io . netty . channel . ServerChannel ; </a> 0
<a> import io . netty . channel . SingleThreadEventExecutor ; </a> 0
<a> import io . netty . channel . SingleThreadEventLoop ; </a> 1
<a> import java . net . SocketAddress ; </a> 0
<a> public class LocalServerChannel extends AbstractServerChannel { </a> 0
<a> private final ChannelConfig config = new DefaultChannelConfig ( ) ; </a> 0
<a> private final Runnable shutdownHook = new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> unsafe ( ) . close ( unsafe ( ) . voidFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> private volatile int state ; </a> 0
<a> private volatile LocalAddress localAddress ; </a> 0
<a> public LocalServerChannel ( ) { </a> 0
<a> this ( null ) ; </a> 0
<a> } </a> 0
<a> public LocalServerChannel ( Integer id ) { </a> 0
<a> super ( id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelConfig config ( ) { </a> 0
<a> return config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public LocalAddress localAddress ( ) { </a> 0
<a> return ( LocalAddress ) super . localAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public LocalAddress remoteAddress ( ) { </a> 0
<a> return ( LocalAddress ) super . remoteAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isOpen ( ) { </a> 0
<a> return state < 2 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isActive ( ) { </a> 0
<a> return state == 1 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isCompatible ( EventLoop loop ) { </a> 0
<a> return loop instanceof SingleThreadEventLoop ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress localAddress0 ( ) { </a> 0
<a> return localAddress ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected Runnable doRegister ( ) throws Exception { </a> 0
<a> ( ( SingleThreadEventExecutor ) eventLoop ( ) ) . addShutdownHook ( shutdownHook ) ; </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doBind ( SocketAddress localAddress ) throws Exception { </a> 0
<a> this . localAddress = LocalChannelRegistry . register ( this , this . localAddress , localAddress ) ; </a> 0
<a> state = 1 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doPreClose ( ) throws Exception { </a> 0
<a> if ( state > 1 ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> LocalChannelRegistry . unregister ( localAddress ) ; </a> 0
<a> localAddress = null ; </a> 0
<a> state = 2 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doClose ( ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDeregister ( ) throws Exception { </a> 1
<a> ( ( SingleThreadEventExecutor ) eventLoop ( ) ) . removeShutdownHook ( shutdownHook ) ; </a> 0
<a> } </a> 0
<a> LocalChannel serve ( final LocalChannel peer ) { </a> 0
<a> LocalChannel child = new LocalChannel ( this , peer ) ; </a> 0
<a> serve0 ( child ) ; </a> 0
<a> return child ; </a> 0
<a> } </a> 0
<a> private void serve0 ( final LocalChannel child ) { </a> 0
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> pipeline ( ) . inboundMessageBuffer ( ) . add ( child ) ; </a> 1
<a> pipeline ( ) . fireInboundBufferUpdated ( ) ; </a> 1
<a> } else { </a> 0
<a> eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> serve0 ( child ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> protected Unsafe newUnsafe ( ) { </a> 0
<a> return new LocalServerUnsafe ( ) ; </a> 1
<a> } </a> 1
<a> private final class LocalServerUnsafe extends AbstractServerUnsafe { </a> 1
<a> @ Override </a> 1
<a> public void suspendRead ( ) { </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void resumeRead ( ) { </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . local ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> public class DatagramPacket { </a> 0
<a> private final ByteBuf data ; </a> 0
<a> private final InetSocketAddress remoteAddress ; </a> 1
<a> public DatagramPacket ( ByteBuf data , InetSocketAddress remoteAddress ) { </a> 1
<a> if ( data == null ) { </a> 0
<a> throw new NullPointerException ( "data" ) ; </a> 0
<a> } </a> 0
<a> if ( remoteAddress == null ) { </a> 1
<a> throw new NullPointerException ( "remoteAddress" ) ; </a> 1
<a> } </a> 0
<a> this . data = data ; </a> 0
<a> this . remoteAddress = remoteAddress ; </a> 1
<a> } </a> 1
<a> public ByteBuf data ( ) { </a> 0
<a> return data ; </a> 0
<a> } </a> 0
<a> public InetSocketAddress remoteAddress ( ) { </a> 1
<a> return remoteAddress ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public String toString ( ) { </a> 1
<a> return "datagram(" + data . readableBytes ( ) + "B, " + remoteAddress + ')' ; </a> 0
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket ; </a> 0
<a> import static io . netty . channel . ChannelOption . * ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelOption ; </a> 0
<a> import io . netty . channel . DefaultChannelConfig ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . DatagramSocket ; </a> 0
<a> import java . net . InetAddress ; </a> 0
<a> import java . net . MulticastSocket ; </a> 0
<a> import java . net . NetworkInterface ; </a> 0
<a> import java . net . SocketException ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class DefaultDatagramChannelConfig extends DefaultChannelConfig implements DatagramChannelConfig { </a> 0
<a> private static final int DEFAULT_RECEIVE_PACKET_SIZE = 2048 ; </a> 1
<a> private final DatagramSocket socket ; </a> 0
<a> private volatile int receivePacketSize = DEFAULT_RECEIVE_PACKET_SIZE ; </a> 1
<a> public DefaultDatagramChannelConfig ( DatagramSocket socket ) { </a> 0
<a> if ( socket == null ) { </a> 0
<a> throw new NullPointerException ( "socket" ) ; </a> 0
<a> } </a> 0
<a> this . socket = socket ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Map < ChannelOption < ? > , Object > getOptions ( ) { </a> 0
<a> return getOptions ( </a> 0
<a> super . getOptions ( ) , </a> 0
<a> SO_BROADCAST , SO_RCVBUF , SO_SNDBUF , SO_REUSEADDR , IP_MULTICAST_LOOP_DISABLED , </a> 0
<a> IP_MULTICAST_ADDR , IP_MULTICAST_IF , IP_MULTICAST_TTL , IP_TOS , UDP_RECEIVE_PACKET_SIZE ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > T getOption ( ChannelOption < T > option ) { </a> 0
<a> if ( option == SO_BROADCAST ) { </a> 0
<a> return ( T ) Boolean . valueOf ( isBroadcast ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == SO_RCVBUF ) { </a> 0
<a> return ( T ) Integer . valueOf ( getReceiveBufferSize ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == SO_SNDBUF ) { </a> 0
<a> return ( T ) Integer . valueOf ( getSendBufferSize ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == UDP_RECEIVE_PACKET_SIZE ) { </a> 1
<a> return ( T ) Integer . valueOf ( getReceivePacketSize ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( option == SO_REUSEADDR ) { </a> 0
<a> return ( T ) Boolean . valueOf ( isReuseAddress ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == IP_MULTICAST_LOOP_DISABLED ) { </a> 0
<a> return ( T ) Boolean . valueOf ( isLoopbackModeDisabled ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == IP_MULTICAST_ADDR ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> T i = ( T ) getInterface ( ) ; </a> 1
<a> return i ; </a> 1
<a> } </a> 0
<a> if ( option == IP_MULTICAST_IF ) { </a> 0
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> T i = ( T ) getNetworkInterface ( ) ; </a> 1
<a> return i ; </a> 1
<a> } </a> 0
<a> if ( option == IP_MULTICAST_TTL ) { </a> 0
<a> return ( T ) Integer . valueOf ( getTimeToLive ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == IP_TOS ) { </a> 0
<a> return ( T ) Integer . valueOf ( getTrafficClass ( ) ) ; </a> 0
<a> } </a> 0
<a> return super . getOption ( option ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > boolean setOption ( ChannelOption < T > option , T value ) { </a> 0
<a> validate ( option , value ) ; </a> 0
<a> if ( option == SO_BROADCAST ) { </a> 0
<a> setBroadcast ( ( Boolean ) value ) ; </a> 0
<a> } else if ( option == SO_RCVBUF ) { </a> 0
<a> setReceiveBufferSize ( ( Integer ) value ) ; </a> 0
<a> } else if ( option == SO_SNDBUF ) { </a> 0
<a> setSendBufferSize ( ( Integer ) value ) ; </a> 0
<a> } else if ( option == SO_REUSEADDR ) { </a> 0
<a> setReuseAddress ( ( Boolean ) value ) ; </a> 0
<a> } else if ( option == IP_MULTICAST_LOOP_DISABLED ) { </a> 0
<a> setLoopbackModeDisabled ( ( Boolean ) value ) ; </a> 0
<a> } else if ( option == IP_MULTICAST_ADDR ) { </a> 0
<a> setInterface ( ( InetAddress ) value ) ; </a> 0
<a> } else if ( option == IP_MULTICAST_IF ) { </a> 0
<a> setNetworkInterface ( ( NetworkInterface ) value ) ; </a> 0
<a> } else if ( option == IP_MULTICAST_TTL ) { </a> 0
<a> setTimeToLive ( ( Integer ) value ) ; </a> 0
<a> } else if ( option == IP_TOS ) { </a> 0
<a> setTrafficClass ( ( Integer ) value ) ; </a> 0
<a> } else { </a> 0
<a> return super . setOption ( option , value ) ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isBroadcast ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getBroadcast ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBroadcast ( boolean broadcast ) { </a> 0
<a> try { </a> 0
<a> socket . setBroadcast ( broadcast ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public InetAddress getInterface ( ) { </a> 0
<a> if ( socket instanceof MulticastSocket ) { </a> 0
<a> try { </a> 0
<a> return ( ( MulticastSocket ) socket ) . getInterface ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setInterface ( InetAddress interfaceAddress ) { </a> 0
<a> if ( socket instanceof MulticastSocket ) { </a> 0
<a> try { </a> 0
<a> ( ( MulticastSocket ) socket ) . setInterface ( interfaceAddress ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isLoopbackModeDisabled ( ) { </a> 0
<a> if ( socket instanceof MulticastSocket ) { </a> 0
<a> try { </a> 0
<a> return ( ( MulticastSocket ) socket ) . getLoopbackMode ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setLoopbackModeDisabled ( boolean loopbackModeDisabled ) { </a> 0
<a> if ( socket instanceof MulticastSocket ) { </a> 0
<a> try { </a> 0
<a> ( ( MulticastSocket ) socket ) . setLoopbackMode ( loopbackModeDisabled ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public NetworkInterface getNetworkInterface ( ) { </a> 0
<a> if ( socket instanceof MulticastSocket ) { </a> 0
<a> try { </a> 0
<a> return ( ( MulticastSocket ) socket ) . getNetworkInterface ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setNetworkInterface ( NetworkInterface networkInterface ) { </a> 0
<a> if ( socket instanceof MulticastSocket ) { </a> 0
<a> try { </a> 0
<a> ( ( MulticastSocket ) socket ) . setNetworkInterface ( networkInterface ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isReuseAddress ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getReuseAddress ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setReuseAddress ( boolean reuseAddress ) { </a> 0
<a> try { </a> 0
<a> socket . setReuseAddress ( reuseAddress ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getReceiveBufferSize ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getReceiveBufferSize ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setReceiveBufferSize ( int receiveBufferSize ) { </a> 0
<a> try { </a> 0
<a> socket . setReceiveBufferSize ( receiveBufferSize ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getSendBufferSize ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getSendBufferSize ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setSendBufferSize ( int sendBufferSize ) { </a> 0
<a> try { </a> 0
<a> socket . setSendBufferSize ( sendBufferSize ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getReceivePacketSize ( ) { </a> 1
<a> return receivePacketSize ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setReceivePacketSize ( int receivePacketSize ) { </a> 0
<a> if ( receivePacketSize <= 0 ) { </a> 1
<a> throw new IllegalArgumentException ( </a> 1
<a> String . format ( "receivePacketSize: %d (expected: > 0)" , receivePacketSize ) ) ; </a> 1
<a> } </a> 1
<a> this . receivePacketSize = receivePacketSize ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getTimeToLive ( ) { </a> 0
<a> if ( socket instanceof MulticastSocket ) { </a> 0
<a> try { </a> 0
<a> return ( ( MulticastSocket ) socket ) . getTimeToLive ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setTimeToLive ( int ttl ) { </a> 0
<a> if ( socket instanceof MulticastSocket ) { </a> 0
<a> try { </a> 0
<a> ( ( MulticastSocket ) socket ) . setTimeToLive ( ttl ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getTrafficClass ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getTrafficClass ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setTrafficClass ( int trafficClass ) { </a> 0
<a> try { </a> 0
<a> socket . setTrafficClass ( trafficClass ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket ; </a> 0
<a> import static io . netty . channel . ChannelOption . * ; </a> 1
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelOption ; </a> 0
<a> import io . netty . channel . DefaultChannelConfig ; </a> 0
<a> import io . netty . util . NetworkConstants ; </a> 0
<a> import java . net . ServerSocket ; </a> 0
<a> import java . net . SocketException ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class DefaultServerSocketChannelConfig extends DefaultChannelConfig </a> 0
<a> implements ServerSocketChannelConfig { </a> 0
<a> private final ServerSocket socket ; </a> 0
<a> private volatile int backlog = NetworkConstants . SOMAXCONN ; </a> 0
<a> public DefaultServerSocketChannelConfig ( ServerSocket socket ) { </a> 0
<a> if ( socket == null ) { </a> 0
<a> throw new NullPointerException ( "socket" ) ; </a> 0
<a> } </a> 0
<a> this . socket = socket ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Map < ChannelOption < ? > , Object > getOptions ( ) { </a> 0
<a> return getOptions ( super . getOptions ( ) , SO_RCVBUF , SO_REUSEADDR , SO_BACKLOG ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > T getOption ( ChannelOption < T > option ) { </a> 0
<a> if ( option == SO_RCVBUF ) { </a> 0
<a> return ( T ) Integer . valueOf ( getReceiveBufferSize ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == SO_REUSEADDR ) { </a> 0
<a> return ( T ) Boolean . valueOf ( isReuseAddress ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == SO_BACKLOG ) { </a> 0
<a> return ( T ) Integer . valueOf ( getBacklog ( ) ) ; </a> 0
<a> } </a> 0
<a> return super . getOption ( option ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > boolean setOption ( ChannelOption < T > option , T value ) { </a> 0
<a> validate ( option , value ) ; </a> 0
<a> if ( option == SO_RCVBUF ) { </a> 0
<a> setReceiveBufferSize ( ( Integer ) value ) ; </a> 0
<a> } else if ( option == SO_REUSEADDR ) { </a> 0
<a> setReuseAddress ( ( Boolean ) value ) ; </a> 0
<a> } else if ( option == SO_BACKLOG ) { </a> 0
<a> setBacklog ( ( Integer ) value ) ; </a> 0
<a> } else { </a> 0
<a> return super . setOption ( option , value ) ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isReuseAddress ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getReuseAddress ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setReuseAddress ( boolean reuseAddress ) { </a> 0
<a> try { </a> 0
<a> socket . setReuseAddress ( reuseAddress ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getReceiveBufferSize ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getReceiveBufferSize ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setReceiveBufferSize ( int receiveBufferSize ) { </a> 0
<a> try { </a> 0
<a> socket . setReceiveBufferSize ( receiveBufferSize ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setPerformancePreferences ( int connectionTime , int latency , int bandwidth ) { </a> 0
<a> socket . setPerformancePreferences ( connectionTime , latency , bandwidth ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getBacklog ( ) { </a> 0
<a> return backlog ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setBacklog ( int backlog ) { </a> 0
<a> if ( backlog < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( "backlog: " + backlog ) ; </a> 0
<a> } </a> 0
<a> this . backlog = backlog ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket ; </a> 0
<a> import static io . netty . channel . ChannelOption . * ; </a> 1
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelOption ; </a> 0
<a> import io . netty . channel . DefaultChannelConfig ; </a> 0
<a> import java . net . Socket ; </a> 0
<a> import java . net . SocketException ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public class DefaultSocketChannelConfig extends DefaultChannelConfig </a> 0
<a> implements SocketChannelConfig { </a> 0
<a> private final Socket socket ; </a> 0
<a> public DefaultSocketChannelConfig ( Socket socket ) { </a> 0
<a> if ( socket == null ) { </a> 0
<a> throw new NullPointerException ( "socket" ) ; </a> 0
<a> } </a> 0
<a> this . socket = socket ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Map < ChannelOption < ? > , Object > getOptions ( ) { </a> 0
<a> return getOptions ( </a> 0
<a> super . getOptions ( ) , </a> 0
<a> SO_RCVBUF , SO_SNDBUF , TCP_NODELAY , SO_KEEPALIVE , SO_REUSEADDR , SO_LINGER , IP_TOS ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > T getOption ( ChannelOption < T > option ) { </a> 0
<a> if ( option == SO_RCVBUF ) { </a> 0
<a> return ( T ) Integer . valueOf ( getReceiveBufferSize ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == SO_SNDBUF ) { </a> 0
<a> return ( T ) Integer . valueOf ( getSendBufferSize ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == TCP_NODELAY ) { </a> 0
<a> return ( T ) Boolean . valueOf ( isTcpNoDelay ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == SO_KEEPALIVE ) { </a> 0
<a> return ( T ) Boolean . valueOf ( isKeepAlive ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == SO_REUSEADDR ) { </a> 0
<a> return ( T ) Boolean . valueOf ( isReuseAddress ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == SO_LINGER ) { </a> 0
<a> return ( T ) Integer . valueOf ( getSoLinger ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( option == IP_TOS ) { </a> 0
<a> return ( T ) Integer . valueOf ( getTrafficClass ( ) ) ; </a> 0
<a> } </a> 0
<a> return super . getOption ( option ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public < T > boolean setOption ( ChannelOption < T > option , T value ) { </a> 0
<a> validate ( option , value ) ; </a> 0
<a> if ( option == SO_RCVBUF ) { </a> 0
<a> setReceiveBufferSize ( ( Integer ) value ) ; </a> 0
<a> } else if ( option == SO_SNDBUF ) { </a> 0
<a> setSendBufferSize ( ( Integer ) value ) ; </a> 0
<a> } else if ( option == TCP_NODELAY ) { </a> 0
<a> setTcpNoDelay ( ( Boolean ) value ) ; </a> 0
<a> } else if ( option == SO_KEEPALIVE ) { </a> 0
<a> setKeepAlive ( ( Boolean ) value ) ; </a> 0
<a> } else if ( option == SO_REUSEADDR ) { </a> 0
<a> setReuseAddress ( ( Boolean ) value ) ; </a> 0
<a> } else if ( option == SO_LINGER ) { </a> 0
<a> setSoLinger ( ( Integer ) value ) ; </a> 0
<a> } else if ( option == IP_TOS ) { </a> 0
<a> setTrafficClass ( ( Integer ) value ) ; </a> 0
<a> } else { </a> 0
<a> return super . setOption ( option , value ) ; </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getReceiveBufferSize ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getReceiveBufferSize ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getSendBufferSize ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getSendBufferSize ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getSoLinger ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getSoLinger ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getTrafficClass ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getTrafficClass ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isKeepAlive ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getKeepAlive ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isReuseAddress ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getReuseAddress ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isTcpNoDelay ( ) { </a> 0
<a> try { </a> 0
<a> return socket . getTcpNoDelay ( ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setKeepAlive ( boolean keepAlive ) { </a> 0
<a> try { </a> 0
<a> socket . setKeepAlive ( keepAlive ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setPerformancePreferences ( </a> 0
<a> int connectionTime , int latency , int bandwidth ) { </a> 0
<a> socket . setPerformancePreferences ( connectionTime , latency , bandwidth ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setReceiveBufferSize ( int receiveBufferSize ) { </a> 0
<a> try { </a> 0
<a> socket . setReceiveBufferSize ( receiveBufferSize ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setReuseAddress ( boolean reuseAddress ) { </a> 0
<a> try { </a> 0
<a> socket . setReuseAddress ( reuseAddress ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setSendBufferSize ( int sendBufferSize ) { </a> 0
<a> try { </a> 0
<a> socket . setSendBufferSize ( sendBufferSize ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setSoLinger ( int soLinger ) { </a> 0
<a> try { </a> 0
<a> if ( soLinger < 0 ) { </a> 0
<a> socket . setSoLinger ( false , 0 ) ; </a> 0
<a> } else { </a> 0
<a> socket . setSoLinger ( true , soLinger ) ; </a> 0
<a> } </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setTcpNoDelay ( boolean tcpNoDelay ) { </a> 0
<a> try { </a> 0
<a> socket . setTcpNoDelay ( tcpNoDelay ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setTrafficClass ( int trafficClass ) { </a> 0
<a> try { </a> 0
<a> socket . setTrafficClass ( trafficClass ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket ; </a> 0
<a> public enum InternetProtocolFamily { </a> 0
<a> IPv4 , </a> 0
<a> IPv6 </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket ; </a> 0
<a> import io . netty . channel . ServerChannel ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> public interface ServerSocketChannel extends ServerChannel { </a> 0
<a> @ Override </a> 0
<a> ServerSocketChannelConfig config ( ) ; </a> 0
<a> @ Override </a> 0
<a> InetSocketAddress localAddress ( ) ; </a> 0
<a> @ Override </a> 0
<a> InetSocketAddress remoteAddress ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket ; </a> 0
<a> import io . netty . channel . ChannelConfig ; </a> 0
<a> import java . net . ServerSocket ; </a> 0
<a> import java . net . StandardSocketOptions ; </a> 0
<a> public interface ServerSocketChannelConfig extends ChannelConfig { </a> 0
<a> int getBacklog ( ) ; </a> 0
<a> void setBacklog ( int backlog ) ; </a> 0
<a> boolean isReuseAddress ( ) ; </a> 0
<a> void setReuseAddress ( boolean reuseAddress ) ; </a> 0
<a> int getReceiveBufferSize ( ) ; </a> 0
<a> void setReceiveBufferSize ( int receiveBufferSize ) ; </a> 0
<a> void setPerformancePreferences ( int connectionTime , int latency , int bandwidth ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> public interface SocketChannel extends Channel { </a> 0
<a> @ Override </a> 0
<a> SocketChannelConfig config ( ) ; </a> 0
<a> @ Override </a> 0
<a> InetSocketAddress localAddress ( ) ; </a> 0
<a> @ Override </a> 0
<a> InetSocketAddress remoteAddress ( ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket ; </a> 0
<a> import io . netty . channel . ChannelConfig ; </a> 0
<a> import java . net . Socket ; </a> 0
<a> import java . net . StandardSocketOptions ; </a> 0
<a> public interface SocketChannelConfig extends ChannelConfig { </a> 0
<a> boolean isTcpNoDelay ( ) ; </a> 0
<a> void setTcpNoDelay ( boolean tcpNoDelay ) ; </a> 0
<a> int getSoLinger ( ) ; </a> 0
<a> void setSoLinger ( int soLinger ) ; </a> 0
<a> int getSendBufferSize ( ) ; </a> 0
<a> void setSendBufferSize ( int sendBufferSize ) ; </a> 0
<a> int getReceiveBufferSize ( ) ; </a> 0
<a> void setReceiveBufferSize ( int receiveBufferSize ) ; </a> 0
<a> boolean isKeepAlive ( ) ; </a> 0
<a> void setKeepAlive ( boolean keepAlive ) ; </a> 0
<a> int getTrafficClass ( ) ; </a> 0
<a> void setTrafficClass ( int trafficClass ) ; </a> 0
<a> boolean isReuseAddress ( ) ; </a> 0
<a> void setReuseAddress ( boolean reuseAddress ) ; </a> 0
<a> void setPerformancePreferences ( int connectionTime , int latency , int bandwidth ) ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . aio ; </a> 0
<a> import io . netty . channel . AbstractChannel ; </a> 1
<a> import io . netty . channel . Channel ; </a> 1
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . EventLoop ; </a> 1
<a> import java . net . ConnectException ; </a> 1
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . net . SocketAddress ; </a> 1
<a> import java . nio . channels . AsynchronousChannel ; </a> 1
<a> import java . util . concurrent . ScheduledFuture ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 1
<a> abstract class AbstractAioChannel extends AbstractChannel { </a> 0
<a> protected final AioEventLoopGroup group ; </a> 0
<a> private final AsynchronousChannel ch ; </a> 0
<a> protected ChannelFuture connectFuture ; </a> 0
<a> protected ScheduledFuture < ? > connectTimeoutFuture ; </a> 1
<a> private ConnectException connectTimeoutException ; </a> 1
<a> protected AbstractAioChannel ( Channel parent , Integer id , AioEventLoopGroup group , AsynchronousChannel ch ) { </a> 0
<a> super ( parent , id ) ; </a> 1
<a> this . ch = ch ; </a> 1
<a> this . group = group ; </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> public InetSocketAddress localAddress ( ) { </a> 0
<a> return ( InetSocketAddress ) super . localAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public InetSocketAddress remoteAddress ( ) { </a> 0
<a> return ( InetSocketAddress ) super . remoteAddress ( ) ; </a> 0
<a> } </a> 0
<a> protected AsynchronousChannel javaChannel ( ) { </a> 1
<a> return ch ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isOpen ( ) { </a> 1
<a> return ch . isOpen ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected Runnable doRegister ( ) throws Exception { </a> 0
<a> if ( ( ( AioEventLoop ) eventLoop ( ) ) . parent ( ) != group ) { </a> 0
<a> throw new ChannelException ( </a> 0
<a> getClass ( ) . getSimpleName ( ) + " must be registered to the " + </a> 0
<a> AioEventLoopGroup . class . getSimpleName ( ) + " which was specified in the constructor." ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDeregister ( ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isCompatible ( EventLoop loop ) { </a> 1
<a> return loop instanceof AioEventLoop ; </a> 1
<a> } </a> 1
<a> protected abstract class AbstractAioUnsafe extends AbstractUnsafe { </a> 1
<a> @ Override </a> 1
<a> public void connect ( final SocketAddress remoteAddress , </a> 1
<a> final SocketAddress localAddress , final ChannelFuture future ) { </a> 0
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> if ( ! ensureOpen ( future ) ) { </a> 0
<a> return ; </a> 1
<a> } </a> 1
<a> try { </a> 1
<a> if ( connectFuture != null ) { </a> 0
<a> throw new IllegalStateException ( "connection attempt already made" ) ; </a> 1
<a> } </a> 1
<a> connectFuture = future ; </a> 0
<a> doConnect ( remoteAddress , localAddress , future ) ; </a> 0
<a> int connectTimeoutMillis = config ( ) . getConnectTimeoutMillis ( ) ; </a> 1
<a> if ( connectTimeoutMillis > 0 ) { </a> 1
<a> connectTimeoutFuture = eventLoop ( ) . schedule ( new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> if ( connectTimeoutException == null ) { </a> 1
<a> connectTimeoutException = new ConnectException ( "connection timed out" ) ; </a> 1
<a> } </a> 1
<a> ChannelFuture connectFuture = AbstractAioChannel . this . connectFuture ; </a> 0
<a> if ( connectFuture != null && </a> 1
<a> connectFuture . setFailure ( connectTimeoutException ) ) { </a> 0
<a> pipeline ( ) . fireExceptionCaught ( connectTimeoutException ) ; </a> 1
<a> close ( voidFuture ( ) ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } , connectTimeoutMillis , TimeUnit . MILLISECONDS ) ; </a> 1
<a> } </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> future . setFailure ( t ) ; </a> 0
<a> pipeline ( ) . fireExceptionCaught ( t ) ; </a> 0
<a> closeIfClosed ( ) ; </a> 1
<a> } </a> 1
<a> } else { </a> 0
<a> eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> connect ( remoteAddress , localAddress , future ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> protected final void connectFailed ( Throwable t ) { </a> 1
<a> connectFuture . setFailure ( t ) ; </a> 0
<a> pipeline ( ) . fireExceptionCaught ( t ) ; </a> 1
<a> closeIfClosed ( ) ; </a> 1
<a> } </a> 1
<a> protected final void connectSuccess ( ) { </a> 1
<a> assert eventLoop ( ) . inEventLoop ( ) ; </a> 1
<a> assert connectFuture != null ; </a> 0
<a> try { </a> 1
<a> boolean wasActive = isActive ( ) ; </a> 1
<a> connectFuture . setSuccess ( ) ; </a> 0
<a> if ( ! wasActive && isActive ( ) ) { </a> 1
<a> pipeline ( ) . fireChannelActive ( ) ; </a> 1
<a> } </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> connectFuture . setFailure ( t ) ; </a> 0
<a> pipeline ( ) . fireExceptionCaught ( t ) ; </a> 0
<a> closeIfClosed ( ) ; </a> 1
<a> } finally { </a> 1
<a> connectTimeoutFuture . cancel ( false ) ; </a> 1
<a> connectFuture = null ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> protected abstract void doConnect ( SocketAddress remoteAddress , </a> 1
<a> SocketAddress localAddress , ChannelFuture connectFuture ) ; </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . aio ; </a> 0
<a> import io . netty . channel . Channel ; </a> 1
<a> import io . netty . channel . EventLoop ; </a> 1
<a> import java . nio . channels . CompletionHandler ; </a> 1
<a> abstract class AioCompletionHandler < V , A extends Channel > implements CompletionHandler < V , A > { </a> 0
<a> protected abstract void completed0 ( V result , A channel ) ; </a> 1
<a> protected abstract void failed0 ( Throwable exc , A channel ) ; </a> 1
<a> private static final int MAX_STACK_DEPTH = 4 ; </a> 0
<a> private static final ThreadLocal < Integer > STACK_DEPTH = new ThreadLocal < Integer > ( ) { </a> 0
<a> @ Override </a> 0
<a> protected Integer initialValue ( ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> @ Override </a> 1
<a> public final void completed ( final V result , final A channel ) { </a> 1
<a> EventLoop loop = channel . eventLoop ( ) ; </a> 1
<a> if ( loop . inEventLoop ( ) ) { </a> 1
<a> Integer d = STACK_DEPTH . get ( ) ; </a> 0
<a> if ( d < MAX_STACK_DEPTH ) { </a> 0
<a> STACK_DEPTH . set ( d + 1 ) ; </a> 0
<a> try { </a> 0
<a> completed0 ( result , channel ) ; </a> 1
<a> } finally { </a> 0
<a> STACK_DEPTH . set ( d ) ; </a> 0
<a> } </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> loop . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> completed0 ( result , channel ) ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public final void failed ( final Throwable exc , final A channel ) { </a> 1
<a> EventLoop loop = channel . eventLoop ( ) ; </a> 1
<a> if ( loop . inEventLoop ( ) ) { </a> 1
<a> Integer d = STACK_DEPTH . get ( ) ; </a> 0
<a> if ( d < MAX_STACK_DEPTH ) { </a> 0
<a> STACK_DEPTH . set ( d + 1 ) ; </a> 0
<a> try { </a> 0
<a> failed0 ( exc , channel ) ; </a> 1
<a> } finally { </a> 0
<a> STACK_DEPTH . set ( d ) ; </a> 0
<a> } </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> loop . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> failed0 ( exc , channel ) ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . aio ; </a> 0
<a> import io . netty . channel . SingleThreadEventLoop ; </a> 0
<a> import io . netty . channel . ChannelTaskScheduler ; </a> 1
<a> import java . util . concurrent . ThreadFactory ; </a> 1
<a> final class AioEventLoop extends SingleThreadEventLoop { </a> 1
<a> AioEventLoop ( AioEventLoopGroup parent , ThreadFactory threadFactory , ChannelTaskScheduler scheduler ) { </a> 0
<a> super ( parent , threadFactory , scheduler ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void run ( ) { </a> 1
<a> for ( ; ; ) { </a> 1
<a> Runnable task ; </a> 1
<a> try { </a> 1
<a> task = takeTask ( ) ; </a> 1
<a> task . run ( ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> } </a> 1
<a> if ( isShutdown ( ) ) { </a> 1
<a> task = pollTask ( ) ; </a> 1
<a> if ( task == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> task . run ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void wakeup ( boolean inEventLoop ) { </a> 1
<a> if ( ! inEventLoop && isShutdown ( ) ) { </a> 1
<a> interruptThread ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . aio ; </a> 0
<a> import io . netty . channel . EventExecutor ; </a> 0
<a> import io . netty . channel . EventLoopException ; </a> 1
<a> import io . netty . channel . MultithreadEventLoopGroup ; </a> 1
<a> import io . netty . channel . ChannelTaskScheduler ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> import java . lang . reflect . Field ; </a> 0
<a> import java . nio . channels . AsynchronousChannelGroup ; </a> 1
<a> import java . util . ArrayDeque ; </a> 0
<a> import java . util . Collections ; </a> 1
<a> import java . util . Deque ; </a> 0
<a> import java . util . List ; </a> 1
<a> import java . util . concurrent . AbstractExecutorService ; </a> 1
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 0
<a> import java . util . concurrent . ConcurrentMap ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 1
<a> public class AioEventLoopGroup extends MultithreadEventLoopGroup { </a> 1
<a> private static final ConcurrentMap < Class < ? > , Field [ ] > fieldCache = new ConcurrentHashMap < Class < ? > , Field [ ] > ( ) ; </a> 0
<a> private static final Field [ ] FAILURE = new Field [ 0 ] ; </a> 0
<a> final AsynchronousChannelGroup group ; </a> 0
<a> public AioEventLoopGroup ( ) { </a> 1
<a> this ( 0 ) ; </a> 0
<a> } </a> 1
<a> public AioEventLoopGroup ( int nThreads ) { </a> 1
<a> this ( nThreads , null ) ; </a> 1
<a> } </a> 1
<a> public AioEventLoopGroup ( int nThreads , ThreadFactory threadFactory ) { </a> 1
<a> super ( nThreads , threadFactory ) ; </a> 1
<a> try { </a> 1
<a> group = AsynchronousChannelGroup . withThreadPool ( new AioExecutorService ( ) ) ; </a> 1
<a> } catch ( IOException e ) { </a> 1
<a> throw new EventLoopException ( "Failed to create an AsynchronousChannelGroup" , e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected EventExecutor newChild ( </a> 1
<a> ThreadFactory threadFactory , ChannelTaskScheduler scheduler , Object ... args ) throws Exception { </a> 0
<a> return new AioEventLoop ( this , threadFactory , scheduler ) ; </a> 1
<a> } </a> 1
<a> private void executeAioTask ( Runnable command ) { </a> 0
<a> AbstractAioChannel ch = null ; </a> 0
<a> try { </a> 0
<a> ch = findChannel ( command ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> } </a> 0
<a> EventExecutor l ; </a> 0
<a> if ( ch != null ) { </a> 0
<a> l = ch . eventLoop ( ) ; </a> 0
<a> } else { </a> 0
<a> l = next ( ) ; </a> 0
<a> } </a> 0
<a> if ( l . isShutdown ( ) ) { </a> 0
<a> command . run ( ) ; </a> 0
<a> } else { </a> 0
<a> l . execute ( command ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static AbstractAioChannel findChannel ( Runnable command ) throws Exception { </a> 0
<a> Class < ? > commandType = command . getClass ( ) ; </a> 1
<a> Field [ ] fields = fieldCache . get ( commandType ) ; </a> 1
<a> if ( fields == null ) { </a> 1
<a> try { </a> 1
<a> fields = findFieldSequence ( command , new ArrayDeque < Field > ( 2 ) ) ; </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> } </a> 0
<a> if ( fields == null ) { </a> 0
<a> fields = FAILURE ; </a> 0
<a> } </a> 0
<a> fieldCache . put ( commandType , fields ) ; </a> 0
<a> } </a> 0
<a> if ( fields == FAILURE ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> final int lastIndex = fields . length - 1 ; </a> 1
<a> for ( int i = 0 ; i < lastIndex ; i ++ ) { </a> 1
<a> command = ( Runnable ) fields [ i ] . get ( command ) ; </a> 0
<a> } </a> 0
<a> return ( AbstractAioChannel ) fields [ lastIndex ] . get ( command ) ; </a> 0
<a> } </a> 1
<a> private static Field [ ] findFieldSequence ( Runnable command , Deque < Field > fields ) throws Exception { </a> 0
<a> Class < ? > commandType = command . getClass ( ) ; </a> 1
<a> for ( Field f : commandType . getDeclaredFields ( ) ) { </a> 0
<a> if ( f . getType ( ) == Runnable . class ) { </a> 0
<a> f . setAccessible ( true ) ; </a> 0
<a> fields . addLast ( f ) ; </a> 1
<a> try { </a> 1
<a> Field [ ] ret = findFieldSequence ( ( Runnable ) f . get ( command ) , fields ) ; </a> 0
<a> if ( ret != null ) { </a> 1
<a> return ret ; </a> 1
<a> } </a> 1
<a> } finally { </a> 1
<a> fields . removeLast ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> if ( f . getType ( ) == Object . class ) { </a> 0
<a> f . setAccessible ( true ) ; </a> 0
<a> fields . addLast ( f ) ; </a> 1
<a> try { </a> 1
<a> Object candidate = f . get ( command ) ; </a> 0
<a> if ( candidate instanceof AbstractAioChannel ) { </a> 0
<a> return fields . toArray ( new Field [ fields . size ( ) ] ) ; </a> 1
<a> } </a> 1
<a> } finally { </a> 1
<a> fields . removeLast ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> private final class AioExecutorService extends AbstractExecutorService { </a> 0
<a> @ Override </a> 0
<a> public void shutdown ( ) { </a> 0
<a> AioEventLoopGroup . this . shutdown ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public List < Runnable > shutdownNow ( ) { </a> 1
<a> AioEventLoopGroup . this . shutdown ( ) ; </a> 0
<a> return Collections . emptyList ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isShutdown ( ) { </a> 0
<a> return AioEventLoopGroup . this . isShutdown ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isTerminated ( ) { </a> 1
<a> return AioEventLoopGroup . this . isTerminated ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { </a> 0
<a> return AioEventLoopGroup . this . awaitTermination ( timeout , unit ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void execute ( Runnable command ) { </a> 0
<a> Class < ? extends Runnable > commandType = command . getClass ( ) ; </a> 0
<a> if ( commandType . getName ( ) . startsWith ( "sun.nio.ch." ) ) { </a> 0
<a> executeAioTask ( command ) ; </a> 0
<a> } else { </a> 0
<a> next ( ) . execute ( command ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . aio ; </a> 0
<a> import io . netty . buffer . ChannelBufType ; </a> 1
<a> import io . netty . channel . ChannelException ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelMetadata ; </a> 1
<a> import io . netty . channel . socket . ServerSocketChannel ; </a> 1
<a> import io . netty . channel . socket . ServerSocketChannelConfig ; </a> 1
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> import java . net . SocketAddress ; </a> 1
<a> import java . nio . channels . AsynchronousChannelGroup ; </a> 1
<a> import java . nio . channels . AsynchronousCloseException ; </a> 1
<a> import java . nio . channels . AsynchronousServerSocketChannel ; </a> 1
<a> import java . nio . channels . AsynchronousSocketChannel ; </a> 1
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 1
<a> public class AioServerSocketChannel extends AbstractAioChannel implements ServerSocketChannel { </a> 1
<a> private static final ChannelMetadata METADATA = new ChannelMetadata ( ChannelBufType . MESSAGE , false ) ; </a> 1
<a> private static final AcceptHandler ACCEPT_HANDLER = new AcceptHandler ( ) ; </a> 1
<a> private static final InternalLogger logger = </a> 1
<a> InternalLoggerFactory . getInstance ( AioServerSocketChannel . class ) ; </a> 1
<a> private final AioEventLoopGroup childGroup ; </a> 0
<a> private final AioServerSocketChannelConfig config ; </a> 1
<a> private boolean closed ; </a> 1
<a> private final AtomicBoolean readSuspended = new AtomicBoolean ( ) ; </a> 1
<a> private final Runnable acceptTask = new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> doAccept ( ) ; </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> private static AsynchronousServerSocketChannel newSocket ( AsynchronousChannelGroup group ) { </a> 1
<a> try { </a> 1
<a> return AsynchronousServerSocketChannel . open ( group ) ; </a> 1
<a> } catch ( IOException e ) { </a> 1
<a> throw new ChannelException ( "Failed to open a socket." , e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public AioServerSocketChannel ( AioEventLoopGroup group ) { </a> 0
<a> this ( group , group ) ; </a> 0
<a> } </a> 1
<a> public AioServerSocketChannel ( AioEventLoopGroup parentGroup , AioEventLoopGroup childGroup ) { </a> 0
<a> super ( null , null , parentGroup , newSocket ( parentGroup . group ) ) ; </a> 0
<a> this . childGroup = childGroup ; </a> 0
<a> config = new AioServerSocketChannelConfig ( javaChannel ( ) ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> protected AsynchronousServerSocketChannel javaChannel ( ) { </a> 1
<a> return ( AsynchronousServerSocketChannel ) super . javaChannel ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isActive ( ) { </a> 1
<a> return javaChannel ( ) . isOpen ( ) && localAddress0 ( ) != null ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelMetadata metadata ( ) { </a> 1
<a> return METADATA ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected SocketAddress localAddress0 ( ) { </a> 1
<a> try { </a> 1
<a> return javaChannel ( ) . getLocalAddress ( ) ; </a> 1
<a> } catch ( IOException e ) { </a> 1
<a> throw new ChannelException ( e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected SocketAddress remoteAddress0 ( ) { </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void doBind ( SocketAddress localAddress ) throws Exception { </a> 1
<a> AsynchronousServerSocketChannel ch = javaChannel ( ) ; </a> 1
<a> ch . bind ( localAddress ) ; </a> 1
<a> doAccept ( ) ; </a> 1
<a> } </a> 1
<a> private void doAccept ( ) { </a> 1
<a> if ( readSuspended . get ( ) ) { </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> javaChannel ( ) . accept ( this , ACCEPT_HANDLER ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void doClose ( ) throws Exception { </a> 1
<a> if ( ! closed ) { </a> 1
<a> closed = true ; </a> 1
<a> javaChannel ( ) . close ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected boolean isFlushPending ( ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void doConnect ( </a> 1
<a> SocketAddress remoteAddress , SocketAddress localAddress , ChannelFuture future ) { </a> 0
<a> future . setFailure ( new UnsupportedOperationException ( ) ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void doDisconnect ( ) throws Exception { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected Runnable doRegister ( ) throws Exception { </a> 1
<a> return super . doRegister ( ) ; </a> 0
<a> } </a> 1
<a> private static final class AcceptHandler </a> 1
<a> extends AioCompletionHandler < AsynchronousSocketChannel , AioServerSocketChannel > { </a> 1
<a> @ Override </a> 1
<a> protected void completed0 ( AsynchronousSocketChannel ch , AioServerSocketChannel channel ) { </a> 1
<a> channel . doAccept ( ) ; </a> 1
<a> channel . pipeline ( ) . inboundMessageBuffer ( ) . add ( </a> 1
<a> new AioSocketChannel ( channel , null , channel . childGroup , ch ) ) ; </a> 0
<a> if ( ! channel . readSuspended . get ( ) ) { </a> 1
<a> channel . pipeline ( ) . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void failed0 ( Throwable t , AioServerSocketChannel channel ) { </a> 1
<a> boolean asyncClosed = false ; </a> 1
<a> if ( t instanceof AsynchronousCloseException ) { </a> 1
<a> asyncClosed = true ; </a> 1
<a> channel . closed = true ; </a> 1
<a> } </a> 1
<a> if ( channel . isOpen ( ) && ! asyncClosed ) { </a> 1
<a> logger . warn ( "Failed to create a new channel from an accepted socket." , t ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ServerSocketChannelConfig config ( ) { </a> 1
<a> return config ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected Unsafe newUnsafe ( ) { </a> 0
<a> return new AioServerSocketUnsafe ( ) ; </a> 1
<a> } </a> 1
<a> private final class AioServerSocketUnsafe extends AbstractAioUnsafe { </a> 1
<a> @ Override </a> 1
<a> public void suspendRead ( ) { </a> 1
<a> readSuspended . set ( true ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void resumeRead ( ) { </a> 1
<a> if ( readSuspended . compareAndSet ( true , false ) ) { </a> 1
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 1
<a> doAccept ( ) ; </a> 1
<a> } else { </a> 1
<a> eventLoop ( ) . execute ( acceptTask ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . aio ; </a> 0
<a> import static io . netty . channel . ChannelOption . * ; </a> 1
<a> import io . netty . channel . ChannelException ; </a> 1
<a> import io . netty . channel . ChannelOption ; </a> 1
<a> import io . netty . channel . DefaultChannelConfig ; </a> 1
<a> import io . netty . channel . socket . ServerSocketChannelConfig ; </a> 1
<a> import io . netty . util . NetworkConstants ; </a> 0
<a> import java . io . IOException ; </a> 1
<a> import java . net . StandardSocketOptions ; </a> 1
<a> import java . nio . channels . AsynchronousServerSocketChannel ; </a> 1
<a> import java . util . Map ; </a> 1
<a> final class AioServerSocketChannelConfig extends DefaultChannelConfig </a> 1
<a> implements ServerSocketChannelConfig { </a> 1
<a> private final AsynchronousServerSocketChannel channel ; </a> 0
<a> private volatile int backlog = NetworkConstants . SOMAXCONN ; </a> 0
<a> AioServerSocketChannelConfig ( AsynchronousServerSocketChannel channel ) { </a> 0
<a> this . channel = channel ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public Map < ChannelOption < ? > , Object > getOptions ( ) { </a> 1
<a> return getOptions ( super . getOptions ( ) , SO_RCVBUF , SO_REUSEADDR , SO_BACKLOG ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> public < T > T getOption ( ChannelOption < T > option ) { </a> 1
<a> if ( option == SO_RCVBUF ) { </a> 1
<a> return ( T ) Integer . valueOf ( getReceiveBufferSize ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( option == SO_REUSEADDR ) { </a> 1
<a> return ( T ) Boolean . valueOf ( isReuseAddress ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( option == SO_BACKLOG ) { </a> 1
<a> return ( T ) Integer . valueOf ( getBacklog ( ) ) ; </a> 1
<a> } </a> 1
<a> return super . getOption ( option ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public < T > boolean setOption ( ChannelOption < T > option , T value ) { </a> 1
<a> validate ( option , value ) ; </a> 1
<a> if ( option == SO_RCVBUF ) { </a> 1
<a> setReceiveBufferSize ( ( Integer ) value ) ; </a> 1
<a> } else if ( option == SO_REUSEADDR ) { </a> 1
<a> setReuseAddress ( ( Boolean ) value ) ; </a> 1
<a> } else if ( option == SO_BACKLOG ) { </a> 1
<a> setBacklog ( ( Integer ) value ) ; </a> 1
<a> } else { </a> 1
<a> return super . setOption ( option , value ) ; </a> 1
<a> } </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isReuseAddress ( ) { </a> 1
<a> try { </a> 0
<a> return channel . getOption ( StandardSocketOptions . SO_REUSEADDR ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> throw new ChannelException ( e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setReuseAddress ( boolean reuseAddress ) { </a> 0
<a> try { </a> 0
<a> channel . setOption ( StandardSocketOptions . SO_REUSEADDR , reuseAddress ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getReceiveBufferSize ( ) { </a> 1
<a> try { </a> 0
<a> return channel . getOption ( StandardSocketOptions . SO_RCVBUF ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setReceiveBufferSize ( int receiveBufferSize ) { </a> 0
<a> try { </a> 0
<a> channel . setOption ( StandardSocketOptions . SO_RCVBUF , receiveBufferSize ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> throw new ChannelException ( e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setPerformancePreferences ( int connectionTime , int latency , int bandwidth ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getBacklog ( ) { </a> 1
<a> return backlog ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setBacklog ( int backlog ) { </a> 0
<a> if ( backlog < 0 ) { </a> 1
<a> throw new IllegalArgumentException ( "backlog: " + backlog ) ; </a> 1
<a> } </a> 1
<a> this . backlog = backlog ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . aio ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 1
<a> import io . netty . buffer . ChannelBufType ; </a> 1
<a> import io . netty . channel . ChannelException ; </a> 1
<a> import io . netty . channel . ChannelFlushFutureNotifier ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 1
<a> import io . netty . channel . ChannelMetadata ; </a> 1
<a> import io . netty . channel . ChannelPipeline ; </a> 1
<a> import io . netty . channel . socket . SocketChannel ; </a> 1
<a> import java . io . IOException ; </a> 1
<a> import java . net . InetSocketAddress ; </a> 1
<a> import java . net . SocketAddress ; </a> 1
<a> import java . nio . ByteBuffer ; </a> 1
<a> import java . nio . channels . AsynchronousChannelGroup ; </a> 1
<a> import java . nio . channels . AsynchronousSocketChannel ; </a> 1
<a> import java . nio . channels . ClosedChannelException ; </a> 1
<a> import java . nio . channels . CompletionHandler ; </a> 1
<a> import java . nio . channels . InterruptedByTimeoutException ; </a> 1
<a> import java . util . concurrent . TimeUnit ; </a> 1
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 1
<a> public class AioSocketChannel extends AbstractAioChannel implements SocketChannel { </a> 1
<a> private static final ChannelMetadata METADATA = new ChannelMetadata ( ChannelBufType . BYTE , false ) ; </a> 1
<a> private static final CompletionHandler < Void , AioSocketChannel > CONNECT_HANDLER = new ConnectHandler ( ) ; </a> 1
<a> private static final CompletionHandler < Integer , AioSocketChannel > WRITE_HANDLER = new WriteHandler < Integer > ( ) ; </a> 1
<a> private static final CompletionHandler < Integer , AioSocketChannel > READ_HANDLER = new ReadHandler < Integer > ( ) ; </a> 1
<a> private static final CompletionHandler < Long , AioSocketChannel > GATHERING_WRITE_HANDLER = new WriteHandler < Long > ( ) ; </a> 1
<a> private static final CompletionHandler < Long , AioSocketChannel > SCATTERING_READ_HANDLER = new ReadHandler < Long > ( ) ; </a> 1
<a> private static AsynchronousSocketChannel newSocket ( AsynchronousChannelGroup group ) { </a> 1
<a> try { </a> 1
<a> return AsynchronousSocketChannel . open ( group ) ; </a> 1
<a> } catch ( IOException e ) { </a> 1
<a> throw new ChannelException ( "Failed to open a socket." , e ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> private final AioSocketChannelConfig config ; </a> 1
<a> private boolean flushing ; </a> 0
<a> private final AtomicBoolean readSuspended = new AtomicBoolean ( ) ; </a> 1
<a> private final AtomicBoolean readInProgress = new AtomicBoolean ( ) ; </a> 0
<a> private final Runnable readTask = new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> AioSocketChannel . this . beginRead ( ) ; </a> 0
<a> } </a> 1
<a> } ; </a> 1
<a> public AioSocketChannel ( AioEventLoopGroup eventLoop ) { </a> 0
<a> this ( null , null , eventLoop , newSocket ( eventLoop . group ) ) ; </a> 0
<a> } </a> 1
<a> AioSocketChannel ( </a> 1
<a> AioServerSocketChannel parent , Integer id , </a> 0
<a> AioEventLoopGroup eventLoop , AsynchronousSocketChannel ch ) { </a> 0
<a> super ( parent , id , eventLoop , ch ) ; </a> 0
<a> config = new AioSocketChannelConfig ( ch ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isActive ( ) { </a> 1
<a> return javaChannel ( ) . isOpen ( ) && remoteAddress0 ( ) != null ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> protected AsynchronousSocketChannel javaChannel ( ) { </a> 1
<a> return ( AsynchronousSocketChannel ) super . javaChannel ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelMetadata metadata ( ) { </a> 1
<a> return METADATA ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void doConnect ( SocketAddress remoteAddress , SocketAddress localAddress , final ChannelFuture future ) { </a> 0
<a> if ( localAddress != null ) { </a> 1
<a> try { </a> 1
<a> javaChannel ( ) . bind ( localAddress ) ; </a> 1
<a> } catch ( IOException e ) { </a> 1
<a> future . setFailure ( e ) ; </a> 0
<a> return ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> javaChannel ( ) . connect ( remoteAddress , this , CONNECT_HANDLER ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected InetSocketAddress localAddress0 ( ) { </a> 1
<a> try { </a> 1
<a> return ( InetSocketAddress ) javaChannel ( ) . getLocalAddress ( ) ; </a> 1
<a> } catch ( IOException e ) { </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected InetSocketAddress remoteAddress0 ( ) { </a> 1
<a> try { </a> 1
<a> return ( InetSocketAddress ) javaChannel ( ) . getRemoteAddress ( ) ; </a> 1
<a> } catch ( IOException e ) { </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected Runnable doRegister ( ) throws Exception { </a> 1
<a> super . doRegister ( ) ; </a> 1
<a> if ( remoteAddress ( ) == null ) { </a> 1
<a> return null ; </a> 1
<a> } </a> 1
<a> return new Runnable ( ) { </a> 1
<a> @ Override </a> 1
<a> public void run ( ) { </a> 1
<a> beginRead ( ) ; </a> 1
<a> } </a> 1
<a> } ; </a> 1
<a> } </a> 1
<a> private static void expandReadBuffer ( ByteBuf byteBuf ) { </a> 0
<a> final int writerIndex = byteBuf . writerIndex ( ) ; </a> 0
<a> final int capacity = byteBuf . capacity ( ) ; </a> 0
<a> if ( capacity != writerIndex ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> final int maxCapacity = byteBuf . maxCapacity ( ) ; </a> 0
<a> if ( capacity == maxCapacity ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> final int increment = 4096 ; </a> 0
<a> if ( writerIndex + increment > maxCapacity ) { </a> 0
<a> byteBuf . capacity ( maxCapacity ) ; </a> 0
<a> } else { </a> 0
<a> byteBuf . ensureWritableBytes ( increment ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> protected void doBind ( SocketAddress localAddress ) throws Exception { </a> 1
<a> javaChannel ( ) . bind ( localAddress ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void doDisconnect ( ) throws Exception { </a> 1
<a> doClose ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void doClose ( ) throws Exception { </a> 1
<a> javaChannel ( ) . close ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected boolean isFlushPending ( ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void doFlushByteBuffer ( ByteBuf buf ) throws Exception { </a> 1
<a> if ( flushing ) { </a> 0
<a> return ; </a> 1
<a> } </a> 1
<a> flushing = true ; </a> 0
<a> buf . discardReadBytes ( ) ; </a> 1
<a> if ( buf . readable ( ) ) { </a> 0
<a> if ( buf . hasNioBuffers ( ) ) { </a> 1
<a> ByteBuffer [ ] buffers = buf . nioBuffers ( buf . readerIndex ( ) , buf . readableBytes ( ) ) ; </a> 1
<a> javaChannel ( ) . write ( buffers , 0 , buffers . length , config . getReadTimeout ( ) , </a> 0
<a> TimeUnit . MILLISECONDS , AioSocketChannel . this , GATHERING_WRITE_HANDLER ) ; </a> 1
<a> } else { </a> 1
<a> javaChannel ( ) . write ( buf . nioBuffer ( ) , config . getReadTimeout ( ) , TimeUnit . MILLISECONDS , </a> 0
<a> this , WRITE_HANDLER ) ; </a> 0
<a> } </a> 1
<a> } else { </a> 1
<a> flushFutureNotifier . notifyFlushFutures ( ) ; </a> 1
<a> flushing = false ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> private void beginRead ( ) { </a> 1
<a> if ( readSuspended . get ( ) ) { </a> 0
<a> return ; </a> 1
<a> } </a> 1
<a> if ( ! readInProgress . compareAndSet ( false , true ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> ByteBuf byteBuf = pipeline ( ) . inboundByteBuffer ( ) ; </a> 1
<a> if ( ! byteBuf . readable ( ) ) { </a> 0
<a> byteBuf . discardReadBytes ( ) ; </a> 0
<a> } </a> 0
<a> expandReadBuffer ( byteBuf ) ; </a> 1
<a> if ( byteBuf . hasNioBuffers ( ) ) { </a> 1
<a> ByteBuffer [ ] buffers = byteBuf . nioBuffers ( byteBuf . writerIndex ( ) , byteBuf . writableBytes ( ) ) ; </a> 1
<a> javaChannel ( ) . read ( buffers , 0 , buffers . length , config . getWriteTimeout ( ) , </a> 0
<a> TimeUnit . MILLISECONDS , AioSocketChannel . this , SCATTERING_READ_HANDLER ) ; </a> 1
<a> } else { </a> 1
<a> ByteBuffer buffer = byteBuf . nioBuffer ( byteBuf . writerIndex ( ) , byteBuf . writableBytes ( ) ) ; </a> 1
<a> javaChannel ( ) . read ( buffer , config . getWriteTimeout ( ) , TimeUnit . MILLISECONDS , </a> 0
<a> AioSocketChannel . this , READ_HANDLER ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> private static final class WriteHandler < T extends Number > extends AioCompletionHandler < T , AioSocketChannel > { </a> 1
<a> @ Override </a> 1
<a> protected void completed0 ( T result , AioSocketChannel channel ) { </a> 1
<a> ByteBuf buf = channel . unsafe ( ) . directOutboundContext ( ) . outboundByteBuffer ( ) ; </a> 0
<a> int writtenBytes = result . intValue ( ) ; </a> 1
<a> if ( writtenBytes > 0 ) { </a> 1
<a> buf . readerIndex ( buf . readerIndex ( ) + writtenBytes ) ; </a> 1
<a> } </a> 0
<a> boolean empty = ! buf . readable ( ) ; </a> 0
<a> if ( empty ) { </a> 0
<a> buf . discardReadBytes ( ) ; </a> 0
<a> } </a> 1
<a> ChannelFlushFutureNotifier notifier = channel . flushFutureNotifier ; </a> 0
<a> notifier . increaseWriteCounter ( writtenBytes ) ; </a> 1
<a> notifier . notifyFlushFutures ( ) ; </a> 1
<a> channel . flushing = false ; </a> 0
<a> if ( ! channel . isActive ( ) ) { </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> if ( buf . readable ( ) ) { </a> 0
<a> try { </a> 0
<a> channel . doFlushByteBuffer ( buf ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> failed0 ( e , channel ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void failed0 ( Throwable cause , AioSocketChannel channel ) { </a> 1
<a> channel . flushFutureNotifier . notifyFlushFutures ( cause ) ; </a> 1
<a> channel . pipeline ( ) . fireExceptionCaught ( cause ) ; </a> 0
<a> if ( cause instanceof InterruptedByTimeoutException ) { </a> 1
<a> channel . unsafe ( ) . close ( channel . unsafe ( ) . voidFuture ( ) ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> ByteBuf buf = channel . unsafe ( ) . directOutboundContext ( ) . outboundByteBuffer ( ) ; </a> 0
<a> if ( ! buf . readable ( ) ) { </a> 0
<a> buf . discardReadBytes ( ) ; </a> 0
<a> } </a> 0
<a> channel . flushing = false ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> private static final class ReadHandler < T extends Number > extends AioCompletionHandler < T , AioSocketChannel > { </a> 1
<a> @ Override </a> 1
<a> protected void completed0 ( T result , AioSocketChannel channel ) { </a> 1
<a> final ChannelPipeline pipeline = channel . pipeline ( ) ; </a> 0
<a> final ByteBuf byteBuf = pipeline . inboundByteBuffer ( ) ; </a> 1
<a> boolean closed = false ; </a> 1
<a> boolean read = false ; </a> 1
<a> try { </a> 1
<a> int localReadAmount = result . intValue ( ) ; </a> 1
<a> if ( localReadAmount > 0 ) { </a> 1
<a> byteBuf . writerIndex ( byteBuf . writerIndex ( ) + localReadAmount ) ; </a> 1
<a> read = true ; </a> 1
<a> } else if ( localReadAmount < 0 ) { </a> 1
<a> closed = true ; </a> 1
<a> } </a> 1
<a> } catch ( Throwable t ) { </a> 1
<a> if ( read ) { </a> 1
<a> read = false ; </a> 1
<a> if ( ! channel . readSuspended . get ( ) ) { </a> 1
<a> pipeline . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> if ( ! ( t instanceof ClosedChannelException ) ) { </a> 1
<a> pipeline . fireExceptionCaught ( t ) ; </a> 1
<a> if ( t instanceof IOException ) { </a> 1
<a> channel . unsafe ( ) . close ( channel . unsafe ( ) . voidFuture ( ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } finally { </a> 1
<a> channel . readInProgress . set ( false ) ; </a> 0
<a> if ( read ) { </a> 1
<a> if ( ! channel . readSuspended . get ( ) ) { </a> 1
<a> pipeline . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> if ( closed && channel . isOpen ( ) ) { </a> 0
<a> channel . unsafe ( ) . close ( channel . unsafe ( ) . voidFuture ( ) ) ; </a> 0
<a> } else { </a> 1
<a> channel . beginRead ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void failed0 ( Throwable t , AioSocketChannel channel ) { </a> 1
<a> if ( t instanceof ClosedChannelException ) { </a> 1
<a> return ; </a> 1
<a> } </a> 1
<a> channel . pipeline ( ) . fireExceptionCaught ( t ) ; </a> 1
<a> if ( t instanceof IOException || t instanceof InterruptedByTimeoutException ) { </a> 1
<a> channel . unsafe ( ) . close ( channel . unsafe ( ) . voidFuture ( ) ) ; </a> 0
<a> } else { </a> 1
<a> channel . beginRead ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> private static final class ConnectHandler extends AioCompletionHandler < Void , AioSocketChannel > { </a> 1
<a> @ Override </a> 1
<a> protected void completed0 ( Void result , AioSocketChannel channel ) { </a> 1
<a> ( ( AbstractAioUnsafe ) channel . unsafe ( ) ) . connectSuccess ( ) ; </a> 1
<a> channel . pipeline ( ) . fireChannelActive ( ) ; </a> 1
<a> channel . beginRead ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void failed0 ( Throwable exc , AioSocketChannel channel ) { </a> 1
<a> ( ( AbstractAioUnsafe ) channel . unsafe ( ) ) . connectFailed ( exc ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public AioSocketChannelConfig config ( ) { </a> 0
<a> return config ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected Unsafe newUnsafe ( ) { </a> 0
<a> return new AioSocketChannelAsyncUnsafe ( ) ; </a> 1
<a> } </a> 1
<a> private final class AioSocketChannelAsyncUnsafe extends AbstractAioUnsafe { </a> 1
<a> @ Override </a> 1
<a> public void suspendRead ( ) { </a> 1
<a> readSuspended . set ( true ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void resumeRead ( ) { </a> 1
<a> if ( readSuspended . compareAndSet ( true , false ) ) { </a> 1
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 1
<a> beginRead ( ) ; </a> 1
<a> } else { </a> 1
<a> eventLoop ( ) . execute ( readTask ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . aio ; </a> 0
<a> import static io . netty . channel . ChannelOption . * ; </a> 1
<a> import io . netty . channel . ChannelException ; </a> 1
<a> import io . netty . channel . ChannelOption ; </a> 1
<a> import io . netty . channel . DefaultChannelConfig ; </a> 1
<a> import io . netty . channel . socket . SocketChannelConfig ; </a> 1
<a> import java . io . IOException ; </a> 1
<a> import java . net . StandardSocketOptions ; </a> 1
<a> import java . nio . channels . InterruptedByTimeoutException ; </a> 1
<a> import java . nio . channels . NetworkChannel ; </a> 0
<a> import java . util . Map ; </a> 0
<a> final class AioSocketChannelConfig extends DefaultChannelConfig </a> 0
<a> implements SocketChannelConfig { </a> 0
<a> private final NetworkChannel channel ; </a> 0
<a> private volatile long readTimeoutInMillis ; </a> 1
<a> private volatile long writeTimeoutInMillis ; </a> 1
<a> AioSocketChannelConfig ( NetworkChannel channel ) { </a> 0
<a> if ( channel == null ) { </a> 0
<a> throw new NullPointerException ( "channel" ) ; </a> 0
<a> } </a> 0
<a> this . channel = channel ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public Map < ChannelOption < ? > , Object > getOptions ( ) { </a> 1
<a> return getOptions ( </a> 1
<a> super . getOptions ( ) , </a> 1
<a> SO_RCVBUF , SO_SNDBUF , TCP_NODELAY , SO_KEEPALIVE , SO_REUSEADDR , SO_LINGER , IP_TOS , </a> 1
<a> AIO_READ_TIMEOUT , AIO_WRITE_TIMEOUT ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> @ SuppressWarnings ( "unchecked" ) </a> 0
<a> public < T > T getOption ( ChannelOption < T > option ) { </a> 1
<a> if ( option == SO_RCVBUF ) { </a> 1
<a> return ( T ) Integer . valueOf ( getReceiveBufferSize ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( option == SO_SNDBUF ) { </a> 1
<a> return ( T ) Integer . valueOf ( getSendBufferSize ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( option == TCP_NODELAY ) { </a> 1
<a> return ( T ) Boolean . valueOf ( isTcpNoDelay ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( option == SO_KEEPALIVE ) { </a> 1
<a> return ( T ) Boolean . valueOf ( isKeepAlive ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( option == SO_REUSEADDR ) { </a> 1
<a> return ( T ) Boolean . valueOf ( isReuseAddress ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( option == SO_LINGER ) { </a> 1
<a> return ( T ) Integer . valueOf ( getSoLinger ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( option == IP_TOS ) { </a> 1
<a> return ( T ) Integer . valueOf ( getTrafficClass ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( option == AIO_READ_TIMEOUT ) { </a> 1
<a> return ( T ) Long . valueOf ( getReadTimeout ( ) ) ; </a> 1
<a> } </a> 1
<a> if ( option == AIO_WRITE_TIMEOUT ) { </a> 1
<a> return ( T ) Long . valueOf ( getWriteTimeout ( ) ) ; </a> 1
<a> } </a> 1
<a> return super . getOption ( option ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public < T > boolean setOption ( ChannelOption < T > option , T value ) { </a> 1
<a> validate ( option , value ) ; </a> 1
<a> if ( option == SO_RCVBUF ) { </a> 1
<a> setReceiveBufferSize ( ( Integer ) value ) ; </a> 1
<a> } else if ( option == SO_SNDBUF ) { </a> 1
<a> setSendBufferSize ( ( Integer ) value ) ; </a> 1
<a> } else if ( option == TCP_NODELAY ) { </a> 1
<a> setTcpNoDelay ( ( Boolean ) value ) ; </a> 1
<a> } else if ( option == SO_KEEPALIVE ) { </a> 1
<a> setKeepAlive ( ( Boolean ) value ) ; </a> 1
<a> } else if ( option == SO_REUSEADDR ) { </a> 1
<a> setReuseAddress ( ( Boolean ) value ) ; </a> 1
<a> } else if ( option == SO_LINGER ) { </a> 1
<a> setSoLinger ( ( Integer ) value ) ; </a> 1
<a> } else if ( option == IP_TOS ) { </a> 1
<a> setTrafficClass ( ( Integer ) value ) ; </a> 1
<a> } else if ( option == AIO_READ_TIMEOUT ) { </a> 1
<a> setReadTimeout ( ( Long ) value ) ; </a> 1
<a> } else if ( option == AIO_WRITE_TIMEOUT ) { </a> 1
<a> setWriteTimeout ( ( Long ) value ) ; </a> 1
<a> } else { </a> 1
<a> return super . setOption ( option , value ) ; </a> 1
<a> } </a> 1
<a> return true ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getReceiveBufferSize ( ) { </a> 1
<a> try { </a> 0
<a> return channel . getOption ( StandardSocketOptions . SO_RCVBUF ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getSendBufferSize ( ) { </a> 1
<a> try { </a> 0
<a> return channel . getOption ( StandardSocketOptions . SO_SNDBUF ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getSoLinger ( ) { </a> 1
<a> try { </a> 0
<a> return channel . getOption ( StandardSocketOptions . SO_LINGER ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public int getTrafficClass ( ) { </a> 1
<a> try { </a> 0
<a> return channel . getOption ( StandardSocketOptions . IP_TOS ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isKeepAlive ( ) { </a> 1
<a> try { </a> 0
<a> return channel . getOption ( StandardSocketOptions . SO_KEEPALIVE ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isReuseAddress ( ) { </a> 1
<a> try { </a> 0
<a> return channel . getOption ( StandardSocketOptions . SO_REUSEADDR ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> throw new ChannelException ( e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isTcpNoDelay ( ) { </a> 1
<a> try { </a> 0
<a> return channel . getOption ( StandardSocketOptions . SO_REUSEADDR ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setKeepAlive ( boolean keepAlive ) { </a> 0
<a> try { </a> 0
<a> channel . setOption ( StandardSocketOptions . SO_KEEPALIVE , keepAlive ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void setPerformancePreferences ( </a> 0
<a> int connectionTime , int latency , int bandwidth ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void setReceiveBufferSize ( int receiveBufferSize ) { </a> 0
<a> try { </a> 0
<a> channel . setOption ( StandardSocketOptions . SO_RCVBUF , receiveBufferSize ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void setReuseAddress ( boolean reuseAddress ) { </a> 0
<a> try { </a> 0
<a> channel . setOption ( StandardSocketOptions . SO_REUSEADDR , reuseAddress ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void setSendBufferSize ( int sendBufferSize ) { </a> 0
<a> try { </a> 0
<a> channel . setOption ( StandardSocketOptions . SO_SNDBUF , sendBufferSize ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void setSoLinger ( int soLinger ) { </a> 0
<a> try { </a> 0
<a> channel . setOption ( StandardSocketOptions . SO_LINGER , soLinger ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> public void setTcpNoDelay ( boolean tcpNoDelay ) { </a> 0
<a> try { </a> 1
<a> channel . setOption ( StandardSocketOptions . TCP_NODELAY , tcpNoDelay ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setTrafficClass ( int trafficClass ) { </a> 0
<a> try { </a> 0
<a> channel . setOption ( StandardSocketOptions . IP_TOS , trafficClass ) ; </a> 0
<a> } catch ( IOException e ) { </a> 1
<a> throw new ChannelException ( e ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> public void setReadTimeout ( long readTimeoutInMillis ) { </a> 0
<a> if ( readTimeoutInMillis < 0 ) { </a> 1
<a> throw new IllegalArgumentException ( "readTimeoutInMillis: " + readTimeoutInMillis ) ; </a> 1
<a> } </a> 1
<a> this . readTimeoutInMillis = readTimeoutInMillis ; </a> 1
<a> } </a> 0
<a> public void setWriteTimeout ( long writeTimeoutInMillis ) { </a> 0
<a> if ( writeTimeoutInMillis < 0 ) { </a> 1
<a> throw new IllegalArgumentException ( "writeTimeoutInMillis: " + writeTimeoutInMillis ) ; </a> 1
<a> } </a> 1
<a> this . writeTimeoutInMillis = writeTimeoutInMillis ; </a> 1
<a> } </a> 0
<a> public long getReadTimeout ( ) { </a> 1
<a> return readTimeoutInMillis ; </a> 1
<a> } </a> 1
<a> public long getWriteTimeout ( ) { </a> 1
<a> return writeTimeoutInMillis ; </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . nio ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . nio . channels . SelectableChannel ; </a> 0
<a> import java . nio . channels . SelectionKey ; </a> 0
<a> abstract class AbstractNioByteChannel extends AbstractNioChannel { </a> 0
<a> protected AbstractNioByteChannel ( </a> 0
<a> Channel parent , Integer id , SelectableChannel ch ) { </a> 0
<a> super ( parent , id , ch , SelectionKey . OP_READ ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected abstract AbstractNioByteUnsafe newUnsafe ( ) ; </a> 1
<a> abstract class AbstractNioByteUnsafe extends AbstractNioUnsafe { </a> 1
<a> @ Override </a> 0
<a> public void read ( ) { </a> 0
<a> assert eventLoop ( ) . inEventLoop ( ) ; </a> 0
<a> final ChannelPipeline pipeline = pipeline ( ) ; </a> 0
<a> final ByteBuf byteBuf = pipeline . inboundByteBuffer ( ) ; </a> 1
<a> boolean closed = false ; </a> 0
<a> boolean read = false ; </a> 1
<a> try { </a> 0
<a> expandReadBuffer ( byteBuf ) ; </a> 1
<a> loop : for ( ; ; ) { </a> 1
<a> int localReadAmount = doReadBytes ( byteBuf ) ; </a> 0
<a> if ( localReadAmount > 0 ) { </a> 1
<a> read = true ; </a> 1
<a> } else if ( localReadAmount < 0 ) { </a> 1
<a> closed = true ; </a> 0
<a> break ; </a> 1
<a> } </a> 1
<a> switch ( expandReadBuffer ( byteBuf ) ) { </a> 1
<a> case 0 : </a> 1
<a> break loop ; </a> 1
<a> case 1 : </a> 1
<a> break ; </a> 1
<a> case 2 : </a> 1
<a> if ( read ) { </a> 0
<a> read = false ; </a> 0
<a> pipeline . fireInboundBufferUpdated ( ) ; </a> 0
<a> if ( ! byteBuf . writable ( ) ) { </a> 0
<a> throw new IllegalStateException ( </a> 1
<a> "an inbound handler whose buffer is full must consume at " + </a> 1
<a> "least one byte." ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( read ) { </a> 0
<a> read = false ; </a> 0
<a> pipeline . fireInboundBufferUpdated ( ) ; </a> 0
<a> } </a> 0
<a> pipeline ( ) . fireExceptionCaught ( t ) ; </a> 0
<a> if ( t instanceof IOException ) { </a> 1
<a> close ( voidFuture ( ) ) ; </a> 1
<a> } </a> 1
<a> } finally { </a> 1
<a> if ( read ) { </a> 1
<a> pipeline . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> if ( closed && isOpen ( ) ) { </a> 0
<a> close ( voidFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doFlushByteBuffer ( ByteBuf buf ) throws Exception { </a> 1
<a> if ( ! buf . readable ( ) ) { </a> 0
<a> buf . clear ( ) ; </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> for ( int i = config ( ) . getWriteSpinCount ( ) - 1 ; i >= 0 ; i -- ) { </a> 0
<a> int localFlushedAmount = doWriteBytes ( buf , i == 0 ) ; </a> 1
<a> if ( localFlushedAmount > 0 ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( ! buf . readable ( ) ) { </a> 0
<a> buf . clear ( ) ; </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected abstract int doReadBytes ( ByteBuf buf ) throws Exception ; </a> 0
<a> protected abstract int doWriteBytes ( ByteBuf buf , boolean lastSpin ) throws Exception ; </a> 0
<a> private static int expandReadBuffer ( ByteBuf byteBuf ) { </a> 0
<a> final int writerIndex = byteBuf . writerIndex ( ) ; </a> 1
<a> final int capacity = byteBuf . capacity ( ) ; </a> 1
<a> if ( capacity != writerIndex ) { </a> 1
<a> return 0 ; </a> 1
<a> } </a> 1
<a> final int maxCapacity = byteBuf . maxCapacity ( ) ; </a> 1
<a> if ( capacity == maxCapacity ) { </a> 1
<a> return 2 ; </a> 1
<a> } </a> 1
<a> final int increment = 4096 ; </a> 1
<a> if ( writerIndex + increment > maxCapacity ) { </a> 0
<a> byteBuf . capacity ( maxCapacity ) ; </a> 1
<a> } else { </a> 1
<a> byteBuf . ensureWritableBytes ( increment ) ; </a> 0
<a> } </a> 0
<a> return 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . nio ; </a> 0
<a> import io . netty . channel . AbstractChannel ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . EventLoop ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . ConnectException ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . nio . channels . SelectableChannel ; </a> 0
<a> import java . nio . channels . SelectionKey ; </a> 0
<a> import java . util . concurrent . ScheduledFuture ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> public abstract class AbstractNioChannel extends AbstractChannel { </a> 0
<a> private static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( AbstractNioChannel . class ) ; </a> 0
<a> private final SelectableChannel ch ; </a> 0
<a> private final int defaultInterestOps ; </a> 1
<a> private volatile SelectionKey selectionKey ; </a> 1
<a> private ChannelFuture connectFuture ; </a> 0
<a> private ScheduledFuture < ? > connectTimeoutFuture ; </a> 0
<a> private ConnectException connectTimeoutException ; </a> 1
<a> protected AbstractNioChannel ( </a> 0
<a> Channel parent , Integer id , SelectableChannel ch , int defaultInterestOps ) { </a> 1
<a> super ( parent , id ) ; </a> 0
<a> this . ch = ch ; </a> 0
<a> this . defaultInterestOps = defaultInterestOps ; </a> 1
<a> try { </a> 0
<a> ch . configureBlocking ( false ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> try { </a> 0
<a> ch . close ( ) ; </a> 0
<a> } catch ( IOException e2 ) { </a> 0
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( </a> 0
<a> "Failed to close a partially initialized socket." , e2 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> throw new ChannelException ( "Failed to enter non-blocking mode." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isOpen ( ) { </a> 0
<a> return ch . isOpen ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public InetSocketAddress localAddress ( ) { </a> 0
<a> return ( InetSocketAddress ) super . localAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public InetSocketAddress remoteAddress ( ) { </a> 0
<a> return ( InetSocketAddress ) super . remoteAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public NioUnsafe unsafe ( ) { </a> 0
<a> return ( NioUnsafe ) super . unsafe ( ) ; </a> 0
<a> } </a> 0
<a> protected SelectableChannel javaChannel ( ) { </a> 0
<a> return ch ; </a> 0
<a> } </a> 0
<a> protected SelectionKey selectionKey ( ) { </a> 0
<a> assert selectionKey != null ; </a> 0
<a> return selectionKey ; </a> 0
<a> } </a> 0
<a> public interface NioUnsafe extends Unsafe { </a> 0
<a> java . nio . channels . Channel ch ( ) ; </a> 0
<a> void finishConnect ( ) ; </a> 0
<a> void read ( ) ; </a> 0
<a> } </a> 0
<a> protected abstract class AbstractNioUnsafe extends AbstractUnsafe implements NioUnsafe { </a> 0
<a> @ Override </a> 0
<a> public java . nio . channels . Channel ch ( ) { </a> 0
<a> return javaChannel ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void connect ( </a> 0
<a> final SocketAddress remoteAddress , final SocketAddress localAddress , final ChannelFuture future ) { </a> 0
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> if ( ! ensureOpen ( future ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> if ( connectFuture != null ) { </a> 0
<a> throw new IllegalStateException ( "connection attempt already made" ) ; </a> 0
<a> } </a> 0
<a> boolean wasActive = isActive ( ) ; </a> 0
<a> if ( doConnect ( remoteAddress , localAddress ) ) { </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> if ( ! wasActive && isActive ( ) ) { </a> 0
<a> pipeline ( ) . fireChannelActive ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> connectFuture = future ; </a> 0
<a> int connectTimeoutMillis = config ( ) . getConnectTimeoutMillis ( ) ; </a> 0
<a> if ( connectTimeoutMillis > 0 ) { </a> 0
<a> connectTimeoutFuture = eventLoop ( ) . schedule ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> if ( connectTimeoutException == null ) { </a> 0
<a> connectTimeoutException = new ConnectException ( "connection timed out" ) ; </a> 0
<a> } </a> 0
<a> ChannelFuture connectFuture = AbstractNioChannel . this . connectFuture ; </a> 0
<a> if ( connectFuture != null && connectFuture . setFailure ( connectTimeoutException ) ) { </a> 0
<a> pipeline ( ) . fireExceptionCaught ( connectTimeoutException ) ; </a> 0
<a> close ( voidFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , connectTimeoutMillis , TimeUnit . MILLISECONDS ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> future . setFailure ( t ) ; </a> 0
<a> pipeline ( ) . fireExceptionCaught ( t ) ; </a> 0
<a> closeIfClosed ( ) ; </a> 0
<a> } </a> 0
<a> } else { </a> 0
<a> eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> connect ( remoteAddress , localAddress , future ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void finishConnect ( ) { </a> 0
<a> assert eventLoop ( ) . inEventLoop ( ) ; </a> 0
<a> assert connectFuture != null ; </a> 0
<a> try { </a> 0
<a> boolean wasActive = isActive ( ) ; </a> 0
<a> doFinishConnect ( ) ; </a> 0
<a> connectFuture . setSuccess ( ) ; </a> 0
<a> if ( ! wasActive && isActive ( ) ) { </a> 0
<a> pipeline ( ) . fireChannelActive ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> connectFuture . setFailure ( t ) ; </a> 0
<a> pipeline ( ) . fireExceptionCaught ( t ) ; </a> 0
<a> closeIfClosed ( ) ; </a> 1
<a> } finally { </a> 0
<a> connectTimeoutFuture . cancel ( false ) ; </a> 0
<a> connectFuture = null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isCompatible ( EventLoop loop ) { </a> 0
<a> return loop instanceof NioEventLoop ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isFlushPending ( ) { </a> 0
<a> SelectionKey selectionKey = this . selectionKey ; </a> 0
<a> return selectionKey . isValid ( ) && ( selectionKey . interestOps ( ) & SelectionKey . OP_WRITE ) != 0 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected Runnable doRegister ( ) throws Exception { </a> 0
<a> NioEventLoop loop = ( NioEventLoop ) eventLoop ( ) ; </a> 1
<a> selectionKey = javaChannel ( ) . register ( </a> 1
<a> loop . selector , isActive ( ) ? defaultInterestOps : 0 , this ) ; </a> 1
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDeregister ( ) throws Exception { </a> 1
<a> ( ( NioEventLoop ) eventLoop ( ) ) . cancel ( selectionKey ( ) ) ; </a> 1
<a> } </a> 0
<a> protected abstract boolean doConnect ( SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception ; </a> 0
<a> protected abstract void doFinishConnect ( ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . nio ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . nio . channels . SelectableChannel ; </a> 0
<a> abstract class AbstractNioMessageChannel extends AbstractNioChannel { </a> 0
<a> protected AbstractNioMessageChannel ( </a> 0
<a> Channel parent , Integer id , SelectableChannel ch , int defaultInterestOps ) { </a> 1
<a> super ( parent , id , ch , defaultInterestOps ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> protected abstract AbstractNioMessageUnsafe newUnsafe ( ) ; </a> 1
<a> abstract class AbstractNioMessageUnsafe extends AbstractNioUnsafe { </a> 1
<a> @ Override </a> 0
<a> public void read ( ) { </a> 0
<a> assert eventLoop ( ) . inEventLoop ( ) ; </a> 0
<a> final ChannelPipeline pipeline = pipeline ( ) ; </a> 0
<a> final MessageBuf < Object > msgBuf = pipeline . inboundMessageBuffer ( ) ; </a> 1
<a> boolean closed = false ; </a> 0
<a> boolean read = false ; </a> 1
<a> try { </a> 0
<a> for ( ; ; ) { </a> 0
<a> int localReadAmount = doReadMessages ( msgBuf ) ; </a> 0
<a> if ( localReadAmount > 0 ) { </a> 0
<a> read = true ; </a> 0
<a> } else if ( localReadAmount == 0 ) { </a> 0
<a> break ; </a> 0
<a> } else if ( localReadAmount < 0 ) { </a> 1
<a> closed = true ; </a> 0
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( read ) { </a> 0
<a> read = false ; </a> 0
<a> pipeline . fireInboundBufferUpdated ( ) ; </a> 0
<a> } </a> 0
<a> pipeline ( ) . fireExceptionCaught ( t ) ; </a> 1
<a> if ( t instanceof IOException ) { </a> 1
<a> close ( voidFuture ( ) ) ; </a> 1
<a> } </a> 1
<a> } finally { </a> 1
<a> if ( read ) { </a> 1
<a> pipeline . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> if ( closed && isOpen ( ) ) { </a> 1
<a> close ( voidFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> @ Override </a> 0
<a> protected void doFlushMessageBuffer ( MessageBuf < Object > buf ) throws Exception { </a> 1
<a> final int writeSpinCount = config ( ) . getWriteSpinCount ( ) - 1 ; </a> 0
<a> while ( ! buf . isEmpty ( ) ) { </a> 1
<a> boolean wrote = false ; </a> 1
<a> for ( int i = writeSpinCount ; i >= 0 ; i -- ) { </a> 0
<a> int localFlushedAmount = doWriteMessages ( buf , i == 0 ) ; </a> 1
<a> if ( localFlushedAmount > 0 ) { </a> 1
<a> wrote = true ; </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> if ( ! wrote ) { </a> 1
<a> break ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> protected abstract int doReadMessages ( MessageBuf < Object > buf ) throws Exception ; </a> 1
<a> protected abstract int doWriteMessages ( MessageBuf < Object > buf , boolean lastSpin ) throws Exception ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . nio ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ChannelBufType ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelMetadata ; </a> 0
<a> import io . netty . channel . socket . DatagramChannelConfig ; </a> 0
<a> import io . netty . channel . socket . DatagramPacket ; </a> 0
<a> import io . netty . channel . socket . InternetProtocolFamily ; </a> 0
<a> import io . netty . util . internal . DetectionUtil ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> import java . net . InetAddress ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . net . NetworkInterface ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . net . SocketException ; </a> 0
<a> import java . nio . ByteBuffer ; </a> 0
<a> import java . nio . channels . DatagramChannel ; </a> 0
<a> import java . nio . channels . MembershipKey ; </a> 0
<a> import java . nio . channels . SelectionKey ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . HashMap ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . List ; </a> 0
<a> import java . util . Map ; </a> 0
<a> public final class NioDatagramChannel </a> 0
<a> extends AbstractNioMessageChannel implements io . netty . channel . socket . DatagramChannel { </a> 0
<a> private static final ChannelMetadata METADATA = new ChannelMetadata ( ChannelBufType . MESSAGE , true ) ; </a> 0
<a> private final DatagramChannelConfig config ; </a> 0
<a> private final Map < InetAddress , List < MembershipKey > > memberships = </a> 0
<a> new HashMap < InetAddress , List < MembershipKey > > ( ) ; </a> 0
<a> private static DatagramChannel newSocket ( ) { </a> 0
<a> try { </a> 0
<a> return DatagramChannel . open ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( "Failed to open a socket." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static DatagramChannel newSocket ( InternetProtocolFamily ipFamily ) { </a> 0
<a> if ( ipFamily == null ) { </a> 0
<a> return newSocket ( ) ; </a> 0
<a> } </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> return DatagramChannel . open ( ProtocolFamilyConverter . convert ( ipFamily ) ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( "Failed to open a socket." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public NioDatagramChannel ( ) { </a> 0
<a> this ( newSocket ( ) ) ; </a> 0
<a> } </a> 0
<a> public NioDatagramChannel ( InternetProtocolFamily ipFamily ) { </a> 0
<a> this ( newSocket ( ipFamily ) ) ; </a> 0
<a> } </a> 0
<a> public NioDatagramChannel ( DatagramChannel socket ) { </a> 0
<a> this ( null , socket ) ; </a> 0
<a> } </a> 0
<a> public NioDatagramChannel ( Integer id , DatagramChannel socket ) { </a> 0
<a> super ( null , id , socket , SelectionKey . OP_READ ) ; </a> 0
<a> config = new NioDatagramChannelConfig ( socket ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelMetadata metadata ( ) { </a> 0
<a> return METADATA ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public DatagramChannelConfig config ( ) { </a> 0
<a> return config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isActive ( ) { </a> 0
<a> DatagramChannel ch = javaChannel ( ) ; </a> 0
<a> return ch . isOpen ( ) && ch . socket ( ) . isBound ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isConnected ( ) { </a> 0
<a> return javaChannel ( ) . isConnected ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected DatagramChannel javaChannel ( ) { </a> 0
<a> return ( DatagramChannel ) super . javaChannel ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress localAddress0 ( ) { </a> 0
<a> return javaChannel ( ) . socket ( ) . getLocalSocketAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress remoteAddress0 ( ) { </a> 0
<a> return javaChannel ( ) . socket ( ) . getRemoteSocketAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doBind ( SocketAddress localAddress ) throws Exception { </a> 0
<a> javaChannel ( ) . socket ( ) . bind ( localAddress ) ; </a> 0
<a> selectionKey ( ) . interestOps ( SelectionKey . OP_READ ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean doConnect ( SocketAddress remoteAddress , </a> 0
<a> SocketAddress localAddress ) throws Exception { </a> 0
<a> if ( localAddress != null ) { </a> 0
<a> javaChannel ( ) . socket ( ) . bind ( localAddress ) ; </a> 0
<a> } </a> 0
<a> boolean success = false ; </a> 0
<a> try { </a> 0
<a> javaChannel ( ) . connect ( remoteAddress ) ; </a> 0
<a> selectionKey ( ) . interestOps ( selectionKey ( ) . interestOps ( ) | SelectionKey . OP_READ ) ; </a> 0
<a> success = true ; </a> 0
<a> return true ; </a> 0
<a> } finally { </a> 0
<a> if ( ! success ) { </a> 0
<a> doClose ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doFinishConnect ( ) throws Exception { </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDisconnect ( ) throws Exception { </a> 0
<a> javaChannel ( ) . disconnect ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doClose ( ) throws Exception { </a> 0
<a> javaChannel ( ) . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int doReadMessages ( MessageBuf < Object > buf ) throws Exception { </a> 1
<a> DatagramChannel ch = javaChannel ( ) ; </a> 0
<a> ByteBuffer data = ByteBuffer . allocate ( config ( ) . getReceivePacketSize ( ) ) ; </a> 0
<a> InetSocketAddress remoteAddress = ( InetSocketAddress ) ch . receive ( data ) ; </a> 1
<a> if ( remoteAddress == null ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> data . flip ( ) ; </a> 0
<a> buf . add ( new DatagramPacket ( Unpooled . wrappedBuffer ( data ) , remoteAddress ) ) ; </a> 0
<a> return 1 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int doWriteMessages ( MessageBuf < Object > buf , boolean lastSpin ) throws Exception { </a> 1
<a> DatagramPacket packet = ( DatagramPacket ) buf . peek ( ) ; </a> 1
<a> ByteBuf data = packet . data ( ) ; </a> 1
<a> ByteBuffer nioData ; </a> 0
<a> if ( data . hasNioBuffer ( ) ) { </a> 1
<a> nioData = data . nioBuffer ( ) ; </a> 0
<a> } else { </a> 0
<a> nioData = ByteBuffer . allocate ( data . readableBytes ( ) ) ; </a> 0
<a> data . getBytes ( data . readerIndex ( ) , nioData ) ; </a> 0
<a> nioData . flip ( ) ; </a> 0
<a> } </a> 0
<a> final int writtenBytes = javaChannel ( ) . send ( nioData , packet . remoteAddress ( ) ) ; </a> 1
<a> final SelectionKey key = selectionKey ( ) ; </a> 0
<a> final int interestOps = key . interestOps ( ) ; </a> 0
<a> if ( writtenBytes <= 0 ) { </a> 0
<a> if ( lastSpin ) { </a> 0
<a> if ( ( interestOps & SelectionKey . OP_WRITE ) == 0 ) { </a> 0
<a> key . interestOps ( interestOps | SelectionKey . OP_WRITE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> buf . remove ( ) ; </a> 1
<a> if ( buf . isEmpty ( ) ) { </a> 1
<a> if ( ( interestOps & SelectionKey . OP_WRITE ) != 0 ) { </a> 0
<a> key . interestOps ( interestOps & ~ SelectionKey . OP_WRITE ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return 1 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture joinGroup ( InetAddress multicastAddress ) { </a> 0
<a> return joinGroup ( multicastAddress , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture joinGroup ( InetAddress multicastAddress , ChannelFuture future ) { </a> 0
<a> try { </a> 0
<a> return joinGroup ( </a> 0
<a> multicastAddress , </a> 0
<a> NetworkInterface . getByInetAddress ( localAddress ( ) . getAddress ( ) ) , </a> 0
<a> null , future ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> future . setFailure ( e ) ; </a> 0
<a> } </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture joinGroup ( </a> 0
<a> InetSocketAddress multicastAddress , NetworkInterface networkInterface ) { </a> 0
<a> return joinGroup ( multicastAddress , networkInterface , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture joinGroup ( </a> 0
<a> InetSocketAddress multicastAddress , NetworkInterface networkInterface , </a> 0
<a> ChannelFuture future ) { </a> 0
<a> return joinGroup ( multicastAddress . getAddress ( ) , networkInterface , null , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture joinGroup ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source ) { </a> 0
<a> return joinGroup ( multicastAddress , networkInterface , source , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture joinGroup ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , </a> 0
<a> InetAddress source , ChannelFuture future ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } else { </a> 0
<a> if ( multicastAddress == null ) { </a> 0
<a> throw new NullPointerException ( "multicastAddress" ) ; </a> 0
<a> } </a> 0
<a> if ( networkInterface == null ) { </a> 0
<a> throw new NullPointerException ( "networkInterface" ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> MembershipKey key ; </a> 0
<a> if ( source == null ) { </a> 0
<a> key = javaChannel ( ) . join ( multicastAddress , networkInterface ) ; </a> 0
<a> } else { </a> 0
<a> key = javaChannel ( ) . join ( multicastAddress , networkInterface , source ) ; </a> 0
<a> } </a> 0
<a> synchronized ( this ) { </a> 0
<a> List < MembershipKey > keys = memberships . get ( multicastAddress ) ; </a> 0
<a> if ( keys == null ) { </a> 0
<a> keys = new ArrayList < MembershipKey > ( ) ; </a> 0
<a> memberships . put ( multicastAddress , keys ) ; </a> 0
<a> } </a> 0
<a> keys . add ( key ) ; </a> 0
<a> } </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> } catch ( Throwable e ) { </a> 0
<a> future . setFailure ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture leaveGroup ( InetAddress multicastAddress ) { </a> 0
<a> return leaveGroup ( multicastAddress , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture leaveGroup ( InetAddress multicastAddress , ChannelFuture future ) { </a> 0
<a> try { </a> 0
<a> return leaveGroup ( </a> 0
<a> multicastAddress , NetworkInterface . getByInetAddress ( localAddress ( ) . getAddress ( ) ) , null , future ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> future . setFailure ( e ) ; </a> 0
<a> } </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture leaveGroup ( </a> 0
<a> InetSocketAddress multicastAddress , NetworkInterface networkInterface ) { </a> 0
<a> return leaveGroup ( multicastAddress , networkInterface , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture leaveGroup ( </a> 0
<a> InetSocketAddress multicastAddress , </a> 0
<a> NetworkInterface networkInterface , ChannelFuture future ) { </a> 0
<a> return leaveGroup ( multicastAddress . getAddress ( ) , networkInterface , null , future ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture leaveGroup ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source ) { </a> 0
<a> return leaveGroup ( multicastAddress , networkInterface , source , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture leaveGroup ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source , </a> 0
<a> ChannelFuture future ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> if ( multicastAddress == null ) { </a> 0
<a> throw new NullPointerException ( "multicastAddress" ) ; </a> 0
<a> } </a> 0
<a> if ( networkInterface == null ) { </a> 0
<a> throw new NullPointerException ( "networkInterface" ) ; </a> 0
<a> } </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( memberships != null ) { </a> 0
<a> List < MembershipKey > keys = memberships . get ( multicastAddress ) ; </a> 0
<a> if ( keys != null ) { </a> 0
<a> Iterator < MembershipKey > keyIt = keys . iterator ( ) ; </a> 0
<a> while ( keyIt . hasNext ( ) ) { </a> 0
<a> MembershipKey key = keyIt . next ( ) ; </a> 0
<a> if ( networkInterface . equals ( key . networkInterface ( ) ) ) { </a> 0
<a> if ( source == null && key . sourceAddress ( ) == null || </a> 0
<a> source != null && source . equals ( key . sourceAddress ( ) ) ) { </a> 0
<a> key . drop ( ) ; </a> 0
<a> keyIt . remove ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( keys . isEmpty ( ) ) { </a> 0
<a> memberships . remove ( multicastAddress ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture block ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , </a> 0
<a> InetAddress sourceToBlock ) { </a> 0
<a> return block ( multicastAddress , networkInterface , sourceToBlock , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture block ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , </a> 0
<a> InetAddress sourceToBlock , ChannelFuture future ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } else { </a> 0
<a> if ( multicastAddress == null ) { </a> 0
<a> throw new NullPointerException ( "multicastAddress" ) ; </a> 0
<a> } </a> 0
<a> if ( sourceToBlock == null ) { </a> 0
<a> throw new NullPointerException ( "sourceToBlock" ) ; </a> 0
<a> } </a> 0
<a> if ( networkInterface == null ) { </a> 0
<a> throw new NullPointerException ( "networkInterface" ) ; </a> 0
<a> } </a> 0
<a> synchronized ( this ) { </a> 0
<a> if ( memberships != null ) { </a> 0
<a> List < MembershipKey > keys = memberships . get ( multicastAddress ) ; </a> 0
<a> for ( MembershipKey key : keys ) { </a> 0
<a> if ( networkInterface . equals ( key . networkInterface ( ) ) ) { </a> 0
<a> try { </a> 0
<a> key . block ( sourceToBlock ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> future . setFailure ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture block ( InetAddress multicastAddress , InetAddress sourceToBlock ) { </a> 0
<a> return block ( multicastAddress , sourceToBlock , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture block ( </a> 0
<a> InetAddress multicastAddress , InetAddress sourceToBlock , ChannelFuture future ) { </a> 0
<a> try { </a> 0
<a> return block ( </a> 0
<a> multicastAddress , </a> 0
<a> NetworkInterface . getByInetAddress ( localAddress ( ) . getAddress ( ) ) , </a> 0
<a> sourceToBlock , future ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> future . setFailure ( e ) ; </a> 0
<a> } </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> protected AbstractNioMessageUnsafe newUnsafe ( ) { </a> 1
<a> return new NioDatagramChannelUnsafe ( ) ; </a> 1
<a> } </a> 1
<a> private final class NioDatagramChannelUnsafe extends AbstractNioMessageUnsafe { </a> 1
<a> @ Override </a> 1
<a> public void suspendRead ( ) { </a> 1
<a> selectionKey ( ) . interestOps ( selectionKey ( ) . interestOps ( ) & ~ SelectionKey . OP_READ ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void resumeRead ( ) { </a> 1
<a> selectionKey ( ) . interestOps ( selectionKey ( ) . interestOps ( ) & ~ SelectionKey . OP_READ ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . nio ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . socket . DefaultDatagramChannelConfig ; </a> 0
<a> import io . netty . util . internal . DetectionUtil ; </a> 1
<a> import java . lang . reflect . Method ; </a> 0
<a> import java . net . InetAddress ; </a> 0
<a> import java . net . NetworkInterface ; </a> 0
<a> import java . net . SocketException ; </a> 0
<a> import java . nio . channels . DatagramChannel ; </a> 0
<a> import java . nio . channels . NetworkChannel ; </a> 0
<a> import java . util . Enumeration ; </a> 0
<a> class NioDatagramChannelConfig extends DefaultDatagramChannelConfig { </a> 0
<a> private static final Object IP_MULTICAST_TTL ; </a> 0
<a> private static final Object IP_MULTICAST_IF ; </a> 0
<a> private static final Object IP_MULTICAST_LOOP ; </a> 0
<a> private static final Method GET_OPTION ; </a> 0
<a> private static final Method SET_OPTION ; </a> 0
<a> static { </a> 0
<a> ClassLoader classLoader = DatagramChannel . class . getClassLoader ( ) ; </a> 0
<a> Class < ? > socketOptionType = null ; </a> 0
<a> try { </a> 0
<a> socketOptionType = Class . forName ( "java.net.SocketOption" , true , classLoader ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> } </a> 0
<a> Class < ? > stdSocketOptionType = null ; </a> 0
<a> try { </a> 0
<a> stdSocketOptionType = Class . forName ( "java.net.StandardSocketOptions" , true , classLoader ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> } </a> 0
<a> Object ipMulticastTtl = null ; </a> 0
<a> Object ipMulticastIf = null ; </a> 0
<a> Object ipMulticastLoop = null ; </a> 0
<a> Method getOption = null ; </a> 0
<a> Method setOption = null ; </a> 0
<a> if ( socketOptionType != null ) { </a> 0
<a> try { </a> 0
<a> ipMulticastTtl = stdSocketOptionType . getDeclaredField ( "IP_MULTICAST_TTL" ) . get ( null ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new Error ( "cannot locate the IP_MULTICAST_TTL field" , e ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> ipMulticastIf = stdSocketOptionType . getDeclaredField ( "IP_MULTICAST_IF" ) . get ( null ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new Error ( "cannot locate the IP_MULTICAST_IF field" , e ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> ipMulticastLoop = stdSocketOptionType . getDeclaredField ( "IP_MULTICAST_LOOP" ) . get ( null ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new Error ( "cannot locate the IP_MULTICAST_LOOP field" , e ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> getOption = NetworkChannel . class . getDeclaredMethod ( "getOption" , socketOptionType ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new Error ( "cannot locate the getOption() method" , e ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> setOption = NetworkChannel . class . getDeclaredMethod ( "setOption" , socketOptionType , Object . class ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new Error ( "cannot locate the setOption() method" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> IP_MULTICAST_TTL = ipMulticastTtl ; </a> 0
<a> IP_MULTICAST_IF = ipMulticastIf ; </a> 0
<a> IP_MULTICAST_LOOP = ipMulticastLoop ; </a> 0
<a> GET_OPTION = getOption ; </a> 0
<a> SET_OPTION = setOption ; </a> 0
<a> } </a> 0
<a> private final DatagramChannel channel ; </a> 0
<a> NioDatagramChannelConfig ( DatagramChannel channel ) { </a> 0
<a> super ( channel . socket ( ) ) ; </a> 0
<a> this . channel = channel ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public int getTimeToLive ( ) { </a> 0
<a> return ( Integer ) getOption0 ( IP_MULTICAST_TTL ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setTimeToLive ( int ttl ) { </a> 0
<a> setOption0 ( IP_MULTICAST_TTL , ttl ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public InetAddress getInterface ( ) { </a> 0
<a> NetworkInterface inf = getNetworkInterface ( ) ; </a> 0
<a> if ( inf == null ) { </a> 0
<a> return null ; </a> 0
<a> } else { </a> 0
<a> Enumeration < InetAddress > addresses = inf . getInetAddresses ( ) ; </a> 0
<a> if ( addresses . hasMoreElements ( ) ) { </a> 0
<a> return addresses . nextElement ( ) ; </a> 0
<a> } </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setInterface ( InetAddress interfaceAddress ) { </a> 0
<a> try { </a> 0
<a> setNetworkInterface ( NetworkInterface . getByInetAddress ( interfaceAddress ) ) ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public NetworkInterface getNetworkInterface ( ) { </a> 0
<a> return ( NetworkInterface ) getOption0 ( IP_MULTICAST_IF ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setNetworkInterface ( NetworkInterface networkInterface ) { </a> 0
<a> setOption0 ( IP_MULTICAST_IF , networkInterface ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isLoopbackModeDisabled ( ) { </a> 0
<a> return ( Boolean ) getOption0 ( IP_MULTICAST_LOOP ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void setLoopbackModeDisabled ( boolean loopbackModeDisabled ) { </a> 0
<a> setOption0 ( IP_MULTICAST_LOOP , loopbackModeDisabled ) ; </a> 0
<a> } </a> 0
<a> private Object getOption0 ( Object option ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } else { </a> 0
<a> try { </a> 0
<a> return GET_OPTION . invoke ( channel , option ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void setOption0 ( Object option , Object value ) { </a> 0
<a> if ( DetectionUtil . javaVersion ( ) < 7 ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } else { </a> 0
<a> try { </a> 0
<a> SET_OPTION . invoke ( channel , option , value ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new ChannelException ( e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . nio ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . SingleThreadEventLoop ; </a> 0
<a> import io . netty . channel . ChannelTaskScheduler ; </a> 1
<a> import io . netty . channel . socket . nio . AbstractNioChannel . NioUnsafe ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . nio . channels . CancelledKeyException ; </a> 0
<a> import java . nio . channels . SelectionKey ; </a> 0
<a> import java . nio . channels . Selector ; </a> 0
<a> import java . nio . channels . spi . SelectorProvider ; </a> 0
<a> import java . util . ArrayList ; </a> 0
<a> import java . util . Collection ; </a> 0
<a> import java . util . Iterator ; </a> 0
<a> import java . util . Queue ; </a> 0
<a> import java . util . Set ; </a> 0
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 0
<a> final class NioEventLoop extends SingleThreadEventLoop { </a> 0
<a> protected static final InternalLogger logger = InternalLoggerFactory </a> 1
<a> . getInstance ( NioEventLoop . class ) ; </a> 1
<a> static final int CLEANUP_INTERVAL = 256 ; </a> 1
<a> protected final Selector selector ; </a> 1
<a> protected final AtomicBoolean wakenUp = new AtomicBoolean ( ) ; </a> 1
<a> private int cancelledKeys ; </a> 0
<a> private boolean cleanedCancelledKeys ; </a> 1
<a> NioEventLoop ( </a> 1
<a> NioEventLoopGroup parent , ThreadFactory threadFactory , </a> 1
<a> ChannelTaskScheduler scheduler , SelectorProvider selectorProvider ) { </a> 0
<a> super ( parent , threadFactory , scheduler ) ; </a> 1
<a> if ( selectorProvider == null ) { </a> 0
<a> throw new NullPointerException ( "selectorProvider" ) ; </a> 0
<a> } </a> 0
<a> selector = openSelector ( selectorProvider ) ; </a> 1
<a> } </a> 0
<a> private static Selector openSelector ( SelectorProvider provider ) { </a> 1
<a> try { </a> 0
<a> return provider . openSelector ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( "failed to open a new selector" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected Queue < Runnable > newTaskQueue ( ) { </a> 0
<a> return new ConcurrentLinkedQueue < Runnable > ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void run ( ) { </a> 0
<a> Selector selector = this . selector ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> wakenUp . set ( false ) ; </a> 0
<a> try { </a> 0
<a> SelectorUtil . select ( selector ) ; </a> 1
<a> if ( wakenUp . get ( ) ) { </a> 0
<a> selector . wakeup ( ) ; </a> 0
<a> } </a> 0
<a> cancelledKeys = 0 ; </a> 0
<a> runAllTasks ( ) ; </a> 1
<a> processSelectedKeys ( ) ; </a> 1
<a> if ( isShutdown ( ) ) { </a> 1
<a> closeAll ( ) ; </a> 0
<a> if ( peekTask ( ) == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( </a> 0
<a> "Unexpected exception in the selector loop." , t ) ; </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 1000 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void cleanup ( ) { </a> 0
<a> try { </a> 0
<a> selector . close ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . warn ( </a> 0
<a> "Failed to close a selector." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> void cancel ( SelectionKey key ) { </a> 0
<a> key . cancel ( ) ; </a> 0
<a> cancelledKeys ++ ; </a> 0
<a> if ( cancelledKeys >= CLEANUP_INTERVAL ) { </a> 0
<a> cancelledKeys = 0 ; </a> 0
<a> cleanedCancelledKeys = true ; </a> 1
<a> SelectorUtil . cleanupKeys ( selector ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void processSelectedKeys ( ) { </a> 0
<a> Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; </a> 0
<a> if ( selectedKeys . isEmpty ( ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> Iterator < SelectionKey > i ; </a> 0
<a> cleanedCancelledKeys = false ; </a> 0
<a> boolean clearSelectedKeys = true ; </a> 0
<a> try { </a> 0
<a> for ( i = selectedKeys . iterator ( ) ; i . hasNext ( ) ; ) { </a> 0
<a> final SelectionKey k = i . next ( ) ; </a> 0
<a> final AbstractNioChannel ch = ( AbstractNioChannel ) k . attachment ( ) ; </a> 0
<a> final NioUnsafe unsafe = ch . unsafe ( ) ; </a> 0
<a> try { </a> 0
<a> int readyOps = k . readyOps ( ) ; </a> 0
<a> if ( ( readyOps & ( SelectionKey . OP_READ | SelectionKey . OP_ACCEPT ) ) != 0 || readyOps == 0 ) { </a> 0
<a> unsafe . read ( ) ; </a> 0
<a> if ( ! ch . isOpen ( ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> if ( ( readyOps & SelectionKey . OP_WRITE ) != 0 ) { </a> 0
<a> unsafe . flushNow ( ) ; </a> 0
<a> } </a> 0
<a> if ( ( readyOps & SelectionKey . OP_CONNECT ) != 0 ) { </a> 0
<a> unsafe . finishConnect ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( CancelledKeyException ignored ) { </a> 0
<a> unsafe . close ( unsafe . voidFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> if ( cleanedCancelledKeys ) { </a> 0
<a> if ( selectedKeys . isEmpty ( ) ) { </a> 0
<a> clearSelectedKeys = false ; </a> 0
<a> break ; </a> 0
<a> } else { </a> 1
<a> i = selectedKeys . iterator ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } finally { </a> 0
<a> if ( clearSelectedKeys ) { </a> 0
<a> selectedKeys . clear ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private void closeAll ( ) { </a> 0
<a> SelectorUtil . cleanupKeys ( selector ) ; </a> 0
<a> Set < SelectionKey > keys = selector . keys ( ) ; </a> 0
<a> Collection < Channel > channels = new ArrayList < Channel > ( keys . size ( ) ) ; </a> 0
<a> for ( SelectionKey k : keys ) { </a> 0
<a> channels . add ( ( Channel ) k . attachment ( ) ) ; </a> 0
<a> } </a> 0
<a> for ( Channel ch : channels ) { </a> 0
<a> ch . unsafe ( ) . close ( ch . unsafe ( ) . voidFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void wakeup ( boolean inEventLoop ) { </a> 0
<a> if ( wakenUp . compareAndSet ( false , true ) ) { </a> 1
<a> selector . wakeup ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . nio ; </a> 0
<a> import io . netty . channel . EventExecutor ; </a> 0
<a> import io . netty . channel . MultithreadEventLoopGroup ; </a> 0
<a> import io . netty . channel . ChannelTaskScheduler ; </a> 1
<a> import java . nio . channels . spi . SelectorProvider ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 1
<a> public class NioEventLoopGroup extends MultithreadEventLoopGroup { </a> 0
<a> public NioEventLoopGroup ( ) { </a> 0
<a> this ( 0 ) ; </a> 0
<a> } </a> 0
<a> public NioEventLoopGroup ( int nThreads ) { </a> 1
<a> this ( nThreads , null ) ; </a> 0
<a> } </a> 0
<a> public NioEventLoopGroup ( int nThreads , ThreadFactory threadFactory ) { </a> 1
<a> super ( nThreads , threadFactory ) ; </a> 1
<a> } </a> 0
<a> public NioEventLoopGroup ( </a> 1
<a> int nThreads , ThreadFactory threadFactory , final SelectorProvider selectorProvider ) { </a> 1
<a> super ( nThreads , threadFactory , selectorProvider ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> protected EventExecutor newChild ( </a> 1
<a> ThreadFactory threadFactory , ChannelTaskScheduler scheduler , Object ... args ) throws Exception { </a> 0
<a> SelectorProvider selectorProvider ; </a> 0
<a> if ( args == null || args . length == 0 || args [ 0 ] == null ) { </a> 0
<a> selectorProvider = SelectorProvider . provider ( ) ; </a> 0
<a> } else { </a> 0
<a> selectorProvider = ( SelectorProvider ) args [ 0 ] ; </a> 0
<a> } </a> 0
<a> return new NioEventLoop ( this , threadFactory , scheduler , selectorProvider ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . nio ; </a> 0
<a> import io . netty . buffer . ChannelBufType ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelMetadata ; </a> 0
<a> import io . netty . channel . socket . DefaultServerSocketChannelConfig ; </a> 0
<a> import io . netty . channel . socket . ServerSocketChannelConfig ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . nio . channels . SelectionKey ; </a> 0
<a> import java . nio . channels . ServerSocketChannel ; </a> 0
<a> import java . nio . channels . SocketChannel ; </a> 0
<a> public class NioServerSocketChannel extends AbstractNioMessageChannel </a> 0
<a> implements io . netty . channel . socket . ServerSocketChannel { </a> 0
<a> private static final ChannelMetadata METADATA = new ChannelMetadata ( ChannelBufType . MESSAGE , false ) ; </a> 0
<a> private static ServerSocketChannel newSocket ( ) { </a> 0
<a> try { </a> 0
<a> return ServerSocketChannel . open ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( </a> 0
<a> "Failed to open a server socket." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private final ServerSocketChannelConfig config ; </a> 0
<a> public NioServerSocketChannel ( ) { </a> 0
<a> super ( null , null , newSocket ( ) , 0 ) ; </a> 1
<a> config = new DefaultServerSocketChannelConfig ( javaChannel ( ) . socket ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelMetadata metadata ( ) { </a> 0
<a> return METADATA ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ServerSocketChannelConfig config ( ) { </a> 0
<a> return config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isActive ( ) { </a> 0
<a> return javaChannel ( ) . socket ( ) . isBound ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public InetSocketAddress remoteAddress ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected ServerSocketChannel javaChannel ( ) { </a> 0
<a> return ( ServerSocketChannel ) super . javaChannel ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress localAddress0 ( ) { </a> 0
<a> return javaChannel ( ) . socket ( ) . getLocalSocketAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doBind ( SocketAddress localAddress ) throws Exception { </a> 0
<a> javaChannel ( ) . socket ( ) . bind ( localAddress ) ; </a> 1
<a> SelectionKey selectionKey = selectionKey ( ) ; </a> 1
<a> selectionKey . interestOps ( selectionKey . interestOps ( ) | SelectionKey . OP_ACCEPT ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doClose ( ) throws Exception { </a> 0
<a> javaChannel ( ) . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int doReadMessages ( MessageBuf < Object > buf ) throws Exception { </a> 1
<a> SocketChannel ch = javaChannel ( ) . accept ( ) ; </a> 0
<a> if ( ch == null ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> buf . add ( new NioSocketChannel ( this , null , ch ) ) ; </a> 0
<a> return 1 ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean doConnect ( </a> 0
<a> SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doFinishConnect ( ) throws Exception { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress remoteAddress0 ( ) { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDisconnect ( ) throws Exception { </a> 0
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int doWriteMessages ( MessageBuf < Object > buf , boolean lastSpin ) throws Exception { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 1
<a> protected AbstractNioMessageUnsafe newUnsafe ( ) { </a> 1
<a> return new NioServerSocketUnsafe ( ) ; </a> 1
<a> } </a> 1
<a> private final class NioServerSocketUnsafe extends AbstractNioMessageUnsafe { </a> 1
<a> @ Override </a> 1
<a> public void suspendRead ( ) { </a> 1
<a> selectionKey ( ) . cancel ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void resumeRead ( ) { </a> 1
<a> try { </a> 1
<a> doRegister ( ) ; </a> 1
<a> } catch ( Exception e ) { </a> 1
<a> e . printStackTrace ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . nio ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ChannelBufType ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelMetadata ; </a> 0
<a> import io . netty . channel . socket . DefaultSocketChannelConfig ; </a> 0
<a> import io . netty . channel . socket . SocketChannelConfig ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . nio . channels . SelectionKey ; </a> 0
<a> import java . nio . channels . SocketChannel ; </a> 0
<a> public class NioSocketChannel extends AbstractNioByteChannel implements io . netty . channel . socket . SocketChannel { </a> 0
<a> private static final ChannelMetadata METADATA = new ChannelMetadata ( ChannelBufType . BYTE , false ) ; </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( NioSocketChannel . class ) ; </a> 0
<a> private final SocketChannelConfig config ; </a> 0
<a> private static SocketChannel newSocket ( ) { </a> 0
<a> try { </a> 0
<a> return SocketChannel . open ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> throw new ChannelException ( "Failed to open a socket." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public NioSocketChannel ( ) { </a> 0
<a> this ( newSocket ( ) ) ; </a> 0
<a> } </a> 0
<a> public NioSocketChannel ( SocketChannel socket ) { </a> 0
<a> this ( null , null , socket ) ; </a> 0
<a> } </a> 0
<a> public NioSocketChannel ( Channel parent , Integer id , SocketChannel socket ) { </a> 0
<a> super ( parent , id , socket ) ; </a> 0
<a> try { </a> 0
<a> socket . configureBlocking ( false ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> try { </a> 0
<a> socket . close ( ) ; </a> 0
<a> } catch ( IOException e2 ) { </a> 0
<a> if ( logger . isWarnEnabled ( ) ) { </a> 0
<a> logger . warn ( </a> 0
<a> "Failed to close a partially initialized socket." , e2 ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> throw new ChannelException ( "Failed to enter non-blocking mode." , e ) ; </a> 0
<a> } </a> 0
<a> config = new DefaultSocketChannelConfig ( socket . socket ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelMetadata metadata ( ) { </a> 0
<a> return METADATA ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public SocketChannelConfig config ( ) { </a> 0
<a> return config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketChannel javaChannel ( ) { </a> 0
<a> return ( SocketChannel ) super . javaChannel ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isActive ( ) { </a> 0
<a> SocketChannel ch = javaChannel ( ) ; </a> 0
<a> return ch . isOpen ( ) && ch . isConnected ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress localAddress0 ( ) { </a> 0
<a> return javaChannel ( ) . socket ( ) . getLocalSocketAddress ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> protected SocketAddress remoteAddress0 ( ) { </a> 1
<a> return javaChannel ( ) . socket ( ) . getRemoteSocketAddress ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void doBind ( SocketAddress localAddress ) throws Exception { </a> 1
<a> javaChannel ( ) . socket ( ) . bind ( localAddress ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean doConnect ( SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception { </a> 0
<a> if ( localAddress != null ) { </a> 0
<a> javaChannel ( ) . socket ( ) . bind ( localAddress ) ; </a> 0
<a> } </a> 0
<a> boolean success = false ; </a> 0
<a> try { </a> 0
<a> boolean connected = javaChannel ( ) . connect ( remoteAddress ) ; </a> 0
<a> if ( connected ) { </a> 0
<a> selectionKey ( ) . interestOps ( SelectionKey . OP_READ ) ; </a> 0
<a> } else { </a> 0
<a> selectionKey ( ) . interestOps ( SelectionKey . OP_CONNECT ) ; </a> 0
<a> } </a> 0
<a> success = true ; </a> 0
<a> return connected ; </a> 0
<a> } finally { </a> 0
<a> if ( ! success ) { </a> 0
<a> doClose ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doFinishConnect ( ) throws Exception { </a> 0
<a> if ( ! javaChannel ( ) . finishConnect ( ) ) { </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> selectionKey ( ) . interestOps ( SelectionKey . OP_READ ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDisconnect ( ) throws Exception { </a> 1
<a> doClose ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void doClose ( ) throws Exception { </a> 1
<a> javaChannel ( ) . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int doReadBytes ( ByteBuf byteBuf ) throws Exception { </a> 0
<a> return byteBuf . writeBytes ( javaChannel ( ) , byteBuf . writableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int doWriteBytes ( ByteBuf buf , boolean lastSpin ) throws Exception { </a> 0
<a> final int expectedWrittenBytes = buf . readableBytes ( ) ; </a> 0
<a> final int writtenBytes = buf . readBytes ( javaChannel ( ) , expectedWrittenBytes ) ; </a> 1
<a> final SelectionKey key = selectionKey ( ) ; </a> 1
<a> final int interestOps = key . interestOps ( ) ; </a> 1
<a> if ( writtenBytes >= expectedWrittenBytes ) { </a> 0
<a> if ( ( interestOps & SelectionKey . OP_WRITE ) != 0 ) { </a> 1
<a> key . interestOps ( interestOps & ~ SelectionKey . OP_WRITE ) ; </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> if ( writtenBytes > 0 || lastSpin ) { </a> 0
<a> if ( ( interestOps & SelectionKey . OP_WRITE ) == 0 ) { </a> 1
<a> key . interestOps ( interestOps | SelectionKey . OP_WRITE ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> return writtenBytes ; </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> protected AbstractNioByteUnsafe newUnsafe ( ) { </a> 1
<a> return new NioSocketChannelUnsafe ( ) ; </a> 1
<a> } </a> 1
<a> private final class NioSocketChannelUnsafe extends AbstractNioByteUnsafe { </a> 1
<a> @ Override </a> 1
<a> public void suspendRead ( ) { </a> 1
<a> selectionKey ( ) . interestOps ( selectionKey ( ) . interestOps ( ) & ~ SelectionKey . OP_READ ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void resumeRead ( ) { </a> 1
<a> selectionKey ( ) . interestOps ( selectionKey ( ) . interestOps ( ) | SelectionKey . OP_READ ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . nio ; </a> 0
<a> import io . netty . channel . socket . InternetProtocolFamily ; </a> 0
<a> import java . net . ProtocolFamily ; </a> 0
<a> import java . net . StandardProtocolFamily ; </a> 0
<a> final class ProtocolFamilyConverter { </a> 0
<a> private ProtocolFamilyConverter ( ) { </a> 0
<a> } </a> 0
<a> public static ProtocolFamily convert ( InternetProtocolFamily family ) { </a> 0
<a> switch ( family ) { </a> 0
<a> case IPv4 : </a> 0
<a> return StandardProtocolFamily . INET ; </a> 0
<a> case IPv6 : </a> 0
<a> return StandardProtocolFamily . INET6 ; </a> 0
<a> default : </a> 0
<a> throw new IllegalArgumentException ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . nio ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . nio . channels . CancelledKeyException ; </a> 0
<a> import java . nio . channels . Selector ; </a> 0
<a> final class SelectorUtil { </a> 0
<a> private static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( SelectorUtil . class ) ; </a> 0
<a> static final long DEFAULT_SELECT_TIMEOUT = 10 ; </a> 0
<a> static final long SELECT_TIMEOUT ; </a> 0
<a> static { </a> 0
<a> String key = "sun.nio.ch.bugLevel" ; </a> 0
<a> try { </a> 0
<a> String buglevel = System . getProperty ( key ) ; </a> 0
<a> if ( buglevel == null ) { </a> 0
<a> System . setProperty ( key , "" ) ; </a> 0
<a> } </a> 0
<a> } catch ( SecurityException e ) { </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( "Unable to get/set System Property '" + key + "'" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> long selectTimeout ; </a> 0
<a> try { </a> 0
<a> selectTimeout = Long . parseLong ( System . getProperty ( "io.netty.selectTimeout" , </a> 0
<a> String . valueOf ( DEFAULT_SELECT_TIMEOUT ) ) ) ; </a> 0
<a> } catch ( NumberFormatException e ) { </a> 0
<a> selectTimeout = DEFAULT_SELECT_TIMEOUT ; </a> 0
<a> } </a> 0
<a> SELECT_TIMEOUT = selectTimeout ; </a> 0
<a> logger . debug ( "Using select timeout of " + SELECT_TIMEOUT ) ; </a> 0
<a> } </a> 0
<a> static void select ( Selector selector ) throws IOException { </a> 1
<a> try { </a> 0
<a> selector . select ( SELECT_TIMEOUT ) ; </a> 0
<a> } catch ( CancelledKeyException e ) { </a> 0
<a> if ( logger . isDebugEnabled ( ) ) { </a> 0
<a> logger . debug ( </a> 0
<a> CancelledKeyException . class . getSimpleName ( ) + </a> 0
<a> " raised by a Selector - JDK bug?" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> static void cleanupKeys ( Selector selector ) { </a> 0
<a> try { </a> 0
<a> selector . selectNow ( ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Failed to update SelectionKeys." , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private SelectorUtil ( ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . nio ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . oio ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> abstract class AbstractOioByteChannel extends AbstractOioChannel { </a> 0
<a> protected AbstractOioByteChannel ( Channel parent , Integer id ) { </a> 0
<a> super ( parent , id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected abstract AbstractOioByteUnsafe newUnsafe ( ) ; </a> 0
<a> abstract class AbstractOioByteUnsafe extends AbstractOioUnsafe { </a> 0
<a> @ Override </a> 0
<a> public void read ( ) { </a> 0
<a> assert eventLoop ( ) . inEventLoop ( ) ; </a> 0
<a> final ChannelPipeline pipeline = pipeline ( ) ; </a> 0
<a> final ByteBuf byteBuf = pipeline . inboundByteBuffer ( ) ; </a> 1
<a> boolean closed = false ; </a> 0
<a> boolean read = false ; </a> 0
<a> try { </a> 0
<a> for ( ; ; ) { </a> 0
<a> int localReadAmount = doReadBytes ( byteBuf ) ; </a> 1
<a> if ( localReadAmount > 0 ) { </a> 0
<a> read = true ; </a> 0
<a> } else if ( localReadAmount < 0 ) { </a> 0
<a> closed = true ; </a> 0
<a> } </a> 0
<a> final int available = available ( ) ; </a> 0
<a> if ( available <= 0 ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> if ( byteBuf . writable ( ) ) { </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> final int capacity = byteBuf . capacity ( ) ; </a> 0
<a> final int maxCapacity = byteBuf . maxCapacity ( ) ; </a> 0
<a> if ( capacity == maxCapacity ) { </a> 0
<a> if ( read ) { </a> 0
<a> read = false ; </a> 0
<a> pipeline . fireInboundBufferUpdated ( ) ; </a> 1
<a> if ( ! byteBuf . writable ( ) ) { </a> 0
<a> throw new IllegalStateException ( </a> 1
<a> "an inbound handler whose buffer is full must consume at " + </a> 1
<a> "least one byte." ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } else { </a> 0
<a> final int writerIndex = byteBuf . writerIndex ( ) ; </a> 0
<a> if ( writerIndex + available > maxCapacity ) { </a> 0
<a> byteBuf . capacity ( maxCapacity ) ; </a> 0
<a> } else { </a> 0
<a> byteBuf . ensureWritableBytes ( available ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( read ) { </a> 0
<a> read = false ; </a> 0
<a> pipeline . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> pipeline ( ) . fireExceptionCaught ( t ) ; </a> 1
<a> if ( t instanceof IOException ) { </a> 0
<a> close ( voidFuture ( ) ) ; </a> 1
<a> } </a> 0
<a> } finally { </a> 0
<a> if ( read ) { </a> 0
<a> pipeline . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> if ( closed && isOpen ( ) ) { </a> 0
<a> close ( voidFuture ( ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doFlushByteBuffer ( ByteBuf buf ) throws Exception { </a> 1
<a> while ( buf . readable ( ) ) { </a> 0
<a> doWriteBytes ( buf ) ; </a> 0
<a> } </a> 0
<a> buf . clear ( ) ; </a> 1
<a> } </a> 0
<a> protected abstract int available ( ) ; </a> 0
<a> protected abstract int doReadBytes ( ByteBuf buf ) throws Exception ; </a> 0
<a> protected abstract void doWriteBytes ( ByteBuf buf ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . oio ; </a> 0
<a> import io . netty . channel . AbstractChannel ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . EventLoop ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 1
<a> import java . net . SocketAddress ; </a> 0
<a> abstract class AbstractOioChannel extends AbstractChannel { </a> 0
<a> static final int SO_TIMEOUT = 1000 ; </a> 0
<a> protected AbstractOioChannel ( Channel parent , Integer id ) { </a> 0
<a> super ( parent , id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public InetSocketAddress localAddress ( ) { </a> 0
<a> return ( InetSocketAddress ) super . localAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public InetSocketAddress remoteAddress ( ) { </a> 0
<a> return ( InetSocketAddress ) super . remoteAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public OioUnsafe unsafe ( ) { </a> 1
<a> return ( OioUnsafe ) super . unsafe ( ) ; </a> 1
<a> } </a> 1
<a> public interface OioUnsafe extends Unsafe { </a> 1
<a> void read ( ) ; </a> 1
<a> } </a> 0
<a> abstract class AbstractOioUnsafe extends AbstractUnsafe implements OioUnsafe { </a> 1
<a> @ Override </a> 0
<a> public void connect ( </a> 0
<a> final SocketAddress remoteAddress , </a> 0
<a> final SocketAddress localAddress , final ChannelFuture future ) { </a> 0
<a> if ( eventLoop ( ) . inEventLoop ( ) ) { </a> 0
<a> if ( ! ensureOpen ( future ) ) { </a> 0
<a> return ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> boolean wasActive = isActive ( ) ; </a> 0
<a> doConnect ( remoteAddress , localAddress ) ; </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> if ( ! wasActive && isActive ( ) ) { </a> 0
<a> pipeline ( ) . fireChannelActive ( ) ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> future . setFailure ( t ) ; </a> 0
<a> pipeline ( ) . fireExceptionCaught ( t ) ; </a> 0
<a> closeIfClosed ( ) ; </a> 1
<a> } </a> 0
<a> } else { </a> 0
<a> eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> connect ( remoteAddress , localAddress , future ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isCompatible ( EventLoop loop ) { </a> 0
<a> return loop instanceof OioEventLoop ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> protected Runnable doRegister ( ) throws Exception { </a> 0
<a> return null ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDeregister ( ) throws Exception { </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected boolean isFlushPending ( ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> protected abstract void doConnect ( </a> 0
<a> SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception ; </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . oio ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelPipeline ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> abstract class AbstractOioMessageChannel extends AbstractOioChannel { </a> 0
<a> protected AbstractOioMessageChannel ( Channel parent , Integer id ) { </a> 0
<a> super ( parent , id ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected abstract AbstractOioMessageUnsafe newUnsafe ( ) ; </a> 0
<a> abstract class AbstractOioMessageUnsafe extends AbstractOioUnsafe { </a> 0
<a> @ Override </a> 0
<a> public void read ( ) { </a> 0
<a> assert eventLoop ( ) . inEventLoop ( ) ; </a> 0
<a> final ChannelPipeline pipeline = pipeline ( ) ; </a> 0
<a> final MessageBuf < Object > msgBuf = pipeline . inboundMessageBuffer ( ) ; </a> 1
<a> boolean closed = false ; </a> 0
<a> boolean read = false ; </a> 1
<a> try { </a> 0
<a> int localReadAmount = doReadMessages ( msgBuf ) ; </a> 0
<a> if ( localReadAmount > 0 ) { </a> 0
<a> read = true ; </a> 0
<a> } else if ( localReadAmount < 0 ) { </a> 0
<a> closed = true ; </a> 0
<a> } </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> if ( read ) { </a> 0
<a> read = false ; </a> 0
<a> pipeline . fireInboundBufferUpdated ( ) ; </a> 0
<a> } </a> 0
<a> pipeline ( ) . fireExceptionCaught ( t ) ; </a> 1
<a> if ( t instanceof IOException ) { </a> 1
<a> close ( voidFuture ( ) ) ; </a> 1
<a> } </a> 0
<a> } finally { </a> 0
<a> if ( read ) { </a> 0
<a> pipeline . fireInboundBufferUpdated ( ) ; </a> 0
<a> } </a> 0
<a> if ( closed && isOpen ( ) ) { </a> 0
<a> close ( voidFuture ( ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void doFlushMessageBuffer ( MessageBuf < Object > buf ) throws Exception { </a> 1
<a> while ( ! buf . isEmpty ( ) ) { </a> 1
<a> doWriteMessages ( buf ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> protected abstract int doReadMessages ( MessageBuf < Object > buf ) throws Exception ; </a> 1
<a> protected abstract void doWriteMessages ( MessageBuf < Object > buf ) throws Exception ; </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . oio ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ChannelBufType ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelMetadata ; </a> 0
<a> import io . netty . channel . socket . DatagramChannel ; </a> 0
<a> import io . netty . channel . socket . DatagramChannelConfig ; </a> 0
<a> import io . netty . channel . socket . DatagramPacket ; </a> 0
<a> import io . netty . channel . socket . DefaultDatagramChannelConfig ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import java . io . IOException ; </a> 0
<a> import java . net . InetAddress ; </a> 0
<a> import java . net . InetSocketAddress ; </a> 0
<a> import java . net . MulticastSocket ; </a> 0
<a> import java . net . NetworkInterface ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . net . SocketException ; </a> 0
<a> import java . net . SocketTimeoutException ; </a> 0
<a> import java . util . Locale ; </a> 0
<a> public class OioDatagramChannel extends AbstractOioMessageChannel </a> 0
<a> implements DatagramChannel { </a> 0
<a> private static final InternalLogger logger = InternalLoggerFactory . getInstance ( OioDatagramChannel . class ) ; </a> 0
<a> private static final ChannelMetadata METADATA = new ChannelMetadata ( ChannelBufType . MESSAGE , true ) ; </a> 0
<a> private static final byte [ ] EMPTY_DATA = new byte [ 0 ] ; </a> 0
<a> private final MulticastSocket socket ; </a> 0
<a> private final DatagramChannelConfig config ; </a> 0
<a> private final java . net . DatagramPacket tmpPacket = new java . net . DatagramPacket ( EMPTY_DATA , 0 ) ; </a> 0
<a> private volatile boolean readSuspended ; </a> 0
<a> private static MulticastSocket newSocket ( ) { </a> 0
<a> try { </a> 0
<a> return new MulticastSocket ( null ) ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new ChannelException ( "failed to create a new socket" , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> public OioDatagramChannel ( ) { </a> 0
<a> this ( newSocket ( ) ) ; </a> 0
<a> } </a> 0
<a> public OioDatagramChannel ( MulticastSocket socket ) { </a> 0
<a> this ( null , socket ) ; </a> 0
<a> } </a> 0
<a> public OioDatagramChannel ( Integer id , MulticastSocket socket ) { </a> 0
<a> super ( null , id ) ; </a> 0
<a> boolean success = false ; </a> 0
<a> try { </a> 0
<a> socket . setSoTimeout ( SO_TIMEOUT ) ; </a> 0
<a> socket . setBroadcast ( false ) ; </a> 0
<a> success = true ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> throw new ChannelException ( </a> 0
<a> "Failed to configure the datagram socket timeout." , e ) ; </a> 0
<a> } finally { </a> 0
<a> if ( ! success ) { </a> 0
<a> socket . close ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> this . socket = socket ; </a> 0
<a> config = new DefaultDatagramChannelConfig ( socket ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelMetadata metadata ( ) { </a> 0
<a> return METADATA ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public DatagramChannelConfig config ( ) { </a> 0
<a> return config ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isOpen ( ) { </a> 0
<a> return ! socket . isClosed ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isActive ( ) { </a> 0
<a> return isOpen ( ) && socket . isBound ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isConnected ( ) { </a> 0
<a> return socket . isConnected ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress localAddress0 ( ) { </a> 0
<a> return socket . getLocalSocketAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress remoteAddress0 ( ) { </a> 0
<a> return socket . getRemoteSocketAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doBind ( SocketAddress localAddress ) throws Exception { </a> 0
<a> socket . bind ( localAddress ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doConnect ( SocketAddress remoteAddress , </a> 0
<a> SocketAddress localAddress ) throws Exception { </a> 0
<a> if ( localAddress != null ) { </a> 0
<a> socket . bind ( localAddress ) ; </a> 0
<a> } </a> 0
<a> boolean success = false ; </a> 0
<a> try { </a> 0
<a> socket . connect ( remoteAddress ) ; </a> 0
<a> success = true ; </a> 0
<a> } finally { </a> 0
<a> if ( ! success ) { </a> 0
<a> try { </a> 0
<a> socket . close ( ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> logger . warn ( "Failed to close a socket." , t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDisconnect ( ) throws Exception { </a> 0
<a> socket . disconnect ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doClose ( ) throws Exception { </a> 0
<a> socket . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int doReadMessages ( MessageBuf < Object > buf ) throws Exception { </a> 1
<a> if ( readSuspended ) { </a> 1
<a> try { </a> 1
<a> Thread . sleep ( SO_TIMEOUT ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> } </a> 1
<a> return 0 ; </a> 1
<a> } </a> 1
<a> int packetSize = config ( ) . getReceivePacketSize ( ) ; </a> 1
<a> byte [ ] data = new byte [ packetSize ] ; </a> 0
<a> tmpPacket . setData ( data ) ; </a> 0
<a> try { </a> 0
<a> socket . receive ( tmpPacket ) ; </a> 0
<a> InetSocketAddress remoteAddr = ( InetSocketAddress ) tmpPacket . getSocketAddress ( ) ; </a> 0
<a> if ( remoteAddr == null ) { </a> 1
<a> remoteAddr = remoteAddress ( ) ; </a> 1
<a> } </a> 1
<a> buf . add ( new DatagramPacket ( Unpooled . wrappedBuffer ( </a> 0
<a> data , tmpPacket . getOffset ( ) , tmpPacket . getLength ( ) ) , remoteAddr ) ) ; </a> 0
<a> if ( readSuspended ) { </a> 1
<a> return 0 ; </a> 1
<a> } else { </a> 1
<a> return 1 ; </a> 0
<a> } </a> 1
<a> } catch ( SocketTimeoutException e ) { </a> 0
<a> return 0 ; </a> 0
<a> } catch ( SocketException e ) { </a> 0
<a> if ( ! e . getMessage ( ) . toLowerCase ( Locale . US ) . contains ( "socket closed" ) ) { </a> 0
<a> throw e ; </a> 0
<a> } </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doWriteMessages ( MessageBuf < Object > buf ) throws Exception { </a> 1
<a> DatagramPacket p = ( DatagramPacket ) buf . poll ( ) ; </a> 1
<a> ByteBuf data = p . data ( ) ; </a> 1
<a> int length = data . readableBytes ( ) ; </a> 0
<a> tmpPacket . setSocketAddress ( p . remoteAddress ( ) ) ; </a> 0
<a> if ( data . hasArray ( ) ) { </a> 0
<a> tmpPacket . setData ( data . array ( ) , data . arrayOffset ( ) + data . readerIndex ( ) , length ) ; </a> 0
<a> } else { </a> 0
<a> byte [ ] tmp = new byte [ length ] ; </a> 0
<a> data . getBytes ( data . readerIndex ( ) , tmp ) ; </a> 0
<a> tmpPacket . setData ( tmp ) ; </a> 0
<a> } </a> 0
<a> socket . send ( tmpPacket ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture joinGroup ( InetAddress multicastAddress ) { </a> 0
<a> return joinGroup ( multicastAddress , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture joinGroup ( InetAddress multicastAddress , ChannelFuture future ) { </a> 0
<a> ensureBound ( ) ; </a> 0
<a> try { </a> 0
<a> socket . joinGroup ( multicastAddress ) ; </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> future . setFailure ( e ) ; </a> 0
<a> } </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture joinGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface ) { </a> 0
<a> return joinGroup ( multicastAddress , networkInterface , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture joinGroup ( </a> 0
<a> InetSocketAddress multicastAddress , NetworkInterface networkInterface , </a> 0
<a> ChannelFuture future ) { </a> 0
<a> ensureBound ( ) ; </a> 0
<a> try { </a> 0
<a> socket . joinGroup ( multicastAddress , networkInterface ) ; </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> future . setFailure ( e ) ; </a> 0
<a> } </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture joinGroup ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source ) { </a> 0
<a> return newFailedFuture ( new UnsupportedOperationException ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture joinGroup ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source , </a> 0
<a> ChannelFuture future ) { </a> 0
<a> future . setFailure ( new UnsupportedOperationException ( ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> private void ensureBound ( ) { </a> 0
<a> if ( ! isActive ( ) ) { </a> 0
<a> throw new IllegalStateException ( </a> 0
<a> DatagramChannel . class . getName ( ) + </a> 0
<a> " must be bound to join a group." ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture leaveGroup ( InetAddress multicastAddress ) { </a> 0
<a> return leaveGroup ( multicastAddress , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture leaveGroup ( InetAddress multicastAddress , ChannelFuture future ) { </a> 0
<a> try { </a> 0
<a> socket . leaveGroup ( multicastAddress ) ; </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> future . setFailure ( e ) ; </a> 0
<a> } </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture leaveGroup ( </a> 0
<a> InetSocketAddress multicastAddress , NetworkInterface networkInterface ) { </a> 0
<a> return leaveGroup ( multicastAddress , networkInterface , newFuture ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture leaveGroup ( </a> 0
<a> InetSocketAddress multicastAddress , NetworkInterface networkInterface , </a> 0
<a> ChannelFuture future ) { </a> 0
<a> try { </a> 0
<a> socket . leaveGroup ( multicastAddress , networkInterface ) ; </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> future . setFailure ( e ) ; </a> 0
<a> } </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture leaveGroup ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source ) { </a> 0
<a> return newFailedFuture ( new UnsupportedOperationException ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture leaveGroup ( </a> 0
<a> InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source , </a> 0
<a> ChannelFuture future ) { </a> 0
<a> future . setFailure ( new UnsupportedOperationException ( ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture block ( InetAddress multicastAddress , </a> 0
<a> NetworkInterface networkInterface , InetAddress sourceToBlock ) { </a> 0
<a> return newFailedFuture ( new UnsupportedOperationException ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture block ( InetAddress multicastAddress , </a> 0
<a> NetworkInterface networkInterface , InetAddress sourceToBlock , </a> 0
<a> ChannelFuture future ) { </a> 0
<a> future . setFailure ( new UnsupportedOperationException ( ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture block ( InetAddress multicastAddress , </a> 0
<a> InetAddress sourceToBlock ) { </a> 0
<a> return newFailedFuture ( new UnsupportedOperationException ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture block ( InetAddress multicastAddress , </a> 0
<a> InetAddress sourceToBlock , ChannelFuture future ) { </a> 0
<a> future . setFailure ( new UnsupportedOperationException ( ) ) ; </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected AbstractOioMessageUnsafe newUnsafe ( ) { </a> 0
<a> return new OioDatagramChannelUnsafe ( ) ; </a> 0
<a> } </a> 0
<a> private final class OioDatagramChannelUnsafe extends AbstractOioMessageUnsafe { </a> 0
<a> @ Override </a> 0
<a> public void suspendRead ( ) { </a> 0
<a> readSuspended = true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void resumeRead ( ) { </a> 0
<a> readSuspended = false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . oio ; </a> 0
<a> import io . netty . channel . Channel ; </a> 1
<a> import io . netty . channel . ChannelFuture ; </a> 1
<a> import io . netty . channel . ChannelFutureListener ; </a> 1
<a> import io . netty . channel . SingleThreadEventLoop ; </a> 1
<a> class OioEventLoop extends SingleThreadEventLoop { </a> 1
<a> private final OioEventLoopGroup parent ; </a> 1
<a> private AbstractOioChannel ch ; </a> 1
<a> OioEventLoop ( OioEventLoopGroup parent ) { </a> 1
<a> super ( parent , parent . threadFactory , parent . scheduler ) ; </a> 1
<a> this . parent = parent ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelFuture register ( Channel channel , ChannelFuture future ) { </a> 0
<a> return super . register ( channel , future ) . addListener ( new ChannelFutureListener ( ) { </a> 0
<a> @ Override </a> 1
<a> public void operationComplete ( ChannelFuture future ) throws Exception { </a> 0
<a> if ( future . isSuccess ( ) ) { </a> 0
<a> ch = ( AbstractOioChannel ) future . channel ( ) ; </a> 0
<a> } else { </a> 0
<a> deregister ( ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> protected void run ( ) { </a> 1
<a> for ( ; ; ) { </a> 1
<a> AbstractOioChannel ch = this . ch ; </a> 0
<a> if ( ch == null || ! ch . isActive ( ) ) { </a> 0
<a> Runnable task ; </a> 1
<a> try { </a> 1
<a> task = takeTask ( ) ; </a> 1
<a> task . run ( ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 1
<a> } </a> 1
<a> } else { </a> 1
<a> long startTime = System . nanoTime ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> final Runnable task = pollTask ( ) ; </a> 1
<a> if ( task == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> task . run ( ) ; </a> 1
<a> if ( System . nanoTime ( ) - startTime > AbstractOioChannel . SO_TIMEOUT * 1000000L ) { </a> 1
<a> break ; </a> 1
<a> } </a> 0
<a> } </a> 1
<a> ch . unsafe ( ) . read ( ) ; </a> 1
<a> if ( ! ch . isRegistered ( ) ) { </a> 0
<a> runAllTasks ( ) ; </a> 0
<a> deregister ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 1
<a> if ( isShutdown ( ) ) { </a> 0
<a> if ( ch != null ) { </a> 0
<a> ch . unsafe ( ) . close ( ch . unsafe ( ) . voidFuture ( ) ) ; </a> 0
<a> } </a> 1
<a> if ( peekTask ( ) == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> protected void wakeup ( boolean inEventLoop ) { </a> 1
<a> interruptThread ( ) ; </a> 1
<a> } </a> 0
<a> private void deregister ( ) { </a> 0
<a> ch = null ; </a> 0
<a> parent . activeChildren . remove ( this ) ; </a> 0
<a> parent . idleChildren . add ( this ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . oio ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 1
<a> import io . netty . channel . EventLoop ; </a> 0
<a> import io . netty . channel . EventLoopGroup ; </a> 1
<a> import io . netty . channel . ChannelTaskScheduler ; </a> 0
<a> import java . util . Collections ; </a> 1
<a> import java . util . Queue ; </a> 1
<a> import java . util . Set ; </a> 1
<a> import java . util . concurrent . ConcurrentHashMap ; </a> 1
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 1
<a> import java . util . concurrent . Executors ; </a> 0
<a> import java . util . concurrent . ThreadFactory ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 1
<a> public class OioEventLoopGroup implements EventLoopGroup { </a> 1
<a> private final int maxChannels ; </a> 1
<a> final ChannelTaskScheduler scheduler ; </a> 0
<a> final ThreadFactory threadFactory ; </a> 1
<a> final Set < OioEventLoop > activeChildren = Collections . newSetFromMap ( </a> 1
<a> new ConcurrentHashMap < OioEventLoop , Boolean > ( ) ) ; </a> 1
<a> final Queue < OioEventLoop > idleChildren = new ConcurrentLinkedQueue < OioEventLoop > ( ) ; </a> 1
<a> private final ChannelException tooManyChannels ; </a> 1
<a> public OioEventLoopGroup ( ) { </a> 0
<a> this ( 0 ) ; </a> 0
<a> } </a> 0
<a> public OioEventLoopGroup ( int maxChannels ) { </a> 0
<a> this ( maxChannels , Executors . defaultThreadFactory ( ) ) ; </a> 0
<a> } </a> 0
<a> public OioEventLoopGroup ( int maxChannels , ThreadFactory threadFactory ) { </a> 0
<a> if ( maxChannels < 0 ) { </a> 0
<a> throw new IllegalArgumentException ( String . format ( </a> 0
<a> "maxChannels: %d (expected: >= 0)" , maxChannels ) ) ; </a> 0
<a> } </a> 0
<a> if ( threadFactory == null ) { </a> 0
<a> throw new NullPointerException ( "threadFactory" ) ; </a> 0
<a> } </a> 0
<a> this . maxChannels = maxChannels ; </a> 0
<a> this . threadFactory = threadFactory ; </a> 0
<a> scheduler = new ChannelTaskScheduler ( threadFactory ) ; </a> 0
<a> tooManyChannels = new ChannelException ( "too many channels (max: " + maxChannels + ')' ) ; </a> 1
<a> tooManyChannels . setStackTrace ( new StackTraceElement [ 0 ] ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public EventLoop next ( ) { </a> 1
<a> throw new UnsupportedOperationException ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void shutdown ( ) { </a> 0
<a> scheduler . shutdown ( ) ; </a> 1
<a> for ( EventLoop l : activeChildren ) { </a> 0
<a> l . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> for ( EventLoop l : idleChildren ) { </a> 0
<a> l . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isShutdown ( ) { </a> 1
<a> if ( ! scheduler . isShutdown ( ) ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> for ( EventLoop l : activeChildren ) { </a> 0
<a> if ( ! l . isShutdown ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( EventLoop l : idleChildren ) { </a> 0
<a> if ( ! l . isShutdown ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isTerminated ( ) { </a> 0
<a> if ( ! scheduler . isTerminated ( ) ) { </a> 1
<a> return false ; </a> 1
<a> } </a> 1
<a> for ( EventLoop l : activeChildren ) { </a> 0
<a> if ( ! l . isTerminated ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( EventLoop l : idleChildren ) { </a> 0
<a> if ( ! l . isTerminated ( ) ) { </a> 0
<a> return false ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return true ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean awaitTermination ( long timeout , TimeUnit unit ) </a> 0
<a> throws InterruptedException { </a> 0
<a> long deadline = System . nanoTime ( ) + unit . toNanos ( timeout ) ; </a> 0
<a> for ( ; ; ) { </a> 0
<a> long timeLeft = deadline - System . nanoTime ( ) ; </a> 0
<a> if ( timeLeft <= 0 ) { </a> 0
<a> return isTerminated ( ) ; </a> 0
<a> } </a> 0
<a> if ( scheduler . awaitTermination ( timeLeft , TimeUnit . NANOSECONDS ) ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> for ( EventLoop l : activeChildren ) { </a> 0
<a> for ( ; ; ) { </a> 0
<a> long timeLeft = deadline - System . nanoTime ( ) ; </a> 0
<a> if ( timeLeft <= 0 ) { </a> 0
<a> return isTerminated ( ) ; </a> 0
<a> } </a> 0
<a> if ( l . awaitTermination ( timeLeft , TimeUnit . NANOSECONDS ) ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> for ( EventLoop l : idleChildren ) { </a> 0
<a> for ( ; ; ) { </a> 0
<a> long timeLeft = deadline - System . nanoTime ( ) ; </a> 0
<a> if ( timeLeft <= 0 ) { </a> 0
<a> return isTerminated ( ) ; </a> 0
<a> } </a> 0
<a> if ( l . awaitTermination ( timeLeft , TimeUnit . NANOSECONDS ) ) { </a> 0
<a> break ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> return isTerminated ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture register ( Channel channel ) { </a> 0
<a> if ( channel == null ) { </a> 0
<a> throw new NullPointerException ( "channel" ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> return nextChild ( ) . register ( channel ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 0
<a> return channel . newFailedFuture ( t ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture register ( Channel channel , ChannelFuture future ) { </a> 0
<a> if ( channel == null ) { </a> 0
<a> throw new NullPointerException ( "channel" ) ; </a> 0
<a> } </a> 0
<a> try { </a> 0
<a> return nextChild ( ) . register ( channel , future ) ; </a> 0
<a> } catch ( Throwable t ) { </a> 1
<a> return channel . newFailedFuture ( t ) ; </a> 0
<a> } </a> 1
<a> } </a> 1
<a> private EventLoop nextChild ( ) { </a> 1
<a> OioEventLoop loop = idleChildren . poll ( ) ; </a> 1
<a> if ( loop == null ) { </a> 0
<a> if ( maxChannels > 0 && activeChildren . size ( ) >= maxChannels ) { </a> 0
<a> throw tooManyChannels ; </a> 0
<a> } </a> 0
<a> loop = new OioEventLoop ( this ) ; </a> 1
<a> } </a> 1
<a> activeChildren . add ( loop ) ; </a> 1
<a> return loop ; </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . oio ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . ChannelBufType ; </a> 0
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelException ; </a> 0
<a> import io . netty . channel . ChannelMetadata ; </a> 0
<a> import io . netty . channel . socket . DefaultSocketChannelConfig ; </a> 0
<a> import io . netty . channel . socket . SocketChannel ; </a> 0
<a> import io . netty . channel . socket . SocketChannelConfig ; </a> 0
<a> import io . netty . logging . InternalLogger ; </a> 1
<a> import io . netty . logging . InternalLoggerFactory ; </a> 1
<a> import java . io . IOException ; </a> 0
<a> import java . io . InputStream ; </a> 0
<a> import java . io . OutputStream ; </a> 0
<a> import java . net . Socket ; </a> 0
<a> import java . net . SocketAddress ; </a> 0
<a> import java . net . SocketTimeoutException ; </a> 0
<a> import java . nio . channels . NotYetConnectedException ; </a> 0
<a> public class OioSocketChannel extends AbstractOioByteChannel </a> 0
<a> implements SocketChannel { </a> 0
<a> private static final InternalLogger logger = </a> 0
<a> InternalLoggerFactory . getInstance ( OioSocketChannel . class ) ; </a> 0
<a> private static final ChannelMetadata METADATA = new ChannelMetadata ( ChannelBufType . BYTE , false ) ; </a> 0
<a> private final Socket socket ; </a> 0
<a> private final SocketChannelConfig config ; </a> 0
<a> private InputStream is ; </a> 0
<a> private OutputStream os ; </a> 0
<a> private volatile boolean readSuspended ; </a> 0
<a> public OioSocketChannel ( ) { </a> 0
<a> this ( new Socket ( ) ) ; </a> 0
<a> } </a> 0
<a> public OioSocketChannel ( Socket socket ) { </a> 0
<a> this ( null , null , socket ) ; </a> 0
<a> } </a> 0
<a> public OioSocketChannel ( Channel parent , Integer id , Socket socket ) { </a> 0
<a> super ( parent , id ) ; </a> 0
<a> this . socket = socket ; </a> 0
<a> config = new DefaultSocketChannelConfig ( socket ) ; </a> 0
<a> boolean success = false ; </a> 0
<a> try { </a> 0
<a> if ( socket . isConnected ( ) ) { </a> 0
<a> is = socket . getInputStream ( ) ; </a> 0
<a> os = socket . getOutputStream ( ) ; </a> 0
<a> } </a> 0
<a> socket . setSoTimeout ( SO_TIMEOUT ) ; </a> 0
<a> success = true ; </a> 0
<a> } catch ( Exception e ) { </a> 0
<a> throw new ChannelException ( "failed to initialize a socket" , e ) ; </a> 0
<a> } finally { </a> 0
<a> if ( ! success ) { </a> 0
<a> try { </a> 0
<a> socket . close ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> logger . warn ( "Failed to close a socket." , e ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelMetadata metadata ( ) { </a> 0
<a> return METADATA ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public SocketChannelConfig config ( ) { </a> 0
<a> return config ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isOpen ( ) { </a> 1
<a> return ! socket . isClosed ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public boolean isActive ( ) { </a> 1
<a> return ! socket . isClosed ( ) && socket . isConnected ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 0
<a> protected SocketAddress localAddress0 ( ) { </a> 0
<a> return socket . getLocalSocketAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected SocketAddress remoteAddress0 ( ) { </a> 0
<a> return socket . getRemoteSocketAddress ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doBind ( SocketAddress localAddress ) throws Exception { </a> 0
<a> socket . bind ( localAddress ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doConnect ( SocketAddress remoteAddress , </a> 0
<a> SocketAddress localAddress ) throws Exception { </a> 0
<a> if ( localAddress != null ) { </a> 0
<a> socket . bind ( localAddress ) ; </a> 0
<a> } </a> 0
<a> boolean success = false ; </a> 0
<a> try { </a> 0
<a> socket . connect ( remoteAddress , config ( ) . getConnectTimeoutMillis ( ) ) ; </a> 0
<a> is = socket . getInputStream ( ) ; </a> 0
<a> os = socket . getOutputStream ( ) ; </a> 0
<a> success = true ; </a> 0
<a> } finally { </a> 0
<a> if ( ! success ) { </a> 0
<a> doClose ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doDisconnect ( ) throws Exception { </a> 0
<a> doClose ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doClose ( ) throws Exception { </a> 0
<a> socket . close ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int available ( ) { </a> 0
<a> try { </a> 0
<a> return is . available ( ) ; </a> 0
<a> } catch ( IOException e ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected int doReadBytes ( ByteBuf buf ) throws Exception { </a> 0
<a> if ( socket . isClosed ( ) ) { </a> 0
<a> return - 1 ; </a> 0
<a> } </a> 0
<a> if ( readSuspended ) { </a> 1
<a> try { </a> 1
<a> Thread . sleep ( SO_TIMEOUT ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 1
<a> } </a> 1
<a> return 0 ; </a> 1
<a> } </a> 1
<a> try { </a> 0
<a> int read = buf . writeBytes ( is , buf . writableBytes ( ) ) ; </a> 1
<a> if ( read > 0 && ! readSuspended ) { </a> 1
<a> return read ; </a> 1
<a> } else { </a> 1
<a> return 0 ; </a> 1
<a> } </a> 1
<a> } catch ( SocketTimeoutException e ) { </a> 0
<a> return 0 ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void doWriteBytes ( ByteBuf buf ) throws Exception { </a> 0
<a> OutputStream os = this . os ; </a> 0
<a> if ( os == null ) { </a> 0
<a> throw new NotYetConnectedException ( ) ; </a> 0
<a> } </a> 0
<a> buf . readBytes ( os , buf . readableBytes ( ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected AbstractOioByteUnsafe newUnsafe ( ) { </a> 0
<a> return new OioSocketChannelUnsafe ( ) ; </a> 0
<a> } </a> 0
<a> private final class OioSocketChannelUnsafe extends AbstractOioByteUnsafe { </a> 0
<a> @ Override </a> 1
<a> public void suspendRead ( ) { </a> 1
<a> readSuspended = true ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void resumeRead ( ) { </a> 1
<a> readSuspended = false ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket . oio ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . socket ; </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import static org . easymock . EasyMock . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import java . util . concurrent . ExecutionException ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . TimeoutException ; </a> 0
<a> import org . junit . Before ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class CompleteChannelFutureTest { </a> 0
<a> private final Channel channel = createMock ( Channel . class ) ; </a> 0
<a> private CompleteChannelFuture future ; </a> 0
<a> @ Before </a> 0
<a> public void init ( ) { </a> 0
<a> future = new CompleteChannelFutureImpl ( channel ) ; </a> 0
<a> } </a> 0
<a> @ Test ( expected = NullPointerException . class ) </a> 0
<a> public void shouldDisallowNullChannel ( ) { </a> 0
<a> new CompleteChannelFutureImpl ( null ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void shouldNotDoAnythingOnRemove ( ) throws Exception { </a> 0
<a> ChannelFutureListener l = createStrictMock ( ChannelFutureListener . class ) ; </a> 0
<a> replay ( l ) ; </a> 0
<a> future . removeListener ( l ) ; </a> 0
<a> verify ( l ) ; </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void testConstantProperties ( ) throws InterruptedException { </a> 0
<a> assertSame ( channel , future . channel ( ) ) ; </a> 0
<a> assertTrue ( future . isDone ( ) ) ; </a> 0
<a> assertFalse ( future . cancel ( ) ) ; </a> 0
<a> assertFalse ( future . isCancelled ( ) ) ; </a> 0
<a> assertSame ( future , future . await ( ) ) ; </a> 0
<a> assertTrue ( future . await ( 1 ) ) ; </a> 0
<a> assertTrue ( future . await ( 1 , TimeUnit . NANOSECONDS ) ) ; </a> 0
<a> assertSame ( future , future . awaitUninterruptibly ( ) ) ; </a> 0
<a> assertTrue ( future . awaitUninterruptibly ( 1 ) ) ; </a> 0
<a> assertTrue ( future . awaitUninterruptibly ( 1 , TimeUnit . NANOSECONDS ) ) ; </a> 0
<a> } </a> 0
<a> private static class CompleteChannelFutureImpl extends CompleteChannelFuture { </a> 0
<a> CompleteChannelFutureImpl ( Channel channel ) { </a> 0
<a> super ( channel ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Throwable cause ( ) { </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public boolean isSuccess ( ) { </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture sync ( ) throws InterruptedException { </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public ChannelFuture syncUninterruptibly ( ) { </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Void get ( ) throws InterruptedException , ExecutionException { </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Void get ( long timeout , TimeUnit unit ) throws InterruptedException , </a> 0
<a> ExecutionException , TimeoutException { </a> 0
<a> throw new Error ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import io . netty . channel . ChannelHandler . Sharable ; </a> 0
<a> import io . netty . channel . local . LocalChannel ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class DefaultChannelPipelineTest { </a> 0
<a> @ Test </a> 0
<a> public void testReplaceChannelHandler ( ) { </a> 0
<a> DefaultChannelPipeline pipeline = new DefaultChannelPipeline ( new LocalChannel ( ) ) ; </a> 0
<a> ChannelHandler handler1 = newHandler ( ) ; </a> 0
<a> pipeline . addLast ( "handler1" , handler1 ) ; </a> 0
<a> pipeline . addLast ( "handler2" , handler1 ) ; </a> 0
<a> pipeline . addLast ( "handler3" , handler1 ) ; </a> 0
<a> assertTrue ( pipeline . get ( "handler1" ) == handler1 ) ; </a> 1
<a> assertTrue ( pipeline . get ( "handler2" ) == handler1 ) ; </a> 1
<a> assertTrue ( pipeline . get ( "handler3" ) == handler1 ) ; </a> 1
<a> ChannelHandler newHandler1 = newHandler ( ) ; </a> 0
<a> pipeline . replace ( "handler1" , "handler1" , newHandler1 ) ; </a> 0
<a> assertTrue ( pipeline . get ( "handler1" ) == newHandler1 ) ; </a> 1
<a> ChannelHandler newHandler3 = newHandler ( ) ; </a> 0
<a> pipeline . replace ( "handler3" , "handler3" , newHandler3 ) ; </a> 0
<a> assertTrue ( pipeline . get ( "handler3" ) == newHandler3 ) ; </a> 1
<a> ChannelHandler newHandler2 = newHandler ( ) ; </a> 0
<a> pipeline . replace ( "handler2" , "handler2" , newHandler2 ) ; </a> 0
<a> assertTrue ( pipeline . get ( "handler2" ) == newHandler2 ) ; </a> 1
<a> } </a> 0
<a> private static ChannelHandler newHandler ( ) { </a> 0
<a> return new TestHandler ( ) ; </a> 0
<a> } </a> 0
<a> @ Sharable </a> 0
<a> private static class TestHandler extends ChannelHandlerAdapter { </a> 0
<a> } </a> 1
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import static org . junit . Assert . * ; </a> 1
<a> import java . util . Queue ; </a> 0
<a> import java . util . concurrent . CountDownLatch ; </a> 0
<a> import java . util . concurrent . Executors ; </a> 1
<a> import java . util . concurrent . LinkedBlockingQueue ; </a> 0
<a> import java . util . concurrent . ScheduledFuture ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 0
<a> import java . util . concurrent . atomic . AtomicBoolean ; </a> 1
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> import java . util . concurrent . atomic . AtomicLong ; </a> 0
<a> import org . junit . After ; </a> 0
<a> import org . junit . Before ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class SingleThreadEventLoopTest { </a> 0
<a> private SingleThreadEventLoopImpl loop ; </a> 1
<a> @ Before </a> 0
<a> public void newEventLoop ( ) { </a> 0
<a> loop = new SingleThreadEventLoopImpl ( ) ; </a> 1
<a> } </a> 0
<a> @ After </a> 0
<a> public void stopEventLoop ( ) { </a> 0
<a> if ( ! loop . isShutdown ( ) ) { </a> 1
<a> loop . shutdown ( ) ; </a> 1
<a> } </a> 0
<a> while ( ! loop . isTerminated ( ) ) { </a> 1
<a> try { </a> 0
<a> loop . awaitTermination ( 1 , TimeUnit . DAYS ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> assertEquals ( 1 , loop . cleanedUp . get ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void shutdownBeforeStart ( ) throws Exception { </a> 0
<a> loop . shutdown ( ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void shutdownAfterStart ( ) throws Exception { </a> 0
<a> final AtomicBoolean interrupted = new AtomicBoolean ( ) ; </a> 1
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> loop . execute ( new Runnable ( ) { </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> latch . countDown ( ) ; </a> 0
<a> try { </a> 1
<a> Thread . sleep ( Integer . MAX_VALUE ) ; </a> 1
<a> } catch ( InterruptedException ignored ) { </a> 1
<a> interrupted . set ( true ) ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> latch . await ( ) ; </a> 0
<a> loop . shutdown ( ) ; </a> 1
<a> while ( ! loop . isTerminated ( ) ) { </a> 1
<a> loop . awaitTermination ( 1 , TimeUnit . DAYS ) ; </a> 1
<a> } </a> 0
<a> assertTrue ( interrupted . get ( ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void scheduleTask ( ) throws Exception { </a> 1
<a> long startTime = System . nanoTime ( ) ; </a> 0
<a> final AtomicLong endTime = new AtomicLong ( ) ; </a> 0
<a> loop . schedule ( new Runnable ( ) { </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> endTime . set ( System . nanoTime ( ) ) ; </a> 0
<a> } </a> 0
<a> } , 500 , TimeUnit . MILLISECONDS ) . get ( ) ; </a> 0
<a> assertTrue ( endTime . get ( ) - startTime >= TimeUnit . MILLISECONDS . toNanos ( 500 ) ) ; </a> 1
<a> } </a> 0
<a> @ Test </a> 0
<a> public void scheduleTaskAtFixedRate ( ) throws Exception { </a> 1
<a> final Queue < Long > timestamps = new LinkedBlockingQueue < Long > ( ) ; </a> 0
<a> ScheduledFuture < ? > f = loop . scheduleAtFixedRate ( new Runnable ( ) { </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> timestamps . add ( System . nanoTime ( ) ) ; </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 50 ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , 100 , 100 , TimeUnit . MILLISECONDS ) ; </a> 0
<a> Thread . sleep ( 550 ) ; </a> 0
<a> assertTrue ( f . cancel ( true ) ) ; </a> 0
<a> assertEquals ( 5 , timestamps . size ( ) ) ; </a> 0
<a> Long previousTimestamp = null ; </a> 0
<a> for ( Long t : timestamps ) { </a> 0
<a> if ( previousTimestamp == null ) { </a> 0
<a> previousTimestamp = t ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> assertTrue ( t . longValue ( ) - previousTimestamp . longValue ( ) >= TimeUnit . MILLISECONDS . toNanos ( 90 ) ) ; </a> 0
<a> previousTimestamp = t ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void scheduleLaggyTaskAtFixedRate ( ) throws Exception { </a> 1
<a> final Queue < Long > timestamps = new LinkedBlockingQueue < Long > ( ) ; </a> 0
<a> ScheduledFuture < ? > f = loop . scheduleAtFixedRate ( new Runnable ( ) { </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> boolean empty = timestamps . isEmpty ( ) ; </a> 0
<a> timestamps . add ( System . nanoTime ( ) ) ; </a> 0
<a> if ( empty ) { </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 400 ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , 100 , 100 , TimeUnit . MILLISECONDS ) ; </a> 0
<a> Thread . sleep ( 550 ) ; </a> 0
<a> assertTrue ( f . cancel ( true ) ) ; </a> 0
<a> assertEquals ( 5 , timestamps . size ( ) ) ; </a> 0
<a> int i = 0 ; </a> 0
<a> Long previousTimestamp = null ; </a> 0
<a> for ( Long t : timestamps ) { </a> 0
<a> if ( previousTimestamp == null ) { </a> 0
<a> previousTimestamp = t ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> long diff = t . longValue ( ) - previousTimestamp . longValue ( ) ; </a> 1
<a> if ( i == 0 ) { </a> 0
<a> assertTrue ( diff >= TimeUnit . MILLISECONDS . toNanos ( 400 ) ) ; </a> 1
<a> } else { </a> 0
<a> assertTrue ( diff <= TimeUnit . MILLISECONDS . toNanos ( 10 ) ) ; </a> 1
<a> } </a> 0
<a> previousTimestamp = t ; </a> 0
<a> i ++ ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void scheduleTaskWithFixedDelay ( ) throws Exception { </a> 1
<a> final Queue < Long > timestamps = new LinkedBlockingQueue < Long > ( ) ; </a> 0
<a> ScheduledFuture < ? > f = loop . scheduleWithFixedDelay ( new Runnable ( ) { </a> 1
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> timestamps . add ( System . nanoTime ( ) ) ; </a> 0
<a> try { </a> 0
<a> Thread . sleep ( 50 ) ; </a> 1
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } , 100 , 100 , TimeUnit . MILLISECONDS ) ; </a> 0
<a> Thread . sleep ( 500 ) ; </a> 0
<a> assertTrue ( f . cancel ( true ) ) ; </a> 0
<a> assertEquals ( 3 , timestamps . size ( ) ) ; </a> 0
<a> Long previousTimestamp = null ; </a> 0
<a> for ( Long t : timestamps ) { </a> 0
<a> if ( previousTimestamp == null ) { </a> 0
<a> previousTimestamp = t ; </a> 0
<a> continue ; </a> 0
<a> } </a> 0
<a> assertTrue ( t . longValue ( ) - previousTimestamp . longValue ( ) >= TimeUnit . MILLISECONDS . toNanos ( 150 ) ) ; </a> 0
<a> previousTimestamp = t ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test </a> 0
<a> public void shutdownWithPendingTasks ( ) throws Exception { </a> 0
<a> final int NUM_TASKS = 3 ; </a> 0
<a> final AtomicInteger ranTasks = new AtomicInteger ( ) ; </a> 0
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 0
<a> final Runnable task = new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> ranTasks . incrementAndGet ( ) ; </a> 0
<a> while ( latch . getCount ( ) > 0 ) { </a> 0
<a> try { </a> 0
<a> latch . await ( ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } ; </a> 0
<a> for ( int i = 0 ; i < NUM_TASKS ; i ++ ) { </a> 0
<a> loop . execute ( task ) ; </a> 1
<a> } </a> 0
<a> while ( ranTasks . get ( ) == 0 ) { </a> 0
<a> Thread . yield ( ) ; </a> 0
<a> } </a> 0
<a> assertEquals ( 1 , ranTasks . get ( ) ) ; </a> 0
<a> loop . shutdown ( ) ; </a> 1
<a> latch . countDown ( ) ; </a> 0
<a> while ( ! loop . isTerminated ( ) ) { </a> 1
<a> loop . awaitTermination ( 1 , TimeUnit . DAYS ) ; </a> 1
<a> } </a> 0
<a> assertEquals ( NUM_TASKS , ranTasks . get ( ) ) ; </a> 0
<a> } </a> 0
<a> private static class SingleThreadEventLoopImpl extends SingleThreadEventLoop { </a> 1
<a> final AtomicInteger cleanedUp = new AtomicInteger ( ) ; </a> 0
<a> SingleThreadEventLoopImpl ( ) { </a> 1
<a> super ( null , Executors . defaultThreadFactory ( ) , </a> 1
<a> new ChannelTaskScheduler ( Executors . defaultThreadFactory ( ) ) ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void run ( ) { </a> 0
<a> for ( ; ; ) { </a> 1
<a> Runnable task ; </a> 1
<a> try { </a> 1
<a> task = takeTask ( ) ; </a> 1
<a> task . run ( ) ; </a> 0
<a> } catch ( InterruptedException e ) { </a> 1
<a> } </a> 1
<a> if ( isShutdown ( ) && peekTask ( ) == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void cleanup ( ) { </a> 0
<a> cleanedUp . incrementAndGet ( ) ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> protected void wakeup ( boolean inEventLoop ) { </a> 1
<a> if ( ! inEventLoop && isShutdown ( ) ) { </a> 1
<a> interruptThread ( ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ChannelFuture register ( Channel channel , ChannelFuture future ) { </a> 0
<a> return future ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel ; </a> 0
<a> import static org . easymock . EasyMock . * ; </a> 0
<a> import static org . junit . Assert . * ; </a> 0
<a> import org . junit . Test ; </a> 0
<a> public class SucceededChannelFutureTest { </a> 0
<a> @ Test </a> 0
<a> public void testConstantProperties ( ) { </a> 0
<a> Channel channel = createMock ( Channel . class ) ; </a> 0
<a> SucceededChannelFuture future = new SucceededChannelFuture ( channel ) ; </a> 0
<a> assertTrue ( future . isSuccess ( ) ) ; </a> 0
<a> assertNull ( future . cause ( ) ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . local ; </a> 0
<a> import io . netty . bootstrap . Bootstrap ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 1
<a> import io . netty . channel . Channel ; </a> 1
<a> import io . netty . channel . ChannelHandlerContext ; </a> 1
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . ChannelInitializer ; </a> 1
<a> import io . netty . logging . InternalLogger ; </a> 0
<a> import io . netty . logging . InternalLoggerFactory ; </a> 0
<a> import org . junit . Assert ; </a> 1
<a> import org . junit . Test ; </a> 1
<a> public class LocalChannelRegistryTest { </a> 1
<a> private static final InternalLogger logger = </a> 1
<a> InternalLoggerFactory . getInstance ( LocalChannelRegistryTest . class ) ; </a> 1
<a> private static final String LOCAL_ADDR_ID = "test.id" ; </a> 1
<a> @ Test </a> 1
<a> public void testLocalAddressReuse ( ) throws Exception { </a> 1
<a> for ( int i = 0 ; i < 2 ; i ++ ) { </a> 1
<a> LocalAddress addr = new LocalAddress ( LOCAL_ADDR_ID ) ; </a> 1
<a> Bootstrap cb = new Bootstrap ( ) ; </a> 0
<a> ServerBootstrap sb = new ServerBootstrap ( ) ; </a> 1
<a> cb . group ( new LocalEventLoopGroup ( ) ) </a> 0
<a> . channel ( new LocalChannel ( ) ) </a> 0
<a> . remoteAddress ( addr ) </a> 0
<a> . handler ( new TestHandler ( ) ) ; </a> 1
<a> sb . group ( new LocalEventLoopGroup ( ) ) </a> 0
<a> . channel ( new LocalServerChannel ( ) ) </a> 0
<a> . localAddress ( addr ) </a> 0
<a> . childHandler ( new ChannelInitializer < LocalChannel > ( ) { </a> 1
<a> @ Override </a> 1
<a> public void initChannel ( LocalChannel ch ) throws Exception { </a> 1
<a> ch . pipeline ( ) . addLast ( new TestHandler ( ) ) ; </a> 1
<a> } </a> 1
<a> } ) ; </a> 1
<a> Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; </a> 0
<a> Channel cc = cb . connect ( ) . sync ( ) . channel ( ) ; </a> 0
<a> cc . pipeline ( ) . inboundMessageBuffer ( ) . add ( "Hello, World" ) ; </a> 1
<a> cc . pipeline ( ) . fireInboundBufferUpdated ( ) ; </a> 1
<a> cc . close ( ) . sync ( ) ; </a> 1
<a> sb . shutdown ( ) ; </a> 0
<a> cb . shutdown ( ) ; </a> 0
<a> sc . closeFuture ( ) . sync ( ) ; </a> 1
<a> Assert . assertTrue ( String . format ( </a> 1
<a> "Expected null, got channel '%s' for local address '%s'" , </a> 1
<a> LocalChannelRegistry . get ( addr ) , addr ) , </a> 1
<a> LocalChannelRegistry . get ( addr ) == null ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> static class TestHandler extends ChannelInboundMessageHandlerAdapter < String > { </a> 1
<a> @ Override </a> 1
<a> public void messageReceived ( ChannelHandlerContext ctx , String msg ) throws Exception { </a> 1
<a> logger . info ( String . format ( "Received mesage: %s" , msg ) ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> } </a> 1
<END_FILE>
<START_FILE>
<a> </a> 0
<a> package io . netty . channel . local ; </a> 0
<a> import io . netty . bootstrap . ServerBootstrap ; </a> 0
<a> import io . netty . buffer . ByteBuf ; </a> 0
<a> import io . netty . buffer . MessageBuf ; </a> 1
<a> import io . netty . buffer . Unpooled ; </a> 1
<a> import io . netty . channel . Channel ; </a> 0
<a> import io . netty . channel . ChannelFuture ; </a> 0
<a> import io . netty . channel . ChannelHandlerAdapter ; </a> 0
<a> import io . netty . channel . ChannelHandlerContext ; </a> 0
<a> import io . netty . channel . ChannelInboundByteHandler ; </a> 1
<a> import io . netty . channel . ChannelInboundMessageHandler ; </a> 1
<a> import io . netty . channel . ChannelInboundMessageHandlerAdapter ; </a> 1
<a> import io . netty . channel . ChannelInitializer ; </a> 0
<a> import io . netty . channel . ChannelOutboundByteHandler ; </a> 1
<a> import io . netty . channel . ChannelOutboundMessageHandler ; </a> 1
<a> import io . netty . channel . DefaultEventExecutorGroup ; </a> 0
<a> import io . netty . channel . EventExecutorGroup ; </a> 0
<a> import io . netty . channel . EventLoopGroup ; </a> 0
<a> import java . util . HashSet ; </a> 1
<a> import java . util . Queue ; </a> 0
<a> import java . util . Set ; </a> 1
<a> import java . util . concurrent . ConcurrentLinkedQueue ; </a> 0
<a> import java . util . concurrent . CountDownLatch ; </a> 1
<a> import java . util . concurrent . ThreadFactory ; </a> 0
<a> import java . util . concurrent . TimeUnit ; </a> 1
<a> import java . util . concurrent . atomic . AtomicInteger ; </a> 0
<a> import java . util . concurrent . atomic . AtomicReference ; </a> 0
<a> import org . junit . AfterClass ; </a> 1
<a> import org . junit . Assert ; </a> 1
<a> import org . junit . BeforeClass ; </a> 1
<a> import org . junit . Test ; </a> 0
<a> public class LocalTransportThreadModelTest { </a> 0
<a> private static ServerBootstrap sb ; </a> 0
<a> private static LocalAddress ADDR ; </a> 1
<a> @ BeforeClass </a> 0
<a> public static void init ( ) { </a> 0
<a> sb = new ServerBootstrap ( ) ; </a> 0
<a> sb . group ( new LocalEventLoopGroup ( ) ) </a> 0
<a> . channel ( new LocalServerChannel ( ) ) </a> 0
<a> . localAddress ( LocalAddress . ANY ) </a> 0
<a> . childHandler ( new ChannelInitializer < LocalChannel > ( ) { </a> 0
<a> @ Override </a> 0
<a> public void initChannel ( LocalChannel ch ) throws Exception { </a> 0
<a> ch . pipeline ( ) . addLast ( new ChannelInboundMessageHandlerAdapter < Object > ( ) { </a> 1
<a> @ Override </a> 0
<a> public void messageReceived ( ChannelHandlerContext ctx , Object msg ) { </a> 1
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> ADDR = ( LocalAddress ) sb . bind ( ) . syncUninterruptibly ( ) . channel ( ) . localAddress ( ) ; </a> 1
<a> } </a> 0
<a> @ AfterClass </a> 0
<a> public static void destroy ( ) { </a> 1
<a> sb . shutdown ( ) ; </a> 0
<a> } </a> 0
<a> @ Test ( timeout = 5000 ) </a> 1
<a> public void testStagedExecutionMultiple ( ) throws Throwable { </a> 0
<a> for ( int i = 0 ; i < 10 ; i ++ ) { </a> 0
<a> testStagedExecution ( ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> @ Test ( timeout = 5000 ) </a> 0
<a> public void testStagedExecution ( ) throws Throwable { </a> 0
<a> EventLoopGroup l = new LocalEventLoopGroup ( 4 , new PrefixThreadFactory ( "l" ) ) ; </a> 0
<a> EventExecutorGroup e1 = new DefaultEventExecutorGroup ( 4 , new PrefixThreadFactory ( "e1" ) ) ; </a> 0
<a> EventExecutorGroup e2 = new DefaultEventExecutorGroup ( 4 , new PrefixThreadFactory ( "e2" ) ) ; </a> 0
<a> ThreadNameAuditor h1 = new ThreadNameAuditor ( ) ; </a> 0
<a> ThreadNameAuditor h2 = new ThreadNameAuditor ( ) ; </a> 0
<a> ThreadNameAuditor h3 = new ThreadNameAuditor ( ) ; </a> 1
<a> Channel ch = new LocalChannel ( ) ; </a> 0
<a> ch . pipeline ( ) . addLast ( h1 ) ; </a> 0
<a> ch . pipeline ( ) . addLast ( e1 , h2 ) ; </a> 0
<a> ch . pipeline ( ) . addLast ( e2 , h3 ) ; </a> 0
<a> l . register ( ch ) . sync ( ) . channel ( ) . connect ( ADDR ) . sync ( ) ; </a> 1
<a> ch . pipeline ( ) . fireInboundBufferUpdated ( ) ; </a> 1
<a> ch . pipeline ( ) . context ( h1 ) . fireInboundBufferUpdated ( ) ; </a> 1
<a> ch . pipeline ( ) . context ( h2 ) . fireInboundBufferUpdated ( ) ; </a> 1
<a> ch . pipeline ( ) . context ( h3 ) . fireInboundBufferUpdated ( ) ; </a> 1
<a> ch . pipeline ( ) . flush ( ) ; </a> 1
<a> ch . pipeline ( ) . context ( h3 ) . flush ( ) ; </a> 1
<a> ch . pipeline ( ) . context ( h2 ) . flush ( ) ; </a> 1
<a> ch . pipeline ( ) . context ( h1 ) . flush ( ) . sync ( ) ; </a> 1
<a> while ( h1 . outboundThreadNames . size ( ) < 3 || h3 . inboundThreadNames . size ( ) < 3 ) { </a> 0
<a> if ( h1 . exception . get ( ) != null ) { </a> 0
<a> throw h1 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( h2 . exception . get ( ) != null ) { </a> 0
<a> throw h2 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( h3 . exception . get ( ) != null ) { </a> 0
<a> throw h3 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> Thread . sleep ( 10 ) ; </a> 0
<a> } </a> 0
<a> String currentName = Thread . currentThread ( ) . getName ( ) ; </a> 0
<a> try { </a> 0
<a> Assert . assertFalse ( h1 . inboundThreadNames . contains ( currentName ) ) ; </a> 0
<a> Assert . assertFalse ( h2 . inboundThreadNames . contains ( currentName ) ) ; </a> 0
<a> Assert . assertFalse ( h3 . inboundThreadNames . contains ( currentName ) ) ; </a> 0
<a> Assert . assertFalse ( h1 . outboundThreadNames . contains ( currentName ) ) ; </a> 0
<a> Assert . assertFalse ( h2 . outboundThreadNames . contains ( currentName ) ) ; </a> 0
<a> Assert . assertFalse ( h3 . outboundThreadNames . contains ( currentName ) ) ; </a> 0
<a> for ( String name : h1 . inboundThreadNames ) { </a> 0
<a> Assert . assertTrue ( name . startsWith ( "l-" ) ) ; </a> 0
<a> } </a> 0
<a> for ( String name : h2 . inboundThreadNames ) { </a> 0
<a> Assert . assertTrue ( name . startsWith ( "e1-" ) ) ; </a> 0
<a> } </a> 0
<a> for ( String name : h3 . inboundThreadNames ) { </a> 0
<a> Assert . assertTrue ( name . startsWith ( "e2-" ) ) ; </a> 0
<a> } </a> 0
<a> for ( String name : h1 . outboundThreadNames ) { </a> 0
<a> Assert . assertTrue ( name . startsWith ( "l-" ) ) ; </a> 0
<a> } </a> 0
<a> for ( String name : h2 . outboundThreadNames ) { </a> 0
<a> Assert . assertTrue ( name . startsWith ( "e1-" ) ) ; </a> 0
<a> } </a> 0
<a> for ( String name : h3 . outboundThreadNames ) { </a> 0
<a> Assert . assertTrue ( name . startsWith ( "e2-" ) ) ; </a> 0
<a> } </a> 0
<a> Set < String > names = new HashSet < String > ( ) ; </a> 1
<a> names . addAll ( h1 . inboundThreadNames ) ; </a> 1
<a> names . addAll ( h1 . outboundThreadNames ) ; </a> 1
<a> Assert . assertEquals ( 1 , names . size ( ) ) ; </a> 1
<a> names . clear ( ) ; </a> 1
<a> names . addAll ( h2 . inboundThreadNames ) ; </a> 1
<a> names . addAll ( h2 . outboundThreadNames ) ; </a> 1
<a> Assert . assertEquals ( 1 , names . size ( ) ) ; </a> 1
<a> names . clear ( ) ; </a> 1
<a> names . addAll ( h3 . inboundThreadNames ) ; </a> 1
<a> names . addAll ( h3 . outboundThreadNames ) ; </a> 1
<a> Assert . assertEquals ( 1 , names . size ( ) ) ; </a> 1
<a> Assert . assertEquals ( 1 , h1 . inboundThreadNames . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( 2 , h2 . inboundThreadNames . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( 3 , h3 . inboundThreadNames . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( 3 , h1 . outboundThreadNames . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( 2 , h2 . outboundThreadNames . size ( ) ) ; </a> 0
<a> Assert . assertEquals ( 1 , h3 . outboundThreadNames . size ( ) ) ; </a> 0
<a> } catch ( AssertionError e ) { </a> 0
<a> System . out . println ( "H1I: " + h1 . inboundThreadNames ) ; </a> 0
<a> System . out . println ( "H2I: " + h2 . inboundThreadNames ) ; </a> 0
<a> System . out . println ( "H3I: " + h3 . inboundThreadNames ) ; </a> 0
<a> System . out . println ( "H1O: " + h1 . outboundThreadNames ) ; </a> 0
<a> System . out . println ( "H2O: " + h2 . outboundThreadNames ) ; </a> 0
<a> System . out . println ( "H3O: " + h3 . outboundThreadNames ) ; </a> 0
<a> throw e ; </a> 0
<a> } finally { </a> 0
<a> l . shutdown ( ) ; </a> 1
<a> l . awaitTermination ( 5 , TimeUnit . SECONDS ) ; </a> 0
<a> e1 . shutdown ( ) ; </a> 1
<a> e1 . awaitTermination ( 5 , TimeUnit . SECONDS ) ; </a> 0
<a> e2 . shutdown ( ) ; </a> 1
<a> e2 . awaitTermination ( 5 , TimeUnit . SECONDS ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Test ( timeout = 30000 ) </a> 0
<a> public void testConcurrentMessageBufferAccess ( ) throws Throwable { </a> 0
<a> EventLoopGroup l = new LocalEventLoopGroup ( 4 , new PrefixThreadFactory ( "l" ) ) ; </a> 0
<a> EventExecutorGroup e1 = new DefaultEventExecutorGroup ( 4 , new PrefixThreadFactory ( "e1" ) ) ; </a> 0
<a> EventExecutorGroup e2 = new DefaultEventExecutorGroup ( 4 , new PrefixThreadFactory ( "e2" ) ) ; </a> 0
<a> EventExecutorGroup e3 = new DefaultEventExecutorGroup ( 4 , new PrefixThreadFactory ( "e3" ) ) ; </a> 0
<a> EventExecutorGroup e4 = new DefaultEventExecutorGroup ( 4 , new PrefixThreadFactory ( "e4" ) ) ; </a> 0
<a> EventExecutorGroup e5 = new DefaultEventExecutorGroup ( 4 , new PrefixThreadFactory ( "e5" ) ) ; </a> 0
<a> try { </a> 0
<a> final MessageForwarder1 h1 = new MessageForwarder1 ( ) ; </a> 0
<a> final MessageForwarder2 h2 = new MessageForwarder2 ( ) ; </a> 0
<a> final MessageForwarder3 h3 = new MessageForwarder3 ( ) ; </a> 1
<a> final MessageForwarder1 h4 = new MessageForwarder1 ( ) ; </a> 0
<a> final MessageForwarder2 h5 = new MessageForwarder2 ( ) ; </a> 0
<a> final MessageDiscarder h6 = new MessageDiscarder ( ) ; </a> 0
<a> final Channel ch = new LocalChannel ( ) ; </a> 0
<a> ch . pipeline ( ) . addLast ( h1 ) </a> 0
<a> . addLast ( e1 , h2 ) </a> 0
<a> . addLast ( e2 , h3 ) </a> 0
<a> . addLast ( e3 , h4 ) </a> 0
<a> . addLast ( e4 , h5 ) </a> 0
<a> . addLast ( e5 , h6 ) ; </a> 0
<a> l . register ( ch ) . sync ( ) . channel ( ) . connect ( ADDR ) . sync ( ) ; </a> 1
<a> final int ROUNDS = 1024 ; </a> 0
<a> final int ELEMS_PER_ROUNDS = 8192 ; </a> 0
<a> final int TOTAL_CNT = ROUNDS * ELEMS_PER_ROUNDS ; </a> 0
<a> for ( int i = 0 ; i < TOTAL_CNT ; ) { </a> 0
<a> final int start = i ; </a> 0
<a> final int end = i + ELEMS_PER_ROUNDS ; </a> 0
<a> i = end ; </a> 0
<a> ch . eventLoop ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> MessageBuf < Object > buf = ch . pipeline ( ) . inboundMessageBuffer ( ) ; </a> 1
<a> for ( int j = start ; j < end ; j ++ ) { </a> 0
<a> buf . add ( Integer . valueOf ( j ) ) ; </a> 1
<a> } </a> 0
<a> ch . pipeline ( ) . fireInboundBufferUpdated ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> while ( h1 . inCnt < TOTAL_CNT || h2 . inCnt < TOTAL_CNT || h3 . inCnt < TOTAL_CNT || </a> 0
<a> h4 . inCnt < TOTAL_CNT || h5 . inCnt < TOTAL_CNT || h6 . inCnt < TOTAL_CNT ) { </a> 0
<a> if ( h1 . exception . get ( ) != null ) { </a> 0
<a> throw h1 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( h2 . exception . get ( ) != null ) { </a> 0
<a> throw h2 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( h3 . exception . get ( ) != null ) { </a> 0
<a> throw h3 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( h4 . exception . get ( ) != null ) { </a> 0
<a> throw h4 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( h5 . exception . get ( ) != null ) { </a> 0
<a> throw h5 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( h6 . exception . get ( ) != null ) { </a> 0
<a> throw h6 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> Thread . sleep ( 10 ) ; </a> 0
<a> } </a> 0
<a> for ( int i = 0 ; i < TOTAL_CNT ; ) { </a> 0
<a> final int start = i ; </a> 0
<a> final int end = i + ELEMS_PER_ROUNDS ; </a> 0
<a> i = end ; </a> 0
<a> ch . pipeline ( ) . context ( h6 ) . executor ( ) . execute ( new Runnable ( ) { </a> 0
<a> @ Override </a> 0
<a> public void run ( ) { </a> 0
<a> MessageBuf < Object > buf = ch . pipeline ( ) . outboundMessageBuffer ( ) ; </a> 1
<a> for ( int j = start ; j < end ; j ++ ) { </a> 0
<a> buf . add ( Integer . valueOf ( j ) ) ; </a> 1
<a> } </a> 0
<a> ch . pipeline ( ) . flush ( ) ; </a> 0
<a> } </a> 0
<a> } ) ; </a> 0
<a> } </a> 0
<a> while ( h1 . outCnt < TOTAL_CNT || h2 . outCnt < TOTAL_CNT || h3 . outCnt < TOTAL_CNT || </a> 0
<a> h4 . outCnt < TOTAL_CNT || h5 . outCnt < TOTAL_CNT || h6 . outCnt < TOTAL_CNT ) { </a> 0
<a> if ( h1 . exception . get ( ) != null ) { </a> 0
<a> throw h1 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( h2 . exception . get ( ) != null ) { </a> 0
<a> throw h2 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( h3 . exception . get ( ) != null ) { </a> 0
<a> throw h3 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( h4 . exception . get ( ) != null ) { </a> 0
<a> throw h4 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( h5 . exception . get ( ) != null ) { </a> 0
<a> throw h5 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> if ( h6 . exception . get ( ) != null ) { </a> 0
<a> throw h6 . exception . get ( ) ; </a> 0
<a> } </a> 0
<a> Thread . sleep ( 10 ) ; </a> 0
<a> } </a> 0
<a> ch . close ( ) . sync ( ) ; </a> 0
<a> h6 . latch . await ( ) ; </a> 1
<a> } finally { </a> 0
<a> l . shutdown ( ) ; </a> 1
<a> e1 . shutdown ( ) ; </a> 1
<a> e2 . shutdown ( ) ; </a> 1
<a> e3 . shutdown ( ) ; </a> 1
<a> e4 . shutdown ( ) ; </a> 1
<a> e5 . shutdown ( ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> private static class ThreadNameAuditor </a> 1
<a> extends ChannelHandlerAdapter </a> 0
<a> implements ChannelInboundMessageHandler < Object > , </a> 1
<a> ChannelOutboundMessageHandler < Object > { </a> 1
<a> private final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 0
<a> private final Queue < String > inboundThreadNames = new ConcurrentLinkedQueue < String > ( ) ; </a> 0
<a> private final Queue < String > outboundThreadNames = new ConcurrentLinkedQueue < String > ( ) ; </a> 0
<a> @ Override </a> 0
<a> public MessageBuf < Object > newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . messageBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public MessageBuf < Object > newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return Unpooled . messageBuffer ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( </a> 1
<a> ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> ctx . inboundMessageBuffer ( ) . clear ( ) ; </a> 1
<a> inboundThreadNames . add ( Thread . currentThread ( ) . getName ( ) ) ; </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void flush ( ChannelHandlerContext ctx , </a> 1
<a> ChannelFuture future ) throws Exception { </a> 0
<a> ctx . outboundMessageBuffer ( ) . clear ( ) ; </a> 1
<a> outboundThreadNames . add ( Thread . currentThread ( ) . getName ( ) ) ; </a> 0
<a> ctx . flush ( future ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> exception . compareAndSet ( null , cause ) ; </a> 0
<a> System . err . print ( "[" + Thread . currentThread ( ) . getName ( ) + "] " ) ; </a> 0
<a> cause . printStackTrace ( ) ; </a> 0
<a> super . exceptionCaught ( ctx , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class MessageForwarder1 </a> 0
<a> extends ChannelHandlerAdapter </a> 0
<a> implements ChannelInboundMessageHandler < Integer > , ChannelOutboundByteHandler { </a> 1
<a> private final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 0
<a> private volatile int inCnt ; </a> 0
<a> private volatile int outCnt ; </a> 0
<a> private volatile Thread t ; </a> 0
<a> @ Override </a> 0
<a> public MessageBuf < Integer > newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . messageBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public ByteBuf newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . buffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( </a> 1
<a> ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> Thread t = this . t ; </a> 0
<a> if ( t == null ) { </a> 0
<a> this . t = Thread . currentThread ( ) ; </a> 0
<a> } else { </a> 0
<a> Assert . assertSame ( t , Thread . currentThread ( ) ) ; </a> 1
<a> } </a> 0
<a> MessageBuf < Integer > in = ctx . inboundMessageBuffer ( ) ; </a> 1
<a> ByteBuf out = ctx . nextInboundByteBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> Integer msg = in . poll ( ) ; </a> 1
<a> if ( msg == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> int expected = inCnt ++ ; </a> 0
<a> Assert . assertEquals ( expected , msg . intValue ( ) ) ; </a> 1
<a> out . writeInt ( msg ) ; </a> 1
<a> } </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( ChannelHandlerContext ctx , </a> 1
<a> ChannelFuture future ) throws Exception { </a> 0
<a> Assert . assertSame ( t , Thread . currentThread ( ) ) ; </a> 1
<a> boolean swallow = this == ctx . pipeline ( ) . first ( ) ; </a> 0
<a> ByteBuf in = ctx . outboundByteBuffer ( ) ; </a> 1
<a> MessageBuf < Object > out = ctx . nextOutboundMessageBuffer ( ) ; </a> 1
<a> while ( in . readableBytes ( ) >= 4 ) { </a> 1
<a> int msg = in . readInt ( ) ; </a> 1
<a> int expected = outCnt ++ ; </a> 0
<a> Assert . assertEquals ( expected , msg ) ; </a> 1
<a> if ( ! swallow ) { </a> 0
<a> out . add ( msg ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> in . unsafe ( ) . discardSomeReadBytes ( ) ; </a> 1
<a> if ( swallow ) { </a> 0
<a> future . setSuccess ( ) ; </a> 0
<a> } else { </a> 0
<a> ctx . flush ( future ) ; </a> 1
<a> } </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> exception . compareAndSet ( null , cause ) ; </a> 0
<a> super . exceptionCaught ( ctx , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class MessageForwarder2 </a> 1
<a> extends ChannelHandlerAdapter </a> 0
<a> implements ChannelInboundByteHandler , ChannelOutboundMessageHandler < Integer > { </a> 1
<a> private final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 0
<a> private volatile int inCnt ; </a> 0
<a> private volatile int outCnt ; </a> 0
<a> private volatile Thread t ; </a> 0
<a> @ Override </a> 0
<a> public ByteBuf newInboundBuffer ( </a> 1
<a> ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . buffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public MessageBuf < Integer > newOutboundBuffer ( </a> 1
<a> ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . messageBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( </a> 1
<a> ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> Thread t = this . t ; </a> 0
<a> if ( t == null ) { </a> 0
<a> this . t = Thread . currentThread ( ) ; </a> 0
<a> } else { </a> 0
<a> Assert . assertSame ( t , Thread . currentThread ( ) ) ; </a> 1
<a> } </a> 0
<a> ByteBuf in = ctx . inboundByteBuffer ( ) ; </a> 1
<a> MessageBuf < Object > out = ctx . nextInboundMessageBuffer ( ) ; </a> 1
<a> while ( in . readableBytes ( ) >= 4 ) { </a> 1
<a> int msg = in . readInt ( ) ; </a> 1
<a> int expected = inCnt ++ ; </a> 0
<a> Assert . assertEquals ( expected , msg ) ; </a> 1
<a> out . add ( msg ) ; </a> 1
<a> } </a> 0
<a> in . discardReadBytes ( ) ; </a> 1
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 1
<a> public void flush ( ChannelHandlerContext ctx , </a> 1
<a> ChannelFuture future ) throws Exception { </a> 0
<a> Assert . assertSame ( t , Thread . currentThread ( ) ) ; </a> 1
<a> MessageBuf < Integer > in = ctx . outboundMessageBuffer ( ) ; </a> 1
<a> ByteBuf out = ctx . nextOutboundByteBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> Integer msg = in . poll ( ) ; </a> 1
<a> if ( msg == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> int expected = outCnt ++ ; </a> 0
<a> Assert . assertEquals ( expected , msg . intValue ( ) ) ; </a> 1
<a> out . writeInt ( msg ) ; </a> 1
<a> } </a> 0
<a> ctx . flush ( future ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> exception . compareAndSet ( null , cause ) ; </a> 0
<a> super . exceptionCaught ( ctx , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class MessageForwarder3 </a> 1
<a> extends ChannelHandlerAdapter </a> 0
<a> implements ChannelInboundMessageHandler < Object > , ChannelOutboundMessageHandler < Object > { </a> 1
<a> private final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 0
<a> private volatile int inCnt ; </a> 0
<a> private volatile int outCnt ; </a> 0
<a> private volatile Thread t ; </a> 0
<a> @ Override </a> 0
<a> public MessageBuf < Object > newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . messageBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public MessageBuf < Object > newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return Unpooled . messageBuffer ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> Thread t = this . t ; </a> 0
<a> if ( t == null ) { </a> 0
<a> this . t = Thread . currentThread ( ) ; </a> 0
<a> } else { </a> 0
<a> Assert . assertSame ( t , Thread . currentThread ( ) ) ; </a> 1
<a> } </a> 0
<a> MessageBuf < Object > in = ctx . inboundMessageBuffer ( ) ; </a> 1
<a> MessageBuf < Object > out = ctx . nextInboundMessageBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> Object msg = in . poll ( ) ; </a> 1
<a> if ( msg == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> int expected = inCnt ++ ; </a> 0
<a> Assert . assertEquals ( expected , msg ) ; </a> 1
<a> out . add ( msg ) ; </a> 1
<a> } </a> 0
<a> ctx . fireInboundBufferUpdated ( ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void flush ( ChannelHandlerContext ctx , </a> 1
<a> ChannelFuture future ) throws Exception { </a> 0
<a> Assert . assertSame ( t , Thread . currentThread ( ) ) ; </a> 1
<a> MessageBuf < Object > in = ctx . outboundMessageBuffer ( ) ; </a> 1
<a> MessageBuf < Object > out = ctx . nextOutboundMessageBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> Object msg = in . poll ( ) ; </a> 1
<a> if ( msg == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> int expected = outCnt ++ ; </a> 0
<a> Assert . assertEquals ( expected , msg ) ; </a> 1
<a> out . add ( msg ) ; </a> 1
<a> } </a> 0
<a> ctx . flush ( future ) ; </a> 1
<a> } </a> 0
<a> @ Override </a> 0
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 0
<a> exception . compareAndSet ( null , cause ) ; </a> 0
<a> System . err . print ( "[" + Thread . currentThread ( ) . getName ( ) + "] " ) ; </a> 0
<a> cause . printStackTrace ( ) ; </a> 0
<a> super . exceptionCaught ( ctx , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class MessageDiscarder </a> 1
<a> extends ChannelHandlerAdapter </a> 0
<a> implements ChannelInboundMessageHandler < Object > , ChannelOutboundMessageHandler < Object > { </a> 1
<a> private final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; </a> 0
<a> private volatile int inCnt ; </a> 0
<a> private volatile int outCnt ; </a> 0
<a> private volatile Thread t ; </a> 0
<a> final CountDownLatch latch = new CountDownLatch ( 1 ) ; </a> 1
<a> @ Override </a> 0
<a> public MessageBuf < Object > newInboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> return Unpooled . messageBuffer ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public MessageBuf < Object > newOutboundBuffer ( ChannelHandlerContext ctx ) throws Exception { </a> 0
<a> return Unpooled . messageBuffer ( ) ; </a> 0
<a> } </a> 1
<a> @ Override </a> 1
<a> public void inboundBufferUpdated ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> Thread t = this . t ; </a> 0
<a> if ( t == null ) { </a> 0
<a> this . t = Thread . currentThread ( ) ; </a> 0
<a> } else { </a> 0
<a> Assert . assertSame ( t , Thread . currentThread ( ) ) ; </a> 1
<a> } </a> 0
<a> MessageBuf < Object > in = ctx . inboundMessageBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> Object msg = in . poll ( ) ; </a> 1
<a> if ( msg == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> int expected = inCnt ++ ; </a> 0
<a> Assert . assertEquals ( expected , msg ) ; </a> 1
<a> } </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void flush ( ChannelHandlerContext ctx , </a> 1
<a> ChannelFuture future ) throws Exception { </a> 0
<a> Assert . assertSame ( t , Thread . currentThread ( ) ) ; </a> 1
<a> MessageBuf < Object > in = ctx . outboundMessageBuffer ( ) ; </a> 1
<a> MessageBuf < Object > out = ctx . nextOutboundMessageBuffer ( ) ; </a> 1
<a> for ( ; ; ) { </a> 1
<a> Object msg = in . poll ( ) ; </a> 1
<a> if ( msg == null ) { </a> 1
<a> break ; </a> 1
<a> } </a> 1
<a> int expected = outCnt ++ ; </a> 0
<a> Assert . assertEquals ( expected , msg ) ; </a> 1
<a> out . add ( msg ) ; </a> 1
<a> } </a> 0
<a> ctx . flush ( future ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { </a> 1
<a> latch . countDown ( ) ; </a> 1
<a> } </a> 1
<a> @ Override </a> 1
<a> public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { </a> 1
<a> exception . compareAndSet ( null , cause ) ; </a> 0
<a> super . exceptionCaught ( ctx , cause ) ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> private static class PrefixThreadFactory implements ThreadFactory { </a> 0
<a> private final String prefix ; </a> 0
<a> private final AtomicInteger id = new AtomicInteger ( ) ; </a> 0
<a> public PrefixThreadFactory ( String prefix ) { </a> 0
<a> this . prefix = prefix ; </a> 0
<a> } </a> 0
<a> @ Override </a> 0
<a> public Thread newThread ( Runnable r ) { </a> 0
<a> Thread t = new Thread ( r ) ; </a> 0
<a> t . setName ( prefix + '-' + id . incrementAndGet ( ) ) ; </a> 0
<a> t . setDaemon ( true ) ; </a> 0
<a> return t ; </a> 0
<a> } </a> 0
<a> } </a> 0
<a> } </a> 0
<END_FILE>
